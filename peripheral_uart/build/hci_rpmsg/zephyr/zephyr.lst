
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

01000000 <_vector_table>:
 1000000:	210097e8 	.word	0x210097e8
 1000004:	01005031 	.word	0x01005031
 1000008:	0101692d 	.word	0x0101692d
 100000c:	01005061 	.word	0x01005061
 1000010:	01005061 	.word	0x01005061
 1000014:	01005061 	.word	0x01005061
 1000018:	01005061 	.word	0x01005061
	...
 100002c:	01004ded 	.word	0x01004ded
 1000030:	01005061 	.word	0x01005061
 1000034:	00000000 	.word	0x00000000
 1000038:	01004da5 	.word	0x01004da5
 100003c:	01015b39 	.word	0x01015b39

01000040 <_irq_vector_table>:
 1000040:	01004ff1 01004ff1 01004ff1 01004ff1     .O...O...O...O..
 1000050:	01004ff1 01004ff1 01004ff1 01004ff1     .O...O...O...O..
 1000060:	0100fbb1 01004ff1 01004ff1 01004ff1     .....O...O...O..
 1000070:	01004ff1 01004ff1 01004ff1 01004ff1     .O...O...O...O..
 1000080:	01004ff1 01004ff1 01004ff1 01004ff1     .O...O...O...O..
 1000090:	01004ff1 01004ff1 01004ff1 01004ff1     .O...O...O...O..
 10000a0:	01004ff1 01004ff1 01004ff1 01004ff1     .O...O...O...O..
 10000b0:	01004ff1 01004ff1                       .O...O..

Disassembly of section text:

010000b8 <__aeabi_uldivmod>:
 10000b8:	b953      	cbnz	r3, 10000d0 <__aeabi_uldivmod+0x18>
 10000ba:	b94a      	cbnz	r2, 10000d0 <__aeabi_uldivmod+0x18>
 10000bc:	2900      	cmp	r1, #0
 10000be:	bf08      	it	eq
 10000c0:	2800      	cmpeq	r0, #0
 10000c2:	bf1c      	itt	ne
 10000c4:	f04f 31ff 	movne.w	r1, #4294967295
 10000c8:	f04f 30ff 	movne.w	r0, #4294967295
 10000cc:	f000 b984 	b.w	10003d8 <__aeabi_idiv0>
 10000d0:	f1ad 0c08 	sub.w	ip, sp, #8
 10000d4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 10000d8:	f000 f806 	bl	10000e8 <__udivmoddi4>
 10000dc:	f8dd e004 	ldr.w	lr, [sp, #4]
 10000e0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 10000e4:	b004      	add	sp, #16
 10000e6:	4770      	bx	lr

010000e8 <__udivmoddi4>:
 10000e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10000ec:	9e09      	ldr	r6, [sp, #36]	; 0x24
 10000ee:	460d      	mov	r5, r1
 10000f0:	4604      	mov	r4, r0
 10000f2:	468a      	mov	sl, r1
 10000f4:	2b00      	cmp	r3, #0
 10000f6:	f040 8085 	bne.w	1000204 <__udivmoddi4+0x11c>
 10000fa:	428a      	cmp	r2, r1
 10000fc:	4617      	mov	r7, r2
 10000fe:	d944      	bls.n	100018a <__udivmoddi4+0xa2>
 1000100:	fab2 f282 	clz	r2, r2
 1000104:	b14a      	cbz	r2, 100011a <__udivmoddi4+0x32>
 1000106:	f1c2 0120 	rsb	r1, r2, #32
 100010a:	fa05 f302 	lsl.w	r3, r5, r2
 100010e:	4097      	lsls	r7, r2
 1000110:	4094      	lsls	r4, r2
 1000112:	fa20 f101 	lsr.w	r1, r0, r1
 1000116:	ea41 0a03 	orr.w	sl, r1, r3
 100011a:	ea4f 4817 	mov.w	r8, r7, lsr #16
 100011e:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 1000122:	fa1f f987 	uxth.w	r9, r7
 1000126:	fbba fef8 	udiv	lr, sl, r8
 100012a:	fb08 a31e 	mls	r3, r8, lr, sl
 100012e:	fb0e f109 	mul.w	r1, lr, r9
 1000132:	ea4c 4303 	orr.w	r3, ip, r3, lsl #16
 1000136:	4299      	cmp	r1, r3
 1000138:	d907      	bls.n	100014a <__udivmoddi4+0x62>
 100013a:	18fb      	adds	r3, r7, r3
 100013c:	f10e 30ff 	add.w	r0, lr, #4294967295
 1000140:	d202      	bcs.n	1000148 <__udivmoddi4+0x60>
 1000142:	4299      	cmp	r1, r3
 1000144:	f200 8130 	bhi.w	10003a8 <__udivmoddi4+0x2c0>
 1000148:	4686      	mov	lr, r0
 100014a:	1a59      	subs	r1, r3, r1
 100014c:	b2a3      	uxth	r3, r4
 100014e:	fbb1 f0f8 	udiv	r0, r1, r8
 1000152:	fb08 1110 	mls	r1, r8, r0, r1
 1000156:	fb00 f909 	mul.w	r9, r0, r9
 100015a:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
 100015e:	45a1      	cmp	r9, r4
 1000160:	d907      	bls.n	1000172 <__udivmoddi4+0x8a>
 1000162:	193c      	adds	r4, r7, r4
 1000164:	f100 33ff 	add.w	r3, r0, #4294967295
 1000168:	d202      	bcs.n	1000170 <__udivmoddi4+0x88>
 100016a:	45a1      	cmp	r9, r4
 100016c:	f200 8119 	bhi.w	10003a2 <__udivmoddi4+0x2ba>
 1000170:	4618      	mov	r0, r3
 1000172:	eba4 0409 	sub.w	r4, r4, r9
 1000176:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
 100017a:	2100      	movs	r1, #0
 100017c:	b11e      	cbz	r6, 1000186 <__udivmoddi4+0x9e>
 100017e:	40d4      	lsrs	r4, r2
 1000180:	2300      	movs	r3, #0
 1000182:	e9c6 4300 	strd	r4, r3, [r6]
 1000186:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 100018a:	b902      	cbnz	r2, 100018e <__udivmoddi4+0xa6>
 100018c:	deff      	udf	#255	; 0xff
 100018e:	fab2 f282 	clz	r2, r2
 1000192:	2a00      	cmp	r2, #0
 1000194:	d151      	bne.n	100023a <__udivmoddi4+0x152>
 1000196:	1bcb      	subs	r3, r1, r7
 1000198:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 100019c:	fa1f f887 	uxth.w	r8, r7
 10001a0:	2101      	movs	r1, #1
 10001a2:	0c25      	lsrs	r5, r4, #16
 10001a4:	fbb3 fcfe 	udiv	ip, r3, lr
 10001a8:	fb0e 301c 	mls	r0, lr, ip, r3
 10001ac:	fb08 f90c 	mul.w	r9, r8, ip
 10001b0:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
 10001b4:	45a9      	cmp	r9, r5
 10001b6:	d90b      	bls.n	10001d0 <__udivmoddi4+0xe8>
 10001b8:	197d      	adds	r5, r7, r5
 10001ba:	f10c 33ff 	add.w	r3, ip, #4294967295
 10001be:	bf2c      	ite	cs
 10001c0:	2001      	movcs	r0, #1
 10001c2:	2000      	movcc	r0, #0
 10001c4:	45a9      	cmp	r9, r5
 10001c6:	d902      	bls.n	10001ce <__udivmoddi4+0xe6>
 10001c8:	2800      	cmp	r0, #0
 10001ca:	f000 80f1 	beq.w	10003b0 <__udivmoddi4+0x2c8>
 10001ce:	469c      	mov	ip, r3
 10001d0:	eba5 0509 	sub.w	r5, r5, r9
 10001d4:	b2a3      	uxth	r3, r4
 10001d6:	fbb5 f0fe 	udiv	r0, r5, lr
 10001da:	fb0e 5510 	mls	r5, lr, r0, r5
 10001de:	fb08 f800 	mul.w	r8, r8, r0
 10001e2:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 10001e6:	45a0      	cmp	r8, r4
 10001e8:	d907      	bls.n	10001fa <__udivmoddi4+0x112>
 10001ea:	193c      	adds	r4, r7, r4
 10001ec:	f100 33ff 	add.w	r3, r0, #4294967295
 10001f0:	d202      	bcs.n	10001f8 <__udivmoddi4+0x110>
 10001f2:	45a0      	cmp	r8, r4
 10001f4:	f200 80d2 	bhi.w	100039c <__udivmoddi4+0x2b4>
 10001f8:	4618      	mov	r0, r3
 10001fa:	eba4 0408 	sub.w	r4, r4, r8
 10001fe:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 1000202:	e7bb      	b.n	100017c <__udivmoddi4+0x94>
 1000204:	428b      	cmp	r3, r1
 1000206:	d908      	bls.n	100021a <__udivmoddi4+0x132>
 1000208:	2e00      	cmp	r6, #0
 100020a:	f000 80be 	beq.w	100038a <__udivmoddi4+0x2a2>
 100020e:	2100      	movs	r1, #0
 1000210:	e9c6 0500 	strd	r0, r5, [r6]
 1000214:	4608      	mov	r0, r1
 1000216:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 100021a:	fab3 f183 	clz	r1, r3
 100021e:	2900      	cmp	r1, #0
 1000220:	d14d      	bne.n	10002be <__udivmoddi4+0x1d6>
 1000222:	42ab      	cmp	r3, r5
 1000224:	f0c0 80b4 	bcc.w	1000390 <__udivmoddi4+0x2a8>
 1000228:	4282      	cmp	r2, r0
 100022a:	f240 80b1 	bls.w	1000390 <__udivmoddi4+0x2a8>
 100022e:	4608      	mov	r0, r1
 1000230:	2e00      	cmp	r6, #0
 1000232:	d0a8      	beq.n	1000186 <__udivmoddi4+0x9e>
 1000234:	e9c6 4a00 	strd	r4, sl, [r6]
 1000238:	e7a5      	b.n	1000186 <__udivmoddi4+0x9e>
 100023a:	f1c2 0020 	rsb	r0, r2, #32
 100023e:	4097      	lsls	r7, r2
 1000240:	fa01 f302 	lsl.w	r3, r1, r2
 1000244:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 1000248:	40c1      	lsrs	r1, r0
 100024a:	fa24 f500 	lsr.w	r5, r4, r0
 100024e:	fa1f f887 	uxth.w	r8, r7
 1000252:	4094      	lsls	r4, r2
 1000254:	431d      	orrs	r5, r3
 1000256:	fbb1 f0fe 	udiv	r0, r1, lr
 100025a:	0c2b      	lsrs	r3, r5, #16
 100025c:	fb0e 1110 	mls	r1, lr, r0, r1
 1000260:	fb00 fc08 	mul.w	ip, r0, r8
 1000264:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 1000268:	459c      	cmp	ip, r3
 100026a:	d90e      	bls.n	100028a <__udivmoddi4+0x1a2>
 100026c:	18fb      	adds	r3, r7, r3
 100026e:	f100 31ff 	add.w	r1, r0, #4294967295
 1000272:	bf2c      	ite	cs
 1000274:	f04f 0901 	movcs.w	r9, #1
 1000278:	f04f 0900 	movcc.w	r9, #0
 100027c:	459c      	cmp	ip, r3
 100027e:	d903      	bls.n	1000288 <__udivmoddi4+0x1a0>
 1000280:	f1b9 0f00 	cmp.w	r9, #0
 1000284:	f000 8098 	beq.w	10003b8 <__udivmoddi4+0x2d0>
 1000288:	4608      	mov	r0, r1
 100028a:	eba3 030c 	sub.w	r3, r3, ip
 100028e:	b2ad      	uxth	r5, r5
 1000290:	fbb3 f1fe 	udiv	r1, r3, lr
 1000294:	fb0e 3311 	mls	r3, lr, r1, r3
 1000298:	fb01 fc08 	mul.w	ip, r1, r8
 100029c:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 10002a0:	45ac      	cmp	ip, r5
 10002a2:	d907      	bls.n	10002b4 <__udivmoddi4+0x1cc>
 10002a4:	197d      	adds	r5, r7, r5
 10002a6:	f101 33ff 	add.w	r3, r1, #4294967295
 10002aa:	d202      	bcs.n	10002b2 <__udivmoddi4+0x1ca>
 10002ac:	45ac      	cmp	ip, r5
 10002ae:	f200 808a 	bhi.w	10003c6 <__udivmoddi4+0x2de>
 10002b2:	4619      	mov	r1, r3
 10002b4:	eba5 030c 	sub.w	r3, r5, ip
 10002b8:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 10002bc:	e771      	b.n	10001a2 <__udivmoddi4+0xba>
 10002be:	f1c1 0420 	rsb	r4, r1, #32
 10002c2:	408b      	lsls	r3, r1
 10002c4:	fa02 f701 	lsl.w	r7, r2, r1
 10002c8:	fa05 fc01 	lsl.w	ip, r5, r1
 10002cc:	40e2      	lsrs	r2, r4
 10002ce:	fa20 f804 	lsr.w	r8, r0, r4
 10002d2:	40e5      	lsrs	r5, r4
 10002d4:	fa00 fe01 	lsl.w	lr, r0, r1
 10002d8:	4313      	orrs	r3, r2
 10002da:	ea48 020c 	orr.w	r2, r8, ip
 10002de:	ea4f 4813 	mov.w	r8, r3, lsr #16
 10002e2:	ea4f 4c12 	mov.w	ip, r2, lsr #16
 10002e6:	fa1f f983 	uxth.w	r9, r3
 10002ea:	fbb5 faf8 	udiv	sl, r5, r8
 10002ee:	fb08 551a 	mls	r5, r8, sl, r5
 10002f2:	fb0a f009 	mul.w	r0, sl, r9
 10002f6:	ea4c 4c05 	orr.w	ip, ip, r5, lsl #16
 10002fa:	4560      	cmp	r0, ip
 10002fc:	d90e      	bls.n	100031c <__udivmoddi4+0x234>
 10002fe:	eb13 0c0c 	adds.w	ip, r3, ip
 1000302:	f10a 35ff 	add.w	r5, sl, #4294967295
 1000306:	bf2c      	ite	cs
 1000308:	f04f 0b01 	movcs.w	fp, #1
 100030c:	f04f 0b00 	movcc.w	fp, #0
 1000310:	4560      	cmp	r0, ip
 1000312:	d902      	bls.n	100031a <__udivmoddi4+0x232>
 1000314:	f1bb 0f00 	cmp.w	fp, #0
 1000318:	d051      	beq.n	10003be <__udivmoddi4+0x2d6>
 100031a:	46aa      	mov	sl, r5
 100031c:	ebac 0c00 	sub.w	ip, ip, r0
 1000320:	b292      	uxth	r2, r2
 1000322:	fbbc f0f8 	udiv	r0, ip, r8
 1000326:	fb08 cc10 	mls	ip, r8, r0, ip
 100032a:	fb00 f909 	mul.w	r9, r0, r9
 100032e:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
 1000332:	45e1      	cmp	r9, ip
 1000334:	d907      	bls.n	1000346 <__udivmoddi4+0x25e>
 1000336:	eb13 0c0c 	adds.w	ip, r3, ip
 100033a:	f100 32ff 	add.w	r2, r0, #4294967295
 100033e:	d201      	bcs.n	1000344 <__udivmoddi4+0x25c>
 1000340:	45e1      	cmp	r9, ip
 1000342:	d843      	bhi.n	10003cc <__udivmoddi4+0x2e4>
 1000344:	4610      	mov	r0, r2
 1000346:	ea40 400a 	orr.w	r0, r0, sl, lsl #16
 100034a:	ebac 0c09 	sub.w	ip, ip, r9
 100034e:	fba0 8907 	umull	r8, r9, r0, r7
 1000352:	45cc      	cmp	ip, r9
 1000354:	4645      	mov	r5, r8
 1000356:	464a      	mov	r2, r9
 1000358:	d302      	bcc.n	1000360 <__udivmoddi4+0x278>
 100035a:	d106      	bne.n	100036a <__udivmoddi4+0x282>
 100035c:	45c6      	cmp	lr, r8
 100035e:	d204      	bcs.n	100036a <__udivmoddi4+0x282>
 1000360:	3801      	subs	r0, #1
 1000362:	ebb8 0507 	subs.w	r5, r8, r7
 1000366:	eb69 0203 	sbc.w	r2, r9, r3
 100036a:	b396      	cbz	r6, 10003d2 <__udivmoddi4+0x2ea>
 100036c:	ebbe 0305 	subs.w	r3, lr, r5
 1000370:	eb6c 0c02 	sbc.w	ip, ip, r2
 1000374:	fa23 f201 	lsr.w	r2, r3, r1
 1000378:	fa0c f404 	lsl.w	r4, ip, r4
 100037c:	fa2c f301 	lsr.w	r3, ip, r1
 1000380:	2100      	movs	r1, #0
 1000382:	4314      	orrs	r4, r2
 1000384:	e9c6 4300 	strd	r4, r3, [r6]
 1000388:	e6fd      	b.n	1000186 <__udivmoddi4+0x9e>
 100038a:	4631      	mov	r1, r6
 100038c:	4630      	mov	r0, r6
 100038e:	e6fa      	b.n	1000186 <__udivmoddi4+0x9e>
 1000390:	1a84      	subs	r4, r0, r2
 1000392:	eb65 0303 	sbc.w	r3, r5, r3
 1000396:	2001      	movs	r0, #1
 1000398:	469a      	mov	sl, r3
 100039a:	e749      	b.n	1000230 <__udivmoddi4+0x148>
 100039c:	3802      	subs	r0, #2
 100039e:	443c      	add	r4, r7
 10003a0:	e72b      	b.n	10001fa <__udivmoddi4+0x112>
 10003a2:	3802      	subs	r0, #2
 10003a4:	443c      	add	r4, r7
 10003a6:	e6e4      	b.n	1000172 <__udivmoddi4+0x8a>
 10003a8:	f1ae 0e02 	sub.w	lr, lr, #2
 10003ac:	443b      	add	r3, r7
 10003ae:	e6cc      	b.n	100014a <__udivmoddi4+0x62>
 10003b0:	f1ac 0c02 	sub.w	ip, ip, #2
 10003b4:	443d      	add	r5, r7
 10003b6:	e70b      	b.n	10001d0 <__udivmoddi4+0xe8>
 10003b8:	3802      	subs	r0, #2
 10003ba:	443b      	add	r3, r7
 10003bc:	e765      	b.n	100028a <__udivmoddi4+0x1a2>
 10003be:	f1aa 0a02 	sub.w	sl, sl, #2
 10003c2:	449c      	add	ip, r3
 10003c4:	e7aa      	b.n	100031c <__udivmoddi4+0x234>
 10003c6:	3902      	subs	r1, #2
 10003c8:	443d      	add	r5, r7
 10003ca:	e773      	b.n	10002b4 <__udivmoddi4+0x1cc>
 10003cc:	3802      	subs	r0, #2
 10003ce:	449c      	add	ip, r3
 10003d0:	e7b9      	b.n	1000346 <__udivmoddi4+0x25e>
 10003d2:	4631      	mov	r1, r6
 10003d4:	e6d7      	b.n	1000186 <__udivmoddi4+0x9e>
 10003d6:	bf00      	nop

010003d8 <__aeabi_idiv0>:
 10003d8:	4770      	bx	lr
 10003da:	bf00      	nop
 10003dc:	0000      	movs	r0, r0
	...

010003e0 <ll_adv_enable>:
u8_t ll_adv_enable(u8_t enable)
{
	u16_t const handle = 0;
	u32_t ticks_anchor;
#endif /* !CONFIG_BT_CTLR_ADV_EXT || !CONFIG_BT_HCI_MESH_EXT */
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 10003e0:	2302      	movs	r3, #2
{
 10003e2:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10003e6:	b08f      	sub	sp, #60	; 0x3c
inline struct ll_adv_set *ull_adv_is_enabled_get(u16_t handle)
{
	struct ll_adv_set *adv;

	adv = ull_adv_set_get(handle);
	if (!adv || !adv->is_enabled) {
 10003e8:	4ca5      	ldr	r4, [pc, #660]	; (1000680 <ll_adv_enable+0x2a0>)
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 10003ea:	930c      	str	r3, [sp, #48]	; 0x30
	if (!enable) {
 10003ec:	2800      	cmp	r0, #0
 10003ee:	f000 80ea 	beq.w	10005c6 <ll_adv_enable+0x1e6>
static inline struct ll_adv_set *is_disabled_get(u16_t handle)
{
	struct ll_adv_set *adv;

	adv = ull_adv_set_get(handle);
	if (!adv || adv->is_enabled) {
 10003f2:	f894 80cc 	ldrb.w	r8, [r4, #204]	; 0xcc
 10003f6:	f018 0801 	ands.w	r8, r8, #1
 10003fa:	d139      	bne.n	1000470 <ll_adv_enable+0x90>
		lll->rl_idx = FILTER_IDX_NONE;
 10003fc:	23ff      	movs	r3, #255	; 0xff
	lll_adv_pdu_enqueue(&lll->scan_rsp, idx);
}

static inline struct pdu_adv *lll_adv_scan_rsp_peek(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 10003fe:	f894 607c 	ldrb.w	r6, [r4, #124]	; 0x7c
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 1000402:	f894 702c 	ldrb.w	r7, [r4, #44]	; 0x2c
		ull_filter_adv_update(lll->filter_policy);
 1000406:	f894 0029 	ldrb.w	r0, [r4, #41]	; 0x29
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 100040a:	eb06 0286 	add.w	r2, r6, r6, lsl #2
 100040e:	ebc6 06c2 	rsb	r6, r6, r2, lsl #3
 1000412:	f000 0003 	and.w	r0, r0, #3
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 1000416:	eb07 0287 	add.w	r2, r7, r7, lsl #2
 100041a:	ebc7 07c2 	rsb	r7, r7, r2, lsl #3
		lll->rl_idx = FILTER_IDX_NONE;
 100041e:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
		ull_filter_adv_update(lll->filter_policy);
 1000422:	f00e fd91 	bl	100ef48 <ull_filter_adv_update>
		if (adv->own_addr_type == BT_ADDR_LE_PUBLIC_ID ||
 1000426:	f894 00da 	ldrb.w	r0, [r4, #218]	; 0xda
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 100042a:	367d      	adds	r6, #125	; 0x7d
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 100042c:	372d      	adds	r7, #45	; 0x2d
 100042e:	0781      	lsls	r1, r0, #30
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 1000430:	4426      	add	r6, r4
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 1000432:	eb04 0907 	add.w	r9, r4, r7
 1000436:	d421      	bmi.n	100047c <ll_adv_enable+0x9c>
			u8_t *tx_addr = ll_addr_get(pdu_adv->tx_addr, NULL);
 1000438:	5de0      	ldrb	r0, [r4, r7]
 100043a:	4641      	mov	r1, r8
 100043c:	f3c0 1080 	ubfx	r0, r0, #6, #1
 1000440:	f006 ffb4 	bl	10073ac <ll_addr_get>
 1000444:	4605      	mov	r5, r0
			memcpy(&pdu_adv->adv_ind.addr[0], tx_addr,
 1000446:	4601      	mov	r1, r0
 1000448:	2206      	movs	r2, #6
 100044a:	f109 0002 	add.w	r0, r9, #2
 100044e:	f016 fae3 	bl	1016a18 <memcpy>
			memcpy(&pdu_scan->scan_rsp.addr[0], tx_addr,
 1000452:	2206      	movs	r2, #6
 1000454:	4629      	mov	r1, r5
 1000456:	1cb0      	adds	r0, r6, #2
 1000458:	f016 fade 	bl	1016a18 <memcpy>
		if (pdu_adv->tx_addr &&
 100045c:	5de3      	ldrb	r3, [r4, r7]
 100045e:	065a      	lsls	r2, r3, #25
 1000460:	d423      	bmi.n	10004aa <ll_adv_enable+0xca>
	if ((pdu_adv->type == PDU_ADV_TYPE_ADV_IND) ||
 1000462:	f013 0f0e 	tst.w	r3, #14
 1000466:	d12c      	bne.n	10004c2 <ll_adv_enable+0xe2>
		if (lll->conn) {
 1000468:	6a63      	ldr	r3, [r4, #36]	; 0x24
 100046a:	2b00      	cmp	r3, #0
 100046c:	f000 8114 	beq.w	1000698 <ll_adv_enable+0x2b8>
	return BT_HCI_ERR_CMD_DISALLOWED;
 1000470:	f04f 080c 	mov.w	r8, #12
}
 1000474:	4640      	mov	r0, r8
 1000476:	b00f      	add	sp, #60	; 0x3c
 1000478:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			lll->rl_idx = ull_filter_rl_find(adv->id_addr_type,
 100047c:	4642      	mov	r2, r8
 100047e:	f3c0 0080 	ubfx	r0, r0, #2, #1
 1000482:	f104 01db 	add.w	r1, r4, #219	; 0xdb
 1000486:	f00e ff4b 	bl	100f320 <ull_filter_rl_find>
			if (lll->rl_idx != FILTER_IDX_NONE) {
 100048a:	28ff      	cmp	r0, #255	; 0xff
			lll->rl_idx = ull_filter_rl_find(adv->id_addr_type,
 100048c:	f884 002a 	strb.w	r0, [r4, #42]	; 0x2a
			if (lll->rl_idx != FILTER_IDX_NONE) {
 1000490:	f040 81d9 	bne.w	1000846 <ll_adv_enable+0x466>
			ull_filter_adv_pdu_update(adv, pdu_adv);
 1000494:	4649      	mov	r1, r9
 1000496:	487a      	ldr	r0, [pc, #488]	; (1000680 <ll_adv_enable+0x2a0>)
 1000498:	f00e fd9c 	bl	100efd4 <ull_filter_adv_pdu_update>
			ull_filter_adv_pdu_update(adv, pdu_scan);
 100049c:	4631      	mov	r1, r6
 100049e:	4878      	ldr	r0, [pc, #480]	; (1000680 <ll_adv_enable+0x2a0>)
 10004a0:	f00e fd98 	bl	100efd4 <ull_filter_adv_pdu_update>
		if (pdu_adv->tx_addr &&
 10004a4:	5de3      	ldrb	r3, [r4, r7]
 10004a6:	065a      	lsls	r2, r3, #25
 10004a8:	d5db      	bpl.n	1000462 <ll_adv_enable+0x82>
		    !mem_nz(pdu_adv->adv_ind.addr, BDADDR_SIZE)) {
 10004aa:	2106      	movs	r1, #6
 10004ac:	f109 0002 	add.w	r0, r9, #2
 10004b0:	f005 fc7c 	bl	1005dac <mem_nz>
		if (pdu_adv->tx_addr &&
 10004b4:	2800      	cmp	r0, #0
 10004b6:	f000 8220 	beq.w	10008fa <ll_adv_enable+0x51a>
 10004ba:	5de3      	ldrb	r3, [r4, r7]
	if ((pdu_adv->type == PDU_ADV_TYPE_ADV_IND) ||
 10004bc:	f013 0f0e 	tst.w	r3, #14
 10004c0:	d0d2      	beq.n	1000468 <ll_adv_enable+0x88>
	u8_t ch_map = lll->chan_map;
 10004c2:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
	const u8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
 10004c6:	2101      	movs	r1, #1
	u8_t ch_map = lll->chan_map;
 10004c8:	f3c3 0342 	ubfx	r3, r3, #1, #3
	const u8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
 10004cc:	a80d      	add	r0, sp, #52	; 0x34
	u8_t ch_map = lll->chan_map;
 10004ce:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
	const u8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
 10004d2:	f005 fded 	bl	10060b0 <util_ones_count_get>
	if (adv_chn_cnt == 0) {
 10004d6:	2800      	cmp	r0, #0
 10004d8:	d06e      	beq.n	10005b8 <ll_adv_enable+0x1d8>
		if (pdu_adv->type == PDU_ADV_TYPE_NONCONN_IND) {
 10004da:	5de2      	ldrb	r2, [r4, r7]
		const u8_t adv_data_len = pdu_adv->len;
 10004dc:	f899 3001 	ldrb.w	r3, [r9, #1]
		if (pdu_adv->type == PDU_ADV_TYPE_NONCONN_IND) {
 10004e0:	f002 020f 	and.w	r2, r2, #15
 10004e4:	2a02      	cmp	r2, #2
		const u8_t rsp_data_len = pdu_scan->len;
 10004e6:	7871      	ldrb	r1, [r6, #1]
		if (pdu_adv->type == PDU_ADV_TYPE_NONCONN_IND) {
 10004e8:	d012      	beq.n	1000510 <ll_adv_enable+0x130>
			if (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND) {
 10004ea:	2a01      	cmp	r2, #1
 10004ec:	f000 8210 	beq.w	1000910 <ll_adv_enable+0x530>
					  BYTES2US(ADVA_SIZE + rsp_data_len,
 10004f0:	00c9      	lsls	r1, r1, #3
		const u16_t scan_rsp_us  = ll_hdr_us +
 10004f2:	3180      	adds	r1, #128	; 0x80
			} else if (pdu_adv->type == PDU_ADV_TYPE_ADV_IND) {
 10004f4:	2a00      	cmp	r2, #0
 10004f6:	f040 8203 	bne.w	1000900 <ll_adv_enable+0x520>
				adv_size += adv_data_len;
 10004fa:	3310      	adds	r3, #16
 10004fc:	00db      	lsls	r3, r3, #3
 10004fe:	f503 724d 	add.w	r2, r3, #820	; 0x334
 1000502:	440a      	add	r2, r1
 1000504:	f503 739a 	add.w	r3, r3, #308	; 0x134
				  + rx_to_us + rxtx_turn_us) * (adv_chn_cnt-1)
 1000508:	3801      	subs	r0, #1
			slot_us += (BYTES2US(adv_size, phy) + EVENT_IFS_MAX_US
 100050a:	fb03 2000 	mla	r0, r3, r0, r2
 100050e:	e009      	b.n	1000524 <ll_adv_enable+0x144>
				   rxtx_turn_us * (adv_chn_cnt - 1);
 1000510:	2264      	movs	r2, #100	; 0x64
			adv_size += adv_data_len;
 1000512:	3310      	adds	r3, #16
			slot_us += BYTES2US(adv_size, phy) * adv_chn_cnt +
 1000514:	00db      	lsls	r3, r3, #3
 1000516:	fb00 f303 	mul.w	r3, r0, r3
				   rxtx_turn_us * (adv_chn_cnt - 1);
 100051a:	3801      	subs	r0, #1
			slot_us += BYTES2US(adv_size, phy) * adv_chn_cnt +
 100051c:	f503 73aa 	add.w	r3, r3, #340	; 0x154
 1000520:	fb02 3000 	mla	r0, r2, r0, r3
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
 1000524:	a354      	add	r3, pc, #336	; (adr r3, 1000678 <ll_adv_enable+0x298>)
 1000526:	e9d3 2300 	ldrd	r2, r3, [r3]
	return hdr->ref--;
}

static inline void ull_hdr_init(struct ull_hdr *hdr)
{
	hdr->disabled_cb = hdr->disabled_param = NULL;
 100052a:	2500      	movs	r5, #0
	adv->evt.ticks_xtal_to_start =
 100052c:	2631      	movs	r6, #49	; 0x31
static inline void lll_hdr_init(void *lll, void *parent)
{
	struct lll_hdr *hdr = lll;

	hdr->parent = parent;
	hdr->is_stop = 0U;
 100052e:	f894 1020 	ldrb.w	r1, [r4, #32]
 1000532:	6026      	str	r6, [r4, #0]
 1000534:	f365 0100 	bfi	r1, r5, #0, #1
 1000538:	f884 1020 	strb.w	r1, [r4, #32]
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
 100053c:	4951      	ldr	r1, [pc, #324]	; (1000684 <ll_adv_enable+0x2a4>)
 100053e:	e9c4 5505 	strd	r5, r5, [r4, #20]
 1000542:	fba0 0101 	umull	r0, r1, r0, r1
	adv->evt.ticks_preempt_to_start =
 1000546:	e9c4 5501 	strd	r5, r5, [r4, #4]
	hdr->parent = parent;
 100054a:	61e4      	str	r4, [r4, #28]
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
 100054c:	f7ff fdb4 	bl	10000b8 <__aeabi_uldivmod>
	u16_t interval = adv->interval;
 1000550:	f8b4 90d8 	ldrh.w	r9, [r4, #216]	; 0xd8
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
 1000554:	60e0      	str	r0, [r4, #12]
	ticks_anchor = ticker_ticks_now_get();
 1000556:	f006 ff23 	bl	10073a0 <ticker_ticks_now_get>
 100055a:	4606      	mov	r6, r0
	lll->is_hdcd = !interval && (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND);
 100055c:	f1b9 0f00 	cmp.w	r9, #0
 1000560:	d107      	bne.n	1000572 <ll_adv_enable+0x192>
 1000562:	5de5      	ldrb	r5, [r4, r7]
 1000564:	f005 050f 	and.w	r5, r5, #15
 1000568:	f1a5 0501 	sub.w	r5, r5, #1
 100056c:	fab5 f585 	clz	r5, r5
 1000570:	096d      	lsrs	r5, r5, #5
 1000572:	f894 0028 	ldrb.w	r0, [r4, #40]	; 0x28
 1000576:	f365 0000 	bfi	r0, r5, #0, #1
	if (lll->is_hdcd) {
 100057a:	f010 0501 	ands.w	r5, r0, #1
	lll->is_hdcd = !interval && (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND);
 100057e:	f884 0028 	strb.w	r0, [r4, #40]	; 0x28
	if (lll->is_hdcd) {
 1000582:	f000 8164 	beq.w	100084e <ll_adv_enable+0x46e>
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000586:	2000      	movs	r0, #0
				   (adv->evt.ticks_slot + ticks_slot_overhead),
 1000588:	68e3      	ldr	r3, [r4, #12]
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 100058a:	4a3f      	ldr	r2, [pc, #252]	; (1000688 <ll_adv_enable+0x2a8>)
 100058c:	4d3f      	ldr	r5, [pc, #252]	; (100068c <ll_adv_enable+0x2ac>)
 100058e:	af0c      	add	r7, sp, #48	; 0x30
 1000590:	2103      	movs	r1, #3
 1000592:	9304      	str	r3, [sp, #16]
 1000594:	9301      	str	r3, [sp, #4]
 1000596:	9205      	str	r2, [sp, #20]
 1000598:	4633      	mov	r3, r6
 100059a:	2202      	movs	r2, #2
 100059c:	e9cd 0002 	strd	r0, r0, [sp, #8]
 10005a0:	9406      	str	r4, [sp, #24]
 10005a2:	9000      	str	r0, [sp, #0]
 10005a4:	9507      	str	r5, [sp, #28]
 10005a6:	9708      	str	r7, [sp, #32]
 10005a8:	f006 fe5a 	bl	1007260 <ticker_start>
		ret = ull_ticker_status_take(ret, &ret_cb);
 10005ac:	4639      	mov	r1, r7
 10005ae:	f009 fe55 	bl	100a25c <ull_ticker_status_take>
		if (ret != TICKER_STATUS_SUCCESS) {
 10005b2:	2800      	cmp	r0, #0
 10005b4:	f000 818b 	beq.w	10008ce <ll_adv_enable+0x4ee>
	if (adv->lll.conn) {
 10005b8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 10005ba:	2b00      	cmp	r3, #0
 10005bc:	f43f af58 	beq.w	1000470 <ll_adv_enable+0x90>
		conn_release(adv);
 10005c0:	f00a f992 	bl	100a8e8 <conn_release.constprop.0>
 10005c4:	e754      	b.n	1000470 <ll_adv_enable+0x90>
}
#endif /* CONFIG_BT_PERIPHERAL */

static inline u8_t disable(u16_t handle)
{
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 10005c6:	930d      	str	r3, [sp, #52]	; 0x34
	if (!adv || !adv->is_enabled) {
 10005c8:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
 10005cc:	07dd      	lsls	r5, r3, #31
 10005ce:	f57f af4f 	bpl.w	1000470 <ll_adv_enable+0x90>
	adv = ull_adv_is_enabled_get(handle);
	if (!adv) {
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	mark = ull_disable_mark(adv);
 10005d2:	4620      	mov	r0, r4
 10005d4:	f009 fe50 	bl	100a278 <ull_disable_mark>
	LL_ASSERT(mark == adv);
 10005d8:	4284      	cmp	r4, r0
 10005da:	d004      	beq.n	10005e6 <ll_adv_enable+0x206>
 10005dc:	f240 41e9 	movw	r1, #1257	; 0x4e9
 10005e0:	482b      	ldr	r0, [pc, #172]	; (1000690 <ll_adv_enable+0x2b0>)
 10005e2:	f003 f84d 	bl	1003680 <bt_ctlr_assert_handle>

#if defined(CONFIG_BT_PERIPHERAL)
	if (adv->lll.is_hdcd) {
 10005e6:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 10005ea:	ad0d      	add	r5, sp, #52	; 0x34
	if (adv->lll.is_hdcd) {
 10005ec:	07d8      	lsls	r0, r3, #31
 10005ee:	d50e      	bpl.n	100060e <ll_adv_enable+0x22e>
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 10005f0:	2103      	movs	r1, #3
 10005f2:	2201      	movs	r2, #1
 10005f4:	2000      	movs	r0, #0
 10005f6:	4b25      	ldr	r3, [pc, #148]	; (100068c <ll_adv_enable+0x2ac>)
 10005f8:	9500      	str	r5, [sp, #0]
 10005fa:	f006 fe97 	bl	100732c <ticker_stop>
				  TICKER_USER_ID_THREAD, TICKER_ID_ADV_STOP,
				  ull_ticker_status_give, (void *)&ret_cb);
		ret = ull_ticker_status_take(ret, &ret_cb);
 10005fe:	4629      	mov	r1, r5
 1000600:	f009 fe2c 	bl	100a25c <ull_ticker_status_take>
		if (ret) {
 1000604:	2800      	cmp	r0, #0
 1000606:	f040 81ac 	bne.w	1000962 <ll_adv_enable+0x582>
			mark = ull_disable_mark(adv);
			LL_ASSERT(mark == adv);

			return BT_HCI_ERR_CMD_DISALLOWED;
		}
		ret_cb = TICKER_STATUS_BUSY;
 100060a:	2302      	movs	r3, #2
 100060c:	930d      	str	r3, [sp, #52]	; 0x34
	}
#endif

	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
 100060e:	2103      	movs	r1, #3
 1000610:	2202      	movs	r2, #2
 1000612:	2000      	movs	r0, #0
 1000614:	4b1d      	ldr	r3, [pc, #116]	; (100068c <ll_adv_enable+0x2ac>)
 1000616:	9500      	str	r5, [sp, #0]
 1000618:	f006 fe88 	bl	100732c <ticker_stop>
			  TICKER_ID_ADV_BASE + handle,
			  ull_ticker_status_give, (void *)&ret_cb);

	ret = ull_ticker_status_take(ret, &ret_cb);
 100061c:	4629      	mov	r1, r5
 100061e:	f009 fe1d 	bl	100a25c <ull_ticker_status_take>
	if (ret) {
 1000622:	2800      	cmp	r0, #0
 1000624:	f040 8186 	bne.w	1000934 <ll_adv_enable+0x554>
		LL_ASSERT(mark == adv);

		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	ret = ull_disable(&adv->lll);
 1000628:	481a      	ldr	r0, [pc, #104]	; (1000694 <ll_adv_enable+0x2b4>)
 100062a:	f009 fe61 	bl	100a2f0 <ull_disable>
	LL_ASSERT(!ret);
 100062e:	2800      	cmp	r0, #0
 1000630:	f040 8173 	bne.w	100091a <ll_adv_enable+0x53a>

	mark = ull_disable_unmark(adv);
 1000634:	4812      	ldr	r0, [pc, #72]	; (1000680 <ll_adv_enable+0x2a0>)
 1000636:	f009 fe29 	bl	100a28c <ull_disable_unmark>
	LL_ASSERT(mark == adv);
 100063a:	4284      	cmp	r4, r0
 100063c:	d004      	beq.n	1000648 <ll_adv_enable+0x268>
 100063e:	f240 510b 	movw	r1, #1291	; 0x50b
 1000642:	4813      	ldr	r0, [pc, #76]	; (1000690 <ll_adv_enable+0x2b0>)
 1000644:	f003 f81c 	bl	1003680 <bt_ctlr_assert_handle>

#if defined(CONFIG_BT_PERIPHERAL)
	if (adv->lll.conn) {
 1000648:	6a63      	ldr	r3, [r4, #36]	; 0x24
 100064a:	b10b      	cbz	r3, 1000650 <ll_adv_enable+0x270>
		conn_release(adv);
 100064c:	f00a f94c 	bl	100a8e8 <conn_release.constprop.0>
	}
#endif /* CONFIG_BT_PERIPHERAL */

	adv->is_enabled = 0U;
 1000650:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc

#if defined(CONFIG_BT_CTLR_PRIVACY)
	if (IS_ENABLED(CONFIG_BT_OBSERVER) && !ull_scan_is_enabled_get(0)) {
 1000654:	2000      	movs	r0, #0
	adv->is_enabled = 0U;
 1000656:	f36f 0300 	bfc	r3, #0, #1
 100065a:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
	if (IS_ENABLED(CONFIG_BT_OBSERVER) && !ull_scan_is_enabled_get(0)) {
 100065e:	f00a fc75 	bl	100af4c <ull_scan_is_enabled_get>
 1000662:	4680      	mov	r8, r0
 1000664:	2800      	cmp	r0, #0
 1000666:	f000 812f 	beq.w	10008c8 <ll_adv_enable+0x4e8>
		ull_filter_adv_scan_state_cb(0);
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */

	return 0;
 100066a:	f04f 0800 	mov.w	r8, #0
}
 100066e:	4640      	mov	r0, r8
 1000670:	b00f      	add	sp, #60	; 0x3c
 1000672:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1000676:	bf00      	nop
 1000678:	1afd498d 	.word	0x1afd498d
 100067c:	00000007 	.word	0x00000007
 1000680:	21002a60 	.word	0x21002a60
 1000684:	3b9aca00 	.word	0x3b9aca00
 1000688:	0100a7f9 	.word	0x0100a7f9
 100068c:	0100a251 	.word	0x0100a251
 1000690:	01018890 	.word	0x01018890
 1000694:	21002a7c 	.word	0x21002a7c
		link = ll_rx_link_alloc();
 1000698:	f009 fd58 	bl	100a14c <ll_rx_link_alloc>
		if (!link) {
 100069c:	4682      	mov	sl, r0
 100069e:	2800      	cmp	r0, #0
 10006a0:	f000 8145 	beq.w	100092e <ll_adv_enable+0x54e>
		node_rx = ll_rx_alloc();
 10006a4:	f009 fd5e 	bl	100a164 <ll_rx_alloc>
		if (!node_rx) {
 10006a8:	4683      	mov	fp, r0
 10006aa:	2800      	cmp	r0, #0
 10006ac:	f000 8153 	beq.w	1000956 <ll_adv_enable+0x576>
		conn = ll_conn_acquire();
 10006b0:	f00a fff4 	bl	100b69c <ll_conn_acquire>
		if (!conn) {
 10006b4:	4605      	mov	r5, r0
 10006b6:	2800      	cmp	r0, #0
 10006b8:	f000 814a 	beq.w	1000950 <ll_adv_enable+0x570>
		conn_lll->handle = 0xFFFF;
 10006bc:	f64f 73ff 	movw	r3, #65535	; 0xffff
		if (!conn_lll->link_tx_free) {
 10006c0:	6f80      	ldr	r0, [r0, #120]	; 0x78
		conn_lll->handle = 0xFFFF;
 10006c2:	85ab      	strh	r3, [r5, #44]	; 0x2c
		conn_lll = &conn->lll;
 10006c4:	f105 031c 	add.w	r3, r5, #28
 10006c8:	930b      	str	r3, [sp, #44]	; 0x2c
		if (!conn_lll->link_tx_free) {
 10006ca:	2800      	cmp	r0, #0
 10006cc:	f000 812b 	beq.w	1000926 <ll_adv_enable+0x546>
		memq_init(conn_lll->link_tx_free, &conn_lll->memq_tx.head,
 10006d0:	f105 026c 	add.w	r2, r5, #108	; 0x6c
 10006d4:	f105 0168 	add.w	r1, r5, #104	; 0x68
 10006d8:	f005 fb74 	bl	1005dc4 <memq_init>
		conn_lll->data_chan_use = 0;
 10006dc:	2300      	movs	r3, #0
		conn_lll->max_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
 10006de:	f04f 1e1b 	mov.w	lr, #1769499	; 0x1b001b
		conn_lll->rssi_latest = 0x7F;
 10006e2:	f04f 0c7f 	mov.w	ip, #127	; 0x7f
		conn->connect_expire = 6;
 10006e6:	2006      	movs	r0, #6
		conn_lll->phy_tx = BIT(0);
 10006e8:	f8b5 2064 	ldrh.w	r2, [r5, #100]	; 0x64
		conn_lll->data_chan_sel = 0;
 10006ec:	f895 103d 	ldrb.w	r1, [r5, #61]	; 0x3d
		conn_lll->phy_tx = BIT(0);
 10006f0:	f422 62ef 	bic.w	r2, r2, #1912	; 0x778
 10006f4:	f022 0207 	bic.w	r2, r2, #7
 10006f8:	f442 7288 	orr.w	r2, r2, #272	; 0x110
 10006fc:	f042 0201 	orr.w	r2, r2, #1
 1000700:	f8a5 2064 	strh.w	r2, [r5, #100]	; 0x64
		conn_lll->slave.latency_enabled = 0;
 1000704:	f895 2040 	ldrb.w	r2, [r5, #64]	; 0x40
		conn_lll->data_chan_sel = 0;
 1000708:	f001 013f 	and.w	r1, r1, #63	; 0x3f
		conn_lll->slave.latency_enabled = 0;
 100070c:	f363 0200 	bfi	r2, r3, #0, #1
		conn_lll->data_chan_sel = 0;
 1000710:	f061 017f 	orn	r1, r1, #127	; 0x7f
 1000714:	f885 103d 	strb.w	r1, [r5, #61]	; 0x3d
		conn_lll->slave.latency_enabled = 0;
 1000718:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
		conn->common.fex_valid = 0;
 100071c:	f895 10dc 	ldrb.w	r1, [r5, #220]	; 0xdc
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
 1000720:	f895 2122 	ldrb.w	r2, [r5, #290]	; 0x122
		conn->common.fex_valid = 0;
 1000724:	f021 0103 	bic.w	r1, r1, #3
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
 1000728:	f022 0203 	bic.w	r2, r2, #3
		conn->common.fex_valid = 0;
 100072c:	f885 10dc 	strb.w	r1, [r5, #220]	; 0xdc
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
 1000730:	f885 2122 	strb.w	r2, [r5, #290]	; 0x122
		conn_lll->max_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M);
 1000734:	4994      	ldr	r1, [pc, #592]	; (1000988 <ll_adv_enable+0x5a8>)
		conn->llcp_feature.features = LL_FEAT;
 1000736:	4a95      	ldr	r2, [pc, #596]	; (100098c <ll_adv_enable+0x5ac>)
		conn_lll->slave.window_widening_event_us = 0;
 1000738:	e9c5 3313 	strd	r3, r3, [r5, #76]	; 0x4c
		conn_lll->data_chan_use = 0;
 100073c:	f885 303f 	strb.w	r3, [r5, #63]	; 0x3f
		conn_lll->latency_prepare = 0;
 1000740:	866b      	strh	r3, [r5, #50]	; 0x32
		conn_lll->latency_event = 0;
 1000742:	636b      	str	r3, [r5, #52]	; 0x34
		conn_lll->slave.window_size_prepare_us = 0;
 1000744:	656b      	str	r3, [r5, #84]	; 0x54
		conn->supervision_expire = 0;
 1000746:	f8a5 30c8 	strh.w	r3, [r5, #200]	; 0xc8
		conn->procedure_expire = 0;
 100074a:	f8a5 30cc 	strh.w	r3, [r5, #204]	; 0xcc
		conn->llcp_req = conn->llcp_ack = conn->llcp_type = 0;
 100074e:	f8a5 30e8 	strh.w	r3, [r5, #232]	; 0xe8
 1000752:	f885 30ea 	strb.w	r3, [r5, #234]	; 0xea
		conn->llcp_rx = NULL;
 1000756:	f8c5 3100 	str.w	r3, [r5, #256]	; 0x100
		conn->llcp_cu.req = conn->llcp_cu.ack = 0;
 100075a:	f8a5 3104 	strh.w	r3, [r5, #260]	; 0x104
		conn->llcp_feature.req = conn->llcp_feature.ack = 0;
 100075e:	f8a5 3118 	strh.w	r3, [r5, #280]	; 0x118
		conn->llcp_version.req = conn->llcp_version.ack = 0;
 1000762:	f8a5 3120 	strh.w	r3, [r5, #288]	; 0x120
		conn->llcp_terminate.reason_peer = 0;
 1000766:	f885 312b 	strb.w	r3, [r5, #299]	; 0x12b
		conn_lll->link_tx_free = NULL;
 100076a:	67ab      	str	r3, [r5, #120]	; 0x78
		conn_lll->max_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
 100076c:	f8c5 e05c 	str.w	lr, [r5, #92]	; 0x5c
		conn_lll->rssi_latest = 0x7F;
 1000770:	f885 c0c1 	strb.w	ip, [r5, #193]	; 0xc1
		conn->connect_expire = 6;
 1000774:	f8a5 00c4 	strh.w	r0, [r5, #196]	; 0xc4
		conn_lll->max_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M);
 1000778:	6629      	str	r1, [r5, #96]	; 0x60
		conn->llcp_feature.features = LL_FEAT;
 100077a:	f8c5 211c 	str.w	r2, [r5, #284]	; 0x11c
		conn->llcp_terminate.node_rx.hdr.link = link;
 100077e:	f8c5 a12c 	str.w	sl, [r5, #300]	; 0x12c
		conn_lll->packet_tx_head_len = 0;
 1000782:	f8a5 307c 	strh.w	r3, [r5, #124]	; 0x7c
		conn->llcp_conn_param.disabled = 0;
 1000786:	f895 c172 	ldrb.w	ip, [r5, #370]	; 0x172
		conn->llcp_length.disabled = 0U;
 100078a:	f895 019a 	ldrb.w	r0, [r5, #410]	; 0x19a
		conn_lll->sn = 0;
 100078e:	f895 107e 	ldrb.w	r1, [r5, #126]	; 0x7e
		conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
 1000792:	f895 2152 	ldrb.w	r2, [r5, #338]	; 0x152
		conn->llcp_conn_param.disabled = 0;
 1000796:	f363 1c04 	bfi	ip, r3, #4, #1
		conn->llcp_length.disabled = 0U;
 100079a:	f363 00c3 	bfi	r0, r3, #3, #1
		conn_lll->sn = 0;
 100079e:	f021 011f 	bic.w	r1, r1, #31
		conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
 10007a2:	f022 0207 	bic.w	r2, r2, #7
		conn->llcp_enc.req = conn->llcp_enc.ack = 0U;
 10007a6:	f8a5 3150 	strh.w	r3, [r5, #336]	; 0x150
		conn->llcp_conn_param.req = 0;
 10007aa:	f8a5 3170 	strh.w	r3, [r5, #368]	; 0x170
		conn->llcp_length.req = conn->llcp_length.ack = 0U;
 10007ae:	f8a5 3198 	strh.w	r3, [r5, #408]	; 0x198
		conn->llcp_length.cache.tx_octets = 0U;
 10007b2:	f8a5 31a4 	strh.w	r3, [r5, #420]	; 0x1a4
		conn->llcp_conn_param.disabled = 0;
 10007b6:	f885 c172 	strb.w	ip, [r5, #370]	; 0x172
		conn_lll->sn = 0;
 10007ba:	f885 107e 	strb.w	r1, [r5, #126]	; 0x7e
		conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
 10007be:	f885 2152 	strb.w	r2, [r5, #338]	; 0x152
		conn->llcp_length.disabled = 0U;
 10007c2:	f885 019a 	strb.w	r0, [r5, #410]	; 0x19a
		conn->default_tx_octets = ull_conn_default_tx_octets_get();
 10007c6:	f00b faf1 	bl	100bdac <ull_conn_default_tx_octets_get>
 10007ca:	f8a5 00d6 	strh.w	r0, [r5, #214]	; 0xd6
		conn->default_tx_time = ull_conn_default_tx_time_get();
 10007ce:	f00b faf3 	bl	100bdb8 <ull_conn_default_tx_time_get>
		conn->llcp_phy.req = conn->llcp_phy.ack = 0;
 10007d2:	f8d5 11a8 	ldr.w	r1, [r5, #424]	; 0x1a8
 10007d6:	4a6e      	ldr	r2, [pc, #440]	; (1000990 <ll_adv_enable+0x5b0>)
		conn->default_tx_time = ull_conn_default_tx_time_get();
 10007d8:	f8a5 00d8 	strh.w	r0, [r5, #216]	; 0xd8
		conn->llcp_phy.req = conn->llcp_phy.ack = 0;
 10007dc:	400a      	ands	r2, r1
 10007de:	f8c5 21a8 	str.w	r2, [r5, #424]	; 0x1a8
		conn->phy_pref_tx = ull_conn_default_phy_tx_get();
 10007e2:	f00b faef 	bl	100bdc4 <ull_conn_default_phy_tx_get>
 10007e6:	f895 21ac 	ldrb.w	r2, [r5, #428]	; 0x1ac
 10007ea:	f360 0202 	bfi	r2, r0, #0, #3
 10007ee:	f885 21ac 	strb.w	r2, [r5, #428]	; 0x1ac
		conn->phy_pref_rx = ull_conn_default_phy_rx_get();
 10007f2:	f00b faed 	bl	100bdd0 <ull_conn_default_phy_rx_get>
		lll->conn = conn_lll;
 10007f6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		adv->node_rx_cc_free = node_rx;
 10007f8:	e9c4 ab34 	strd	sl, fp, [r4, #208]	; 0xd0
		lll->conn = conn_lll;
 10007fc:	6263      	str	r3, [r4, #36]	; 0x24
	hdr->is_stop = 0U;
 10007fe:	2300      	movs	r3, #0
		conn->phy_pref_flags = 0;
 1000800:	f895 11ac 	ldrb.w	r1, [r5, #428]	; 0x1ac
 1000804:	0102      	lsls	r2, r0, #4
 1000806:	f895 0020 	ldrb.w	r0, [r5, #32]
 100080a:	f002 0270 	and.w	r2, r2, #112	; 0x70
 100080e:	f021 0178 	bic.w	r1, r1, #120	; 0x78
 1000812:	430a      	orrs	r2, r1
 1000814:	f363 0000 	bfi	r0, r3, #0, #1
		conn->tx_data = conn->tx_data_last = 0;
 1000818:	e9c5 336f 	strd	r3, r3, [r5, #444]	; 0x1bc
		conn->tx_head = conn->tx_ctrl = conn->tx_ctrl_last =
 100081c:	e9c5 336d 	strd	r3, r3, [r5, #436]	; 0x1b4
 1000820:	e9c5 3305 	strd	r3, r3, [r5, #20]
 1000824:	f8c5 31b0 	str.w	r3, [r5, #432]	; 0x1b0
	hdr->parent = parent;
 1000828:	61ed      	str	r5, [r5, #28]
		conn->phy_pref_flags = 0;
 100082a:	f885 21ac 	strb.w	r2, [r5, #428]	; 0x1ac
	hdr->is_stop = 0U;
 100082e:	f885 0020 	strb.w	r0, [r5, #32]
		err = lll_clock_wait();
 1000832:	f00f fc8f 	bl	1010154 <lll_clock_wait>
		if (err) {
 1000836:	2800      	cmp	r0, #0
 1000838:	f43f ae43 	beq.w	10004c2 <ll_adv_enable+0xe2>
			conn_release(adv);
 100083c:	f00a f854 	bl	100a8e8 <conn_release.constprop.0>
			return BT_HCI_ERR_HW_FAILURE;
 1000840:	f04f 0803 	mov.w	r8, #3
 1000844:	e616      	b.n	1000474 <ll_adv_enable+0x94>
				ull_filter_rpa_update(false);
 1000846:	4640      	mov	r0, r8
 1000848:	f00e fc44 	bl	100f0d4 <ull_filter_rpa_update>
 100084c:	e622      	b.n	1000494 <ll_adv_enable+0xb4>
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
 100084e:	2791      	movs	r7, #145	; 0x91
 1000850:	a34b      	add	r3, pc, #300	; (adr r3, 1000980 <ll_adv_enable+0x5a0>)
 1000852:	e9d3 2300 	ldrd	r2, r3, [r3]
		ret = ticker_start_ext(
 1000856:	f64f 7cff 	movw	ip, #65535	; 0xffff
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
 100085a:	484e      	ldr	r0, [pc, #312]	; (1000994 <ll_adv_enable+0x5b4>)
		ll_adv_ticker_ext[handle].ticks_slot_window =
 100085c:	f8df e148 	ldr.w	lr, [pc, #328]	; 10009a8 <ll_adv_enable+0x5c8>
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
 1000860:	fba9 0100 	umull	r0, r1, r9, r0
 1000864:	fb07 1109 	mla	r1, r7, r9, r1
		const u32_t ticks_slot = adv->evt.ticks_slot +
 1000868:	68e7      	ldr	r7, [r4, #12]
		ret = ticker_start_ext(
 100086a:	9406      	str	r4, [sp, #24]
 100086c:	9704      	str	r7, [sp, #16]
			ULL_ADV_RANDOM_DELAY + ticks_slot;
 100086e:	f207 1747 	addw	r7, r7, #327	; 0x147
		ret = ticker_start_ext(
 1000872:	9502      	str	r5, [sp, #8]
		ll_adv_ticker_ext[handle].ticks_slot_window =
 1000874:	f8ce 7000 	str.w	r7, [lr]
		ret = ticker_start_ext(
 1000878:	4f47      	ldr	r7, [pc, #284]	; (1000998 <ll_adv_enable+0x5b8>)
 100087a:	f8cd c00c 	str.w	ip, [sp, #12]
 100087e:	f8df c12c 	ldr.w	ip, [pc, #300]	; 10009ac <ll_adv_enable+0x5cc>
 1000882:	9707      	str	r7, [sp, #28]
 1000884:	af0c      	add	r7, sp, #48	; 0x30
 1000886:	f8cd e024 	str.w	lr, [sp, #36]	; 0x24
 100088a:	f8cd c014 	str.w	ip, [sp, #20]
 100088e:	9708      	str	r7, [sp, #32]
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
 1000890:	f7ff fc12 	bl	10000b8 <__aeabi_uldivmod>
		ret = ticker_start_ext(
 1000894:	4633      	mov	r3, r6
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
 1000896:	e9cd 5000 	strd	r5, r0, [sp]
		ret = ticker_start_ext(
 100089a:	2202      	movs	r2, #2
 100089c:	4628      	mov	r0, r5
 100089e:	2103      	movs	r1, #3
 10008a0:	f006 fc90 	bl	10071c4 <ticker_start_ext>
	ret = ull_ticker_status_take(ret, &ret_cb);
 10008a4:	4639      	mov	r1, r7
 10008a6:	f009 fcd9 	bl	100a25c <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
 10008aa:	2800      	cmp	r0, #0
 10008ac:	f47f ae84 	bne.w	10005b8 <ll_adv_enable+0x1d8>
	adv->is_enabled = 1;
 10008b0:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
 10008b4:	f043 0301 	orr.w	r3, r3, #1
 10008b8:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
	if (IS_ENABLED(CONFIG_BT_OBSERVER) && !ull_scan_is_enabled_get(0)) {
 10008bc:	f00a fb46 	bl	100af4c <ull_scan_is_enabled_get>
 10008c0:	2800      	cmp	r0, #0
 10008c2:	f47f aed2 	bne.w	100066a <ll_adv_enable+0x28a>
		ull_filter_adv_scan_state_cb(BIT(0));
 10008c6:	2001      	movs	r0, #1
 10008c8:	f00e fb1c 	bl	100ef04 <ull_filter_adv_scan_state_cb>
 10008cc:	e5d2      	b.n	1000474 <ll_adv_enable+0x94>
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 10008ce:	f24a 31d8 	movw	r1, #41944	; 0xa3d8
		ret_cb = TICKER_STATUS_BUSY;
 10008d2:	f04f 0c02 	mov.w	ip, #2
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 10008d6:	4a31      	ldr	r2, [pc, #196]	; (100099c <ll_adv_enable+0x5bc>)
 10008d8:	9100      	str	r1, [sp, #0]
 10008da:	9205      	str	r2, [sp, #20]
 10008dc:	4633      	mov	r3, r6
 10008de:	2201      	movs	r2, #1
 10008e0:	2103      	movs	r1, #3
 10008e2:	e9cd 5707 	strd	r5, r7, [sp, #28]
 10008e6:	e9cd 0003 	strd	r0, r0, [sp, #12]
 10008ea:	e9cd 0001 	strd	r0, r0, [sp, #4]
 10008ee:	9406      	str	r4, [sp, #24]
		ret_cb = TICKER_STATUS_BUSY;
 10008f0:	f8cd c030 	str.w	ip, [sp, #48]	; 0x30
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 10008f4:	f006 fcb4 	bl	1007260 <ticker_start>
 10008f8:	e7d4      	b.n	10008a4 <ll_adv_enable+0x4c4>
			return BT_HCI_ERR_INVALID_PARAM;
 10008fa:	f04f 0812 	mov.w	r8, #18
 10008fe:	e5b9      	b.n	1000474 <ll_adv_enable+0x94>
			} else if (pdu_adv->type == PDU_ADV_TYPE_SCAN_IND) {
 1000900:	2a06      	cmp	r2, #6
 1000902:	f43f adfa 	beq.w	10004fa <ll_adv_enable+0x11a>
 1000906:	f44f 73da 	mov.w	r3, #436	; 0x1b4
 100090a:	f44f 721b 	mov.w	r2, #620	; 0x26c
 100090e:	e5fb      	b.n	1000508 <ll_adv_enable+0x128>
 1000910:	f44f 73f2 	mov.w	r3, #484	; 0x1e4
 1000914:	f44f 727f 	mov.w	r2, #1020	; 0x3fc
 1000918:	e5f6      	b.n	1000508 <ll_adv_enable+0x128>
	LL_ASSERT(!ret);
 100091a:	f44f 61a1 	mov.w	r1, #1288	; 0x508
 100091e:	4820      	ldr	r0, [pc, #128]	; (10009a0 <ll_adv_enable+0x5c0>)
 1000920:	f002 feae 	bl	1003680 <bt_ctlr_assert_handle>
 1000924:	e686      	b.n	1000634 <ll_adv_enable+0x254>
			conn_lll->link_tx_free = &conn_lll->link_tx;
 1000926:	f105 0070 	add.w	r0, r5, #112	; 0x70
 100092a:	67a8      	str	r0, [r5, #120]	; 0x78
 100092c:	e6d0      	b.n	10006d0 <ll_adv_enable+0x2f0>
			return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
 100092e:	f04f 0807 	mov.w	r8, #7
 1000932:	e59f      	b.n	1000474 <ll_adv_enable+0x94>
		mark = ull_disable_mark(adv);
 1000934:	481b      	ldr	r0, [pc, #108]	; (10009a4 <ll_adv_enable+0x5c4>)
 1000936:	f009 fc9f 	bl	100a278 <ull_disable_mark>
		LL_ASSERT(mark == adv);
 100093a:	4284      	cmp	r4, r0
 100093c:	f43f ad98 	beq.w	1000470 <ll_adv_enable+0x90>
 1000940:	f240 5102 	movw	r1, #1282	; 0x502
 1000944:	4816      	ldr	r0, [pc, #88]	; (10009a0 <ll_adv_enable+0x5c0>)
 1000946:	f002 fe9b 	bl	1003680 <bt_ctlr_assert_handle>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100094a:	f04f 080c 	mov.w	r8, #12
 100094e:	e591      	b.n	1000474 <ll_adv_enable+0x94>
			ll_rx_release(node_rx);
 1000950:	4658      	mov	r0, fp
 1000952:	f009 fc0d 	bl	100a170 <ll_rx_release>
			ll_rx_link_release(link);
 1000956:	4650      	mov	r0, sl
 1000958:	f009 fbfe 	bl	100a158 <ll_rx_link_release>
			return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
 100095c:	f04f 0807 	mov.w	r8, #7
 1000960:	e588      	b.n	1000474 <ll_adv_enable+0x94>
			mark = ull_disable_mark(adv);
 1000962:	4810      	ldr	r0, [pc, #64]	; (10009a4 <ll_adv_enable+0x5c4>)
 1000964:	f009 fc88 	bl	100a278 <ull_disable_mark>
			LL_ASSERT(mark == adv);
 1000968:	4284      	cmp	r4, r0
 100096a:	f43f ad81 	beq.w	1000470 <ll_adv_enable+0x90>
 100096e:	f240 41f3 	movw	r1, #1267	; 0x4f3
 1000972:	480b      	ldr	r0, [pc, #44]	; (10009a0 <ll_adv_enable+0x5c0>)
 1000974:	f002 fe84 	bl	1003680 <bt_ctlr_assert_handle>
 1000978:	f04f 080c 	mov.w	r8, #12
 100097c:	e57a      	b.n	1000474 <ll_adv_enable+0x94>
 100097e:	bf00      	nop
 1000980:	1afd498d 	.word	0x1afd498d
 1000984:	00000007 	.word	0x00000007
 1000988:	01480148 	.word	0x01480148
 100098c:	000149ff 	.word	0x000149ff
 1000990:	f6ff0000 	.word	0xf6ff0000
 1000994:	84e72a00 	.word	0x84e72a00
 1000998:	0100a251 	.word	0x0100a251
 100099c:	0100a799 	.word	0x0100a799
 10009a0:	01018890 	.word	0x01018890
 10009a4:	21002a60 	.word	0x21002a60
 10009a8:	21002b44 	.word	0x21002b44
 10009ac:	0100a7f9 	.word	0x0100a7f9

010009b0 <ll_scan_params_set>:
#define BT_CTLR_SCAN_MAX 1
static struct ll_scan_set ll_scan[BT_CTLR_SCAN_MAX];

u8_t ll_scan_params_set(u8_t type, u16_t interval, u16_t window,
			u8_t own_addr_type, u8_t filter_policy)
{
 10009b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
struct ll_scan_set *ull_scan_is_disabled_get(u16_t handle)
{
	struct ll_scan_set *scan;

	scan = ull_scan_set_get(handle);
	if (!scan || scan->is_enabled) {
 10009b4:	4d1a      	ldr	r5, [pc, #104]	; (1000a20 <ll_scan_params_set+0x70>)
{
 10009b6:	f89d 4018 	ldrb.w	r4, [sp, #24]
	if (!scan || scan->is_enabled) {
 10009ba:	f895 7048 	ldrb.w	r7, [r5, #72]	; 0x48
 10009be:	f017 0601 	ands.w	r6, r7, #1
 10009c2:	d123      	bne.n	1000a0c <ll_scan_params_set+0x5c>
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
 10009c4:	f04f 0891 	mov.w	r8, #145	; 0x91
 10009c8:	4686      	mov	lr, r0
 10009ca:	468c      	mov	ip, r1
 10009cc:	4815      	ldr	r0, [pc, #84]	; (1000a24 <ll_scan_params_set+0x74>)
	lll->filter_policy = filter_policy;
 10009ce:	00e4      	lsls	r4, r4, #3
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
 10009d0:	fba2 0100 	umull	r0, r1, r2, r0
 10009d4:	fb08 1102 	mla	r1, r8, r2, r1
	lll->filter_policy = filter_policy;
 10009d8:	f895 2032 	ldrb.w	r2, [r5, #50]	; 0x32
 10009dc:	f004 0418 	and.w	r4, r4, #24
 10009e0:	ea44 14ce 	orr.w	r4, r4, lr, lsl #7
	scan->own_addr_type = own_addr_type;
 10009e4:	f363 0742 	bfi	r7, r3, #1, #2
	lll->filter_policy = filter_policy;
 10009e8:	f002 0367 	and.w	r3, r2, #103	; 0x67
 10009ec:	431c      	orrs	r4, r3
	scan->own_addr_type = own_addr_type;
 10009ee:	f885 7048 	strb.w	r7, [r5, #72]	; 0x48
	lll->interval = interval;
 10009f2:	f8a5 c042 	strh.w	ip, [r5, #66]	; 0x42
	lll->filter_policy = filter_policy;
 10009f6:	f885 4032 	strb.w	r4, [r5, #50]	; 0x32
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
 10009fa:	a307      	add	r3, pc, #28	; (adr r3, 1000a18 <ll_scan_params_set+0x68>)
 10009fc:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000a00:	f7ff fb5a 	bl	10000b8 <__aeabi_uldivmod>
 1000a04:	6468      	str	r0, [r5, #68]	; 0x44
}
 1000a06:	4630      	mov	r0, r6
 1000a08:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 1000a0c:	260c      	movs	r6, #12
}
 1000a0e:	4630      	mov	r0, r6
 1000a10:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 1000a14:	f3af 8000 	nop.w
 1000a18:	1afd498d 	.word	0x1afd498d
 1000a1c:	00000007 	.word	0x00000007
 1000a20:	21002b68 	.word	0x21002b68
 1000a24:	84e72a00 	.word	0x84e72a00

01000a28 <ull_scan_params_set>:
{
 1000a28:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1000a2a:	461e      	mov	r6, r3
 1000a2c:	4605      	mov	r5, r0
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
 1000a2e:	f04f 0e91 	mov.w	lr, #145	; 0x91
{
 1000a32:	468c      	mov	ip, r1
 1000a34:	4617      	mov	r7, r2
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
 1000a36:	a30d      	add	r3, pc, #52	; (adr r3, 1000a6c <ull_scan_params_set+0x44>)
 1000a38:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000a3c:	480a      	ldr	r0, [pc, #40]	; (1000a68 <ull_scan_params_set+0x40>)
{
 1000a3e:	f89d 4018 	ldrb.w	r4, [sp, #24]
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
 1000a42:	fba6 0100 	umull	r0, r1, r6, r0
	lll->filter_policy = filter_policy;
 1000a46:	00e4      	lsls	r4, r4, #3
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
 1000a48:	fb0e 1106 	mla	r1, lr, r6, r1
	lll->filter_policy = filter_policy;
 1000a4c:	7dae      	ldrb	r6, [r5, #22]
 1000a4e:	f004 0418 	and.w	r4, r4, #24
 1000a52:	ea44 14cc 	orr.w	r4, r4, ip, lsl #7
 1000a56:	f006 0667 	and.w	r6, r6, #103	; 0x67
 1000a5a:	4334      	orrs	r4, r6
	lll->interval = interval;
 1000a5c:	84ef      	strh	r7, [r5, #38]	; 0x26
	lll->filter_policy = filter_policy;
 1000a5e:	75ac      	strb	r4, [r5, #22]
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
 1000a60:	f7ff fb2a 	bl	10000b8 <__aeabi_uldivmod>
 1000a64:	62a8      	str	r0, [r5, #40]	; 0x28
}
 1000a66:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 1000a68:	84e72a00 	.word	0x84e72a00
 1000a6c:	1afd498d 	.word	0x1afd498d
 1000a70:	00000007 	.word	0x00000007
 1000a74:	00000000 	.word	0x00000000

01000a78 <ull_scan_enable>:
{
 1000a78:	e92d 4df0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, fp, lr}
 1000a7c:	4604      	mov	r4, r0
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 1000a7e:	2202      	movs	r2, #2
	lll->chan = 0;
 1000a80:	f890 3032 	ldrb.w	r3, [r0, #50]	; 0x32
	lll->init_addr_type = scan->own_addr_type;
 1000a84:	f890 0048 	ldrb.w	r0, [r0, #72]	; 0x48
 1000a88:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 1000a8c:	f3c0 0040 	ubfx	r0, r0, #1, #1
 1000a90:	f360 1386 	bfi	r3, r0, #6, #1
 1000a94:	2500      	movs	r5, #0
{
 1000a96:	b08e      	sub	sp, #56	; 0x38
	lll->init_addr_type = scan->own_addr_type;
 1000a98:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
	ll_addr_get(lll->init_addr_type, lll->init_addr);
 1000a9c:	f104 0135 	add.w	r1, r4, #53	; 0x35
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 1000aa0:	920b      	str	r2, [sp, #44]	; 0x2c
	ll_addr_get(lll->init_addr_type, lll->init_addr);
 1000aa2:	f006 fc83 	bl	10073ac <ll_addr_get>
	ticks_interval = HAL_TICKER_US_TO_TICKS((u64_t)lll->interval * 625U);
 1000aa6:	2391      	movs	r3, #145	; 0x91
 1000aa8:	f8b4 7042 	ldrh.w	r7, [r4, #66]	; 0x42
 1000aac:	4848      	ldr	r0, [pc, #288]	; (1000bd0 <ull_scan_enable+0x158>)
 1000aae:	f894 6020 	ldrb.w	r6, [r4, #32]
 1000ab2:	fba7 0100 	umull	r0, r1, r7, r0
 1000ab6:	f365 0600 	bfi	r6, r5, #0, #1
 1000aba:	fb03 1107 	mla	r1, r3, r7, r1
 1000abe:	a342      	add	r3, pc, #264	; (adr r3, 1000bc8 <ull_scan_enable+0x150>)
 1000ac0:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000ac4:	e9c4 5505 	strd	r5, r5, [r4, #20]
 1000ac8:	f884 6020 	strb.w	r6, [r4, #32]
	hdr->parent = parent;
 1000acc:	61e4      	str	r4, [r4, #28]
 1000ace:	f7ff faf3 	bl	10000b8 <__aeabi_uldivmod>
 1000ad2:	4606      	mov	r6, r0
	scan->evt.ticks_xtal_to_start =
 1000ad4:	2131      	movs	r1, #49	; 0x31
	if ((lll->ticks_window +
 1000ad6:	6c63      	ldr	r3, [r4, #68]	; 0x44
	    (ticks_interval -
 1000ad8:	f1a6 0231 	sub.w	r2, r6, #49	; 0x31
	if ((lll->ticks_window +
 1000adc:	3309      	adds	r3, #9
 1000ade:	4293      	cmp	r3, r2
	scan->evt.ticks_preempt_to_start =
 1000ae0:	e9c4 5501 	strd	r5, r5, [r4, #4]
		lll->ticks_window = 0;
 1000ae4:	bf28      	it	cs
 1000ae6:	6465      	strcs	r5, [r4, #68]	; 0x44
	scan->evt.ticks_xtal_to_start =
 1000ae8:	6021      	str	r1, [r4, #0]
		scan->evt.ticks_slot =
 1000aea:	bf34      	ite	cc
 1000aec:	60e3      	strcc	r3, [r4, #12]
		scan->evt.ticks_slot =
 1000aee:	60e2      	strcs	r2, [r4, #12]
	ticks_anchor = ticker_ticks_now_get();
 1000af0:	f006 fc56 	bl	10073a0 <ticker_ticks_now_get>
	if (!lll->conn) {
 1000af4:	6a67      	ldr	r7, [r4, #36]	; 0x24
	ticks_anchor = ticker_ticks_now_get();
 1000af6:	4605      	mov	r5, r0
	if (!lll->conn) {
 1000af8:	2f00      	cmp	r7, #0
 1000afa:	d042      	beq.n	1000b82 <ull_scan_enable+0x10a>
			   HAL_TICKER_REMAINDER((u64_t)lll->interval * 625U),
 1000afc:	a332      	add	r3, pc, #200	; (adr r3, 1000bc8 <ull_scan_enable+0x150>)
 1000afe:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000b02:	2791      	movs	r7, #145	; 0x91
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000b04:	f04f 0800 	mov.w	r8, #0
			   HAL_TICKER_REMAINDER((u64_t)lll->interval * 625U),
 1000b08:	f8b4 a042 	ldrh.w	sl, [r4, #66]	; 0x42
 1000b0c:	4830      	ldr	r0, [pc, #192]	; (1000bd0 <ull_scan_enable+0x158>)
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000b0e:	9406      	str	r4, [sp, #24]
			   HAL_TICKER_REMAINDER((u64_t)lll->interval * 625U),
 1000b10:	fbaa 0100 	umull	r0, r1, sl, r0
 1000b14:	fb07 110a 	mla	r1, r7, sl, r1
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000b18:	4f2e      	ldr	r7, [pc, #184]	; (1000bd4 <ull_scan_enable+0x15c>)
 1000b1a:	f8cd 800c 	str.w	r8, [sp, #12]
 1000b1e:	9707      	str	r7, [sp, #28]
 1000b20:	68e7      	ldr	r7, [r4, #12]
 1000b22:	f8df c0b8 	ldr.w	ip, [pc, #184]	; 1000bdc <ull_scan_enable+0x164>
 1000b26:	e9cd 7c04 	strd	r7, ip, [sp, #16]
 1000b2a:	af0b      	add	r7, sp, #44	; 0x2c
 1000b2c:	9708      	str	r7, [sp, #32]
			   HAL_TICKER_REMAINDER((u64_t)lll->interval * 625U),
 1000b2e:	f7ff fac3 	bl	10000b8 <__aeabi_uldivmod>
 1000b32:	4610      	mov	r0, r2
 1000b34:	4619      	mov	r1, r3
 1000b36:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 1000b3a:	2300      	movs	r3, #0
 1000b3c:	f7ff fabc 	bl	10000b8 <__aeabi_uldivmod>
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000b40:	462b      	mov	r3, r5
 1000b42:	2204      	movs	r2, #4
 1000b44:	2103      	movs	r1, #3
 1000b46:	9002      	str	r0, [sp, #8]
 1000b48:	f8cd 8000 	str.w	r8, [sp]
 1000b4c:	4640      	mov	r0, r8
 1000b4e:	9601      	str	r6, [sp, #4]
 1000b50:	f006 fb86 	bl	1007260 <ticker_start>
	ret = ull_ticker_status_take(ret, &ret_cb);
 1000b54:	4639      	mov	r1, r7
 1000b56:	f009 fb81 	bl	100a25c <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
 1000b5a:	4605      	mov	r5, r0
 1000b5c:	b968      	cbnz	r0, 1000b7a <ull_scan_enable+0x102>
	scan->is_enabled = 1U;
 1000b5e:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 1000b62:	f043 0301 	orr.w	r3, r3, #1
 1000b66:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
	if (!ull_adv_is_enabled_get(0))
 1000b6a:	f00a f8af 	bl	100accc <ull_adv_is_enabled_get>
 1000b6e:	4604      	mov	r4, r0
 1000b70:	b300      	cbz	r0, 1000bb4 <ull_scan_enable+0x13c>
	return 0;
 1000b72:	4628      	mov	r0, r5
}
 1000b74:	b00e      	add	sp, #56	; 0x38
 1000b76:	e8bd 8df0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, fp, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 1000b7a:	200c      	movs	r0, #12
}
 1000b7c:	b00e      	add	sp, #56	; 0x38
 1000b7e:	e8bd 8df0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, fp, pc}
		ull_sched_after_mstr_slot_get(TICKER_USER_ID_THREAD,
 1000b82:	68e1      	ldr	r1, [r4, #12]
 1000b84:	2003      	movs	r0, #3
 1000b86:	3131      	adds	r1, #49	; 0x31
 1000b88:	ab0d      	add	r3, sp, #52	; 0x34
 1000b8a:	aa0c      	add	r2, sp, #48	; 0x30
		u32_t offset_us = 0U;
 1000b8c:	e9cd 770c 	strd	r7, r7, [sp, #48]	; 0x30
		ull_sched_after_mstr_slot_get(TICKER_USER_ID_THREAD,
 1000b90:	f00d ffee 	bl	100eb70 <ull_sched_after_mstr_slot_get>
		if (offset_us) {
 1000b94:	990d      	ldr	r1, [sp, #52]	; 0x34
 1000b96:	2900      	cmp	r1, #0
 1000b98:	d0b0      	beq.n	1000afc <ull_scan_enable+0x84>
				       HAL_TICKER_US_TO_TICKS(offset_us);
 1000b9a:	a30b      	add	r3, pc, #44	; (adr r3, 1000bc8 <ull_scan_enable+0x150>)
 1000b9c:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000ba0:	480d      	ldr	r0, [pc, #52]	; (1000bd8 <ull_scan_enable+0x160>)
 1000ba2:	fba1 0100 	umull	r0, r1, r1, r0
 1000ba6:	f7ff fa87 	bl	10000b8 <__aeabi_uldivmod>
			ticks_anchor = ticks_ref +
 1000baa:	9d0c      	ldr	r5, [sp, #48]	; 0x30
				       HAL_TICKER_US_TO_TICKS(offset_us);
 1000bac:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			ticks_anchor = ticks_ref +
 1000bb0:	4405      	add	r5, r0
 1000bb2:	e7a3      	b.n	1000afc <ull_scan_enable+0x84>
		ull_filter_adv_scan_state_cb(BIT(1));
 1000bb4:	2002      	movs	r0, #2
 1000bb6:	f00e f9a5 	bl	100ef04 <ull_filter_adv_scan_state_cb>
	return 0;
 1000bba:	4620      	mov	r0, r4
}
 1000bbc:	b00e      	add	sp, #56	; 0x38
 1000bbe:	e8bd 8df0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, fp, pc}
 1000bc2:	bf00      	nop
 1000bc4:	f3af 8000 	nop.w
 1000bc8:	1afd498d 	.word	0x1afd498d
 1000bcc:	00000007 	.word	0x00000007
 1000bd0:	84e72a00 	.word	0x84e72a00
 1000bd4:	0100a251 	.word	0x0100a251
 1000bd8:	3b9aca00 	.word	0x3b9aca00
 1000bdc:	0100ad21 	.word	0x0100ad21

01000be0 <ull_conn_llcp>:
	return 0;
}

int ull_conn_llcp(struct ll_conn *conn, u32_t ticks_at_expire, u16_t lazy)
{
	LL_ASSERT(conn->lll.handle != 0xFFFF);
 1000be0:	f64f 73ff 	movw	r3, #65535	; 0xffff
{
 1000be4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	LL_ASSERT(conn->lll.handle != 0xFFFF);
 1000be8:	8d87      	ldrh	r7, [r0, #44]	; 0x2c
{
 1000bea:	4604      	mov	r4, r0
	LL_ASSERT(conn->lll.handle != 0xFFFF);
 1000bec:	429f      	cmp	r7, r3
{
 1000bee:	460e      	mov	r6, r1
 1000bf0:	4615      	mov	r5, r2
 1000bf2:	b08d      	sub	sp, #52	; 0x34
	LL_ASSERT(conn->lll.handle != 0xFFFF);
 1000bf4:	f000 808b 	beq.w	1000d0e <ull_conn_llcp+0x12e>

	/* Check if no other procedure with instant is requested and not in
	 * Encryption setup.
	 */
	if ((conn->llcp_ack == conn->llcp_req) &&
 1000bf8:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
 1000bfc:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 1000c00:	429a      	cmp	r2, r3
 1000c02:	d00e      	beq.n	1000c22 <ull_conn_llcp+0x42>
	}

	/* Check if procedures with instant or encryption setup is requested or
	 * active.
	 */
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
 1000c04:	1a9b      	subs	r3, r3, r2
 1000c06:	f003 0303 	and.w	r3, r3, #3
 1000c0a:	2b02      	cmp	r3, #2
 1000c0c:	d01b      	beq.n	1000c46 <ull_conn_llcp+0x66>
			break;
		}
	}

	/* Terminate Procedure Request */
	if (conn->llcp_terminate.ack != conn->llcp_terminate.req) {
 1000c0e:	f894 2129 	ldrb.w	r2, [r4, #297]	; 0x129
 1000c12:	f894 3128 	ldrb.w	r3, [r4, #296]	; 0x128
 1000c16:	429a      	cmp	r2, r3
 1000c18:	d130      	bne.n	1000c7c <ull_conn_llcp+0x9c>
				conn->procedure_expire++;
			}
		}
	}

	return 0;
 1000c1a:	2000      	movs	r0, #0
}
 1000c1c:	b00d      	add	sp, #52	; 0x34
 1000c1e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	    !conn->llcp_enc.pause_rx) {
 1000c22:	f894 0152 	ldrb.w	r0, [r4, #338]	; 0x152
	if ((conn->llcp_ack == conn->llcp_req) &&
 1000c26:	f010 0801 	ands.w	r8, r0, #1
 1000c2a:	d1f0      	bne.n	1000c0e <ull_conn_llcp+0x2e>
		if (conn->llcp_cu.ack != conn->llcp_cu.req) {
 1000c2c:	f894 1105 	ldrb.w	r1, [r4, #261]	; 0x105
 1000c30:	f894 7104 	ldrb.w	r7, [r4, #260]	; 0x104
 1000c34:	428f      	cmp	r7, r1
 1000c36:	f000 836f 	beq.w	1001318 <ull_conn_llcp+0x738>
			conn->llcp_type = LLCP_CONN_UPD;
 1000c3a:	2101      	movs	r1, #1
			conn->llcp_ack -= 2U;
 1000c3c:	1e93      	subs	r3, r2, #2
 1000c3e:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
			conn->llcp_type = LLCP_CONN_UPD;
 1000c42:	f884 10ea 	strb.w	r1, [r4, #234]	; 0xea
		} else if (conn->llcp_length.ack != conn->llcp_length.req) {
 1000c46:	f894 3198 	ldrb.w	r3, [r4, #408]	; 0x198
 1000c4a:	f894 2199 	ldrb.w	r2, [r4, #409]	; 0x199
 1000c4e:	429a      	cmp	r2, r3
 1000c50:	d006      	beq.n	1000c60 <ull_conn_llcp+0x80>
			if ((conn->llcp_length.state ==
 1000c52:	f894 019a 	ldrb.w	r0, [r4, #410]	; 0x19a
 1000c56:	f000 0206 	and.w	r2, r0, #6
 1000c5a:	2a04      	cmp	r2, #4
 1000c5c:	f000 83a6 	beq.w	10013ac <ull_conn_llcp+0x7cc>
		switch (conn->llcp_type) {
 1000c60:	f894 70ea 	ldrb.w	r7, [r4, #234]	; 0xea
 1000c64:	1e7b      	subs	r3, r7, #1
 1000c66:	2b05      	cmp	r3, #5
 1000c68:	f200 8350 	bhi.w	100130c <ull_conn_llcp+0x72c>
 1000c6c:	e8df f013 	tbh	[pc, r3, lsl #1]
 1000c70:	02e70066 	.word	0x02e70066
 1000c74:	034e028e 	.word	0x034e028e
 1000c78:	01af0311 	.word	0x01af0311
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1000c7c:	482d      	ldr	r0, [pc, #180]	; (1000d34 <ull_conn_llcp+0x154>)
 1000c7e:	f005 f84b 	bl	1005d18 <mem_acquire>
		if (tx) {
 1000c82:	4603      	mov	r3, r0
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1000c84:	900b      	str	r0, [sp, #44]	; 0x2c
		if (tx) {
 1000c86:	b358      	cbz	r0, 1000ce0 <ull_conn_llcp+0x100>
			pdu_tx->len = offsetof(struct pdu_data_llctrl,
 1000c88:	2102      	movs	r1, #2
			conn->llcp_terminate.ack = conn->llcp_terminate.req;
 1000c8a:	f894 2128 	ldrb.w	r2, [r4, #296]	; 0x128
 1000c8e:	f884 2129 	strb.w	r2, [r4, #297]	; 0x129
			pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 1000c92:	7902      	ldrb	r2, [r0, #4]
			pdu_tx->len = offsetof(struct pdu_data_llctrl,
 1000c94:	7141      	strb	r1, [r0, #5]
			pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 1000c96:	f042 0203 	orr.w	r2, r2, #3
 1000c9a:	7102      	strb	r2, [r0, #4]
			pdu_tx->llctrl.opcode =
 1000c9c:	71c1      	strb	r1, [r0, #7]
			pdu_tx->llctrl.terminate_ind.error_code =
 1000c9e:	f894 112a 	ldrb.w	r1, [r4, #298]	; 0x12a
					 struct node_tx *tx, bool pause)
{
	/* check if a packet was tx-ed and not acked by peer */
	if (
	    /* data/ctrl packet is in the head */
	    conn->tx_head &&
 1000ca2:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
			pdu_tx->llctrl.terminate_ind.error_code =
 1000ca6:	7201      	strb	r1, [r0, #8]
	if (
 1000ca8:	b32a      	cbz	r2, 1000cf6 <ull_conn_llcp+0x116>
#if defined(CONFIG_BT_CTLR_LE_ENC)
	    !conn->llcp_enc.pause_tx &&
 1000caa:	f894 1152 	ldrb.w	r1, [r4, #338]	; 0x152
	    conn->tx_head &&
 1000cae:	0788      	lsls	r0, r1, #30
 1000cb0:	d421      	bmi.n	1000cf6 <ull_conn_llcp+0x116>
#endif /* CONFIG_BT_CTLR_LE_ENC */
#if defined(CONFIG_BT_CTLR_PHY)
	    !conn->llcp_phy.pause_tx &&
 1000cb2:	f894 11ab 	ldrb.w	r1, [r4, #427]	; 0x1ab
 1000cb6:	07c9      	lsls	r1, r1, #31
 1000cb8:	d41d      	bmi.n	1000cf6 <ull_conn_llcp+0x116>

		/* if data transmitted once, keep it at head of the tx list,
		 * as we will insert a ctrl after it, hence advance the
		 * data pointer
		 */
		if (conn->tx_head == conn->tx_data) {
 1000cba:	f8d4 11bc 	ldr.w	r1, [r4, #444]	; 0x1bc
 1000cbe:	428a      	cmp	r2, r1
			conn->tx_data = conn->tx_data->next;
 1000cc0:	bf04      	itt	eq
 1000cc2:	6811      	ldreq	r1, [r2, #0]
 1000cc4:	f8c4 11bc 	streq.w	r1, [r4, #444]	; 0x1bc
		}

		/* if no ctrl packet already queued, new ctrl added will be
		 * the ctrl pointer and is inserted after head.
		 */
		if (!conn->tx_ctrl) {
 1000cc8:	f8d4 11b4 	ldr.w	r1, [r4, #436]	; 0x1b4
 1000ccc:	b9b1      	cbnz	r1, 1000cfc <ull_conn_llcp+0x11c>
			tx->next = conn->tx_head->next;
 1000cce:	6811      	ldr	r1, [r2, #0]
 1000cd0:	6019      	str	r1, [r3, #0]
			conn->tx_head->next = tx;
 1000cd2:	6013      	str	r3, [r2, #0]
			 * control PDU in Encryption Procedure that is not
			 * implicitly paused, will set the control and control
			 * last marker.
			 */
			if (!pause) {
				conn->tx_ctrl = tx;
 1000cd4:	681a      	ldr	r2, [r3, #0]
				conn->tx_ctrl_last = tx;
 1000cd6:	e9c4 336d 	strd	r3, r3, [r4, #436]	; 0x1b4
			ctrl_tx_last_enqueue(conn, tx);
		}
	}

	/* Update last pointer if ctrl added at end of tx list */
	if (!tx->next) {
 1000cda:	b90a      	cbnz	r2, 1000ce0 <ull_conn_llcp+0x100>
		conn->tx_data_last = tx;
 1000cdc:	f8c4 31c0 	str.w	r3, [r4, #448]	; 0x1c0
		if (!conn->procedure_expire) {
 1000ce0:	f8b4 00cc 	ldrh.w	r0, [r4, #204]	; 0xcc
 1000ce4:	2800      	cmp	r0, #0
 1000ce6:	d198      	bne.n	1000c1a <ull_conn_llcp+0x3a>
			conn->procedure_expire = conn->supervision_reload;
 1000ce8:	f8b4 30c6 	ldrh.w	r3, [r4, #198]	; 0xc6
			if (conn->procedure_expire <= 1U) {
 1000cec:	2b01      	cmp	r3, #1
 1000cee:	d914      	bls.n	1000d1a <ull_conn_llcp+0x13a>
			conn->procedure_expire = conn->supervision_reload;
 1000cf0:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
 1000cf4:	e791      	b.n	1000c1a <ull_conn_llcp+0x3a>
		if (!conn->tx_ctrl) {
 1000cf6:	f8d4 11b4 	ldr.w	r1, [r4, #436]	; 0x1b4
 1000cfa:	b1a1      	cbz	r1, 1000d26 <ull_conn_llcp+0x146>
	tx->next = conn->tx_ctrl_last->next;
 1000cfc:	f8d4 21b8 	ldr.w	r2, [r4, #440]	; 0x1b8
 1000d00:	6811      	ldr	r1, [r2, #0]
 1000d02:	6019      	str	r1, [r3, #0]
	conn->tx_ctrl_last->next = tx;
 1000d04:	6013      	str	r3, [r2, #0]
	conn->tx_ctrl_last = tx;
 1000d06:	f8c4 31b8 	str.w	r3, [r4, #440]	; 0x1b8
 1000d0a:	681a      	ldr	r2, [r3, #0]
}
 1000d0c:	e7e5      	b.n	1000cda <ull_conn_llcp+0xfa>
	LL_ASSERT(conn->lll.handle != 0xFFFF);
 1000d0e:	f44f 7142 	mov.w	r1, #776	; 0x308
 1000d12:	4809      	ldr	r0, [pc, #36]	; (1000d38 <ull_conn_llcp+0x158>)
 1000d14:	f002 fcb4 	bl	1003680 <bt_ctlr_assert_handle>
 1000d18:	e76e      	b.n	1000bf8 <ull_conn_llcp+0x18>
				conn->procedure_expire++;
 1000d1a:	3301      	adds	r3, #1
 1000d1c:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
}
 1000d20:	b00d      	add	sp, #52	; 0x34
 1000d22:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			tx->next = conn->tx_head;
 1000d26:	601a      	str	r2, [r3, #0]
				conn->tx_ctrl = tx;
 1000d28:	e9c4 336c 	strd	r3, r3, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 1000d2c:	f8c4 31b8 	str.w	r3, [r4, #440]	; 0x1b8
 1000d30:	e7d3      	b.n	1000cda <ull_conn_llcp+0xfa>
 1000d32:	bf00      	nop
 1000d34:	21005288 	.word	0x21005288
 1000d38:	01018934 	.word	0x01018934
	struct ll_conn *conn_upd;
	u16_t instant_latency;
	u16_t event_counter;


	conn_upd = conn_upd_curr;
 1000d3c:	f8df 9444 	ldr.w	r9, [pc, #1092]	; 1001184 <ull_conn_llcp+0x5a4>

	/* set mutex */
	if (!conn_upd) {
 1000d40:	f8d9 3000 	ldr.w	r3, [r9]
 1000d44:	2b00      	cmp	r3, #0
 1000d46:	f000 84da 	beq.w	10016fe <ull_conn_llcp+0xb1e>
		conn_upd_curr = conn;
	}

	/* Calculate current event counter */
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
 1000d4a:	8ee7      	ldrh	r7, [r4, #54]	; 0x36
 1000d4c:	8e62      	ldrh	r2, [r4, #50]	; 0x32

	instant_latency = (event_counter - conn->llcp.conn_upd.instant) &
			  0xffff;
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
 1000d4e:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
 1000d52:	4417      	add	r7, r2
 1000d54:	442f      	add	r7, r5
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
 1000d56:	f013 0303 	ands.w	r3, r3, #3
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
 1000d5a:	b2bf      	uxth	r7, r7
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
 1000d5c:	f040 8378 	bne.w	1001450 <ull_conn_llcp+0x870>
	instant_latency = (event_counter - conn->llcp.conn_upd.instant) &
 1000d60:	f8b4 80ec 	ldrh.w	r8, [r4, #236]	; 0xec
 1000d64:	eba7 0208 	sub.w	r2, r7, r8
 1000d68:	fa1f fb82 	uxth.w	fp, r2
				    pdu_ctrl_tx, NULL, NULL);
#endif /* !CONFIG_BT_CTLR_SCHED_ADVANCED */

		ctrl_tx_enqueue(conn, tx);

	} else if (instant_latency <= 0x7FFF) {
 1000d6c:	0412      	lsls	r2, r2, #16
 1000d6e:	f53f af4e 	bmi.w	1000c0e <ull_conn_llcp+0x2e>
		u32_t ticker_status;
		u32_t periodic_us;
		u16_t latency;

		/* procedure request acked */
		conn->llcp_cu.ack = conn->llcp_cu.req;
 1000d72:	f894 2104 	ldrb.w	r2, [r4, #260]	; 0x104
		conn->llcp_ack = conn->llcp_req;

#if defined(CONFIG_BT_CTLR_CONN_PARAM_REQ)
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
 1000d76:	f894 1170 	ldrb.w	r1, [r4, #368]	; 0x170
		conn->llcp_cu.ack = conn->llcp_cu.req;
 1000d7a:	f884 2105 	strb.w	r2, [r4, #261]	; 0x105
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
 1000d7e:	f894 2171 	ldrb.w	r2, [r4, #369]	; 0x171
		conn->llcp_ack = conn->llcp_req;
 1000d82:	f894 00e8 	ldrb.w	r0, [r4, #232]	; 0xe8
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
 1000d86:	428a      	cmp	r2, r1
		conn->llcp_ack = conn->llcp_req;
 1000d88:	f884 00e9 	strb.w	r0, [r4, #233]	; 0xe9
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
 1000d8c:	d009      	beq.n	1000da2 <ull_conn_llcp+0x1c2>
		    (conn->llcp_conn_param.state == LLCP_CPR_STATE_UPD)) {
 1000d8e:	f894 2172 	ldrb.w	r2, [r4, #370]	; 0x172
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
 1000d92:	f002 0207 	and.w	r2, r2, #7
 1000d96:	2a05      	cmp	r2, #5
			conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
 1000d98:	bf04      	itt	eq
 1000d9a:	f884 1171 	strbeq.w	r1, [r4, #369]	; 0x171

			/* Stop procedure timeout */
			conn->procedure_expire = 0U;
 1000d9e:	f8a4 30cc 	strheq.w	r3, [r4, #204]	; 0xcc
		}
#endif /* CONFIG_BT_CTLR_CONN_PARAM_REQ */

		/* reset mutex */
		if (conn_upd_curr == conn) {
 1000da2:	f8d9 3000 	ldr.w	r3, [r9]
 1000da6:	429c      	cmp	r4, r3
			conn_upd_curr = NULL;
 1000da8:	bf04      	itt	eq
 1000daa:	2300      	moveq	r3, #0
 1000dac:	f8c9 3000 	streq.w	r3, [r9]
		}

		lll = &conn->lll;

		/* Acquire Rx node */
		rx = conn->llcp_rx;
 1000db0:	f8d4 9100 	ldr.w	r9, [r4, #256]	; 0x100
		LL_ASSERT(rx && rx->hdr.link);
 1000db4:	f1b9 0f00 	cmp.w	r9, #0
 1000db8:	f000 85cf 	beq.w	100195a <ull_conn_llcp+0xd7a>
 1000dbc:	f8d9 0000 	ldr.w	r0, [r9]
 1000dc0:	2800      	cmp	r0, #0
 1000dc2:	f000 85ca 	beq.w	100195a <ull_conn_llcp+0xd7a>
		conn->llcp_rx = rx->hdr.link->mem;

		/* Prepare the rx packet structure */
		if ((conn->llcp_cu.interval != lll->interval) ||
 1000dc6:	f8b4 c108 	ldrh.w	ip, [r4, #264]	; 0x108
 1000dca:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
		conn->llcp_rx = rx->hdr.link->mem;
 1000dcc:	6842      	ldr	r2, [r0, #4]
		if ((conn->llcp_cu.interval != lll->interval) ||
 1000dce:	459c      	cmp	ip, r3
 1000dd0:	f8b4 e10a 	ldrh.w	lr, [r4, #266]	; 0x10a
		conn->llcp_rx = rx->hdr.link->mem;
 1000dd4:	f8c4 2100 	str.w	r2, [r4, #256]	; 0x100
		if ((conn->llcp_cu.interval != lll->interval) ||
 1000dd8:	f000 86db 	beq.w	1001b92 <ull_conn_llcp+0xfb2>
 1000ddc:	f8b4 a10c 	ldrh.w	sl, [r4, #268]	; 0x10c
				       lll->interval * 1250) !=
		     conn->supervision_reload)) {
			struct node_rx_cu *cu;

			rx->hdr.handle = lll->handle;
			rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
 1000de0:	210a      	movs	r1, #10

			/* prepare connection update complete structure */
			cu = (void *)rx->pdu;
			cu->status = 0x00;
 1000de2:	2300      	movs	r3, #0
			rx->hdr.handle = lll->handle;
 1000de4:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
			rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
 1000de6:	f889 1004 	strb.w	r1, [r9, #4]
			rx->hdr.handle = lll->handle;
 1000dea:	f8a9 2006 	strh.w	r2, [r9, #6]
			cu->interval = conn->llcp_cu.interval;
 1000dee:	f8a9 c022 	strh.w	ip, [r9, #34]	; 0x22
			cu->latency = conn->llcp_cu.latency;
 1000df2:	f8a9 e024 	strh.w	lr, [r9, #36]	; 0x24
			cu->timeout = conn->llcp_cu.timeout;
 1000df6:	f8a9 a026 	strh.w	sl, [r9, #38]	; 0x26
			cu->status = 0x00;
 1000dfa:	f889 3020 	strb.w	r3, [r9, #32]
			/* Mark for buffer for release */
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
		}

		/* enqueue rx node towards Thread */
		ll_rx_put(rx->hdr.link, rx);
 1000dfe:	4649      	mov	r1, r9
 1000e00:	f009 f9bc 	bl	100a17c <ll_rx_put>
		ll_rx_sched();
 1000e04:	f009 f9c4 	bl	100a190 <ll_rx_sched>

#if defined(CONFIG_BT_CTLR_XTAL_ADVANCED)
		/* restore to normal prepare */
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
 1000e08:	6823      	ldr	r3, [r4, #0]
 1000e0a:	2b00      	cmp	r3, #0
 1000e0c:	da09      	bge.n	1000e22 <ull_conn_llcp+0x242>
			u32_t ticks_prepare_to_start =
 1000e0e:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
				MAX(conn->evt.ticks_active_to_start,
				    conn->evt.ticks_preempt_to_start);

			conn->evt.ticks_xtal_to_start &= ~XON_BITMASK;
			ticks_at_expire -= (conn->evt.ticks_xtal_to_start -
 1000e12:	428a      	cmp	r2, r1
 1000e14:	bf2c      	ite	cs
 1000e16:	18b6      	addcs	r6, r6, r2
 1000e18:	1876      	addcc	r6, r6, r1
			conn->evt.ticks_xtal_to_start &= ~XON_BITMASK;
 1000e1a:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 1000e1e:	6023      	str	r3, [r4, #0]
			ticks_at_expire -= (conn->evt.ticks_xtal_to_start -
 1000e20:	1af6      	subs	r6, r6, r3
					    ticks_prepare_to_start);
		}
#endif /* CONFIG_BT_CTLR_XTAL_ADVANCED */

		/* compensate for instant_latency due to laziness */
		conn_interval_old = instant_latency * lll->interval;
 1000e22:	8de1      	ldrh	r1, [r4, #46]	; 0x2e
		latency = conn_interval_old / conn->llcp_cu.interval;
 1000e24:	f8b4 9108 	ldrh.w	r9, [r4, #264]	; 0x108
		conn_interval_old = instant_latency * lll->interval;
 1000e28:	fb01 f10b 	mul.w	r1, r1, fp
 1000e2c:	b289      	uxth	r1, r1
		latency = conn_interval_old / conn->llcp_cu.interval;
 1000e2e:	fbb1 fcf9 	udiv	ip, r1, r9
		conn_interval_new = latency * conn->llcp_cu.interval;
 1000e32:	fb0c f009 	mul.w	r0, ip, r9
 1000e36:	b280      	uxth	r0, r0
		latency = conn_interval_old / conn->llcp_cu.interval;
 1000e38:	fa1f f38c 	uxth.w	r3, ip
		if (conn_interval_new > conn_interval_old) {
 1000e3c:	4281      	cmp	r1, r0
		latency = conn_interval_old / conn->llcp_cu.interval;
 1000e3e:	930b      	str	r3, [sp, #44]	; 0x2c
		if (conn_interval_new > conn_interval_old) {
 1000e40:	f080 8579 	bcs.w	1001936 <ull_conn_llcp+0xd56>
			ticks_at_expire += HAL_TICKER_US_TO_TICKS(
 1000e44:	a3c4      	add	r3, pc, #784	; (adr r3, 1001158 <ull_conn_llcp+0x578>)
 1000e46:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000e4a:	f240 4ce2 	movw	ip, #1250	; 0x4e2
 1000e4e:	1a41      	subs	r1, r0, r1
 1000e50:	fb0c f101 	mul.w	r1, ip, r1
 1000e54:	48c2      	ldr	r0, [pc, #776]	; (1001160 <ull_conn_llcp+0x580>)
 1000e56:	fba1 0100 	umull	r0, r1, r1, r0
 1000e5a:	f7ff f92d 	bl	10000b8 <__aeabi_uldivmod>
 1000e5e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 1000e62:	4406      	add	r6, r0
		} else {
			ticks_slot_overhead = 0U;
		}

		/* calculate the window widening and interval */
		conn_interval_us = conn->llcp_cu.interval * 1250U;
 1000e64:	f240 4ae2 	movw	sl, #1250	; 0x4e2
		lll->latency_prepare += lazy;
 1000e68:	8e63      	ldrh	r3, [r4, #50]	; 0x32
		lll->latency_prepare -= (instant_latency - latency);
 1000e6a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
		lll->latency_prepare += lazy;
 1000e6c:	441d      	add	r5, r3
		lll->latency_prepare -= (instant_latency - latency);
 1000e6e:	eba8 0707 	sub.w	r7, r8, r7
		periodic_us = conn_interval_us;

		if (0) {
#if defined(CONFIG_BT_PERIPHERAL)
		} else if (lll->role) {
 1000e72:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
		lll->latency_prepare -= (instant_latency - latency);
 1000e76:	4417      	add	r7, r2
 1000e78:	442f      	add	r7, r5
		} else if (lll->role) {
 1000e7a:	2b00      	cmp	r3, #0
		conn_interval_us = conn->llcp_cu.interval * 1250U;
 1000e7c:	fb0a f509 	mul.w	r5, sl, r9
		lll->latency_prepare -= (instant_latency - latency);
 1000e80:	8667      	strh	r7, [r4, #50]	; 0x32
		} else if (lll->role) {
 1000e82:	f2c0 86ba 	blt.w	1001bfa <ull_conn_llcp+0x101a>
			periodic_us -= lll->slave.window_widening_periodic_us;
#endif /* CONFIG_BT_PERIPHERAL */

#if defined(CONFIG_BT_CENTRAL)
		} else if (!lll->role) {
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
 1000e86:	a3b4      	add	r3, pc, #720	; (adr r3, 1001158 <ull_conn_llcp+0x578>)
 1000e88:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000e8c:	f8d4 0110 	ldr.w	r0, [r4, #272]	; 0x110
 1000e90:	49b3      	ldr	r1, [pc, #716]	; (1001160 <ull_conn_llcp+0x580>)
		periodic_us = conn_interval_us;
 1000e92:	46aa      	mov	sl, r5
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
 1000e94:	fba0 0101 	umull	r0, r1, r0, r1
 1000e98:	f7ff f90e 	bl	10000b8 <__aeabi_uldivmod>
 1000e9c:	f020 487f 	bic.w	r8, r0, #4278190080	; 0xff000000

			/* Workaround: Due to the missing remainder param in
			 * ticker_start function for first interval; add a
			 * tick so as to use the ceiled value.
			 */
			ticks_win_offset += 1U;
 1000ea0:	f108 0801 	add.w	r8, r8, #1

		lll->interval = conn->llcp_cu.interval;
		lll->latency = conn->llcp_cu.latency;

		conn->supervision_reload =
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
 1000ea4:	f242 7310 	movw	r3, #10000	; 0x2710
 1000ea8:	f8b4 210c 	ldrh.w	r2, [r4, #268]	; 0x10c
					  conn_interval_us);
		conn->procedure_reload =
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
 1000eac:	49ad      	ldr	r1, [pc, #692]	; (1001164 <ull_conn_llcp+0x584>)
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
 1000eae:	fb03 5202 	mla	r2, r3, r2, r5

#if defined(CONFIG_BT_CTLR_LE_PING)
		/* APTO in no. of connection events */
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 1000eb2:	4bad      	ldr	r3, [pc, #692]	; (1001168 <ull_conn_llcp+0x588>)
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
 1000eb4:	3a01      	subs	r2, #1
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 1000eb6:	442b      	add	r3, r5
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
 1000eb8:	fbb2 f2f5 	udiv	r2, r2, r5
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 1000ebc:	fbb3 f3f5 	udiv	r3, r3, r5
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
 1000ec0:	4429      	add	r1, r5
 1000ec2:	fbb1 f5f5 	udiv	r5, r1, r5
		lll->latency = conn->llcp_cu.latency;
 1000ec6:	f8b4 010a 	ldrh.w	r0, [r4, #266]	; 0x10a
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 1000eca:	b299      	uxth	r1, r3
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
 1000ecc:	f8a4 20c6 	strh.w	r2, [r4, #198]	; 0xc6
						      conn_interval_us);
		/* Dispatch LE Ping PDU 6 connection events (that peer would
		 * listen to) before 30s timeout
		 * TODO: "peer listens to" is greater than 30s due to latency
		 */
		conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
 1000ed0:	1d82      	adds	r2, r0, #6
 1000ed2:	4291      	cmp	r1, r2
		lll->interval = conn->llcp_cu.interval;
 1000ed4:	f8a4 902e 	strh.w	r9, [r4, #46]	; 0x2e
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 1000ed8:	f8a4 10d2 	strh.w	r1, [r4, #210]	; 0xd2
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
 1000edc:	f8a4 50ca 	strh.w	r5, [r4, #202]	; 0xca
		lll->latency = conn->llcp_cu.latency;
 1000ee0:	8620      	strh	r0, [r4, #48]	; 0x30
		conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
 1000ee2:	dd02      	ble.n	1000eea <ull_conn_llcp+0x30a>
				     (conn->apto_reload - (lll->latency + 6)) :
 1000ee4:	1a09      	subs	r1, r1, r0
 1000ee6:	3906      	subs	r1, #6
		conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
 1000ee8:	b289      	uxth	r1, r1
				     conn->apto_reload;
#endif /* CONFIG_BT_CTLR_LE_PING */

		if (conn->llcp_cu.cmd) {
 1000eea:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
		conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
 1000eee:	f8a4 10ce 	strh.w	r1, [r4, #206]	; 0xce
		if (conn->llcp_cu.cmd) {
 1000ef2:	075f      	lsls	r7, r3, #29
			conn->supervision_expire = 0U;
 1000ef4:	bf48      	it	mi
 1000ef6:	2300      	movmi	r3, #0
#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
		/* disable ticker job, in order to chain stop and start
		 * to avoid RTC being stopped if no tickers active.
		 */
		u32_t mayfly_was_enabled =
			mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH,
 1000ef8:	f04f 0102 	mov.w	r1, #2
			conn->supervision_expire = 0U;
 1000efc:	bf48      	it	mi
 1000efe:	f8a4 30c8 	strhmi.w	r3, [r4, #200]	; 0xc8
			mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH,
 1000f02:	2001      	movs	r0, #1
 1000f04:	f011 fb92 	bl	101262c <mayfly_is_enabled>
					  TICKER_USER_ID_ULL_LOW);
		mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW,
 1000f08:	2200      	movs	r2, #0
 1000f0a:	2102      	movs	r1, #2
			mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH,
 1000f0c:	4681      	mov	r9, r0
		mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW,
 1000f0e:	2001      	movs	r0, #1
 1000f10:	f004 ffa6 	bl	1005e60 <mayfly_enable>
	return mem_index_get(conn, conn_pool, sizeof(struct ll_conn));
 1000f14:	f44f 72e4 	mov.w	r2, #456	; 0x1c8
 1000f18:	4994      	ldr	r1, [pc, #592]	; (100116c <ull_conn_llcp+0x58c>)
 1000f1a:	4620      	mov	r0, r4
 1000f1c:	f004 ff32 	bl	1005d84 <mem_index_get>
			      0);
#endif

		/* start slave/master with new timings */
		ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
 1000f20:	1d45      	adds	r5, r0, #5
 1000f22:	b2ed      	uxtb	r5, r5
		ticker_status =	ticker_stop(TICKER_INSTANCE_ID_CTLR,
 1000f24:	4b92      	ldr	r3, [pc, #584]	; (1001170 <ull_conn_llcp+0x590>)
 1000f26:	462a      	mov	r2, r5
 1000f28:	2101      	movs	r1, #1
 1000f2a:	2000      	movs	r0, #0
 1000f2c:	9400      	str	r4, [sp, #0]
 1000f2e:	f006 f9fd 	bl	100732c <ticker_stop>
					    TICKER_USER_ID_ULL_HIGH,
					    ticker_id_conn,
					    ticker_stop_conn_op_cb,
					    (void *)conn);
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 1000f32:	f030 0302 	bics.w	r3, r0, #2
 1000f36:	d004      	beq.n	1000f42 <ull_conn_llcp+0x362>
 1000f38:	f640 1164 	movw	r1, #2404	; 0x964
 1000f3c:	488d      	ldr	r0, [pc, #564]	; (1001174 <ull_conn_llcp+0x594>)
 1000f3e:	f002 fb9f 	bl	1003680 <bt_ctlr_assert_handle>
		ticker_status =
			ticker_start(TICKER_INSTANCE_ID_CTLR,
				     TICKER_USER_ID_ULL_HIGH,
				     ticker_id_conn,
				     ticks_at_expire, ticks_win_offset,
				     HAL_TICKER_US_TO_TICKS(periodic_us),
 1000f42:	a385      	add	r3, pc, #532	; (adr r3, 1001158 <ull_conn_llcp+0x578>)
 1000f44:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000f48:	4985      	ldr	r1, [pc, #532]	; (1001160 <ull_conn_llcp+0x580>)
 1000f4a:	fbaa ab01 	umull	sl, fp, sl, r1
 1000f4e:	4650      	mov	r0, sl
 1000f50:	4659      	mov	r1, fp
 1000f52:	f7ff f8b1 	bl	10000b8 <__aeabi_uldivmod>
				     HAL_TICKER_REMAINDER(periodic_us),
 1000f56:	2107      	movs	r1, #7
 1000f58:	4a87      	ldr	r2, [pc, #540]	; (1001178 <ull_conn_llcp+0x598>)
			ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000f5a:	f020 477f 	bic.w	r7, r0, #4278190080	; 0xff000000
				     HAL_TICKER_REMAINDER(periodic_us),
 1000f5e:	fba7 2302 	umull	r2, r3, r7, r2
 1000f62:	fb01 3307 	mla	r3, r1, r7, r3
 1000f66:	ebba 0002 	subs.w	r0, sl, r2
 1000f6a:	eb6b 0103 	sbc.w	r1, fp, r3
 1000f6e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 1000f72:	2300      	movs	r3, #0
 1000f74:	f7ff f8a0 	bl	10000b8 <__aeabi_uldivmod>
 1000f78:	4603      	mov	r3, r0
			ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000f7a:	2000      	movs	r0, #0
 1000f7c:	f994 c03d 	ldrsb.w	ip, [r4, #61]	; 0x3d
 1000f80:	4a7e      	ldr	r2, [pc, #504]	; (100117c <ull_conn_llcp+0x59c>)
 1000f82:	497f      	ldr	r1, [pc, #508]	; (1001180 <ull_conn_llcp+0x5a0>)
 1000f84:	4584      	cmp	ip, r0
 1000f86:	bfa8      	it	ge
 1000f88:	4611      	movge	r1, r2
				     TICKER_LAZY_MUST_EXPIRE,
#else
				     TICKER_NULL_LAZY,
#endif /* CONFIG_BT_CTLR_CONN_META */
				     (ticks_slot_overhead +
				      conn->evt.ticks_slot),
 1000f8a:	68e2      	ldr	r2, [r4, #12]
			ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000f8c:	f8df c1f8 	ldr.w	ip, [pc, #504]	; 1001188 <ull_conn_llcp+0x5a8>
 1000f90:	e9cd 7301 	strd	r7, r3, [sp, #4]
				      conn->evt.ticks_slot),
 1000f94:	9204      	str	r2, [sp, #16]
			ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000f96:	4633      	mov	r3, r6
 1000f98:	9105      	str	r1, [sp, #20]
 1000f9a:	462a      	mov	r2, r5
 1000f9c:	2101      	movs	r1, #1
 1000f9e:	9408      	str	r4, [sp, #32]
 1000fa0:	9406      	str	r4, [sp, #24]
 1000fa2:	f8cd 8000 	str.w	r8, [sp]
 1000fa6:	9003      	str	r0, [sp, #12]
 1000fa8:	f8cd c01c 	str.w	ip, [sp, #28]
 1000fac:	f006 f958 	bl	1007260 <ticker_start>
#else
				     ull_master_ticker_cb,
#endif
				     conn, ticker_start_conn_op_cb,
				     (void *)conn);
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 1000fb0:	f030 0302 	bics.w	r3, r0, #2
 1000fb4:	d004      	beq.n	1000fc0 <ull_conn_llcp+0x3e0>
 1000fb6:	f640 117e 	movw	r1, #2430	; 0x97e
 1000fba:	486e      	ldr	r0, [pc, #440]	; (1001174 <ull_conn_llcp+0x594>)
 1000fbc:	f002 fb60 	bl	1003680 <bt_ctlr_assert_handle>
			  (ticker_status == TICKER_STATUS_BUSY));

#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
		/* enable ticker job, if disabled in this function */
		if (mayfly_was_enabled) {
 1000fc0:	f1b9 0f00 	cmp.w	r9, #0
 1000fc4:	f040 8601 	bne.w	1001bca <ull_conn_llcp+0xfea>
				return -ECANCELED;
 1000fc8:	f06f 0047 	mvn.w	r0, #71	; 0x47
 1000fcc:	e626      	b.n	1000c1c <ull_conn_llcp+0x3c>
			event_counter = lll->event_counter +
 1000fce:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 1000fd0:	8e62      	ldrh	r2, [r4, #50]	; 0x32
static inline void event_phy_upd_ind_prep(struct ll_conn *conn,
					  u16_t event_counter)
{
	struct node_rx_pu *upd;

	if (conn->llcp.phy_upd_ind.initiate) {
 1000fd2:	f894 60ec 	ldrb.w	r6, [r4, #236]	; 0xec
			event_counter = lll->event_counter +
 1000fd6:	4413      	add	r3, r2
					lll->latency_prepare + lazy;
 1000fd8:	441d      	add	r5, r3
	if (conn->llcp.phy_upd_ind.initiate) {
 1000fda:	07f7      	lsls	r7, r6, #31
 1000fdc:	46b3      	mov	fp, r6
			event_counter = lll->event_counter +
 1000fde:	b2ad      	uxth	r5, r5
	if (conn->llcp.phy_upd_ind.initiate) {
 1000fe0:	f100 8326 	bmi.w	1001630 <ull_conn_llcp+0xa50>
		ind->m_to_s_phy = conn->llcp.phy_upd_ind.tx;
		ind->s_to_m_phy = conn->llcp.phy_upd_ind.rx;
		ind->instant = sys_cpu_to_le16(conn->llcp.phy_upd_ind.instant);

		ctrl_tx_enqueue(conn, tx);
	} else if (((event_counter - conn->llcp.phy_upd_ind.instant) &
 1000fe4:	f8b4 20ee 	ldrh.w	r2, [r4, #238]	; 0xee
 1000fe8:	1aad      	subs	r5, r5, r2
 1000fea:	042a      	lsls	r2, r5, #16
 1000fec:	f53f ae0f 	bmi.w	1000c0e <ull_conn_llcp+0x2e>
	if (!conn->common.fex_valid ||
 1000ff0:	f894 20dc 	ldrb.w	r2, [r4, #220]	; 0xdc
		struct lll_conn *lll = &conn->lll;
		struct node_rx_pdu *rx;
		u8_t old_tx, old_rx;

		/* procedure request acked */
		conn->llcp_ack = conn->llcp_req;
 1000ff4:	f894 10e8 	ldrb.w	r1, [r4, #232]	; 0xe8

		/* apply new phy */
		old_tx = lll->phy_tx;
 1000ff8:	f894 9064 	ldrb.w	r9, [r4, #100]	; 0x64
		old_rx = lll->phy_rx;
 1000ffc:	f894 a065 	ldrb.w	sl, [r4, #101]	; 0x65
	if (!conn->common.fex_valid ||
 1001000:	07d3      	lsls	r3, r2, #31

#if defined(CONFIG_BT_CTLR_DATA_LENGTH)
		u16_t eff_tx_time = lll->max_tx_time;
		u16_t eff_rx_time = lll->max_rx_time;
 1001002:	f8b4 8062 	ldrh.w	r8, [r4, #98]	; 0x62
		conn->llcp_ack = conn->llcp_req;
 1001006:	f884 10e9 	strb.w	r1, [r4, #233]	; 0xe9
		old_tx = lll->phy_tx;
 100100a:	f009 0907 	and.w	r9, r9, #7
		old_rx = lll->phy_rx;
 100100e:	f00a 0a07 	and.w	sl, sl, #7
	if (!conn->common.fex_valid ||
 1001012:	f140 85ee 	bpl.w	1001bf2 <ull_conn_llcp+0x1012>
	feature_coded_phy = (conn->llcp_feature.features &
 1001016:	f8d4 211c 	ldr.w	r2, [r4, #284]	; 0x11c
	if (!conn->common.fex_valid ||
 100101a:	0517      	lsls	r7, r2, #20
 100101c:	f141 8055 	bpl.w	10020ca <ull_conn_llcp+0x14ea>
		tx_time = MIN(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_CODED),
 1001020:	f244 2290 	movw	r2, #17040	; 0x4290
 1001024:	f8b4 50d8 	ldrh.w	r5, [r4, #216]	; 0xd8
 1001028:	920b      	str	r2, [sp, #44]	; 0x2c
 100102a:	4295      	cmp	r5, r2
 100102c:	bf28      	it	cs
 100102e:	4615      	movcs	r5, r2
		tx_time = MAX(PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M), tx_time);
 1001030:	f5b5 7fa4 	cmp.w	r5, #328	; 0x148
 1001034:	bf38      	it	cc
 1001036:	f44f 75a4 	movcc.w	r5, #328	; 0x148
		u16_t max_rx_time, max_tx_time;

		dle_max_time_get(conn, &max_rx_time, &max_tx_time);
#endif /* CONFIG_BT_CTLR_DATA_LENGTH */

		if (conn->llcp.phy_upd_ind.tx) {
 100103a:	f016 0f1c 	tst.w	r6, #28
 100103e:	f040 86ee 	bne.w	1001e1e <ull_conn_llcp+0x123e>
		u16_t eff_tx_time = lll->max_tx_time;
 1001042:	f8b4 7060 	ldrh.w	r7, [r4, #96]	; 0x60
						    lll->phy_tx,
						    max_tx_time);

#endif /* CONFIG_BT_CTLR_DATA_LENGTH */
		}
		if (conn->llcp.phy_upd_ind.rx) {
 1001046:	f016 0fe0 	tst.w	r6, #224	; 0xe0
 100104a:	d00c      	beq.n	1001066 <ull_conn_llcp+0x486>
			lll->phy_rx = conn->llcp.phy_upd_ind.rx;
 100104c:	f894 2065 	ldrb.w	r2, [r4, #101]	; 0x65
 1001050:	0971      	lsrs	r1, r6, #5
 1001052:	f361 0202 	bfi	r2, r1, #0, #3
 1001056:	f884 2065 	strb.w	r2, [r4, #101]	; 0x65

#if defined(CONFIG_BT_CTLR_DATA_LENGTH)
			eff_rx_time =
				calc_eff_time(lll->max_rx_octets, lll->phy_rx,
 100105a:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 100105c:	f894 005e 	ldrb.w	r0, [r4, #94]	; 0x5e
 1001060:	f00a f800 	bl	100b064 <calc_eff_time>
 1001064:	4680      	mov	r8, r0
					      max_rx_time);

#endif /* CONFIG_BT_CTLR_DATA_LENGTH */
		}
		lll->phy_flags = conn->phy_pref_flags;
 1001066:	f894 21ac 	ldrb.w	r2, [r4, #428]	; 0x1ac
 100106a:	f894 1064 	ldrb.w	r1, [r4, #100]	; 0x64
 100106e:	f3c2 02c0 	ubfx	r2, r2, #3, #1

		/* Acquire Rx node */
		rx = conn->llcp_rx;
 1001072:	f8d4 6100 	ldr.w	r6, [r4, #256]	; 0x100
		lll->phy_flags = conn->phy_pref_flags;
 1001076:	f362 01c3 	bfi	r1, r2, #3, #1
 100107a:	f884 1064 	strb.w	r1, [r4, #100]	; 0x64
		LL_ASSERT(rx && rx->hdr.link);
 100107e:	2e00      	cmp	r6, #0
 1001080:	f000 87cd 	beq.w	100201e <ull_conn_llcp+0x143e>
 1001084:	6830      	ldr	r0, [r6, #0]
 1001086:	2800      	cmp	r0, #0
 1001088:	f000 87c9 	beq.w	100201e <ull_conn_llcp+0x143e>
		conn->llcp_rx = rx->hdr.link->mem;
 100108c:	6842      	ldr	r2, [r0, #4]

		/* generate event if phy changed or initiated by cmd */
		if (!conn->llcp.phy_upd_ind.cmd && (lll->phy_tx == old_tx) &&
 100108e:	f01b 0f02 	tst.w	fp, #2
 1001092:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
		conn->llcp_rx = rx->hdr.link->mem;
 1001096:	f8c4 2100 	str.w	r2, [r4, #256]	; 0x100
		if (!conn->llcp.phy_upd_ind.cmd && (lll->phy_tx == old_tx) &&
 100109a:	f040 87ec 	bne.w	1002076 <ull_conn_llcp+0x1496>
		    (lll->phy_rx == old_rx)) {
 100109e:	f894 2065 	ldrb.w	r2, [r4, #101]	; 0x65
		if (!conn->llcp.phy_upd_ind.cmd && (lll->phy_tx == old_tx) &&
 10010a2:	f003 0307 	and.w	r3, r3, #7
 10010a6:	4599      	cmp	r9, r3
		    (lll->phy_rx == old_rx)) {
 10010a8:	f002 0207 	and.w	r2, r2, #7
		if (!conn->llcp.phy_upd_ind.cmd && (lll->phy_tx == old_tx) &&
 10010ac:	f001 8071 	beq.w	1002192 <ull_conn_llcp+0x15b2>

			return;
		}

		rx->hdr.handle = lll->handle;
		rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
 10010b0:	f04f 0e0e 	mov.w	lr, #14

		upd = (void *)rx->pdu;
		upd->status = 0U;
 10010b4:	2100      	movs	r1, #0
		rx->hdr.handle = lll->handle;
 10010b6:	f8b4 c02c 	ldrh.w	ip, [r4, #44]	; 0x2c
		upd->status = 0U;
 10010ba:	f886 1020 	strb.w	r1, [r6, #32]
		rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
 10010be:	f886 e004 	strb.w	lr, [r6, #4]
		upd->tx = lll->phy_tx;
		upd->rx = lll->phy_rx;

		/* enqueue rx node towards Thread */
		ll_rx_put(rx->hdr.link, rx);
 10010c2:	4631      	mov	r1, r6
		rx->hdr.handle = lll->handle;
 10010c4:	f8a6 c006 	strh.w	ip, [r6, #6]
		upd->tx = lll->phy_tx;
 10010c8:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
		upd->rx = lll->phy_rx;
 10010cc:	f886 2022 	strb.w	r2, [r6, #34]	; 0x22
		ll_rx_put(rx->hdr.link, rx);
 10010d0:	f009 f854 	bl	100a17c <ll_rx_put>

#if defined(CONFIG_BT_CTLR_DATA_LENGTH)
		/* get a rx node for ULL->LL */
		rx = conn->llcp_rx;
 10010d4:	f8d4 6100 	ldr.w	r6, [r4, #256]	; 0x100
		LL_ASSERT(rx && rx->hdr.link);
 10010d8:	2e00      	cmp	r6, #0
 10010da:	f000 87aa 	beq.w	1002032 <ull_conn_llcp+0x1452>
 10010de:	6830      	ldr	r0, [r6, #0]
 10010e0:	2800      	cmp	r0, #0
 10010e2:	f000 87a6 	beq.w	1002032 <ull_conn_llcp+0x1452>
		conn->llcp_rx = rx->hdr.link->mem;

		/* Update max tx and/or max rx if changed */
		if ((eff_tx_time <= lll->max_tx_time) &&
 10010e6:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
		conn->llcp_rx = rx->hdr.link->mem;
 10010ea:	6842      	ldr	r2, [r0, #4]
		if ((eff_tx_time <= lll->max_tx_time) &&
 10010ec:	42bb      	cmp	r3, r7
		conn->llcp_rx = rx->hdr.link->mem;
 10010ee:	f8c4 2100 	str.w	r2, [r4, #256]	; 0x100
		if ((eff_tx_time <= lll->max_tx_time) &&
 10010f2:	d309      	bcc.n	1001108 <ull_conn_llcp+0x528>
 10010f4:	42ab      	cmp	r3, r5
 10010f6:	d807      	bhi.n	1001108 <ull_conn_llcp+0x528>
		    (lll->max_tx_time <= max_tx_time) &&
		    (eff_rx_time <= lll->max_rx_time) &&
 10010f8:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
		    (lll->max_tx_time <= max_tx_time) &&
 10010fc:	4543      	cmp	r3, r8
 10010fe:	d303      	bcc.n	1001108 <ull_conn_llcp+0x528>
		    (eff_rx_time <= lll->max_rx_time) &&
 1001100:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 1001102:	4293      	cmp	r3, r2
 1001104:	f241 8177 	bls.w	10023f6 <ull_conn_llcp+0x1816>
		lll->max_tx_time = eff_tx_time;
		lll->max_rx_time = eff_rx_time;

		/* prepare length rsp structure */
		rx->hdr.handle = lll->handle;
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 1001108:	f04f 0c02 	mov.w	ip, #2

		struct pdu_data *pdu_rx = (void *)rx->pdu;

		pdu_rx->ll_id = PDU_DATA_LLID_CTRL;
		pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
 100110c:	2109      	movs	r1, #9
			      sizeof(struct pdu_data_llctrl_length_rsp);
		pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 100110e:	2215      	movs	r2, #21
		lll->max_tx_time = eff_tx_time;
 1001110:	f8a4 7060 	strh.w	r7, [r4, #96]	; 0x60
		lll->max_rx_time = eff_rx_time;
 1001114:	f8a4 8062 	strh.w	r8, [r4, #98]	; 0x62
		pdu_rx->ll_id = PDU_DATA_LLID_CTRL;
 1001118:	f896 3020 	ldrb.w	r3, [r6, #32]
		rx->hdr.handle = lll->handle;
 100111c:	8da5      	ldrh	r5, [r4, #44]	; 0x2c
		pdu_rx->ll_id = PDU_DATA_LLID_CTRL;
 100111e:	f043 0303 	orr.w	r3, r3, #3
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 1001122:	f886 c004 	strb.w	ip, [r6, #4]
		pdu_rx->ll_id = PDU_DATA_LLID_CTRL;
 1001126:	f886 3020 	strb.w	r3, [r6, #32]
		pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
 100112a:	f886 1021 	strb.w	r1, [r6, #33]	; 0x21

		struct pdu_data_llctrl_length_req *lr =
			(void *)&pdu_rx->llctrl.length_rsp;

		lr->max_rx_octets = sys_cpu_to_le16(lll->max_rx_octets);
 100112e:	f8b4 105e 	ldrh.w	r1, [r4, #94]	; 0x5e
		lr->max_tx_octets = sys_cpu_to_le16(lll->max_tx_octets);
 1001132:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
		rx->hdr.handle = lll->handle;
 1001136:	80f5      	strh	r5, [r6, #6]
		lr->max_rx_octets = sys_cpu_to_le16(lll->max_rx_octets);
 1001138:	84b1      	strh	r1, [r6, #36]	; 0x24
		lr->max_tx_octets = sys_cpu_to_le16(lll->max_tx_octets);
 100113a:	8533      	strh	r3, [r6, #40]	; 0x28
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
		lr->max_tx_time = sys_cpu_to_le16(lll->max_tx_time);

		/* enqueue rx node towards Thread */
		ll_rx_put(rx->hdr.link, rx);
 100113c:	4631      	mov	r1, r6
		pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 100113e:	f886 2023 	strb.w	r2, [r6, #35]	; 0x23
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
 1001142:	f8a6 8026 	strh.w	r8, [r6, #38]	; 0x26
		lr->max_tx_time = sys_cpu_to_le16(lll->max_tx_time);
 1001146:	8577      	strh	r7, [r6, #42]	; 0x2a
		ll_rx_put(rx->hdr.link, rx);
 1001148:	f009 f818 	bl	100a17c <ll_rx_put>
#endif /* CONFIG_BT_CTLR_DATA_LENGTH */

		ll_rx_sched();
 100114c:	f009 f820 	bl	100a190 <ll_rx_sched>
 1001150:	e55d      	b.n	1000c0e <ull_conn_llcp+0x2e>
 1001152:	bf00      	nop
 1001154:	f3af 8000 	nop.w
 1001158:	1afd498d 	.word	0x1afd498d
 100115c:	00000007 	.word	0x00000007
 1001160:	3b9aca00 	.word	0x3b9aca00
 1001164:	026259ff 	.word	0x026259ff
 1001168:	01c9c37f 	.word	0x01c9c37f
 100116c:	21002bd0 	.word	0x21002bd0
 1001170:	0100b33d 	.word	0x0100b33d
 1001174:	01018934 	.word	0x01018934
 1001178:	1afd498d 	.word	0x1afd498d
 100117c:	0100e305 	.word	0x0100e305
 1001180:	0100e1b5 	.word	0x0100e1b5
 1001184:	21004850 	.word	0x21004850
 1001188:	0100b30d 	.word	0x0100b30d
	if (conn->llcp.encryption.state) {
 100118c:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
 1001190:	f013 0503 	ands.w	r5, r3, #3
 1001194:	f47f ad3b 	bne.w	1000c0e <ull_conn_llcp+0x2e>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1001198:	48ab      	ldr	r0, [pc, #684]	; (1001448 <ull_conn_llcp+0x868>)
 100119a:	f004 fdbd 	bl	1005d18 <mem_acquire>
	if (!tx) {
 100119e:	4606      	mov	r6, r0
 10011a0:	2800      	cmp	r0, #0
 10011a2:	f43f ad34 	beq.w	1000c0e <ull_conn_llcp+0x2e>
	if (!lll->role) {
 10011a6:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
 10011aa:	2b00      	cmp	r3, #0
 10011ac:	f280 8578 	bge.w	1001ca0 <ull_conn_llcp+0x10c0>
		if (conn->llcp.encryption.error_code) {
 10011b0:	f894 50ed 	ldrb.w	r5, [r4, #237]	; 0xed
 10011b4:	2d00      	cmp	r5, #0
 10011b6:	f000 836c 	beq.w	1001892 <ull_conn_llcp+0xcb2>
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10011ba:	7903      	ldrb	r3, [r0, #4]
	if (conn->common.fex_valid &&
 10011bc:	f894 20dc 	ldrb.w	r2, [r4, #220]	; 0xdc
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10011c0:	f043 0303 	orr.w	r3, r3, #3
	if (conn->common.fex_valid &&
 10011c4:	07d2      	lsls	r2, r2, #31
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10011c6:	7103      	strb	r3, [r0, #4]
	if (conn->common.fex_valid &&
 10011c8:	f140 8723 	bpl.w	1002012 <ull_conn_llcp+0x1432>
	    (conn->llcp_feature.features & BIT(BT_LE_FEAT_BIT_EXT_REJ_IND))) {
 10011cc:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
	if (conn->common.fex_valid &&
 10011d0:	075b      	lsls	r3, r3, #29
 10011d2:	f140 871e 	bpl.w	1002012 <ull_conn_llcp+0x1432>
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
 10011d6:	2211      	movs	r2, #17
		p->reject_opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
 10011d8:	2303      	movs	r3, #3
		p->error_code = conn->llcp.encryption.error_code;
 10011da:	7245      	strb	r5, [r0, #9]
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
 10011dc:	71c2      	strb	r2, [r0, #7]
		p->reject_opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
 10011de:	7203      	strb	r3, [r0, #8]
	conn->llcp.encryption.error_code = 0U;
 10011e0:	2200      	movs	r2, #0
	pdu->len += offsetof(struct pdu_data_llctrl, reject_ind);
 10011e2:	7177      	strb	r7, [r6, #5]
	    conn->tx_head &&
 10011e4:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
	conn->llcp.encryption.error_code = 0U;
 10011e8:	f884 20ed 	strb.w	r2, [r4, #237]	; 0xed
	if (
 10011ec:	2b00      	cmp	r3, #0
 10011ee:	f000 8397 	beq.w	1001920 <ull_conn_llcp+0xd40>
	    !conn->llcp_enc.pause_tx &&
 10011f2:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
	    conn->tx_head &&
 10011f6:	0795      	lsls	r5, r2, #30
 10011f8:	f100 8392 	bmi.w	1001920 <ull_conn_llcp+0xd40>
	    !conn->llcp_phy.pause_tx &&
 10011fc:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
 1001200:	07d0      	lsls	r0, r2, #31
 1001202:	f100 838d 	bmi.w	1001920 <ull_conn_llcp+0xd40>
		if (conn->tx_head == conn->tx_data) {
 1001206:	f8d4 21bc 	ldr.w	r2, [r4, #444]	; 0x1bc
 100120a:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 100120c:	bf04      	itt	eq
 100120e:	681a      	ldreq	r2, [r3, #0]
 1001210:	f8c4 21bc 	streq.w	r2, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 1001214:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 1001218:	2a00      	cmp	r2, #0
 100121a:	f001 80c9 	beq.w	10023b0 <ull_conn_llcp+0x17d0>
	tx->next = conn->tx_ctrl_last->next;
 100121e:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 1001222:	681a      	ldr	r2, [r3, #0]
 1001224:	6032      	str	r2, [r6, #0]
	conn->tx_ctrl_last->next = tx;
 1001226:	601e      	str	r6, [r3, #0]
	conn->tx_ctrl_last = tx;
 1001228:	f8c4 61b8 	str.w	r6, [r4, #440]	; 0x1b8
 100122c:	6833      	ldr	r3, [r6, #0]
	if (!tx->next) {
 100122e:	2b00      	cmp	r3, #0
 1001230:	f000 86eb 	beq.w	100200a <ull_conn_llcp+0x142a>
	conn->llcp_ack = conn->llcp_req;
 1001234:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 1001238:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
 100123c:	e4e7      	b.n	1000c0e <ull_conn_llcp+0x2e>
			event_counter = lll->event_counter +
 100123e:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 1001240:	8e61      	ldrh	r1, [r4, #50]	; 0x32
	if (conn->llcp.chan_map.initiate) {
 1001242:	f894 20ec 	ldrb.w	r2, [r4, #236]	; 0xec
			event_counter = lll->event_counter +
 1001246:	440b      	add	r3, r1
					lll->latency_prepare + lazy;
 1001248:	441d      	add	r5, r3
	if (conn->llcp.chan_map.initiate) {
 100124a:	07d6      	lsls	r6, r2, #31
			event_counter = lll->event_counter +
 100124c:	b2ad      	uxth	r5, r5
	if (conn->llcp.chan_map.initiate) {
 100124e:	f100 81a1 	bmi.w	1001594 <ull_conn_llcp+0x9b4>
	} else if (((event_counter - conn->llcp.chan_map.instant) & 0xFFFF)
 1001252:	f8b4 30f2 	ldrh.w	r3, [r4, #242]	; 0xf2
 1001256:	1aed      	subs	r5, r5, r3
 1001258:	0429      	lsls	r1, r5, #16
 100125a:	f53f acd8 	bmi.w	1000c0e <ull_conn_llcp+0x2e>
		conn->llcp_ack = conn->llcp_req;
 100125e:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
		memcpy(&lll->data_chan_map[0],
 1001262:	f104 0538 	add.w	r5, r4, #56	; 0x38
 1001266:	2205      	movs	r2, #5
		conn->llcp_ack = conn->llcp_req;
 1001268:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
		memcpy(&lll->data_chan_map[0],
 100126c:	f104 01ed 	add.w	r1, r4, #237	; 0xed
 1001270:	4628      	mov	r0, r5
 1001272:	f015 fbd1 	bl	1016a18 <memcpy>
			util_ones_count_get(&lll->data_chan_map[0],
 1001276:	4628      	mov	r0, r5
 1001278:	2105      	movs	r1, #5
 100127a:	f004 ff19 	bl	10060b0 <util_ones_count_get>
		conn->chm_updated = 1U;
 100127e:	2201      	movs	r2, #1
		lll->data_chan_count =
 1001280:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
		conn->chm_updated = 1U;
 1001284:	f884 21c4 	strb.w	r2, [r4, #452]	; 0x1c4
		lll->data_chan_count =
 1001288:	f360 0305 	bfi	r3, r0, #0, #6
 100128c:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
		conn->chm_updated = 1U;
 1001290:	e4bd      	b.n	1000c0e <ull_conn_llcp+0x2e>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1001292:	486d      	ldr	r0, [pc, #436]	; (1001448 <ull_conn_llcp+0x868>)
 1001294:	f004 fd40 	bl	1005d18 <mem_acquire>
	if (tx) {
 1001298:	2800      	cmp	r0, #0
 100129a:	f43f acb8 	beq.w	1000c0e <ull_conn_llcp+0x2e>
		pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, ping_req) +
 100129e:	2301      	movs	r3, #1
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_REQ;
 10012a0:	2112      	movs	r1, #18
		conn->llcp_ack = conn->llcp_req;
 10012a2:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
 10012a6:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 10012aa:	7902      	ldrb	r2, [r0, #4]
		pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, ping_req) +
 10012ac:	7143      	strb	r3, [r0, #5]
	    conn->tx_head &&
 10012ae:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 10012b2:	f042 0203 	orr.w	r2, r2, #3
 10012b6:	7102      	strb	r2, [r0, #4]
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_REQ;
 10012b8:	71c1      	strb	r1, [r0, #7]
	if (
 10012ba:	2b00      	cmp	r3, #0
 10012bc:	f000 82de 	beq.w	100187c <ull_conn_llcp+0xc9c>
	    !conn->llcp_enc.pause_tx &&
 10012c0:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
	    conn->tx_head &&
 10012c4:	0791      	lsls	r1, r2, #30
 10012c6:	f100 82d9 	bmi.w	100187c <ull_conn_llcp+0xc9c>
	    !conn->llcp_phy.pause_tx &&
 10012ca:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
 10012ce:	07d2      	lsls	r2, r2, #31
 10012d0:	f100 82d4 	bmi.w	100187c <ull_conn_llcp+0xc9c>
		if (conn->tx_head == conn->tx_data) {
 10012d4:	f8d4 21bc 	ldr.w	r2, [r4, #444]	; 0x1bc
 10012d8:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 10012da:	bf04      	itt	eq
 10012dc:	681a      	ldreq	r2, [r3, #0]
 10012de:	f8c4 21bc 	streq.w	r2, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 10012e2:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 10012e6:	2a00      	cmp	r2, #0
 10012e8:	f001 804f 	beq.w	100238a <ull_conn_llcp+0x17aa>
	tx->next = conn->tx_ctrl_last->next;
 10012ec:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 10012f0:	681a      	ldr	r2, [r3, #0]
 10012f2:	6002      	str	r2, [r0, #0]
	conn->tx_ctrl_last->next = tx;
 10012f4:	6018      	str	r0, [r3, #0]
	conn->tx_ctrl_last = tx;
 10012f6:	f8c4 01b8 	str.w	r0, [r4, #440]	; 0x1b8
 10012fa:	6803      	ldr	r3, [r0, #0]
	if (!tx->next) {
 10012fc:	2b00      	cmp	r3, #0
 10012fe:	f000 8573 	beq.w	1001de8 <ull_conn_llcp+0x1208>
		conn->procedure_expire = conn->procedure_reload;
 1001302:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
 1001306:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
 100130a:	e480      	b.n	1000c0e <ull_conn_llcp+0x2e>
			LL_ASSERT(0);
 100130c:	f240 318e 	movw	r1, #910	; 0x38e
 1001310:	484e      	ldr	r0, [pc, #312]	; (100144c <ull_conn_llcp+0x86c>)
 1001312:	f002 f9b5 	bl	1003680 <bt_ctlr_assert_handle>
			break;
 1001316:	e47a      	b.n	1000c0e <ull_conn_llcp+0x2e>
		} else if (conn->llcp_feature.ack != conn->llcp_feature.req) {
 1001318:	f894 7119 	ldrb.w	r7, [r4, #281]	; 0x119
 100131c:	f894 c118 	ldrb.w	ip, [r4, #280]	; 0x118
 1001320:	4567      	cmp	r7, ip
 1001322:	d159      	bne.n	10013d8 <ull_conn_llcp+0x7f8>
		} else if (conn->llcp_version.ack != conn->llcp_version.req) {
 1001324:	f894 7121 	ldrb.w	r7, [r4, #289]	; 0x121
 1001328:	f894 c120 	ldrb.w	ip, [r4, #288]	; 0x120
 100132c:	4567      	cmp	r7, ip
 100132e:	f000 831d 	beq.w	100196c <ull_conn_llcp+0xd8c>
	if (!((conn->llcp_version.ack - conn->llcp_version.req) & 0x01)) {
 1001332:	eba7 070c 	sub.w	r7, r7, ip
 1001336:	07f9      	lsls	r1, r7, #31
 1001338:	f57f ac69 	bpl.w	1000c0e <ull_conn_llcp+0x2e>
	if (conn->llcp_version.tx == 0U) {
 100133c:	f894 3122 	ldrb.w	r3, [r4, #290]	; 0x122
 1001340:	07da      	lsls	r2, r3, #31
 1001342:	f140 8775 	bpl.w	1002230 <ull_conn_llcp+0x1650>
	} else if (conn->llcp_version.rx) {
 1001346:	079a      	lsls	r2, r3, #30
 1001348:	f140 875e 	bpl.w	1002208 <ull_conn_llcp+0x1628>
		rx = ll_pdu_rx_alloc();
 100134c:	f008 ff44 	bl	100a1d8 <ll_pdu_rx_alloc>
		if (!rx) {
 1001350:	4601      	mov	r1, r0
 1001352:	b330      	cbz	r0, 10013a2 <ull_conn_llcp+0x7c2>
		pdu->len = offsetof(struct pdu_data_llctrl, version_ind) +
 1001354:	2006      	movs	r0, #6
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
 1001356:	220c      	movs	r2, #12
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 1001358:	2702      	movs	r7, #2
		conn->llcp_version.ack = conn->llcp_version.req;
 100135a:	f894 3120 	ldrb.w	r3, [r4, #288]	; 0x120
		rx->hdr.handle = conn->lll.handle;
 100135e:	f8b4 c02c 	ldrh.w	ip, [r4, #44]	; 0x2c
		conn->llcp_version.ack = conn->llcp_version.req;
 1001362:	f884 3121 	strb.w	r3, [r4, #289]	; 0x121
		pdu->ll_id = PDU_DATA_LLID_CTRL;
 1001366:	f891 3020 	ldrb.w	r3, [r1, #32]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 100136a:	710f      	strb	r7, [r1, #4]
		pdu->ll_id = PDU_DATA_LLID_CTRL;
 100136c:	f043 0303 	orr.w	r3, r3, #3
 1001370:	f881 3020 	strb.w	r3, [r1, #32]
		pdu->len = offsetof(struct pdu_data_llctrl, version_ind) +
 1001374:	f881 0021 	strb.w	r0, [r1, #33]	; 0x21
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
 1001378:	f881 2023 	strb.w	r2, [r1, #35]	; 0x23
		rx->hdr.handle = conn->lll.handle;
 100137c:	f8a1 c006 	strh.w	ip, [r1, #6]
		pdu->llctrl.version_ind.version_number =
 1001380:	f894 0123 	ldrb.w	r0, [r4, #291]	; 0x123
		pdu->llctrl.version_ind.company_id =
 1001384:	f8b4 2124 	ldrh.w	r2, [r4, #292]	; 0x124
		pdu->llctrl.version_ind.sub_version_number =
 1001388:	f8b4 3126 	ldrh.w	r3, [r4, #294]	; 0x126
		pdu->llctrl.version_ind.version_number =
 100138c:	f881 0024 	strb.w	r0, [r1, #36]	; 0x24
		pdu->llctrl.version_ind.company_id =
 1001390:	f8a1 2025 	strh.w	r2, [r1, #37]	; 0x25
		pdu->llctrl.version_ind.sub_version_number =
 1001394:	f8a1 3027 	strh.w	r3, [r1, #39]	; 0x27
		ll_rx_put(rx->hdr.link, rx);
 1001398:	6808      	ldr	r0, [r1, #0]
 100139a:	f008 feef 	bl	100a17c <ll_rx_put>
		ll_rx_sched();
 100139e:	f008 fef7 	bl	100a190 <ll_rx_sched>
 10013a2:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 10013a6:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
 10013aa:	e42b      	b.n	1000c04 <ull_conn_llcp+0x24>
	switch (conn->llcp_length.state) {
 10013ac:	f000 0207 	and.w	r2, r0, #7
 10013b0:	2a06      	cmp	r2, #6
 10013b2:	f201 817b 	bhi.w	10026ac <ull_conn_llcp+0x1acc>
 10013b6:	a101      	add	r1, pc, #4	; (adr r1, 10013bc <ull_conn_llcp+0x7dc>)
 10013b8:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
 10013bc:	010017a9 	.word	0x010017a9
 10013c0:	01000c61 	.word	0x01000c61
 10013c4:	01000c61 	.word	0x01000c61
 10013c8:	01000c61 	.word	0x01000c61
 10013cc:	01001707 	.word	0x01001707
 10013d0:	01001707 	.word	0x01001707
 10013d4:	01000c61 	.word	0x01000c61
	if (!((conn->llcp_feature.ack - conn->llcp_feature.req) & 0x01)) {
 10013d8:	eba7 070c 	sub.w	r7, r7, ip
 10013dc:	07fb      	lsls	r3, r7, #31
 10013de:	f57f ac16 	bpl.w	1000c0e <ull_conn_llcp+0x2e>
	if (conn->common.fex_valid) {
 10013e2:	f894 10dc 	ldrb.w	r1, [r4, #220]	; 0xdc
 10013e6:	f011 0701 	ands.w	r7, r1, #1
 10013ea:	f000 849e 	beq.w	1001d2a <ull_conn_llcp+0x114a>
		rx = ll_pdu_rx_alloc();
 10013ee:	f008 fef3 	bl	100a1d8 <ll_pdu_rx_alloc>
		if (!rx) {
 10013f2:	4607      	mov	r7, r0
 10013f4:	2800      	cmp	r0, #0
 10013f6:	d0d4      	beq.n	10013a2 <ull_conn_llcp+0x7c2>
		pdu->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
 10013f8:	2209      	movs	r2, #9
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 10013fa:	2002      	movs	r0, #2
		conn->llcp_feature.ack = conn->llcp_feature.req;
 10013fc:	f894 3118 	ldrb.w	r3, [r4, #280]	; 0x118
		rx->hdr.handle = conn->lll.handle;
 1001400:	f8b4 c02c 	ldrh.w	ip, [r4, #44]	; 0x2c
		conn->llcp_feature.ack = conn->llcp_feature.req;
 1001404:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119
		pdu->ll_id = PDU_DATA_LLID_CTRL;
 1001408:	f897 3020 	ldrb.w	r3, [r7, #32]
		(void)memset(&pdu->llctrl.feature_rsp.features[0], 0x00,
 100140c:	4641      	mov	r1, r8
		pdu->ll_id = PDU_DATA_LLID_CTRL;
 100140e:	f043 0303 	orr.w	r3, r3, #3
 1001412:	f887 3020 	strb.w	r3, [r7, #32]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 1001416:	7138      	strb	r0, [r7, #4]
		pdu->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
 1001418:	f887 2021 	strb.w	r2, [r7, #33]	; 0x21
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_RSP;
 100141c:	f887 2023 	strb.w	r2, [r7, #35]	; 0x23
		rx->hdr.handle = conn->lll.handle;
 1001420:	f8a7 c006 	strh.w	ip, [r7, #6]
		(void)memset(&pdu->llctrl.feature_rsp.features[0], 0x00,
 1001424:	2208      	movs	r2, #8
 1001426:	f107 0024 	add.w	r0, r7, #36	; 0x24
 100142a:	f015 fb20 	bl	1016a6e <memset>
		sys_put_le24(conn->llcp_feature.features,
 100142e:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
		ll_rx_put(rx->hdr.link, rx);
 1001432:	4639      	mov	r1, r7
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le16(u16_t val, u8_t dst[2])
{
	dst[0] = val;
	dst[1] = val >> 8;
 1001434:	f3c3 2007 	ubfx	r0, r3, #8, #8
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le24(u32_t val, u8_t dst[3])
{
	sys_put_le16(val, dst);
	dst[2] = val >> 16;
 1001438:	0c1a      	lsrs	r2, r3, #16
	dst[0] = val;
 100143a:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
	dst[1] = val >> 8;
 100143e:	f887 0025 	strb.w	r0, [r7, #37]	; 0x25
	dst[2] = val >> 16;
 1001442:	f887 2026 	strb.w	r2, [r7, #38]	; 0x26
 1001446:	e7a7      	b.n	1001398 <ull_conn_llcp+0x7b8>
 1001448:	21005288 	.word	0x21005288
 100144c:	01018934 	.word	0x01018934
		rx = ll_pdu_rx_alloc_peek(1);
 1001450:	2001      	movs	r0, #1
 1001452:	f008 fea3 	bl	100a19c <ll_pdu_rx_alloc_peek>
		if (!rx) {
 1001456:	4680      	mov	r8, r0
 1001458:	2800      	cmp	r0, #0
 100145a:	f43f abd8 	beq.w	1000c0e <ull_conn_llcp+0x2e>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100145e:	48ce      	ldr	r0, [pc, #824]	; (1001798 <ull_conn_llcp+0xbb8>)
 1001460:	f004 fc5a 	bl	1005d18 <mem_acquire>
		if (!tx) {
 1001464:	4605      	mov	r5, r0
 1001466:	2800      	cmp	r0, #0
 1001468:	f43f abd1 	beq.w	1000c0e <ull_conn_llcp+0x2e>
		(void)ll_pdu_rx_alloc();
 100146c:	f008 feb4 	bl	100a1d8 <ll_pdu_rx_alloc>
		rx->hdr.link->mem = conn->llcp_rx;
 1001470:	f8d8 3000 	ldr.w	r3, [r8]
 1001474:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
 1001478:	605a      	str	r2, [r3, #4]
		switch (conn->llcp_cu.state) {
 100147a:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
		conn->llcp_rx = rx;
 100147e:	f8c4 8100 	str.w	r8, [r4, #256]	; 0x100
		switch (conn->llcp_cu.state) {
 1001482:	f003 0303 	and.w	r3, r3, #3
 1001486:	2b01      	cmp	r3, #1
 1001488:	f000 8615 	beq.w	10020b6 <ull_conn_llcp+0x14d6>
 100148c:	2b02      	cmp	r3, #2
 100148e:	f000 85e3 	beq.w	1002058 <ull_conn_llcp+0x1478>
			LL_ASSERT(0);
 1001492:	f640 018f 	movw	r1, #2191	; 0x88f
 1001496:	48c1      	ldr	r0, [pc, #772]	; (100179c <ull_conn_llcp+0xbbc>)
 1001498:	f002 f8f2 	bl	1003680 <bt_ctlr_assert_handle>
		void (*fp_mfy_select_or_use)(void *) = NULL;
 100149c:	2100      	movs	r1, #0
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, conn_update_ind) +
 100149e:	f04f 0e0c 	mov.w	lr, #12
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND;
 10014a2:	f04f 0c00 	mov.w	ip, #0
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
 10014a6:	f894 2106 	ldrb.w	r2, [r4, #262]	; 0x106
	conn->llcp.conn_upd.instant = event_counter + conn->lll.latency + 6;
 10014aa:	8e23      	ldrh	r3, [r4, #48]	; 0x30
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
 10014ac:	f36f 0201 	bfc	r2, #0, #2
	conn->llcp.conn_upd.instant = event_counter + conn->lll.latency + 6;
 10014b0:	443b      	add	r3, r7
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
 10014b2:	f884 2106 	strb.w	r2, [r4, #262]	; 0x106
	conn->llcp.conn_upd.instant = event_counter + conn->lll.latency + 6;
 10014b6:	3306      	adds	r3, #6
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 10014b8:	792a      	ldrb	r2, [r5, #4]
	conn->llcp.conn_upd.instant = event_counter + conn->lll.latency + 6;
 10014ba:	b298      	uxth	r0, r3
 10014bc:	f8a4 00ec 	strh.w	r0, [r4, #236]	; 0xec
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 10014c0:	f042 0203 	orr.w	r2, r2, #3
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, conn_update_ind) +
 10014c4:	f885 e005 	strb.w	lr, [r5, #5]
		sys_cpu_to_le16(conn->llcp_cu.win_offset_us / 1250U);
 10014c8:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 10014cc:	712a      	strb	r2, [r5, #4]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND;
 10014ce:	f885 c007 	strb.w	ip, [r5, #7]
	pdu_ctrl_tx->llctrl.conn_update_ind.win_size = conn->llcp_cu.win_size;
 10014d2:	f894 2114 	ldrb.w	r2, [r4, #276]	; 0x114
		sys_cpu_to_le16(conn->llcp_cu.win_offset_us / 1250U);
 10014d6:	4fb2      	ldr	r7, [pc, #712]	; (10017a0 <ull_conn_llcp+0xbc0>)
 10014d8:	fba7 7303 	umull	r7, r3, r7, r3
	pdu_ctrl_tx->llctrl.conn_update_ind.interval =
 10014dc:	f8b4 7108 	ldrh.w	r7, [r4, #264]	; 0x108
	pdu_ctrl_tx->llctrl.conn_update_ind.win_size = conn->llcp_cu.win_size;
 10014e0:	722a      	strb	r2, [r5, #8]
	pdu_ctrl_tx->llctrl.conn_update_ind.latency =
 10014e2:	f8b4 210a 	ldrh.w	r2, [r4, #266]	; 0x10a
	pdu_ctrl_tx->llctrl.conn_update_ind.interval =
 10014e6:	f8a5 700b 	strh.w	r7, [r5, #11]
	pdu_ctrl_tx->llctrl.conn_update_ind.timeout =
 10014ea:	f8b4 710c 	ldrh.w	r7, [r4, #268]	; 0x10c
	pdu_ctrl_tx->llctrl.conn_update_ind.latency =
 10014ee:	f8a5 200d 	strh.w	r2, [r5, #13]
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
 10014f2:	6822      	ldr	r2, [r4, #0]
	pdu_ctrl_tx->llctrl.conn_update_ind.win_offset =
 10014f4:	f3c3 238f 	ubfx	r3, r3, #10, #16
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
 10014f8:	4562      	cmp	r2, ip
	pdu_ctrl_tx->llctrl.conn_update_ind.instant =
 10014fa:	f8a5 0011 	strh.w	r0, [r5, #17]
	pdu_ctrl_tx->llctrl.conn_update_ind.timeout =
 10014fe:	f8a5 700f 	strh.w	r7, [r5, #15]
	pdu_ctrl_tx->llctrl.conn_update_ind.win_offset =
 1001502:	f8a5 3009 	strh.w	r3, [r5, #9]
		conn->llcp.conn_upd.ticks_anchor = ticks_at_expire;
 1001506:	f8c4 60f4 	str.w	r6, [r4, #244]	; 0xf4
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
 100150a:	da0a      	bge.n	1001522 <ull_conn_llcp+0x942>
			u32_t ticks_prepare_to_start =
 100150c:	e9d4 0301 	ldrd	r0, r3, [r4, #4]
			conn->llcp.conn_upd.ticks_anchor -=
 1001510:	4283      	cmp	r3, r0
 1001512:	bf2c      	ite	cs
 1001514:	18f6      	addcs	r6, r6, r3
 1001516:	1836      	addcc	r6, r6, r0
				(conn->evt.ticks_xtal_to_start &
 1001518:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
			conn->llcp.conn_upd.ticks_anchor -=
 100151c:	1ab2      	subs	r2, r6, r2
 100151e:	f8c4 20f4 	str.w	r2, [r4, #244]	; 0xf4
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 1001522:	2201      	movs	r2, #1
		mfy_sched_offset->fp = fp_mfy_select_or_use;
 1001524:	4b9f      	ldr	r3, [pc, #636]	; (10017a4 <ull_conn_llcp+0xbc4>)
		conn->llcp.conn_upd.pdu_win_offset = (u16_t *)
 1001526:	f105 0609 	add.w	r6, r5, #9
		mfy_sched_offset->fp = fp_mfy_select_or_use;
 100152a:	60d9      	str	r1, [r3, #12]
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 100152c:	4610      	mov	r0, r2
 100152e:	2102      	movs	r1, #2
		conn->llcp.conn_upd.pdu_win_offset = (u16_t *)
 1001530:	f8c4 60f0 	str.w	r6, [r4, #240]	; 0xf0
		mfy_sched_offset->param = (void *)conn;
 1001534:	609c      	str	r4, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 1001536:	f004 fcc7 	bl	1005ec8 <mayfly_enqueue>
		LL_ASSERT(!retval);
 100153a:	2800      	cmp	r0, #0
 100153c:	f040 85be 	bne.w	10020bc <ull_conn_llcp+0x14dc>
	    conn->tx_head &&
 1001540:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
	if (
 1001544:	2b00      	cmp	r3, #0
 1001546:	f000 8349 	beq.w	1001bdc <ull_conn_llcp+0xffc>
	    !conn->llcp_enc.pause_tx &&
 100154a:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
	    conn->tx_head &&
 100154e:	0790      	lsls	r0, r2, #30
 1001550:	f100 8344 	bmi.w	1001bdc <ull_conn_llcp+0xffc>
	    !conn->llcp_phy.pause_tx &&
 1001554:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
 1001558:	07d1      	lsls	r1, r2, #31
 100155a:	f100 833f 	bmi.w	1001bdc <ull_conn_llcp+0xffc>
		if (conn->tx_head == conn->tx_data) {
 100155e:	f8d4 21bc 	ldr.w	r2, [r4, #444]	; 0x1bc
 1001562:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 1001564:	bf04      	itt	eq
 1001566:	681a      	ldreq	r2, [r3, #0]
 1001568:	f8c4 21bc 	streq.w	r2, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 100156c:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 1001570:	2a00      	cmp	r2, #0
 1001572:	f000 8725 	beq.w	10023c0 <ull_conn_llcp+0x17e0>
	tx->next = conn->tx_ctrl_last->next;
 1001576:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 100157a:	681a      	ldr	r2, [r3, #0]
 100157c:	602a      	str	r2, [r5, #0]
	conn->tx_ctrl_last->next = tx;
 100157e:	601d      	str	r5, [r3, #0]
	conn->tx_ctrl_last = tx;
 1001580:	f8c4 51b8 	str.w	r5, [r4, #440]	; 0x1b8
 1001584:	682b      	ldr	r3, [r5, #0]
	if (!tx->next) {
 1001586:	2b00      	cmp	r3, #0
 1001588:	f47f ab41 	bne.w	1000c0e <ull_conn_llcp+0x2e>
		conn->tx_data_last = tx;
 100158c:	f8c4 51c0 	str.w	r5, [r4, #448]	; 0x1c0
 1001590:	f7ff bb3d 	b.w	1000c0e <ull_conn_llcp+0x2e>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1001594:	4880      	ldr	r0, [pc, #512]	; (1001798 <ull_conn_llcp+0xbb8>)
 1001596:	f004 fbbf 	bl	1005d18 <mem_acquire>
		if (tx) {
 100159a:	4606      	mov	r6, r0
 100159c:	2800      	cmp	r0, #0
 100159e:	f43f ab36 	beq.w	1000c0e <ull_conn_llcp+0x2e>
			pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl,
 10015a2:	2708      	movs	r7, #8
			pdu_ctrl_tx->llctrl.opcode =
 10015a4:	2001      	movs	r0, #1
			conn->llcp.chan_map.instant = event_counter +
 10015a6:	8e23      	ldrh	r3, [r4, #48]	; 0x30
			conn->llcp.chan_map.initiate = 0U;
 10015a8:	f894 10ec 	ldrb.w	r1, [r4, #236]	; 0xec
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 10015ac:	7932      	ldrb	r2, [r6, #4]
			conn->llcp.chan_map.instant = event_counter +
 10015ae:	441d      	add	r5, r3
						      conn->lll.latency + 6;
 10015b0:	1dab      	adds	r3, r5, #6
			conn->llcp.chan_map.initiate = 0U;
 10015b2:	f36f 0100 	bfc	r1, #0, #1
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 10015b6:	f042 0203 	orr.w	r2, r2, #3
			conn->llcp.chan_map.instant = event_counter +
 10015ba:	f8a4 30f2 	strh.w	r3, [r4, #242]	; 0xf2
			conn->llcp.chan_map.initiate = 0U;
 10015be:	f884 10ec 	strb.w	r1, [r4, #236]	; 0xec
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 10015c2:	7132      	strb	r2, [r6, #4]
			pdu_ctrl_tx->llctrl.opcode =
 10015c4:	71f0      	strb	r0, [r6, #7]
			memcpy(&pdu_ctrl_tx->llctrl.chan_map_ind.chm[0],
 10015c6:	2205      	movs	r2, #5
			pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl,
 10015c8:	7177      	strb	r7, [r6, #5]
			memcpy(&pdu_ctrl_tx->llctrl.chan_map_ind.chm[0],
 10015ca:	f104 01ed 	add.w	r1, r4, #237	; 0xed
 10015ce:	19f0      	adds	r0, r6, r7
 10015d0:	f015 fa22 	bl	1016a18 <memcpy>
			pdu_ctrl_tx->llctrl.chan_map_ind.instant =
 10015d4:	f8b4 20f2 	ldrh.w	r2, [r4, #242]	; 0xf2
	    conn->tx_head &&
 10015d8:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
			pdu_ctrl_tx->llctrl.chan_map_ind.instant =
 10015dc:	f8a6 200d 	strh.w	r2, [r6, #13]
	if (
 10015e0:	2b00      	cmp	r3, #0
 10015e2:	f000 8411 	beq.w	1001e08 <ull_conn_llcp+0x1228>
	    !conn->llcp_enc.pause_tx &&
 10015e6:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
	    conn->tx_head &&
 10015ea:	0795      	lsls	r5, r2, #30
 10015ec:	f100 840c 	bmi.w	1001e08 <ull_conn_llcp+0x1228>
	    !conn->llcp_phy.pause_tx &&
 10015f0:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
 10015f4:	07d0      	lsls	r0, r2, #31
 10015f6:	f100 8407 	bmi.w	1001e08 <ull_conn_llcp+0x1228>
		if (conn->tx_head == conn->tx_data) {
 10015fa:	f8d4 21bc 	ldr.w	r2, [r4, #444]	; 0x1bc
 10015fe:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 1001600:	bf04      	itt	eq
 1001602:	681a      	ldreq	r2, [r3, #0]
 1001604:	f8c4 21bc 	streq.w	r2, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 1001608:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 100160c:	2a00      	cmp	r2, #0
 100160e:	f000 86ea 	beq.w	10023e6 <ull_conn_llcp+0x1806>
	tx->next = conn->tx_ctrl_last->next;
 1001612:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 1001616:	681a      	ldr	r2, [r3, #0]
 1001618:	6032      	str	r2, [r6, #0]
	conn->tx_ctrl_last->next = tx;
 100161a:	601e      	str	r6, [r3, #0]
	conn->tx_ctrl_last = tx;
 100161c:	f8c4 61b8 	str.w	r6, [r4, #440]	; 0x1b8
 1001620:	6833      	ldr	r3, [r6, #0]
	if (!tx->next) {
 1001622:	2b00      	cmp	r3, #0
 1001624:	f47f aaf3 	bne.w	1000c0e <ull_conn_llcp+0x2e>
		conn->tx_data_last = tx;
 1001628:	f8c4 61c0 	str.w	r6, [r4, #448]	; 0x1c0
 100162c:	f7ff baef 	b.w	1000c0e <ull_conn_llcp+0x2e>
		rx = ll_pdu_rx_alloc_peek(2);
 1001630:	2002      	movs	r0, #2
 1001632:	f008 fdb3 	bl	100a19c <ll_pdu_rx_alloc_peek>
		if (!rx) {
 1001636:	4607      	mov	r7, r0
 1001638:	2800      	cmp	r0, #0
 100163a:	f43f aae8 	beq.w	1000c0e <ull_conn_llcp+0x2e>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100163e:	4856      	ldr	r0, [pc, #344]	; (1001798 <ull_conn_llcp+0xbb8>)
 1001640:	f004 fb6a 	bl	1005d18 <mem_acquire>
		if (!tx) {
 1001644:	4680      	mov	r8, r0
 1001646:	2800      	cmp	r0, #0
 1001648:	f43f aae1 	beq.w	1000c0e <ull_conn_llcp+0x2e>
		conn->llcp.phy_upd_ind.initiate = 0U;
 100164c:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
 1001650:	f36f 0300 	bfc	r3, #0, #1
		       conn->llcp.phy_upd_ind.rx) & 0x07)) {
 1001654:	f3c3 1642 	ubfx	r6, r3, #5, #3
		if (!((conn->llcp.phy_upd_ind.tx |
 1001658:	ea46 0693 	orr.w	r6, r6, r3, lsr #2
 100165c:	f016 0607 	ands.w	r6, r6, #7
		conn->llcp.phy_upd_ind.initiate = 0U;
 1001660:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
		if (!((conn->llcp.phy_upd_ind.tx |
 1001664:	b2db      	uxtb	r3, r3
 1001666:	f040 85b1 	bne.w	10021cc <ull_conn_llcp+0x15ec>
			conn->llcp_ack = conn->llcp_req;
 100166a:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
			if (conn->llcp.phy_upd_ind.cmd) {
 100166e:	079d      	lsls	r5, r3, #30
			conn->llcp.phy_upd_ind.instant = 0U;
 1001670:	f8a4 60ee 	strh.w	r6, [r4, #238]	; 0xee
			conn->llcp_ack = conn->llcp_req;
 1001674:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
			if (conn->llcp.phy_upd_ind.cmd) {
 1001678:	f100 8629 	bmi.w	10022ce <ull_conn_llcp+0x16ee>
 100167c:	4633      	mov	r3, r6
 100167e:	4630      	mov	r0, r6
		pdu_ctrl_tx->len =
 1001680:	2205      	movs	r2, #5
		pdu_ctrl_tx->llctrl.opcode =
 1001682:	2118      	movs	r1, #24
		pdu_ctrl_tx->len =
 1001684:	f888 2005 	strb.w	r2, [r8, #5]
		ind->m_to_s_phy = conn->llcp.phy_upd_ind.tx;
 1001688:	f888 6008 	strb.w	r6, [r8, #8]
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100168c:	f898 2004 	ldrb.w	r2, [r8, #4]
		ind->s_to_m_phy = conn->llcp.phy_upd_ind.rx;
 1001690:	f888 3009 	strb.w	r3, [r8, #9]
	    conn->tx_head &&
 1001694:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001698:	f042 0203 	orr.w	r2, r2, #3
		ind->instant = sys_cpu_to_le16(conn->llcp.phy_upd_ind.instant);
 100169c:	f8a8 000a 	strh.w	r0, [r8, #10]
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 10016a0:	f888 2004 	strb.w	r2, [r8, #4]
		pdu_ctrl_tx->llctrl.opcode =
 10016a4:	f888 1007 	strb.w	r1, [r8, #7]
	if (
 10016a8:	2b00      	cmp	r3, #0
 10016aa:	f000 83a1 	beq.w	1001df0 <ull_conn_llcp+0x1210>
	    !conn->llcp_enc.pause_tx &&
 10016ae:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
	    conn->tx_head &&
 10016b2:	0790      	lsls	r0, r2, #30
 10016b4:	f100 839c 	bmi.w	1001df0 <ull_conn_llcp+0x1210>
	    !conn->llcp_phy.pause_tx &&
 10016b8:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
 10016bc:	07d1      	lsls	r1, r2, #31
 10016be:	f100 8397 	bmi.w	1001df0 <ull_conn_llcp+0x1210>
		if (conn->tx_head == conn->tx_data) {
 10016c2:	f8d4 21bc 	ldr.w	r2, [r4, #444]	; 0x1bc
 10016c6:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 10016c8:	bf04      	itt	eq
 10016ca:	681a      	ldreq	r2, [r3, #0]
 10016cc:	f8c4 21bc 	streq.w	r2, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 10016d0:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 10016d4:	2a00      	cmp	r2, #0
 10016d6:	f000 867b 	beq.w	10023d0 <ull_conn_llcp+0x17f0>
	tx->next = conn->tx_ctrl_last->next;
 10016da:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 10016de:	681a      	ldr	r2, [r3, #0]
 10016e0:	f8c8 2000 	str.w	r2, [r8]
	conn->tx_ctrl_last->next = tx;
 10016e4:	f8c3 8000 	str.w	r8, [r3]
	conn->tx_ctrl_last = tx;
 10016e8:	f8c4 81b8 	str.w	r8, [r4, #440]	; 0x1b8
 10016ec:	f8d8 3000 	ldr.w	r3, [r8]
	if (!tx->next) {
 10016f0:	2b00      	cmp	r3, #0
 10016f2:	f47f aa8c 	bne.w	1000c0e <ull_conn_llcp+0x2e>
		conn->tx_data_last = tx;
 10016f6:	f8c4 81c0 	str.w	r8, [r4, #448]	; 0x1c0
 10016fa:	f7ff ba88 	b.w	1000c0e <ull_conn_llcp+0x2e>
		conn_upd_curr = conn;
 10016fe:	f8c9 4000 	str.w	r4, [r9]
 1001702:	f7ff bb22 	b.w	1000d4a <ull_conn_llcp+0x16a>
		lll->max_rx_octets = conn->llcp_length.rx_octets;
 1001706:	f8b4 119c 	ldrh.w	r1, [r4, #412]	; 0x19c
		lll->max_rx_time = conn->llcp_length.rx_time;
 100170a:	f8b4 21a0 	ldrh.w	r2, [r4, #416]	; 0x1a0
		if (conn->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {
 100170e:	f000 0007 	and.w	r0, r0, #7
 1001712:	2804      	cmp	r0, #4
		tx_octets = conn->llcp_length.tx_octets;
 1001714:	f8b4 919e 	ldrh.w	r9, [r4, #414]	; 0x19e
		u16_t tx_time = conn->llcp_length.tx_time;
 1001718:	f8b4 81a2 	ldrh.w	r8, [r4, #418]	; 0x1a2
		lll->max_rx_octets = conn->llcp_length.rx_octets;
 100171c:	f8a4 105e 	strh.w	r1, [r4, #94]	; 0x5e
		lll->max_rx_time = conn->llcp_length.rx_time;
 1001720:	f8a4 2062 	strh.w	r2, [r4, #98]	; 0x62
		if (conn->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {
 1001724:	f000 84e3 	beq.w	10020ee <ull_conn_llcp+0x150e>
			conn->llcp_length.state =
 1001728:	2006      	movs	r0, #6
 100172a:	f894 319a 	ldrb.w	r3, [r4, #410]	; 0x19a
 100172e:	f360 0302 	bfi	r3, r0, #0, #3
 1001732:	f884 319a 	strb.w	r3, [r4, #410]	; 0x19a
		rx = conn->llcp_rx;
 1001736:	f8d4 7100 	ldr.w	r7, [r4, #256]	; 0x100
		LL_ASSERT(rx && rx->hdr.link);
 100173a:	2f00      	cmp	r7, #0
 100173c:	f000 84af 	beq.w	100209e <ull_conn_llcp+0x14be>
 1001740:	6838      	ldr	r0, [r7, #0]
 1001742:	2800      	cmp	r0, #0
 1001744:	f000 84ab 	beq.w	100209e <ull_conn_llcp+0x14be>
		pdu_ctrl_rx->len =
 1001748:	f04f 0e09 	mov.w	lr, #9
		pdu_ctrl_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 100174c:	f04f 0c15 	mov.w	ip, #21
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 1001750:	f04f 0a02 	mov.w	sl, #2
		pdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;
 1001754:	f897 3020 	ldrb.w	r3, [r7, #32]
		rx->hdr.handle = conn->lll.handle;
 1001758:	f8b4 b02c 	ldrh.w	fp, [r4, #44]	; 0x2c
		pdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;
 100175c:	f043 0303 	orr.w	r3, r3, #3
 1001760:	930b      	str	r3, [sp, #44]	; 0x2c
		conn->llcp_rx = rx->hdr.link->mem;
 1001762:	6843      	ldr	r3, [r0, #4]
 1001764:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
		pdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;
 1001768:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		lr->max_rx_octets = sys_cpu_to_le16(lll->max_rx_octets);
 100176a:	84b9      	strh	r1, [r7, #36]	; 0x24
		pdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;
 100176c:	f887 3020 	strb.w	r3, [r7, #32]
		ll_rx_put(rx->hdr.link, rx);
 1001770:	4639      	mov	r1, r7
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
 1001772:	84fa      	strh	r2, [r7, #38]	; 0x26
		pdu_ctrl_rx->len =
 1001774:	f887 e021 	strb.w	lr, [r7, #33]	; 0x21
		pdu_ctrl_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 1001778:	f887 c023 	strb.w	ip, [r7, #35]	; 0x23
		rx->hdr.handle = conn->lll.handle;
 100177c:	f8a7 b006 	strh.w	fp, [r7, #6]
		lr->max_tx_octets = sys_cpu_to_le16(tx_octets);
 1001780:	f8a7 9028 	strh.w	r9, [r7, #40]	; 0x28
		lr->max_tx_time = sys_cpu_to_le16(tx_time);
 1001784:	f8a7 802a 	strh.w	r8, [r7, #42]	; 0x2a
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 1001788:	f887 a004 	strb.w	sl, [r7, #4]
		ll_rx_put(rx->hdr.link, rx);
 100178c:	f008 fcf6 	bl	100a17c <ll_rx_put>
		ll_rx_sched();
 1001790:	f008 fcfe 	bl	100a190 <ll_rx_sched>
	break;
 1001794:	f7ff ba64 	b.w	1000c60 <ull_conn_llcp+0x80>
 1001798:	21005288 	.word	0x21005288
 100179c:	01018934 	.word	0x01018934
 10017a0:	d1b71759 	.word	0xd1b71759
 10017a4:	21000404 	.word	0x21000404
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 10017a8:	48bf      	ldr	r0, [pc, #764]	; (1001aa8 <ull_conn_llcp+0xec8>)
 10017aa:	f004 fab5 	bl	1005d18 <mem_acquire>
		if (!tx) {
 10017ae:	2800      	cmp	r0, #0
 10017b0:	f43f aa56 	beq.w	1000c60 <ull_conn_llcp+0x80>
		conn->llcp_length.state = LLCP_LENGTH_STATE_REQ_ACK_WAIT;
 10017b4:	f04f 0801 	mov.w	r8, #1
		pdu_ctrl_tx->len =
 10017b8:	2209      	movs	r2, #9
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
 10017ba:	f06f 0704 	mvn.w	r7, #4
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_REQ;
 10017be:	f04f 0e14 	mov.w	lr, #20
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
 10017c2:	f04f 0c00 	mov.w	ip, #0
		conn->llcp_length.state = LLCP_LENGTH_STATE_REQ_ACK_WAIT;
 10017c6:	f894 319a 	ldrb.w	r3, [r4, #410]	; 0x19a
		conn->default_tx_octets = conn->llcp_length.tx_octets;
 10017ca:	f8b4 119e 	ldrh.w	r1, [r4, #414]	; 0x19e
		conn->llcp_length.state = LLCP_LENGTH_STATE_REQ_ACK_WAIT;
 10017ce:	f368 0302 	bfi	r3, r8, #0, #3
 10017d2:	f884 319a 	strb.w	r3, [r4, #410]	; 0x19a
		conn->default_tx_time = conn->llcp_length.tx_time;
 10017d6:	f8b4 31a2 	ldrh.w	r3, [r4, #418]	; 0x1a2
		conn->default_tx_octets = conn->llcp_length.tx_octets;
 10017da:	f8a4 10d6 	strh.w	r1, [r4, #214]	; 0xd6
		conn->default_tx_time = conn->llcp_length.tx_time;
 10017de:	f8a4 30d8 	strh.w	r3, [r4, #216]	; 0xd8
		pdu_ctrl_tx->len =
 10017e2:	7142      	strb	r2, [r0, #5]
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 10017e4:	7902      	ldrb	r2, [r0, #4]
		lr->max_tx_octets = sys_cpu_to_le16(conn->default_tx_octets);
 10017e6:	8181      	strh	r1, [r0, #12]
	if (!conn->common.fex_valid ||
 10017e8:	f894 10dc 	ldrb.w	r1, [r4, #220]	; 0xdc
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 10017ec:	f042 0203 	orr.w	r2, r2, #3
 10017f0:	7102      	strb	r2, [r0, #4]
	feature_coded_phy = (conn->llcp_feature.features &
 10017f2:	f8d4 211c 	ldr.w	r2, [r4, #284]	; 0x11c
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
 10017f6:	7207      	strb	r7, [r0, #8]
	if (!conn->common.fex_valid ||
 10017f8:	07cf      	lsls	r7, r1, #31
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_REQ;
 10017fa:	f880 e007 	strb.w	lr, [r0, #7]
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
 10017fe:	f880 c009 	strb.w	ip, [r0, #9]
	if (!conn->common.fex_valid ||
 1001802:	f140 8440 	bpl.w	1002086 <ull_conn_llcp+0x14a6>
 1001806:	0511      	lsls	r1, r2, #20
 1001808:	f140 859d 	bpl.w	1002346 <ull_conn_llcp+0x1766>
		tx_time = MIN(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_CODED),
 100180c:	f244 2190 	movw	r1, #17040	; 0x4290
 1001810:	428b      	cmp	r3, r1
 1001812:	bf28      	it	cs
 1001814:	460b      	movcs	r3, r1
		tx_time = MAX(PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M), tx_time);
 1001816:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
 100181a:	bf38      	it	cc
 100181c:	f44f 73a4 	movcc.w	r3, #328	; 0x148
	    conn->tx_head &&
 1001820:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
		lr->max_rx_time = sys_cpu_to_le16(rx_time);
 1001824:	8141      	strh	r1, [r0, #10]
		lr->max_tx_time = sys_cpu_to_le16(tx_time);
 1001826:	81c3      	strh	r3, [r0, #14]
	if (
 1001828:	2a00      	cmp	r2, #0
 100182a:	f000 840a 	beq.w	1002042 <ull_conn_llcp+0x1462>
	    !conn->llcp_enc.pause_tx &&
 100182e:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
	    conn->tx_head &&
 1001832:	079b      	lsls	r3, r3, #30
 1001834:	f100 8405 	bmi.w	1002042 <ull_conn_llcp+0x1462>
	    !conn->llcp_phy.pause_tx &&
 1001838:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
 100183c:	07df      	lsls	r7, r3, #31
 100183e:	f100 8400 	bmi.w	1002042 <ull_conn_llcp+0x1462>
		if (conn->tx_head == conn->tx_data) {
 1001842:	f8d4 31bc 	ldr.w	r3, [r4, #444]	; 0x1bc
 1001846:	429a      	cmp	r2, r3
			conn->tx_data = conn->tx_data->next;
 1001848:	bf04      	itt	eq
 100184a:	6813      	ldreq	r3, [r2, #0]
 100184c:	f8c4 31bc 	streq.w	r3, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 1001850:	f8d4 31b4 	ldr.w	r3, [r4, #436]	; 0x1b4
 1001854:	2b00      	cmp	r3, #0
 1001856:	f000 85ed 	beq.w	1002434 <ull_conn_llcp+0x1854>
	tx->next = conn->tx_ctrl_last->next;
 100185a:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 100185e:	681a      	ldr	r2, [r3, #0]
 1001860:	6002      	str	r2, [r0, #0]
	conn->tx_ctrl_last->next = tx;
 1001862:	6018      	str	r0, [r3, #0]
	conn->tx_ctrl_last = tx;
 1001864:	f8c4 01b8 	str.w	r0, [r4, #440]	; 0x1b8
 1001868:	6802      	ldr	r2, [r0, #0]
	if (!tx->next) {
 100186a:	2a00      	cmp	r2, #0
 100186c:	f000 852b 	beq.w	10022c6 <ull_conn_llcp+0x16e6>
		conn->procedure_expire = conn->procedure_reload;
 1001870:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
 1001874:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	break;
 1001878:	f7ff b9f2 	b.w	1000c60 <ull_conn_llcp+0x80>
		if (!conn->tx_ctrl) {
 100187c:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 1001880:	2a00      	cmp	r2, #0
 1001882:	f47f ad33 	bne.w	10012ec <ull_conn_llcp+0x70c>
			tx->next = conn->tx_head;
 1001886:	6003      	str	r3, [r0, #0]
				conn->tx_ctrl = tx;
 1001888:	e9c4 006c 	strd	r0, r0, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 100188c:	f8c4 01b8 	str.w	r0, [r4, #440]	; 0x1b8
 1001890:	e534      	b.n	10012fc <ull_conn_llcp+0x71c>
			ecb_encrypt(&conn->llcp_enc.ltk[0],
 1001892:	f104 077f 	add.w	r7, r4, #127	; 0x7f
 1001896:	463b      	mov	r3, r7
 1001898:	462a      	mov	r2, r5
 100189a:	f104 01ee 	add.w	r1, r4, #238	; 0xee
 100189e:	f204 105d 	addw	r0, r4, #349	; 0x15d
 10018a2:	f010 f94d 	bl	1011b40 <ecb_encrypt>
			memcpy(&lll->ccm_tx.key[0],
 10018a6:	4639      	mov	r1, r7
			pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl,
 10018a8:	2701      	movs	r7, #1
			memcpy(&lll->ccm_tx.key[0],
 10018aa:	2210      	movs	r2, #16
 10018ac:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
 10018b0:	f015 f8b2 	bl	1016a18 <memcpy>
			memcpy(&lll->ccm_tx.iv[0], &lll->ccm_rx.iv[0],
 10018b4:	2208      	movs	r2, #8
 10018b6:	f104 0198 	add.w	r1, r4, #152	; 0x98
 10018ba:	f104 00b9 	add.w	r0, r4, #185	; 0xb9
 10018be:	f015 f8ab 	bl	1016a18 <memcpy>
			pdu_ctrl_tx->llctrl.opcode =
 10018c2:	2005      	movs	r0, #5
			lll->ccm_rx.direction = 1U;
 10018c4:	f894 2097 	ldrb.w	r2, [r4, #151]	; 0x97
			lll->ccm_tx.direction = 0U;
 10018c8:	f894 10b8 	ldrb.w	r1, [r4, #184]	; 0xb8
			lll->enc_rx = 1U;
 10018cc:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
			lll->ccm_rx.direction = 1U;
 10018d0:	433a      	orrs	r2, r7
			lll->enc_rx = 1U;
 10018d2:	f043 0308 	orr.w	r3, r3, #8
			lll->ccm_tx.direction = 0U;
 10018d6:	f365 0100 	bfi	r1, r5, #0, #1
			lll->ccm_rx.direction = 1U;
 10018da:	f884 2097 	strb.w	r2, [r4, #151]	; 0x97
			lll->enc_rx = 1U;
 10018de:	f884 307e 	strb.w	r3, [r4, #126]	; 0x7e
			lll->ccm_tx.counter = 0U;
 10018e2:	e9c4 552c 	strd	r5, r5, [r4, #176]	; 0xb0
			lll->ccm_rx.counter = 0U;
 10018e6:	f884 508f 	strb.w	r5, [r4, #143]	; 0x8f
 10018ea:	f884 5090 	strb.w	r5, [r4, #144]	; 0x90
 10018ee:	f884 5091 	strb.w	r5, [r4, #145]	; 0x91
 10018f2:	f884 5092 	strb.w	r5, [r4, #146]	; 0x92
 10018f6:	f884 5093 	strb.w	r5, [r4, #147]	; 0x93
 10018fa:	f884 5094 	strb.w	r5, [r4, #148]	; 0x94
 10018fe:	f884 5095 	strb.w	r5, [r4, #149]	; 0x95
 1001902:	f884 5096 	strb.w	r5, [r4, #150]	; 0x96
			lll->ccm_tx.direction = 0U;
 1001906:	f884 10b8 	strb.w	r1, [r4, #184]	; 0xb8
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100190a:	7932      	ldrb	r2, [r6, #4]
			pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl,
 100190c:	7177      	strb	r7, [r6, #5]
	    conn->tx_head &&
 100190e:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001912:	f042 0203 	orr.w	r2, r2, #3
 1001916:	7132      	strb	r2, [r6, #4]
			pdu_ctrl_tx->llctrl.opcode =
 1001918:	71f0      	strb	r0, [r6, #7]
	if (
 100191a:	2b00      	cmp	r3, #0
 100191c:	f47f ac69 	bne.w	10011f2 <ull_conn_llcp+0x612>
		if (!conn->tx_ctrl) {
 1001920:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 1001924:	2a00      	cmp	r2, #0
 1001926:	f47f ac7a 	bne.w	100121e <ull_conn_llcp+0x63e>
			tx->next = conn->tx_head;
 100192a:	6033      	str	r3, [r6, #0]
				conn->tx_ctrl = tx;
 100192c:	e9c4 666c 	strd	r6, r6, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 1001930:	f8c4 61b8 	str.w	r6, [r4, #440]	; 0x1b8
 1001934:	e47b      	b.n	100122e <ull_conn_llcp+0x64e>
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
 1001936:	f240 40e2 	movw	r0, #1250	; 0x4e2
 100193a:	a359      	add	r3, pc, #356	; (adr r3, 1001aa0 <ull_conn_llcp+0xec0>)
 100193c:	e9d3 2300 	ldrd	r2, r3, [r3]
 1001940:	fb09 111c 	mls	r1, r9, ip, r1
 1001944:	b289      	uxth	r1, r1
 1001946:	fb00 f101 	mul.w	r1, r0, r1
 100194a:	4858      	ldr	r0, [pc, #352]	; (1001aac <ull_conn_llcp+0xecc>)
 100194c:	fba1 0100 	umull	r0, r1, r1, r0
 1001950:	f7fe fbb2 	bl	10000b8 <__aeabi_uldivmod>
 1001954:	1a36      	subs	r6, r6, r0
 1001956:	f7ff ba85 	b.w	1000e64 <ull_conn_llcp+0x284>
		LL_ASSERT(rx && rx->hdr.link);
 100195a:	4855      	ldr	r0, [pc, #340]	; (1001ab0 <ull_conn_llcp+0xed0>)
 100195c:	f44f 610c 	mov.w	r1, #2240	; 0x8c0
 1001960:	f001 fe8e 	bl	1003680 <bt_ctlr_assert_handle>
 1001964:	f8d9 0000 	ldr.w	r0, [r9]
 1001968:	f7ff ba2d 	b.w	1000dc6 <ull_conn_llcp+0x1e6>
		} else if (conn->llcp_conn_param.ack !=
 100196c:	f894 c171 	ldrb.w	ip, [r4, #369]	; 0x171
 1001970:	f894 7170 	ldrb.w	r7, [r4, #368]	; 0x170
 1001974:	45bc      	cmp	ip, r7
 1001976:	f000 8275 	beq.w	1001e64 <ull_conn_llcp+0x1284>
	conn_upd = conn_upd_curr;
 100197a:	f8df 9138 	ldr.w	r9, [pc, #312]	; 1001ab4 <ull_conn_llcp+0xed4>
 100197e:	f8d9 7000 	ldr.w	r7, [r9]
	if (conn_upd && (conn_upd != conn)) {
 1001982:	2f00      	cmp	r7, #0
 1001984:	f000 84c6 	beq.w	1002314 <ull_conn_llcp+0x1734>
 1001988:	42bc      	cmp	r4, r7
 100198a:	f47f a940 	bne.w	1000c0e <ull_conn_llcp+0x2e>
	switch (conn->llcp_conn_param.state) {
 100198e:	f894 7172 	ldrb.w	r7, [r4, #370]	; 0x172
 1001992:	f007 0707 	and.w	r7, r7, #7
 1001996:	2f05      	cmp	r7, #5
 1001998:	f200 868f 	bhi.w	10026ba <ull_conn_llcp+0x1ada>
 100199c:	f20f 0c04 	addw	ip, pc, #4
 10019a0:	f85c f027 	ldr.w	pc, [ip, r7, lsl #2]
 10019a4:	01001ab9 	.word	0x01001ab9
 10019a8:	01001a1d 	.word	0x01001a1d
 10019ac:	010019bd 	.word	0x010019bd
 10019b0:	01000c05 	.word	0x01000c05
 10019b4:	01000c05 	.word	0x01000c05
 10019b8:	01000c05 	.word	0x01000c05
	if (conn->llcp_enc.pause_tx) {
 10019bc:	0783      	lsls	r3, r0, #30
 10019be:	f53f a926 	bmi.w	1000c0e <ull_conn_llcp+0x2e>
	rx = ll_pdu_rx_alloc();
 10019c2:	f008 fc09 	bl	100a1d8 <ll_pdu_rx_alloc>
	if (!rx) {
 10019c6:	4601      	mov	r1, r0
 10019c8:	2800      	cmp	r0, #0
 10019ca:	f43f acea 	beq.w	10013a2 <ull_conn_llcp+0x7c2>
	conn->llcp_conn_param.state = LLCP_CPR_STATE_APP_WAIT;
 10019ce:	2303      	movs	r3, #3
	rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 10019d0:	f04f 0e02 	mov.w	lr, #2
	pdu->len = offsetof(struct pdu_data_llctrl, conn_param_req) +
 10019d4:	f04f 0c18 	mov.w	ip, #24
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
 10019d8:	200f      	movs	r0, #15
	conn->llcp_conn_param.state = LLCP_CPR_STATE_APP_WAIT;
 10019da:	f894 2172 	ldrb.w	r2, [r4, #370]	; 0x172
	rx->hdr.handle = conn->lll.handle;
 10019de:	8da7      	ldrh	r7, [r4, #44]	; 0x2c
	conn->llcp_conn_param.state = LLCP_CPR_STATE_APP_WAIT;
 10019e0:	f363 0202 	bfi	r2, r3, #0, #3
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10019e4:	f891 3020 	ldrb.w	r3, [r1, #32]
	conn->llcp_conn_param.state = LLCP_CPR_STATE_APP_WAIT;
 10019e8:	f884 2172 	strb.w	r2, [r4, #370]	; 0x172
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10019ec:	f043 0303 	orr.w	r3, r3, #3
 10019f0:	f881 3020 	strb.w	r3, [r1, #32]
	rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 10019f4:	f881 e004 	strb.w	lr, [r1, #4]
	pdu->len = offsetof(struct pdu_data_llctrl, conn_param_req) +
 10019f8:	f881 c021 	strb.w	ip, [r1, #33]	; 0x21
	p->interval_min = sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
 10019fc:	f8b4 2174 	ldrh.w	r2, [r4, #372]	; 0x174
	p->interval_max = sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
 1001a00:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
	p->interval_min = sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
 1001a04:	848a      	strh	r2, [r1, #36]	; 0x24
	p->latency = sys_cpu_to_le16(conn->llcp_conn_param.latency);
 1001a06:	f8b4 2178 	ldrh.w	r2, [r4, #376]	; 0x178
	p->interval_max = sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
 1001a0a:	84cb      	strh	r3, [r1, #38]	; 0x26
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
 1001a0c:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
	rx->hdr.handle = conn->lll.handle;
 1001a10:	80cf      	strh	r7, [r1, #6]
	p->latency = sys_cpu_to_le16(conn->llcp_conn_param.latency);
 1001a12:	850a      	strh	r2, [r1, #40]	; 0x28
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
 1001a14:	854b      	strh	r3, [r1, #42]	; 0x2a
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
 1001a16:	f881 0023 	strb.w	r0, [r1, #35]	; 0x23
	ll_rx_put(rx->hdr.link, rx);
 1001a1a:	e4bd      	b.n	1001398 <ull_conn_llcp+0x7b8>
	if (conn->llcp_conn_param.status) {
 1001a1c:	f894 7173 	ldrb.w	r7, [r4, #371]	; 0x173
 1001a20:	2f00      	cmp	r7, #0
 1001a22:	f040 8516 	bne.w	1002452 <ull_conn_llcp+0x1872>
	if (!conn->lll.role) {
 1001a26:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
 1001a2a:	2b00      	cmp	r3, #0
 1001a2c:	f2c0 8549 	blt.w	10024c2 <ull_conn_llcp+0x18e2>
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
 1001a30:	2505      	movs	r5, #5
		conn->llcp_cu.win_size = 1U;
 1001a32:	2001      	movs	r0, #1
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
 1001a34:	f894 2172 	ldrb.w	r2, [r4, #370]	; 0x172
		if (conn->llcp_conn_param.preferred_periodicity) {
 1001a38:	f894 317c 	ldrb.w	r3, [r4, #380]	; 0x17c
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
 1001a3c:	f365 0202 	bfi	r2, r5, #0, #3
		conn->llcp_cu.win_offset_us = 0U;
 1001a40:	f8c4 7110 	str.w	r7, [r4, #272]	; 0x110
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
 1001a44:	f884 2172 	strb.w	r2, [r4, #370]	; 0x172
		conn->llcp_cu.win_size = 1U;
 1001a48:	f884 0114 	strb.w	r0, [r4, #276]	; 0x114
		if (conn->llcp_conn_param.preferred_periodicity) {
 1001a4c:	2b00      	cmp	r3, #0
 1001a4e:	f000 85ef 	beq.w	1002630 <ull_conn_llcp+0x1a50>
				((conn->llcp_conn_param.interval_min /
 1001a52:	f8b4 2174 	ldrh.w	r2, [r4, #372]	; 0x174
 1001a56:	fbb2 f2f3 	udiv	r2, r2, r3
			conn->llcp_cu.interval =
 1001a5a:	fb02 3303 	mla	r3, r2, r3, r3
 1001a5e:	b29a      	uxth	r2, r3
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
 1001a60:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
		conn->llcp_cu.state = LLCP_CUI_STATE_SELECT;
 1001a64:	f894 0106 	ldrb.w	r0, [r4, #262]	; 0x106
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
 1001a68:	f3c3 03c0 	ubfx	r3, r3, #3, #1
		conn->llcp_cu.state = LLCP_CUI_STATE_SELECT;
 1001a6c:	009b      	lsls	r3, r3, #2
 1001a6e:	f020 0007 	bic.w	r0, r0, #7
 1001a72:	f043 0302 	orr.w	r3, r3, #2
 1001a76:	4303      	orrs	r3, r0
		conn->llcp_cu.latency = conn->llcp_conn_param.latency;
 1001a78:	f8b4 5178 	ldrh.w	r5, [r4, #376]	; 0x178
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
 1001a7c:	f8b4 017a 	ldrh.w	r0, [r4, #378]	; 0x17a
		conn->llcp_cu.ack--;
 1001a80:	3901      	subs	r1, #1
 1001a82:	f884 1105 	strb.w	r1, [r4, #261]	; 0x105
 1001a86:	f8a4 2108 	strh.w	r2, [r4, #264]	; 0x108
		conn->llcp_cu.state = LLCP_CUI_STATE_SELECT;
 1001a8a:	f884 3106 	strb.w	r3, [r4, #262]	; 0x106
		conn->llcp_cu.latency = conn->llcp_conn_param.latency;
 1001a8e:	f8a4 510a 	strh.w	r5, [r4, #266]	; 0x10a
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
 1001a92:	f8a4 010c 	strh.w	r0, [r4, #268]	; 0x10c
		return;
 1001a96:	f7ff b8ba 	b.w	1000c0e <ull_conn_llcp+0x2e>
 1001a9a:	bf00      	nop
 1001a9c:	f3af 8000 	nop.w
 1001aa0:	1afd498d 	.word	0x1afd498d
 1001aa4:	00000007 	.word	0x00000007
 1001aa8:	21005288 	.word	0x21005288
 1001aac:	3b9aca00 	.word	0x3b9aca00
 1001ab0:	01018934 	.word	0x01018934
 1001ab4:	21004850 	.word	0x21004850
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1001ab8:	48e3      	ldr	r0, [pc, #908]	; (1001e48 <ull_conn_llcp+0x1268>)
			event_counter = lll->event_counter +
 1001aba:	f8b4 8036 	ldrh.w	r8, [r4, #54]	; 0x36
					lll->latency_prepare + lazy;
 1001abe:	f8b4 a032 	ldrh.w	sl, [r4, #50]	; 0x32
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1001ac2:	f004 f929 	bl	1005d18 <mem_acquire>
	if (!tx) {
 1001ac6:	4607      	mov	r7, r0
 1001ac8:	2800      	cmp	r0, #0
 1001aca:	f43f ac6a 	beq.w	10013a2 <ull_conn_llcp+0x7c2>
	conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP_WAIT;
 1001ace:	2104      	movs	r1, #4
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, conn_param_req) +
 1001ad0:	f04f 0e18 	mov.w	lr, #24
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
 1001ad4:	f04f 0c0f 	mov.w	ip, #15
	p->offset1 = sys_cpu_to_le16(0xffff);
 1001ad8:	f04f 30ff 	mov.w	r0, #4294967295
	p->preferred_periodicity = 0U;
 1001adc:	2200      	movs	r2, #0
			event_counter = lll->event_counter +
 1001ade:	eb08 030a 	add.w	r3, r8, sl
	conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP_WAIT;
 1001ae2:	f894 8172 	ldrb.w	r8, [r4, #370]	; 0x172
	p->reference_conn_event_count = sys_cpu_to_le16(event_counter);
 1001ae6:	442b      	add	r3, r5
	conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP_WAIT;
 1001ae8:	f361 0802 	bfi	r8, r1, #0, #3
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001aec:	7939      	ldrb	r1, [r7, #4]
	conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP_WAIT;
 1001aee:	f884 8172 	strb.w	r8, [r4, #370]	; 0x172
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001af2:	f041 0103 	orr.w	r1, r1, #3
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, conn_param_req) +
 1001af6:	f887 e005 	strb.w	lr, [r7, #5]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001afa:	7139      	strb	r1, [r7, #4]
	p->interval_min = sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
 1001afc:	f8b4 1174 	ldrh.w	r1, [r4, #372]	; 0x174
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
 1001b00:	f887 c007 	strb.w	ip, [r7, #7]
	p->interval_min = sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
 1001b04:	8139      	strh	r1, [r7, #8]
	p->latency = sys_cpu_to_le16(conn->llcp_conn_param.latency);
 1001b06:	f8b4 1178 	ldrh.w	r1, [r4, #376]	; 0x178
	p->interval_max = sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
 1001b0a:	f8b4 c176 	ldrh.w	ip, [r4, #374]	; 0x176
	p->latency = sys_cpu_to_le16(conn->llcp_conn_param.latency);
 1001b0e:	81b9      	strh	r1, [r7, #12]
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
 1001b10:	f8b4 117a 	ldrh.w	r1, [r4, #378]	; 0x17a
	p->interval_max = sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
 1001b14:	f8a7 c00a 	strh.w	ip, [r7, #10]
	p->reference_conn_event_count = sys_cpu_to_le16(event_counter);
 1001b18:	f8a7 3011 	strh.w	r3, [r7, #17]
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
 1001b1c:	81f9      	strh	r1, [r7, #14]
	p->preferred_periodicity = 0U;
 1001b1e:	743a      	strb	r2, [r7, #16]
	p->offset0 = sys_cpu_to_le16(0x0000);
 1001b20:	74fa      	strb	r2, [r7, #19]
 1001b22:	753a      	strb	r2, [r7, #20]
	p->offset1 = sys_cpu_to_le16(0xffff);
 1001b24:	7578      	strb	r0, [r7, #21]
 1001b26:	75b8      	strb	r0, [r7, #22]
	p->offset2 = sys_cpu_to_le16(0xffff);
 1001b28:	75f8      	strb	r0, [r7, #23]
 1001b2a:	7638      	strb	r0, [r7, #24]
	p->offset3 = sys_cpu_to_le16(0xffff);
 1001b2c:	7678      	strb	r0, [r7, #25]
 1001b2e:	76b8      	strb	r0, [r7, #26]
	p->offset4 = sys_cpu_to_le16(0xffff);
 1001b30:	76f8      	strb	r0, [r7, #27]
 1001b32:	7738      	strb	r0, [r7, #28]
	p->offset5 = sys_cpu_to_le16(0xffff);
 1001b34:	7778      	strb	r0, [r7, #29]
 1001b36:	77b8      	strb	r0, [r7, #30]
	ctrl_tx_pause_enqueue(conn, tx, false);
 1001b38:	4639      	mov	r1, r7
 1001b3a:	4620      	mov	r0, r4
 1001b3c:	f009 fad8 	bl	100b0f0 <ctrl_tx_pause_enqueue>
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
 1001b40:	6822      	ldr	r2, [r4, #0]
	conn->procedure_expire = conn->procedure_reload;
 1001b42:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
 1001b46:	2a00      	cmp	r2, #0
	conn_upd_curr = conn;
 1001b48:	f8c9 4000 	str.w	r4, [r9]
		conn->llcp_conn_param.ticks_ref = ticks_at_expire;
 1001b4c:	f8c4 6190 	str.w	r6, [r4, #400]	; 0x190
	conn->procedure_expire = conn->procedure_reload;
 1001b50:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
 1001b54:	da0a      	bge.n	1001b6c <ull_conn_llcp+0xf8c>
			u32_t ticks_prepare_to_start =
 1001b56:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
			conn->llcp_conn_param.ticks_ref -=
 1001b5a:	428b      	cmp	r3, r1
 1001b5c:	bf2c      	ite	cs
 1001b5e:	18f3      	addcs	r3, r6, r3
 1001b60:	1873      	addcc	r3, r6, r1
				(conn->evt.ticks_xtal_to_start &
 1001b62:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
			conn->llcp_conn_param.ticks_ref -=
 1001b66:	1a9b      	subs	r3, r3, r2
 1001b68:	f8c4 3190 	str.w	r3, [r4, #400]	; 0x190
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 1001b6c:	2201      	movs	r2, #1
		s_mfy_sched_offset.param = (void *)conn;
 1001b6e:	4bb7      	ldr	r3, [pc, #732]	; (1001e4c <ull_conn_llcp+0x126c>)
		conn->llcp_conn_param.pdu_win_offset0 = (u16_t *)&p->offset0;
 1001b70:	3713      	adds	r7, #19
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 1001b72:	4610      	mov	r0, r2
 1001b74:	2102      	movs	r1, #2
		conn->llcp_conn_param.pdu_win_offset0 = (u16_t *)&p->offset0;
 1001b76:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
		s_mfy_sched_offset.param = (void *)conn;
 1001b7a:	609c      	str	r4, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 1001b7c:	f004 f9a4 	bl	1005ec8 <mayfly_enqueue>
		LL_ASSERT(!retval);
 1001b80:	2800      	cmp	r0, #0
 1001b82:	f43f ac0e 	beq.w	10013a2 <ull_conn_llcp+0x7c2>
 1001b86:	f640 3176 	movw	r1, #2934	; 0xb76
 1001b8a:	48b1      	ldr	r0, [pc, #708]	; (1001e50 <ull_conn_llcp+0x1270>)
 1001b8c:	f001 fd78 	bl	1003680 <bt_ctlr_assert_handle>
 1001b90:	e407      	b.n	10013a2 <ull_conn_llcp+0x7c2>
		if ((conn->llcp_cu.interval != lll->interval) ||
 1001b92:	8e23      	ldrh	r3, [r4, #48]	; 0x30
 1001b94:	4573      	cmp	r3, lr
 1001b96:	f47f a921 	bne.w	1000ddc <ull_conn_llcp+0x1fc>
		    (RADIO_CONN_EVENTS(conn->llcp_cu.timeout * 10000U,
 1001b9a:	f240 41e2 	movw	r1, #1250	; 0x4e2
 1001b9e:	f242 7310 	movw	r3, #10000	; 0x2710
 1001ba2:	fb01 f10c 	mul.w	r1, r1, ip
 1001ba6:	f8b4 a10c 	ldrh.w	sl, [r4, #268]	; 0x10c
		    (conn->llcp_cu.latency != lll->latency) ||
 1001baa:	f8b4 20c6 	ldrh.w	r2, [r4, #198]	; 0xc6
		    (RADIO_CONN_EVENTS(conn->llcp_cu.timeout * 10000U,
 1001bae:	fb03 130a 	mla	r3, r3, sl, r1
 1001bb2:	3b01      	subs	r3, #1
 1001bb4:	fbb3 f3f1 	udiv	r3, r3, r1
		    (conn->llcp_cu.latency != lll->latency) ||
 1001bb8:	b29b      	uxth	r3, r3
 1001bba:	429a      	cmp	r2, r3
 1001bbc:	f47f a910 	bne.w	1000de0 <ull_conn_llcp+0x200>
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 1001bc0:	2303      	movs	r3, #3
 1001bc2:	f889 3004 	strb.w	r3, [r9, #4]
 1001bc6:	f7ff b91a 	b.w	1000dfe <ull_conn_llcp+0x21e>
			mayfly_enable(TICKER_USER_ID_ULL_HIGH,
 1001bca:	2201      	movs	r2, #1
 1001bcc:	2102      	movs	r1, #2
 1001bce:	4610      	mov	r0, r2
 1001bd0:	f004 f946 	bl	1005e60 <mayfly_enable>
				return -ECANCELED;
 1001bd4:	f06f 0047 	mvn.w	r0, #71	; 0x47
 1001bd8:	f7ff b820 	b.w	1000c1c <ull_conn_llcp+0x3c>
		if (!conn->tx_ctrl) {
 1001bdc:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 1001be0:	2a00      	cmp	r2, #0
 1001be2:	f47f acc8 	bne.w	1001576 <ull_conn_llcp+0x996>
			tx->next = conn->tx_head;
 1001be6:	602b      	str	r3, [r5, #0]
				conn->tx_ctrl = tx;
 1001be8:	e9c4 556c 	strd	r5, r5, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 1001bec:	f8c4 51b8 	str.w	r5, [r4, #440]	; 0x1b8
 1001bf0:	e4c9      	b.n	1001586 <ull_conn_llcp+0x9a6>
		tx_time = MAX(MIN(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_1M),
 1001bf2:	f640 0248 	movw	r2, #2120	; 0x848
 1001bf6:	f7ff ba15 	b.w	1001024 <ull_conn_llcp+0x444>
			lll->slave.window_widening_prepare_us -=
 1001bfa:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
				lll->slave.window_widening_periodic_us *
 1001bfc:	6c63      	ldr	r3, [r4, #68]	; 0x44
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
 1001bfe:	4f95      	ldr	r7, [pc, #596]	; (1001e54 <ull_conn_llcp+0x1274>)
			lll->slave.window_widening_prepare_us -=
 1001c00:	fb03 231b 	mls	r3, r3, fp, r2
 1001c04:	64e3      	str	r3, [r4, #76]	; 0x4c
				(((lll_conn_ppm_local_get() +
 1001c06:	f00f fa31 	bl	101106c <lll_conn_ppm_local_get>
				   lll_conn_ppm_get(conn->slave.sca)) *
 1001c0a:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
				(((lll_conn_ppm_local_get() +
 1001c0e:	4680      	mov	r8, r0
				   lll_conn_ppm_get(conn->slave.sca)) *
 1001c10:	f3c3 0082 	ubfx	r0, r3, #2, #3
 1001c14:	f00f fa2c 	bl	1011070 <lll_conn_ppm_get>
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
 1001c18:	a389      	add	r3, pc, #548	; (adr r3, 1001e40 <ull_conn_llcp+0x1260>)
 1001c1a:	e9d3 2300 	ldrd	r2, r3, [r3]
				(((lll_conn_ppm_local_get() +
 1001c1e:	eb08 0100 	add.w	r1, r8, r0
				   lll_conn_ppm_get(conn->slave.sca)) *
 1001c22:	fb05 f101 	mul.w	r1, r5, r1
				  conn_interval_us) + (1000000 - 1)) / 1000000U;
 1001c26:	488c      	ldr	r0, [pc, #560]	; (1001e58 <ull_conn_llcp+0x1278>)
 1001c28:	f501 2174 	add.w	r1, r1, #999424	; 0xf4000
 1001c2c:	f201 213f 	addw	r1, r1, #575	; 0x23f
 1001c30:	fba0 0101 	umull	r0, r1, r0, r1
 1001c34:	ea4f 4991 	mov.w	r9, r1, lsr #18
				lll->slave.window_widening_periodic_us *
 1001c38:	990b      	ldr	r1, [sp, #44]	; 0x2c
				(conn_interval_us >> 1) - EVENT_IFS_US;
 1001c3a:	0868      	lsrs	r0, r5, #1
				lll->slave.window_widening_periodic_us *
 1001c3c:	fb09 f801 	mul.w	r8, r9, r1
			lll->slave.window_widening_prepare_us +=
 1001c40:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
				(conn_interval_us >> 1) - EVENT_IFS_US;
 1001c42:	3896      	subs	r0, #150	; 0x96
			lll->slave.window_widening_prepare_us +=
 1001c44:	4441      	add	r1, r8
 1001c46:	4281      	cmp	r1, r0
 1001c48:	bf28      	it	cs
 1001c4a:	4601      	movcs	r1, r0
			conn->slave.ticks_to_offset = 0U;
 1001c4c:	f04f 0e00 	mov.w	lr, #0
				conn->llcp_cu.win_size * 1250U;
 1001c50:	f894 c114 	ldrb.w	ip, [r4, #276]	; 0x114
			lll->slave.window_widening_max_us =
 1001c54:	e9c4 0112 	strd	r0, r1, [r4, #72]	; 0x48
				conn->llcp_cu.win_size * 1250U;
 1001c58:	fb0a fc0c 	mul.w	ip, sl, ip
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
 1001c5c:	fba8 0107 	umull	r0, r1, r8, r7
			lll->slave.window_widening_periodic_us =
 1001c60:	f8c4 9044 	str.w	r9, [r4, #68]	; 0x44
			lll->slave.window_size_prepare_us =
 1001c64:	f8c4 c054 	str.w	ip, [r4, #84]	; 0x54
			conn->slave.ticks_to_offset = 0U;
 1001c68:	f8c4 e0e4 	str.w	lr, [r4, #228]	; 0xe4
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
 1001c6c:	f7fe fa24 	bl	10000b8 <__aeabi_uldivmod>
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
 1001c70:	a373      	add	r3, pc, #460	; (adr r3, 1001e40 <ull_conn_llcp+0x1260>)
 1001c72:	e9d3 2300 	ldrd	r2, r3, [r3]
 1001c76:	4979      	ldr	r1, [pc, #484]	; (1001e5c <ull_conn_llcp+0x127c>)
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
 1001c78:	1a36      	subs	r6, r6, r0
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
 1001c7a:	f8d4 0110 	ldr.w	r0, [r4, #272]	; 0x110
 1001c7e:	fba1 1000 	umull	r1, r0, r1, r0
 1001c82:	0a80      	lsrs	r0, r0, #10
 1001c84:	fb0a f000 	mul.w	r0, sl, r0
 1001c88:	fba0 0107 	umull	r0, r1, r0, r7
 1001c8c:	f7fe fa14 	bl	10000b8 <__aeabi_uldivmod>
			periodic_us -= lll->slave.window_widening_periodic_us;
 1001c90:	eba5 0a09 	sub.w	sl, r5, r9
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
 1001c94:	f020 487f 	bic.w	r8, r0, #4278190080	; 0xff000000
			periodic_us -= lll->slave.window_widening_periodic_us;
 1001c98:	f8b4 9108 	ldrh.w	r9, [r4, #264]	; 0x108
 1001c9c:	f7ff b902 	b.w	1000ea4 <ull_conn_llcp+0x2c4>
		ecb_encrypt(&conn->llcp_enc.ltk[0],
 1001ca0:	f104 077f 	add.w	r7, r4, #127	; 0x7f
 1001ca4:	463b      	mov	r3, r7
 1001ca6:	462a      	mov	r2, r5
 1001ca8:	f104 01ee 	add.w	r1, r4, #238	; 0xee
 1001cac:	f204 105d 	addw	r0, r4, #349	; 0x15d
 1001cb0:	f00f ff46 	bl	1011b40 <ecb_encrypt>
		memcpy(&lll->ccm_tx.key[0], &lll->ccm_rx.key[0],
 1001cb4:	4639      	mov	r1, r7
 1001cb6:	2210      	movs	r2, #16
 1001cb8:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
 1001cbc:	f014 feac 	bl	1016a18 <memcpy>
		memcpy(&lll->ccm_tx.iv[0], &lll->ccm_rx.iv[0],
 1001cc0:	2208      	movs	r2, #8
 1001cc2:	f104 0198 	add.w	r1, r4, #152	; 0x98
 1001cc6:	f104 00b9 	add.w	r0, r4, #185	; 0xb9
 1001cca:	f014 fea5 	bl	1016a18 <memcpy>
		lll->ccm_rx.direction = 0;
 1001cce:	f894 1097 	ldrb.w	r1, [r4, #151]	; 0x97
		lll->ccm_tx.direction = 1;
 1001cd2:	f894 20b8 	ldrb.w	r2, [r4, #184]	; 0xb8
		lll->enc_rx = 1;
 1001cd6:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
		lll->ccm_rx.direction = 0;
 1001cda:	f365 0100 	bfi	r1, r5, #0, #1
		lll->enc_rx = 1;
 1001cde:	f043 0308 	orr.w	r3, r3, #8
		lll->ccm_tx.direction = 1;
 1001ce2:	f042 0201 	orr.w	r2, r2, #1
		lll->ccm_rx.direction = 0;
 1001ce6:	f884 1097 	strb.w	r1, [r4, #151]	; 0x97
		lll->enc_rx = 1;
 1001cea:	f884 307e 	strb.w	r3, [r4, #126]	; 0x7e
		start_enc_rsp_send(conn, pdu_ctrl_tx);
 1001cee:	4620      	mov	r0, r4
		lll->ccm_tx.counter = 0;
 1001cf0:	e9c4 552c 	strd	r5, r5, [r4, #176]	; 0xb0
		lll->ccm_rx.counter = 0;
 1001cf4:	f884 508f 	strb.w	r5, [r4, #143]	; 0x8f
 1001cf8:	f884 5090 	strb.w	r5, [r4, #144]	; 0x90
 1001cfc:	f884 5091 	strb.w	r5, [r4, #145]	; 0x91
 1001d00:	f884 5092 	strb.w	r5, [r4, #146]	; 0x92
 1001d04:	f884 5093 	strb.w	r5, [r4, #147]	; 0x93
 1001d08:	f884 5094 	strb.w	r5, [r4, #148]	; 0x94
 1001d0c:	f884 5095 	strb.w	r5, [r4, #149]	; 0x95
 1001d10:	f884 5096 	strb.w	r5, [r4, #150]	; 0x96
		lll->ccm_tx.direction = 1;
 1001d14:	f884 20b8 	strb.w	r2, [r4, #184]	; 0xb8
		start_enc_rsp_send(conn, pdu_ctrl_tx);
 1001d18:	1d31      	adds	r1, r6, #4
 1001d1a:	f009 fb91 	bl	100b440 <start_enc_rsp_send>
	    conn->tx_head &&
 1001d1e:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
	if (
 1001d22:	2b00      	cmp	r3, #0
 1001d24:	f47f aa65 	bne.w	10011f2 <ull_conn_llcp+0x612>
 1001d28:	e5fa      	b.n	1001920 <ull_conn_llcp+0xd40>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1001d2a:	4847      	ldr	r0, [pc, #284]	; (1001e48 <ull_conn_llcp+0x1268>)
 1001d2c:	f003 fff4 	bl	1005d18 <mem_acquire>
	if (tx) {
 1001d30:	4680      	mov	r8, r0
 1001d32:	2800      	cmp	r0, #0
 1001d34:	f43f ab35 	beq.w	10013a2 <ull_conn_llcp+0x7c2>
		pdu->len = offsetof(struct pdu_data_llctrl, feature_req) +
 1001d38:	2209      	movs	r2, #9
		conn->llcp_feature.ack--;
 1001d3a:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
		conn->llcp_feature.features = LL_FEAT;
 1001d3e:	4948      	ldr	r1, [pc, #288]	; (1001e60 <ull_conn_llcp+0x1280>)
		conn->llcp_feature.ack--;
 1001d40:	3b01      	subs	r3, #1
 1001d42:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119
		conn->llcp_feature.features = LL_FEAT;
 1001d46:	f8c4 111c 	str.w	r1, [r4, #284]	; 0x11c
		pdu->len = offsetof(struct pdu_data_llctrl, feature_req) +
 1001d4a:	7142      	strb	r2, [r0, #5]
		pdu->llctrl.opcode = !conn->lll.role ?
 1001d4c:	f994 203d 	ldrsb.w	r2, [r4, #61]	; 0x3d
		pdu->ll_id = PDU_DATA_LLID_CTRL;
 1001d50:	7903      	ldrb	r3, [r0, #4]
		pdu->llctrl.opcode = !conn->lll.role ?
 1001d52:	2a00      	cmp	r2, #0
 1001d54:	bfac      	ite	ge
 1001d56:	2208      	movge	r2, #8
 1001d58:	220e      	movlt	r2, #14
 1001d5a:	71c2      	strb	r2, [r0, #7]
		(void)memset(&pdu->llctrl.feature_req.features[0],
 1001d5c:	2208      	movs	r2, #8
		pdu->ll_id = PDU_DATA_LLID_CTRL;
 1001d5e:	f043 0303 	orr.w	r3, r3, #3
 1001d62:	7103      	strb	r3, [r0, #4]
		(void)memset(&pdu->llctrl.feature_req.features[0],
 1001d64:	4639      	mov	r1, r7
 1001d66:	4410      	add	r0, r2
 1001d68:	f014 fe81 	bl	1016a6e <memset>
		sys_put_le24(conn->llcp_feature.features,
 1001d6c:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
	dst[1] = val >> 8;
 1001d70:	f3c3 2107 	ubfx	r1, r3, #8, #8
	dst[2] = val >> 16;
 1001d74:	0c1a      	lsrs	r2, r3, #16
	dst[0] = val;
 1001d76:	f888 3008 	strb.w	r3, [r8, #8]
	dst[1] = val >> 8;
 1001d7a:	f888 1009 	strb.w	r1, [r8, #9]
	dst[2] = val >> 16;
 1001d7e:	f888 200a 	strb.w	r2, [r8, #10]
	    conn->tx_head &&
 1001d82:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
	if (
 1001d86:	2b00      	cmp	r3, #0
 1001d88:	f000 8169 	beq.w	100205e <ull_conn_llcp+0x147e>
	    !conn->llcp_enc.pause_tx &&
 1001d8c:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
	    conn->tx_head &&
 1001d90:	0797      	lsls	r7, r2, #30
 1001d92:	f100 8164 	bmi.w	100205e <ull_conn_llcp+0x147e>
	    !conn->llcp_phy.pause_tx &&
 1001d96:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
 1001d9a:	07d0      	lsls	r0, r2, #31
 1001d9c:	f100 815f 	bmi.w	100205e <ull_conn_llcp+0x147e>
		if (conn->tx_head == conn->tx_data) {
 1001da0:	f8d4 21bc 	ldr.w	r2, [r4, #444]	; 0x1bc
 1001da4:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 1001da6:	bf04      	itt	eq
 1001da8:	681a      	ldreq	r2, [r3, #0]
 1001daa:	f8c4 21bc 	streq.w	r2, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 1001dae:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 1001db2:	2a00      	cmp	r2, #0
 1001db4:	f000 837b 	beq.w	10024ae <ull_conn_llcp+0x18ce>
	tx->next = conn->tx_ctrl_last->next;
 1001db8:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 1001dbc:	681a      	ldr	r2, [r3, #0]
 1001dbe:	f8c8 2000 	str.w	r2, [r8]
	conn->tx_ctrl_last->next = tx;
 1001dc2:	f8c3 8000 	str.w	r8, [r3]
	conn->tx_ctrl_last = tx;
 1001dc6:	f8c4 81b8 	str.w	r8, [r4, #440]	; 0x1b8
 1001dca:	f8d8 3000 	ldr.w	r3, [r8]
	if (!tx->next) {
 1001dce:	2b00      	cmp	r3, #0
 1001dd0:	f000 82b6 	beq.w	1002340 <ull_conn_llcp+0x1760>
		conn->procedure_expire = conn->procedure_reload;
 1001dd4:	f8b4 20ca 	ldrh.w	r2, [r4, #202]	; 0xca
 1001dd8:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 1001ddc:	f8a4 20cc 	strh.w	r2, [r4, #204]	; 0xcc
	break;
 1001de0:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
 1001de4:	f7fe bf0e 	b.w	1000c04 <ull_conn_llcp+0x24>
		conn->tx_data_last = tx;
 1001de8:	f8c4 01c0 	str.w	r0, [r4, #448]	; 0x1c0
 1001dec:	f7ff ba89 	b.w	1001302 <ull_conn_llcp+0x722>
		if (!conn->tx_ctrl) {
 1001df0:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 1001df4:	2a00      	cmp	r2, #0
 1001df6:	f47f ac70 	bne.w	10016da <ull_conn_llcp+0xafa>
			tx->next = conn->tx_head;
 1001dfa:	f8c8 3000 	str.w	r3, [r8]
				conn->tx_ctrl = tx;
 1001dfe:	e9c4 886c 	strd	r8, r8, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 1001e02:	f8c4 81b8 	str.w	r8, [r4, #440]	; 0x1b8
 1001e06:	e473      	b.n	10016f0 <ull_conn_llcp+0xb10>
		if (!conn->tx_ctrl) {
 1001e08:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 1001e0c:	2a00      	cmp	r2, #0
 1001e0e:	f47f ac00 	bne.w	1001612 <ull_conn_llcp+0xa32>
			tx->next = conn->tx_head;
 1001e12:	6033      	str	r3, [r6, #0]
				conn->tx_ctrl = tx;
 1001e14:	e9c4 666c 	strd	r6, r6, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 1001e18:	f8c4 61b8 	str.w	r6, [r4, #440]	; 0x1b8
 1001e1c:	e401      	b.n	1001622 <ull_conn_llcp+0xa42>
			lll->phy_tx = conn->llcp.phy_upd_ind.tx;
 1001e1e:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
 1001e22:	f3c6 0182 	ubfx	r1, r6, #2, #3
 1001e26:	f361 0202 	bfi	r2, r1, #0, #3
 1001e2a:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
			eff_tx_time = calc_eff_time(lll->max_tx_octets,
 1001e2e:	f894 005c 	ldrb.w	r0, [r4, #92]	; 0x5c
 1001e32:	462a      	mov	r2, r5
 1001e34:	f009 f916 	bl	100b064 <calc_eff_time>
 1001e38:	4607      	mov	r7, r0
 1001e3a:	f7ff b904 	b.w	1001046 <ull_conn_llcp+0x466>
 1001e3e:	bf00      	nop
 1001e40:	1afd498d 	.word	0x1afd498d
 1001e44:	00000007 	.word	0x00000007
 1001e48:	21005288 	.word	0x21005288
 1001e4c:	21000414 	.word	0x21000414
 1001e50:	01018934 	.word	0x01018934
 1001e54:	3b9aca00 	.word	0x3b9aca00
 1001e58:	431bde83 	.word	0x431bde83
 1001e5c:	d1b71759 	.word	0xd1b71759
 1001e60:	000149ff 	.word	0x000149ff
		} else if (conn->llcp_length.ack != conn->llcp_length.req) {
 1001e64:	f894 7198 	ldrb.w	r7, [r4, #408]	; 0x198
 1001e68:	f894 1199 	ldrb.w	r1, [r4, #409]	; 0x199
 1001e6c:	42b9      	cmp	r1, r7
 1001e6e:	f000 8149 	beq.w	1002104 <ull_conn_llcp+0x1524>
	switch (conn->llcp_length.state) {
 1001e72:	f894 119a 	ldrb.w	r1, [r4, #410]	; 0x19a
 1001e76:	f001 0007 	and.w	r0, r1, #7
 1001e7a:	2806      	cmp	r0, #6
 1001e7c:	f200 840f 	bhi.w	100269e <ull_conn_llcp+0x1abe>
 1001e80:	f20f 0c04 	addw	ip, pc, #4
 1001e84:	f85c f020 	ldr.w	pc, [ip, r0, lsl #2]
 1001e88:	01001f3d 	.word	0x01001f3d
 1001e8c:	01000c05 	.word	0x01000c05
 1001e90:	01000c05 	.word	0x01000c05
 1001e94:	01000c05 	.word	0x01000c05
 1001e98:	01001ea5 	.word	0x01001ea5
 1001e9c:	01001ea5 	.word	0x01001ea5
 1001ea0:	01000c05 	.word	0x01000c05
		lll->max_rx_octets = conn->llcp_length.rx_octets;
 1001ea4:	f8b4 019c 	ldrh.w	r0, [r4, #412]	; 0x19c
		lll->max_rx_time = conn->llcp_length.rx_time;
 1001ea8:	f8b4 21a0 	ldrh.w	r2, [r4, #416]	; 0x1a0
		if (conn->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {
 1001eac:	f001 0307 	and.w	r3, r1, #7
 1001eb0:	2b04      	cmp	r3, #4
		tx_octets = conn->llcp_length.tx_octets;
 1001eb2:	f8b4 919e 	ldrh.w	r9, [r4, #414]	; 0x19e
		u16_t tx_time = conn->llcp_length.tx_time;
 1001eb6:	f8b4 81a2 	ldrh.w	r8, [r4, #418]	; 0x1a2
		lll->max_rx_octets = conn->llcp_length.rx_octets;
 1001eba:	f8a4 005e 	strh.w	r0, [r4, #94]	; 0x5e
		lll->max_rx_time = conn->llcp_length.rx_time;
 1001ebe:	f8a4 2062 	strh.w	r2, [r4, #98]	; 0x62
		if (conn->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {
 1001ec2:	f000 82ea 	beq.w	100249a <ull_conn_llcp+0x18ba>
			conn->llcp_length.state =
 1001ec6:	2306      	movs	r3, #6
 1001ec8:	f363 0102 	bfi	r1, r3, #0, #3
 1001ecc:	f884 119a 	strb.w	r1, [r4, #410]	; 0x19a
		rx = conn->llcp_rx;
 1001ed0:	f8d4 7100 	ldr.w	r7, [r4, #256]	; 0x100
		LL_ASSERT(rx && rx->hdr.link);
 1001ed4:	2f00      	cmp	r7, #0
 1001ed6:	f000 82b5 	beq.w	1002444 <ull_conn_llcp+0x1864>
 1001eda:	6838      	ldr	r0, [r7, #0]
 1001edc:	2800      	cmp	r0, #0
 1001ede:	f000 82b1 	beq.w	1002444 <ull_conn_llcp+0x1864>
		pdu_ctrl_rx->len =
 1001ee2:	f04f 0e09 	mov.w	lr, #9
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 1001ee6:	f04f 0a02 	mov.w	sl, #2
		pdu_ctrl_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 1001eea:	2115      	movs	r1, #21
		pdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;
 1001eec:	f897 3020 	ldrb.w	r3, [r7, #32]
		conn->llcp_rx = rx->hdr.link->mem;
 1001ef0:	6842      	ldr	r2, [r0, #4]
		pdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;
 1001ef2:	f043 0303 	orr.w	r3, r3, #3
		rx->hdr.handle = conn->lll.handle;
 1001ef6:	f8b4 c02c 	ldrh.w	ip, [r4, #44]	; 0x2c
		conn->llcp_rx = rx->hdr.link->mem;
 1001efa:	f8c4 2100 	str.w	r2, [r4, #256]	; 0x100
		pdu_ctrl_rx->len =
 1001efe:	f887 e021 	strb.w	lr, [r7, #33]	; 0x21
		pdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;
 1001f02:	f887 3020 	strb.w	r3, [r7, #32]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 1001f06:	f887 a004 	strb.w	sl, [r7, #4]
		lr->max_rx_octets = sys_cpu_to_le16(lll->max_rx_octets);
 1001f0a:	f8b4 205e 	ldrh.w	r2, [r4, #94]	; 0x5e
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
 1001f0e:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
		rx->hdr.handle = conn->lll.handle;
 1001f12:	f8a7 c006 	strh.w	ip, [r7, #6]
		lr->max_rx_octets = sys_cpu_to_le16(lll->max_rx_octets);
 1001f16:	84ba      	strh	r2, [r7, #36]	; 0x24
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
 1001f18:	84fb      	strh	r3, [r7, #38]	; 0x26
		pdu_ctrl_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 1001f1a:	f887 1023 	strb.w	r1, [r7, #35]	; 0x23
		lr->max_tx_octets = sys_cpu_to_le16(tx_octets);
 1001f1e:	f8a7 9028 	strh.w	r9, [r7, #40]	; 0x28
		ll_rx_put(rx->hdr.link, rx);
 1001f22:	4639      	mov	r1, r7
		lr->max_tx_time = sys_cpu_to_le16(tx_time);
 1001f24:	f8a7 802a 	strh.w	r8, [r7, #42]	; 0x2a
		ll_rx_put(rx->hdr.link, rx);
 1001f28:	f008 f928 	bl	100a17c <ll_rx_put>
		ll_rx_sched();
 1001f2c:	f008 f930 	bl	100a190 <ll_rx_sched>
	break;
 1001f30:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 1001f34:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
 1001f38:	f7fe be64 	b.w	1000c04 <ull_conn_llcp+0x24>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1001f3c:	48b8      	ldr	r0, [pc, #736]	; (1002220 <ull_conn_llcp+0x1640>)
 1001f3e:	f003 feeb 	bl	1005d18 <mem_acquire>
		if (!tx) {
 1001f42:	2800      	cmp	r0, #0
 1001f44:	f43f aa2d 	beq.w	10013a2 <ull_conn_llcp+0x7c2>
		conn->llcp_length.state = LLCP_LENGTH_STATE_REQ_ACK_WAIT;
 1001f48:	f04f 0801 	mov.w	r8, #1
		pdu_ctrl_tx->len =
 1001f4c:	2209      	movs	r2, #9
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
 1001f4e:	f06f 0704 	mvn.w	r7, #4
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_REQ;
 1001f52:	f04f 0e14 	mov.w	lr, #20
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
 1001f56:	f04f 0c00 	mov.w	ip, #0
		conn->llcp_length.state = LLCP_LENGTH_STATE_REQ_ACK_WAIT;
 1001f5a:	f894 319a 	ldrb.w	r3, [r4, #410]	; 0x19a
		conn->default_tx_octets = conn->llcp_length.tx_octets;
 1001f5e:	f8b4 119e 	ldrh.w	r1, [r4, #414]	; 0x19e
		conn->llcp_length.state = LLCP_LENGTH_STATE_REQ_ACK_WAIT;
 1001f62:	f368 0302 	bfi	r3, r8, #0, #3
 1001f66:	f884 319a 	strb.w	r3, [r4, #410]	; 0x19a
		conn->default_tx_time = conn->llcp_length.tx_time;
 1001f6a:	f8b4 31a2 	ldrh.w	r3, [r4, #418]	; 0x1a2
		conn->default_tx_octets = conn->llcp_length.tx_octets;
 1001f6e:	f8a4 10d6 	strh.w	r1, [r4, #214]	; 0xd6
		conn->default_tx_time = conn->llcp_length.tx_time;
 1001f72:	f8a4 30d8 	strh.w	r3, [r4, #216]	; 0xd8
		pdu_ctrl_tx->len =
 1001f76:	7142      	strb	r2, [r0, #5]
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001f78:	7902      	ldrb	r2, [r0, #4]
		lr->max_tx_octets = sys_cpu_to_le16(conn->default_tx_octets);
 1001f7a:	8181      	strh	r1, [r0, #12]
	if (!conn->common.fex_valid ||
 1001f7c:	f894 10dc 	ldrb.w	r1, [r4, #220]	; 0xdc
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001f80:	f042 0203 	orr.w	r2, r2, #3
 1001f84:	7102      	strb	r2, [r0, #4]
	feature_coded_phy = (conn->llcp_feature.features &
 1001f86:	f8d4 211c 	ldr.w	r2, [r4, #284]	; 0x11c
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
 1001f8a:	7207      	strb	r7, [r0, #8]
	if (!conn->common.fex_valid ||
 1001f8c:	07cf      	lsls	r7, r1, #31
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_REQ;
 1001f8e:	f880 e007 	strb.w	lr, [r0, #7]
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
 1001f92:	f880 c009 	strb.w	ip, [r0, #9]
	if (!conn->common.fex_valid ||
 1001f96:	f140 8242 	bpl.w	100241e <ull_conn_llcp+0x183e>
 1001f9a:	0511      	lsls	r1, r2, #20
 1001f9c:	f140 8323 	bpl.w	10025e6 <ull_conn_llcp+0x1a06>
		tx_time = MIN(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_CODED),
 1001fa0:	f244 2290 	movw	r2, #17040	; 0x4290
 1001fa4:	4293      	cmp	r3, r2
 1001fa6:	bf28      	it	cs
 1001fa8:	4613      	movcs	r3, r2
		tx_time = MAX(PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M), tx_time);
 1001faa:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
 1001fae:	bf38      	it	cc
 1001fb0:	f44f 73a4 	movcc.w	r3, #328	; 0x148
	    conn->tx_head &&
 1001fb4:	f8d4 11b0 	ldr.w	r1, [r4, #432]	; 0x1b0
		lr->max_rx_time = sys_cpu_to_le16(rx_time);
 1001fb8:	8142      	strh	r2, [r0, #10]
		lr->max_tx_time = sys_cpu_to_le16(tx_time);
 1001fba:	81c3      	strh	r3, [r0, #14]
	if (
 1001fbc:	2900      	cmp	r1, #0
 1001fbe:	f000 8223 	beq.w	1002408 <ull_conn_llcp+0x1828>
	    !conn->llcp_enc.pause_tx &&
 1001fc2:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
	    conn->tx_head &&
 1001fc6:	079b      	lsls	r3, r3, #30
 1001fc8:	f100 821e 	bmi.w	1002408 <ull_conn_llcp+0x1828>
	    !conn->llcp_phy.pause_tx &&
 1001fcc:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
 1001fd0:	07df      	lsls	r7, r3, #31
 1001fd2:	f100 8219 	bmi.w	1002408 <ull_conn_llcp+0x1828>
		if (conn->tx_head == conn->tx_data) {
 1001fd6:	f8d4 31bc 	ldr.w	r3, [r4, #444]	; 0x1bc
 1001fda:	4299      	cmp	r1, r3
			conn->tx_data = conn->tx_data->next;
 1001fdc:	bf04      	itt	eq
 1001fde:	680b      	ldreq	r3, [r1, #0]
 1001fe0:	f8c4 31bc 	streq.w	r3, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 1001fe4:	f8d4 31b4 	ldr.w	r3, [r4, #436]	; 0x1b4
 1001fe8:	2b00      	cmp	r3, #0
 1001fea:	f000 834b 	beq.w	1002684 <ull_conn_llcp+0x1aa4>
	tx->next = conn->tx_ctrl_last->next;
 1001fee:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 1001ff2:	681a      	ldr	r2, [r3, #0]
 1001ff4:	6002      	str	r2, [r0, #0]
	conn->tx_ctrl_last->next = tx;
 1001ff6:	6018      	str	r0, [r3, #0]
	conn->tx_ctrl_last = tx;
 1001ff8:	f8c4 01b8 	str.w	r0, [r4, #440]	; 0x1b8
	if (!tx->next) {
 1001ffc:	6803      	ldr	r3, [r0, #0]
 1001ffe:	2b00      	cmp	r3, #0
 1002000:	f47f aee8 	bne.w	1001dd4 <ull_conn_llcp+0x11f4>
		conn->tx_data_last = tx;
 1002004:	f8c4 01c0 	str.w	r0, [r4, #448]	; 0x1c0
		conn->procedure_expire = conn->procedure_reload;
 1002008:	e6e4      	b.n	1001dd4 <ull_conn_llcp+0x11f4>
		conn->tx_data_last = tx;
 100200a:	f8c4 61c0 	str.w	r6, [r4, #448]	; 0x1c0
 100200e:	f7ff b911 	b.w	1001234 <ull_conn_llcp+0x654>
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_IND;
 1002012:	230d      	movs	r3, #13
		p->error_code =	conn->llcp.encryption.error_code;
 1002014:	2702      	movs	r7, #2
 1002016:	7235      	strb	r5, [r6, #8]
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_IND;
 1002018:	71f3      	strb	r3, [r6, #7]
		pdu->len = sizeof(struct pdu_data_llctrl_reject_ind);
 100201a:	f7ff b8e1 	b.w	10011e0 <ull_conn_llcp+0x600>
		LL_ASSERT(rx && rx->hdr.link);
 100201e:	4881      	ldr	r0, [pc, #516]	; (1002224 <ull_conn_llcp+0x1644>)
 1002020:	f640 6138 	movw	r1, #3640	; 0xe38
 1002024:	f001 fb2c 	bl	1003680 <bt_ctlr_assert_handle>
 1002028:	6830      	ldr	r0, [r6, #0]
 100202a:	f894 b0ec 	ldrb.w	fp, [r4, #236]	; 0xec
 100202e:	f7ff b82d 	b.w	100108c <ull_conn_llcp+0x4ac>
		LL_ASSERT(rx && rx->hdr.link);
 1002032:	487c      	ldr	r0, [pc, #496]	; (1002224 <ull_conn_llcp+0x1644>)
 1002034:	f640 6164 	movw	r1, #3684	; 0xe64
 1002038:	f001 fb22 	bl	1003680 <bt_ctlr_assert_handle>
 100203c:	6830      	ldr	r0, [r6, #0]
 100203e:	f7ff b852 	b.w	10010e6 <ull_conn_llcp+0x506>
		if (!conn->tx_ctrl) {
 1002042:	f8d4 31b4 	ldr.w	r3, [r4, #436]	; 0x1b4
 1002046:	2b00      	cmp	r3, #0
 1002048:	f47f ac07 	bne.w	100185a <ull_conn_llcp+0xc7a>
			tx->next = conn->tx_head;
 100204c:	6002      	str	r2, [r0, #0]
				conn->tx_ctrl = tx;
 100204e:	e9c4 006c 	strd	r0, r0, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 1002052:	f8c4 01b8 	str.w	r0, [r4, #440]	; 0x1b8
 1002056:	e408      	b.n	100186a <ull_conn_llcp+0xc8a>
		switch (conn->llcp_cu.state) {
 1002058:	4973      	ldr	r1, [pc, #460]	; (1002228 <ull_conn_llcp+0x1648>)
 100205a:	f7ff ba20 	b.w	100149e <ull_conn_llcp+0x8be>
		if (!conn->tx_ctrl) {
 100205e:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 1002062:	2a00      	cmp	r2, #0
 1002064:	f47f aea8 	bne.w	1001db8 <ull_conn_llcp+0x11d8>
			tx->next = conn->tx_head;
 1002068:	f8c8 3000 	str.w	r3, [r8]
				conn->tx_ctrl = tx;
 100206c:	e9c4 886c 	strd	r8, r8, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 1002070:	f8c4 81b8 	str.w	r8, [r4, #440]	; 0x1b8
 1002074:	e6ab      	b.n	1001dce <ull_conn_llcp+0x11ee>
 1002076:	f894 2065 	ldrb.w	r2, [r4, #101]	; 0x65
 100207a:	f003 0307 	and.w	r3, r3, #7
 100207e:	f002 0207 	and.w	r2, r2, #7
 1002082:	f7ff b815 	b.w	10010b0 <ull_conn_llcp+0x4d0>
		tx_time = MAX(MIN(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_1M),
 1002086:	f640 0148 	movw	r1, #2120	; 0x848
 100208a:	428b      	cmp	r3, r1
 100208c:	bf28      	it	cs
 100208e:	460b      	movcs	r3, r1
 1002090:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
 1002094:	bf38      	it	cc
 1002096:	f44f 73a4 	movcc.w	r3, #328	; 0x148
 100209a:	f7ff bbc1 	b.w	1001820 <ull_conn_llcp+0xc40>
		LL_ASSERT(rx && rx->hdr.link);
 100209e:	f640 5108 	movw	r1, #3336	; 0xd08
 10020a2:	4860      	ldr	r0, [pc, #384]	; (1002224 <ull_conn_llcp+0x1644>)
 10020a4:	f001 faec 	bl	1003680 <bt_ctlr_assert_handle>
 10020a8:	6838      	ldr	r0, [r7, #0]
 10020aa:	f8b4 105e 	ldrh.w	r1, [r4, #94]	; 0x5e
 10020ae:	f8b4 2062 	ldrh.w	r2, [r4, #98]	; 0x62
 10020b2:	f7ff bb49 	b.w	1001748 <ull_conn_llcp+0xb68>
			fp_mfy_select_or_use = ull_sched_mfy_win_offset_use;
 10020b6:	495d      	ldr	r1, [pc, #372]	; (100222c <ull_conn_llcp+0x164c>)
 10020b8:	f7ff b9f1 	b.w	100149e <ull_conn_llcp+0x8be>
		LL_ASSERT(!retval);
 10020bc:	f640 0149 	movw	r1, #2121	; 0x849
 10020c0:	4858      	ldr	r0, [pc, #352]	; (1002224 <ull_conn_llcp+0x1644>)
 10020c2:	f001 fadd 	bl	1003680 <bt_ctlr_assert_handle>
 10020c6:	f7ff ba3b 	b.w	1001540 <ull_conn_llcp+0x960>
	    (!feature_coded_phy && !feature_phy_2m)) {
 10020ca:	05d5      	lsls	r5, r2, #23
 10020cc:	f57f ad91 	bpl.w	1001bf2 <ull_conn_llcp+0x1012>
		tx_time = MAX(PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M),
 10020d0:	f44f 6385 	mov.w	r3, #1064	; 0x428
 10020d4:	f8b4 50d8 	ldrh.w	r5, [r4, #216]	; 0xd8
 10020d8:	930b      	str	r3, [sp, #44]	; 0x2c
 10020da:	429d      	cmp	r5, r3
 10020dc:	bf28      	it	cs
 10020de:	461d      	movcs	r5, r3
 10020e0:	f5b5 7fa4 	cmp.w	r5, #328	; 0x148
 10020e4:	bf38      	it	cc
 10020e6:	f44f 75a4 	movcc.w	r5, #328	; 0x148
 10020ea:	f7fe bfa6 	b.w	100103a <ull_conn_llcp+0x45a>
			if (!conn->llcp_length.cache.tx_octets) {
 10020ee:	f8b4 01a4 	ldrh.w	r0, [r4, #420]	; 0x1a4
 10020f2:	2800      	cmp	r0, #0
 10020f4:	f040 8138 	bne.w	1002368 <ull_conn_llcp+0x1788>
				conn->llcp_length.ack = conn->llcp_length.req;
 10020f8:	f884 3199 	strb.w	r3, [r4, #409]	; 0x199
				conn->procedure_expire = 0U;
 10020fc:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
 1002100:	f7ff bb19 	b.w	1001736 <ull_conn_llcp+0xb56>
		} else if (conn->llcp_phy.ack != conn->llcp_phy.req) {
 1002104:	f894 31a8 	ldrb.w	r3, [r4, #424]	; 0x1a8
 1002108:	f894 11a9 	ldrb.w	r1, [r4, #425]	; 0x1a9
 100210c:	4299      	cmp	r1, r3
 100210e:	f43e ad7e 	beq.w	1000c0e <ull_conn_llcp+0x2e>
	switch (conn->llcp_phy.state) {
 1002112:	f894 11aa 	ldrb.w	r1, [r4, #426]	; 0x1aa
 1002116:	f001 0003 	and.w	r0, r1, #3
 100211a:	2803      	cmp	r0, #3
 100211c:	f000 8220 	beq.w	1002560 <ull_conn_llcp+0x1980>
 1002120:	2800      	cmp	r0, #0
 1002122:	f47e ad74 	bne.w	1000c0e <ull_conn_llcp+0x2e>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1002126:	483e      	ldr	r0, [pc, #248]	; (1002220 <ull_conn_llcp+0x1640>)
 1002128:	f003 fdf6 	bl	1005d18 <mem_acquire>
		if (!tx) {
 100212c:	4601      	mov	r1, r0
 100212e:	2800      	cmp	r0, #0
 1002130:	f43f a937 	beq.w	10013a2 <ull_conn_llcp+0x7c2>
		conn->llcp_phy.state = LLCP_PHY_STATE_ACK_WAIT;
 1002134:	2001      	movs	r0, #1
		pdu_ctrl_tx->len =
 1002136:	f04f 0c03 	mov.w	ip, #3
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_REQ;
 100213a:	2716      	movs	r7, #22
		conn->llcp_phy.state = LLCP_PHY_STATE_ACK_WAIT;
 100213c:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
		conn->phy_pref_tx = conn->llcp_phy.tx;
 1002140:	f894 21ac 	ldrb.w	r2, [r4, #428]	; 0x1ac
		conn->llcp_phy.state = LLCP_PHY_STATE_ACK_WAIT;
 1002144:	f360 0301 	bfi	r3, r0, #0, #2
		conn->phy_pref_tx = conn->llcp_phy.tx;
 1002148:	f3c3 0082 	ubfx	r0, r3, #2, #3
 100214c:	f360 0202 	bfi	r2, r0, #0, #3
		conn->phy_pref_rx = conn->llcp_phy.rx;
 1002150:	f3c3 1042 	ubfx	r0, r3, #5, #3
 1002154:	f360 1206 	bfi	r2, r0, #4, #3
		conn->phy_pref_flags = conn->llcp_phy.flags;
 1002158:	f894 01ab 	ldrb.w	r0, [r4, #427]	; 0x1ab
		conn->llcp_phy.state = LLCP_PHY_STATE_ACK_WAIT;
 100215c:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
		conn->phy_pref_flags = conn->llcp_phy.flags;
 1002160:	f3c0 0040 	ubfx	r0, r0, #1, #1
 1002164:	f360 02c3 	bfi	r2, r0, #3, #1
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1002168:	7908      	ldrb	r0, [r1, #4]
		conn->phy_pref_tx = conn->llcp_phy.tx;
 100216a:	f3c3 0e82 	ubfx	lr, r3, #2, #3
		conn->phy_pref_flags = conn->llcp_phy.flags;
 100216e:	f884 21ac 	strb.w	r2, [r4, #428]	; 0x1ac
		conn->phy_pref_rx = conn->llcp_phy.rx;
 1002172:	f3c3 1342 	ubfx	r3, r3, #5, #3
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1002176:	ea40 020c 	orr.w	r2, r0, ip
 100217a:	710a      	strb	r2, [r1, #4]
	ctrl_tx_pause_enqueue(conn, tx, false);
 100217c:	4620      	mov	r0, r4
 100217e:	2200      	movs	r2, #0
		pr->tx_phys = conn->llcp_phy.tx;
 1002180:	f881 e008 	strb.w	lr, [r1, #8]
		pr->rx_phys = conn->llcp_phy.rx;
 1002184:	724b      	strb	r3, [r1, #9]
		pdu_ctrl_tx->len =
 1002186:	f881 c005 	strb.w	ip, [r1, #5]
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_REQ;
 100218a:	71cf      	strb	r7, [r1, #7]
	ctrl_tx_pause_enqueue(conn, tx, false);
 100218c:	f008 ffb0 	bl	100b0f0 <ctrl_tx_pause_enqueue>
 1002190:	e620      	b.n	1001dd4 <ull_conn_llcp+0x11f4>
		if (!conn->llcp.phy_upd_ind.cmd && (lll->phy_tx == old_tx) &&
 1002192:	4592      	cmp	sl, r2
 1002194:	f47e af8c 	bne.w	10010b0 <ull_conn_llcp+0x4d0>
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 1002198:	2303      	movs	r3, #3
			ll_rx_put(rx->hdr.link, rx);
 100219a:	4631      	mov	r1, r6
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100219c:	7133      	strb	r3, [r6, #4]
			ll_rx_put(rx->hdr.link, rx);
 100219e:	f007 ffed 	bl	100a17c <ll_rx_put>
				rx = conn->llcp_rx;
 10021a2:	f8d4 5100 	ldr.w	r5, [r4, #256]	; 0x100
				LL_ASSERT(rx && rx->hdr.link);
 10021a6:	2d00      	cmp	r5, #0
 10021a8:	f000 822d 	beq.w	1002606 <ull_conn_llcp+0x1a26>
 10021ac:	6828      	ldr	r0, [r5, #0]
 10021ae:	2800      	cmp	r0, #0
 10021b0:	f000 8229 	beq.w	1002606 <ull_conn_llcp+0x1a26>
				rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 10021b4:	2303      	movs	r3, #3
				conn->llcp_rx = rx->hdr.link->mem;
 10021b6:	6842      	ldr	r2, [r0, #4]
				ll_rx_put(rx->hdr.link, rx);
 10021b8:	4629      	mov	r1, r5
				conn->llcp_rx = rx->hdr.link->mem;
 10021ba:	f8c4 2100 	str.w	r2, [r4, #256]	; 0x100
				rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 10021be:	712b      	strb	r3, [r5, #4]
				ll_rx_put(rx->hdr.link, rx);
 10021c0:	f007 ffdc 	bl	100a17c <ll_rx_put>
			ll_rx_sched();
 10021c4:	f007 ffe4 	bl	100a190 <ll_rx_sched>
			return;
 10021c8:	f7fe bd21 	b.w	1000c0e <ull_conn_llcp+0x2e>
			conn->llcp.phy_upd_ind.instant = event_counter +
 10021cc:	8e23      	ldrh	r3, [r4, #48]	; 0x30
 10021ce:	441d      	add	r5, r3
							 lll->latency +
 10021d0:	1dab      	adds	r3, r5, #6
			conn->llcp.phy_upd_ind.instant = event_counter +
 10021d2:	f8a4 30ee 	strh.w	r3, [r4, #238]	; 0xee
			(void)ll_pdu_rx_alloc();
 10021d6:	f007 ffff 	bl	100a1d8 <ll_pdu_rx_alloc>
			rx->hdr.link->mem = conn->llcp_rx;
 10021da:	683b      	ldr	r3, [r7, #0]
 10021dc:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
 10021e0:	605a      	str	r2, [r3, #4]
			conn->llcp_rx = rx;
 10021e2:	f8c4 7100 	str.w	r7, [r4, #256]	; 0x100
			rx = ll_pdu_rx_alloc();
 10021e6:	f007 fff7 	bl	100a1d8 <ll_pdu_rx_alloc>
			rx->hdr.link->mem = conn->llcp_rx;
 10021ea:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
 10021ee:	6803      	ldr	r3, [r0, #0]
 10021f0:	605a      	str	r2, [r3, #4]
			conn->llcp_rx = rx;
 10021f2:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
 10021f6:	f8c4 0100 	str.w	r0, [r4, #256]	; 0x100
 10021fa:	f3c3 0682 	ubfx	r6, r3, #2, #3
 10021fe:	f8b4 00ee 	ldrh.w	r0, [r4, #238]	; 0xee
 1002202:	095b      	lsrs	r3, r3, #5
 1002204:	f7ff ba3c 	b.w	1001680 <ull_conn_llcp+0xaa0>
		LL_ASSERT(0);
 1002208:	f640 3127 	movw	r1, #2855	; 0xb27
 100220c:	4805      	ldr	r0, [pc, #20]	; (1002224 <ull_conn_llcp+0x1644>)
 100220e:	f001 fa37 	bl	1003680 <bt_ctlr_assert_handle>
 1002212:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 1002216:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
 100221a:	f7fe bcf3 	b.w	1000c04 <ull_conn_llcp+0x24>
 100221e:	bf00      	nop
 1002220:	21005288 	.word	0x21005288
 1002224:	01018934 	.word	0x01018934
 1002228:	0100eb85 	.word	0x0100eb85
 100222c:	0100eb81 	.word	0x0100eb81
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1002230:	48c9      	ldr	r0, [pc, #804]	; (1002558 <ull_conn_llcp+0x1978>)
 1002232:	f003 fd71 	bl	1005d18 <mem_acquire>
		if (tx) {
 1002236:	2800      	cmp	r0, #0
 1002238:	f43f a8b3 	beq.w	10013a2 <ull_conn_llcp+0x7c2>
			pdu->llctrl.version_ind.sub_version_number = svn;
 100223c:	f04f 31ff 	mov.w	r1, #4294967295
			pdu->len =
 1002240:	f04f 0906 	mov.w	r9, #6
			pdu->llctrl.opcode =
 1002244:	f04f 080c 	mov.w	r8, #12
			pdu->llctrl.version_ind.version_number =
 1002248:	f04f 0e0b 	mov.w	lr, #11
			pdu->llctrl.version_ind.company_id = cid;
 100224c:	f06f 0c0e 	mvn.w	ip, #14
 1002250:	2705      	movs	r7, #5
			conn->llcp_version.ack--;
 1002252:	f894 3121 	ldrb.w	r3, [r4, #289]	; 0x121
			conn->llcp_version.tx = 1U;
 1002256:	f894 2122 	ldrb.w	r2, [r4, #290]	; 0x122
			conn->llcp_version.ack--;
 100225a:	440b      	add	r3, r1
 100225c:	f884 3121 	strb.w	r3, [r4, #289]	; 0x121
			pdu->ll_id = PDU_DATA_LLID_CTRL;
 1002260:	7903      	ldrb	r3, [r0, #4]
			conn->llcp_version.tx = 1U;
 1002262:	f042 0201 	orr.w	r2, r2, #1
 1002266:	f884 2122 	strb.w	r2, [r4, #290]	; 0x122
			pdu->ll_id = PDU_DATA_LLID_CTRL;
 100226a:	f043 0303 	orr.w	r3, r3, #3
			pdu->len =
 100226e:	f880 9005 	strb.w	r9, [r0, #5]
			pdu->ll_id = PDU_DATA_LLID_CTRL;
 1002272:	7103      	strb	r3, [r0, #4]
	    conn->tx_head &&
 1002274:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
			pdu->llctrl.opcode =
 1002278:	f880 8007 	strb.w	r8, [r0, #7]
			pdu->llctrl.version_ind.version_number =
 100227c:	f880 e008 	strb.w	lr, [r0, #8]
			pdu->llctrl.version_ind.company_id = cid;
 1002280:	f880 c009 	strb.w	ip, [r0, #9]
 1002284:	7287      	strb	r7, [r0, #10]
			pdu->llctrl.version_ind.sub_version_number = svn;
 1002286:	72c1      	strb	r1, [r0, #11]
 1002288:	7301      	strb	r1, [r0, #12]
	if (
 100228a:	2b00      	cmp	r3, #0
 100228c:	f000 8085 	beq.w	100239a <ull_conn_llcp+0x17ba>
	    !conn->llcp_enc.pause_tx &&
 1002290:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
	    conn->tx_head &&
 1002294:	0797      	lsls	r7, r2, #30
 1002296:	f100 8080 	bmi.w	100239a <ull_conn_llcp+0x17ba>
	    !conn->llcp_phy.pause_tx &&
 100229a:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
 100229e:	07d1      	lsls	r1, r2, #31
 10022a0:	d47b      	bmi.n	100239a <ull_conn_llcp+0x17ba>
		if (conn->tx_head == conn->tx_data) {
 10022a2:	f8d4 21bc 	ldr.w	r2, [r4, #444]	; 0x1bc
 10022a6:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 10022a8:	bf04      	itt	eq
 10022aa:	681a      	ldreq	r2, [r3, #0]
 10022ac:	f8c4 21bc 	streq.w	r2, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 10022b0:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 10022b4:	2a00      	cmp	r2, #0
 10022b6:	f47f ae9a 	bne.w	1001fee <ull_conn_llcp+0x140e>
			tx->next = conn->tx_head->next;
 10022ba:	681a      	ldr	r2, [r3, #0]
 10022bc:	6002      	str	r2, [r0, #0]
			conn->tx_head->next = tx;
 10022be:	6018      	str	r0, [r3, #0]
				conn->tx_ctrl_last = tx;
 10022c0:	e9c4 006d 	strd	r0, r0, [r4, #436]	; 0x1b4
 10022c4:	e69a      	b.n	1001ffc <ull_conn_llcp+0x141c>
		conn->tx_data_last = tx;
 10022c6:	f8c4 01c0 	str.w	r0, [r4, #448]	; 0x1c0
 10022ca:	f7ff bad1 	b.w	1001870 <ull_conn_llcp+0xc90>
				(void)ll_pdu_rx_alloc();
 10022ce:	f007 ff83 	bl	100a1d8 <ll_pdu_rx_alloc>
				rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
 10022d2:	230e      	movs	r3, #14
				rx->hdr.handle = lll->handle;
 10022d4:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
				upd->status = 0U;
 10022d6:	f887 6020 	strb.w	r6, [r7, #32]
				rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
 10022da:	713b      	strb	r3, [r7, #4]
				upd->tx = lll->phy_tx;
 10022dc:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
				ll_rx_put(rx->hdr.link, rx);
 10022e0:	6838      	ldr	r0, [r7, #0]
				upd->tx = lll->phy_tx;
 10022e2:	f3c3 0302 	ubfx	r3, r3, #0, #3
 10022e6:	f887 3021 	strb.w	r3, [r7, #33]	; 0x21
				upd->rx = lll->phy_rx;
 10022ea:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
				ll_rx_put(rx->hdr.link, rx);
 10022ee:	4639      	mov	r1, r7
				upd->rx = lll->phy_rx;
 10022f0:	f3c3 0302 	ubfx	r3, r3, #0, #3
 10022f4:	f887 3022 	strb.w	r3, [r7, #34]	; 0x22
				rx->hdr.handle = lll->handle;
 10022f8:	80fa      	strh	r2, [r7, #6]
				ll_rx_put(rx->hdr.link, rx);
 10022fa:	f007 ff3f 	bl	100a17c <ll_rx_put>
				ll_rx_sched();
 10022fe:	f007 ff47 	bl	100a190 <ll_rx_sched>
 1002302:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
 1002306:	f8b4 00ee 	ldrh.w	r0, [r4, #238]	; 0xee
 100230a:	f3c3 0682 	ubfx	r6, r3, #2, #3
 100230e:	095b      	lsrs	r3, r3, #5
 1002310:	f7ff b9b6 	b.w	1001680 <ull_conn_llcp+0xaa0>
	switch (conn->llcp_conn_param.state) {
 1002314:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
 1002318:	f003 0307 	and.w	r3, r3, #7
 100231c:	2b05      	cmp	r3, #5
 100231e:	f200 81cc 	bhi.w	10026ba <ull_conn_llcp+0x1ada>
 1002322:	a201      	add	r2, pc, #4	; (adr r2, 1002328 <ull_conn_llcp+0x1748>)
 1002324:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 1002328:	01001ab9 	.word	0x01001ab9
 100232c:	01001a1d 	.word	0x01001a1d
 1002330:	010019bd 	.word	0x010019bd
 1002334:	01000c0f 	.word	0x01000c0f
 1002338:	01000c0f 	.word	0x01000c0f
 100233c:	01000c0f 	.word	0x01000c0f
		conn->tx_data_last = tx;
 1002340:	f8c4 81c0 	str.w	r8, [r4, #448]	; 0x1c0
		conn->procedure_expire = conn->procedure_reload;
 1002344:	e546      	b.n	1001dd4 <ull_conn_llcp+0x11f4>
	    (!feature_coded_phy && !feature_phy_2m)) {
 1002346:	05d2      	lsls	r2, r2, #23
 1002348:	f57f ae9d 	bpl.w	1002086 <ull_conn_llcp+0x14a6>
		tx_time = MAX(PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M),
 100234c:	f5b3 6f85 	cmp.w	r3, #1064	; 0x428
 1002350:	bf28      	it	cs
 1002352:	f44f 6385 	movcs.w	r3, #1064	; 0x428
 1002356:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
 100235a:	f44f 6185 	mov.w	r1, #1064	; 0x428
 100235e:	bf38      	it	cc
 1002360:	f44f 73a4 	movcc.w	r3, #328	; 0x148
 1002364:	f7ff ba5c 	b.w	1001820 <ull_conn_llcp+0xc40>
				conn->llcp_length.cache.tx_octets = 0;
 1002368:	2700      	movs	r7, #0
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
 100236a:	f894 319a 	ldrb.w	r3, [r4, #410]	; 0x19a
				conn->llcp_length.tx_octets =
 100236e:	f8a4 019e 	strh.w	r0, [r4, #414]	; 0x19e
				conn->llcp_length.tx_time =
 1002372:	f8b4 01a6 	ldrh.w	r0, [r4, #422]	; 0x1a6
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
 1002376:	f367 0302 	bfi	r3, r7, #0, #3
				conn->llcp_length.cache.tx_octets = 0;
 100237a:	f8a4 71a4 	strh.w	r7, [r4, #420]	; 0x1a4
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
 100237e:	f884 319a 	strb.w	r3, [r4, #410]	; 0x19a
				conn->llcp_length.tx_time =
 1002382:	f8a4 01a2 	strh.w	r0, [r4, #418]	; 0x1a2
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
 1002386:	f7ff b9d6 	b.w	1001736 <ull_conn_llcp+0xb56>
			tx->next = conn->tx_head->next;
 100238a:	681a      	ldr	r2, [r3, #0]
 100238c:	6002      	str	r2, [r0, #0]
			conn->tx_head->next = tx;
 100238e:	6018      	str	r0, [r3, #0]
				conn->tx_ctrl = tx;
 1002390:	6803      	ldr	r3, [r0, #0]
				conn->tx_ctrl_last = tx;
 1002392:	e9c4 006d 	strd	r0, r0, [r4, #436]	; 0x1b4
 1002396:	f7fe bfb1 	b.w	10012fc <ull_conn_llcp+0x71c>
		if (!conn->tx_ctrl) {
 100239a:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 100239e:	2a00      	cmp	r2, #0
 10023a0:	f47f ae25 	bne.w	1001fee <ull_conn_llcp+0x140e>
			tx->next = conn->tx_head;
 10023a4:	6003      	str	r3, [r0, #0]
				conn->tx_ctrl = tx;
 10023a6:	e9c4 006c 	strd	r0, r0, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 10023aa:	f8c4 01b8 	str.w	r0, [r4, #440]	; 0x1b8
 10023ae:	e625      	b.n	1001ffc <ull_conn_llcp+0x141c>
			tx->next = conn->tx_head->next;
 10023b0:	681a      	ldr	r2, [r3, #0]
 10023b2:	6032      	str	r2, [r6, #0]
			conn->tx_head->next = tx;
 10023b4:	601e      	str	r6, [r3, #0]
				conn->tx_ctrl = tx;
 10023b6:	6833      	ldr	r3, [r6, #0]
				conn->tx_ctrl_last = tx;
 10023b8:	e9c4 666d 	strd	r6, r6, [r4, #436]	; 0x1b4
 10023bc:	f7fe bf37 	b.w	100122e <ull_conn_llcp+0x64e>
			tx->next = conn->tx_head->next;
 10023c0:	681a      	ldr	r2, [r3, #0]
 10023c2:	602a      	str	r2, [r5, #0]
			conn->tx_head->next = tx;
 10023c4:	601d      	str	r5, [r3, #0]
				conn->tx_ctrl = tx;
 10023c6:	682b      	ldr	r3, [r5, #0]
				conn->tx_ctrl_last = tx;
 10023c8:	e9c4 556d 	strd	r5, r5, [r4, #436]	; 0x1b4
 10023cc:	f7ff b8db 	b.w	1001586 <ull_conn_llcp+0x9a6>
			tx->next = conn->tx_head->next;
 10023d0:	681a      	ldr	r2, [r3, #0]
 10023d2:	f8c8 2000 	str.w	r2, [r8]
			conn->tx_head->next = tx;
 10023d6:	f8c3 8000 	str.w	r8, [r3]
				conn->tx_ctrl = tx;
 10023da:	f8d8 3000 	ldr.w	r3, [r8]
				conn->tx_ctrl_last = tx;
 10023de:	e9c4 886d 	strd	r8, r8, [r4, #436]	; 0x1b4
 10023e2:	f7ff b985 	b.w	10016f0 <ull_conn_llcp+0xb10>
			tx->next = conn->tx_head->next;
 10023e6:	681a      	ldr	r2, [r3, #0]
 10023e8:	6032      	str	r2, [r6, #0]
			conn->tx_head->next = tx;
 10023ea:	601e      	str	r6, [r3, #0]
				conn->tx_ctrl = tx;
 10023ec:	6833      	ldr	r3, [r6, #0]
				conn->tx_ctrl_last = tx;
 10023ee:	e9c4 666d 	strd	r6, r6, [r4, #436]	; 0x1b4
 10023f2:	f7ff b916 	b.w	1001622 <ull_conn_llcp+0xa42>
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 10023f6:	2303      	movs	r3, #3
			ll_rx_put(rx->hdr.link, rx);
 10023f8:	4631      	mov	r1, r6
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 10023fa:	7133      	strb	r3, [r6, #4]
			ll_rx_put(rx->hdr.link, rx);
 10023fc:	f007 febe 	bl	100a17c <ll_rx_put>
			ll_rx_sched();
 1002400:	f007 fec6 	bl	100a190 <ll_rx_sched>
			return;
 1002404:	f7fe bc03 	b.w	1000c0e <ull_conn_llcp+0x2e>
		if (!conn->tx_ctrl) {
 1002408:	f8d4 31b4 	ldr.w	r3, [r4, #436]	; 0x1b4
 100240c:	2b00      	cmp	r3, #0
 100240e:	f47f adee 	bne.w	1001fee <ull_conn_llcp+0x140e>
			tx->next = conn->tx_head;
 1002412:	6001      	str	r1, [r0, #0]
				conn->tx_ctrl = tx;
 1002414:	e9c4 006c 	strd	r0, r0, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 1002418:	f8c4 01b8 	str.w	r0, [r4, #440]	; 0x1b8
 100241c:	e5ee      	b.n	1001ffc <ull_conn_llcp+0x141c>
		tx_time = MAX(MIN(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_1M),
 100241e:	f640 0248 	movw	r2, #2120	; 0x848
 1002422:	4293      	cmp	r3, r2
 1002424:	bf28      	it	cs
 1002426:	4613      	movcs	r3, r2
 1002428:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
 100242c:	bf38      	it	cc
 100242e:	f44f 73a4 	movcc.w	r3, #328	; 0x148
 1002432:	e5bf      	b.n	1001fb4 <ull_conn_llcp+0x13d4>
			tx->next = conn->tx_head->next;
 1002434:	6813      	ldr	r3, [r2, #0]
 1002436:	6003      	str	r3, [r0, #0]
			conn->tx_head->next = tx;
 1002438:	6010      	str	r0, [r2, #0]
				conn->tx_ctrl = tx;
 100243a:	6802      	ldr	r2, [r0, #0]
				conn->tx_ctrl_last = tx;
 100243c:	e9c4 006d 	strd	r0, r0, [r4, #436]	; 0x1b4
 1002440:	f7ff ba13 	b.w	100186a <ull_conn_llcp+0xc8a>
		LL_ASSERT(rx && rx->hdr.link);
 1002444:	4845      	ldr	r0, [pc, #276]	; (100255c <ull_conn_llcp+0x197c>)
 1002446:	f640 5108 	movw	r1, #3336	; 0xd08
 100244a:	f001 f919 	bl	1003680 <bt_ctlr_assert_handle>
 100244e:	6838      	ldr	r0, [r7, #0]
 1002450:	e547      	b.n	1001ee2 <ull_conn_llcp+0x1302>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1002452:	4841      	ldr	r0, [pc, #260]	; (1002558 <ull_conn_llcp+0x1978>)
 1002454:	f003 fc60 	bl	1005d18 <mem_acquire>
		if (!tx) {
 1002458:	4601      	mov	r1, r0
 100245a:	2800      	cmp	r0, #0
 100245c:	f43e afa1 	beq.w	10013a2 <ull_conn_llcp+0x7c2>
		pdu->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
 1002460:	2003      	movs	r0, #3
		rej->reject_opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
 1002462:	220f      	movs	r2, #15
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
 1002464:	2711      	movs	r7, #17
		pdu->ll_id = PDU_DATA_LLID_CTRL;
 1002466:	790b      	ldrb	r3, [r1, #4]
		pdu->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
 1002468:	7148      	strb	r0, [r1, #5]
		pdu->ll_id = PDU_DATA_LLID_CTRL;
 100246a:	4303      	orrs	r3, r0
		rej->reject_opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
 100246c:	720a      	strb	r2, [r1, #8]
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
 100246e:	71cf      	strb	r7, [r1, #7]
		pdu->ll_id = PDU_DATA_LLID_CTRL;
 1002470:	710b      	strb	r3, [r1, #4]
		rej->error_code = conn->llcp_conn_param.status;
 1002472:	f894 3173 	ldrb.w	r3, [r4, #371]	; 0x173
	ctrl_tx_pause_enqueue(conn, tx, false);
 1002476:	2200      	movs	r2, #0
		rej->error_code = conn->llcp_conn_param.status;
 1002478:	724b      	strb	r3, [r1, #9]
	ctrl_tx_pause_enqueue(conn, tx, false);
 100247a:	4620      	mov	r0, r4
 100247c:	f008 fe38 	bl	100b0f0 <ctrl_tx_pause_enqueue>
		conn_upd_curr = NULL;
 1002480:	2200      	movs	r2, #0
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
 1002482:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
		conn_upd_curr = NULL;
 1002486:	f8c9 2000 	str.w	r2, [r9]
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
 100248a:	f884 3171 	strb.w	r3, [r4, #369]	; 0x171
		return;
 100248e:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
 1002492:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 1002496:	f7fe bbb5 	b.w	1000c04 <ull_conn_llcp+0x24>
			if (!conn->llcp_length.cache.tx_octets) {
 100249a:	f8b4 31a4 	ldrh.w	r3, [r4, #420]	; 0x1a4
 100249e:	2b00      	cmp	r3, #0
 10024a0:	f040 80b8 	bne.w	1002614 <ull_conn_llcp+0x1a34>
				conn->llcp_length.ack = conn->llcp_length.req;
 10024a4:	f884 7199 	strb.w	r7, [r4, #409]	; 0x199
				conn->procedure_expire = 0U;
 10024a8:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
 10024ac:	e510      	b.n	1001ed0 <ull_conn_llcp+0x12f0>
			tx->next = conn->tx_head->next;
 10024ae:	681a      	ldr	r2, [r3, #0]
 10024b0:	f8c8 2000 	str.w	r2, [r8]
			conn->tx_head->next = tx;
 10024b4:	f8c3 8000 	str.w	r8, [r3]
				conn->tx_ctrl = tx;
 10024b8:	f8d8 3000 	ldr.w	r3, [r8]
				conn->tx_ctrl_last = tx;
 10024bc:	e9c4 886d 	strd	r8, r8, [r4, #436]	; 0x1b4
 10024c0:	e485      	b.n	1001dce <ull_conn_llcp+0x11ee>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 10024c2:	4825      	ldr	r0, [pc, #148]	; (1002558 <ull_conn_llcp+0x1978>)
 10024c4:	f003 fc28 	bl	1005d18 <mem_acquire>
	if (!tx) {
 10024c8:	4601      	mov	r1, r0
 10024ca:	2800      	cmp	r0, #0
 10024cc:	f43e af69 	beq.w	10013a2 <ull_conn_llcp+0x7c2>
	pdu->len = offsetof(struct pdu_data_llctrl, conn_param_rsp) +
 10024d0:	2018      	movs	r0, #24
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_RSP;
 10024d2:	2210      	movs	r2, #16
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10024d4:	790b      	ldrb	r3, [r1, #4]
	pdu->len = offsetof(struct pdu_data_llctrl, conn_param_rsp) +
 10024d6:	7148      	strb	r0, [r1, #5]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 10024d8:	f043 0303 	orr.w	r3, r3, #3
 10024dc:	710b      	strb	r3, [r1, #4]
	rsp->interval_min =
 10024de:	f8b4 0174 	ldrh.w	r0, [r4, #372]	; 0x174
	rsp->interval_max =
 10024e2:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
	rsp->interval_min =
 10024e6:	8108      	strh	r0, [r1, #8]
	rsp->latency =
 10024e8:	f8b4 0178 	ldrh.w	r0, [r4, #376]	; 0x178
	rsp->interval_max =
 10024ec:	814b      	strh	r3, [r1, #10]
	rsp->timeout =
 10024ee:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
	rsp->latency =
 10024f2:	8188      	strh	r0, [r1, #12]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_RSP;
 10024f4:	71ca      	strb	r2, [r1, #7]
	rsp->timeout =
 10024f6:	81cb      	strh	r3, [r1, #14]
	rsp->preferred_periodicity =
 10024f8:	f894 317c 	ldrb.w	r3, [r4, #380]	; 0x17c
	ctrl_tx_pause_enqueue(conn, tx, false);
 10024fc:	4620      	mov	r0, r4
	rsp->preferred_periodicity =
 10024fe:	740b      	strb	r3, [r1, #16]
	rsp->reference_conn_event_count =
 1002500:	f8b4 317e 	ldrh.w	r3, [r4, #382]	; 0x17e
	rsp->offset0 = sys_cpu_to_le16(conn->llcp_conn_param.offset0);
 1002504:	f8b4 2180 	ldrh.w	r2, [r4, #384]	; 0x180
	rsp->reference_conn_event_count =
 1002508:	f8a1 3011 	strh.w	r3, [r1, #17]
	rsp->offset1 = sys_cpu_to_le16(conn->llcp_conn_param.offset1);
 100250c:	f8b4 3182 	ldrh.w	r3, [r4, #386]	; 0x182
	rsp->offset0 = sys_cpu_to_le16(conn->llcp_conn_param.offset0);
 1002510:	f8a1 2013 	strh.w	r2, [r1, #19]
	rsp->offset2 = sys_cpu_to_le16(conn->llcp_conn_param.offset2);
 1002514:	f8b4 2184 	ldrh.w	r2, [r4, #388]	; 0x184
	rsp->offset1 = sys_cpu_to_le16(conn->llcp_conn_param.offset1);
 1002518:	f8a1 3015 	strh.w	r3, [r1, #21]
	rsp->offset3 = sys_cpu_to_le16(conn->llcp_conn_param.offset3);
 100251c:	f8b4 3186 	ldrh.w	r3, [r4, #390]	; 0x186
	rsp->offset2 = sys_cpu_to_le16(conn->llcp_conn_param.offset2);
 1002520:	f8a1 2017 	strh.w	r2, [r1, #23]
	rsp->offset4 = sys_cpu_to_le16(conn->llcp_conn_param.offset4);
 1002524:	f8b4 2188 	ldrh.w	r2, [r4, #392]	; 0x188
	rsp->offset3 = sys_cpu_to_le16(conn->llcp_conn_param.offset3);
 1002528:	f8a1 3019 	strh.w	r3, [r1, #25]
	rsp->offset5 = sys_cpu_to_le16(conn->llcp_conn_param.offset5);
 100252c:	f8b4 318a 	ldrh.w	r3, [r4, #394]	; 0x18a
	rsp->offset4 = sys_cpu_to_le16(conn->llcp_conn_param.offset4);
 1002530:	f8a1 201b 	strh.w	r2, [r1, #27]
	rsp->offset5 = sys_cpu_to_le16(conn->llcp_conn_param.offset5);
 1002534:	f8a1 301d 	strh.w	r3, [r1, #29]
	ctrl_tx_pause_enqueue(conn, tx, false);
 1002538:	463a      	mov	r2, r7
 100253a:	f008 fdd9 	bl	100b0f0 <ctrl_tx_pause_enqueue>
	conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
 100253e:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
 1002542:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
 1002546:	f884 3171 	strb.w	r3, [r4, #369]	; 0x171
	conn_upd_curr = NULL;
 100254a:	f8c9 7000 	str.w	r7, [r9]
 100254e:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 1002552:	f7fe bb57 	b.w	1000c04 <ull_conn_llcp+0x24>
 1002556:	bf00      	nop
 1002558:	21005288 	.word	0x21005288
 100255c:	01018934 	.word	0x01018934
		if (conn->llcp_phy.tx & BIT(1)) {
 1002560:	0708      	lsls	r0, r1, #28
		conn->llcp_phy.ack = conn->llcp_phy.req;
 1002562:	f884 31a9 	strb.w	r3, [r4, #425]	; 0x1a9
		if (conn->llcp_phy.tx & BIT(1)) {
 1002566:	f3c1 0382 	ubfx	r3, r1, #2, #3
 100256a:	d56d      	bpl.n	1002648 <ull_conn_llcp+0x1a68>
			conn->llcp_phy.tx = BIT(1);
 100256c:	2102      	movs	r1, #2
 100256e:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
 1002572:	f361 0384 	bfi	r3, r1, #2, #3
 1002576:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
		if (conn->llcp_phy.rx & BIT(1)) {
 100257a:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
 100257e:	065f      	lsls	r7, r3, #25
 1002580:	ea4f 1153 	mov.w	r1, r3, lsr #5
 1002584:	d558      	bpl.n	1002638 <ull_conn_llcp+0x1a58>
			conn->llcp_phy.rx = BIT(1);
 1002586:	2102      	movs	r1, #2
 1002588:	f361 1347 	bfi	r3, r1, #5, #3
 100258c:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
		if (conn->llcp_phy.tx != conn->lll.phy_tx) {
 1002590:	f894 11aa 	ldrb.w	r1, [r4, #426]	; 0x1aa
 1002594:	f894 0064 	ldrb.w	r0, [r4, #100]	; 0x64
		if (conn->llcp_phy.rx != conn->lll.phy_rx) {
 1002598:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
		if (conn->llcp_phy.tx != conn->lll.phy_tx) {
 100259c:	f000 0007 	and.w	r0, r0, #7
		if (conn->llcp_phy.rx != conn->lll.phy_rx) {
 10025a0:	f003 0307 	and.w	r3, r3, #7
		if (conn->llcp_phy.tx != conn->lll.phy_tx) {
 10025a4:	f3c1 0782 	ubfx	r7, r1, #2, #3
			conn->llcp.phy_upd_ind.tx = 0U;
 10025a8:	42b8      	cmp	r0, r7
 10025aa:	bf08      	it	eq
 10025ac:	2700      	moveq	r7, #0
			conn->llcp.phy_upd_ind.rx = 0U;
 10025ae:	ebb3 1f51 	cmp.w	r3, r1, lsr #5
		if (conn->llcp_phy.rx != conn->lll.phy_rx) {
 10025b2:	ea4f 1051 	mov.w	r0, r1, lsr #5
			conn->llcp.phy_upd_ind.rx = 0U;
 10025b6:	bf08      	it	eq
 10025b8:	2000      	moveq	r0, #0
		conn->llcp_type = LLCP_PHY_UPD;
 10025ba:	f04f 0c06 	mov.w	ip, #6
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
 10025be:	f894 11ab 	ldrb.w	r1, [r4, #427]	; 0x1ab
		conn->llcp_ack -= 2U;
 10025c2:	1e93      	subs	r3, r2, #2
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
 10025c4:	f3c1 0180 	ubfx	r1, r1, #2, #1
		conn->llcp.phy_upd_ind.initiate = 1U;
 10025c8:	0049      	lsls	r1, r1, #1
 10025ca:	f041 0101 	orr.w	r1, r1, #1
 10025ce:	ea41 1140 	orr.w	r1, r1, r0, lsl #5
 10025d2:	ea41 0187 	orr.w	r1, r1, r7, lsl #2
		conn->llcp_ack -= 2U;
 10025d6:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
		conn->llcp.phy_upd_ind.initiate = 1U;
 10025da:	f884 10ec 	strb.w	r1, [r4, #236]	; 0xec
		conn->llcp_type = LLCP_PHY_UPD;
 10025de:	f884 c0ea 	strb.w	ip, [r4, #234]	; 0xea
		} else if (conn->llcp_length.ack != conn->llcp_length.req) {
 10025e2:	f7fe bb3d 	b.w	1000c60 <ull_conn_llcp+0x80>
	    (!feature_coded_phy && !feature_phy_2m)) {
 10025e6:	05d2      	lsls	r2, r2, #23
 10025e8:	f57f af19 	bpl.w	100241e <ull_conn_llcp+0x183e>
		tx_time = MAX(PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M),
 10025ec:	f5b3 6f85 	cmp.w	r3, #1064	; 0x428
 10025f0:	bf28      	it	cs
 10025f2:	f44f 6385 	movcs.w	r3, #1064	; 0x428
 10025f6:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
		rx_time = MAX(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_2M),
 10025fa:	f44f 6285 	mov.w	r2, #1064	; 0x428
 10025fe:	bf38      	it	cc
 1002600:	f44f 73a4 	movcc.w	r3, #328	; 0x148
 1002604:	e4d6      	b.n	1001fb4 <ull_conn_llcp+0x13d4>
				LL_ASSERT(rx && rx->hdr.link);
 1002606:	4832      	ldr	r0, [pc, #200]	; (10026d0 <ull_conn_llcp+0x1af0>)
 1002608:	f640 6147 	movw	r1, #3655	; 0xe47
 100260c:	f001 f838 	bl	1003680 <bt_ctlr_assert_handle>
 1002610:	6828      	ldr	r0, [r5, #0]
 1002612:	e5cf      	b.n	10021b4 <ull_conn_llcp+0x15d4>
				conn->llcp_length.cache.tx_octets = 0;
 1002614:	2200      	movs	r2, #0
				conn->llcp_length.tx_octets =
 1002616:	f8a4 319e 	strh.w	r3, [r4, #414]	; 0x19e
				conn->llcp_length.tx_time =
 100261a:	f8b4 31a6 	ldrh.w	r3, [r4, #422]	; 0x1a6
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
 100261e:	f362 0102 	bfi	r1, r2, #0, #3
 1002622:	f884 119a 	strb.w	r1, [r4, #410]	; 0x19a
				conn->llcp_length.cache.tx_octets = 0;
 1002626:	f8a4 21a4 	strh.w	r2, [r4, #420]	; 0x1a4
				conn->llcp_length.tx_time =
 100262a:	f8a4 31a2 	strh.w	r3, [r4, #418]	; 0x1a2
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
 100262e:	e44f      	b.n	1001ed0 <ull_conn_llcp+0x12f0>
				conn->llcp_conn_param.interval_max;
 1002630:	f8b4 2176 	ldrh.w	r2, [r4, #374]	; 0x176
 1002634:	f7ff ba14 	b.w	1001a60 <ull_conn_llcp+0xe80>
		} else if (conn->llcp_phy.rx & BIT(0)) {
 1002638:	07c8      	lsls	r0, r1, #31
 100263a:	d50f      	bpl.n	100265c <ull_conn_llcp+0x1a7c>
			conn->llcp_phy.rx = BIT(0);
 100263c:	2101      	movs	r1, #1
 100263e:	f361 1347 	bfi	r3, r1, #5, #3
 1002642:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
 1002646:	e7a3      	b.n	1002590 <ull_conn_llcp+0x19b0>
		} else if (conn->llcp_phy.tx & BIT(0)) {
 1002648:	07d9      	lsls	r1, r3, #31
 100264a:	d510      	bpl.n	100266e <ull_conn_llcp+0x1a8e>
			conn->llcp_phy.tx = BIT(0);
 100264c:	2101      	movs	r1, #1
 100264e:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
 1002652:	f361 0384 	bfi	r3, r1, #2, #3
 1002656:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
 100265a:	e78e      	b.n	100257a <ull_conn_llcp+0x199a>
		} else if (conn->llcp_phy.rx & BIT(2)) {
 100265c:	f011 0104 	ands.w	r1, r1, #4
			conn->llcp_phy.rx = BIT(2);
 1002660:	bf18      	it	ne
 1002662:	2104      	movne	r1, #4
			conn->llcp_phy.rx = 0U;
 1002664:	f361 1347 	bfi	r3, r1, #5, #3
 1002668:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
 100266c:	e790      	b.n	1002590 <ull_conn_llcp+0x19b0>
		} else if (conn->llcp_phy.tx & BIT(2)) {
 100266e:	f013 0304 	ands.w	r3, r3, #4
 1002672:	d00d      	beq.n	1002690 <ull_conn_llcp+0x1ab0>
			conn->llcp_phy.tx = BIT(2);
 1002674:	2104      	movs	r1, #4
 1002676:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
 100267a:	f361 0384 	bfi	r3, r1, #2, #3
 100267e:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
 1002682:	e77a      	b.n	100257a <ull_conn_llcp+0x199a>
			tx->next = conn->tx_head->next;
 1002684:	680b      	ldr	r3, [r1, #0]
 1002686:	6003      	str	r3, [r0, #0]
			conn->tx_head->next = tx;
 1002688:	6008      	str	r0, [r1, #0]
				conn->tx_ctrl_last = tx;
 100268a:	e9c4 006d 	strd	r0, r0, [r4, #436]	; 0x1b4
 100268e:	e4b5      	b.n	1001ffc <ull_conn_llcp+0x141c>
			conn->llcp_phy.tx = 0U;
 1002690:	f894 11aa 	ldrb.w	r1, [r4, #426]	; 0x1aa
 1002694:	f363 0184 	bfi	r1, r3, #2, #3
 1002698:	f884 11aa 	strb.w	r1, [r4, #426]	; 0x1aa
 100269c:	e76d      	b.n	100257a <ull_conn_llcp+0x199a>
		LL_ASSERT(0);
 100269e:	f44f 6153 	mov.w	r1, #3376	; 0xd30
 10026a2:	480b      	ldr	r0, [pc, #44]	; (10026d0 <ull_conn_llcp+0x1af0>)
 10026a4:	f000 ffec 	bl	1003680 <bt_ctlr_assert_handle>
		break;
 10026a8:	f7fe be7b 	b.w	10013a2 <ull_conn_llcp+0x7c2>
		LL_ASSERT(0);
 10026ac:	f44f 6153 	mov.w	r1, #3376	; 0xd30
 10026b0:	4807      	ldr	r0, [pc, #28]	; (10026d0 <ull_conn_llcp+0x1af0>)
 10026b2:	f000 ffe5 	bl	1003680 <bt_ctlr_assert_handle>
		break;
 10026b6:	f7fe bad3 	b.w	1000c60 <ull_conn_llcp+0x80>
		LL_ASSERT(0);
 10026ba:	f640 4134 	movw	r1, #3124	; 0xc34
 10026be:	4804      	ldr	r0, [pc, #16]	; (10026d0 <ull_conn_llcp+0x1af0>)
 10026c0:	f000 ffde 	bl	1003680 <bt_ctlr_assert_handle>
		break;
 10026c4:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 10026c8:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
 10026cc:	f7fe ba9a 	b.w	1000c04 <ull_conn_llcp+0x24>
 10026d0:	01018934 	.word	0x01018934
 10026d4:	00000000 	.word	0x00000000

010026d8 <ull_slave_setup>:
static void ticker_op_stop_adv_cb(u32_t status, void *param);
static void ticker_op_cb(u32_t status, void *param);

void ull_slave_setup(memq_link_t *link, struct node_rx_hdr *rx,
		     struct node_rx_ftr *ftr, struct lll_conn *lll)
{
 10026d8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10026dc:	4693      	mov	fp, r2
	u8_t chan_sel;

	((struct lll_adv *)ftr->param)->conn = NULL;

	adv = ((struct lll_adv *)ftr->param)->hdr.parent;
	conn = lll->hdr.parent;
 10026de:	461a      	mov	r2, r3
{
 10026e0:	4689      	mov	r9, r1
	((struct lll_adv *)ftr->param)->conn = NULL;
 10026e2:	2100      	movs	r1, #0
{
 10026e4:	461d      	mov	r5, r3
	((struct lll_adv *)ftr->param)->conn = NULL;
 10026e6:	f8db 6000 	ldr.w	r6, [fp]
	conn = lll->hdr.parent;
 10026ea:	f852 4b0c 	ldr.w	r4, [r2], #12

	/* Populate the slave context */
	pdu_adv = (void *)((struct node_rx_pdu *)rx)->pdu;
	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
	memcpy(&lll->access_addr[0], &pdu_adv->connect_ind.access_addr[0], 4);
 10026ee:	f103 0808 	add.w	r8, r3, #8
	adv = ((struct lll_adv *)ftr->param)->hdr.parent;
 10026f2:	6833      	ldr	r3, [r6, #0]
{
 10026f4:	b093      	sub	sp, #76	; 0x4c
	((struct lll_adv *)ftr->param)->conn = NULL;
 10026f6:	60b1      	str	r1, [r6, #8]
{
 10026f8:	4607      	mov	r7, r0
	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
 10026fa:	f109 0132 	add.w	r1, r9, #50	; 0x32
 10026fe:	4610      	mov	r0, r2
 1002700:	2203      	movs	r2, #3
	adv = ((struct lll_adv *)ftr->param)->hdr.parent;
 1002702:	930a      	str	r3, [sp, #40]	; 0x28
	memcpy(&lll->data_chan_map[0], &pdu_adv->connect_ind.chan_map[0],
 1002704:	f105 061c 	add.w	r6, r5, #28
	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
 1002708:	f014 f986 	bl	1016a18 <memcpy>
	memcpy(&lll->access_addr[0], &pdu_adv->connect_ind.access_addr[0], 4);
 100270c:	2204      	movs	r2, #4
 100270e:	f109 012e 	add.w	r1, r9, #46	; 0x2e
 1002712:	4640      	mov	r0, r8
 1002714:	f014 f980 	bl	1016a18 <memcpy>
	memcpy(&lll->data_chan_map[0], &pdu_adv->connect_ind.chan_map[0],
 1002718:	2205      	movs	r2, #5
 100271a:	f109 013e 	add.w	r1, r9, #62	; 0x3e
 100271e:	4630      	mov	r0, r6
 1002720:	f014 f97a 	bl	1016a18 <memcpy>
	       sizeof(lll->data_chan_map));
	lll->data_chan_count = util_ones_count_get(&lll->data_chan_map[0],
 1002724:	4630      	mov	r0, r6
 1002726:	2105      	movs	r1, #5
 1002728:	f003 fcc2 	bl	10060b0 <util_ones_count_get>
 100272c:	f895 2021 	ldrb.w	r2, [r5, #33]	; 0x21
 1002730:	f000 003f 	and.w	r0, r0, #63	; 0x3f
 1002734:	f360 0205 	bfi	r2, r0, #0, #6
			       sizeof(lll->data_chan_map));
	if (lll->data_chan_count < 2) {
 1002738:	2801      	cmp	r0, #1
	lll->data_chan_count = util_ones_count_get(&lll->data_chan_map[0],
 100273a:	f885 2021 	strb.w	r2, [r5, #33]	; 0x21
	if (lll->data_chan_count < 2) {
 100273e:	d90a      	bls.n	1002756 <ull_slave_setup+0x7e>
		return;
	}
	lll->data_chan_hop = pdu_adv->connect_ind.hop;
 1002740:	f899 2043 	ldrb.w	r2, [r9, #67]	; 0x43
 1002744:	f002 011f 	and.w	r1, r2, #31
	if ((lll->data_chan_hop < 5) || (lll->data_chan_hop > 16)) {
 1002748:	3905      	subs	r1, #5
	lll->data_chan_hop = pdu_adv->connect_ind.hop;
 100274a:	f3c2 0004 	ubfx	r0, r2, #0, #5
	if ((lll->data_chan_hop < 5) || (lll->data_chan_hop > 16)) {
 100274e:	290b      	cmp	r1, #11
	lll->data_chan_hop = pdu_adv->connect_ind.hop;
 1002750:	f885 0022 	strb.w	r0, [r5, #34]	; 0x22
	if ((lll->data_chan_hop < 5) || (lll->data_chan_hop > 16)) {
 1002754:	d902      	bls.n	100275c <ull_slave_setup+0x84>
	/* enable ticker job, irrespective of disabled in this function so
	 * first connection event can be scheduled as soon as possible.
	 */
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1);
#endif
}
 1002756:	b013      	add	sp, #76	; 0x4c
 1002758:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	interval = sys_le16_to_cpu(pdu_adv->connect_ind.interval);
 100275c:	f8b9 6038 	ldrh.w	r6, [r9, #56]	; 0x38
	conn->slave.sca = pdu_adv->connect_ind.sca;
 1002760:	f894 10dc 	ldrb.w	r1, [r4, #220]	; 0xdc
	lll->interval = interval;
 1002764:	826e      	strh	r6, [r5, #18]
	lll->latency = sys_le16_to_cpu(pdu_adv->connect_ind.latency);
 1002766:	f899 c03b 	ldrb.w	ip, [r9, #59]	; 0x3b
 100276a:	f899 003a 	ldrb.w	r0, [r9, #58]	; 0x3a
	conn->slave.sca = pdu_adv->connect_ind.sca;
 100276e:	0952      	lsrs	r2, r2, #5
	lll->latency = sys_le16_to_cpu(pdu_adv->connect_ind.latency);
 1002770:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
 1002774:	82a8      	strh	r0, [r5, #20]
	win_offset = sys_le16_to_cpu(pdu_adv->connect_ind.win_offset);
 1002776:	f8b9 3036 	ldrh.w	r3, [r9, #54]	; 0x36
	conn->slave.sca = pdu_adv->connect_ind.sca;
 100277a:	f362 0184 	bfi	r1, r2, #2, #3
 100277e:	f884 10dc 	strb.w	r1, [r4, #220]	; 0xdc
	win_offset = sys_le16_to_cpu(pdu_adv->connect_ind.win_offset);
 1002782:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
		(((lll_conn_ppm_local_get() +
 1002786:	f00e fc71 	bl	101106c <lll_conn_ppm_local_get>
	conn_interval_us = interval * 1250U;
 100278a:	f240 4ae2 	movw	sl, #1250	; 0x4e2
		   lll_conn_ppm_get(conn->slave.sca)) *
 100278e:	f894 20dc 	ldrb.w	r2, [r4, #220]	; 0xdc
		(((lll_conn_ppm_local_get() +
 1002792:	900b      	str	r0, [sp, #44]	; 0x2c
		   lll_conn_ppm_get(conn->slave.sca)) *
 1002794:	f3c2 0082 	ubfx	r0, r2, #2, #3
 1002798:	f00e fc6a 	bl	1011070 <lll_conn_ppm_get>
		RADIO_CONN_EVENTS((timeout * 10U * 1000U), conn_interval_us);
 100279c:	f242 7210 	movw	r2, #10000	; 0x2710
	interval = sys_le16_to_cpu(pdu_adv->connect_ind.interval);
 10027a0:	b2b6      	uxth	r6, r6
	conn_interval_us = interval * 1250U;
 10027a2:	fb0a f606 	mul.w	r6, sl, r6
		(((lll_conn_ppm_local_get() +
 10027a6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	lll->slave.window_size_event_us = pdu_adv->connect_ind.win_size * 1250U;
 10027a8:	f899 1035 	ldrb.w	r1, [r9, #53]	; 0x35
		(((lll_conn_ppm_local_get() +
 10027ac:	4418      	add	r0, r3
		   lll_conn_ppm_get(conn->slave.sca)) *
 10027ae:	fb06 f000 	mul.w	r0, r6, r0
		  conn_interval_us) + (1000000 - 1)) / 1000000U;
 10027b2:	4bc5      	ldr	r3, [pc, #788]	; (1002ac8 <ull_slave_setup+0x3f0>)
 10027b4:	f500 2074 	add.w	r0, r0, #999424	; 0xf4000
 10027b8:	f200 203f 	addw	r0, r0, #575	; 0x23f
 10027bc:	fba3 3000 	umull	r3, r0, r3, r0
	lll->slave.window_size_event_us = pdu_adv->connect_ind.win_size * 1250U;
 10027c0:	fb0a f301 	mul.w	r3, sl, r1
	lll->slave.window_widening_max_us = (conn_interval_us >> 1) -
 10027c4:	0871      	lsrs	r1, r6, #1
		  conn_interval_us) + (1000000 - 1)) / 1000000U;
 10027c6:	0c80      	lsrs	r0, r0, #18
	lll->slave.window_widening_max_us = (conn_interval_us >> 1) -
 10027c8:	3996      	subs	r1, #150	; 0x96
	lll->slave.window_widening_periodic_us =
 10027ca:	62a8      	str	r0, [r5, #40]	; 0x28
	lll->slave.window_widening_max_us = (conn_interval_us >> 1) -
 10027cc:	62e9      	str	r1, [r5, #44]	; 0x2c
	lll->slave.window_size_event_us = pdu_adv->connect_ind.win_size * 1250U;
 10027ce:	63eb      	str	r3, [r5, #60]	; 0x3c
	timeout = sys_le16_to_cpu(pdu_adv->connect_ind.timeout);
 10027d0:	f8b9 303c 	ldrh.w	r3, [r9, #60]	; 0x3c
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 10027d4:	49bd      	ldr	r1, [pc, #756]	; (1002acc <ull_slave_setup+0x3f4>)
	timeout = sys_le16_to_cpu(pdu_adv->connect_ind.timeout);
 10027d6:	b298      	uxth	r0, r3
		RADIO_CONN_EVENTS((timeout * 10U * 1000U), conn_interval_us);
 10027d8:	fb02 6200 	mla	r2, r2, r0, r6
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 10027dc:	4431      	add	r1, r6
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
 10027de:	48bc      	ldr	r0, [pc, #752]	; (1002ad0 <ull_slave_setup+0x3f8>)
		RADIO_CONN_EVENTS((timeout * 10U * 1000U), conn_interval_us);
 10027e0:	3a01      	subs	r2, #1
 10027e2:	fbb2 f2f6 	udiv	r2, r2, r6
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 10027e6:	fbb1 f1f6 	udiv	r1, r1, r6
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
 10027ea:	4430      	add	r0, r6
 10027ec:	fbb0 f0f6 	udiv	r0, r0, r6
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
 10027f0:	f8b5 c014 	ldrh.w	ip, [r5, #20]
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 10027f4:	fa1f fe81 	uxth.w	lr, r1
		RADIO_CONN_EVENTS((timeout * 10U * 1000U), conn_interval_us);
 10027f8:	f8a4 20c6 	strh.w	r2, [r4, #198]	; 0xc6
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
 10027fc:	f10c 0206 	add.w	r2, ip, #6
 1002800:	4596      	cmp	lr, r2
	timeout = sys_le16_to_cpu(pdu_adv->connect_ind.timeout);
 1002802:	f8ad 3036 	strh.w	r3, [sp, #54]	; 0x36
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 1002806:	f8a4 e0d2 	strh.w	lr, [r4, #210]	; 0xd2
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
 100280a:	f8a4 00ca 	strh.w	r0, [r4, #202]	; 0xca
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
 100280e:	dd05      	ble.n	100281c <ull_slave_setup+0x144>
			     (conn->apto_reload - (lll->latency + 6)) :
 1002810:	ebae 0c0c 	sub.w	ip, lr, ip
 1002814:	f1ac 0c06 	sub.w	ip, ip, #6
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
 1002818:	fa1f fe8c 	uxth.w	lr, ip
	memcpy((void *)&conn->slave.force, &lll->access_addr[0],
 100281c:	4641      	mov	r1, r8
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
 100281e:	f8a4 e0ce 	strh.w	lr, [r4, #206]	; 0xce
	memcpy((void *)&conn->slave.force, &lll->access_addr[0],
 1002822:	2204      	movs	r2, #4
 1002824:	f104 00e0 	add.w	r0, r4, #224	; 0xe0
 1002828:	f014 f8f6 	bl	1016a18 <memcpy>
	peer_addr_type = pdu_adv->tx_addr;
 100282c:	f899 c020 	ldrb.w	ip, [r9, #32]
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
 1002830:	f109 0a22 	add.w	sl, r9, #34	; 0x22
	peer_addr_type = pdu_adv->tx_addr;
 1002834:	f3cc 1380 	ubfx	r3, ip, #6, #1
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
 1002838:	4651      	mov	r1, sl
 100283a:	2206      	movs	r2, #6
 100283c:	a810      	add	r0, sp, #64	; 0x40
	peer_addr_type = pdu_adv->tx_addr;
 100283e:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
 1002842:	f014 f8e9 	bl	1016a18 <memcpy>
	cc->status = 0U;
 1002846:	f44f 7180 	mov.w	r1, #256	; 0x100
	chan_sel = pdu_adv->chan_sel;
 100284a:	f899 2020 	ldrb.w	r2, [r9, #32]
	if (ull_filter_lll_lrpa_used(adv->lll.rl_idx)) {
 100284e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	cc->status = 0U;
 1002850:	f8a9 1020 	strh.w	r1, [r9, #32]
	if (ull_filter_lll_lrpa_used(adv->lll.rl_idx)) {
 1002854:	f893 002a 	ldrb.w	r0, [r3, #42]	; 0x2a
	chan_sel = pdu_adv->chan_sel;
 1002858:	f3c2 1340 	ubfx	r3, r2, #5, #1
	u8_t rl_idx = ftr->rl_idx;
 100285c:	f89b 8016 	ldrb.w	r8, [fp, #22]
	chan_sel = pdu_adv->chan_sel;
 1002860:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
 1002864:	930b      	str	r3, [sp, #44]	; 0x2c
	if (ull_filter_lll_lrpa_used(adv->lll.rl_idx)) {
 1002866:	f00d f847 	bl	100f8f8 <ull_filter_lll_lrpa_used>
		memcpy(&cc->local_rpa[0], &pdu_adv->connect_ind.adv_addr[0],
 100286a:	2206      	movs	r2, #6
	if (ull_filter_lll_lrpa_used(adv->lll.rl_idx)) {
 100286c:	4601      	mov	r1, r0
 100286e:	2800      	cmp	r0, #0
 1002870:	f040 80ef 	bne.w	1002a52 <ull_slave_setup+0x37a>
		memset(&cc->local_rpa[0], 0x0, BDADDR_SIZE);
 1002874:	f109 002f 	add.w	r0, r9, #47	; 0x2f
 1002878:	f014 f8f9 	bl	1016a6e <memset>
	if (rl_idx != FILTER_IDX_NONE) {
 100287c:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
 1002880:	f000 80f1 	beq.w	1002a66 <ull_slave_setup+0x38e>
		ll_rl_id_addr_get(rl_idx, &cc->peer_addr_type,
 1002884:	4651      	mov	r1, sl
 1002886:	4640      	mov	r0, r8
 1002888:	f109 0223 	add.w	r2, r9, #35	; 0x23
 100288c:	f00c faa2 	bl	100edd4 <ll_rl_id_addr_get>
		cc->peer_addr_type += 2;
 1002890:	f899 2022 	ldrb.w	r2, [r9, #34]	; 0x22
		memcpy(&cc->peer_rpa[0], &peer_addr[0], BDADDR_SIZE);
 1002894:	a910      	add	r1, sp, #64	; 0x40
		cc->peer_addr_type += 2;
 1002896:	3202      	adds	r2, #2
 1002898:	f889 2022 	strb.w	r2, [r9, #34]	; 0x22
		memcpy(&cc->peer_rpa[0], &peer_addr[0], BDADDR_SIZE);
 100289c:	f109 0029 	add.w	r0, r9, #41	; 0x29
 10028a0:	2206      	movs	r2, #6
 10028a2:	f014 f8b9 	bl	1016a18 <memcpy>
	cc->sca = conn->slave.sca;
 10028a6:	f894 20dc 	ldrb.w	r2, [r4, #220]	; 0xdc
	cc->interval = lll->interval;
 10028aa:	8a68      	ldrh	r0, [r5, #18]
	cc->latency = lll->latency;
 10028ac:	8aa9      	ldrh	r1, [r5, #20]
	cc->timeout = timeout;
 10028ae:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
	cc->sca = conn->slave.sca;
 10028b2:	f3c2 0282 	ubfx	r2, r2, #2, #3
	cc->timeout = timeout;
 10028b6:	f8a9 303a 	strh.w	r3, [r9, #58]	; 0x3a
	cc->interval = lll->interval;
 10028ba:	f8a9 0036 	strh.w	r0, [r9, #54]	; 0x36
	cc->sca = conn->slave.sca;
 10028be:	f889 203c 	strb.w	r2, [r9, #60]	; 0x3c
	cc->latency = lll->latency;
 10028c2:	f8a9 1038 	strh.w	r1, [r9, #56]	; 0x38
	lll->handle = ll_conn_handle_get(conn);
 10028c6:	4620      	mov	r0, r4
 10028c8:	f008 fef4 	bl	100b6b4 <ll_conn_handle_get>
 10028cc:	4602      	mov	r2, r0
 10028ce:	8228      	strh	r0, [r5, #16]
		ll_rx_put(link, rx);
 10028d0:	4649      	mov	r1, r9
 10028d2:	4638      	mov	r0, r7
	rx->handle = lll->handle;
 10028d4:	f8a9 2006 	strh.w	r2, [r9, #6]
		rx_csa = (void *)ftr->extra;
 10028d8:	f8db 7004 	ldr.w	r7, [fp, #4]
		ll_rx_put(link, rx);
 10028dc:	f007 fc4e 	bl	100a17c <ll_rx_put>
		rx->type = NODE_RX_TYPE_CHAN_SEL_ALGO;
 10028e0:	230d      	movs	r3, #13
		rx->handle = lll->handle;
 10028e2:	8a2a      	ldrh	r2, [r5, #16]
		rx->type = NODE_RX_TYPE_CHAN_SEL_ALGO;
 10028e4:	713b      	strb	r3, [r7, #4]
		if (chan_sel) {
 10028e6:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		link = rx->link;
 10028e8:	6838      	ldr	r0, [r7, #0]
		rx->handle = lll->handle;
 10028ea:	80fa      	strh	r2, [r7, #6]
		if (chan_sel) {
 10028ec:	2b00      	cmp	r3, #0
 10028ee:	f000 80cb 	beq.w	1002a88 <ull_slave_setup+0x3b0>
			cs->csa = 0x01;
 10028f2:	2101      	movs	r1, #1
			u16_t aa_ls = ((u16_t)lll->access_addr[1] << 8) |
 10028f4:	7a6a      	ldrb	r2, [r5, #9]
				      lll->access_addr[0];
 10028f6:	7a2b      	ldrb	r3, [r5, #8]
			u16_t aa_ms = ((u16_t)lll->access_addr[3] << 8) |
 10028f8:	f895 e00b 	ldrb.w	lr, [r5, #11]
				      lll->access_addr[2];
 10028fc:	f895 c00a 	ldrb.w	ip, [r5, #10]
			u16_t aa_ls = ((u16_t)lll->access_addr[1] << 8) |
 1002900:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			lll->data_chan_sel = 1;
 1002904:	f895 2021 	ldrb.w	r2, [r5, #33]	; 0x21
			u16_t aa_ms = ((u16_t)lll->access_addr[3] << 8) |
 1002908:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
			lll->data_chan_id = aa_ms ^ aa_ls;
 100290c:	ea83 030c 	eor.w	r3, r3, ip
			lll->data_chan_sel = 1;
 1002910:	f042 0240 	orr.w	r2, r2, #64	; 0x40
			lll->data_chan_id = aa_ms ^ aa_ls;
 1002914:	846b      	strh	r3, [r5, #34]	; 0x22
			lll->data_chan_sel = 1;
 1002916:	f885 2021 	strb.w	r2, [r5, #33]	; 0x21
			cs->csa = 0x01;
 100291a:	f887 1020 	strb.w	r1, [r7, #32]
	ll_rx_put(link, rx);
 100291e:	4639      	mov	r1, r7
 1002920:	f007 fc2c 	bl	100a17c <ll_rx_put>
	conn->evt.ticks_active_to_start = 0U;
 1002924:	2700      	movs	r7, #0
	ll_rx_sched();
 1002926:	f007 fc33 	bl	100a190 <ll_rx_sched>
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 100292a:	a365      	add	r3, pc, #404	; (adr r3, 1002ac0 <ull_slave_setup+0x3e8>)
 100292c:	e9d3 2300 	ldrd	r2, r3, [r3]
	conn->evt.ticks_xtal_to_start =
 1002930:	f04f 0c31 	mov.w	ip, #49	; 0x31
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 1002934:	f8db a010 	ldr.w	sl, [fp, #16]
 1002938:	4966      	ldr	r1, [pc, #408]	; (1002ad4 <ull_slave_setup+0x3fc>)
	conn_offset_us += ((u64_t)win_offset + 1) * 1250U;
 100293a:	f240 48e2 	movw	r8, #1250	; 0x4e2
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 100293e:	f20a 4052 	addw	r0, sl, #1106	; 0x452
	conn->evt.ticks_xtal_to_start =
 1002942:	f8c4 c000 	str.w	ip, [r4]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 1002946:	fba0 0101 	umull	r0, r1, r0, r1
	conn->evt.ticks_preempt_to_start =
 100294a:	e9c4 7701 	strd	r7, r7, [r4, #4]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 100294e:	f7fd fbb3 	bl	10000b8 <__aeabi_uldivmod>
	conn_offset_us += ((u64_t)win_offset + 1) * 1250U;
 1002952:	f8bd 2030 	ldrh.w	r2, [sp, #48]	; 0x30
 1002956:	f8db 300c 	ldr.w	r3, [fp, #12]
 100295a:	fb08 8c02 	mla	ip, r8, r2, r8
	conn_interval_us -= lll->slave.window_widening_periodic_us;
 100295e:	6aad      	ldr	r5, [r5, #40]	; 0x28
 1002960:	f5a3 78ae 	sub.w	r8, r3, #348	; 0x15c
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 1002964:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
 1002968:	463a      	mov	r2, r7
 100296a:	2102      	movs	r1, #2
	conn->evt.ticks_slot =
 100296c:	60e0      	str	r0, [r4, #12]
	conn_interval_us -= lll->slave.window_widening_periodic_us;
 100296e:	eba8 0a0a 	sub.w	sl, r8, sl
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
 1002972:	2001      	movs	r0, #1
	conn_offset_us -= ftr->us_radio_rdy;
 1002974:	eb0c 080a 	add.w	r8, ip, sl
	conn_interval_us -= lll->slave.window_widening_periodic_us;
 1002978:	1b76      	subs	r6, r6, r5
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
 100297a:	f003 fa71 	bl	1005e60 <mayfly_enable>
	ticker_id_adv = TICKER_ID_ADV_BASE + ull_adv_handle_get(adv);
 100297e:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 1002980:	4628      	mov	r0, r5
 1002982:	f008 f987 	bl	100ac94 <ull_adv_handle_get>
 1002986:	1c82      	adds	r2, r0, #2
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 1002988:	2101      	movs	r1, #1
 100298a:	4638      	mov	r0, r7
 100298c:	4b52      	ldr	r3, [pc, #328]	; (1002ad8 <ull_slave_setup+0x400>)
 100298e:	b2d2      	uxtb	r2, r2
 1002990:	9500      	str	r5, [sp, #0]
 1002992:	f004 fccb 	bl	100732c <ticker_stop>
}
#endif /* CONFIG_BT_CTLR_LE_ENC */

static void ticker_op_stop_adv_cb(u32_t status, void *param)
{
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
 1002996:	2801      	cmp	r0, #1
 1002998:	f000 8083 	beq.w	1002aa2 <ull_slave_setup+0x3ca>
	if (adv->lll.is_hdcd) {
 100299c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 100299e:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 10029a2:	07db      	lsls	r3, r3, #31
 10029a4:	d475      	bmi.n	1002a92 <ull_slave_setup+0x3ba>
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
 10029a6:	4620      	mov	r0, r4
 10029a8:	f008 fe84 	bl	100b6b4 <ll_conn_handle_get>
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
 10029ac:	a344      	add	r3, pc, #272	; (adr r3, 1002ac0 <ull_slave_setup+0x3e8>)
 10029ae:	e9d3 2300 	ldrd	r2, r3, [r3]
 10029b2:	4948      	ldr	r1, [pc, #288]	; (1002ad4 <ull_slave_setup+0x3fc>)
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
 10029b4:	4605      	mov	r5, r0
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
 10029b6:	fba6 6701 	umull	r6, r7, r6, r1
 10029ba:	4630      	mov	r0, r6
 10029bc:	4639      	mov	r1, r7
 10029be:	f7fd fb7b 	bl	10000b8 <__aeabi_uldivmod>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 10029c2:	f240 1121 	movw	r1, #289	; 0x121
				     HAL_TICKER_REMAINDER(conn_interval_us),
 10029c6:	f04f 0c07 	mov.w	ip, #7
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 10029ca:	f04f 0a00 	mov.w	sl, #0
				     HAL_TICKER_REMAINDER(conn_interval_us),
 10029ce:	4a43      	ldr	r2, [pc, #268]	; (1002adc <ull_slave_setup+0x404>)
 10029d0:	f020 497f 	bic.w	r9, r0, #4278190080	; 0xff000000
 10029d4:	fba9 2302 	umull	r2, r3, r9, r2
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 10029d8:	9108      	str	r1, [sp, #32]
 10029da:	4941      	ldr	r1, [pc, #260]	; (1002ae0 <ull_slave_setup+0x408>)
 10029dc:	9406      	str	r4, [sp, #24]
				     HAL_TICKER_REMAINDER(conn_interval_us),
 10029de:	fb0c 3309 	mla	r3, ip, r9, r3
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 10029e2:	f8db c008 	ldr.w	ip, [fp, #8]
 10029e6:	9107      	str	r1, [sp, #28]
 10029e8:	493e      	ldr	r1, [pc, #248]	; (1002ae4 <ull_slave_setup+0x40c>)
				     HAL_TICKER_REMAINDER(conn_interval_us),
 10029ea:	1ab0      	subs	r0, r6, r2
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 10029ec:	9105      	str	r1, [sp, #20]
 10029ee:	68e4      	ldr	r4, [r4, #12]
				     HAL_TICKER_REMAINDER(conn_interval_us),
 10029f0:	eb67 0103 	sbc.w	r1, r7, r3
 10029f4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 10029f8:	2300      	movs	r3, #0
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 10029fa:	f1ac 0631 	sub.w	r6, ip, #49	; 0x31
 10029fe:	e9cd a403 	strd	sl, r4, [sp, #12]
				     HAL_TICKER_REMAINDER(conn_interval_us),
 1002a02:	f7fd fb59 	bl	10000b8 <__aeabi_uldivmod>
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
 1002a06:	a32e      	add	r3, pc, #184	; (adr r3, 1002ac0 <ull_slave_setup+0x3e8>)
 1002a08:	e9d3 2300 	ldrd	r2, r3, [r3]
				     HAL_TICKER_REMAINDER(conn_interval_us),
 1002a0c:	4604      	mov	r4, r0
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
 1002a0e:	4931      	ldr	r1, [pc, #196]	; (1002ad4 <ull_slave_setup+0x3fc>)
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1002a10:	e9cd 9401 	strd	r9, r4, [sp, #4]
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
 1002a14:	fba8 0101 	umull	r0, r1, r8, r1
 1002a18:	f7fd fb4e 	bl	10000b8 <__aeabi_uldivmod>
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
 1002a1c:	3505      	adds	r5, #5
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1002a1e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 1002a22:	b2ed      	uxtb	r5, r5
 1002a24:	4633      	mov	r3, r6
 1002a26:	9000      	str	r0, [sp, #0]
 1002a28:	462a      	mov	r2, r5
 1002a2a:	4650      	mov	r0, sl
 1002a2c:	2101      	movs	r1, #1
 1002a2e:	f004 fc17 	bl	1007260 <ticker_start>
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 1002a32:	f030 0302 	bics.w	r3, r0, #2
 1002a36:	d004      	beq.n	1002a42 <ull_slave_setup+0x36a>
 1002a38:	f44f 7191 	mov.w	r1, #290	; 0x122
 1002a3c:	482a      	ldr	r0, [pc, #168]	; (1002ae8 <ull_slave_setup+0x410>)
 1002a3e:	f000 fe1f 	bl	1003680 <bt_ctlr_assert_handle>
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1);
 1002a42:	2201      	movs	r2, #1
 1002a44:	2102      	movs	r1, #2
 1002a46:	4610      	mov	r0, r2
 1002a48:	f003 fa0a 	bl	1005e60 <mayfly_enable>
}
 1002a4c:	b013      	add	sp, #76	; 0x4c
 1002a4e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		memcpy(&cc->local_rpa[0], &pdu_adv->connect_ind.adv_addr[0],
 1002a52:	f109 0128 	add.w	r1, r9, #40	; 0x28
 1002a56:	f109 002f 	add.w	r0, r9, #47	; 0x2f
 1002a5a:	f013 ffdd 	bl	1016a18 <memcpy>
	if (rl_idx != FILTER_IDX_NONE) {
 1002a5e:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
 1002a62:	f47f af0f 	bne.w	1002884 <ull_slave_setup+0x1ac>
		memset(&cc->peer_rpa[0], 0x0, BDADDR_SIZE);
 1002a66:	2206      	movs	r2, #6
 1002a68:	2100      	movs	r1, #0
 1002a6a:	f109 0029 	add.w	r0, r9, #41	; 0x29
 1002a6e:	f013 fffe 	bl	1016a6e <memset>
		cc->peer_addr_type = peer_addr_type;
 1002a72:	f89d 303c 	ldrb.w	r3, [sp, #60]	; 0x3c
		memcpy(cc->peer_addr, peer_addr, BDADDR_SIZE);
 1002a76:	2206      	movs	r2, #6
		cc->peer_addr_type = peer_addr_type;
 1002a78:	f889 3022 	strb.w	r3, [r9, #34]	; 0x22
		memcpy(cc->peer_addr, peer_addr, BDADDR_SIZE);
 1002a7c:	a910      	add	r1, sp, #64	; 0x40
 1002a7e:	f109 0023 	add.w	r0, r9, #35	; 0x23
 1002a82:	f013 ffc9 	bl	1016a18 <memcpy>
 1002a86:	e70e      	b.n	10028a6 <ull_slave_setup+0x1ce>
			cs->csa = 0x00;
 1002a88:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
 1002a8c:	f887 3020 	strb.w	r3, [r7, #32]
 1002a90:	e745      	b.n	100291e <ull_slave_setup+0x246>
		ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
 1002a92:	2300      	movs	r3, #0
 1002a94:	2201      	movs	r2, #1
 1002a96:	4618      	mov	r0, r3
 1002a98:	4611      	mov	r1, r2
 1002a9a:	9300      	str	r3, [sp, #0]
 1002a9c:	f004 fc46 	bl	100732c <ticker_stop>
 1002aa0:	e781      	b.n	10029a6 <ull_slave_setup+0x2ce>
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
 1002aa2:	f007 fc01 	bl	100a2a8 <ull_disable_mark_get>
 1002aa6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 1002aa8:	4283      	cmp	r3, r0
 1002aaa:	f43f af77 	beq.w	100299c <ull_slave_setup+0x2c4>
 1002aae:	f44f 71de 	mov.w	r1, #444	; 0x1bc
 1002ab2:	480d      	ldr	r0, [pc, #52]	; (1002ae8 <ull_slave_setup+0x410>)
 1002ab4:	f000 fde4 	bl	1003680 <bt_ctlr_assert_handle>
		  param == ull_disable_mark_get());
}
 1002ab8:	e770      	b.n	100299c <ull_slave_setup+0x2c4>
 1002aba:	bf00      	nop
 1002abc:	f3af 8000 	nop.w
 1002ac0:	1afd498d 	.word	0x1afd498d
 1002ac4:	00000007 	.word	0x00000007
 1002ac8:	431bde83 	.word	0x431bde83
 1002acc:	01c9c37f 	.word	0x01c9c37f
 1002ad0:	026259ff 	.word	0x026259ff
 1002ad4:	3b9aca00 	.word	0x3b9aca00
 1002ad8:	0100e231 	.word	0x0100e231
 1002adc:	1afd498d 	.word	0x1afd498d
 1002ae0:	0100e1a1 	.word	0x0100e1a1
 1002ae4:	0100e1b5 	.word	0x0100e1b5
 1002ae8:	01018994 	.word	0x01018994
 1002aec:	00000000 	.word	0x00000000

01002af0 <ull_slave_done>:
{
 1002af0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	preamble_to_addr_us =
 1002af4:	e9d0 c70c 	ldrd	ip, r7, [r0, #48]	; 0x30
	start_to_address_actual_us =
 1002af8:	f8d0 802c 	ldr.w	r8, [r0, #44]	; 0x2c
				       window_widening_event_us +
 1002afc:	eb0c 0407 	add.w	r4, ip, r7
	start_to_address_expected_us = EVENT_JITTER_US +
 1002b00:	3430      	adds	r4, #48	; 0x30
	if (start_to_address_actual_us <= start_to_address_expected_us) {
 1002b02:	45a0      	cmp	r8, r4
{
 1002b04:	460e      	mov	r6, r1
 1002b06:	4615      	mov	r5, r2
	if (start_to_address_actual_us <= start_to_address_expected_us) {
 1002b08:	d818      	bhi.n	1002b3c <ull_slave_done+0x4c>
			HAL_TICKER_US_TO_TICKS(window_widening_event_us);
 1002b0a:	a319      	add	r3, pc, #100	; (adr r3, 1002b70 <ull_slave_done+0x80>)
 1002b0c:	e9d3 2300 	ldrd	r2, r3, [r3]
 1002b10:	4f19      	ldr	r7, [pc, #100]	; (1002b78 <ull_slave_done+0x88>)
			HAL_TICKER_US_TO_TICKS((start_to_address_expected_us -
 1002b12:	eba4 0408 	sub.w	r4, r4, r8
			HAL_TICKER_US_TO_TICKS(window_widening_event_us);
 1002b16:	fbac 0107 	umull	r0, r1, ip, r7
 1002b1a:	f7fd facd 	bl	10000b8 <__aeabi_uldivmod>
			HAL_TICKER_US_TO_TICKS((start_to_address_expected_us -
 1002b1e:	a314      	add	r3, pc, #80	; (adr r3, 1002b70 <ull_slave_done+0x80>)
 1002b20:	e9d3 2300 	ldrd	r2, r3, [r3]
			HAL_TICKER_US_TO_TICKS(window_widening_event_us);
 1002b24:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_plus =
 1002b28:	6030      	str	r0, [r6, #0]
			HAL_TICKER_US_TO_TICKS((start_to_address_expected_us -
 1002b2a:	fba4 0107 	umull	r0, r1, r4, r7
 1002b2e:	f7fd fac3 	bl	10000b8 <__aeabi_uldivmod>
 1002b32:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_minus =
 1002b36:	6028      	str	r0, [r5, #0]
}
 1002b38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			HAL_TICKER_US_TO_TICKS(start_to_address_actual_us);
 1002b3c:	4c0e      	ldr	r4, [pc, #56]	; (1002b78 <ull_slave_done+0x88>)
 1002b3e:	a30c      	add	r3, pc, #48	; (adr r3, 1002b70 <ull_slave_done+0x80>)
 1002b40:	e9d3 2300 	ldrd	r2, r3, [r3]
 1002b44:	fba8 0104 	umull	r0, r1, r8, r4
 1002b48:	f7fd fab6 	bl	10000b8 <__aeabi_uldivmod>
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
 1002b4c:	a308      	add	r3, pc, #32	; (adr r3, 1002b70 <ull_slave_done+0x80>)
 1002b4e:	e9d3 2300 	ldrd	r2, r3, [r3]
			HAL_TICKER_US_TO_TICKS(start_to_address_actual_us);
 1002b52:	f020 417f 	bic.w	r1, r0, #4278190080	; 0xff000000
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
 1002b56:	f107 0030 	add.w	r0, r7, #48	; 0x30
		*ticks_drift_plus =
 1002b5a:	6031      	str	r1, [r6, #0]
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
 1002b5c:	fba0 0104 	umull	r0, r1, r0, r4
 1002b60:	f7fd faaa 	bl	10000b8 <__aeabi_uldivmod>
 1002b64:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_minus =
 1002b68:	6028      	str	r0, [r5, #0]
}
 1002b6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 1002b6e:	bf00      	nop
 1002b70:	1afd498d 	.word	0x1afd498d
 1002b74:	00000007 	.word	0x00000007
 1002b78:	3b9aca00 	.word	0x3b9aca00
 1002b7c:	00000000 	.word	0x00000000

01002b80 <ull_master_setup>:
}
#endif /* CONFIG_BT_CTLR_LE_ENC */

void ull_master_setup(memq_link_t *link, struct node_rx_hdr *rx,
		      struct node_rx_ftr *ftr, struct lll_conn *lll)
{
 1002b80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct pdu_adv *pdu_tx;
	u8_t peer_addr_type;
	u32_t ticker_status;
	u8_t chan_sel;

	((struct lll_scan *)ftr->param)->conn = NULL;
 1002b84:	f04f 0b00 	mov.w	fp, #0
{
 1002b88:	460c      	mov	r4, r1
 1002b8a:	461d      	mov	r5, r3
 1002b8c:	4616      	mov	r6, r2
	scan = ((struct lll_scan *)ftr->param)->hdr.parent;
	conn = lll->hdr.parent;

	pdu_tx = (void *)((struct node_rx_pdu *)rx)->pdu;

	peer_addr_type = pdu_tx->rx_addr;
 1002b8e:	f891 7020 	ldrb.w	r7, [r1, #32]
	((struct lll_scan *)ftr->param)->conn = NULL;
 1002b92:	6813      	ldr	r3, [r2, #0]
{
 1002b94:	b08f      	sub	sp, #60	; 0x3c
	((struct lll_scan *)ftr->param)->conn = NULL;
 1002b96:	f8c3 b008 	str.w	fp, [r3, #8]
	memcpy(peer_addr, &pdu_tx->connect_ind.adv_addr[0], BDADDR_SIZE);
 1002b9a:	2206      	movs	r2, #6
	scan = ((struct lll_scan *)ftr->param)->hdr.parent;
 1002b9c:	f8d3 a000 	ldr.w	sl, [r3]
	memcpy(peer_addr, &pdu_tx->connect_ind.adv_addr[0], BDADDR_SIZE);
 1002ba0:	3128      	adds	r1, #40	; 0x28
	peer_addr_type = pdu_tx->rx_addr;
 1002ba2:	f3c7 13c0 	ubfx	r3, r7, #7, #1
{
 1002ba6:	4681      	mov	r9, r0
	memcpy(peer_addr, &pdu_tx->connect_ind.adv_addr[0], BDADDR_SIZE);
 1002ba8:	a80c      	add	r0, sp, #48	; 0x30
	peer_addr_type = pdu_tx->rx_addr;
 1002baa:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
	conn = lll->hdr.parent;
 1002bae:	682f      	ldr	r7, [r5, #0]
	memcpy(peer_addr, &pdu_tx->connect_ind.adv_addr[0], BDADDR_SIZE);
 1002bb0:	f013 ff32 	bl	1016a18 <memcpy>

	/* This is the chan sel bit from the received adv pdu */
	chan_sel = pdu_tx->chan_sel;
 1002bb4:	f894 8020 	ldrb.w	r8, [r4, #32]

	cc = (void *)pdu_tx;
	cc->status = 0U;
 1002bb8:	f8a4 b020 	strh.w	fp, [r4, #32]
	cc->role = 0U;

#if defined(CONFIG_BT_CTLR_PRIVACY)
	u8_t rl_idx = ftr->rl_idx;

	if (ftr->lrpa_used) {
 1002bbc:	7d71      	ldrb	r1, [r6, #21]
	chan_sel = pdu_tx->chan_sel;
 1002bbe:	f3c8 1340 	ubfx	r3, r8, #5, #1
	if (ftr->lrpa_used) {
 1002bc2:	f011 0101 	ands.w	r1, r1, #1
	chan_sel = pdu_tx->chan_sel;
 1002bc6:	4698      	mov	r8, r3
		memcpy(&cc->local_rpa[0], &pdu_tx->connect_ind.init_addr[0],
 1002bc8:	f04f 0206 	mov.w	r2, #6
	u8_t rl_idx = ftr->rl_idx;
 1002bcc:	f896 b016 	ldrb.w	fp, [r6, #22]
	chan_sel = pdu_tx->chan_sel;
 1002bd0:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
	if (ftr->lrpa_used) {
 1002bd4:	f000 80e1 	beq.w	1002d9a <ull_master_setup+0x21a>
		memcpy(&cc->local_rpa[0], &pdu_tx->connect_ind.init_addr[0],
 1002bd8:	f104 0122 	add.w	r1, r4, #34	; 0x22
 1002bdc:	f104 002f 	add.w	r0, r4, #47	; 0x2f
 1002be0:	f013 ff1a 	bl	1016a18 <memcpy>
		       BDADDR_SIZE);
	} else {
		memset(&cc->local_rpa[0], 0x0, BDADDR_SIZE);
	}

	if (rl_idx != FILTER_IDX_NONE) {
 1002be4:	f1bb 0fff 	cmp.w	fp, #255	; 0xff
 1002be8:	f000 80df 	beq.w	1002daa <ull_master_setup+0x22a>
		/* Store identity address */
		ll_rl_id_addr_get(rl_idx, &cc->peer_addr_type,
 1002bec:	4658      	mov	r0, fp
 1002bee:	f104 0223 	add.w	r2, r4, #35	; 0x23
 1002bf2:	f104 0122 	add.w	r1, r4, #34	; 0x22
 1002bf6:	f00c f8ed 	bl	100edd4 <ll_rl_id_addr_get>
				  &cc->peer_addr[0]);
		/* Mark it as identity address from RPA (0x02, 0x03) */
		cc->peer_addr_type += 2;
 1002bfa:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22

		/* Store peer RPA */
		memcpy(&cc->peer_rpa[0], &peer_addr[0], BDADDR_SIZE);
 1002bfe:	2206      	movs	r2, #6
		cc->peer_addr_type += 2;
 1002c00:	3302      	adds	r3, #2
		memcpy(&cc->peer_rpa[0], &peer_addr[0], BDADDR_SIZE);
 1002c02:	a90c      	add	r1, sp, #48	; 0x30
		cc->peer_addr_type += 2;
 1002c04:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
		memcpy(&cc->peer_rpa[0], &peer_addr[0], BDADDR_SIZE);
 1002c08:	f104 0029 	add.w	r0, r4, #41	; 0x29
 1002c0c:	f013 ff04 	bl	1016a18 <memcpy>
#endif /* CONFIG_BT_CTLR_PRIVACY */
		cc->peer_addr_type = peer_addr_type;
		memcpy(cc->peer_addr, &peer_addr[0], BDADDR_SIZE);
	}

	cc->interval = lll->interval;
 1002c10:	8a6b      	ldrh	r3, [r5, #18]
	cc->latency = lll->latency;
 1002c12:	8aaa      	ldrh	r2, [r5, #20]
	cc->interval = lll->interval;
 1002c14:	86e3      	strh	r3, [r4, #54]	; 0x36
	cc->timeout = scan->lll.conn_timeout;
 1002c16:	f8ba 3030 	ldrh.w	r3, [sl, #48]	; 0x30
	cc->latency = lll->latency;
 1002c1a:	8722      	strh	r2, [r4, #56]	; 0x38
	cc->timeout = scan->lll.conn_timeout;
 1002c1c:	8763      	strh	r3, [r4, #58]	; 0x3a
	cc->sca = lll_conn_sca_local_get();
 1002c1e:	f00e fa23 	bl	1011068 <lll_conn_sca_local_get>
 1002c22:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c

	lll->handle = ll_conn_handle_get(conn);
 1002c26:	4638      	mov	r0, r7
 1002c28:	f008 fd44 	bl	100b6b4 <ll_conn_handle_get>
 1002c2c:	4603      	mov	r3, r0
		 * rx node.
		 */
		rx_csa = (void *)ftr->extra;

		/* Enqueue the connection event */
		ll_rx_put(link, rx);
 1002c2e:	4621      	mov	r1, r4
	lll->handle = ll_conn_handle_get(conn);
 1002c30:	822b      	strh	r3, [r5, #16]
		ll_rx_put(link, rx);
 1002c32:	4648      	mov	r0, r9
	rx->handle = lll->handle;
 1002c34:	80e3      	strh	r3, [r4, #6]
		rx_csa = (void *)ftr->extra;
 1002c36:	6874      	ldr	r4, [r6, #4]
		ll_rx_put(link, rx);
 1002c38:	f007 faa0 	bl	100a17c <ll_rx_put>
		/* use the rx node for CSA event */
		rx = (void *)rx_csa;
		link = rx->link;

		rx->handle = lll->handle;
		rx->type = NODE_RX_TYPE_CHAN_SEL_ALGO;
 1002c3c:	220d      	movs	r2, #13
		rx->handle = lll->handle;
 1002c3e:	8a2b      	ldrh	r3, [r5, #16]
		link = rx->link;
 1002c40:	6820      	ldr	r0, [r4, #0]
		rx->type = NODE_RX_TYPE_CHAN_SEL_ALGO;
 1002c42:	7122      	strb	r2, [r4, #4]
		rx->handle = lll->handle;
 1002c44:	80e3      	strh	r3, [r4, #6]

		cs = (void *)rx_csa->pdu;

		if (chan_sel) {
 1002c46:	f1b8 0f00 	cmp.w	r8, #0
 1002c4a:	f000 80a1 	beq.w	1002d90 <ull_master_setup+0x210>
				      lll->access_addr[2];

			lll->data_chan_sel = 1;
			lll->data_chan_id = aa_ms ^ aa_ls;

			cs->csa = 0x01;
 1002c4e:	f04f 0c01 	mov.w	ip, #1
			u16_t aa_ls = ((u16_t)lll->access_addr[1] << 8) |
 1002c52:	7a6a      	ldrb	r2, [r5, #9]
				      lll->access_addr[0];
 1002c54:	7a2b      	ldrb	r3, [r5, #8]
			u16_t aa_ms = ((u16_t)lll->access_addr[3] << 8) |
 1002c56:	f895 e00b 	ldrb.w	lr, [r5, #11]
				      lll->access_addr[2];
 1002c5a:	7aa9      	ldrb	r1, [r5, #10]
			u16_t aa_ls = ((u16_t)lll->access_addr[1] << 8) |
 1002c5c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			lll->data_chan_sel = 1;
 1002c60:	f895 2021 	ldrb.w	r2, [r5, #33]	; 0x21
			u16_t aa_ms = ((u16_t)lll->access_addr[3] << 8) |
 1002c64:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
			lll->data_chan_id = aa_ms ^ aa_ls;
 1002c68:	404b      	eors	r3, r1
			lll->data_chan_sel = 1;
 1002c6a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
			lll->data_chan_id = aa_ms ^ aa_ls;
 1002c6e:	846b      	strh	r3, [r5, #34]	; 0x22
			lll->data_chan_sel = 1;
 1002c70:	f885 2021 	strb.w	r2, [r5, #33]	; 0x21
			cs->csa = 0x01;
 1002c74:	f884 c020 	strb.w	ip, [r4, #32]
		} else {
			cs->csa = 0x00;
		}
	}

	ll_rx_put(link, rx);
 1002c78:	4621      	mov	r1, r4
 1002c7a:	f007 fa7f 	bl	100a17c <ll_rx_put>
	ll_rx_sched();

	/* TODO: active_to_start feature port */
	conn->evt.ticks_active_to_start = 0U;
 1002c7e:	2400      	movs	r4, #0
	ll_rx_sched();
 1002c80:	f007 fa86 	bl	100a190 <ll_rx_sched>
	conn->evt.ticks_xtal_to_start =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US);
	conn->evt.ticks_preempt_to_start =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_PREEMPT_MIN_US);
	conn->evt.ticks_slot =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 1002c84:	a352      	add	r3, pc, #328	; (adr r3, 1002dd0 <ull_master_setup+0x250>)
 1002c86:	e9d3 2300 	ldrd	r2, r3, [r3]
	conn->evt.ticks_xtal_to_start =
 1002c8a:	f04f 0c31 	mov.w	ip, #49	; 0x31
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 1002c8e:	f8d6 9010 	ldr.w	r9, [r6, #16]
 1002c92:	f8df b154 	ldr.w	fp, [pc, #340]	; 1002de8 <ull_master_setup+0x268>
 1002c96:	f209 4052 	addw	r0, r9, #1106	; 0x452
	conn->evt.ticks_xtal_to_start =
 1002c9a:	f8c7 c000 	str.w	ip, [r7]
	conn->evt.ticks_preempt_to_start =
 1002c9e:	e9c7 4401 	strd	r4, r4, [r7, #4]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 1002ca2:	fba0 010b 	umull	r0, r1, r0, fp
 1002ca6:	f7fd fa07 	bl	10000b8 <__aeabi_uldivmod>
		ticks_slot_overhead = ticks_slot_offset;
	} else {
		ticks_slot_overhead = 0U;
	}

	conn_interval_us = lll->interval * 1250;
 1002caa:	f240 48e2 	movw	r8, #1250	; 0x4e2
 1002cae:	f8b5 c012 	ldrh.w	ip, [r5, #18]
	conn_offset_us = ftr->us_radio_end;
 1002cb2:	68f3      	ldr	r3, [r6, #12]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 1002cb4:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	/* disable ticker job, in order to chain stop and start to avoid RTC
	 * being stopped if no tickers active.
	 */
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
 1002cb8:	4622      	mov	r2, r4
 1002cba:	2102      	movs	r1, #2
	conn->evt.ticks_slot =
 1002cbc:	60f8      	str	r0, [r7, #12]
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
 1002cbe:	2001      	movs	r0, #1
	conn_interval_us = lll->interval * 1250;
 1002cc0:	fb08 f80c 	mul.w	r8, r8, ip
	conn_offset_us -= EVENT_OVERHEAD_START_US;
 1002cc4:	f5a3 7587 	sub.w	r5, r3, #270	; 0x10e
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
 1002cc8:	f003 f8ca 	bl	1005e60 <mayfly_enable>
#endif

	/* Stop Scanner */
	ticker_id_scan = TICKER_ID_SCAN_BASE + ull_scan_handle_get(scan);
 1002ccc:	4650      	mov	r0, sl
 1002cce:	f008 f921 	bl	100af14 <ull_scan_handle_get>
 1002cd2:	1d02      	adds	r2, r0, #4
 1002cd4:	b2d2      	uxtb	r2, r2
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 1002cd6:	2101      	movs	r1, #1
 1002cd8:	4b3f      	ldr	r3, [pc, #252]	; (1002dd8 <ull_master_setup+0x258>)
				    TICKER_USER_ID_ULL_HIGH,
				    ticker_id_scan, ticker_op_stop_scan_cb,
				    (void *)(u32_t)ticker_id_scan);
 1002cda:	9200      	str	r2, [sp, #0]
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 1002cdc:	4620      	mov	r0, r4
 1002cde:	f004 fb25 	bl	100732c <ticker_stop>

	/* Scanner stop can expire while here in this ISR.
	 * Deferred attempt to stop can fail as it would have
	 * expired, hence ignore failure.
	 */
	ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
 1002ce2:	4623      	mov	r3, r4
 1002ce4:	2203      	movs	r2, #3
 1002ce6:	2101      	movs	r1, #1
 1002ce8:	4620      	mov	r0, r4
 1002cea:	9400      	str	r4, [sp, #0]
 1002cec:	f004 fb1e 	bl	100732c <ticker_stop>
		    TICKER_ID_SCAN_STOP, NULL, NULL);

	/* Start master */
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
 1002cf0:	4638      	mov	r0, r7
 1002cf2:	f008 fcdf 	bl	100b6b4 <ll_conn_handle_get>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1002cf6:	f44f 7119 	mov.w	r1, #612	; 0x264
 1002cfa:	4a38      	ldr	r2, [pc, #224]	; (1002ddc <ull_master_setup+0x25c>)
 1002cfc:	4b38      	ldr	r3, [pc, #224]	; (1002de0 <ull_master_setup+0x260>)
 1002cfe:	e9cd 2107 	strd	r2, r1, [sp, #28]
	conn_offset_us -= ftr->us_radio_rdy;
 1002d02:	eba5 0509 	sub.w	r5, r5, r9
				     TICKER_USER_ID_ULL_HIGH,
				     ticker_id_conn,
				     ftr->ticks_anchor - ticks_slot_offset,
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
 1002d06:	fb88 890b 	smull	r8, r9, r8, fp
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1002d0a:	9706      	str	r7, [sp, #24]
 1002d0c:	9305      	str	r3, [sp, #20]
 1002d0e:	68fb      	ldr	r3, [r7, #12]
 1002d10:	68b6      	ldr	r6, [r6, #8]
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
 1002d12:	1d47      	adds	r7, r0, #5
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1002d14:	9304      	str	r3, [sp, #16]
				     HAL_TICKER_REMAINDER(conn_interval_us),
 1002d16:	4640      	mov	r0, r8
 1002d18:	a32d      	add	r3, pc, #180	; (adr r3, 1002dd0 <ull_master_setup+0x250>)
 1002d1a:	e9d3 2300 	ldrd	r2, r3, [r3]
 1002d1e:	4649      	mov	r1, r9
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1002d20:	9403      	str	r4, [sp, #12]
				     HAL_TICKER_REMAINDER(conn_interval_us),
 1002d22:	f7fd f9c9 	bl	10000b8 <__aeabi_uldivmod>
 1002d26:	4610      	mov	r0, r2
 1002d28:	4619      	mov	r1, r3
 1002d2a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 1002d2e:	2300      	movs	r3, #0
 1002d30:	f7fd f9c2 	bl	10000b8 <__aeabi_uldivmod>
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
 1002d34:	a326      	add	r3, pc, #152	; (adr r3, 1002dd0 <ull_master_setup+0x250>)
 1002d36:	e9d3 2300 	ldrd	r2, r3, [r3]
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1002d3a:	f1a6 0a31 	sub.w	sl, r6, #49	; 0x31
				     HAL_TICKER_REMAINDER(conn_interval_us),
 1002d3e:	4606      	mov	r6, r0
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
 1002d40:	4649      	mov	r1, r9
 1002d42:	4640      	mov	r0, r8
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1002d44:	9602      	str	r6, [sp, #8]
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
 1002d46:	f7fd f9b7 	bl	10000b8 <__aeabi_uldivmod>
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
 1002d4a:	a321      	add	r3, pc, #132	; (adr r3, 1002dd0 <ull_master_setup+0x250>)
 1002d4c:	e9d3 2300 	ldrd	r2, r3, [r3]
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
 1002d50:	4606      	mov	r6, r0
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
 1002d52:	fba5 010b 	umull	r0, r1, r5, fp
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
 1002d56:	9601      	str	r6, [sp, #4]
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
 1002d58:	f7fd f9ae 	bl	10000b8 <__aeabi_uldivmod>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1002d5c:	b2ff      	uxtb	r7, r7
 1002d5e:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 1002d62:	4653      	mov	r3, sl
 1002d64:	9000      	str	r0, [sp, #0]
 1002d66:	463a      	mov	r2, r7
 1002d68:	4620      	mov	r0, r4
 1002d6a:	2101      	movs	r1, #1
 1002d6c:	f004 fa78 	bl	1007260 <ticker_start>
				     TICKER_NULL_LAZY,
				     (conn->evt.ticks_slot +
				      ticks_slot_overhead),
				     ull_master_ticker_cb, conn, ticker_op_cb,
				     (void *)__LINE__);
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 1002d70:	f030 0302 	bics.w	r3, r0, #2
 1002d74:	d004      	beq.n	1002d80 <ull_master_setup+0x200>
 1002d76:	f240 2165 	movw	r1, #613	; 0x265
 1002d7a:	481a      	ldr	r0, [pc, #104]	; (1002de4 <ull_master_setup+0x264>)
 1002d7c:	f000 fc80 	bl	1003680 <bt_ctlr_assert_handle>

#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	/* enable ticker job, irrespective of disabled in this function so
	 * first connection event can be scheduled as soon as possible.
	 */
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1);
 1002d80:	2201      	movs	r2, #1
 1002d82:	2102      	movs	r1, #2
 1002d84:	4610      	mov	r0, r2
 1002d86:	f003 f86b 	bl	1005e60 <mayfly_enable>
#endif
}
 1002d8a:	b00f      	add	sp, #60	; 0x3c
 1002d8c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			cs->csa = 0x00;
 1002d90:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
 1002d94:	f884 3020 	strb.w	r3, [r4, #32]
 1002d98:	e76e      	b.n	1002c78 <ull_master_setup+0xf8>
		memset(&cc->local_rpa[0], 0x0, BDADDR_SIZE);
 1002d9a:	f104 002f 	add.w	r0, r4, #47	; 0x2f
 1002d9e:	f013 fe66 	bl	1016a6e <memset>
	if (rl_idx != FILTER_IDX_NONE) {
 1002da2:	f1bb 0fff 	cmp.w	fp, #255	; 0xff
 1002da6:	f47f af21 	bne.w	1002bec <ull_master_setup+0x6c>
		memset(&cc->peer_rpa[0], 0x0, BDADDR_SIZE);
 1002daa:	2206      	movs	r2, #6
 1002dac:	2100      	movs	r1, #0
 1002dae:	f104 0029 	add.w	r0, r4, #41	; 0x29
 1002db2:	f013 fe5c 	bl	1016a6e <memset>
		cc->peer_addr_type = peer_addr_type;
 1002db6:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
		memcpy(cc->peer_addr, &peer_addr[0], BDADDR_SIZE);
 1002dba:	2206      	movs	r2, #6
		cc->peer_addr_type = peer_addr_type;
 1002dbc:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
		memcpy(cc->peer_addr, &peer_addr[0], BDADDR_SIZE);
 1002dc0:	a90c      	add	r1, sp, #48	; 0x30
 1002dc2:	f104 0023 	add.w	r0, r4, #35	; 0x23
 1002dc6:	f013 fe27 	bl	1016a18 <memcpy>
 1002dca:	e721      	b.n	1002c10 <ull_master_setup+0x90>
 1002dcc:	f3af 8000 	nop.w
 1002dd0:	1afd498d 	.word	0x1afd498d
 1002dd4:	00000007 	.word	0x00000007
 1002dd8:	0100e2ed 	.word	0x0100e2ed
 1002ddc:	0100e2f1 	.word	0x0100e2f1
 1002de0:	0100e305 	.word	0x0100e305
 1002de4:	010189ec 	.word	0x010189ec
 1002de8:	3b9aca00 	.word	0x3b9aca00
 1002dec:	00000000 	.word	0x00000000

01002df0 <isr_rx>:

	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
}

static void isr_rx(void *param)
{
 1002df0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1002df4:	b083      	sub	sp, #12
 1002df6:	4604      	mov	r4, r0
	if (IS_ENABLED(CONFIG_BT_CTLR_PROFILE_ISR)) {
		lll_prof_latency_capture();
	}

	/* Read radio status and events */
	trx_done = radio_is_done();
 1002df8:	f00f f8e4 	bl	1011fc4 <radio_is_done>
	if (trx_done) {
 1002dfc:	f010 0fff 	tst.w	r0, #255	; 0xff
 1002e00:	d112      	bne.n	1002e28 <isr_rx+0x38>
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready = 0U;
		devmatch_id = irkmatch_id = 0xFF;
	}

	/* Clear radio status and events */
	radio_status_reset();
 1002e02:	f00f f8c9 	bl	1011f98 <radio_status_reset>
	radio_tmr_status_reset();
 1002e06:	f00f f99f 	bl	1012148 <radio_tmr_status_reset>
	radio_filter_status_reset();
 1002e0a:	f00f f985 	bl	1012118 <radio_filter_status_reset>
	radio_ar_status_reset();
 1002e0e:	f00f fbd9 	bl	10125c4 <radio_ar_status_reset>
	radio_rssi_status_reset();
 1002e12:	f00f f949 	bl	10120a8 <radio_rssi_status_reset>
			return;
		}
	}

isr_rx_do_close:
	radio_isr_set(isr_done, lll);
 1002e16:	4621      	mov	r1, r4
 1002e18:	48cb      	ldr	r0, [pc, #812]	; (1003148 <isr_rx+0x358>)
 1002e1a:	f00e ffa9 	bl	1011d70 <radio_isr_set>
	radio_disable();
}
 1002e1e:	b003      	add	sp, #12
 1002e20:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	radio_disable();
 1002e24:	f00f b8a2 	b.w	1011f6c <radio_disable>
		crc_ok = radio_crc_is_valid();
 1002e28:	f00f f8ec 	bl	1012004 <radio_crc_is_valid>
 1002e2c:	fa5f f880 	uxtb.w	r8, r0
		devmatch_ok = radio_filter_has_match();
 1002e30:	f00f f97a 	bl	1012128 <radio_filter_has_match>
 1002e34:	b2c6      	uxtb	r6, r0
		devmatch_id = radio_filter_match_get();
 1002e36:	f00f f981 	bl	101213c <radio_filter_match_get>
 1002e3a:	4607      	mov	r7, r0
		irkmatch_ok = radio_ar_has_match();
 1002e3c:	f00f fbce 	bl	10125dc <radio_ar_has_match>
 1002e40:	b2c5      	uxtb	r5, r0
		irkmatch_id = radio_ar_match_get();
 1002e42:	f00f fbb9 	bl	10125b8 <radio_ar_match_get>
 1002e46:	4682      	mov	sl, r0
		rssi_ready = radio_rssi_is_ready();
 1002e48:	f00f f936 	bl	10120b8 <radio_rssi_is_ready>
 1002e4c:	4681      	mov	r9, r0
	radio_status_reset();
 1002e4e:	f00f f8a3 	bl	1011f98 <radio_status_reset>
	radio_tmr_status_reset();
 1002e52:	f00f f979 	bl	1012148 <radio_tmr_status_reset>
	radio_filter_status_reset();
 1002e56:	f00f f95f 	bl	1012118 <radio_filter_status_reset>
	radio_ar_status_reset();
 1002e5a:	f00f fbb3 	bl	10125c4 <radio_ar_status_reset>
	radio_rssi_status_reset();
 1002e5e:	f00f f923 	bl	10120a8 <radio_rssi_status_reset>
	rl_idx = devmatch_ok ?
 1002e62:	2e00      	cmp	r6, #0
 1002e64:	f040 80b1 	bne.w	1002fca <isr_rx+0x1da>
 1002e68:	2d00      	cmp	r5, #0
 1002e6a:	f040 80c0 	bne.w	1002fee <isr_rx+0x1fe>
 1002e6e:	27ff      	movs	r7, #255	; 0xff
	if (crc_ok && isr_rx_scan_check(lll, irkmatch_ok, devmatch_ok,
 1002e70:	f1b8 0f00 	cmp.w	r8, #0
 1002e74:	d0cf      	beq.n	1002e16 <isr_rx+0x26>

static inline bool isr_rx_scan_check(struct lll_scan *lll, u8_t irkmatch_ok,
				     u8_t devmatch_ok, u8_t rl_idx)
{
#if defined(CONFIG_BT_CTLR_PRIVACY)
	return (((lll->filter_policy & 0x01) == 0) &&
 1002e76:	7da3      	ldrb	r3, [r4, #22]
		 (!devmatch_ok || ull_filter_lll_rl_idx_allowed(irkmatch_ok,
								rl_idx))) ||
 1002e78:	0719      	lsls	r1, r3, #28
 1002e7a:	f100 80ae 	bmi.w	1002fda <isr_rx+0x1ea>
	return (((lll->filter_policy & 0x01) == 0) &&
 1002e7e:	2e00      	cmp	r6, #0
 1002e80:	f040 81f3 	bne.w	100326a <isr_rx+0x47a>
{
	struct node_rx_pdu *node_rx;
	struct pdu_adv *pdu_adv_rx;
	bool dir_report = false;

	node_rx = ull_pdu_rx_alloc_peek(1);
 1002e84:	2001      	movs	r0, #1
 1002e86:	f007 fa65 	bl	100a354 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
 1002e8a:	4680      	mov	r8, r0
 1002e8c:	2800      	cmp	r0, #0
 1002e8e:	f000 8203 	beq.w	1003298 <isr_rx+0x4a8>
	pdu_adv_rx = (void *)node_rx->pdu;

	if (0) {
#if defined(CONFIG_BT_CENTRAL)
	/* Initiator */
	} else if ((lll->conn) &&
 1002e92:	68a3      	ldr	r3, [r4, #8]
		rssi_ready = radio_rssi_is_ready();
 1002e94:	fa5f f689 	uxtb.w	r6, r9
	} else if ((lll->conn) &&
 1002e98:	2b00      	cmp	r3, #0
 1002e9a:	f000 80db 	beq.w	1003054 <isr_rx+0x264>
}

static inline bool isr_scan_init_check(struct lll_scan *lll,
				       struct pdu_adv *pdu, u8_t rl_idx)
{
	return ((((lll->filter_policy & 0x01) != 0U) ||
 1002e9e:	7da3      	ldrb	r3, [r4, #22]
		 isr_scan_init_adva_check(lll, pdu, rl_idx)) &&
 1002ea0:	071a      	lsls	r2, r3, #28
 1002ea2:	f140 81ee 	bpl.w	1003282 <isr_rx+0x492>
		(((pdu->type == PDU_ADV_TYPE_ADV_IND) &&
 1002ea6:	f898 0020 	ldrb.w	r0, [r8, #32]
		 isr_scan_init_adva_check(lll, pdu, rl_idx)) &&
 1002eaa:	f010 030f 	ands.w	r3, r0, #15
 1002eae:	f040 80a4 	bne.w	1002ffa <isr_rx+0x20a>
		(((pdu->type == PDU_ADV_TYPE_ADV_IND) &&
 1002eb2:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 1002eb6:	2b25      	cmp	r3, #37	; 0x25
 1002eb8:	f200 811c 	bhi.w	10030f4 <isr_rx+0x304>
			rx = ull_pdu_rx_alloc_peek(4);
 1002ebc:	2004      	movs	r0, #4
 1002ebe:	f007 fa49 	bl	100a354 <ull_pdu_rx_alloc_peek>
		if (!rx) {
 1002ec2:	2800      	cmp	r0, #0
 1002ec4:	d0a7      	beq.n	1002e16 <isr_rx+0x26>
		pdu_end_us = radio_tmr_end_get();
 1002ec6:	f00f fa89 	bl	10123dc <radio_tmr_end_get>
		if (!lll->ticks_window) {
 1002eca:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		pdu_end_us = radio_tmr_end_get();
 1002ecc:	4681      	mov	r9, r0
		if (!lll->ticks_window) {
 1002ece:	b943      	cbnz	r3, 1002ee2 <isr_rx+0xf2>
			scan_interval_us = lll->interval * 625U;
 1002ed0:	f240 2371 	movw	r3, #625	; 0x271
 1002ed4:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 1002ed6:	fb03 f302 	mul.w	r3, r3, r2
			pdu_end_us %= scan_interval_us;
 1002eda:	fbb0 f2f3 	udiv	r2, r0, r3
 1002ede:	fb03 0912 	mls	r9, r3, r2, r0
		if (pdu_end_us > (HAL_TICKER_TICKS_TO_US(evt->ticks_slot) -
 1002ee2:	f04f 0e07 	mov.w	lr, #7
 1002ee6:	6823      	ldr	r3, [r4, #0]
 1002ee8:	4898      	ldr	r0, [pc, #608]	; (100314c <isr_rx+0x35c>)
 1002eea:	f8d3 c00c 	ldr.w	ip, [r3, #12]
 1002eee:	a394      	add	r3, pc, #592	; (adr r3, 1003140 <isr_rx+0x350>)
 1002ef0:	e9d3 2300 	ldrd	r2, r3, [r3]
 1002ef4:	fbac 0100 	umull	r0, r1, ip, r0
 1002ef8:	fb0e 110c 	mla	r1, lr, ip, r1
 1002efc:	f7fd f8dc 	bl	10000b8 <__aeabi_uldivmod>
				  EVENT_IFS_US - 352 - EVENT_OVERHEAD_START_US -
 1002f00:	f2a0 3342 	subw	r3, r0, #834	; 0x342
		if (pdu_end_us > (HAL_TICKER_TICKS_TO_US(evt->ticks_slot) -
 1002f04:	454b      	cmp	r3, r9
 1002f06:	d386      	bcc.n	1002e16 <isr_rx+0x26>
		radio_switch_complete_and_disable();
 1002f08:	f00f f8a8 	bl	101205c <radio_switch_complete_and_disable>
		lll_conn = lll->conn;
 1002f0c:	f8d4 a008 	ldr.w	sl, [r4, #8]
		pdu_tx = (void *)radio_pkt_scratch_get();
 1002f10:	f00f f886 	bl	1012020 <radio_pkt_scratch_get>
 1002f14:	4683      	mov	fp, r0
		pdu_tx->len = sizeof(struct pdu_adv_connect_ind);
 1002f16:	2022      	movs	r0, #34	; 0x22
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
 1002f18:	f898 2020 	ldrb.w	r2, [r8, #32]
		pdu_tx->type = PDU_ADV_TYPE_CONNECT_IND;
 1002f1c:	f89b 1000 	ldrb.w	r1, [fp]
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
 1002f20:	f3c2 1280 	ubfx	r2, r2, #6, #1
		pdu_tx->type = PDU_ADV_TYPE_CONNECT_IND;
 1002f24:	01d2      	lsls	r2, r2, #7
 1002f26:	f001 0150 	and.w	r1, r1, #80	; 0x50
 1002f2a:	f042 0225 	orr.w	r2, r2, #37	; 0x25
 1002f2e:	430a      	orrs	r2, r1
 1002f30:	f88b 2000 	strb.w	r2, [fp]
		pdu_tx->len = sizeof(struct pdu_adv_connect_ind);
 1002f34:	f88b 0001 	strb.w	r0, [fp, #1]
		lrpa = ull_filter_lll_lrpa_get(rl_idx);
 1002f38:	4638      	mov	r0, r7
 1002f3a:	f00c fceb 	bl	100f914 <ull_filter_lll_lrpa_get>
		if (lll->rpa_gen && lrpa) {
 1002f3e:	7de2      	ldrb	r2, [r4, #23]
		lrpa = ull_filter_lll_lrpa_get(rl_idx);
 1002f40:	4603      	mov	r3, r0
		if (lll->rpa_gen && lrpa) {
 1002f42:	07d2      	lsls	r2, r2, #31
		lrpa = ull_filter_lll_lrpa_get(rl_idx);
 1002f44:	9000      	str	r0, [sp, #0]
			pdu_tx->tx_addr = 1;
 1002f46:	4658      	mov	r0, fp
		if (lll->rpa_gen && lrpa) {
 1002f48:	f140 8222 	bpl.w	1003390 <isr_rx+0x5a0>
 1002f4c:	2b00      	cmp	r3, #0
 1002f4e:	f000 821f 	beq.w	1003390 <isr_rx+0x5a0>
			pdu_tx->tx_addr = 1;
 1002f52:	f89b 1000 	ldrb.w	r1, [fp]
			memcpy(&pdu_tx->connect_ind.init_addr[0], lrpa->val,
 1002f56:	2206      	movs	r2, #6
			pdu_tx->tx_addr = 1;
 1002f58:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 1002f5c:	f800 1b02 	strb.w	r1, [r0], #2
			memcpy(&pdu_tx->connect_ind.init_addr[0], lrpa->val,
 1002f60:	4619      	mov	r1, r3
 1002f62:	f013 fd59 	bl	1016a18 <memcpy>
		memcpy(&pdu_tx->connect_ind.adv_addr[0],
 1002f66:	2206      	movs	r2, #6
 1002f68:	f108 0122 	add.w	r1, r8, #34	; 0x22
 1002f6c:	f10b 0008 	add.w	r0, fp, #8
 1002f70:	f013 fd52 	bl	1016a18 <memcpy>
		memcpy(&pdu_tx->connect_ind.access_addr[0],
 1002f74:	2204      	movs	r2, #4
 1002f76:	f10a 0108 	add.w	r1, sl, #8
 1002f7a:	f10b 000e 	add.w	r0, fp, #14
 1002f7e:	f013 fd4b 	bl	1016a18 <memcpy>
		memcpy(&pdu_tx->connect_ind.crc_init[0],
 1002f82:	2203      	movs	r2, #3
 1002f84:	f10a 010c 	add.w	r1, sl, #12
 1002f88:	f10b 0012 	add.w	r0, fp, #18
 1002f8c:	f013 fd44 	bl	1016a18 <memcpy>
		pdu_tx->connect_ind.win_size = 1;
 1002f90:	2201      	movs	r2, #1
		conn_interval_us = (u32_t)lll_conn->interval * 1250U;
 1002f92:	f8ba 3012 	ldrh.w	r3, [sl, #18]
		pdu_tx->connect_ind.win_size = 1;
 1002f96:	f88b 2015 	strb.w	r2, [fp, #21]
		conn_interval_us = (u32_t)lll_conn->interval * 1250U;
 1002f9a:	9301      	str	r3, [sp, #4]
		conn_offset_us = radio_tmr_end_get() + 502 + 1250;
 1002f9c:	f00f fa1e 	bl	10123dc <radio_tmr_end_get>
		    lll->conn_win_offset_us == 0U) {
 1002fa0:	f8d4 9010 	ldr.w	r9, [r4, #16]
		conn_offset_us = radio_tmr_end_get() + 502 + 1250;
 1002fa4:	f500 62db 	add.w	r2, r0, #1752	; 0x6d8
		if (!IS_ENABLED(CONFIG_BT_CTLR_SCHED_ADVANCED) ||
 1002fa8:	f1b9 0f00 	cmp.w	r9, #0
 1002fac:	f000 8201 	beq.w	10033b2 <isr_rx+0x5c2>
		conn_interval_us = (u32_t)lll_conn->interval * 1250U;
 1002fb0:	f240 41e2 	movw	r1, #1250	; 0x4e2
 1002fb4:	9b01      	ldr	r3, [sp, #4]
 1002fb6:	fb01 f103 	mul.w	r1, r1, r3
			while ((conn_space_us & ((u32_t)1 << 31)) ||
 1002fba:	f1b9 0f00 	cmp.w	r9, #0
 1002fbe:	db02      	blt.n	1002fc6 <isr_rx+0x1d6>
 1002fc0:	454a      	cmp	r2, r9
 1002fc2:	f240 80c5 	bls.w	1003150 <isr_rx+0x360>
				conn_space_us += conn_interval_us;
 1002fc6:	4489      	add	r9, r1
 1002fc8:	e7f7      	b.n	1002fba <isr_rx+0x1ca>
		 ull_filter_lll_rl_idx(!!(lll->filter_policy & 0x01),
 1002fca:	7da0      	ldrb	r0, [r4, #22]
 1002fcc:	b2f9      	uxtb	r1, r7
 1002fce:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 1002fd2:	f00c fcbd 	bl	100f950 <ull_filter_lll_rl_idx>
 1002fd6:	4607      	mov	r7, r0
 1002fd8:	e74a      	b.n	1002e70 <isr_rx+0x80>
		(((lll->filter_policy & 0x01) != 0) &&
 1002fda:	2e00      	cmp	r6, #0
 1002fdc:	f47f af52 	bne.w	1002e84 <isr_rx+0x94>
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(rl_idx)));
 1002fe0:	4638      	mov	r0, r7
 1002fe2:	f00c fd27 	bl	100fa34 <ull_filter_lll_irk_whitelisted>
 1002fe6:	2800      	cmp	r0, #0
 1002fe8:	f47f af4c 	bne.w	1002e84 <isr_rx+0x94>
 1002fec:	e713      	b.n	1002e16 <isr_rx+0x26>
		 irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
 1002fee:	fa5f f08a 	uxtb.w	r0, sl
 1002ff2:	f00c fced 	bl	100f9d0 <ull_filter_lll_rl_irk_idx>
 1002ff6:	4607      	mov	r7, r0
 1002ff8:	e73a      	b.n	1002e70 <isr_rx+0x80>
		  (pdu->len <= sizeof(struct pdu_adv_adv_ind))) ||
 1002ffa:	2b01      	cmp	r3, #1
 1002ffc:	d14e      	bne.n	100309c <isr_rx+0x2ac>
		 ((pdu->type == PDU_ADV_TYPE_DIRECT_IND) &&
 1002ffe:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 1003002:	2b0c      	cmp	r3, #12
 1003004:	f47f af07 	bne.w	1002e16 <isr_rx+0x26>
				       struct pdu_adv *pdu, u8_t rl_idx,
				       bool *dir_report)
{
#if defined(CONFIG_BT_CTLR_PRIVACY)
	if (ull_filter_lll_rl_addr_resolve(pdu->rx_addr,
					   pdu->direct_ind.tgt_addr, rl_idx)) {
 1003008:	f108 0928 	add.w	r9, r8, #40	; 0x28
	if (ull_filter_lll_rl_addr_resolve(pdu->rx_addr,
 100300c:	4649      	mov	r1, r9
 100300e:	463a      	mov	r2, r7
 1003010:	09c0      	lsrs	r0, r0, #7
 1003012:	f00c fda5 	bl	100fb60 <ull_filter_lll_rl_addr_resolve>
 1003016:	2800      	cmp	r0, #0
 1003018:	f47f af50 	bne.w	1002ebc <isr_rx+0xcc>
		return true;
	} else if (init && lll->rpa_gen &&
 100301c:	7de3      	ldrb	r3, [r4, #23]
 100301e:	07db      	lsls	r3, r3, #31
 1003020:	f100 81e3 	bmi.w	10033ea <isr_rx+0x5fa>
		 */
		return false;
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */

	return (((lll->init_addr_type == pdu->rx_addr) &&
 1003024:	7da3      	ldrb	r3, [r4, #22]
 1003026:	f898 0020 	ldrb.w	r0, [r8, #32]
		!memcmp(lll->init_addr, pdu->direct_ind.tgt_addr,
			BDADDR_SIZE))) ||
 100302a:	f3c3 1280 	ubfx	r2, r3, #6, #1
 100302e:	ebb2 1fd0 	cmp.w	r2, r0, lsr #7
 1003032:	f000 8206 	beq.w	1003442 <isr_rx+0x652>

static inline bool isr_scan_tgta_rpa_check(struct lll_scan *lll,
					   struct pdu_adv *pdu,
					   bool *dir_report)
{
	if (((lll->filter_policy & 0x02) != 0U) &&
 1003036:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 100303a:	0798      	lsls	r0, r3, #30
 100303c:	d50a      	bpl.n	1003054 <isr_rx+0x264>
 100303e:	f998 3020 	ldrsb.w	r3, [r8, #32]
 1003042:	2b00      	cmp	r3, #0
 1003044:	da06      	bge.n	1003054 <isr_rx+0x264>
	    (pdu->rx_addr != 0) &&
 1003046:	f898 302d 	ldrb.w	r3, [r8, #45]	; 0x2d
 100304a:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 100304e:	2b40      	cmp	r3, #64	; 0x40
 1003050:	f43f af34 	beq.w	1002ebc <isr_rx+0xcc>
 1003054:	f898 0020 	ldrb.w	r0, [r8, #32]
	} else if (((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
 1003058:	f010 030f 	ands.w	r3, r0, #15
 100305c:	d11e      	bne.n	100309c <isr_rx+0x2ac>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
 100305e:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 1003062:	2b25      	cmp	r3, #37	; 0x25
 1003064:	f63f aed7 	bhi.w	1002e16 <isr_rx+0x26>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind)) &&
 1003068:	f994 2016 	ldrsb.w	r2, [r4, #22]
 100306c:	2a00      	cmp	r2, #0
 100306e:	f2c0 811f 	blt.w	10032b0 <isr_rx+0x4c0>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
 1003072:	2b25      	cmp	r3, #37	; 0x25
	bool dir_report = false;
 1003074:	bf98      	it	ls
 1003076:	f04f 0900 	movls.w	r9, #0
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
 100307a:	d83b      	bhi.n	10030f4 <isr_rx+0x304>
		   isr_scan_rsp_adva_matches(pdu_adv_rx))) &&
 100307c:	2b00      	cmp	r3, #0
 100307e:	f43f aeca 	beq.w	1002e16 <isr_rx+0x26>
		 (pdu_adv_rx->len != 0) &&
 1003082:	68a3      	ldr	r3, [r4, #8]
 1003084:	2b00      	cmp	r3, #0
 1003086:	f47f aec6 	bne.w	1002e16 <isr_rx+0x26>
		err = isr_rx_scan_report(lll, rssi_ready,
 100308a:	2d00      	cmp	r5, #0
 100308c:	bf14      	ite	ne
 100308e:	4639      	movne	r1, r7
 1003090:	21ff      	moveq	r1, #255	; 0xff
 1003092:	464a      	mov	r2, r9
 1003094:	4630      	mov	r0, r6
 1003096:	f00d fef7 	bl	1010e88 <isr_rx_scan_report.isra.0>
		if (err) {
 100309a:	e6bc      	b.n	1002e16 <isr_rx+0x26>
	} else if (((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
 100309c:	2b06      	cmp	r3, #6
 100309e:	f000 8101 	beq.w	10032a4 <isr_rx+0x4b4>
	else if (((((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
 10030a2:	2b02      	cmp	r3, #2
 10030a4:	f000 815a 	beq.w	100335c <isr_rx+0x56c>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind))) ||
 10030a8:	2b01      	cmp	r3, #1
 10030aa:	d123      	bne.n	10030f4 <isr_rx+0x304>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_DIRECT_IND) &&
 10030ac:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 10030b0:	2b0c      	cmp	r3, #12
 10030b2:	f47f aeb0 	bne.w	1002e16 <isr_rx+0x26>
					   pdu->direct_ind.tgt_addr, rl_idx)) {
 10030b6:	f108 0a28 	add.w	sl, r8, #40	; 0x28
	if (ull_filter_lll_rl_addr_resolve(pdu->rx_addr,
 10030ba:	4651      	mov	r1, sl
 10030bc:	463a      	mov	r2, r7
 10030be:	09c0      	lsrs	r0, r0, #7
 10030c0:	f00c fd4e 	bl	100fb60 <ull_filter_lll_rl_addr_resolve>
 10030c4:	4681      	mov	r9, r0
 10030c6:	2800      	cmp	r0, #0
 10030c8:	f040 818a 	bne.w	10033e0 <isr_rx+0x5f0>
	return (((lll->init_addr_type == pdu->rx_addr) &&
 10030cc:	7da3      	ldrb	r3, [r4, #22]
 10030ce:	f898 0020 	ldrb.w	r0, [r8, #32]
			BDADDR_SIZE))) ||
 10030d2:	f3c3 1280 	ubfx	r2, r3, #6, #1
 10030d6:	ebb2 1fd0 	cmp.w	r2, r0, lsr #7
 10030da:	f000 818d 	beq.w	10033f8 <isr_rx+0x608>
	if (((lll->filter_policy & 0x02) != 0U) &&
 10030de:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 10030e2:	0798      	lsls	r0, r3, #30
 10030e4:	d504      	bpl.n	10030f0 <isr_rx+0x300>
 10030e6:	f998 3020 	ldrsb.w	r3, [r8, #32]
 10030ea:	2b00      	cmp	r3, #0
 10030ec:	f2c0 818f 	blt.w	100340e <isr_rx+0x61e>
 10030f0:	f898 0020 	ldrb.w	r0, [r8, #32]
					&dir_report))) ||
 10030f4:	f000 000f 	and.w	r0, r0, #15
 10030f8:	2804      	cmp	r0, #4
 10030fa:	f47f ae8c 	bne.w	1002e16 <isr_rx+0x26>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_RSP) &&
 10030fe:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 1003102:	2b25      	cmp	r3, #37	; 0x25
 1003104:	f63f ae87 	bhi.w	1002e16 <isr_rx+0x26>
		   (lll->state != 0U) &&
 1003108:	7da3      	ldrb	r3, [r4, #22]
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_scan_rsp)) &&
 100310a:	07da      	lsls	r2, r3, #31
 100310c:	f57f ae83 	bpl.w	1002e16 <isr_rx+0x26>
	return false;
}

static inline bool isr_scan_rsp_adva_matches(struct pdu_adv *srsp)
{
	struct pdu_adv *sreq = (void *)radio_pkt_scratch_get();
 1003110:	f00e ff86 	bl	1012020 <radio_pkt_scratch_get>

	return ((sreq->rx_addr == srsp->tx_addr) &&
 1003114:	f898 3020 	ldrb.w	r3, [r8, #32]
 1003118:	7802      	ldrb	r2, [r0, #0]
 100311a:	f3c3 1380 	ubfx	r3, r3, #6, #1
 100311e:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
 1003122:	f47f ae78 	bne.w	1002e16 <isr_rx+0x26>
		(memcmp(&sreq->scan_req.adv_addr[0],
 1003126:	2206      	movs	r2, #6
 1003128:	3008      	adds	r0, #8
 100312a:	f108 0122 	add.w	r1, r8, #34	; 0x22
 100312e:	f013 fc63 	bl	10169f8 <memcmp>
	return ((sreq->rx_addr == srsp->tx_addr) &&
 1003132:	4681      	mov	r9, r0
 1003134:	2800      	cmp	r0, #0
 1003136:	f47f ae6e 	bne.w	1002e16 <isr_rx+0x26>
 100313a:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 100313e:	e79d      	b.n	100307c <isr_rx+0x28c>
 1003140:	3b9aca00 	.word	0x3b9aca00
 1003144:	00000000 	.word	0x00000000
 1003148:	01010c15 	.word	0x01010c15
 100314c:	1afd498d 	.word	0x1afd498d
				sys_cpu_to_le16((conn_space_us -
 1003150:	49c4      	ldr	r1, [pc, #784]	; (1003464 <isr_rx+0x674>)
 1003152:	eba9 0202 	sub.w	r2, r9, r2
 1003156:	fba1 3202 	umull	r3, r2, r1, r2
			pdu_tx->connect_ind.win_size++;
 100315a:	f89b 1015 	ldrb.w	r1, [fp, #21]
			pdu_tx->connect_ind.win_offset =
 100315e:	f3c2 228f 	ubfx	r2, r2, #10, #16
			pdu_tx->connect_ind.win_size++;
 1003162:	3101      	adds	r1, #1
			pdu_tx->connect_ind.win_offset =
 1003164:	f8ab 2016 	strh.w	r2, [fp, #22]
			pdu_tx->connect_ind.win_size++;
 1003168:	f88b 1015 	strb.w	r1, [fp, #21]
		pdu_tx->connect_ind.interval =
 100316c:	f8ba 0012 	ldrh.w	r0, [sl, #18]
		pdu_tx->connect_ind.latency =
 1003170:	f8ba 1014 	ldrh.w	r1, [sl, #20]
		pdu_tx->connect_ind.timeout =
 1003174:	8aa2      	ldrh	r2, [r4, #20]
		pdu_tx->connect_ind.interval =
 1003176:	f8ab 0018 	strh.w	r0, [fp, #24]
		pdu_tx->connect_ind.latency =
 100317a:	f8ab 101a 	strh.w	r1, [fp, #26]
		pdu_tx->connect_ind.timeout =
 100317e:	f8ab 201c 	strh.w	r2, [fp, #28]
		memcpy(&pdu_tx->connect_ind.chan_map[0],
 1003182:	f10a 011c 	add.w	r1, sl, #28
 1003186:	2205      	movs	r2, #5
 1003188:	f10b 001e 	add.w	r0, fp, #30
 100318c:	f013 fc44 	bl	1016a18 <memcpy>
		pdu_tx->connect_ind.hop = lll_conn->data_chan_hop;
 1003190:	f89a 1022 	ldrb.w	r1, [sl, #34]	; 0x22
 1003194:	f89b 2023 	ldrb.w	r2, [fp, #35]	; 0x23
 1003198:	f361 0204 	bfi	r2, r1, #0, #5
 100319c:	f88b 2023 	strb.w	r2, [fp, #35]	; 0x23
		pdu_tx->connect_ind.sca = lll_conn_sca_local_get();
 10031a0:	f00d ff62 	bl	1011068 <lll_conn_sca_local_get>
 10031a4:	4601      	mov	r1, r0
 10031a6:	f89b 2023 	ldrb.w	r2, [fp, #35]	; 0x23
		radio_pkt_tx_set(pdu_tx);
 10031aa:	4658      	mov	r0, fp
		pdu_tx->connect_ind.sca = lll_conn_sca_local_get();
 10031ac:	f361 1247 	bfi	r2, r1, #5, #3
 10031b0:	f88b 2023 	strb.w	r2, [fp, #35]	; 0x23
		radio_pkt_tx_set(pdu_tx);
 10031b4:	f00e feac 	bl	1011f10 <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
 10031b8:	f00e fefa 	bl	1011fb0 <radio_is_ready>
 10031bc:	2800      	cmp	r0, #0
 10031be:	f040 8103 	bne.w	10033c8 <isr_rx+0x5d8>
		radio_isr_set(isr_cleanup, lll);
 10031c2:	4621      	mov	r1, r4
 10031c4:	48a8      	ldr	r0, [pc, #672]	; (1003468 <isr_rx+0x678>)
 10031c6:	f00e fdd3 	bl	1011d70 <radio_isr_set>
		if (rssi_ready) {
 10031ca:	2e00      	cmp	r6, #0
 10031cc:	f040 80f7 	bne.w	10033be <isr_rx+0x5ce>
}

static inline int lll_stop(void *lll)
{
	struct lll_hdr *hdr = lll;
	int ret = !!hdr->is_stop;
 10031d0:	7922      	ldrb	r2, [r4, #4]

	hdr->is_stop = 1U;
 10031d2:	f042 0101 	orr.w	r1, r2, #1
		LL_ASSERT(!ret);
 10031d6:	07d3      	lsls	r3, r2, #31
 10031d8:	7121      	strb	r1, [r4, #4]
 10031da:	f100 80fb 	bmi.w	10033d4 <isr_rx+0x5e4>
		rx = ull_pdu_rx_alloc();
 10031de:	f007 f8d7 	bl	100a390 <ull_pdu_rx_alloc>
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
 10031e2:	2108      	movs	r1, #8
		rx->hdr.handle = 0xffff;
 10031e4:	f64f 72ff 	movw	r2, #65535	; 0xffff
		rx = ull_pdu_rx_alloc();
 10031e8:	4606      	mov	r6, r0
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
 10031ea:	7101      	strb	r1, [r0, #4]
		u8_t pdu_adv_rx_chan_sel = pdu_adv_rx->chan_sel;
 10031ec:	f898 8020 	ldrb.w	r8, [r8, #32]
		memcpy(rx->pdu, pdu_tx, (offsetof(struct pdu_adv, connect_ind) +
 10031f0:	4659      	mov	r1, fp
		rx->hdr.handle = 0xffff;
 10031f2:	80c2      	strh	r2, [r0, #6]
		memcpy(rx->pdu, pdu_tx, (offsetof(struct pdu_adv, connect_ind) +
 10031f4:	2224      	movs	r2, #36	; 0x24
 10031f6:	3020      	adds	r0, #32
 10031f8:	f013 fc0e 	bl	1016a18 <memcpy>
		pdu_adv_rx->chan_sel = pdu_adv_rx_chan_sel;
 10031fc:	f896 3020 	ldrb.w	r3, [r6, #32]
		u8_t pdu_adv_rx_chan_sel = pdu_adv_rx->chan_sel;
 1003200:	f3c8 1840 	ubfx	r8, r8, #5, #1
		pdu_adv_rx->chan_sel = pdu_adv_rx_chan_sel;
 1003204:	f368 1345 	bfi	r3, r8, #5, #1
 1003208:	f886 3020 	strb.w	r3, [r6, #32]
		ftr->param = lll;
 100320c:	60b4      	str	r4, [r6, #8]
		ftr->ticks_anchor = radio_tmr_start_get();
 100320e:	f00f f85f 	bl	10122d0 <radio_tmr_start_get>
				    radio_tx_chain_delay_get(0, 0);
 1003212:	2100      	movs	r1, #0
		ftr->ticks_anchor = radio_tmr_start_get();
 1003214:	6130      	str	r0, [r6, #16]
				    radio_tx_chain_delay_get(0, 0);
 1003216:	4608      	mov	r0, r1
 1003218:	f00e fe8a 	bl	1011f30 <radio_tx_chain_delay_get>
		ftr->us_radio_rdy = radio_tx_ready_delay_get(0, 0);
 100321c:	2100      	movs	r1, #0
		ftr->us_radio_end = conn_space_us -
 100321e:	eba9 0000 	sub.w	r0, r9, r0
 1003222:	6170      	str	r0, [r6, #20]
		ftr->us_radio_rdy = radio_tx_ready_delay_get(0, 0);
 1003224:	4608      	mov	r0, r1
 1003226:	f00e fe79 	bl	1011f1c <radio_tx_ready_delay_get>
		ftr->rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
 100322a:	2d00      	cmp	r5, #0
 100322c:	bf08      	it	eq
 100322e:	27ff      	moveq	r7, #255	; 0xff
 1003230:	77b7      	strb	r7, [r6, #30]
		ftr->lrpa_used = lll->rpa_gen && lrpa;
 1003232:	7de3      	ldrb	r3, [r4, #23]
		ftr->us_radio_rdy = radio_tx_ready_delay_get(0, 0);
 1003234:	61b0      	str	r0, [r6, #24]
		ftr->lrpa_used = lll->rpa_gen && lrpa;
 1003236:	f013 0301 	ands.w	r3, r3, #1
 100323a:	f000 80b8 	beq.w	10033ae <isr_rx+0x5be>
 100323e:	9b00      	ldr	r3, [sp, #0]
 1003240:	f1b3 0b00 	subs.w	fp, r3, #0
 1003244:	bf18      	it	ne
 1003246:	f04f 0b01 	movne.w	fp, #1
 100324a:	7f73      	ldrb	r3, [r6, #29]
 100324c:	f36b 0300 	bfi	r3, fp, #0, #1
 1003250:	7773      	strb	r3, [r6, #29]
			ftr->extra = ull_pdu_rx_alloc();
 1003252:	f007 f89d 	bl	100a390 <ull_pdu_rx_alloc>
		ull_rx_put(rx->hdr.link, rx);
 1003256:	4631      	mov	r1, r6
			ftr->extra = ull_pdu_rx_alloc();
 1003258:	60f0      	str	r0, [r6, #12]
		ull_rx_put(rx->hdr.link, rx);
 100325a:	6830      	ldr	r0, [r6, #0]
 100325c:	f007 f8b0 	bl	100a3c0 <ull_rx_put>
}
 1003260:	b003      	add	sp, #12
 1003262:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		ull_rx_sched();
 1003266:	f007 b8bb 	b.w	100a3e0 <ull_rx_sched>
		 (!devmatch_ok || ull_filter_lll_rl_idx_allowed(irkmatch_ok,
 100326a:	4639      	mov	r1, r7
 100326c:	4628      	mov	r0, r5
 100326e:	f00c fc11 	bl	100fa94 <ull_filter_lll_rl_idx_allowed>
 1003272:	2800      	cmp	r0, #0
 1003274:	f47f ae06 	bne.w	1002e84 <isr_rx+0x94>
		(((lll->filter_policy & 0x01) != 0) &&
 1003278:	7da3      	ldrb	r3, [r4, #22]
								rl_idx))) ||
 100327a:	071b      	lsls	r3, r3, #28
 100327c:	f57f adcb 	bpl.w	1002e16 <isr_rx+0x26>
 1003280:	e600      	b.n	1002e84 <isr_rx+0x94>
	if (rl_idx != FILTER_IDX_NONE) {
 1003282:	2fff      	cmp	r7, #255	; 0xff
 1003284:	d06d      	beq.n	1003362 <isr_rx+0x572>
		return (rl_idx == lll->rl_idx);
 1003286:	7e23      	ldrb	r3, [r4, #24]
 1003288:	1bdb      	subs	r3, r3, r7
 100328a:	fab3 f383 	clz	r3, r3
 100328e:	095b      	lsrs	r3, r3, #5
	return ((((lll->filter_policy & 0x01) != 0U) ||
 1003290:	2b00      	cmp	r3, #0
 1003292:	f47f ae08 	bne.w	1002ea6 <isr_rx+0xb6>
 1003296:	e6dd      	b.n	1003054 <isr_rx+0x264>
	LL_ASSERT(node_rx);
 1003298:	f240 21aa 	movw	r1, #682	; 0x2aa
 100329c:	4873      	ldr	r0, [pc, #460]	; (100346c <isr_rx+0x67c>)
 100329e:	f000 f9ef 	bl	1003680 <bt_ctlr_assert_handle>
 10032a2:	e5f6      	b.n	1002e92 <isr_rx+0xa2>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
 10032a4:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 10032a8:	2b25      	cmp	r3, #37	; 0x25
 10032aa:	f67f aedd 	bls.w	1003068 <isr_rx+0x278>
 10032ae:	e721      	b.n	10030f4 <isr_rx+0x304>
		   lll->type &&
 10032b0:	68a2      	ldr	r2, [r4, #8]
 10032b2:	2a00      	cmp	r2, #0
 10032b4:	f47f aedd 	bne.w	1003072 <isr_rx+0x282>
		radio_tmr_tifs_set(EVENT_IFS_US);
 10032b8:	2096      	movs	r0, #150	; 0x96
 10032ba:	f00e ff55 	bl	1012168 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
 10032be:	2000      	movs	r0, #0
 10032c0:	f00e feb2 	bl	1012028 <radio_switch_complete_and_rx>
		err = isr_rx_scan_report(lll, rssi_ready,
 10032c4:	2d00      	cmp	r5, #0
 10032c6:	bf14      	ite	ne
 10032c8:	4639      	movne	r1, r7
 10032ca:	21ff      	moveq	r1, #255	; 0xff
 10032cc:	4630      	mov	r0, r6
 10032ce:	2200      	movs	r2, #0
 10032d0:	f00d fdda 	bl	1010e88 <isr_rx_scan_report.isra.0>
		if (err) {
 10032d4:	2800      	cmp	r0, #0
 10032d6:	f47f ad9e 	bne.w	1002e16 <isr_rx+0x26>
		pdu_tx = (void *)radio_pkt_scratch_get();
 10032da:	f00e fea1 	bl	1012020 <radio_pkt_scratch_get>
		pdu_tx->len = sizeof(struct pdu_adv_scan_req);
 10032de:	210c      	movs	r1, #12
		pdu_tx = (void *)radio_pkt_scratch_get();
 10032e0:	4605      	mov	r5, r0
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
 10032e2:	f898 3020 	ldrb.w	r3, [r8, #32]
		pdu_tx->type = PDU_ADV_TYPE_SCAN_REQ;
 10032e6:	7802      	ldrb	r2, [r0, #0]
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
 10032e8:	f3c3 1380 	ubfx	r3, r3, #6, #1
		pdu_tx->type = PDU_ADV_TYPE_SCAN_REQ;
 10032ec:	01db      	lsls	r3, r3, #7
 10032ee:	f002 0270 	and.w	r2, r2, #112	; 0x70
 10032f2:	f043 0303 	orr.w	r3, r3, #3
 10032f6:	4313      	orrs	r3, r2
 10032f8:	702b      	strb	r3, [r5, #0]
		pdu_tx->len = sizeof(struct pdu_adv_scan_req);
 10032fa:	7069      	strb	r1, [r5, #1]
		lrpa = ull_filter_lll_lrpa_get(rl_idx);
 10032fc:	4638      	mov	r0, r7
 10032fe:	f00c fb09 	bl	100f914 <ull_filter_lll_lrpa_get>
		if (lll->rpa_gen && lrpa) {
 1003302:	7de3      	ldrb	r3, [r4, #23]
		lrpa = ull_filter_lll_lrpa_get(rl_idx);
 1003304:	4601      	mov	r1, r0
		if (lll->rpa_gen && lrpa) {
 1003306:	07de      	lsls	r6, r3, #31
			pdu_tx->tx_addr = 1;
 1003308:	4628      	mov	r0, r5
		if (lll->rpa_gen && lrpa) {
 100330a:	f140 808c 	bpl.w	1003426 <isr_rx+0x636>
 100330e:	2900      	cmp	r1, #0
 1003310:	f000 8089 	beq.w	1003426 <isr_rx+0x636>
			pdu_tx->tx_addr = 1;
 1003314:	782b      	ldrb	r3, [r5, #0]
			memcpy(&pdu_tx->scan_req.scan_addr[0], lrpa->val,
 1003316:	2206      	movs	r2, #6
			pdu_tx->tx_addr = 1;
 1003318:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 100331c:	f800 3b02 	strb.w	r3, [r0], #2
			memcpy(&pdu_tx->scan_req.scan_addr[0], lrpa->val,
 1003320:	f013 fb7a 	bl	1016a18 <memcpy>
		memcpy(&pdu_tx->scan_req.adv_addr[0],
 1003324:	2206      	movs	r2, #6
 1003326:	f108 0122 	add.w	r1, r8, #34	; 0x22
 100332a:	f105 0008 	add.w	r0, r5, #8
 100332e:	f013 fb73 	bl	1016a18 <memcpy>
		radio_pkt_tx_set(pdu_tx);
 1003332:	4628      	mov	r0, r5
 1003334:	f00e fdec 	bl	1011f10 <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
 1003338:	f00e fe3a 	bl	1011fb0 <radio_is_ready>
 100333c:	2800      	cmp	r0, #0
 100333e:	f040 808b 	bne.w	1003458 <isr_rx+0x668>
		radio_tmr_end_capture();
 1003342:	f00f f835 	bl	10123b0 <radio_tmr_end_capture>
		radio_isr_set(isr_tx, lll);
 1003346:	4621      	mov	r1, r4
		lll->state = 1U;
 1003348:	7da3      	ldrb	r3, [r4, #22]
		radio_isr_set(isr_tx, lll);
 100334a:	4849      	ldr	r0, [pc, #292]	; (1003470 <isr_rx+0x680>)
		lll->state = 1U;
 100334c:	f043 0301 	orr.w	r3, r3, #1
 1003350:	75a3      	strb	r3, [r4, #22]
}
 1003352:	b003      	add	sp, #12
 1003354:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		radio_isr_set(isr_tx, lll);
 1003358:	f00e bd0a 	b.w	1011d70 <radio_isr_set>
 100335c:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 1003360:	e687      	b.n	1003072 <isr_rx+0x282>
	return ((lll->adv_addr_type == pdu->tx_addr) &&
 1003362:	f898 0020 	ldrb.w	r0, [r8, #32]
 1003366:	f3c3 1340 	ubfx	r3, r3, #5, #1
 100336a:	f3c0 1280 	ubfx	r2, r0, #6, #1
 100336e:	4293      	cmp	r3, r2
 1003370:	f47f ae72 	bne.w	1003058 <isr_rx+0x268>
		!memcmp(lll->adv_addr, &pdu->adv_ind.addr[0], BDADDR_SIZE));
 1003374:	2206      	movs	r2, #6
 1003376:	f108 0122 	add.w	r1, r8, #34	; 0x22
 100337a:	f104 001f 	add.w	r0, r4, #31
 100337e:	f013 fb3b 	bl	10169f8 <memcmp>
	return ((lll->adv_addr_type == pdu->tx_addr) &&
 1003382:	fab0 f380 	clz	r3, r0
 1003386:	095b      	lsrs	r3, r3, #5
	return ((((lll->filter_policy & 0x01) != 0U) ||
 1003388:	2b00      	cmp	r3, #0
 100338a:	f47f ad8c 	bne.w	1002ea6 <isr_rx+0xb6>
 100338e:	e661      	b.n	1003054 <isr_rx+0x264>
			pdu_tx->tx_addr = lll->init_addr_type;
 1003390:	7da2      	ldrb	r2, [r4, #22]
 1003392:	f89b 1000 	ldrb.w	r1, [fp]
 1003396:	f3c2 1280 	ubfx	r2, r2, #6, #1
 100339a:	f362 1186 	bfi	r1, r2, #6, #1
 100339e:	f800 1b02 	strb.w	r1, [r0], #2
			memcpy(&pdu_tx->connect_ind.init_addr[0],
 10033a2:	2206      	movs	r2, #6
 10033a4:	f104 0119 	add.w	r1, r4, #25
 10033a8:	f013 fb36 	bl	1016a18 <memcpy>
 10033ac:	e5db      	b.n	1002f66 <isr_rx+0x176>
 10033ae:	469b      	mov	fp, r3
 10033b0:	e74b      	b.n	100324a <isr_rx+0x45a>
			pdu_tx->connect_ind.win_offset = sys_cpu_to_le16(0);
 10033b2:	f88b 9016 	strb.w	r9, [fp, #22]
 10033b6:	f88b 9017 	strb.w	r9, [fp, #23]
		conn_offset_us = radio_tmr_end_get() + 502 + 1250;
 10033ba:	4691      	mov	r9, r2
 10033bc:	e6d6      	b.n	100316c <isr_rx+0x37c>
			lll_conn->rssi_latest =  radio_rssi_get();
 10033be:	f00e fe6d 	bl	101209c <radio_rssi_get>
 10033c2:	f88a 00a5 	strb.w	r0, [sl, #165]	; 0xa5
 10033c6:	e703      	b.n	10031d0 <isr_rx+0x3e0>
		LL_ASSERT(!radio_is_ready());
 10033c8:	f240 3123 	movw	r1, #803	; 0x323
 10033cc:	4827      	ldr	r0, [pc, #156]	; (100346c <isr_rx+0x67c>)
 10033ce:	f000 f957 	bl	1003680 <bt_ctlr_assert_handle>
 10033d2:	e6f6      	b.n	10031c2 <isr_rx+0x3d2>
		LL_ASSERT(!ret);
 10033d4:	f240 3149 	movw	r1, #841	; 0x349
 10033d8:	4824      	ldr	r0, [pc, #144]	; (100346c <isr_rx+0x67c>)
 10033da:	f000 f951 	bl	1003680 <bt_ctlr_assert_handle>
 10033de:	e6fe      	b.n	10031de <isr_rx+0x3ee>
	bool dir_report = false;
 10033e0:	f04f 0900 	mov.w	r9, #0
 10033e4:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 10033e8:	e648      	b.n	100307c <isr_rx+0x28c>
		   ull_filter_lll_lrpa_get(rl_idx)) {
 10033ea:	4638      	mov	r0, r7
 10033ec:	f00c fa92 	bl	100f914 <ull_filter_lll_lrpa_get>
	} else if (init && lll->rpa_gen &&
 10033f0:	2800      	cmp	r0, #0
 10033f2:	f47f ae2f 	bne.w	1003054 <isr_rx+0x264>
 10033f6:	e615      	b.n	1003024 <isr_rx+0x234>
		!memcmp(lll->init_addr, pdu->direct_ind.tgt_addr,
 10033f8:	4651      	mov	r1, sl
 10033fa:	2206      	movs	r2, #6
 10033fc:	f104 0019 	add.w	r0, r4, #25
 1003400:	f013 fafa 	bl	10169f8 <memcmp>
	return (((lll->init_addr_type == pdu->rx_addr) &&
 1003404:	2800      	cmp	r0, #0
 1003406:	f43f ae98 	beq.w	100313a <isr_rx+0x34a>
 100340a:	7da3      	ldrb	r3, [r4, #22]
 100340c:	e667      	b.n	10030de <isr_rx+0x2ee>
	    (pdu->rx_addr != 0) &&
 100340e:	f898 302d 	ldrb.w	r3, [r8, #45]	; 0x2d
 1003412:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 1003416:	2b40      	cmp	r3, #64	; 0x40
 1003418:	f47f ae6a 	bne.w	10030f0 <isr_rx+0x300>
			*dir_report = true;
 100341c:	f04f 0901 	mov.w	r9, #1
 1003420:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 1003424:	e62a      	b.n	100307c <isr_rx+0x28c>
			pdu_tx->tx_addr = lll->init_addr_type;
 1003426:	7da3      	ldrb	r3, [r4, #22]
 1003428:	782a      	ldrb	r2, [r5, #0]
 100342a:	f3c3 1380 	ubfx	r3, r3, #6, #1
 100342e:	f363 1286 	bfi	r2, r3, #6, #1
 1003432:	f800 2b02 	strb.w	r2, [r0], #2
			memcpy(&pdu_tx->scan_req.scan_addr[0],
 1003436:	f104 0119 	add.w	r1, r4, #25
 100343a:	2206      	movs	r2, #6
 100343c:	f013 faec 	bl	1016a18 <memcpy>
 1003440:	e770      	b.n	1003324 <isr_rx+0x534>
		!memcmp(lll->init_addr, pdu->direct_ind.tgt_addr,
 1003442:	4649      	mov	r1, r9
 1003444:	2206      	movs	r2, #6
 1003446:	f104 0019 	add.w	r0, r4, #25
 100344a:	f013 fad5 	bl	10169f8 <memcmp>
	return (((lll->init_addr_type == pdu->rx_addr) &&
 100344e:	2800      	cmp	r0, #0
 1003450:	f43f ad34 	beq.w	1002ebc <isr_rx+0xcc>
 1003454:	7da3      	ldrb	r3, [r4, #22]
 1003456:	e5ee      	b.n	1003036 <isr_rx+0x246>
		LL_ASSERT(!radio_is_ready());
 1003458:	f240 31a5 	movw	r1, #933	; 0x3a5
 100345c:	4803      	ldr	r0, [pc, #12]	; (100346c <isr_rx+0x67c>)
 100345e:	f000 f90f 	bl	1003680 <bt_ctlr_assert_handle>
 1003462:	e76e      	b.n	1003342 <isr_rx+0x552>
 1003464:	d1b71759 	.word	0xd1b71759
 1003468:	01010ddd 	.word	0x01010ddd
 100346c:	01018b6c 	.word	0x01018b6c
 1003470:	01010c29 	.word	0x01010c29

01003474 <virtio_get_status>:
extern "C" {
#endif

static ALWAYS_INLINE u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
 1003474:	4b01      	ldr	r3, [pc, #4]	; (100347c <virtio_get_status+0x8>)
 1003476:	7818      	ldrb	r0, [r3, #0]
static struct k_work ipm_work;

static unsigned char virtio_get_status(struct virtio_device *vdev)
{
	return sys_read8(VDEV_STATUS_ADDR);
}
 1003478:	4770      	bx	lr
 100347a:	bf00      	nop
 100347c:	20070000 	.word	0x20070000

01003480 <virtio_set_status>:
}

static ALWAYS_INLINE void sys_write8(u8_t data, mem_addr_t addr)
{
	*(volatile u8_t *)addr = data;
 1003480:	4b01      	ldr	r3, [pc, #4]	; (1003488 <virtio_set_status+0x8>)
 1003482:	7019      	strb	r1, [r3, #0]
}

static void virtio_set_status(struct virtio_device *vdev, unsigned char status)
{
	sys_write8(status, VDEV_STATUS_ADDR);
}
 1003484:	4770      	bx	lr
 1003486:	bf00      	nop
 1003488:	20070000 	.word	0x20070000

0100348c <endpoint_cb>:
}
#endif /* CONFIG_BT_CTLR_ASSERT_HANDLER */

int endpoint_cb(struct rpmsg_endpoint *ept, void *data, size_t len, u32_t src,
		void *priv)
{
 100348c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 100348e:	4617      	mov	r7, r2
 1003490:	460e      	mov	r6, r1
 * @return Source ID.
 */
static inline u32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((u8_t *)data - (u8_t *)__log_const_start)/
 1003492:	4b33      	ldr	r3, [pc, #204]	; (1003560 <endpoint_cb+0xd4>)
 1003494:	4c33      	ldr	r4, [pc, #204]	; (1003564 <endpoint_cb+0xd8>)
	LOG_INF("Received message of %u bytes.", len);
 1003496:	4639      	mov	r1, r7
 1003498:	1ae4      	subs	r4, r4, r3
 100349a:	08e4      	lsrs	r4, r4, #3
 100349c:	01a4      	lsls	r4, r4, #6
 100349e:	f044 0203 	orr.w	r2, r4, #3
 10034a2:	4831      	ldr	r0, [pc, #196]	; (1003568 <endpoint_cb+0xdc>)
 10034a4:	f012 f830 	bl	1015508 <log_1>
	pkt_indicator = *data++;
 10034a8:	4633      	mov	r3, r6
 10034aa:	f813 1b01 	ldrb.w	r1, [r3], #1
	remaining -= sizeof(pkt_indicator);
 10034ae:	1e7a      	subs	r2, r7, #1
	switch (pkt_indicator) {
 10034b0:	2901      	cmp	r1, #1
 10034b2:	d007      	beq.n	10034c4 <endpoint_cb+0x38>
 10034b4:	2902      	cmp	r1, #2
 10034b6:	d034      	beq.n	1003522 <endpoint_cb+0x96>
		LOG_ERR("Unknown HCI type %u", pkt_indicator);
 10034b8:	482c      	ldr	r0, [pc, #176]	; (100356c <endpoint_cb+0xe0>)
 10034ba:	f044 0201 	orr.w	r2, r4, #1
 10034be:	f012 f823 	bl	1015508 <log_1>
 10034c2:	e006      	b.n	10034d2 <endpoint_cb+0x46>
	if (remaining < sizeof(*hdr)) {
 10034c4:	2a02      	cmp	r2, #2
 10034c6:	d807      	bhi.n	10034d8 <endpoint_cb+0x4c>
		LOG_ERR("Not enought data for command header");
 10034c8:	4829      	ldr	r0, [pc, #164]	; (1003570 <endpoint_cb+0xe4>)
 10034ca:	f044 0101 	orr.w	r1, r4, #1
		LOG_ERR("No available command buffers!");
 10034ce:	f012 f80e 	bl	10154ee <log_0>
	hci_rpmsg_rx((u8_t *) data, len);

	return RPMSG_SUCCESS;
}
 10034d2:	2000      	movs	r0, #0
 10034d4:	b003      	add	sp, #12
 10034d6:	bdf0      	pop	{r4, r5, r6, r7, pc}
	buf = bt_buf_get_tx(BT_BUF_CMD, K_NO_WAIT, hdr, sizeof(*hdr));
 10034d8:	2203      	movs	r2, #3
 10034da:	2000      	movs	r0, #0
 10034dc:	e9cd 3200 	strd	r3, r2, [sp]
 10034e0:	2200      	movs	r2, #0
 10034e2:	2300      	movs	r3, #0
 10034e4:	f002 f9fe 	bl	10058e4 <bt_buf_get_tx>
	if (buf) {
 10034e8:	4605      	mov	r5, r0
 10034ea:	b160      	cbz	r0, 1003506 <endpoint_cb+0x7a>
	if (remaining != hdr->param_len) {
 10034ec:	78f3      	ldrb	r3, [r6, #3]
		remaining -= sizeof(*hdr);
 10034ee:	1f3a      	subs	r2, r7, #4
	if (remaining != hdr->param_len) {
 10034f0:	429a      	cmp	r2, r3
 10034f2:	d00c      	beq.n	100350e <endpoint_cb+0x82>
		LOG_ERR("Command payload length is not correct");
 10034f4:	481f      	ldr	r0, [pc, #124]	; (1003574 <endpoint_cb+0xe8>)
 10034f6:	f044 0101 	orr.w	r1, r4, #1
		LOG_ERR("ACL payload length is not correct");
 10034fa:	f011 fff8 	bl	10154ee <log_0>
		net_buf_unref(buf);
 10034fe:	4628      	mov	r0, r5
 1003500:	f00f fad4 	bl	1012aac <net_buf_unref>
	if (buf) {
 1003504:	e7e5      	b.n	10034d2 <endpoint_cb+0x46>
		LOG_ERR("No available command buffers!");
 1003506:	481c      	ldr	r0, [pc, #112]	; (1003578 <endpoint_cb+0xec>)
 1003508:	f044 0101 	orr.w	r1, r4, #1
 100350c:	e7df      	b.n	10034ce <endpoint_cb+0x42>
	net_buf_add_mem(buf, data, remaining);
 100350e:	1d31      	adds	r1, r6, #4
	net_buf_add_mem(buf, data, remaining);
 1003510:	f105 0008 	add.w	r0, r5, #8
 1003514:	f013 fb94 	bl	1016c40 <net_buf_simple_add_mem>
		net_buf_put(&tx_queue, buf);
 1003518:	4629      	mov	r1, r5
 100351a:	4818      	ldr	r0, [pc, #96]	; (100357c <endpoint_cb+0xf0>)
 100351c:	f013 fb7d 	bl	1016c1a <net_buf_put>
	return RPMSG_SUCCESS;
 1003520:	e7d7      	b.n	10034d2 <endpoint_cb+0x46>
	if (remaining < sizeof(*hdr)) {
 1003522:	2a03      	cmp	r2, #3
 1003524:	d803      	bhi.n	100352e <endpoint_cb+0xa2>
		LOG_ERR("Not enought data for ACL header");
 1003526:	4816      	ldr	r0, [pc, #88]	; (1003580 <endpoint_cb+0xf4>)
 1003528:	f044 0101 	orr.w	r1, r4, #1
 100352c:	e7cf      	b.n	10034ce <endpoint_cb+0x42>
	buf = bt_buf_get_tx(BT_BUF_ACL_OUT, K_NO_WAIT, hdr, sizeof(*hdr));
 100352e:	2204      	movs	r2, #4
 1003530:	4608      	mov	r0, r1
 1003532:	e9cd 3200 	strd	r3, r2, [sp]
 1003536:	2200      	movs	r2, #0
 1003538:	2300      	movs	r3, #0
 100353a:	f002 f9d3 	bl	10058e4 <bt_buf_get_tx>
	if (buf) {
 100353e:	4605      	mov	r5, r0
 1003540:	b140      	cbz	r0, 1003554 <endpoint_cb+0xc8>
	if (remaining != sys_le16_to_cpu(hdr->len)) {
 1003542:	f8b6 3003 	ldrh.w	r3, [r6, #3]
		remaining -= sizeof(*hdr);
 1003546:	1f7a      	subs	r2, r7, #5
	if (remaining != sys_le16_to_cpu(hdr->len)) {
 1003548:	429a      	cmp	r2, r3
 100354a:	d007      	beq.n	100355c <endpoint_cb+0xd0>
		LOG_ERR("ACL payload length is not correct");
 100354c:	480d      	ldr	r0, [pc, #52]	; (1003584 <endpoint_cb+0xf8>)
 100354e:	f044 0101 	orr.w	r1, r4, #1
 1003552:	e7d2      	b.n	10034fa <endpoint_cb+0x6e>
		LOG_ERR("No available ACL buffers!");
 1003554:	480c      	ldr	r0, [pc, #48]	; (1003588 <endpoint_cb+0xfc>)
 1003556:	f044 0101 	orr.w	r1, r4, #1
 100355a:	e7b8      	b.n	10034ce <endpoint_cb+0x42>
	net_buf_add_mem(buf, data, remaining);
 100355c:	1d71      	adds	r1, r6, #5
 100355e:	e7d7      	b.n	1003510 <endpoint_cb+0x84>
 1003560:	01018208 	.word	0x01018208
 1003564:	010182e8 	.word	0x010182e8
 1003568:	01018fa8 	.word	0x01018fa8
 100356c:	0101908a 	.word	0x0101908a
 1003570:	01018fc6 	.word	0x01018fc6
 1003574:	01019008 	.word	0x01019008
 1003578:	01018fea 	.word	0x01018fea
 100357c:	2100060c 	.word	0x2100060c
 1003580:	0101902e 	.word	0x0101902e
 1003584:	01019068 	.word	0x01019068
 1003588:	0101904e 	.word	0x0101904e

0100358c <tx_thread>:
{
 100358c:	b570      	push	{r4, r5, r6, lr}
 100358e:	4b0f      	ldr	r3, [pc, #60]	; (10035cc <tx_thread+0x40>)
 1003590:	4c0f      	ldr	r4, [pc, #60]	; (10035d0 <tx_thread+0x44>)
		buf = net_buf_get(&tx_queue, K_FOREVER);
 1003592:	4e10      	ldr	r6, [pc, #64]	; (10035d4 <tx_thread+0x48>)
 1003594:	1ae4      	subs	r4, r4, r3
 1003596:	08e4      	lsrs	r4, r4, #3
			LOG_ERR("Unable to send (err %d)", err);
 1003598:	01a4      	lsls	r4, r4, #6
 100359a:	f044 0401 	orr.w	r4, r4, #1
		buf = net_buf_get(&tx_queue, K_FOREVER);
 100359e:	f04f 32ff 	mov.w	r2, #4294967295
 10035a2:	f04f 33ff 	mov.w	r3, #4294967295
 10035a6:	4630      	mov	r0, r6
 10035a8:	f013 fb19 	bl	1016bde <net_buf_get>
 10035ac:	4605      	mov	r5, r0
		err = bt_send(buf);
 10035ae:	f013 fad9 	bl	1016b64 <bt_send>
		if (err) {
 10035b2:	4601      	mov	r1, r0
 10035b4:	b130      	cbz	r0, 10035c4 <tx_thread+0x38>
			LOG_ERR("Unable to send (err %d)", err);
 10035b6:	4808      	ldr	r0, [pc, #32]	; (10035d8 <tx_thread+0x4c>)
 10035b8:	4622      	mov	r2, r4
 10035ba:	f011 ffa5 	bl	1015508 <log_1>
			net_buf_unref(buf);
 10035be:	4628      	mov	r0, r5
 10035c0:	f00f fa74 	bl	1012aac <net_buf_unref>
		arch_syscall_invoke0(K_SYSCALL_K_YIELD);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_yield();
 10035c4:	f011 f87e 	bl	10146c4 <z_impl_k_yield>
	while (1) {
 10035c8:	e7e9      	b.n	100359e <tx_thread+0x12>
 10035ca:	bf00      	nop
 10035cc:	01018208 	.word	0x01018208
 10035d0:	010182e8 	.word	0x010182e8
 10035d4:	2100060c 	.word	0x2100060c
 10035d8:	0101909e 	.word	0x0101909e

010035dc <ipm_callback_process>:
	virtqueue_notification(vq[1]);
 10035dc:	4b01      	ldr	r3, [pc, #4]	; (10035e4 <ipm_callback_process+0x8>)
 10035de:	6858      	ldr	r0, [r3, #4]
 10035e0:	f013 bf0b 	b.w	10173fa <virtqueue_notification>
 10035e4:	210008bc 	.word	0x210008bc

010035e8 <virtio_notify>:
	status = ipm_send(ipm_tx_handle, 0, 0, NULL, 0);
 10035e8:	4b0d      	ldr	r3, [pc, #52]	; (1003620 <virtio_notify+0x38>)
{
 10035ea:	b513      	push	{r0, r1, r4, lr}
	status = ipm_send(ipm_tx_handle, 0, 0, NULL, 0);
 10035ec:	6818      	ldr	r0, [r3, #0]
			   const void *data, int size)
{
	const struct ipm_driver_api *api =
		(const struct ipm_driver_api *)ipmdev->driver_api;

	return api->send(ipmdev, wait, id, data, size);
 10035ee:	2300      	movs	r3, #0
 10035f0:	6882      	ldr	r2, [r0, #8]
 10035f2:	9300      	str	r3, [sp, #0]
 10035f4:	4619      	mov	r1, r3
 10035f6:	6814      	ldr	r4, [r2, #0]
 10035f8:	461a      	mov	r2, r3
 10035fa:	47a0      	blx	r4
	if (status != 0) {
 10035fc:	4601      	mov	r1, r0
 10035fe:	b160      	cbz	r0, 100361a <virtio_notify+0x32>
 1003600:	4b08      	ldr	r3, [pc, #32]	; (1003624 <virtio_notify+0x3c>)
 1003602:	4a09      	ldr	r2, [pc, #36]	; (1003628 <virtio_notify+0x40>)
		LOG_ERR("ipm_send failed to notify: %d", status);
 1003604:	4809      	ldr	r0, [pc, #36]	; (100362c <virtio_notify+0x44>)
 1003606:	1ad2      	subs	r2, r2, r3
 1003608:	08d2      	lsrs	r2, r2, #3
 100360a:	0192      	lsls	r2, r2, #6
 100360c:	f042 0201 	orr.w	r2, r2, #1
}
 1003610:	b002      	add	sp, #8
 1003612:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		LOG_ERR("ipm_send failed to notify: %d", status);
 1003616:	f011 bf77 	b.w	1015508 <log_1>
}
 100361a:	b002      	add	sp, #8
 100361c:	bd10      	pop	{r4, pc}
 100361e:	bf00      	nop
 1003620:	21000778 	.word	0x21000778
 1003624:	01018208 	.word	0x01018208
 1003628:	010182e8 	.word	0x010182e8
 100362c:	010190b6 	.word	0x010190b6

01003630 <ipm_callback>:
{
 1003630:	b508      	push	{r3, lr}
 1003632:	4a0e      	ldr	r2, [pc, #56]	; (100366c <ipm_callback+0x3c>)
 1003634:	4b0e      	ldr	r3, [pc, #56]	; (1003670 <ipm_callback+0x40>)
	LOG_INF("Got callback of id %u", id);
 1003636:	480f      	ldr	r0, [pc, #60]	; (1003674 <ipm_callback+0x44>)
 1003638:	1ad2      	subs	r2, r2, r3
 100363a:	08d2      	lsrs	r2, r2, #3
 100363c:	0192      	lsls	r2, r2, #6
 100363e:	f042 0203 	orr.w	r2, r2, #3
 1003642:	f011 ff61 	bl	1015508 <log_1>
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 1003646:	490c      	ldr	r1, [pc, #48]	; (1003678 <ipm_callback+0x48>)
 1003648:	e8d1 3fef 	ldaex	r3, [r1]
 100364c:	f043 0201 	orr.w	r2, r3, #1
 1003650:	e8c1 2fe0 	stlex	r0, r2, [r1]
 1003654:	2800      	cmp	r0, #0
 1003656:	d1f7      	bne.n	1003648 <ipm_callback+0x18>
 * @return N/A
 */
static inline void k_work_submit_to_queue(struct k_work_q *work_q,
					  struct k_work *work)
{
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
 1003658:	07db      	lsls	r3, r3, #31
 100365a:	d405      	bmi.n	1003668 <ipm_callback+0x38>
}
 100365c:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		k_queue_append(&work_q->queue, work);
 1003660:	4806      	ldr	r0, [pc, #24]	; (100367c <ipm_callback+0x4c>)
 1003662:	3908      	subs	r1, #8
 1003664:	f014 b96f 	b.w	1017946 <k_queue_append>
 1003668:	bd08      	pop	{r3, pc}
 100366a:	bf00      	nop
 100366c:	010182e8 	.word	0x010182e8
 1003670:	01018208 	.word	0x01018208
 1003674:	010190d4 	.word	0x010190d4
 1003678:	21000784 	.word	0x21000784
 100367c:	21007fc8 	.word	0x21007fc8

01003680 <bt_ctlr_assert_handle>:
{
 1003680:	460a      	mov	r2, r1
 1003682:	4b05      	ldr	r3, [pc, #20]	; (1003698 <bt_ctlr_assert_handle+0x18>)
 1003684:	4905      	ldr	r1, [pc, #20]	; (100369c <bt_ctlr_assert_handle+0x1c>)
 1003686:	1a5b      	subs	r3, r3, r1
 1003688:	08db      	lsrs	r3, r3, #3
	LOG_ERR("Controller assert in: %s at %d", file, line);
 100368a:	019b      	lsls	r3, r3, #6
 100368c:	4601      	mov	r1, r0
 100368e:	f043 0301 	orr.w	r3, r3, #1
 1003692:	4803      	ldr	r0, [pc, #12]	; (10036a0 <bt_ctlr_assert_handle+0x20>)
 1003694:	f011 bf4c 	b.w	1015530 <log_2>
 1003698:	010182e8 	.word	0x010182e8
 100369c:	01018208 	.word	0x01018208
 10036a0:	010190ea 	.word	0x010190ea

010036a4 <main>:

	return err;
}

void main(void)
{
 10036a4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct metal_init_params metal_params = METAL_INIT_DEFAULTS;
 10036a8:	4b86      	ldr	r3, [pc, #536]	; (10038c4 <main+0x220>)
{
 10036aa:	b08b      	sub	sp, #44	; 0x2c
	struct metal_init_params metal_params = METAL_INIT_DEFAULTS;
 10036ac:	9308      	str	r3, [sp, #32]
 10036ae:	2306      	movs	r3, #6
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
 10036b0:	2200      	movs	r2, #0
 10036b2:	4985      	ldr	r1, [pc, #532]	; (10038c8 <main+0x224>)
 10036b4:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 10036b8:	4b84      	ldr	r3, [pc, #528]	; (10038cc <main+0x228>)
	err = metal_init(&metal_params);
 10036ba:	a808      	add	r0, sp, #32
 10036bc:	e9c3 1201 	strd	r1, r2, [r3, #4]
 10036c0:	601a      	str	r2, [r3, #0]
 10036c2:	f010 f835 	bl	1013730 <metal_init>
	if (err) {
 10036c6:	4c82      	ldr	r4, [pc, #520]	; (10038d0 <main+0x22c>)
 10036c8:	4a82      	ldr	r2, [pc, #520]	; (10038d4 <main+0x230>)
 10036ca:	4601      	mov	r1, r0
 10036cc:	1b12      	subs	r2, r2, r4
 10036ce:	08d4      	lsrs	r4, r2, #3
 10036d0:	b130      	cbz	r0, 10036e0 <main+0x3c>
		LOG_ERR("metal_init: failed - error code %d", err);
 10036d2:	01a2      	lsls	r2, r4, #6
 10036d4:	4880      	ldr	r0, [pc, #512]	; (10038d8 <main+0x234>)
 10036d6:	f042 0201 	orr.w	r2, r2, #1
		LOG_ERR("rpmsg_create_ept failed %d", err);
 10036da:	f011 ff15 	bl	1015508 <log_1>
		return err;
 10036de:	e024      	b.n	100372a <main+0x86>
	err = metal_register_generic_device(&shm_device);
 10036e0:	487e      	ldr	r0, [pc, #504]	; (10038dc <main+0x238>)
 10036e2:	f010 f805 	bl	10136f0 <metal_register_generic_device>
	if (err) {
 10036e6:	4601      	mov	r1, r0
 10036e8:	b120      	cbz	r0, 10036f4 <main+0x50>
		LOG_ERR("Couldn't register shared memory device: %d", err);
 10036ea:	01a2      	lsls	r2, r4, #6
 10036ec:	487c      	ldr	r0, [pc, #496]	; (10038e0 <main+0x23c>)
 10036ee:	f042 0201 	orr.w	r2, r2, #1
 10036f2:	e7f2      	b.n	10036da <main+0x36>
	err = metal_device_open("generic", SHM_DEVICE_NAME, &device);
 10036f4:	4e7b      	ldr	r6, [pc, #492]	; (10038e4 <main+0x240>)
 10036f6:	497c      	ldr	r1, [pc, #496]	; (10038e8 <main+0x244>)
 10036f8:	4632      	mov	r2, r6
 10036fa:	487c      	ldr	r0, [pc, #496]	; (10038ec <main+0x248>)
 10036fc:	f013 fbf6 	bl	1016eec <metal_device_open>
	if (err) {
 1003700:	4605      	mov	r5, r0
 1003702:	b128      	cbz	r0, 1003710 <main+0x6c>
		LOG_ERR("metal_device_open failed: %d", err);
 1003704:	01a2      	lsls	r2, r4, #6
 1003706:	4601      	mov	r1, r0
 1003708:	f042 0201 	orr.w	r2, r2, #1
 100370c:	4878      	ldr	r0, [pc, #480]	; (10038f0 <main+0x24c>)
 100370e:	e7e4      	b.n	10036da <main+0x36>
	io = metal_device_io_region(device, 0);
 1003710:	6833      	ldr	r3, [r6, #0]
 * @return I/O accessor handle, or NULL on failure.
 */
static inline struct metal_io_region *
metal_device_io_region(struct metal_device *device, unsigned int index)
{
	return (index < device->num_regions
 1003712:	f8df 824c 	ldr.w	r8, [pc, #588]	; 1003960 <main+0x2bc>
		? &device->regions[index]
		: NULL);
 1003716:	689a      	ldr	r2, [r3, #8]
 1003718:	b952      	cbnz	r2, 1003730 <main+0x8c>
 100371a:	f8c8 2000 	str.w	r2, [r8]
		LOG_ERR("metal_device_io_region failed to get region");
 100371e:	01a1      	lsls	r1, r4, #6
 1003720:	4874      	ldr	r0, [pc, #464]	; (10038f4 <main+0x250>)
 1003722:	f041 0101 	orr.w	r1, r1, #1
		LOG_ERR("virtqueue_allocate failed to alloc vq[1]");
 1003726:	f011 fee2 	bl	10154ee <log_0>
		err = hci_rpmsg_send(buf);
		if (err) {
			LOG_ERR("Failed to send (err %d)", err);
		}
	}
}
 100372a:	b00b      	add	sp, #44	; 0x2c
 100372c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1003730:	330c      	adds	r3, #12
	io = metal_device_io_region(device, 0);
 1003732:	f8c8 3000 	str.w	r3, [r8]
	if (!io) {
 1003736:	2b00      	cmp	r3, #0
 1003738:	d0f1      	beq.n	100371e <main+0x7a>
	if (z_syscall_trap()) {
		return (struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
 100373a:	486f      	ldr	r0, [pc, #444]	; (10038f8 <main+0x254>)
 100373c:	f010 fae6 	bl	1013d0c <z_impl_device_get_binding>
	ipm_tx_handle = device_get_binding("IPM_1");
 1003740:	4b6e      	ldr	r3, [pc, #440]	; (10038fc <main+0x258>)
 1003742:	6018      	str	r0, [r3, #0]
	if (!ipm_tx_handle) {
 1003744:	b920      	cbnz	r0, 1003750 <main+0xac>
		LOG_ERR("Could not get TX IPM device handle");
 1003746:	01a1      	lsls	r1, r4, #6
 1003748:	486d      	ldr	r0, [pc, #436]	; (1003900 <main+0x25c>)
 100374a:	f041 0101 	orr.w	r1, r1, #1
 100374e:	e7ea      	b.n	1003726 <main+0x82>
 1003750:	486c      	ldr	r0, [pc, #432]	; (1003904 <main+0x260>)
 1003752:	f010 fadb 	bl	1013d0c <z_impl_device_get_binding>
	if (!ipm_rx_handle) {
 1003756:	b920      	cbnz	r0, 1003762 <main+0xbe>
		LOG_ERR("Could not get RX IPM device handle");
 1003758:	01a1      	lsls	r1, r4, #6
 100375a:	486b      	ldr	r0, [pc, #428]	; (1003908 <main+0x264>)
 100375c:	f041 0101 	orr.w	r1, r1, #1
 1003760:	e7e1      	b.n	1003726 <main+0x82>
					 ipm_callback_t cb, void *context)
{
	const struct ipm_driver_api *api =
		(const struct ipm_driver_api *)ipmdev->driver_api;

	api->register_callback(ipmdev, cb, context);
 1003762:	6883      	ldr	r3, [r0, #8]
 1003764:	462a      	mov	r2, r5
 1003766:	685b      	ldr	r3, [r3, #4]
 1003768:	4968      	ldr	r1, [pc, #416]	; (100390c <main+0x268>)
 100376a:	4798      	blx	r3
#endif

#if (CONFIG_HEAP_MEM_POOL_SIZE > 0)
static inline void *metal_allocate_memory(unsigned int size)
{
	return k_malloc(size);
 100376c:	20b4      	movs	r0, #180	; 0xb4
 100376e:	f010 fcc9 	bl	1014104 <k_malloc>
	struct virtqueue *vqs;
	uint32_t vq_size = sizeof(struct virtqueue) +
		 num_desc_extra * sizeof(struct vq_desc_extra);

	vqs = metal_allocate_memory(vq_size);
	if (vqs) {
 1003772:	4607      	mov	r7, r0
 1003774:	b118      	cbz	r0, 100377e <main+0xda>
		memset(vqs, 0x00, vq_size);
 1003776:	22b4      	movs	r2, #180	; 0xb4
 1003778:	4629      	mov	r1, r5
 100377a:	f013 f978 	bl	1016a6e <memset>
	vq[0] = virtqueue_allocate(VRING_SIZE);
 100377e:	4e64      	ldr	r6, [pc, #400]	; (1003910 <main+0x26c>)
 1003780:	6037      	str	r7, [r6, #0]
	if (!vq[0]) {
 1003782:	b927      	cbnz	r7, 100378e <main+0xea>
		LOG_ERR("virtqueue_allocate failed to alloc vq[0]");
 1003784:	01a1      	lsls	r1, r4, #6
 1003786:	4863      	ldr	r0, [pc, #396]	; (1003914 <main+0x270>)
 1003788:	f041 0101 	orr.w	r1, r1, #1
 100378c:	e7cb      	b.n	1003726 <main+0x82>
 100378e:	20b4      	movs	r0, #180	; 0xb4
 1003790:	f010 fcb8 	bl	1014104 <k_malloc>
	if (vqs) {
 1003794:	4605      	mov	r5, r0
 1003796:	b118      	cbz	r0, 10037a0 <main+0xfc>
		memset(vqs, 0x00, vq_size);
 1003798:	22b4      	movs	r2, #180	; 0xb4
 100379a:	2100      	movs	r1, #0
 100379c:	f013 f967 	bl	1016a6e <memset>
	vq[1] = virtqueue_allocate(VRING_SIZE);
 10037a0:	6075      	str	r5, [r6, #4]
	if (!vq[1]) {
 10037a2:	b925      	cbnz	r5, 10037ae <main+0x10a>
		LOG_ERR("virtqueue_allocate failed to alloc vq[1]");
 10037a4:	01a1      	lsls	r1, r4, #6
 10037a6:	485c      	ldr	r0, [pc, #368]	; (1003918 <main+0x274>)
 10037a8:	f041 0101 	orr.w	r1, r1, #1
 10037ac:	e7bb      	b.n	1003726 <main+0x82>
	rvrings[0].info.num_descs = VRING_SIZE;
 10037ae:	2010      	movs	r0, #16
	rvrings[0].io = io;
 10037b0:	4a5a      	ldr	r2, [pc, #360]	; (100391c <main+0x278>)
	rvrings[0].info.vaddr = (void *)VRING_TX_ADDRESS;
 10037b2:	495b      	ldr	r1, [pc, #364]	; (1003920 <main+0x27c>)
	rvrings[0].info.num_descs = VRING_SIZE;
 10037b4:	8190      	strh	r0, [r2, #12]
	rvrings[0].info.vaddr = (void *)VRING_TX_ADDRESS;
 10037b6:	6051      	str	r1, [r2, #4]
	rvrings[0].info.align = VRING_ALIGNMENT;
 10037b8:	2104      	movs	r1, #4
	rvrings[1].info.num_descs = VRING_SIZE;
 10037ba:	8490      	strh	r0, [r2, #36]	; 0x24
	vdev.role = RPMSG_REMOTE;
 10037bc:	2001      	movs	r0, #1
	rvrings[0].vq = vq[0];
 10037be:	6836      	ldr	r6, [r6, #0]
	rvrings[0].info.align = VRING_ALIGNMENT;
 10037c0:	6091      	str	r1, [r2, #8]
	rvrings[1].info.align = VRING_ALIGNMENT;
 10037c2:	6211      	str	r1, [r2, #32]
	vdev.role = RPMSG_REMOTE;
 10037c4:	4957      	ldr	r1, [pc, #348]	; (1003924 <main+0x280>)
	rvrings[0].io = io;
 10037c6:	f8d8 3000 	ldr.w	r3, [r8]
	rvrings[0].vq = vq[0];
 10037ca:	6016      	str	r6, [r2, #0]
	vdev.role = RPMSG_REMOTE;
 10037cc:	6188      	str	r0, [r1, #24]
	rvrings[1].info.vaddr = (void *)VRING_RX_ADDRESS;
 10037ce:	4e56      	ldr	r6, [pc, #344]	; (1003928 <main+0x284>)
	vdev.vrings_num = VRING_COUNT;
 10037d0:	2002      	movs	r0, #2
	vdev.vrings_info = &rvrings[0];
 10037d2:	62ca      	str	r2, [r1, #44]	; 0x2c
	rvrings[0].io = io;
 10037d4:	6153      	str	r3, [r2, #20]
	rvrings[1].io = io;
 10037d6:	62d3      	str	r3, [r2, #44]	; 0x2c
	rvrings[1].info.vaddr = (void *)VRING_RX_ADDRESS;
 10037d8:	61d6      	str	r6, [r2, #28]
	rvrings[1].vq = vq[1];
 10037da:	6195      	str	r5, [r2, #24]
	err = rpmsg_init_vdev(&rvdev, &vdev, NULL, io, NULL);
 10037dc:	2200      	movs	r2, #0
	vdev.vrings_num = VRING_COUNT;
 10037de:	6288      	str	r0, [r1, #40]	; 0x28
	vdev.func = &dispatch;
 10037e0:	4852      	ldr	r0, [pc, #328]	; (100392c <main+0x288>)
 10037e2:	6208      	str	r0, [r1, #32]
	err = rpmsg_init_vdev(&rvdev, &vdev, NULL, io, NULL);
 10037e4:	4852      	ldr	r0, [pc, #328]	; (1003930 <main+0x28c>)
 10037e6:	9200      	str	r2, [sp, #0]
 10037e8:	f010 f998 	bl	1013b1c <rpmsg_init_vdev>
	if (err) {
 10037ec:	4601      	mov	r1, r0
 10037ee:	b120      	cbz	r0, 10037fa <main+0x156>
		LOG_ERR("rpmsg_init_vdev failed %d", err);
 10037f0:	01a2      	lsls	r2, r4, #6
 10037f2:	4850      	ldr	r0, [pc, #320]	; (1003934 <main+0x290>)
 10037f4:	f042 0201 	orr.w	r2, r2, #1
 10037f8:	e76f      	b.n	10036da <main+0x36>
	err = rpmsg_create_ept(&ep, rdev, "bt_hci", RPMSG_ADDR_ANY,
 10037fa:	4b4f      	ldr	r3, [pc, #316]	; (1003938 <main+0x294>)
 10037fc:	4a4f      	ldr	r2, [pc, #316]	; (100393c <main+0x298>)
 10037fe:	9302      	str	r3, [sp, #8]
 1003800:	4b4f      	ldr	r3, [pc, #316]	; (1003940 <main+0x29c>)
 1003802:	494b      	ldr	r1, [pc, #300]	; (1003930 <main+0x28c>)
 1003804:	9301      	str	r3, [sp, #4]
 1003806:	f04f 33ff 	mov.w	r3, #4294967295
 100380a:	484e      	ldr	r0, [pc, #312]	; (1003944 <main+0x2a0>)
 100380c:	9300      	str	r3, [sp, #0]
 100380e:	f010 f853 	bl	10138b8 <rpmsg_create_ept>
	if (err) {
 1003812:	4605      	mov	r5, r0
 1003814:	2800      	cmp	r0, #0
 1003816:	d039      	beq.n	100388c <main+0x1e8>
		LOG_ERR("rpmsg_create_ept failed %d", err);
 1003818:	01a2      	lsls	r2, r4, #6
 100381a:	4601      	mov	r1, r0
 100381c:	f042 0201 	orr.w	r2, r2, #1
 1003820:	4849      	ldr	r0, [pc, #292]	; (1003948 <main+0x2a4>)
 1003822:	e75a      	b.n	10036da <main+0x36>
	switch (bt_buf_get_type(buf)) {
 1003824:	2104      	movs	r1, #4
	net_buf_push_u8(buf, pkt_indicator);
 1003826:	f105 0008 	add.w	r0, r5, #8
 100382a:	f013 fa12 	bl	1016c52 <net_buf_simple_push_u8>
 * Returns number of bytes it has sent or negative error value on failure.
 */
static inline int rpmsg_send(struct rpmsg_endpoint *ept, const void *data,
			     int len)
{
	if (ept->dest_addr == RPMSG_ADDR_ANY)
 100382e:	6aba      	ldr	r2, [r7, #40]	; 0x28
	rpmsg_send(&ep, buf->data, buf->len);
 1003830:	68ab      	ldr	r3, [r5, #8]
 1003832:	1c50      	adds	r0, r2, #1
 1003834:	89a9      	ldrh	r1, [r5, #12]
 1003836:	d006      	beq.n	1003846 <main+0x1a2>
		return RPMSG_ERR_ADDR;
	return rpmsg_send_offchannel_raw(ept, ept->addr, ept->dest_addr, data,
 1003838:	2001      	movs	r0, #1
 100383a:	e9cd 1000 	strd	r1, r0, [sp]
 100383e:	4638      	mov	r0, r7
 1003840:	6a79      	ldr	r1, [r7, #36]	; 0x24
 1003842:	f010 f827 	bl	1013894 <rpmsg_send_offchannel_raw>
	net_buf_unref(buf);
 1003846:	4628      	mov	r0, r5
 1003848:	f00f f930 	bl	1012aac <net_buf_unref>
		buf = net_buf_get(&rx_queue, K_FOREVER);
 100384c:	f04f 32ff 	mov.w	r2, #4294967295
 1003850:	f04f 33ff 	mov.w	r3, #4294967295
 1003854:	4648      	mov	r0, r9
 1003856:	f013 f9c2 	bl	1016bde <net_buf_get>
	 * pointer to an enum causes issues on qemu_x86 because the true
	 * size is 8-bit, but the enum is 32-bit on qemu_x86. So we put in
	 * a temporary cast to 8-bit to ensure only 8 bits are read from
	 * the pointer.
	 */
	return (enum bt_buf_type)(*(u8_t *)net_buf_user_data(buf));
 100385a:	7d01      	ldrb	r1, [r0, #20]
 100385c:	4605      	mov	r5, r0
	switch (bt_buf_get_type(buf)) {
 100385e:	2901      	cmp	r1, #1
 1003860:	d0e0      	beq.n	1003824 <main+0x180>
 1003862:	2903      	cmp	r1, #3
 1003864:	d010      	beq.n	1003888 <main+0x1e4>
		LOG_ERR("Unknown type %u", bt_buf_get_type(buf));
 1003866:	01a6      	lsls	r6, r4, #6
 1003868:	f046 0601 	orr.w	r6, r6, #1
 100386c:	4632      	mov	r2, r6
 100386e:	4640      	mov	r0, r8
 1003870:	f011 fe4a 	bl	1015508 <log_1>
		net_buf_unref(buf);
 1003874:	4628      	mov	r0, r5
 1003876:	f00f f919 	bl	1012aac <net_buf_unref>
			LOG_ERR("Failed to send (err %d)", err);
 100387a:	4632      	mov	r2, r6
 100387c:	f06f 0115 	mvn.w	r1, #21
 1003880:	4832      	ldr	r0, [pc, #200]	; (100394c <main+0x2a8>)
 1003882:	f011 fe41 	bl	1015508 <log_1>
 1003886:	e7e1      	b.n	100384c <main+0x1a8>
		pkt_indicator = HCI_RPMSG_ACL;
 1003888:	2102      	movs	r1, #2
 100388a:	e7cc      	b.n	1003826 <main+0x182>
	bt_enable_raw(&rx_queue);
 100388c:	4830      	ldr	r0, [pc, #192]	; (1003950 <main+0x2ac>)
 100388e:	f002 f86f 	bl	1005970 <bt_enable_raw>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 1003892:	2200      	movs	r2, #0
 1003894:	2300      	movs	r3, #0
 1003896:	e9cd 2306 	strd	r2, r3, [sp, #24]
 100389a:	f06f 0308 	mvn.w	r3, #8
 100389e:	f44f 6280 	mov.w	r2, #1024	; 0x400
 10038a2:	e9cd 5302 	strd	r5, r3, [sp, #8]
 10038a6:	e9cd 5500 	strd	r5, r5, [sp]
 10038aa:	4b2a      	ldr	r3, [pc, #168]	; (1003954 <main+0x2b0>)
 10038ac:	492a      	ldr	r1, [pc, #168]	; (1003958 <main+0x2b4>)
 10038ae:	482b      	ldr	r0, [pc, #172]	; (100395c <main+0x2b8>)
 10038b0:	9504      	str	r5, [sp, #16]
 10038b2:	f011 f807 	bl	10148c4 <z_impl_k_thread_create>
		buf = net_buf_get(&rx_queue, K_FOREVER);
 10038b6:	f8df 9098 	ldr.w	r9, [pc, #152]	; 1003950 <main+0x2ac>
	if (ept->dest_addr == RPMSG_ADDR_ANY)
 10038ba:	4f22      	ldr	r7, [pc, #136]	; (1003944 <main+0x2a0>)
		LOG_ERR("Unknown type %u", bt_buf_get_type(buf));
 10038bc:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 1003964 <main+0x2c0>
 10038c0:	e7c4      	b.n	100384c <main+0x1a8>
 10038c2:	bf00      	nop
 10038c4:	01013781 	.word	0x01013781
 10038c8:	010035dd 	.word	0x010035dd
 10038cc:	2100077c 	.word	0x2100077c
 10038d0:	01018208 	.word	0x01018208
 10038d4:	010182e8 	.word	0x010182e8
 10038d8:	01019109 	.word	0x01019109
 10038dc:	21000010 	.word	0x21000010
 10038e0:	0101912c 	.word	0x0101912c
 10038e4:	21000730 	.word	0x21000730
 10038e8:	01019157 	.word	0x01019157
 10038ec:	01019161 	.word	0x01019161
 10038f0:	01019169 	.word	0x01019169
 10038f4:	01019186 	.word	0x01019186
 10038f8:	0101998a 	.word	0x0101998a
 10038fc:	21000778 	.word	0x21000778
 1003900:	010191b2 	.word	0x010191b2
 1003904:	010191d5 	.word	0x010191d5
 1003908:	010191db 	.word	0x010191db
 100390c:	01003631 	.word	0x01003631
 1003910:	210008bc 	.word	0x210008bc
 1003914:	010191fe 	.word	0x010191fe
 1003918:	01019227 	.word	0x01019227
 100391c:	21000818 	.word	0x21000818
 1003920:	20077c00 	.word	0x20077c00
 1003924:	210006b8 	.word	0x210006b8
 1003928:	20077800 	.word	0x20077800
 100392c:	01018358 	.word	0x01018358
 1003930:	21000788 	.word	0x21000788
 1003934:	01019250 	.word	0x01019250
 1003938:	01014eed 	.word	0x01014eed
 100393c:	0101926a 	.word	0x0101926a
 1003940:	0100348d 	.word	0x0100348d
 1003944:	21000734 	.word	0x21000734
 1003948:	01019271 	.word	0x01019271
 100394c:	0101929c 	.word	0x0101929c
 1003950:	210005f4 	.word	0x210005f4
 1003954:	0100358d 	.word	0x0100358d
 1003958:	210080d8 	.word	0x210080d8
 100395c:	21000848 	.word	0x21000848
 1003960:	21000774 	.word	0x21000774
 1003964:	0101928c 	.word	0x0101928c

01003968 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
 1003968:	680b      	ldr	r3, [r1, #0]
 100396a:	3301      	adds	r3, #1
 100396c:	600b      	str	r3, [r1, #0]
	return _char_out(c);
 100396e:	4b01      	ldr	r3, [pc, #4]	; (1003974 <char_out+0xc>)
 1003970:	681b      	ldr	r3, [r3, #0]
 1003972:	4718      	bx	r3
 1003974:	21000068 	.word	0x21000068

01003978 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
 1003978:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100397c:	b085      	sub	sp, #20
 100397e:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 1003980:	469b      	mov	fp, r3
 1003982:	2c01      	cmp	r4, #1
 1003984:	bfb8      	it	lt
 1003986:	2401      	movlt	r4, #1
 1003988:	2b01      	cmp	r3, #1
 100398a:	bf0c      	ite	eq
 100398c:	2330      	moveq	r3, #48	; 0x30
 100398e:	2320      	movne	r3, #32
 1003990:	4615      	mov	r5, r2
 1003992:	4606      	mov	r6, r0
 1003994:	468a      	mov	sl, r1
 1003996:	2701      	movs	r7, #1
 1003998:	f04f 080a 	mov.w	r8, #10
 100399c:	2200      	movs	r2, #0
 100399e:	f8df 9070 	ldr.w	r9, [pc, #112]	; 1003a10 <_printk_dec_ulong+0x98>
 10039a2:	9302      	str	r3, [sp, #8]
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 10) {
		if (found_largest_digit != 0 || remainder >= pos) {
 10039a4:	fbb5 f3f9 	udiv	r3, r5, r9
 10039a8:	9301      	str	r3, [sp, #4]
 10039aa:	b90a      	cbnz	r2, 10039b0 <_printk_dec_ulong+0x38>
 10039ac:	45a9      	cmp	r9, r5
 10039ae:	d81e      	bhi.n	10039ee <_printk_dec_ulong+0x76>
			found_largest_digit = 1;
			out((int)(remainder / pos + 48), ctx);
 10039b0:	9b01      	ldr	r3, [sp, #4]
 10039b2:	4651      	mov	r1, sl
 10039b4:	f103 0030 	add.w	r0, r3, #48	; 0x30
 10039b8:	47b0      	blx	r6
			found_largest_digit = 1;
 10039ba:	2201      	movs	r2, #1
			digits++;
 10039bc:	3701      	adds	r7, #1
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
		remainder %= pos;
 10039be:	9b01      	ldr	r3, [sp, #4]
		remaining--;
 10039c0:	f108 38ff 	add.w	r8, r8, #4294967295
		remainder %= pos;
 10039c4:	fb09 5513 	mls	r5, r9, r3, r5
		pos /= 10;
 10039c8:	230a      	movs	r3, #10
	while (pos >= 10) {
 10039ca:	f1b8 0f01 	cmp.w	r8, #1
		pos /= 10;
 10039ce:	fbb9 f9f3 	udiv	r9, r9, r3
	while (pos >= 10) {
 10039d2:	d1e7      	bne.n	10039a4 <_printk_dec_ulong+0x2c>
	}
	out((int)(remainder + 48), ctx);
 10039d4:	4651      	mov	r1, sl
 10039d6:	f105 0030 	add.w	r0, r5, #48	; 0x30
 10039da:	47b0      	blx	r6

	if (padding == PAD_SPACE_AFTER) {
 10039dc:	f1bb 0f03 	cmp.w	fp, #3
 10039e0:	d102      	bne.n	10039e8 <_printk_dec_ulong+0x70>
		remaining = min_width - digits;
 10039e2:	1be4      	subs	r4, r4, r7
		while (remaining-- > 0) {
 10039e4:	2c00      	cmp	r4, #0
 10039e6:	dc0e      	bgt.n	1003a06 <_printk_dec_ulong+0x8e>
			out(' ', ctx);
		}
	}
}
 10039e8:	b005      	add	sp, #20
 10039ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (remaining <= min_width
 10039ee:	4544      	cmp	r4, r8
 10039f0:	dbe5      	blt.n	10039be <_printk_dec_ulong+0x46>
				&& padding < PAD_SPACE_AFTER) {
 10039f2:	f1bb 0f02 	cmp.w	fp, #2
 10039f6:	d8e2      	bhi.n	10039be <_printk_dec_ulong+0x46>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
 10039f8:	4651      	mov	r1, sl
 10039fa:	9802      	ldr	r0, [sp, #8]
 10039fc:	9203      	str	r2, [sp, #12]
			digits++;
 10039fe:	3701      	adds	r7, #1
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
 1003a00:	47b0      	blx	r6
			digits++;
 1003a02:	9a03      	ldr	r2, [sp, #12]
 1003a04:	e7db      	b.n	10039be <_printk_dec_ulong+0x46>
			out(' ', ctx);
 1003a06:	4651      	mov	r1, sl
 1003a08:	2020      	movs	r0, #32
 1003a0a:	47b0      	blx	r6
 1003a0c:	3c01      	subs	r4, #1
 1003a0e:	e7e9      	b.n	10039e4 <_printk_dec_ulong+0x6c>
 1003a10:	3b9aca00 	.word	0x3b9aca00

01003a14 <__printk_hook_install>:
	_char_out = fn;
 1003a14:	4b01      	ldr	r3, [pc, #4]	; (1003a1c <__printk_hook_install+0x8>)
 1003a16:	6018      	str	r0, [r3, #0]
}
 1003a18:	4770      	bx	lr
 1003a1a:	bf00      	nop
 1003a1c:	21000068 	.word	0x21000068

01003a20 <z_vprintk>:
{
 1003a20:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char length_mod = 0;
 1003a24:	2700      	movs	r7, #0
{
 1003a26:	4605      	mov	r5, r0
 1003a28:	468b      	mov	fp, r1
	int min_width = -1;
 1003a2a:	f04f 39ff 	mov.w	r9, #4294967295
	enum pad_type padding = PAD_NONE;
 1003a2e:	46b8      	mov	r8, r7
{
 1003a30:	461c      	mov	r4, r3
 1003a32:	b08d      	sub	sp, #52	; 0x34
 1003a34:	1e53      	subs	r3, r2, #1
 1003a36:	9303      	str	r3, [sp, #12]
			might_format = 0;
 1003a38:	2600      	movs	r6, #0
					break;
 1003a3a:	e005      	b.n	1003a48 <z_vprintk+0x28>
		if (!might_format) {
 1003a3c:	b96e      	cbnz	r6, 1003a5a <z_vprintk+0x3a>
			if (*fmt != '%') {
 1003a3e:	2825      	cmp	r0, #37	; 0x25
 1003a40:	f000 8171 	beq.w	1003d26 <z_vprintk+0x306>
				out((int)*fmt, ctx);
 1003a44:	4659      	mov	r1, fp
 1003a46:	47a8      	blx	r5
	while (*fmt) {
 1003a48:	9b03      	ldr	r3, [sp, #12]
 1003a4a:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 1003a4e:	9303      	str	r3, [sp, #12]
 1003a50:	2800      	cmp	r0, #0
 1003a52:	d1f3      	bne.n	1003a3c <z_vprintk+0x1c>
}
 1003a54:	b00d      	add	sp, #52	; 0x34
 1003a56:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			switch (*fmt) {
 1003a5a:	287a      	cmp	r0, #122	; 0x7a
 1003a5c:	d80a      	bhi.n	1003a74 <z_vprintk+0x54>
 1003a5e:	2862      	cmp	r0, #98	; 0x62
 1003a60:	d810      	bhi.n	1003a84 <z_vprintk+0x64>
 1003a62:	2830      	cmp	r0, #48	; 0x30
 1003a64:	d054      	beq.n	1003b10 <z_vprintk+0xf0>
 1003a66:	d845      	bhi.n	1003af4 <z_vprintk+0xd4>
 1003a68:	2825      	cmp	r0, #37	; 0x25
 1003a6a:	f000 815a 	beq.w	1003d22 <z_vprintk+0x302>
 1003a6e:	282d      	cmp	r0, #45	; 0x2d
 1003a70:	f000 815f 	beq.w	1003d32 <z_vprintk+0x312>
					out((int)'%', ctx);
 1003a74:	4659      	mov	r1, fp
 1003a76:	2025      	movs	r0, #37	; 0x25
 1003a78:	47a8      	blx	r5
					out((int)*fmt, ctx);
 1003a7a:	4659      	mov	r1, fp
 1003a7c:	9b03      	ldr	r3, [sp, #12]
 1003a7e:	7818      	ldrb	r0, [r3, #0]
 1003a80:	47a8      	blx	r5
 1003a82:	e7d9      	b.n	1003a38 <z_vprintk+0x18>
 1003a84:	f1a0 0363 	sub.w	r3, r0, #99	; 0x63
 1003a88:	2b17      	cmp	r3, #23
 1003a8a:	d8f3      	bhi.n	1003a74 <z_vprintk+0x54>
 1003a8c:	a201      	add	r2, pc, #4	; (adr r2, 1003a94 <z_vprintk+0x74>)
 1003a8e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 1003a92:	bf00      	nop
 1003a94:	01003d1b 	.word	0x01003d1b
 1003a98:	01003b5f 	.word	0x01003b5f
 1003a9c:	01003a75 	.word	0x01003a75
 1003aa0:	01003a75 	.word	0x01003a75
 1003aa4:	01003a75 	.word	0x01003a75
 1003aa8:	01003b41 	.word	0x01003b41
 1003aac:	01003b5f 	.word	0x01003b5f
 1003ab0:	01003a75 	.word	0x01003a75
 1003ab4:	01003a75 	.word	0x01003a75
 1003ab8:	01003b41 	.word	0x01003b41
 1003abc:	01003a75 	.word	0x01003a75
 1003ac0:	01003a75 	.word	0x01003a75
 1003ac4:	01003a75 	.word	0x01003a75
 1003ac8:	01003c01 	.word	0x01003c01
 1003acc:	01003a75 	.word	0x01003a75
 1003ad0:	01003a75 	.word	0x01003a75
 1003ad4:	01003ceb 	.word	0x01003ceb
 1003ad8:	01003a75 	.word	0x01003a75
 1003adc:	01003bcf 	.word	0x01003bcf
 1003ae0:	01003a75 	.word	0x01003a75
 1003ae4:	01003a75 	.word	0x01003a75
 1003ae8:	01003afd 	.word	0x01003afd
 1003aec:	01003a75 	.word	0x01003a75
 1003af0:	01003b41 	.word	0x01003b41
			switch (*fmt) {
 1003af4:	2839      	cmp	r0, #57	; 0x39
 1003af6:	d91a      	bls.n	1003b2e <z_vprintk+0x10e>
 1003af8:	2858      	cmp	r0, #88	; 0x58
 1003afa:	d1bb      	bne.n	1003a74 <z_vprintk+0x54>
				if (*fmt == 'p') {
 1003afc:	9b03      	ldr	r3, [sp, #12]
 1003afe:	781b      	ldrb	r3, [r3, #0]
 1003b00:	2b70      	cmp	r3, #112	; 0x70
 1003b02:	f040 8088 	bne.w	1003c16 <z_vprintk+0x1f6>
					x = va_arg(ap, unsigned int);
 1003b06:	f854 3b04 	ldr.w	r3, [r4], #4
 1003b0a:	2200      	movs	r2, #0
 1003b0c:	9306      	str	r3, [sp, #24]
 1003b0e:	e090      	b.n	1003c32 <z_vprintk+0x212>
				if (min_width < 0 && padding == PAD_NONE) {
 1003b10:	f1b9 0f00 	cmp.w	r9, #0
 1003b14:	da0e      	bge.n	1003b34 <z_vprintk+0x114>
 1003b16:	f1b8 0f00 	cmp.w	r8, #0
 1003b1a:	f000 810d 	beq.w	1003d38 <z_vprintk+0x318>
					min_width = *fmt - '0';
 1003b1e:	f1a0 0930 	sub.w	r9, r0, #48	; 0x30
					padding = PAD_SPACE_BEFORE;
 1003b22:	f1b8 0f00 	cmp.w	r8, #0
 1003b26:	bf08      	it	eq
 1003b28:	f04f 0802 	moveq.w	r8, #2
 1003b2c:	e78c      	b.n	1003a48 <z_vprintk+0x28>
				if (min_width < 0) {
 1003b2e:	f1b9 0f00 	cmp.w	r9, #0
 1003b32:	dbf4      	blt.n	1003b1e <z_vprintk+0xfe>
					min_width = 10 * min_width + *fmt - '0';
 1003b34:	230a      	movs	r3, #10
 1003b36:	fb03 0909 	mla	r9, r3, r9, r0
 1003b3a:	f1a9 0930 	sub.w	r9, r9, #48	; 0x30
 1003b3e:	e7f0      	b.n	1003b22 <z_vprintk+0x102>
				if (*fmt == 'h' && length_mod == 'h') {
 1003b40:	2868      	cmp	r0, #104	; 0x68
 1003b42:	d103      	bne.n	1003b4c <z_vprintk+0x12c>
 1003b44:	2f68      	cmp	r7, #104	; 0x68
 1003b46:	d106      	bne.n	1003b56 <z_vprintk+0x136>
					length_mod = 'H';
 1003b48:	2748      	movs	r7, #72	; 0x48
 1003b4a:	e77d      	b.n	1003a48 <z_vprintk+0x28>
				} else if (*fmt == 'l' && length_mod == 'l') {
 1003b4c:	286c      	cmp	r0, #108	; 0x6c
 1003b4e:	d102      	bne.n	1003b56 <z_vprintk+0x136>
 1003b50:	2f6c      	cmp	r7, #108	; 0x6c
 1003b52:	f000 80f4 	beq.w	1003d3e <z_vprintk+0x31e>
				} else if (length_mod == 0) {
 1003b56:	2f00      	cmp	r7, #0
 1003b58:	d18c      	bne.n	1003a74 <z_vprintk+0x54>
 1003b5a:	4607      	mov	r7, r0
 1003b5c:	e774      	b.n	1003a48 <z_vprintk+0x28>
				if (length_mod == 'z') {
 1003b5e:	2f7a      	cmp	r7, #122	; 0x7a
 1003b60:	d102      	bne.n	1003b68 <z_vprintk+0x148>
					d = va_arg(ap, int);
 1003b62:	f854 6b04 	ldr.w	r6, [r4], #4
 1003b66:	e021      	b.n	1003bac <z_vprintk+0x18c>
				} else if (length_mod == 'l') {
 1003b68:	2f6c      	cmp	r7, #108	; 0x6c
 1003b6a:	d0fa      	beq.n	1003b62 <z_vprintk+0x142>
				} else if (length_mod == 'L') {
 1003b6c:	2f4c      	cmp	r7, #76	; 0x4c
 1003b6e:	d1f8      	bne.n	1003b62 <z_vprintk+0x142>
					long long lld = va_arg(ap, long long);
 1003b70:	3407      	adds	r4, #7
 1003b72:	f024 0407 	bic.w	r4, r4, #7
 1003b76:	e8f4 2302 	ldrd	r2, r3, [r4], #8
 1003b7a:	e9cd 2304 	strd	r2, r3, [sp, #16]
					if (lld > __LONG_MAX__ ||
 1003b7e:	9b04      	ldr	r3, [sp, #16]
 1003b80:	f04f 30ff 	mov.w	r0, #4294967295
 1003b84:	f113 4100 	adds.w	r1, r3, #2147483648	; 0x80000000
 1003b88:	9b05      	ldr	r3, [sp, #20]
 1003b8a:	9108      	str	r1, [sp, #32]
 1003b8c:	f143 0100 	adc.w	r1, r3, #0
 1003b90:	9109      	str	r1, [sp, #36]	; 0x24
 1003b92:	2100      	movs	r1, #0
 1003b94:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 1003b98:	4299      	cmp	r1, r3
 1003b9a:	bf08      	it	eq
 1003b9c:	4290      	cmpeq	r0, r2
 1003b9e:	d204      	bcs.n	1003baa <z_vprintk+0x18a>
						print_err(out, ctx);
 1003ba0:	4659      	mov	r1, fp
 1003ba2:	4628      	mov	r0, r5
 1003ba4:	f011 f9a6 	bl	1014ef4 <print_err>
						break;
 1003ba8:	e746      	b.n	1003a38 <z_vprintk+0x18>
					d = lld;
 1003baa:	9e04      	ldr	r6, [sp, #16]
				if (d < 0) {
 1003bac:	2e00      	cmp	r6, #0
 1003bae:	da05      	bge.n	1003bbc <z_vprintk+0x19c>
					out((int)'-', ctx);
 1003bb0:	4659      	mov	r1, fp
 1003bb2:	202d      	movs	r0, #45	; 0x2d
 1003bb4:	47a8      	blx	r5
					d = -d;
 1003bb6:	4276      	negs	r6, r6
					min_width--;
 1003bb8:	f109 39ff 	add.w	r9, r9, #4294967295
				_printk_dec_ulong(out, ctx, d, padding,
 1003bbc:	4643      	mov	r3, r8
 1003bbe:	4632      	mov	r2, r6
 1003bc0:	f8cd 9000 	str.w	r9, [sp]
				_printk_dec_ulong(out, ctx, u, padding,
 1003bc4:	4659      	mov	r1, fp
 1003bc6:	4628      	mov	r0, r5
 1003bc8:	f7ff fed6 	bl	1003978 <_printk_dec_ulong>
				break;
 1003bcc:	e734      	b.n	1003a38 <z_vprintk+0x18>
				if (length_mod == 'z') {
 1003bce:	2f7a      	cmp	r7, #122	; 0x7a
 1003bd0:	d102      	bne.n	1003bd8 <z_vprintk+0x1b8>
					u = va_arg(ap, unsigned int);
 1003bd2:	f854 2b04 	ldr.w	r2, [r4], #4
 1003bd6:	e00f      	b.n	1003bf8 <z_vprintk+0x1d8>
				} else if (length_mod == 'l') {
 1003bd8:	2f6c      	cmp	r7, #108	; 0x6c
 1003bda:	d0fa      	beq.n	1003bd2 <z_vprintk+0x1b2>
				} else if (length_mod == 'L') {
 1003bdc:	2f4c      	cmp	r7, #76	; 0x4c
 1003bde:	d1f8      	bne.n	1003bd2 <z_vprintk+0x1b2>
					if (llu > ~0UL) {
 1003be0:	2100      	movs	r1, #0
 1003be2:	f04f 30ff 	mov.w	r0, #4294967295
					unsigned long long llu =
 1003be6:	3407      	adds	r4, #7
 1003be8:	f024 0407 	bic.w	r4, r4, #7
 1003bec:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (llu > ~0UL) {
 1003bf0:	4299      	cmp	r1, r3
 1003bf2:	bf08      	it	eq
 1003bf4:	4290      	cmpeq	r0, r2
 1003bf6:	d3d3      	bcc.n	1003ba0 <z_vprintk+0x180>
				_printk_dec_ulong(out, ctx, u, padding,
 1003bf8:	4643      	mov	r3, r8
 1003bfa:	f8cd 9000 	str.w	r9, [sp]
 1003bfe:	e7e1      	b.n	1003bc4 <z_vprintk+0x1a4>
				out('0', ctx);
 1003c00:	4659      	mov	r1, fp
 1003c02:	2030      	movs	r0, #48	; 0x30
 1003c04:	47a8      	blx	r5
				out('x', ctx);
 1003c06:	4659      	mov	r1, fp
 1003c08:	2078      	movs	r0, #120	; 0x78
 1003c0a:	47a8      	blx	r5
					min_width = 8;
 1003c0c:	f04f 0908 	mov.w	r9, #8
				padding = PAD_ZERO_BEFORE;
 1003c10:	f04f 0801 	mov.w	r8, #1
 1003c14:	e772      	b.n	1003afc <z_vprintk+0xdc>
				} else if (length_mod == 'l') {
 1003c16:	2f6c      	cmp	r7, #108	; 0x6c
 1003c18:	f43f af75 	beq.w	1003b06 <z_vprintk+0xe6>
				} else if (length_mod == 'L') {
 1003c1c:	2f4c      	cmp	r7, #76	; 0x4c
 1003c1e:	f47f af72 	bne.w	1003b06 <z_vprintk+0xe6>
					x = va_arg(ap, unsigned long long);
 1003c22:	1de3      	adds	r3, r4, #7
 1003c24:	f023 0307 	bic.w	r3, r3, #7
 1003c28:	461c      	mov	r4, r3
 1003c2a:	f854 2b08 	ldr.w	r2, [r4], #8
 1003c2e:	9206      	str	r2, [sp, #24]
 1003c30:	685a      	ldr	r2, [r3, #4]
	int digits = 0;
 1003c32:	2100      	movs	r1, #0
	int remaining = 16; /* 16 digits max */
 1003c34:	2310      	movs	r3, #16
	int shift = sizeof(num) * 8;
 1003c36:	f04f 0a40 	mov.w	sl, #64	; 0x40
	int digits = 0;
 1003c3a:	9104      	str	r1, [sp, #16]
	int found_largest_digit = 0;
 1003c3c:	9107      	str	r1, [sp, #28]
		shift -= 4;
 1003c3e:	f1aa 0a04 	sub.w	sl, sl, #4
		nibble = (num >> shift) & 0xf;
 1003c42:	9906      	ldr	r1, [sp, #24]
 1003c44:	f1ca 0e20 	rsb	lr, sl, #32
 1003c48:	f1aa 0c20 	sub.w	ip, sl, #32
 1003c4c:	fa21 f00a 	lsr.w	r0, r1, sl
 1003c50:	fa02 fe0e 	lsl.w	lr, r2, lr
 1003c54:	ea40 000e 	orr.w	r0, r0, lr
 1003c58:	fa22 fc0c 	lsr.w	ip, r2, ip
 1003c5c:	ea40 000c 	orr.w	r0, r0, ip
		if (nibble != 0 || found_largest_digit != 0 || shift == 0) {
 1003c60:	f010 000f 	ands.w	r0, r0, #15
 1003c64:	d107      	bne.n	1003c76 <z_vprintk+0x256>
 1003c66:	9907      	ldr	r1, [sp, #28]
 1003c68:	b911      	cbnz	r1, 1003c70 <z_vprintk+0x250>
 1003c6a:	f1ba 0f00 	cmp.w	sl, #0
 1003c6e:	d125      	bne.n	1003cbc <z_vprintk+0x29c>
			nibble += nibble > 9 ? 87 : 48;
 1003c70:	f04f 0c30 	mov.w	ip, #48	; 0x30
 1003c74:	e005      	b.n	1003c82 <z_vprintk+0x262>
 1003c76:	2809      	cmp	r0, #9
 1003c78:	bf8c      	ite	hi
 1003c7a:	f04f 0c57 	movhi.w	ip, #87	; 0x57
 1003c7e:	f04f 0c30 	movls.w	ip, #48	; 0x30
 1003c82:	4460      	add	r0, ip
			out((int)nibble, ctx);
 1003c84:	4659      	mov	r1, fp
 1003c86:	b240      	sxtb	r0, r0
 1003c88:	920a      	str	r2, [sp, #40]	; 0x28
 1003c8a:	9307      	str	r3, [sp, #28]
 1003c8c:	47a8      	blx	r5
			digits++;
 1003c8e:	9b04      	ldr	r3, [sp, #16]
	while (shift >= 4) {
 1003c90:	9a0a      	ldr	r2, [sp, #40]	; 0x28
			digits++;
 1003c92:	3301      	adds	r3, #1
 1003c94:	9304      	str	r3, [sp, #16]
	while (shift >= 4) {
 1003c96:	9b07      	ldr	r3, [sp, #28]
 1003c98:	f1ba 0f00 	cmp.w	sl, #0
 1003c9c:	d123      	bne.n	1003ce6 <z_vprintk+0x2c6>
	if (padding == PAD_SPACE_AFTER) {
 1003c9e:	f1b8 0f03 	cmp.w	r8, #3
 1003ca2:	f47f aec9 	bne.w	1003a38 <z_vprintk+0x18>
		remaining = min_width * 2 - digits;
 1003ca6:	9b04      	ldr	r3, [sp, #16]
 1003ca8:	ebc3 0649 	rsb	r6, r3, r9, lsl #1
		while (remaining-- > 0) {
 1003cac:	2e00      	cmp	r6, #0
 1003cae:	f77f aec3 	ble.w	1003a38 <z_vprintk+0x18>
			out(' ', ctx);
 1003cb2:	4659      	mov	r1, fp
 1003cb4:	2020      	movs	r0, #32
 1003cb6:	47a8      	blx	r5
 1003cb8:	3e01      	subs	r6, #1
 1003cba:	e7f7      	b.n	1003cac <z_vprintk+0x28c>
		if (remaining-- <= min_width) {
 1003cbc:	1e59      	subs	r1, r3, #1
 1003cbe:	4599      	cmp	r9, r3
 1003cc0:	910a      	str	r1, [sp, #40]	; 0x28
 1003cc2:	db07      	blt.n	1003cd4 <z_vprintk+0x2b4>
			if (padding == PAD_ZERO_BEFORE) {
 1003cc4:	f1b8 0f01 	cmp.w	r8, #1
 1003cc8:	d106      	bne.n	1003cd8 <z_vprintk+0x2b8>
				out('0', ctx);
 1003cca:	4659      	mov	r1, fp
 1003ccc:	2030      	movs	r0, #48	; 0x30
 1003cce:	920b      	str	r2, [sp, #44]	; 0x2c
				out(' ', ctx);
 1003cd0:	47a8      	blx	r5
 1003cd2:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
			nibble += nibble > 9 ? 87 : 48;
 1003cd4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 1003cd6:	e7b2      	b.n	1003c3e <z_vprintk+0x21e>
			} else if (padding == PAD_SPACE_BEFORE) {
 1003cd8:	f1b8 0f02 	cmp.w	r8, #2
 1003cdc:	d1fa      	bne.n	1003cd4 <z_vprintk+0x2b4>
				out(' ', ctx);
 1003cde:	4659      	mov	r1, fp
 1003ce0:	2020      	movs	r0, #32
 1003ce2:	920b      	str	r2, [sp, #44]	; 0x2c
 1003ce4:	e7f4      	b.n	1003cd0 <z_vprintk+0x2b0>
			found_largest_digit = 1;
 1003ce6:	9607      	str	r6, [sp, #28]
 1003ce8:	e7a9      	b.n	1003c3e <z_vprintk+0x21e>
				char *s = va_arg(ap, char *);
 1003cea:	f854 6b04 	ldr.w	r6, [r4], #4
				while (*s) {
 1003cee:	46b2      	mov	sl, r6
 1003cf0:	4653      	mov	r3, sl
 1003cf2:	f81a 0b01 	ldrb.w	r0, [sl], #1
 1003cf6:	b968      	cbnz	r0, 1003d14 <z_vprintk+0x2f4>
				if (padding == PAD_SPACE_AFTER) {
 1003cf8:	f1b8 0f03 	cmp.w	r8, #3
 1003cfc:	d121      	bne.n	1003d42 <z_vprintk+0x322>
					int remaining = min_width - (s - start);
 1003cfe:	1b9e      	subs	r6, r3, r6
 1003d00:	eba9 0606 	sub.w	r6, r9, r6
					while (remaining-- > 0) {
 1003d04:	2e00      	cmp	r6, #0
 1003d06:	f77f ae97 	ble.w	1003a38 <z_vprintk+0x18>
						out(' ', ctx);
 1003d0a:	4659      	mov	r1, fp
 1003d0c:	2020      	movs	r0, #32
 1003d0e:	47a8      	blx	r5
 1003d10:	3e01      	subs	r6, #1
 1003d12:	e7f7      	b.n	1003d04 <z_vprintk+0x2e4>
					out((int)(*s++), ctx);
 1003d14:	4659      	mov	r1, fp
 1003d16:	47a8      	blx	r5
 1003d18:	e7ea      	b.n	1003cf0 <z_vprintk+0x2d0>
				out(c, ctx);
 1003d1a:	4659      	mov	r1, fp
 1003d1c:	f854 0b04 	ldr.w	r0, [r4], #4
 1003d20:	e6ae      	b.n	1003a80 <z_vprintk+0x60>
				out((int)'%', ctx);
 1003d22:	4659      	mov	r1, fp
 1003d24:	e6ac      	b.n	1003a80 <z_vprintk+0x60>
				length_mod = 0;
 1003d26:	4637      	mov	r7, r6
				padding = PAD_NONE;
 1003d28:	46b0      	mov	r8, r6
				min_width = -1;
 1003d2a:	f04f 39ff 	mov.w	r9, #4294967295
				might_format = 1;
 1003d2e:	2601      	movs	r6, #1
 1003d30:	e68a      	b.n	1003a48 <z_vprintk+0x28>
			switch (*fmt) {
 1003d32:	f04f 0803 	mov.w	r8, #3
 1003d36:	e687      	b.n	1003a48 <z_vprintk+0x28>
					padding = PAD_ZERO_BEFORE;
 1003d38:	f04f 0801 	mov.w	r8, #1
 1003d3c:	e684      	b.n	1003a48 <z_vprintk+0x28>
					length_mod = 'L';
 1003d3e:	274c      	movs	r7, #76	; 0x4c
 1003d40:	e682      	b.n	1003a48 <z_vprintk+0x28>
			might_format = 0;
 1003d42:	4606      	mov	r6, r0
		++fmt;
 1003d44:	e680      	b.n	1003a48 <z_vprintk+0x28>
 1003d46:	bf00      	nop

01003d48 <vprintk>:
{
 1003d48:	b507      	push	{r0, r1, r2, lr}
 1003d4a:	460b      	mov	r3, r1
	struct out_context ctx = { 0 };
 1003d4c:	2100      	movs	r1, #0
{
 1003d4e:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
 1003d50:	9101      	str	r1, [sp, #4]
	z_vprintk(char_out, &ctx, fmt, ap);
 1003d52:	4803      	ldr	r0, [pc, #12]	; (1003d60 <vprintk+0x18>)
 1003d54:	a901      	add	r1, sp, #4
 1003d56:	f7ff fe63 	bl	1003a20 <z_vprintk>
}
 1003d5a:	b003      	add	sp, #12
 1003d5c:	f85d fb04 	ldr.w	pc, [sp], #4
 1003d60:	01003969 	.word	0x01003969

01003d64 <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
 1003d64:	b530      	push	{r4, r5, lr}
	struct str_context ctx = { str, size, 0 };
 1003d66:	2500      	movs	r5, #0
{
 1003d68:	b085      	sub	sp, #20
	struct str_context ctx = { str, size, 0 };
 1003d6a:	e9cd 0101 	strd	r0, r1, [sp, #4]
{
 1003d6e:	4604      	mov	r4, r0

	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
 1003d70:	a901      	add	r1, sp, #4
 1003d72:	4805      	ldr	r0, [pc, #20]	; (1003d88 <vsnprintk+0x24>)
	struct str_context ctx = { str, size, 0 };
 1003d74:	9503      	str	r5, [sp, #12]
	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
 1003d76:	f7ff fe53 	bl	1003a20 <z_vprintk>

	if (ctx.count < ctx.max) {
 1003d7a:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
 1003d7e:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
 1003d80:	bfb8      	it	lt
 1003d82:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
 1003d84:	b005      	add	sp, #20
 1003d86:	bd30      	pop	{r4, r5, pc}
 1003d88:	01014f11 	.word	0x01014f11

01003d8c <nordicsemi_nrf53_init>:
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
 1003d8c:	f04f 0320 	mov.w	r3, #32
 1003d90:	f3ef 8111 	mrs	r1, BASEPRI
 1003d94:	f383 8811 	msr	BASEPRI, r3
 1003d98:	f3bf 8f6f 	isb	sy
#ifdef CONFIG_SOC_NRF5340_CPUAPP
	/* Enable the instruction & data cache */
	NRF_CACHE->ENABLE = CACHE_ENABLE_ENABLE_Msk;
#endif /* CONFIG_SOC_NRF5340_CPUAPP */
#ifdef CONFIG_SOC_NRF5340_CPUNET
	NRF_NVMC->ICACHECNF |= NVMC_ICACHECNF_CACHEEN_Enabled;
 1003d9c:	4a06      	ldr	r2, [pc, #24]	; (1003db8 <nordicsemi_nrf53_init+0x2c>)
 1003d9e:	f8d2 3540 	ldr.w	r3, [r2, #1344]	; 0x540
 1003da2:	f043 0301 	orr.w	r3, r3, #1
 1003da6:	f8c2 3540 	str.w	r3, [r2, #1344]	; 0x540
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
 1003daa:	f381 8811 	msr	BASEPRI, r1
 1003dae:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
 1003db2:	2000      	movs	r0, #0
 1003db4:	4770      	bx	lr
 1003db6:	bf00      	nop
 1003db8:	41080000 	.word	0x41080000

01003dbc <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
 1003dbc:	b120      	cbz	r0, 1003dc8 <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
 1003dbe:	4b03      	ldr	r3, [pc, #12]	; (1003dcc <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
 1003dc0:	0180      	lsls	r0, r0, #6
 1003dc2:	f043 0301 	orr.w	r3, r3, #1
 1003dc6:	4718      	bx	r3

void arch_busy_wait(u32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
 1003dc8:	4770      	bx	lr
 1003dca:	bf00      	nop
 1003dcc:	01018350 	.word	0x01018350

01003dd0 <enable_logger>:

K_THREAD_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(struct device *arg)
{
 1003dd0:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
 1003dd2:	2200      	movs	r2, #0
{
 1003dd4:	b089      	sub	sp, #36	; 0x24
		k_timer_init(&log_process_thread_timer,
 1003dd6:	490f      	ldr	r1, [pc, #60]	; (1003e14 <enable_logger+0x44>)
 1003dd8:	480f      	ldr	r0, [pc, #60]	; (1003e18 <enable_logger+0x48>)
 1003dda:	f014 f825 	bl	1017e28 <k_timer_init>
 1003dde:	2200      	movs	r2, #0
 1003de0:	2300      	movs	r3, #0
 1003de2:	2400      	movs	r4, #0
 1003de4:	e9cd 2306 	strd	r2, r3, [sp, #24]
 1003de8:	230e      	movs	r3, #14
 1003dea:	4d0c      	ldr	r5, [pc, #48]	; (1003e1c <enable_logger+0x4c>)
 1003dec:	e9cd 3403 	strd	r3, r4, [sp, #12]
 1003df0:	f44f 7240 	mov.w	r2, #768	; 0x300
 1003df4:	4628      	mov	r0, r5
 1003df6:	e9cd 4401 	strd	r4, r4, [sp, #4]
 1003dfa:	4b09      	ldr	r3, [pc, #36]	; (1003e20 <enable_logger+0x50>)
 1003dfc:	4909      	ldr	r1, [pc, #36]	; (1003e24 <enable_logger+0x54>)
 1003dfe:	9400      	str	r4, [sp, #0]
 1003e00:	f010 fd60 	bl	10148c4 <z_impl_k_thread_create>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&thread_id, *(uintptr_t *)&value, K_SYSCALL_K_THREAD_NAME_SET);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_name_set(thread_id, value);
 1003e04:	4908      	ldr	r1, [pc, #32]	; (1003e28 <enable_logger+0x58>)
 1003e06:	4628      	mov	r0, r5
 1003e08:	f013 ff21 	bl	1017c4e <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
 1003e0c:	4620      	mov	r0, r4
 1003e0e:	b009      	add	sp, #36	; 0x24
 1003e10:	bd30      	pop	{r4, r5, pc}
 1003e12:	bf00      	nop
 1003e14:	01003e2d 	.word	0x01003e2d
 1003e18:	210006e8 	.word	0x210006e8
 1003e1c:	210008f4 	.word	0x210008f4
 1003e20:	01004215 	.word	0x01004215
 1003e24:	210084d8 	.word	0x210084d8
 1003e28:	010192c2 	.word	0x010192c2

01003e2c <log_process_thread_timer_expiry_fn>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
 1003e2c:	4801      	ldr	r0, [pc, #4]	; (1003e34 <log_process_thread_timer_expiry_fn+0x8>)
 1003e2e:	f010 bcbb 	b.w	10147a8 <z_impl_k_sem_give>
 1003e32:	bf00      	nop
 1003e34:	21000598 	.word	0x21000598

01003e38 <log_core_init>:
{
 1003e38:	b508      	push	{r3, lr}
		log_msg_pool_init();
 1003e3a:	f000 fa49 	bl	10042d0 <log_msg_pool_init>
		log_list_init(&list);
 1003e3e:	4809      	ldr	r0, [pc, #36]	; (1003e64 <log_core_init+0x2c>)
 1003e40:	f011 fb12 	bl	1015468 <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
 1003e44:	2304      	movs	r3, #4
 1003e46:	2228      	movs	r2, #40	; 0x28
 1003e48:	4907      	ldr	r1, [pc, #28]	; (1003e68 <log_core_init+0x30>)
 1003e4a:	4808      	ldr	r0, [pc, #32]	; (1003e6c <log_core_init+0x34>)
 1003e4c:	f013 fccb 	bl	10177e6 <k_mem_slab_init>
		timestamp_func = k_cycle_get_32_wrapper;
 1003e50:	4b07      	ldr	r3, [pc, #28]	; (1003e70 <log_core_init+0x38>)
 1003e52:	4a08      	ldr	r2, [pc, #32]	; (1003e74 <log_core_init+0x3c>)
	log_output_timestamp_freq_set(freq);
 1003e54:	f44f 4000 	mov.w	r0, #32768	; 0x8000
		timestamp_func = k_cycle_get_32_wrapper;
 1003e58:	601a      	str	r2, [r3, #0]
}
 1003e5a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	log_output_timestamp_freq_set(freq);
 1003e5e:	f000 bc7d 	b.w	100475c <log_output_timestamp_freq_set>
 1003e62:	bf00      	nop
 1003e64:	210008d0 	.word	0x210008d0
 1003e68:	2100a8e8 	.word	0x2100a8e8
 1003e6c:	210008d8 	.word	0x210008d8
 1003e70:	2100006c 	.word	0x2100006c
 1003e74:	010154a7 	.word	0x010154a7

01003e78 <dropped_notify>:
{
 1003e78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
 1003e7a:	2500      	movs	r5, #0
 1003e7c:	4b0c      	ldr	r3, [pc, #48]	; (1003eb0 <dropped_notify+0x38>)
 1003e7e:	e8d3 7fef 	ldaex	r7, [r3]
 1003e82:	e8c3 5fe2 	stlex	r2, r5, [r3]
 1003e86:	2a00      	cmp	r2, #0
 1003e88:	d1f9      	bne.n	1003e7e <dropped_notify+0x6>
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
 1003e8a:	4c0a      	ldr	r4, [pc, #40]	; (1003eb4 <dropped_notify+0x3c>)
 1003e8c:	4e0a      	ldr	r6, [pc, #40]	; (1003eb8 <dropped_notify+0x40>)
 1003e8e:	1b36      	subs	r6, r6, r4
 1003e90:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
 1003e92:	42b5      	cmp	r5, r6
 1003e94:	db00      	blt.n	1003e98 <dropped_notify+0x20>
}
 1003e96:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
 1003e98:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
 1003e9a:	795b      	ldrb	r3, [r3, #5]
 1003e9c:	b12b      	cbz	r3, 1003eaa <dropped_notify+0x32>
	if (backend->api->dropped != NULL) {
 1003e9e:	6823      	ldr	r3, [r4, #0]
 1003ea0:	68db      	ldr	r3, [r3, #12]
 1003ea2:	b113      	cbz	r3, 1003eaa <dropped_notify+0x32>
		backend->api->dropped(backend, cnt);
 1003ea4:	4639      	mov	r1, r7
 1003ea6:	4620      	mov	r0, r4
 1003ea8:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
 1003eaa:	3501      	adds	r5, #1
 1003eac:	3410      	adds	r4, #16
 1003eae:	e7f0      	b.n	1003e92 <dropped_notify+0x1a>
 1003eb0:	210008c8 	.word	0x210008c8
 1003eb4:	01018330 	.word	0x01018330
 1003eb8:	01018340 	.word	0x01018340

01003ebc <log_dropped>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 1003ebc:	4b04      	ldr	r3, [pc, #16]	; (1003ed0 <log_dropped+0x14>)
 1003ebe:	e8d3 2fef 	ldaex	r2, [r3]
 1003ec2:	3201      	adds	r2, #1
 1003ec4:	e8c3 2fe1 	stlex	r1, r2, [r3]
 1003ec8:	2900      	cmp	r1, #0
 1003eca:	d1f8      	bne.n	1003ebe <log_dropped+0x2>
}
 1003ecc:	4770      	bx	lr
 1003ece:	bf00      	nop
 1003ed0:	210008c8 	.word	0x210008c8

01003ed4 <log_source_name_get>:
 1003ed4:	4a04      	ldr	r2, [pc, #16]	; (1003ee8 <log_source_name_get+0x14>)
 1003ed6:	4b05      	ldr	r3, [pc, #20]	; (1003eec <log_source_name_get+0x18>)
 1003ed8:	1a9b      	subs	r3, r3, r2
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
 1003eda:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
 1003ede:	bf34      	ite	cc
 1003ee0:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
 1003ee4:	2000      	movcs	r0, #0
}
 1003ee6:	4770      	bx	lr
 1003ee8:	01018208 	.word	0x01018208
 1003eec:	01018330 	.word	0x01018330

01003ef0 <log_backend_enable>:
	id += backend - log_backend_get(0);
 1003ef0:	4b09      	ldr	r3, [pc, #36]	; (1003f18 <log_backend_enable+0x28>)
	log_backend_id_set(backend, id);
 1003ef2:	6842      	ldr	r2, [r0, #4]
	id += backend - log_backend_get(0);
 1003ef4:	1ac3      	subs	r3, r0, r3
 1003ef6:	111b      	asrs	r3, r3, #4
 1003ef8:	3301      	adds	r3, #1
{
 1003efa:	b510      	push	{r4, lr}
	log_backend_id_set(backend, id);
 1003efc:	7113      	strb	r3, [r2, #4]
	backend->cb->active = true;
 1003efe:	2201      	movs	r2, #1
	log_backend_activate(backend, ctx);
 1003f00:	6843      	ldr	r3, [r0, #4]
	if (!backend_attached) {
 1003f02:	4c06      	ldr	r4, [pc, #24]	; (1003f1c <log_backend_enable+0x2c>)
 1003f04:	715a      	strb	r2, [r3, #5]
 1003f06:	7822      	ldrb	r2, [r4, #0]
	backend->cb->ctx = ctx;
 1003f08:	6019      	str	r1, [r3, #0]
 1003f0a:	b912      	cbnz	r2, 1003f12 <log_backend_enable+0x22>
 1003f0c:	4804      	ldr	r0, [pc, #16]	; (1003f20 <log_backend_enable+0x30>)
 1003f0e:	f010 fc4b 	bl	10147a8 <z_impl_k_sem_give>
	backend_attached = true;
 1003f12:	2301      	movs	r3, #1
 1003f14:	7023      	strb	r3, [r4, #0]
}
 1003f16:	bd10      	pop	{r4, pc}
 1003f18:	01018330 	.word	0x01018330
 1003f1c:	21008060 	.word	0x21008060
 1003f20:	21000598 	.word	0x21000598

01003f24 <log_init>:
{
 1003f24:	b570      	push	{r4, r5, r6, lr}
 1003f26:	4b0f      	ldr	r3, [pc, #60]	; (1003f64 <log_init+0x40>)
 1003f28:	e8d3 5fef 	ldaex	r5, [r3]
 1003f2c:	1c6a      	adds	r2, r5, #1
 1003f2e:	e8c3 2fe1 	stlex	r1, r2, [r3]
 1003f32:	2900      	cmp	r1, #0
 1003f34:	d1f8      	bne.n	1003f28 <log_init+0x4>
	if (atomic_inc(&initialized) != 0) {
 1003f36:	b92d      	cbnz	r5, 1003f44 <log_init+0x20>
	return __log_backends_end - __log_backends_start;
 1003f38:	4c0b      	ldr	r4, [pc, #44]	; (1003f68 <log_init+0x44>)
 1003f3a:	4e0c      	ldr	r6, [pc, #48]	; (1003f6c <log_init+0x48>)
 1003f3c:	1b36      	subs	r6, r6, r4
 1003f3e:	1136      	asrs	r6, r6, #4
	for (i = 0; i < log_backend_count_get(); i++) {
 1003f40:	42b5      	cmp	r5, r6
 1003f42:	db00      	blt.n	1003f46 <log_init+0x22>
}
 1003f44:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
 1003f46:	7b23      	ldrb	r3, [r4, #12]
 1003f48:	b143      	cbz	r3, 1003f5c <log_init+0x38>
			if (backend->api->init != NULL) {
 1003f4a:	6823      	ldr	r3, [r4, #0]
 1003f4c:	695b      	ldr	r3, [r3, #20]
 1003f4e:	b103      	cbz	r3, 1003f52 <log_init+0x2e>
				backend->api->init();
 1003f50:	4798      	blx	r3
			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
 1003f52:	2204      	movs	r2, #4
 1003f54:	2100      	movs	r1, #0
 1003f56:	4620      	mov	r0, r4
 1003f58:	f7ff ffca 	bl	1003ef0 <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
 1003f5c:	3501      	adds	r5, #1
 1003f5e:	3410      	adds	r4, #16
 1003f60:	e7ee      	b.n	1003f40 <log_init+0x1c>
 1003f62:	bf00      	nop
 1003f64:	210008cc 	.word	0x210008cc
 1003f68:	01018330 	.word	0x01018330
 1003f6c:	01018340 	.word	0x01018340

01003f70 <log_strdup>:
	return (((const char *)addr >= (const char *)RO_START) &&
 1003f70:	4b14      	ldr	r3, [pc, #80]	; (1003fc4 <log_strdup+0x54>)
{
 1003f72:	b537      	push	{r0, r1, r2, r4, r5, lr}
	return (((const char *)addr >= (const char *)RO_START) &&
 1003f74:	4298      	cmp	r0, r3
{
 1003f76:	4604      	mov	r4, r0
	return (((const char *)addr >= (const char *)RO_START) &&
 1003f78:	d302      	bcc.n	1003f80 <log_strdup+0x10>
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
 1003f7a:	4b13      	ldr	r3, [pc, #76]	; (1003fc8 <log_strdup+0x58>)
 1003f7c:	4298      	cmp	r0, r3
 1003f7e:	d31c      	bcc.n	1003fba <log_strdup+0x4a>
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
 1003f80:	2200      	movs	r2, #0
 1003f82:	2300      	movs	r3, #0
 1003f84:	4811      	ldr	r0, [pc, #68]	; (1003fcc <log_strdup+0x5c>)
 1003f86:	a901      	add	r1, sp, #4
 1003f88:	f010 f860 	bl	101404c <k_mem_slab_alloc>
	if (err != 0) {
 1003f8c:	4605      	mov	r5, r0
 1003f8e:	b9b8      	cbnz	r0, 1003fc0 <log_strdup+0x50>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
 1003f90:	2201      	movs	r2, #1
 1003f92:	9b01      	ldr	r3, [sp, #4]
 1003f94:	e8d3 1fef 	ldaex	r1, [r3]
 1003f98:	e8c3 2fe0 	stlex	r0, r2, [r3]
 1003f9c:	2800      	cmp	r0, #0
 1003f9e:	d1f9      	bne.n	1003f94 <log_strdup+0x24>
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
 1003fa0:	9801      	ldr	r0, [sp, #4]
 1003fa2:	4621      	mov	r1, r4
 1003fa4:	221f      	movs	r2, #31
 1003fa6:	3004      	adds	r0, #4
 1003fa8:	f012 fcf1 	bl	101698e <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
 1003fac:	237e      	movs	r3, #126	; 0x7e
 1003fae:	9c01      	ldr	r4, [sp, #4]
 1003fb0:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	dup->buf[sizeof(dup->buf) - 1] = '\0';
 1003fb4:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
	return dup->buf;
 1003fb8:	3404      	adds	r4, #4
}
 1003fba:	4620      	mov	r0, r4
 1003fbc:	b003      	add	sp, #12
 1003fbe:	bd30      	pop	{r4, r5, pc}
		return (char *)log_strdup_fail_msg;
 1003fc0:	4c03      	ldr	r4, [pc, #12]	; (1003fd0 <log_strdup+0x60>)
 1003fc2:	e7fa      	b.n	1003fba <log_strdup+0x4a>
 1003fc4:	01018098 	.word	0x01018098
 1003fc8:	01019c00 	.word	0x01019c00
 1003fcc:	210008d8 	.word	0x210008d8
 1003fd0:	010192ca 	.word	0x010192ca

01003fd4 <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (u8_t *)buf);
 1003fd4:	b148      	cbz	r0, 1003fea <log_is_strdup+0x16>
 1003fd6:	4b05      	ldr	r3, [pc, #20]	; (1003fec <log_is_strdup+0x18>)
 1003fd8:	4298      	cmp	r0, r3
 1003fda:	d305      	bcc.n	1003fe8 <log_is_strdup+0x14>
 1003fdc:	33a0      	adds	r3, #160	; 0xa0
 1003fde:	4298      	cmp	r0, r3
 1003fe0:	bf2c      	ite	cs
 1003fe2:	2000      	movcs	r0, #0
 1003fe4:	2001      	movcc	r0, #1
 1003fe6:	4770      	bx	lr
 1003fe8:	2000      	movs	r0, #0
}
 1003fea:	4770      	bx	lr
 1003fec:	2100a8e8 	.word	0x2100a8e8

01003ff0 <z_impl_log_process>:
{
 1003ff0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!backend_attached && !bypass) {
 1003ff4:	4b4a      	ldr	r3, [pc, #296]	; (1004120 <z_impl_log_process+0x130>)
{
 1003ff6:	4604      	mov	r4, r0
	if (!backend_attached && !bypass) {
 1003ff8:	781b      	ldrb	r3, [r3, #0]
{
 1003ffa:	b085      	sub	sp, #20
	if (!backend_attached && !bypass) {
 1003ffc:	b903      	cbnz	r3, 1004000 <z_impl_log_process+0x10>
 1003ffe:	b340      	cbz	r0, 1004052 <z_impl_log_process+0x62>
	__asm__ volatile(
 1004000:	f04f 0320 	mov.w	r3, #32
 1004004:	f3ef 8611 	mrs	r6, BASEPRI
 1004008:	f383 8811 	msr	BASEPRI, r3
 100400c:	f3bf 8f6f 	isb	sy
	msg = log_list_head_get(&list);
 1004010:	4844      	ldr	r0, [pc, #272]	; (1004124 <z_impl_log_process+0x134>)
 1004012:	f011 fa39 	bl	1015488 <log_list_head_get>
 1004016:	4605      	mov	r5, r0
	__asm__ volatile(
 1004018:	f386 8811 	msr	BASEPRI, r6
 100401c:	f3bf 8f6f 	isb	sy
	if (msg != NULL) {
 1004020:	b158      	cbz	r0, 100403a <z_impl_log_process+0x4a>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
 1004022:	4b41      	ldr	r3, [pc, #260]	; (1004128 <z_impl_log_process+0x138>)
 1004024:	e8d3 2fef 	ldaex	r2, [r3]
 1004028:	3a01      	subs	r2, #1
 100402a:	e8c3 2fe1 	stlex	r1, r2, [r3]
 100402e:	2900      	cmp	r1, #0
 1004030:	d1f8      	bne.n	1004024 <z_impl_log_process+0x34>
	if (!bypass) {
 1004032:	b194      	cbz	r4, 100405a <z_impl_log_process+0x6a>
	log_msg_put(msg);
 1004034:	4628      	mov	r0, r5
 1004036:	f011 fb39 	bl	10156ac <log_msg_put>
	if (!bypass && dropped_cnt) {
 100403a:	b924      	cbnz	r4, 1004046 <z_impl_log_process+0x56>
 100403c:	4b3b      	ldr	r3, [pc, #236]	; (100412c <z_impl_log_process+0x13c>)
 100403e:	681b      	ldr	r3, [r3, #0]
 1004040:	b10b      	cbz	r3, 1004046 <z_impl_log_process+0x56>
		dropped_notify();
 1004042:	f7ff ff19 	bl	1003e78 <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
 1004046:	4837      	ldr	r0, [pc, #220]	; (1004124 <z_impl_log_process+0x134>)
 1004048:	f011 fa1c 	bl	1015484 <log_list_head_peek>
 100404c:	1e04      	subs	r4, r0, #0
 100404e:	bf18      	it	ne
 1004050:	2401      	movne	r4, #1
}
 1004052:	4620      	mov	r0, r4
 1004054:	b005      	add	sp, #20
 1004056:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    !panic_mode) {
 100405a:	4b35      	ldr	r3, [pc, #212]	; (1004130 <z_impl_log_process+0x140>)
		if (IS_ENABLED(CONFIG_LOG_DETECT_MISSED_STRDUP) &&
 100405c:	781b      	ldrb	r3, [r3, #0]
 100405e:	b9cb      	cbnz	r3, 1004094 <z_impl_log_process+0xa4>
 * @retval true  Standard message.
 * @retval false Hexdump message.
 */
static inline bool log_msg_is_std(struct log_msg *msg)
{
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
 1004060:	7a2b      	ldrb	r3, [r5, #8]
	if (!log_msg_is_std(msg)) {
 1004062:	07db      	lsls	r3, r3, #31
 1004064:	d416      	bmi.n	1004094 <z_impl_log_process+0xa4>
	msg_str = log_msg_str_get(msg);
 1004066:	f011 fb30 	bl	10156ca <log_msg_str_get>
 100406a:	4680      	mov	r8, r0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
 100406c:	4628      	mov	r0, r5
 100406e:	f011 fafb 	bl	1015668 <log_msg_nargs_get>
 1004072:	4601      	mov	r1, r0
 1004074:	4640      	mov	r0, r8
 1004076:	f011 fa1a 	bl	10154ae <z_log_get_s_mask>
 100407a:	4606      	mov	r6, r0
	return ((u8_t *)data - (u8_t *)__log_const_start)/
 100407c:	4f2d      	ldr	r7, [pc, #180]	; (1004134 <z_impl_log_process+0x144>)
 100407e:	4b2e      	ldr	r3, [pc, #184]	; (1004138 <z_impl_log_process+0x148>)
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
 1004080:	f8df b0d0 	ldr.w	fp, [pc, #208]	; 1004154 <z_impl_log_process+0x164>
 1004084:	1bdb      	subs	r3, r3, r7
 1004086:	08db      	lsrs	r3, r3, #3
 1004088:	9303      	str	r3, [sp, #12]
 100408a:	4b2c      	ldr	r3, [pc, #176]	; (100413c <z_impl_log_process+0x14c>)
 100408c:	1bdb      	subs	r3, r3, r7
 100408e:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
	while (mask) {
 1004092:	b936      	cbnz	r6, 10040a2 <z_impl_log_process+0xb2>
 1004094:	4e2a      	ldr	r6, [pc, #168]	; (1004140 <z_impl_log_process+0x150>)
 1004096:	4f2b      	ldr	r7, [pc, #172]	; (1004144 <z_impl_log_process+0x154>)
 1004098:	f04f 0800 	mov.w	r8, #0
 100409c:	1bbf      	subs	r7, r7, r6
 100409e:	113f      	asrs	r7, r7, #4
 10040a0:	e03a      	b.n	1004118 <z_impl_log_process+0x128>
		idx = 31 - __builtin_clz(mask);
 10040a2:	fab6 f186 	clz	r1, r6
 10040a6:	f1c1 091f 	rsb	r9, r1, #31
		str = (const char *)log_msg_arg_get(msg, idx);
 10040aa:	4649      	mov	r1, r9
 10040ac:	4628      	mov	r0, r5
 10040ae:	f011 fade 	bl	101566e <log_msg_arg_get>
	return (((const char *)addr >= (const char *)RO_START) &&
 10040b2:	4b25      	ldr	r3, [pc, #148]	; (1004148 <z_impl_log_process+0x158>)
		str = (const char *)log_msg_arg_get(msg, idx);
 10040b4:	4601      	mov	r1, r0
	return (((const char *)addr >= (const char *)RO_START) &&
 10040b6:	4298      	cmp	r0, r3
 10040b8:	d302      	bcc.n	10040c0 <z_impl_log_process+0xd0>
		if (!is_rodata(str) && !log_is_strdup(str) &&
 10040ba:	4b24      	ldr	r3, [pc, #144]	; (100414c <z_impl_log_process+0x15c>)
 10040bc:	4298      	cmp	r0, r3
 10040be:	d31a      	bcc.n	10040f6 <z_impl_log_process+0x106>
 10040c0:	4608      	mov	r0, r1
 10040c2:	f7ff ff87 	bl	1003fd4 <log_is_strdup>
 10040c6:	4602      	mov	r2, r0
 10040c8:	b9a8      	cbnz	r0, 10040f6 <z_impl_log_process+0x106>
 10040ca:	4b21      	ldr	r3, [pc, #132]	; (1004150 <z_impl_log_process+0x160>)
 10040cc:	4299      	cmp	r1, r3
 10040ce:	d012      	beq.n	10040f6 <z_impl_log_process+0x106>
	return msg->hdr.ids.source_id;
 10040d0:	896b      	ldrh	r3, [r5, #10]
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
 10040d2:	9903      	ldr	r1, [sp, #12]
 10040d4:	f3c3 1389 	ubfx	r3, r3, #6, #10
 10040d8:	428b      	cmp	r3, r1
	return __log_const_start[source_id].name;
 10040da:	bf38      	it	cc
 10040dc:	f857 2033 	ldrcc.w	r2, [r7, r3, lsl #3]
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
 10040e0:	ea4f 138a 	mov.w	r3, sl, lsl #6
 10040e4:	f043 0301 	orr.w	r3, r3, #1
 10040e8:	f8ad 3000 	strh.w	r3, [sp]
 10040ec:	4649      	mov	r1, r9
 10040ee:	4643      	mov	r3, r8
 10040f0:	4658      	mov	r0, fp
 10040f2:	f011 fa36 	bl	1015562 <log_3>
		mask &= ~BIT(idx);
 10040f6:	2101      	movs	r1, #1
 10040f8:	fa01 f109 	lsl.w	r1, r1, r9
 10040fc:	ea26 0601 	bic.w	r6, r6, r1
 1004100:	e7c7      	b.n	1004092 <z_impl_log_process+0xa2>
	return backend->cb->active;
 1004102:	6873      	ldr	r3, [r6, #4]
			if (log_backend_is_active(backend) &&
 1004104:	795b      	ldrb	r3, [r3, #5]
 1004106:	b123      	cbz	r3, 1004112 <z_impl_log_process+0x122>
	backend->api->put(backend, msg);
 1004108:	6833      	ldr	r3, [r6, #0]
 100410a:	4629      	mov	r1, r5
 100410c:	4630      	mov	r0, r6
 100410e:	681b      	ldr	r3, [r3, #0]
 1004110:	4798      	blx	r3
		for (int i = 0; i < log_backend_count_get(); i++) {
 1004112:	f108 0801 	add.w	r8, r8, #1
 1004116:	3610      	adds	r6, #16
 1004118:	45b8      	cmp	r8, r7
 100411a:	dbf2      	blt.n	1004102 <z_impl_log_process+0x112>
 100411c:	e78a      	b.n	1004034 <z_impl_log_process+0x44>
 100411e:	bf00      	nop
 1004120:	21008060 	.word	0x21008060
 1004124:	210008d0 	.word	0x210008d0
 1004128:	210008c4 	.word	0x210008c4
 100412c:	210008c8 	.word	0x210008c8
 1004130:	21008061 	.word	0x21008061
 1004134:	01018208 	.word	0x01018208
 1004138:	01018330 	.word	0x01018330
 100413c:	010182f8 	.word	0x010182f8
 1004140:	01018330 	.word	0x01018330
 1004144:	01018340 	.word	0x01018340
 1004148:	01018098 	.word	0x01018098
 100414c:	01019c00 	.word	0x01019c00
 1004150:	010192ca 	.word	0x010192ca
 1004154:	010192e4 	.word	0x010192e4

01004158 <msg_finalize>:
	msg->hdr.timestamp = timestamp_func();
 1004158:	4b27      	ldr	r3, [pc, #156]	; (10041f8 <msg_finalize+0xa0>)
{
 100415a:	b573      	push	{r0, r1, r4, r5, r6, lr}
	msg->hdr.timestamp = timestamp_func();
 100415c:	681b      	ldr	r3, [r3, #0]
	msg->hdr.ids = src_level;
 100415e:	8141      	strh	r1, [r0, #10]
{
 1004160:	4604      	mov	r4, r0
	msg->hdr.timestamp = timestamp_func();
 1004162:	4798      	blx	r3
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 1004164:	4d25      	ldr	r5, [pc, #148]	; (10041fc <msg_finalize+0xa4>)
 1004166:	60e0      	str	r0, [r4, #12]
 1004168:	e8d5 3fef 	ldaex	r3, [r5]
 100416c:	3301      	adds	r3, #1
 100416e:	e8c5 3fe2 	stlex	r2, r3, [r5]
 1004172:	2a00      	cmp	r2, #0
 1004174:	d1f8      	bne.n	1004168 <msg_finalize+0x10>
	__asm__ volatile(
 1004176:	f04f 0320 	mov.w	r3, #32
 100417a:	f3ef 8611 	mrs	r6, BASEPRI
 100417e:	f383 8811 	msr	BASEPRI, r3
 1004182:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
 1004186:	481e      	ldr	r0, [pc, #120]	; (1004200 <msg_finalize+0xa8>)
 1004188:	4621      	mov	r1, r4
 100418a:	f011 f971 	bl	1015470 <log_list_add_tail>
	__asm__ volatile(
 100418e:	f386 8811 	msr	BASEPRI, r6
 1004192:	f3bf 8f6f 	isb	sy
	if (panic_mode) {
 1004196:	4b1b      	ldr	r3, [pc, #108]	; (1004204 <msg_finalize+0xac>)
 1004198:	781b      	ldrb	r3, [r3, #0]
 100419a:	b183      	cbz	r3, 10041be <msg_finalize+0x66>
	__asm__ volatile(
 100419c:	f04f 0320 	mov.w	r3, #32
 10041a0:	f3ef 8411 	mrs	r4, BASEPRI
 10041a4:	f383 8811 	msr	BASEPRI, r3
 10041a8:	f3bf 8f6f 	isb	sy
	if (z_syscall_trap()) {
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
 10041ac:	2000      	movs	r0, #0
 10041ae:	f7ff ff1f 	bl	1003ff0 <z_impl_log_process>
	__asm__ volatile(
 10041b2:	f384 8811 	msr	BASEPRI, r4
 10041b6:	f3bf 8f6f 	isb	sy
}
 10041ba:	b002      	add	sp, #8
 10041bc:	bd70      	pop	{r4, r5, r6, pc}
	} else if (proc_tid != NULL && buffered_cnt == 1) {
 10041be:	4a12      	ldr	r2, [pc, #72]	; (1004208 <msg_finalize+0xb0>)
 10041c0:	682b      	ldr	r3, [r5, #0]
 10041c2:	6812      	ldr	r2, [r2, #0]
 10041c4:	2a00      	cmp	r2, #0
 10041c6:	d0f8      	beq.n	10041ba <msg_finalize+0x62>
 10041c8:	2b01      	cmp	r3, #1
 10041ca:	d10a      	bne.n	10041e2 <msg_finalize+0x8a>
	z_impl_k_timer_start(timer, duration, period);
 10041cc:	2200      	movs	r2, #0
 10041ce:	2300      	movs	r3, #0
 10041d0:	480e      	ldr	r0, [pc, #56]	; (100420c <msg_finalize+0xb4>)
 10041d2:	e9cd 2300 	strd	r2, r3, [sp]
 10041d6:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 10041da:	2300      	movs	r3, #0
 10041dc:	f010 fdae 	bl	1014d3c <z_impl_k_timer_start>
 10041e0:	e7eb      	b.n	10041ba <msg_finalize+0x62>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
 10041e2:	2b0a      	cmp	r3, #10
 10041e4:	d1e9      	bne.n	10041ba <msg_finalize+0x62>
	z_impl_k_timer_stop(timer);
 10041e6:	4809      	ldr	r0, [pc, #36]	; (100420c <msg_finalize+0xb4>)
 10041e8:	f013 fe2a 	bl	1017e40 <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
 10041ec:	4808      	ldr	r0, [pc, #32]	; (1004210 <msg_finalize+0xb8>)
}
 10041ee:	b002      	add	sp, #8
 10041f0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 10041f4:	f010 bad8 	b.w	10147a8 <z_impl_k_sem_give>
 10041f8:	2100006c 	.word	0x2100006c
 10041fc:	210008c4 	.word	0x210008c4
 1004200:	210008d0 	.word	0x210008d0
 1004204:	21008061 	.word	0x21008061
 1004208:	21000968 	.word	0x21000968
 100420c:	210006e8 	.word	0x210006e8
 1004210:	21000598 	.word	0x21000598

01004214 <log_process_thread_func>:
{
 1004214:	b510      	push	{r4, lr}
	log_init();
 1004216:	f7ff fe85 	bl	1003f24 <log_init>
	return z_impl_k_current_get();
 100421a:	f010 fabf 	bl	101479c <z_impl_k_current_get>
	proc_tid = process_tid;
 100421e:	4b0c      	ldr	r3, [pc, #48]	; (1004250 <log_process_thread_func+0x3c>)
 1004220:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
 1004222:	b130      	cbz	r0, 1004232 <log_process_thread_func+0x1e>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
 1004224:	4b0b      	ldr	r3, [pc, #44]	; (1004254 <log_process_thread_func+0x40>)
	    process_tid &&
 1004226:	681b      	ldr	r3, [r3, #0]
 1004228:	2b09      	cmp	r3, #9
 100422a:	dd02      	ble.n	1004232 <log_process_thread_func+0x1e>
	z_impl_k_sem_give(sem);
 100422c:	480a      	ldr	r0, [pc, #40]	; (1004258 <log_process_thread_func+0x44>)
 100422e:	f010 fabb 	bl	10147a8 <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
 1004232:	4c09      	ldr	r4, [pc, #36]	; (1004258 <log_process_thread_func+0x44>)
 1004234:	2000      	movs	r0, #0
 1004236:	f7ff fedb 	bl	1003ff0 <z_impl_log_process>
		if (log_process(false) == false) {
 100423a:	2800      	cmp	r0, #0
 100423c:	d1fa      	bne.n	1004234 <log_process_thread_func+0x20>
 100423e:	f04f 32ff 	mov.w	r2, #4294967295
 1004242:	f04f 33ff 	mov.w	r3, #4294967295
 1004246:	4620      	mov	r0, r4
 1004248:	f010 fad4 	bl	10147f4 <z_impl_k_sem_take>
 100424c:	e7f2      	b.n	1004234 <log_process_thread_func+0x20>
 100424e:	bf00      	nop
 1004250:	21000968 	.word	0x21000968
 1004254:	210008c4 	.word	0x210008c4
 1004258:	21000598 	.word	0x21000598

0100425c <z_impl_log_panic>:
{
 100425c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
 100425e:	4f0e      	ldr	r7, [pc, #56]	; (1004298 <z_impl_log_panic+0x3c>)
 1004260:	783d      	ldrb	r5, [r7, #0]
 1004262:	b975      	cbnz	r5, 1004282 <z_impl_log_panic+0x26>
	log_init();
 1004264:	f7ff fe5e 	bl	1003f24 <log_init>
	return __log_backends_end - __log_backends_start;
 1004268:	4c0c      	ldr	r4, [pc, #48]	; (100429c <z_impl_log_panic+0x40>)
 100426a:	4e0d      	ldr	r6, [pc, #52]	; (10042a0 <z_impl_log_panic+0x44>)
 100426c:	1b36      	subs	r6, r6, r4
 100426e:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
 1004270:	42b5      	cmp	r5, r6
 1004272:	db07      	blt.n	1004284 <z_impl_log_panic+0x28>
 1004274:	2000      	movs	r0, #0
 1004276:	f7ff febb 	bl	1003ff0 <z_impl_log_process>
		while (log_process(false) == true) {
 100427a:	2800      	cmp	r0, #0
 100427c:	d1fa      	bne.n	1004274 <z_impl_log_panic+0x18>
	panic_mode = true;
 100427e:	2301      	movs	r3, #1
 1004280:	703b      	strb	r3, [r7, #0]
}
 1004282:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return backend->cb->active;
 1004284:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
 1004286:	795b      	ldrb	r3, [r3, #5]
 1004288:	b11b      	cbz	r3, 1004292 <z_impl_log_panic+0x36>
	backend->api->panic(backend);
 100428a:	6823      	ldr	r3, [r4, #0]
 100428c:	4620      	mov	r0, r4
 100428e:	691b      	ldr	r3, [r3, #16]
 1004290:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
 1004292:	3501      	adds	r5, #1
 1004294:	3410      	adds	r4, #16
 1004296:	e7eb      	b.n	1004270 <z_impl_log_panic+0x14>
 1004298:	21008061 	.word	0x21008061
 100429c:	01018330 	.word	0x01018330
 10042a0:	01018340 	.word	0x01018340

010042a4 <log_free>:
{
 10042a4:	b507      	push	{r0, r1, r2, lr}
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
 10042a6:	3804      	subs	r0, #4
 10042a8:	9001      	str	r0, [sp, #4]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
 10042aa:	e8d0 3fef 	ldaex	r3, [r0]
 10042ae:	1e5a      	subs	r2, r3, #1
 10042b0:	e8c0 2fe1 	stlex	r1, r2, [r0]
 10042b4:	2900      	cmp	r1, #0
 10042b6:	d1f8      	bne.n	10042aa <log_free+0x6>
	if (atomic_dec(&dup->refcount) == 1) {
 10042b8:	2b01      	cmp	r3, #1
 10042ba:	d103      	bne.n	10042c4 <log_free+0x20>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
 10042bc:	4803      	ldr	r0, [pc, #12]	; (10042cc <log_free+0x28>)
 10042be:	a901      	add	r1, sp, #4
 10042c0:	f00f fef6 	bl	10140b0 <k_mem_slab_free>
}
 10042c4:	b003      	add	sp, #12
 10042c6:	f85d fb04 	ldr.w	pc, [sp], #4
 10042ca:	bf00      	nop
 10042cc:	210008d8 	.word	0x210008d8

010042d0 <log_msg_pool_init>:
static u8_t __noinit __aligned(sizeof(void *))
		log_msg_pool_buf[CONFIG_LOG_BUFFER_SIZE];

void log_msg_pool_init(void)
{
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
 10042d0:	2320      	movs	r3, #32
 10042d2:	4902      	ldr	r1, [pc, #8]	; (10042dc <log_msg_pool_init+0xc>)
 10042d4:	461a      	mov	r2, r3
 10042d6:	4802      	ldr	r0, [pc, #8]	; (10042e0 <log_msg_pool_init+0x10>)
 10042d8:	f013 ba85 	b.w	10177e6 <k_mem_slab_init>
 10042dc:	2100a988 	.word	0x2100a988
 10042e0:	2100096c 	.word	0x2100096c

010042e4 <log_msg_no_space_handle>:
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
	union log_msg_chunk *msg = NULL;
 10042e4:	2300      	movs	r3, #0
{
 10042e6:	b537      	push	{r0, r1, r2, r4, r5, lr}

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
			log_dropped();
			err = k_mem_slab_alloc(&log_msg_pool,
 10042e8:	4d09      	ldr	r5, [pc, #36]	; (1004310 <log_msg_no_space_handle+0x2c>)
	union log_msg_chunk *msg = NULL;
 10042ea:	9301      	str	r3, [sp, #4]
 10042ec:	2001      	movs	r0, #1
 10042ee:	f7ff fe7f 	bl	1003ff0 <z_impl_log_process>
 10042f2:	4604      	mov	r4, r0
			log_dropped();
 10042f4:	f7ff fde2 	bl	1003ebc <log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
 10042f8:	2200      	movs	r2, #0
 10042fa:	2300      	movs	r3, #0
 10042fc:	4628      	mov	r0, r5
 10042fe:	a901      	add	r1, sp, #4
 1004300:	f00f fea4 	bl	101404c <k_mem_slab_alloc>
					       (void **)&msg,
					       K_NO_WAIT);
		} while ((err != 0) && more);
 1004304:	b108      	cbz	r0, 100430a <log_msg_no_space_handle+0x26>
 1004306:	2c00      	cmp	r4, #0
 1004308:	d1f0      	bne.n	10042ec <log_msg_no_space_handle+0x8>
	} else {
		log_dropped();
	}
	return msg;

}
 100430a:	9801      	ldr	r0, [sp, #4]
 100430c:	b003      	add	sp, #12
 100430e:	bd30      	pop	{r4, r5, pc}
 1004310:	2100096c 	.word	0x2100096c

01004314 <log_msg_chunk_alloc>:
	union log_msg_chunk *msg = NULL;
 1004314:	2300      	movs	r3, #0
{
 1004316:	b507      	push	{r0, r1, r2, lr}
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
 1004318:	2200      	movs	r2, #0
	union log_msg_chunk *msg = NULL;
 100431a:	9301      	str	r3, [sp, #4]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
 100431c:	4806      	ldr	r0, [pc, #24]	; (1004338 <log_msg_chunk_alloc+0x24>)
 100431e:	2300      	movs	r3, #0
 1004320:	a901      	add	r1, sp, #4
 1004322:	f00f fe93 	bl	101404c <k_mem_slab_alloc>
	if (err != 0) {
 1004326:	b110      	cbz	r0, 100432e <log_msg_chunk_alloc+0x1a>
		msg = log_msg_no_space_handle();
 1004328:	f7ff ffdc 	bl	10042e4 <log_msg_no_space_handle>
 100432c:	9001      	str	r0, [sp, #4]
}
 100432e:	9801      	ldr	r0, [sp, #4]
 1004330:	b003      	add	sp, #12
 1004332:	f85d fb04 	ldr.w	pc, [sp], #4
 1004336:	bf00      	nop
 1004338:	2100096c 	.word	0x2100096c

0100433c <msg_free>:
{
 100433c:	b5f0      	push	{r4, r5, r6, r7, lr}
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
 100433e:	7a03      	ldrb	r3, [r0, #8]
	}
}

u32_t log_msg_nargs_get(struct log_msg *msg)
{
	return msg->hdr.params.std.nargs;
 1004340:	7a45      	ldrb	r5, [r0, #9]
{
 1004342:	b085      	sub	sp, #20
 1004344:	9001      	str	r0, [sp, #4]
	if (log_msg_is_std(msg) && nargs) {
 1004346:	07d8      	lsls	r0, r3, #31
	return msg->hdr.params.std.nargs;
 1004348:	ea4f 1515 	mov.w	r5, r5, lsr #4
	if (log_msg_is_std(msg) && nargs) {
 100434c:	d41c      	bmi.n	1004388 <msg_free+0x4c>
 100434e:	b1dd      	cbz	r5, 1004388 <msg_free+0x4c>
		u32_t smask = 0;
 1004350:	2400      	movs	r4, #0
		for (i = 0; i < nargs; i++) {
 1004352:	4626      	mov	r6, r4
			void *buf = (void *)log_msg_arg_get(msg, i);
 1004354:	4631      	mov	r1, r6
 1004356:	9801      	ldr	r0, [sp, #4]
 1004358:	f011 f989 	bl	101566e <log_msg_arg_get>
 100435c:	4607      	mov	r7, r0
			if (log_is_strdup(buf)) {
 100435e:	f7ff fe39 	bl	1003fd4 <log_is_strdup>
 1004362:	b170      	cbz	r0, 1004382 <msg_free+0x46>
				if (smask == 0) {
 1004364:	b934      	cbnz	r4, 1004374 <msg_free+0x38>
					smask = z_log_get_s_mask(
 1004366:	9b01      	ldr	r3, [sp, #4]
 1004368:	4629      	mov	r1, r5
 100436a:	6918      	ldr	r0, [r3, #16]
 100436c:	f011 f89f 	bl	10154ae <z_log_get_s_mask>
					if (smask == 0) {
 1004370:	4604      	mov	r4, r0
 1004372:	b148      	cbz	r0, 1004388 <msg_free+0x4c>
				if (smask & BIT(i)) {
 1004374:	fa24 f306 	lsr.w	r3, r4, r6
 1004378:	07d9      	lsls	r1, r3, #31
 100437a:	d502      	bpl.n	1004382 <msg_free+0x46>
					log_free(buf);
 100437c:	4638      	mov	r0, r7
 100437e:	f7ff ff91 	bl	10042a4 <log_free>
		for (i = 0; i < nargs; i++) {
 1004382:	3601      	adds	r6, #1
 1004384:	42ae      	cmp	r6, r5
 1004386:	d3e5      	bcc.n	1004354 <msg_free+0x18>
	if (msg->hdr.params.generic.ext == 1) {
 1004388:	9b01      	ldr	r3, [sp, #4]
 100438a:	7a1a      	ldrb	r2, [r3, #8]
 100438c:	0792      	lsls	r2, r2, #30
 100438e:	d504      	bpl.n	100439a <msg_free+0x5e>
		cont_free(msg->payload.ext.next);
 1004390:	695b      	ldr	r3, [r3, #20]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
 1004392:	4c08      	ldr	r4, [pc, #32]	; (10043b4 <msg_free+0x78>)
 1004394:	9303      	str	r3, [sp, #12]
	while (cont != NULL) {
 1004396:	9b03      	ldr	r3, [sp, #12]
 1004398:	b92b      	cbnz	r3, 10043a6 <msg_free+0x6a>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
 100439a:	4806      	ldr	r0, [pc, #24]	; (10043b4 <msg_free+0x78>)
 100439c:	a901      	add	r1, sp, #4
 100439e:	f00f fe87 	bl	10140b0 <k_mem_slab_free>
}
 10043a2:	b005      	add	sp, #20
 10043a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		next = cont->next;
 10043a6:	681d      	ldr	r5, [r3, #0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
 10043a8:	4620      	mov	r0, r4
 10043aa:	a903      	add	r1, sp, #12
 10043ac:	f00f fe80 	bl	10140b0 <k_mem_slab_free>
		cont = next;
 10043b0:	9503      	str	r5, [sp, #12]
 10043b2:	e7f0      	b.n	1004396 <msg_free+0x5a>
 10043b4:	2100096c 	.word	0x2100096c

010043b8 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *log_output,
			   const char *fmt, ...)
{
 10043b8:	b40e      	push	{r1, r2, r3}
 10043ba:	b503      	push	{r0, r1, lr}
 10043bc:	ab03      	add	r3, sp, #12
 10043be:	f853 2b04 	ldr.w	r2, [r3], #4
 10043c2:	4601      	mov	r1, r0
	va_start(args, fmt);
#if !defined(CONFIG_NEWLIB_LIBC) && !defined(CONFIG_ARCH_POSIX) && \
    defined(CONFIG_LOG_ENABLE_FANCY_OUTPUT_FORMATTING)
	length = z_prf(out_func, (void *)log_output, (char *)fmt, args);
#else
	z_vprintk(out_func, (void *)log_output, fmt, args);
 10043c4:	4804      	ldr	r0, [pc, #16]	; (10043d8 <print_formatted+0x20>)
	va_start(args, fmt);
 10043c6:	9301      	str	r3, [sp, #4]
	z_vprintk(out_func, (void *)log_output, fmt, args);
 10043c8:	f7ff fb2a 	bl	1003a20 <z_vprintk>
#endif
	va_end(args);

	return length;
}
 10043cc:	2000      	movs	r0, #0
 10043ce:	b002      	add	sp, #8
 10043d0:	f85d eb04 	ldr.w	lr, [sp], #4
 10043d4:	b003      	add	sp, #12
 10043d6:	4770      	bx	lr
 10043d8:	01015a73 	.word	0x01015a73

010043dc <prefix_print>:
}

static u32_t prefix_print(const struct log_output *log_output,
			 u32_t flags, bool func_on, u32_t timestamp, u8_t level,
			 u8_t domain_id, u16_t source_id)
{
 10043dc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (stamp) {
 10043e0:	f011 0402 	ands.w	r4, r1, #2
{
 10043e4:	b085      	sub	sp, #20
 10043e6:	4690      	mov	r8, r2
 10043e8:	4606      	mov	r6, r0
 10043ea:	461a      	mov	r2, r3
 10043ec:	f89d 7038 	ldrb.w	r7, [sp, #56]	; 0x38
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
 10043f0:	f001 0901 	and.w	r9, r1, #1
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
 10043f4:	f001 0508 	and.w	r5, r1, #8
	if (stamp) {
 10043f8:	d007      	beq.n	100440a <prefix_print+0x2e>
	if (!format) {
 10043fa:	f011 0f44 	tst.w	r1, #68	; 0x44
 10043fe:	d137      	bne.n	1004470 <prefix_print+0x94>
		length = print_formatted(log_output, "[%08lu] ", timestamp);
 1004400:	4932      	ldr	r1, [pc, #200]	; (10044cc <prefix_print+0xf0>)
 1004402:	f7ff ffd9 	bl	10043b8 <print_formatted>
			length = print_formatted(log_output,
 1004406:	4601      	mov	r1, r0
		length += timestamp_print(log_output, flags, timestamp);
 1004408:	460c      	mov	r4, r1
	if (color) {
 100440a:	f1b9 0f00 	cmp.w	r9, #0
 100440e:	d00a      	beq.n	1004426 <prefix_print+0x4a>
		const char *color = start && (colors[level] != NULL) ?
 1004410:	4b2f      	ldr	r3, [pc, #188]	; (10044d0 <prefix_print+0xf4>)
		print_formatted(log_output, "%s", color);
 1004412:	4630      	mov	r0, r6
		const char *color = start && (colors[level] != NULL) ?
 1004414:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
		print_formatted(log_output, "%s", color);
 1004418:	4b2e      	ldr	r3, [pc, #184]	; (10044d4 <prefix_print+0xf8>)
 100441a:	492f      	ldr	r1, [pc, #188]	; (10044d8 <prefix_print+0xfc>)
 100441c:	2a00      	cmp	r2, #0
 100441e:	bf08      	it	eq
 1004420:	461a      	moveq	r2, r3
 1004422:	f7ff ffc9 	bl	10043b8 <print_formatted>
	if (level_on) {
 1004426:	b13d      	cbz	r5, 1004438 <prefix_print+0x5c>
		total += print_formatted(log_output, "<%s> ", severity[level]);
 1004428:	4b2c      	ldr	r3, [pc, #176]	; (10044dc <prefix_print+0x100>)
 100442a:	4630      	mov	r0, r6
 100442c:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
 1004430:	492b      	ldr	r1, [pc, #172]	; (10044e0 <prefix_print+0x104>)
 1004432:	f7ff ffc1 	bl	10043b8 <print_formatted>
 1004436:	4605      	mov	r5, r0
	total += print_formatted(log_output,
 1004438:	f1b8 0f00 	cmp.w	r8, #0
 100443c:	d043      	beq.n	10044c6 <prefix_print+0xea>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
 100443e:	2301      	movs	r3, #1
 1004440:	fa03 f707 	lsl.w	r7, r3, r7
	total += print_formatted(log_output,
 1004444:	4b27      	ldr	r3, [pc, #156]	; (10044e4 <prefix_print+0x108>)
 1004446:	f017 0f10 	tst.w	r7, #16
 100444a:	4f27      	ldr	r7, [pc, #156]	; (10044e8 <prefix_print+0x10c>)
 100444c:	bf18      	it	ne
 100444e:	461f      	movne	r7, r3
 1004450:	f8bd 1040 	ldrh.w	r1, [sp, #64]	; 0x40
 1004454:	f89d 003c 	ldrb.w	r0, [sp, #60]	; 0x3c
 1004458:	f7ff fd3c 	bl	1003ed4 <log_source_name_get>
 100445c:	4639      	mov	r1, r7
 100445e:	4602      	mov	r2, r0
 1004460:	4630      	mov	r0, r6
 1004462:	f7ff ffa9 	bl	10043b8 <print_formatted>
 1004466:	4428      	add	r0, r5
		length += ids_print(log_output, level_on, func_on,
				    domain_id, source_id, level);
	}

	return length;
}
 1004468:	4420      	add	r0, r4
 100446a:	b005      	add	sp, #20
 100446c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (freq != 0U) {
 1004470:	4b1e      	ldr	r3, [pc, #120]	; (10044ec <prefix_print+0x110>)
 1004472:	6819      	ldr	r1, [r3, #0]
 1004474:	2900      	cmp	r1, #0
 1004476:	d0c7      	beq.n	1004408 <prefix_print+0x2c>
		timestamp /= timestamp_div;
 1004478:	4b1d      	ldr	r3, [pc, #116]	; (10044f0 <prefix_print+0x114>)
 100447a:	f44f 6e61 	mov.w	lr, #3600	; 0xe10
 100447e:	681b      	ldr	r3, [r3, #0]
		ms = (remainder * 1000U) / freq;
 1004480:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
		timestamp /= timestamp_div;
 1004484:	fbb2 f3f3 	udiv	r3, r2, r3
		seconds = timestamp / freq;
 1004488:	fbb3 f4f1 	udiv	r4, r3, r1
		seconds -= hours * 3600U;
 100448c:	fbb4 f2fe 	udiv	r2, r4, lr
 1004490:	fb0e 4e12 	mls	lr, lr, r2, r4
		remainder = timestamp % freq;
 1004494:	fb01 3414 	mls	r4, r1, r4, r3
		ms = (remainder * 1000U) / freq;
 1004498:	fb0c f404 	mul.w	r4, ip, r4
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
 100449c:	fbb4 fbf1 	udiv	fp, r4, r1
		mins = seconds / 60U;
 10044a0:	f04f 0a3c 	mov.w	sl, #60	; 0x3c
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
 10044a4:	fb01 441b 	mls	r4, r1, fp, r4
 10044a8:	fb0c f404 	mul.w	r4, ip, r4
		mins = seconds / 60U;
 10044ac:	fbbe f3fa 	udiv	r3, lr, sl
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
 10044b0:	fbb4 f1f1 	udiv	r1, r4, r1
			length = print_formatted(log_output,
 10044b4:	e9cd b101 	strd	fp, r1, [sp, #4]
 10044b8:	fb0a e113 	mls	r1, sl, r3, lr
 10044bc:	9100      	str	r1, [sp, #0]
 10044be:	490d      	ldr	r1, [pc, #52]	; (10044f4 <prefix_print+0x118>)
 10044c0:	f7ff ff7a 	bl	10043b8 <print_formatted>
 10044c4:	e79f      	b.n	1004406 <prefix_print+0x2a>
	total += print_formatted(log_output,
 10044c6:	4f08      	ldr	r7, [pc, #32]	; (10044e8 <prefix_print+0x10c>)
 10044c8:	e7c2      	b.n	1004450 <prefix_print+0x74>
 10044ca:	bf00      	nop
 10044cc:	01019335 	.word	0x01019335
 10044d0:	0101837c 	.word	0x0101837c
 10044d4:	01019327 	.word	0x01019327
 10044d8:	0101935a 	.word	0x0101935a
 10044dc:	01018390 	.word	0x01018390
 10044e0:	0101935d 	.word	0x0101935d
 10044e4:	01019331 	.word	0x01019331
 10044e8:	0101932c 	.word	0x0101932c
 10044ec:	21000988 	.word	0x21000988
 10044f0:	2100098c 	.word	0x2100098c
 10044f4:	0101933e 	.word	0x0101933e

010044f8 <postfix_print>:

static void postfix_print(const struct log_output *log_output,
			  u32_t flags, u8_t level)
{
 10044f8:	b538      	push	{r3, r4, r5, lr}
 10044fa:	460c      	mov	r4, r1
	if (color) {
 10044fc:	07e1      	lsls	r1, r4, #31
{
 10044fe:	4605      	mov	r5, r0
	if (color) {
 1004500:	d503      	bpl.n	100450a <postfix_print+0x12>
		print_formatted(log_output, "%s", color);
 1004502:	4a08      	ldr	r2, [pc, #32]	; (1004524 <postfix_print+0x2c>)
 1004504:	4908      	ldr	r1, [pc, #32]	; (1004528 <postfix_print+0x30>)
 1004506:	f7ff ff57 	bl	10043b8 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
 100450a:	06e2      	lsls	r2, r4, #27
 100450c:	d408      	bmi.n	1004520 <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
 100450e:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
 1004510:	4628      	mov	r0, r5
	color_postfix(log_output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(log_output, flags);
}
 1004512:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\n");
 1004516:	bf4c      	ite	mi
 1004518:	4904      	ldrmi	r1, [pc, #16]	; (100452c <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
 100451a:	4905      	ldrpl	r1, [pc, #20]	; (1004530 <postfix_print+0x38>)
 100451c:	f7ff bf4c 	b.w	10043b8 <print_formatted>
}
 1004520:	bd38      	pop	{r3, r4, r5, pc}
 1004522:	bf00      	nop
 1004524:	01019327 	.word	0x01019327
 1004528:	0101935a 	.word	0x0101935a
 100452c:	01019364 	.word	0x01019364
 1004530:	01019363 	.word	0x01019363

01004534 <hexdump_line_print>:
{
 1004534:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1004538:	461d      	mov	r5, r3
 100453a:	9b08      	ldr	r3, [sp, #32]
 100453c:	4617      	mov	r7, r2
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
 100453e:	06da      	lsls	r2, r3, #27
{
 1004540:	4604      	mov	r4, r0
 1004542:	460e      	mov	r6, r1
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
 1004544:	d405      	bmi.n	1004552 <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
 1004546:	0699      	lsls	r1, r3, #26
		print_formatted(ctx, "\n");
 1004548:	bf4c      	ite	mi
 100454a:	492a      	ldrmi	r1, [pc, #168]	; (10045f4 <hexdump_line_print+0xc0>)
		print_formatted(ctx, "\r\n");
 100454c:	492a      	ldrpl	r1, [pc, #168]	; (10045f8 <hexdump_line_print+0xc4>)
 100454e:	f7ff ff33 	bl	10043b8 <print_formatted>
{
 1004552:	f04f 0800 	mov.w	r8, #0
		print_formatted(log_output, " ");
 1004556:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 1004600 <hexdump_line_print+0xcc>
	for (int i = 0; i < prefix_offset; i++) {
 100455a:	45a8      	cmp	r8, r5
 100455c:	db2a      	blt.n	10045b4 <hexdump_line_print+0x80>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 100455e:	2500      	movs	r5, #0
			print_formatted(log_output, "   ");
 1004560:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 1004604 <hexdump_line_print+0xd0>
			print_formatted(log_output, "%02x ", data[i]);
 1004564:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 1004608 <hexdump_line_print+0xd4>
			print_formatted(log_output, " ");
 1004568:	f8df a094 	ldr.w	sl, [pc, #148]	; 1004600 <hexdump_line_print+0xcc>
		if (i < length) {
 100456c:	42bd      	cmp	r5, r7
 100456e:	d22f      	bcs.n	10045d0 <hexdump_line_print+0x9c>
			print_formatted(log_output, "%02x ", data[i]);
 1004570:	4649      	mov	r1, r9
 1004572:	4620      	mov	r0, r4
 1004574:	5d72      	ldrb	r2, [r6, r5]
 1004576:	f7ff ff1f 	bl	10043b8 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 100457a:	3501      	adds	r5, #1
 100457c:	2d10      	cmp	r5, #16
 100457e:	d120      	bne.n	10045c2 <hexdump_line_print+0x8e>
	print_formatted(log_output, "|");
 1004580:	4620      	mov	r0, r4
 1004582:	491e      	ldr	r1, [pc, #120]	; (10045fc <hexdump_line_print+0xc8>)
 1004584:	f7ff ff18 	bl	10043b8 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 1004588:	2500      	movs	r5, #0
			print_formatted(log_output, " ");
 100458a:	f8df 8074 	ldr.w	r8, [pc, #116]	; 1004600 <hexdump_line_print+0xcc>
			print_formatted(log_output, "%c",
 100458e:	f8df 907c 	ldr.w	r9, [pc, #124]	; 100460c <hexdump_line_print+0xd8>
		if (i < length) {
 1004592:	42af      	cmp	r7, r5
 1004594:	d928      	bls.n	10045e8 <hexdump_line_print+0xb4>
			char c = (char)data[i];
 1004596:	5d72      	ldrb	r2, [r6, r5]
			print_formatted(log_output, "%c",
 1004598:	4649      	mov	r1, r9
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isprint(int c)
{
	return (int)((((unsigned)c) >= ' ') &&
 100459a:	f1a2 0320 	sub.w	r3, r2, #32
 100459e:	2b5f      	cmp	r3, #95	; 0x5f
 10045a0:	bf28      	it	cs
 10045a2:	222e      	movcs	r2, #46	; 0x2e
 10045a4:	4620      	mov	r0, r4
 10045a6:	f7ff ff07 	bl	10043b8 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 10045aa:	3501      	adds	r5, #1
 10045ac:	2d10      	cmp	r5, #16
 10045ae:	d114      	bne.n	10045da <hexdump_line_print+0xa6>
}
 10045b0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(log_output, " ");
 10045b4:	4649      	mov	r1, r9
 10045b6:	4620      	mov	r0, r4
 10045b8:	f7ff fefe 	bl	10043b8 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
 10045bc:	f108 0801 	add.w	r8, r8, #1
 10045c0:	e7cb      	b.n	100455a <hexdump_line_print+0x26>
		if (i > 0 && !(i % 8)) {
 10045c2:	076a      	lsls	r2, r5, #29
 10045c4:	d1d2      	bne.n	100456c <hexdump_line_print+0x38>
			print_formatted(log_output, " ");
 10045c6:	4651      	mov	r1, sl
 10045c8:	4620      	mov	r0, r4
 10045ca:	f7ff fef5 	bl	10043b8 <print_formatted>
 10045ce:	e7cd      	b.n	100456c <hexdump_line_print+0x38>
			print_formatted(log_output, "   ");
 10045d0:	4641      	mov	r1, r8
 10045d2:	4620      	mov	r0, r4
 10045d4:	f7ff fef0 	bl	10043b8 <print_formatted>
 10045d8:	e7cf      	b.n	100457a <hexdump_line_print+0x46>
		if (i > 0 && !(i % 8)) {
 10045da:	076b      	lsls	r3, r5, #29
 10045dc:	d1d9      	bne.n	1004592 <hexdump_line_print+0x5e>
			print_formatted(log_output, " ");
 10045de:	4641      	mov	r1, r8
 10045e0:	4620      	mov	r0, r4
 10045e2:	f7ff fee9 	bl	10043b8 <print_formatted>
 10045e6:	e7d4      	b.n	1004592 <hexdump_line_print+0x5e>
			print_formatted(log_output, " ");
 10045e8:	4641      	mov	r1, r8
 10045ea:	4620      	mov	r0, r4
 10045ec:	f7ff fee4 	bl	10043b8 <print_formatted>
 10045f0:	e7db      	b.n	10045aa <hexdump_line_print+0x76>
 10045f2:	bf00      	nop
 10045f4:	01019364 	.word	0x01019364
 10045f8:	01019363 	.word	0x01019363
 10045fc:	0101936c 	.word	0x0101936c
 1004600:	01019ac9 	.word	0x01019ac9
 1004604:	01019ac7 	.word	0x01019ac7
 1004608:	01019366 	.word	0x01019366
 100460c:	0101936e 	.word	0x0101936e

01004610 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *log_output,
			    struct log_msg *msg,
			    u32_t flags)
{
 1004610:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return msg->hdr.ids.level;
 1004614:	7a8b      	ldrb	r3, [r1, #10]
 1004616:	4617      	mov	r7, r2
		log_output_msg_syst_process(log_output, msg, flags);
		return;
	}

	prefix_offset = raw_string ?
			0 : prefix_print(log_output, flags, std_msg, timestamp,
 1004618:	f013 0807 	ands.w	r8, r3, #7
{
 100461c:	4605      	mov	r5, r0
 100461e:	460e      	mov	r6, r1
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
 1004620:	7a0a      	ldrb	r2, [r1, #8]
 1004622:	b08a      	sub	sp, #40	; 0x28
			0 : prefix_print(log_output, flags, std_msg, timestamp,
 1004624:	d021      	beq.n	100466a <log_output_msg_process+0x5a>
 1004626:	43d2      	mvns	r2, r2
	return msg->hdr.ids.source_id;
 1004628:	8949      	ldrh	r1, [r1, #10]
 100462a:	f3c3 03c2 	ubfx	r3, r3, #3, #3
 100462e:	f3c1 1189 	ubfx	r1, r1, #6, #10
 1004632:	e9cd 8300 	strd	r8, r3, [sp]
 1004636:	9102      	str	r1, [sp, #8]
 1004638:	68f3      	ldr	r3, [r6, #12]
 100463a:	4639      	mov	r1, r7
 100463c:	f002 0201 	and.w	r2, r2, #1
 1004640:	f7ff fecc 	bl	10043dc <prefix_print>
 1004644:	4681      	mov	r9, r0
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
 1004646:	7a34      	ldrb	r4, [r6, #8]
 1004648:	43e4      	mvns	r4, r4
					 level, domain_id, source_id);

	if (log_msg_is_std(msg)) {
 100464a:	f014 0401 	ands.w	r4, r4, #1
 100464e:	d00e      	beq.n	100466e <log_output_msg_process+0x5e>
		std_print(msg, log_output);
 1004650:	4629      	mov	r1, r5
 1004652:	4630      	mov	r0, r6
 1004654:	f011 f8a3 	bl	101579e <std_print>
		raw_string_print(msg, log_output);
	} else {
		hexdump_print(msg, log_output, prefix_offset, flags);
	}

	if (!raw_string) {
 1004658:	f1b8 0f00 	cmp.w	r8, #0
 100465c:	d02b      	beq.n	10046b6 <log_output_msg_process+0xa6>
		postfix_print(log_output, flags, level);
 100465e:	4642      	mov	r2, r8
 1004660:	4639      	mov	r1, r7
 1004662:	4628      	mov	r0, r5
 1004664:	f7ff ff48 	bl	10044f8 <postfix_print>
 1004668:	e025      	b.n	10046b6 <log_output_msg_process+0xa6>
			0 : prefix_print(log_output, flags, std_msg, timestamp,
 100466a:	46c1      	mov	r9, r8
 100466c:	e7eb      	b.n	1004646 <log_output_msg_process+0x36>
	} else if (raw_string) {
 100466e:	f1b8 0f00 	cmp.w	r8, #0
 1004672:	d126      	bne.n	10046c2 <log_output_msg_process+0xb2>
	size_t offset = 0;
 1004674:	4627      	mov	r7, r4
		length = log_output->size;
 1004676:	68eb      	ldr	r3, [r5, #12]
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
 1004678:	aa06      	add	r2, sp, #24
		length = log_output->size;
 100467a:	9306      	str	r3, [sp, #24]
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
 100467c:	4630      	mov	r0, r6
 100467e:	463b      	mov	r3, r7
 1004680:	68a9      	ldr	r1, [r5, #8]
 1004682:	f011 f878 	bl	1015776 <log_msg_hexdump_data_get>
		log_output->control_block->offset = length;
 1004686:	9a06      	ldr	r2, [sp, #24]
 1004688:	686b      	ldr	r3, [r5, #4]
 100468a:	601a      	str	r2, [r3, #0]
		if (length != 0) {
 100468c:	b13a      	cbz	r2, 100469e <log_output_msg_process+0x8e>
			eol = (log_output->buf[length - 1] == '\n');
 100468e:	68ab      	ldr	r3, [r5, #8]
 1004690:	4413      	add	r3, r2
 1004692:	f813 4c01 	ldrb.w	r4, [r3, #-1]
 1004696:	f1a4 030a 	sub.w	r3, r4, #10
 100469a:	425c      	negs	r4, r3
 100469c:	415c      	adcs	r4, r3
		log_output_flush(log_output);
 100469e:	4628      	mov	r0, r5
 10046a0:	f011 f9da 	bl	1015a58 <log_output_flush>
		offset += length;
 10046a4:	9b06      	ldr	r3, [sp, #24]
 10046a6:	441f      	add	r7, r3
	} while (length > 0);
 10046a8:	2b00      	cmp	r3, #0
 10046aa:	d1e4      	bne.n	1004676 <log_output_msg_process+0x66>
	if (eol) {
 10046ac:	b11c      	cbz	r4, 10046b6 <log_output_msg_process+0xa6>
		print_formatted(log_output, "\r");
 10046ae:	4628      	mov	r0, r5
 10046b0:	4913      	ldr	r1, [pc, #76]	; (1004700 <log_output_msg_process+0xf0>)
 10046b2:	f7ff fe81 	bl	10043b8 <print_formatted>
	}

	log_output_flush(log_output);
 10046b6:	4628      	mov	r0, r5
 10046b8:	f011 f9ce 	bl	1015a58 <log_output_flush>
}
 10046bc:	b00a      	add	sp, #40	; 0x28
 10046be:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	print_formatted(log_output, "%s", log_msg_str_get(msg));
 10046c2:	4630      	mov	r0, r6
 10046c4:	f011 f801 	bl	10156ca <log_msg_str_get>
 10046c8:	490e      	ldr	r1, [pc, #56]	; (1004704 <log_output_msg_process+0xf4>)
 10046ca:	4602      	mov	r2, r0
 10046cc:	4628      	mov	r0, r5
 10046ce:	f7ff fe73 	bl	10043b8 <print_formatted>
		length = sizeof(buf);
 10046d2:	f04f 0a10 	mov.w	sl, #16
		log_msg_hexdump_data_get(msg, buf, &length, offset);
 10046d6:	aa05      	add	r2, sp, #20
 10046d8:	4623      	mov	r3, r4
 10046da:	4630      	mov	r0, r6
 10046dc:	a906      	add	r1, sp, #24
		length = sizeof(buf);
 10046de:	f8cd a014 	str.w	sl, [sp, #20]
		log_msg_hexdump_data_get(msg, buf, &length, offset);
 10046e2:	f011 f848 	bl	1015776 <log_msg_hexdump_data_get>
		if (length) {
 10046e6:	9a05      	ldr	r2, [sp, #20]
 10046e8:	2a00      	cmp	r2, #0
 10046ea:	d0b8      	beq.n	100465e <log_output_msg_process+0x4e>
			hexdump_line_print(log_output, buf, length,
 10046ec:	464b      	mov	r3, r9
 10046ee:	4628      	mov	r0, r5
 10046f0:	9700      	str	r7, [sp, #0]
 10046f2:	a906      	add	r1, sp, #24
 10046f4:	f7ff ff1e 	bl	1004534 <hexdump_line_print>
			offset += length;
 10046f8:	9b05      	ldr	r3, [sp, #20]
 10046fa:	441c      	add	r4, r3
		length = sizeof(buf);
 10046fc:	e7eb      	b.n	10046d6 <log_output_msg_process+0xc6>
 10046fe:	bf00      	nop
 1004700:	01019371 	.word	0x01019371
 1004704:	0101935a 	.word	0x0101935a

01004708 <log_output_dropped_process>:
	postfix_print(log_output, flags, level);
	log_output_flush(log_output);
}

void log_output_dropped_process(const struct log_output *log_output, u32_t cnt)
{
 1004708:	b573      	push	{r0, r1, r4, r5, r6, lr}
	int len;
	static const char prefix[] = DROPPED_COLOR_PREFIX "--- ";
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = log_output->func;
	struct device *dev = (struct device *)log_output->control_block->ctx;
 100470a:	e9d0 4300 	ldrd	r4, r3, [r0]
 100470e:	685d      	ldr	r5, [r3, #4]

	cnt = MIN(cnt, 9999);
	len = snprintk(buf, sizeof(buf), "%d", cnt);
 1004710:	f242 730f 	movw	r3, #9999	; 0x270f
 1004714:	428b      	cmp	r3, r1
 1004716:	bf28      	it	cs
 1004718:	460b      	movcs	r3, r1
 100471a:	4668      	mov	r0, sp
 100471c:	2105      	movs	r1, #5
 100471e:	4a0c      	ldr	r2, [pc, #48]	; (1004750 <log_output_dropped_process+0x48>)
 1004720:	f010 fc16 	bl	1014f50 <snprintk>
 1004724:	4606      	mov	r6, r0

	buffer_write(outf, (u8_t *)prefix, sizeof(prefix) - 1, dev);
 1004726:	462b      	mov	r3, r5
 1004728:	4620      	mov	r0, r4
 100472a:	220b      	movs	r2, #11
 100472c:	4909      	ldr	r1, [pc, #36]	; (1004754 <log_output_dropped_process+0x4c>)
 100472e:	f011 f829 	bl	1015784 <buffer_write>
	buffer_write(outf, buf, len, dev);
 1004732:	462b      	mov	r3, r5
 1004734:	4632      	mov	r2, r6
 1004736:	4669      	mov	r1, sp
 1004738:	4620      	mov	r0, r4
 100473a:	f011 f823 	bl	1015784 <buffer_write>
	buffer_write(outf, (u8_t *)postfix, sizeof(postfix) - 1, dev);
 100473e:	462b      	mov	r3, r5
 1004740:	221b      	movs	r2, #27
 1004742:	4620      	mov	r0, r4
 1004744:	4904      	ldr	r1, [pc, #16]	; (1004758 <log_output_dropped_process+0x50>)
 1004746:	f011 f81d 	bl	1015784 <buffer_write>
}
 100474a:	b002      	add	sp, #8
 100474c:	bd70      	pop	{r4, r5, r6, pc}
 100474e:	bf00      	nop
 1004750:	01019183 	.word	0x01019183
 1004754:	010193af 	.word	0x010193af
 1004758:	01019393 	.word	0x01019393

0100475c <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(u32_t frequency)
{
	timestamp_div = 1U;
 100475c:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
 100475e:	2100      	movs	r1, #0
	timestamp_div = 1U;
 1004760:	4a07      	ldr	r2, [pc, #28]	; (1004780 <log_output_timestamp_freq_set+0x24>)
{
 1004762:	b510      	push	{r4, lr}
	while (frequency > 1000000) {
 1004764:	4c07      	ldr	r4, [pc, #28]	; (1004784 <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
 1004766:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
 1004768:	42a0      	cmp	r0, r4
 100476a:	d804      	bhi.n	1004776 <log_output_timestamp_freq_set+0x1a>
 100476c:	b101      	cbz	r1, 1004770 <log_output_timestamp_freq_set+0x14>
 100476e:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
 1004770:	4b05      	ldr	r3, [pc, #20]	; (1004788 <log_output_timestamp_freq_set+0x2c>)
 1004772:	6018      	str	r0, [r3, #0]
}
 1004774:	bd10      	pop	{r4, pc}
		timestamp_div *= 2U;
 1004776:	2101      	movs	r1, #1
		frequency /= 2U;
 1004778:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
 100477a:	005b      	lsls	r3, r3, #1
 100477c:	e7f4      	b.n	1004768 <log_output_timestamp_freq_set+0xc>
 100477e:	bf00      	nop
 1004780:	2100098c 	.word	0x2100098c
 1004784:	000f4240 	.word	0x000f4240
 1004788:	21000988 	.word	0x21000988

0100478c <panic>:
 * @param log_output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const log_output)
{
	log_output_flush(log_output);
 100478c:	4801      	ldr	r0, [pc, #4]	; (1004794 <panic+0x8>)
 100478e:	f011 b963 	b.w	1015a58 <log_output_flush>
 1004792:	bf00      	nop
 1004794:	010183bc 	.word	0x010183bc

01004798 <dropped>:
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const log_output, u32_t cnt)
{
	log_output_dropped_process(log_output, cnt);
 1004798:	4801      	ldr	r0, [pc, #4]	; (10047a0 <dropped+0x8>)
 100479a:	f7ff bfb5 	b.w	1004708 <log_output_dropped_process>
 100479e:	bf00      	nop
 10047a0:	010183bc 	.word	0x010183bc

010047a4 <log_backend_uart_init>:

	log_backend_std_put(&log_output, flag, msg);
}

static void log_backend_uart_init(void)
{
 10047a4:	b508      	push	{r3, lr}
 10047a6:	4803      	ldr	r0, [pc, #12]	; (10047b4 <log_backend_uart_init+0x10>)
 10047a8:	f00f fab0 	bl	1013d0c <z_impl_device_get_binding>
 * @param ctx		User context.
 */
static inline void log_output_ctx_set(const struct log_output *log_output,
				      void *ctx)
{
	log_output->control_block->ctx = ctx;
 10047ac:	4b02      	ldr	r3, [pc, #8]	; (10047b8 <log_backend_uart_init+0x14>)
 10047ae:	6058      	str	r0, [r3, #4]

	dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
	assert(dev);

	log_output_ctx_set(&log_output, dev);
}
 10047b0:	bd08      	pop	{r3, pc}
 10047b2:	bf00      	nop
 10047b4:	010193bb 	.word	0x010193bb
 10047b8:	21000998 	.word	0x21000998

010047bc <put>:
{
 10047bc:	b510      	push	{r4, lr}
 10047be:	460c      	mov	r4, r1
	log_msg_get(msg);
 10047c0:	4608      	mov	r0, r1
 10047c2:	f010 ff48 	bl	1015656 <log_msg_get>
	log_output_msg_process(log_output, msg, flags);
 10047c6:	4621      	mov	r1, r4
 10047c8:	4804      	ldr	r0, [pc, #16]	; (10047dc <put+0x20>)
 10047ca:	220f      	movs	r2, #15
 10047cc:	f7ff ff20 	bl	1004610 <log_output_msg_process>
	log_msg_put(msg);
 10047d0:	4620      	mov	r0, r4
}
 10047d2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 10047d6:	f010 bf69 	b.w	10156ac <log_msg_put>
 10047da:	bf00      	nop
 10047dc:	010183bc 	.word	0x010183bc

010047e0 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
 10047e0:	b510      	push	{r4, lr}
 10047e2:	4807      	ldr	r0, [pc, #28]	; (1004800 <uart_console_init+0x20>)
 10047e4:	f00f fa92 	bl	1013d0c <z_impl_device_get_binding>
	__stdout_hook_install(console_out);
 10047e8:	4c06      	ldr	r4, [pc, #24]	; (1004804 <uart_console_init+0x24>)

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
 10047ea:	4b07      	ldr	r3, [pc, #28]	; (1004808 <uart_console_init+0x28>)
 10047ec:	6018      	str	r0, [r3, #0]
	__stdout_hook_install(console_out);
 10047ee:	4620      	mov	r0, r4
 10047f0:	f001 f838 	bl	1005864 <__stdout_hook_install>
	__printk_hook_install(console_out);
 10047f4:	4620      	mov	r0, r4
 10047f6:	f7ff f90d 	bl	1003a14 <__printk_hook_install>
#endif

	uart_console_hook_install();

	return 0;
}
 10047fa:	2000      	movs	r0, #0
 10047fc:	bd10      	pop	{r4, pc}
 10047fe:	bf00      	nop
 1004800:	010193bb 	.word	0x010193bb
 1004804:	0100480d 	.word	0x0100480d
 1004808:	210009a4 	.word	0x210009a4

0100480c <console_out>:
	if ('\n' == c) {
 100480c:	280a      	cmp	r0, #10
{
 100480e:	b538      	push	{r3, r4, r5, lr}
 1004810:	4604      	mov	r4, r0
 1004812:	4d07      	ldr	r5, [pc, #28]	; (1004830 <console_out+0x24>)
	if ('\n' == c) {
 1004814:	d104      	bne.n	1004820 <console_out+0x14>
 1004816:	6828      	ldr	r0, [r5, #0]
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	api->poll_out(dev, out_char);
 1004818:	6883      	ldr	r3, [r0, #8]
 100481a:	210d      	movs	r1, #13
 100481c:	685b      	ldr	r3, [r3, #4]
 100481e:	4798      	blx	r3
	uart_poll_out(uart_console_dev, c);
 1004820:	6828      	ldr	r0, [r5, #0]
 1004822:	6883      	ldr	r3, [r0, #8]
 1004824:	b2e1      	uxtb	r1, r4
 1004826:	685b      	ldr	r3, [r3, #4]
 1004828:	4798      	blx	r3
}
 100482a:	4620      	mov	r0, r4
 100482c:	bd38      	pop	{r3, r4, r5, pc}
 100482e:	bf00      	nop
 1004830:	210009a4 	.word	0x210009a4

01004834 <clock_async_start>:
}

static int clock_async_start(struct device *dev,
			     clock_control_subsys_t subsys,
			     struct clock_control_async_data *data)
{
 1004834:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct nrf_clock_control_sub_data *clk_data;
	int key;
	u8_t ref;

	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
	config = get_sub_config(dev, type);
 1004838:	6846      	ldr	r6, [r0, #4]
	clk_data = get_sub_data(dev, type);
 100483a:	f8d0 e00c 	ldr.w	lr, [r0, #12]
 100483e:	b2cf      	uxtb	r7, r1
			((data != NULL) && (data->cb != NULL)));

	/* if node is in the list it means that it is scheduled for
	 * the second time.
	 */
	if ((data != NULL)
 1004840:	b14a      	cbz	r2, 1004856 <clock_async_start+0x22>
	sys_snode_t *item = sys_slist_peek_head(list);
 1004842:	230c      	movs	r3, #12
 1004844:	437b      	muls	r3, r7
 1004846:	f85e 3003 	ldr.w	r3, [lr, r3]
		if (item == node) {
 100484a:	429a      	cmp	r2, r3
 100484c:	d053      	beq.n	10048f6 <clock_async_start+0xc2>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT(slist, snode)
 100484e:	b113      	cbz	r3, 1004856 <clock_async_start+0x22>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 1004850:	681b      	ldr	r3, [r3, #0]
	} while (item);
 1004852:	2b00      	cmp	r3, #0
 1004854:	d1f9      	bne.n	100484a <clock_async_start+0x16>
	__asm__ volatile(
 1004856:	f04f 0320 	mov.w	r3, #32
 100485a:	f3ef 8c11 	mrs	ip, BASEPRI
 100485e:	f383 8811 	msr	BASEPRI, r3
 1004862:	f3bf 8f6f 	isb	sy
	    && is_in_list(&clk_data->list, &data->node)) {
		return -EBUSY;
	}

	key = irq_lock();
	ref = ++clk_data->ref;
 1004866:	250c      	movs	r5, #12
 1004868:	437d      	muls	r5, r7
 100486a:	eb0e 0305 	add.w	r3, lr, r5
 100486e:	7a1c      	ldrb	r4, [r3, #8]
 1004870:	3401      	adds	r4, #1
 1004872:	b2e4      	uxtb	r4, r4
 1004874:	721c      	strb	r4, [r3, #8]
	__asm__ volatile(
 1004876:	f38c 8811 	msr	BASEPRI, ip
 100487a:	f3bf 8f6f 	isb	sy
	__ASSERT_NO_MSG(clk_data->ref > 0);
	irq_unlock(key);

	if (data) {
 100487e:	b352      	cbz	r2, 10048d6 <clock_async_start+0xa2>
    p_reg->INTENSET = mask;
}

NRF_STATIC_INLINE void nrf_clock_int_disable(NRF_CLOCK_Type * p_reg, uint32_t mask)
{
    p_reg->INTENCLR = mask;
 1004880:	f04f 0803 	mov.w	r8, #3
 1004884:	f8df c078 	ldr.w	ip, [pc, #120]	; 1004900 <clock_async_start+0xcc>
 1004888:	f8cc 8308 	str.w	r8, [ip, #776]	; 0x308
		bool already_started;

		clock_irqs_disable();
		already_started = clk_data->started;
 100488c:	f893 c009 	ldrb.w	ip, [r3, #9]
		if (!already_started) {
 1004890:	f1bc 0f00 	cmp.w	ip, #0
 1004894:	d115      	bne.n	10048c2 <clock_async_start+0x8e>
	__asm__ volatile(
 1004896:	f04f 0820 	mov.w	r8, #32
 100489a:	f3ef 8911 	mrs	r9, BASEPRI
 100489e:	f388 8811 	msr	BASEPRI, r8
 10048a2:	f3bf 8f6f 	isb	sy
	parent->next = child;
 10048a6:	f8c2 c000 	str.w	ip, [r2]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
 10048aa:	f8d3 8004 	ldr.w	r8, [r3, #4]
 10048ae:	f1b8 0f00 	cmp.w	r8, #0
 10048b2:	d11c      	bne.n	10048ee <clock_async_start+0xba>
	list->tail = node;
 10048b4:	605a      	str	r2, [r3, #4]
	list->head = node;
 10048b6:	f84e 2005 	str.w	r2, [lr, r5]
	__asm__ volatile(
 10048ba:	f389 8811 	msr	BASEPRI, r9
 10048be:	f3bf 8f6f 	isb	sy
    p_reg->INTENSET = mask;
 10048c2:	2503      	movs	r5, #3
 10048c4:	4b0e      	ldr	r3, [pc, #56]	; (1004900 <clock_async_start+0xcc>)
 10048c6:	f8c3 5304 	str.w	r5, [r3, #772]	; 0x304
			list_append(&clk_data->list, &data->node);
		}
		clock_irqs_enable();

		if (already_started) {
 10048ca:	f1bc 0f00 	cmp.w	ip, #0
 10048ce:	d002      	beq.n	10048d6 <clock_async_start+0xa2>
			data->cb(dev, subsys, data->user_data);
 10048d0:	e9d2 3201 	ldrd	r3, r2, [r2, #4]
 10048d4:	4798      	blx	r3
		}
	}

	if (ref == 1) {
 10048d6:	2c01      	cmp	r4, #1
 10048d8:	d107      	bne.n	10048ea <clock_async_start+0xb6>
		if (IS_ENABLED(CONFIG_NRF52_ANOMALY_132_WORKAROUND) &&
			(subsys == CLOCK_CONTROL_NRF_SUBSYS_LF)) {
			anomaly_132_workaround();
		}

		nrf_clock_task_trigger(NRF_CLOCK, config->start_tsk);
 10048da:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
}

NRF_STATIC_INLINE void nrf_clock_task_trigger(NRF_CLOCK_Type * p_reg, nrf_clock_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 10048de:	78b3      	ldrb	r3, [r6, #2]
 10048e0:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
 10048e4:	f503 43a0 	add.w	r3, r3, #20480	; 0x5000
 10048e8:	601c      	str	r4, [r3, #0]
	}

	return 0;
 10048ea:	2000      	movs	r0, #0
 10048ec:	e005      	b.n	10048fa <clock_async_start+0xc6>
	parent->next = child;
 10048ee:	f8c8 2000 	str.w	r2, [r8]
	list->tail = node;
 10048f2:	605a      	str	r2, [r3, #4]
}
 10048f4:	e7e1      	b.n	10048ba <clock_async_start+0x86>
		return -EBUSY;
 10048f6:	f06f 000f 	mvn.w	r0, #15
}
 10048fa:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 10048fe:	bf00      	nop
 1004900:	41005000 	.word	0x41005000

01004904 <clk_init>:
 * symbol.
 */
void nrf_power_clock_isr(void *arg);

static int clk_init(struct device *dev)
{
 1004904:	b510      	push	{r4, lr}
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
 1004906:	2200      	movs	r2, #0
{
 1004908:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
 100490a:	2101      	movs	r1, #1
 100490c:	2005      	movs	r0, #5
 100490e:	f000 faaf 	bl	1004e70 <z_arm_irq_priority_set>
		    nrf_power_clock_isr, 0, 0);

	irq_enable(DT_INST_IRQN(0));
 1004912:	2005      	movs	r0, #5
 1004914:	f000 fa7a 	bl	1004e0c <arch_irq_enable>
    return false;
}

NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source)
{
    p_reg->LFCLKSRC = (uint32_t)(source);
 1004918:	2202      	movs	r2, #2
 100491a:	4b07      	ldr	r3, [pc, #28]	; (1004938 <clk_init+0x34>)
	list->head = NULL;
 100491c:	2000      	movs	r0, #0
 100491e:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    p_reg->INTENSET = mask;
 1004922:	2203      	movs	r2, #3
 1004924:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

	clock_irqs_enable();

	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		sys_slist_init(&(get_sub_data(dev, i)->list));
 1004928:	68e3      	ldr	r3, [r4, #12]
	list->tail = NULL;
 100492a:	e9c3 0000 	strd	r0, r0, [r3]
 100492e:	68e3      	ldr	r3, [r4, #12]
 1004930:	e9c3 0003 	strd	r0, r0, [r3, #12]
	}

	return 0;
}
 1004934:	bd10      	pop	{r4, pc}
 1004936:	bf00      	nop
 1004938:	41005000 	.word	0x41005000

0100493c <clkstarted_handle.constprop.0>:
DEVICE_AND_API_INIT(clock_nrf, DT_INST_LABEL(0),
		    clk_init, &data, &config, PRE_KERNEL_1,
		    CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &clock_control_api);

static void clkstarted_handle(struct device *dev,
 100493c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
{
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
	struct clock_control_async_data *async_data;

	DBG(dev, type, "Clock started");
	sub_data->started = true;
 100493e:	240c      	movs	r4, #12
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
 1004940:	4e11      	ldr	r6, [pc, #68]	; (1004988 <clkstarted_handle.constprop.0+0x4c>)
static void clkstarted_handle(struct device *dev,
 1004942:	4605      	mov	r5, r0
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
 1004944:	68f3      	ldr	r3, [r6, #12]
	sub_data->started = true;
 1004946:	fb04 3400 	mla	r4, r4, r0, r3
 100494a:	2301      	movs	r3, #1
 100494c:	7263      	strb	r3, [r4, #9]
	__asm__ volatile(
 100494e:	f04f 0320 	mov.w	r3, #32
 1004952:	f3ef 8111 	mrs	r1, BASEPRI
 1004956:	f383 8811 	msr	BASEPRI, r3
 100495a:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
 100495e:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
 1004960:	b12b      	cbz	r3, 100496e <clkstarted_handle.constprop.0+0x32>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 1004962:	6860      	ldr	r0, [r4, #4]
 1004964:	681a      	ldr	r2, [r3, #0]
 1004966:	4283      	cmp	r3, r0
	list->head = node;
 1004968:	6022      	str	r2, [r4, #0]
	list->tail = node;
 100496a:	bf08      	it	eq
 100496c:	6062      	streq	r2, [r4, #4]
	__asm__ volatile(
 100496e:	f381 8811 	msr	BASEPRI, r1
 1004972:	f3bf 8f6f 	isb	sy

	while ((async_data = list_get(&sub_data->list)) != NULL) {
 1004976:	b903      	cbnz	r3, 100497a <clkstarted_handle.constprop.0+0x3e>
		async_data->cb(dev, (clock_control_subsys_t)type,
				async_data->user_data);
	}
}
 1004978:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		async_data->cb(dev, (clock_control_subsys_t)type,
 100497a:	4629      	mov	r1, r5
 100497c:	e9d3 7201 	ldrd	r7, r2, [r3, #4]
 1004980:	4630      	mov	r0, r6
 1004982:	47b8      	blx	r7
 1004984:	e7e3      	b.n	100494e <clkstarted_handle.constprop.0+0x12>
 1004986:	bf00      	nop
 1004988:	21000504 	.word	0x21000504

0100498c <nrf_power_clock_isr>:
	}
#endif
}

void nrf_power_clock_isr(void *arg)
{
 100498c:	b508      	push	{r3, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
 100498e:	4b10      	ldr	r3, [pc, #64]	; (10049d0 <nrf_power_clock_isr+0x44>)
 1004990:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
 1004992:	b162      	cbz	r2, 10049ae <nrf_power_clock_isr+0x22>
    return p_reg->INTENSET & mask;
 1004994:	4a0f      	ldr	r2, [pc, #60]	; (10049d4 <nrf_power_clock_isr+0x48>)
 1004996:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
 100499a:	07d1      	lsls	r1, r2, #31
 100499c:	d507      	bpl.n	10049ae <nrf_power_clock_isr+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 100499e:	2200      	movs	r2, #0
 10049a0:	601a      	str	r2, [r3, #0]
	struct device *dev = DEVICE_GET(clock_nrf);

	if (clock_event_check_and_clean(NRF_CLOCK_EVENT_HFCLKSTARTED,
					NRF_CLOCK_INT_HF_STARTED_MASK)) {
		struct nrf_clock_control_sub_data *data =
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
 10049a2:	4b0d      	ldr	r3, [pc, #52]	; (10049d8 <nrf_power_clock_isr+0x4c>)

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (!data->started) {
 10049a4:	68db      	ldr	r3, [r3, #12]
 10049a6:	7a58      	ldrb	r0, [r3, #9]
 10049a8:	b908      	cbnz	r0, 10049ae <nrf_power_clock_isr+0x22>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
 10049aa:	f7ff ffc7 	bl	100493c <clkstarted_handle.constprop.0>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
 10049ae:	4b0b      	ldr	r3, [pc, #44]	; (10049dc <nrf_power_clock_isr+0x50>)
 10049b0:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
 10049b2:	b15a      	cbz	r2, 10049cc <nrf_power_clock_isr+0x40>
    return p_reg->INTENSET & mask;
 10049b4:	4a07      	ldr	r2, [pc, #28]	; (10049d4 <nrf_power_clock_isr+0x48>)
 10049b6:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
 10049ba:	0792      	lsls	r2, r2, #30
 10049bc:	d506      	bpl.n	10049cc <nrf_power_clock_isr+0x40>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 10049be:	2200      	movs	r2, #0
					NRF_CLOCK_INT_LF_STARTED_MASK)) {
		if (IS_ENABLED(
			CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
			z_nrf_clock_calibration_lfclk_started();
		}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
 10049c0:	2001      	movs	r0, #1
 10049c2:	601a      	str	r2, [r3, #0]
	usb_power_isr();

	if (IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
		z_nrf_clock_calibration_isr();
	}
}
 10049c4:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
 10049c8:	f7ff bfb8 	b.w	100493c <clkstarted_handle.constprop.0>
}
 10049cc:	bd08      	pop	{r3, pc}
 10049ce:	bf00      	nop
 10049d0:	41005100 	.word	0x41005100
 10049d4:	41005000 	.word	0x41005000
 10049d8:	21000504 	.word	0x21000504
 10049dc:	41005104 	.word	0x41005104

010049e0 <handle_next_tick_case>:
 * counter progresses during that time it means that 1 tick elapsed and
 * interrupt is set pending.
 */
static void handle_next_tick_case(u32_t t)
{
	set_comparator(t + 2);
 10049e0:	1c82      	adds	r2, r0, #2

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE  void nrf_rtc_cc_set(NRF_RTC_Type * p_reg, uint32_t ch, uint32_t cc_val)
{
    p_reg->CC[ch] = cc_val;
 10049e2:	4b08      	ldr	r3, [pc, #32]	; (1004a04 <handle_next_tick_case+0x24>)
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
 10049e4:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 10049e8:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
#endif
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
 10049ec:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
	while (t != counter()) {
 10049f0:	4290      	cmp	r0, r2
 10049f2:	d100      	bne.n	10049f6 <handle_next_tick_case+0x16>
		 * generated. Trigger interrupt.
		 */
		t = counter();
		set_comparator(t + 2);
	}
}
 10049f4:	4770      	bx	lr
 10049f6:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
		set_comparator(t + 2);
 10049fa:	1c82      	adds	r2, r0, #2
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
 10049fc:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 1004a00:	e7f2      	b.n	10049e8 <handle_next_tick_case+0x8>
 1004a02:	bf00      	nop
 1004a04:	41016000 	.word	0x41016000

01004a08 <rtc1_nrf_isr>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 1004a08:	2200      	movs	r2, #0
 1004a0a:	4b06      	ldr	r3, [pc, #24]	; (1004a24 <rtc1_nrf_isr+0x1c>)
 1004a0c:	601a      	str	r2, [r3, #0]
{
	ARG_UNUSED(arg);
	event_clear();

	u32_t t = get_comparator();
	u32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
 1004a0e:	4a06      	ldr	r2, [pc, #24]	; (1004a28 <rtc1_nrf_isr+0x20>)
    return p_reg->CC[ch];
 1004a10:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
 1004a14:	6813      	ldr	r3, [r2, #0]
	return (a - b) & COUNTER_MAX;
 1004a16:	1ac0      	subs	r0, r0, r3
 1004a18:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
 1004a1c:	4403      	add	r3, r0
 1004a1e:	6013      	str	r3, [r2, #0]
		 * so it won't get preempted by the interrupt.
		 */
		set_absolute_ticks(last_count + CYC_PER_TICK);
	}

	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
 1004a20:	f010 b8f8 	b.w	1014c14 <z_clock_announce>
 1004a24:	41016140 	.word	0x41016140
 1004a28:	210009c0 	.word	0x210009c0

01004a2c <z_clock_driver_init>:
}

int z_clock_driver_init(struct device *device)
{
 1004a2c:	b538      	push	{r3, r4, r5, lr}
 1004a2e:	4814      	ldr	r0, [pc, #80]	; (1004a80 <z_clock_driver_init+0x54>)
 1004a30:	f00f f96c 	bl	1013d0c <z_impl_device_get_binding>
	struct device *clock;

	ARG_UNUSED(device);

	clock = device_get_binding(DT_LABEL(DT_INST(0, nordic_nrf_clock)));
	if (!clock) {
 1004a34:	b300      	cbz	r0, 1004a78 <z_clock_driver_init+0x4c>
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->on(dev, sys);
 1004a36:	6883      	ldr	r3, [r0, #8]
}

NRF_STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    p_reg->PRESCALER = val;
 1004a38:	2400      	movs	r4, #0
 1004a3a:	2101      	movs	r1, #1
 1004a3c:	681b      	ldr	r3, [r3, #0]
 1004a3e:	4798      	blx	r3
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 1004a40:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 1004a44:	4d0f      	ldr	r5, [pc, #60]	; (1004a84 <z_clock_driver_init+0x58>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 1004a46:	4b10      	ldr	r3, [pc, #64]	; (1004a88 <z_clock_driver_init+0x5c>)
    p_reg->PRESCALER = val;
 1004a48:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 1004a4c:	601c      	str	r4, [r3, #0]
 1004a4e:	4b0f      	ldr	r3, [pc, #60]	; (1004a8c <z_clock_driver_init+0x60>)
	nrf_rtc_prescaler_set(RTC, 0);
	event_clear();
	NVIC_ClearPendingIRQ(RTC1_IRQn);
	int_enable();

	IRQ_CONNECT(RTC1_IRQn, 1, rtc1_nrf_isr, 0, 0);
 1004a50:	2101      	movs	r1, #1
 1004a52:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    p_reg->INTENSET = mask;
 1004a56:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 1004a5a:	4622      	mov	r2, r4
 1004a5c:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
 1004a60:	2016      	movs	r0, #22
 1004a62:	f000 fa05 	bl	1004e70 <z_arm_irq_priority_set>
	irq_enable(RTC1_IRQn);
 1004a66:	2016      	movs	r0, #22
 1004a68:	f000 f9d0 	bl	1004e0c <arch_irq_enable>
    return (uint32_t)p_reg + task;
}

NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
 1004a6c:	2301      	movs	r3, #1

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		set_comparator(counter() + CYC_PER_TICK);
	}

	return 0;
 1004a6e:	4620      	mov	r0, r4
 1004a70:	4a07      	ldr	r2, [pc, #28]	; (1004a90 <z_clock_driver_init+0x64>)
 1004a72:	6013      	str	r3, [r2, #0]
 1004a74:	602b      	str	r3, [r5, #0]
}
 1004a76:	bd38      	pop	{r3, r4, r5, pc}
		return -1;
 1004a78:	f04f 30ff 	mov.w	r0, #4294967295
 1004a7c:	e7fb      	b.n	1004a76 <z_clock_driver_init+0x4a>
 1004a7e:	bf00      	nop
 1004a80:	010193d9 	.word	0x010193d9
 1004a84:	41016000 	.word	0x41016000
 1004a88:	41016140 	.word	0x41016140
 1004a8c:	e000e100 	.word	0xe000e100
 1004a90:	41016008 	.word	0x41016008

01004a94 <z_clock_set_timeout>:

void z_clock_set_timeout(s32_t ticks, bool idle)
{
 1004a94:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     return p_reg->COUNTER;
 1004a96:	4b2c      	ldr	r3, [pc, #176]	; (1004b48 <z_clock_set_timeout+0xb4>)

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return;
	}

	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
 1004a98:	4c2c      	ldr	r4, [pc, #176]	; (1004b4c <z_clock_set_timeout+0xb8>)
 1004a9a:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);

	u32_t unannounced = counter_sub(counter(), last_count);
 1004a9e:	4b2c      	ldr	r3, [pc, #176]	; (1004b50 <z_clock_set_timeout+0xbc>)
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
 1004aa0:	f1b0 3fff 	cmp.w	r0, #4294967295
 1004aa4:	bf08      	it	eq
 1004aa6:	4620      	moveq	r0, r4
	u32_t unannounced = counter_sub(counter(), last_count);
 1004aa8:	6819      	ldr	r1, [r3, #0]
	return (a - b) & COUNTER_MAX;
 1004aaa:	1a52      	subs	r2, r2, r1
 1004aac:	f022 437f 	bic.w	r3, r2, #4278190080	; 0xff000000
	/* If we haven't announced for more than half the 24-bit wrap
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
 1004ab0:	0212      	lsls	r2, r2, #8
 1004ab2:	d436      	bmi.n	1004b22 <z_clock_set_timeout+0x8e>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
 1004ab4:	3801      	subs	r0, #1
 1004ab6:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 1004aba:	42a0      	cmp	r0, r4
 1004abc:	bfa8      	it	ge
 1004abe:	4620      	movge	r0, r4
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
 1004ac0:	3301      	adds	r3, #1
 1004ac2:	4418      	add	r0, r3
	 */
	if (cyc > MAX_CYCLES) {
		cyc = MAX_CYCLES;
	}

	cyc += last_count;
 1004ac4:	42a0      	cmp	r0, r4
 1004ac6:	bf94      	ite	ls
 1004ac8:	180c      	addls	r4, r1, r0
 1004aca:	190c      	addhi	r4, r1, r4
    p_reg->INTENCLR = mask;
 1004acc:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 1004ad0:	2700      	movs	r7, #0
    p_reg->INTENCLR = mask;
 1004ad2:	4b1d      	ldr	r3, [pc, #116]	; (1004b48 <z_clock_set_timeout+0xb4>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 1004ad4:	4e1f      	ldr	r6, [pc, #124]	; (1004b54 <z_clock_set_timeout+0xc0>)
    p_reg->INTENCLR = mask;
 1004ad6:	f8c3 0308 	str.w	r0, [r3, #776]	; 0x308
     return p_reg->COUNTER;
 1004ada:	f8d3 1504 	ldr.w	r1, [r3, #1284]	; 0x504
    return p_reg->CC[ch];
 1004ade:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
 1004ae2:	f021 457f 	bic.w	r5, r1, #4278190080	; 0xff000000
	return (a - b) & COUNTER_MAX;
 1004ae6:	1a52      	subs	r2, r2, r1
 1004ae8:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
	if (counter_sub(prev_val, now) == 1) {
 1004aec:	2a01      	cmp	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 1004aee:	6037      	str	r7, [r6, #0]
    p_reg->CC[ch] = cc_val;
 1004af0:	f8c3 5540 	str.w	r5, [r3, #1344]	; 0x540
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
 1004af4:	461d      	mov	r5, r3
 1004af6:	f8c3 0344 	str.w	r0, [r3, #836]	; 0x344
 1004afa:	d103      	bne.n	1004b04 <z_clock_set_timeout+0x70>
	z_impl_k_busy_wait(usec_to_wait);
 1004afc:	200f      	movs	r0, #15
 1004afe:	f013 f8a4 	bl	1017c4a <z_impl_k_busy_wait>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 1004b02:	6037      	str	r7, [r6, #0]
 1004b04:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 1004b08:	4b13      	ldr	r3, [pc, #76]	; (1004b58 <z_clock_set_timeout+0xc4>)
 1004b0a:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
     return p_reg->COUNTER;
 1004b0e:	f8d5 0504 	ldr.w	r0, [r5, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
 1004b12:	1a23      	subs	r3, r4, r0
 1004b14:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	if (diff == 1) {
 1004b18:	2b01      	cmp	r3, #1
 1004b1a:	d104      	bne.n	1004b26 <z_clock_set_timeout+0x92>
		handle_next_tick_case(t);
 1004b1c:	f7ff ff60 	bl	10049e0 <handle_next_tick_case>
 1004b20:	e00b      	b.n	1004b3a <z_clock_set_timeout+0xa6>
		ticks = 0;
 1004b22:	2000      	movs	r0, #0
 1004b24:	e7cc      	b.n	1004ac0 <z_clock_set_timeout+0x2c>
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
 1004b26:	f024 437f 	bic.w	r3, r4, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
 1004b2a:	f8c5 3540 	str.w	r3, [r5, #1344]	; 0x540
     return p_reg->COUNTER;
 1004b2e:	f8d5 0504 	ldr.w	r0, [r5, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
 1004b32:	1a24      	subs	r4, r4, r0
 1004b34:	3c02      	subs	r4, #2
	if (diff > MAX_TICKS) {
 1004b36:	0223      	lsls	r3, r4, #8
 1004b38:	d4f0      	bmi.n	1004b1c <z_clock_set_timeout+0x88>
    p_reg->INTENSET = mask;
 1004b3a:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 1004b3e:	4b02      	ldr	r3, [pc, #8]	; (1004b48 <z_clock_set_timeout+0xb4>)
 1004b40:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	set_protected_absolute_ticks(cyc);
}
 1004b44:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 1004b46:	bf00      	nop
 1004b48:	41016000 	.word	0x41016000
 1004b4c:	007fffff 	.word	0x007fffff
 1004b50:	210009c0 	.word	0x210009c0
 1004b54:	41016140 	.word	0x41016140
 1004b58:	e000e100 	.word	0xe000e100

01004b5c <z_clock_elapsed>:
	__asm__ volatile(
 1004b5c:	f04f 0220 	mov.w	r2, #32
 1004b60:	f3ef 8311 	mrs	r3, BASEPRI
 1004b64:	f382 8811 	msr	BASEPRI, r2
 1004b68:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
 1004b6c:	4a06      	ldr	r2, [pc, #24]	; (1004b88 <z_clock_elapsed+0x2c>)
 1004b6e:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
 1004b72:	4a06      	ldr	r2, [pc, #24]	; (1004b8c <z_clock_elapsed+0x30>)
	return (a - b) & COUNTER_MAX;
 1004b74:	6812      	ldr	r2, [r2, #0]
 1004b76:	1a80      	subs	r0, r0, r2
 1004b78:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	__asm__ volatile(
 1004b7c:	f383 8811 	msr	BASEPRI, r3
 1004b80:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
 1004b84:	4770      	bx	lr
 1004b86:	bf00      	nop
 1004b88:	41016000 	.word	0x41016000
 1004b8c:	210009c0 	.word	0x210009c0

01004b90 <z_timer_cycle_get_32>:
	__asm__ volatile(
 1004b90:	f04f 0320 	mov.w	r3, #32
 1004b94:	f3ef 8211 	mrs	r2, BASEPRI
 1004b98:	f383 8811 	msr	BASEPRI, r3
 1004b9c:	f3bf 8f6f 	isb	sy

u32_t z_timer_cycle_get_32(void)
{
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) + last_count;
 1004ba0:	4906      	ldr	r1, [pc, #24]	; (1004bbc <z_timer_cycle_get_32+0x2c>)
 1004ba2:	4b07      	ldr	r3, [pc, #28]	; (1004bc0 <z_timer_cycle_get_32+0x30>)
 1004ba4:	6808      	ldr	r0, [r1, #0]
 1004ba6:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	__asm__ volatile(
 1004baa:	f382 8811 	msr	BASEPRI, r2
 1004bae:	f3bf 8f6f 	isb	sy
	return (a - b) & COUNTER_MAX;
 1004bb2:	1a1b      	subs	r3, r3, r0
 1004bb4:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000

	k_spin_unlock(&lock, key);
	return ret;
}
 1004bb8:	4418      	add	r0, r3
 1004bba:	4770      	bx	lr
 1004bbc:	210009c0 	.word	0x210009c0
 1004bc0:	41016000 	.word	0x41016000

01004bc4 <uECC_get_rng>:
}

uECC_RNG_Function uECC_get_rng(void)
{
	return g_rng_function;
}
 1004bc4:	4b01      	ldr	r3, [pc, #4]	; (1004bcc <uECC_get_rng+0x8>)
 1004bc6:	6818      	ldr	r0, [r3, #0]
 1004bc8:	4770      	bx	lr
 1004bca:	bf00      	nop
 1004bcc:	21000070 	.word	0x21000070

01004bd0 <vli_mmod_fast_secp256r1>:
{
	return &curve_secp256r1;
}

void vli_mmod_fast_secp256r1(unsigned int *result, unsigned int*product)
{
 1004bd0:	b5f0      	push	{r4, r5, r6, r7, lr}
	unsigned int tmp[NUM_ECC_WORDS];
	int carry;

	/* t */
	uECC_vli_set(result, product, NUM_ECC_WORDS);
 1004bd2:	2208      	movs	r2, #8
{
 1004bd4:	b089      	sub	sp, #36	; 0x24
 1004bd6:	460c      	mov	r4, r1
 1004bd8:	4606      	mov	r6, r0
	uECC_vli_set(result, product, NUM_ECC_WORDS);
 1004bda:	f011 f954 	bl	1015e86 <uECC_vli_set>

	/* s1 */
	tmp[0] = tmp[1] = tmp[2] = 0;
 1004bde:	2700      	movs	r7, #0
	tmp[3] = product[11];
 1004be0:	6acb      	ldr	r3, [r1, #44]	; 0x2c
	tmp[4] = product[12];
	tmp[5] = product[13];
	tmp[6] = product[14];
	tmp[7] = product[15];
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1004be2:	466a      	mov	r2, sp
	tmp[3] = product[11];
 1004be4:	9303      	str	r3, [sp, #12]
	tmp[4] = product[12];
 1004be6:	6b0b      	ldr	r3, [r1, #48]	; 0x30
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1004be8:	4668      	mov	r0, sp
	tmp[4] = product[12];
 1004bea:	9304      	str	r3, [sp, #16]
	tmp[5] = product[13];
 1004bec:	6b4b      	ldr	r3, [r1, #52]	; 0x34
	tmp[0] = tmp[1] = tmp[2] = 0;
 1004bee:	e9cd 7701 	strd	r7, r7, [sp, #4]
	tmp[5] = product[13];
 1004bf2:	9305      	str	r3, [sp, #20]
	tmp[6] = product[14];
 1004bf4:	6b8b      	ldr	r3, [r1, #56]	; 0x38
	tmp[0] = tmp[1] = tmp[2] = 0;
 1004bf6:	9700      	str	r7, [sp, #0]
	tmp[6] = product[14];
 1004bf8:	9306      	str	r3, [sp, #24]
	tmp[7] = product[15];
 1004bfa:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1004bfc:	4669      	mov	r1, sp
	tmp[7] = product[15];
 1004bfe:	9307      	str	r3, [sp, #28]
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1004c00:	2308      	movs	r3, #8
 1004c02:	f011 f847 	bl	1015c94 <uECC_vli_add>
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004c06:	2308      	movs	r3, #8
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1004c08:	4605      	mov	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004c0a:	466a      	mov	r2, sp
 1004c0c:	4631      	mov	r1, r6
 1004c0e:	4630      	mov	r0, r6
 1004c10:	f011 f840 	bl	1015c94 <uECC_vli_add>

	/* s2 */
	tmp[3] = product[12];
 1004c14:	6b23      	ldr	r3, [r4, #48]	; 0x30
	tmp[4] = product[13];
	tmp[5] = product[14];
	tmp[6] = product[15];
	tmp[7] = 0;
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1004c16:	466a      	mov	r2, sp
	tmp[3] = product[12];
 1004c18:	9303      	str	r3, [sp, #12]
	tmp[4] = product[13];
 1004c1a:	6b63      	ldr	r3, [r4, #52]	; 0x34
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1004c1c:	4669      	mov	r1, sp
	tmp[4] = product[13];
 1004c1e:	9304      	str	r3, [sp, #16]
	tmp[5] = product[14];
 1004c20:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004c22:	4405      	add	r5, r0
	tmp[5] = product[14];
 1004c24:	9305      	str	r3, [sp, #20]
	tmp[6] = product[15];
 1004c26:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1004c28:	4668      	mov	r0, sp
	tmp[7] = 0;
 1004c2a:	e9cd 3706 	strd	r3, r7, [sp, #24]
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1004c2e:	2308      	movs	r3, #8
 1004c30:	f011 f830 	bl	1015c94 <uECC_vli_add>
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004c34:	4631      	mov	r1, r6
 1004c36:	2308      	movs	r3, #8
 1004c38:	466a      	mov	r2, sp
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1004c3a:	4405      	add	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004c3c:	4630      	mov	r0, r6
 1004c3e:	f011 f829 	bl	1015c94 <uECC_vli_add>

	/* s3 */
	tmp[0] = product[8];
 1004c42:	6a23      	ldr	r3, [r4, #32]
	tmp[1] = product[9];
	tmp[2] = product[10];
	tmp[3] = tmp[4] = tmp[5] = 0;
	tmp[6] = product[14];
	tmp[7] = product[15];
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004c44:	466a      	mov	r2, sp
	tmp[0] = product[8];
 1004c46:	9300      	str	r3, [sp, #0]
	tmp[1] = product[9];
 1004c48:	6a63      	ldr	r3, [r4, #36]	; 0x24
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004c4a:	4405      	add	r5, r0
	tmp[1] = product[9];
 1004c4c:	9301      	str	r3, [sp, #4]
	tmp[2] = product[10];
 1004c4e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004c50:	4630      	mov	r0, r6
	tmp[2] = product[10];
 1004c52:	9302      	str	r3, [sp, #8]
	tmp[6] = product[14];
 1004c54:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	tmp[3] = tmp[4] = tmp[5] = 0;
 1004c56:	e9cd 7704 	strd	r7, r7, [sp, #16]
	tmp[6] = product[14];
 1004c5a:	9306      	str	r3, [sp, #24]
	tmp[7] = product[15];
 1004c5c:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	tmp[3] = tmp[4] = tmp[5] = 0;
 1004c5e:	9703      	str	r7, [sp, #12]
	tmp[7] = product[15];
 1004c60:	9307      	str	r3, [sp, #28]
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004c62:	2308      	movs	r3, #8
 1004c64:	f011 f816 	bl	1015c94 <uECC_vli_add>

	/* s4 */
	tmp[0] = product[9];
 1004c68:	6a63      	ldr	r3, [r4, #36]	; 0x24
	tmp[1] = product[10];
	tmp[2] = product[11];
	tmp[3] = product[13];
	tmp[4] = product[14];
 1004c6a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
	tmp[0] = product[9];
 1004c6c:	9300      	str	r3, [sp, #0]
	tmp[1] = product[10];
 1004c6e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	tmp[4] = product[14];
 1004c70:	9204      	str	r2, [sp, #16]
	tmp[1] = product[10];
 1004c72:	9301      	str	r3, [sp, #4]
	tmp[2] = product[11];
 1004c74:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	tmp[5] = product[15];
 1004c76:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	tmp[2] = product[11];
 1004c78:	9302      	str	r3, [sp, #8]
	tmp[3] = product[13];
 1004c7a:	6b63      	ldr	r3, [r4, #52]	; 0x34
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004c7c:	4405      	add	r5, r0
	tmp[6] = product[13];
 1004c7e:	e9cd 2305 	strd	r2, r3, [sp, #20]
	tmp[3] = product[13];
 1004c82:	9303      	str	r3, [sp, #12]
	tmp[7] = product[8];
 1004c84:	6a23      	ldr	r3, [r4, #32]
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004c86:	466a      	mov	r2, sp
	tmp[7] = product[8];
 1004c88:	9307      	str	r3, [sp, #28]
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004c8a:	4630      	mov	r0, r6
 1004c8c:	2308      	movs	r3, #8
 1004c8e:	f011 f801 	bl	1015c94 <uECC_vli_add>

	/* d1 */
	tmp[0] = product[11];
 1004c92:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	tmp[1] = product[12];
	tmp[2] = product[13];
	tmp[3] = tmp[4] = tmp[5] = 0;
	tmp[6] = product[8];
	tmp[7] = product[10];
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004c94:	466a      	mov	r2, sp
	tmp[0] = product[11];
 1004c96:	9300      	str	r3, [sp, #0]
	tmp[1] = product[12];
 1004c98:	6b23      	ldr	r3, [r4, #48]	; 0x30
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004c9a:	4405      	add	r5, r0
	tmp[1] = product[12];
 1004c9c:	9301      	str	r3, [sp, #4]
	tmp[2] = product[13];
 1004c9e:	6b63      	ldr	r3, [r4, #52]	; 0x34
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004ca0:	4630      	mov	r0, r6
	tmp[2] = product[13];
 1004ca2:	9302      	str	r3, [sp, #8]
	tmp[6] = product[8];
 1004ca4:	6a23      	ldr	r3, [r4, #32]
	tmp[3] = tmp[4] = tmp[5] = 0;
 1004ca6:	e9cd 7704 	strd	r7, r7, [sp, #16]
	tmp[6] = product[8];
 1004caa:	9306      	str	r3, [sp, #24]
	tmp[7] = product[10];
 1004cac:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	tmp[3] = tmp[4] = tmp[5] = 0;
 1004cae:	9703      	str	r7, [sp, #12]
	tmp[7] = product[10];
 1004cb0:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004cb2:	2308      	movs	r3, #8
 1004cb4:	f011 f91d 	bl	1015ef2 <uECC_vli_sub>

	/* d2 */
	tmp[0] = product[12];
 1004cb8:	6b23      	ldr	r3, [r4, #48]	; 0x30
	tmp[2] = product[14];
	tmp[3] = product[15];
	tmp[4] = tmp[5] = 0;
	tmp[6] = product[9];
	tmp[7] = product[11];
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004cba:	466a      	mov	r2, sp
	tmp[0] = product[12];
 1004cbc:	9300      	str	r3, [sp, #0]
	tmp[1] = product[13];
 1004cbe:	6b63      	ldr	r3, [r4, #52]	; 0x34
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004cc0:	1a2d      	subs	r5, r5, r0
	tmp[1] = product[13];
 1004cc2:	9301      	str	r3, [sp, #4]
	tmp[2] = product[14];
 1004cc4:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004cc6:	4630      	mov	r0, r6
	tmp[2] = product[14];
 1004cc8:	9302      	str	r3, [sp, #8]
	tmp[3] = product[15];
 1004cca:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	tmp[4] = tmp[5] = 0;
 1004ccc:	e9cd 7704 	strd	r7, r7, [sp, #16]
	tmp[3] = product[15];
 1004cd0:	9303      	str	r3, [sp, #12]
	tmp[6] = product[9];
 1004cd2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 1004cd4:	9306      	str	r3, [sp, #24]
	tmp[7] = product[11];
 1004cd6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 1004cd8:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004cda:	2308      	movs	r3, #8
 1004cdc:	f011 f909 	bl	1015ef2 <uECC_vli_sub>

	/* d3 */
	tmp[0] = product[13];
 1004ce0:	6b63      	ldr	r3, [r4, #52]	; 0x34
	tmp[3] = product[8];
	tmp[4] = product[9];
	tmp[5] = product[10];
	tmp[6] = 0;
	tmp[7] = product[12];
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004ce2:	466a      	mov	r2, sp
	tmp[0] = product[13];
 1004ce4:	9300      	str	r3, [sp, #0]
	tmp[1] = product[14];
 1004ce6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004ce8:	1a2d      	subs	r5, r5, r0
	tmp[1] = product[14];
 1004cea:	9301      	str	r3, [sp, #4]
	tmp[2] = product[15];
 1004cec:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004cee:	4630      	mov	r0, r6
	tmp[2] = product[15];
 1004cf0:	9302      	str	r3, [sp, #8]
	tmp[3] = product[8];
 1004cf2:	6a23      	ldr	r3, [r4, #32]
 1004cf4:	9303      	str	r3, [sp, #12]
	tmp[4] = product[9];
 1004cf6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 1004cf8:	9304      	str	r3, [sp, #16]
	tmp[5] = product[10];
 1004cfa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	tmp[6] = 0;
 1004cfc:	e9cd 3705 	strd	r3, r7, [sp, #20]
	tmp[7] = product[12];
 1004d00:	6b23      	ldr	r3, [r4, #48]	; 0x30
 1004d02:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004d04:	2308      	movs	r3, #8
 1004d06:	f011 f8f4 	bl	1015ef2 <uECC_vli_sub>

	/* d4 */
	tmp[0] = product[14];
 1004d0a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004d0c:	1a2d      	subs	r5, r5, r0
	tmp[0] = product[14];
 1004d0e:	9300      	str	r3, [sp, #0]
	tmp[1] = product[15];
 1004d10:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	tmp[3] = product[9];
	tmp[4] = product[10];
	tmp[5] = product[11];
	tmp[6] = 0;
	tmp[7] = product[13];
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004d12:	466a      	mov	r2, sp
	tmp[2] = 0;
 1004d14:	e9cd 3701 	strd	r3, r7, [sp, #4]
	tmp[3] = product[9];
 1004d18:	6a63      	ldr	r3, [r4, #36]	; 0x24
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004d1a:	4630      	mov	r0, r6
	tmp[3] = product[9];
 1004d1c:	9303      	str	r3, [sp, #12]
	tmp[4] = product[10];
 1004d1e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1004d20:	9304      	str	r3, [sp, #16]
	tmp[5] = product[11];
 1004d22:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	tmp[6] = 0;
 1004d24:	e9cd 3705 	strd	r3, r7, [sp, #20]
	tmp[7] = product[13];
 1004d28:	6b63      	ldr	r3, [r4, #52]	; 0x34
 1004d2a:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004d2c:	2308      	movs	r3, #8
 1004d2e:	f011 f8e0 	bl	1015ef2 <uECC_vli_sub>

	if (carry < 0) {
 1004d32:	1a2d      	subs	r5, r5, r0
 1004d34:	d410      	bmi.n	1004d58 <vli_mmod_fast_secp256r1+0x188>
			carry += uECC_vli_add(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
		}
		while (carry < 0);
	} else  {
		while (carry || 
		       uECC_vli_cmp_unsafe(curve_secp256r1.p, result, NUM_ECC_WORDS) != 1) {
 1004d36:	4c0d      	ldr	r4, [pc, #52]	; (1004d6c <vli_mmod_fast_secp256r1+0x19c>)
		while (carry || 
 1004d38:	b935      	cbnz	r5, 1004d48 <vli_mmod_fast_secp256r1+0x178>
		       uECC_vli_cmp_unsafe(curve_secp256r1.p, result, NUM_ECC_WORDS) != 1) {
 1004d3a:	2208      	movs	r2, #8
 1004d3c:	4631      	mov	r1, r6
 1004d3e:	4620      	mov	r0, r4
 1004d40:	f011 f8ad 	bl	1015e9e <uECC_vli_cmp_unsafe>
		while (carry || 
 1004d44:	2801      	cmp	r0, #1
 1004d46:	d00f      	beq.n	1004d68 <vli_mmod_fast_secp256r1+0x198>
			carry -= uECC_vli_sub(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
 1004d48:	2308      	movs	r3, #8
 1004d4a:	4622      	mov	r2, r4
 1004d4c:	4631      	mov	r1, r6
 1004d4e:	4630      	mov	r0, r6
 1004d50:	f011 f8cf 	bl	1015ef2 <uECC_vli_sub>
 1004d54:	1a2d      	subs	r5, r5, r0
 1004d56:	e7ef      	b.n	1004d38 <vli_mmod_fast_secp256r1+0x168>
			carry += uECC_vli_add(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
 1004d58:	4a04      	ldr	r2, [pc, #16]	; (1004d6c <vli_mmod_fast_secp256r1+0x19c>)
 1004d5a:	2308      	movs	r3, #8
 1004d5c:	4631      	mov	r1, r6
 1004d5e:	4630      	mov	r0, r6
 1004d60:	f010 ff98 	bl	1015c94 <uECC_vli_add>
		while (carry < 0);
 1004d64:	182d      	adds	r5, r5, r0
 1004d66:	d4f8      	bmi.n	1004d5a <vli_mmod_fast_secp256r1+0x18a>
		}
	}
}
 1004d68:	b009      	add	sp, #36	; 0x24
 1004d6a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 1004d6c:	010183f4 	.word	0x010183f4

01004d70 <arch_swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
 1004d70:	4a09      	ldr	r2, [pc, #36]	; (1004d98 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
 1004d72:	490a      	ldr	r1, [pc, #40]	; (1004d9c <arch_swap+0x2c>)
	_current->arch.basepri = key;
 1004d74:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
 1004d76:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
 1004d78:	66d8      	str	r0, [r3, #108]	; 0x6c
	_current->arch.swap_return_value = _k_neg_eagain;
 1004d7a:	6719      	str	r1, [r3, #112]	; 0x70

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 1004d7c:	4908      	ldr	r1, [pc, #32]	; (1004da0 <arch_swap+0x30>)
 1004d7e:	684b      	ldr	r3, [r1, #4]
 1004d80:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 1004d84:	604b      	str	r3, [r1, #4]
 1004d86:	2300      	movs	r3, #0
 1004d88:	f383 8811 	msr	BASEPRI, r3
 1004d8c:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
 1004d90:	6893      	ldr	r3, [r2, #8]
}
 1004d92:	6f18      	ldr	r0, [r3, #112]	; 0x70
 1004d94:	4770      	bx	lr
 1004d96:	bf00      	nop
 1004d98:	21007f8c 	.word	0x21007f8c
 1004d9c:	01018f90 	.word	0x01018f90
 1004da0:	e000ed00 	.word	0xe000ed00

01004da4 <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
 1004da4:	490f      	ldr	r1, [pc, #60]	; (1004de4 <z_arm_pendsv+0x40>)
    ldr r2, [r1, #_kernel_offset_to_current]
 1004da6:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
 1004da8:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
 1004dac:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
 1004dae:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
 1004db2:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 1004db6:	2020      	movs	r0, #32
    msr BASEPRI, r0
 1004db8:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
 1004dbc:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
 1004dc0:	4f09      	ldr	r7, [pc, #36]	; (1004de8 <z_arm_pendsv+0x44>)
    ldr v3, =_SCS_ICSR_UNPENDSV
 1004dc2:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
 1004dc6:	6a4a      	ldr	r2, [r1, #36]	; 0x24

    str r2, [r1, #_kernel_offset_to_current]
 1004dc8:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
 1004dca:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
 1004dcc:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
    movs r3, #0
 1004dce:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
 1004dd0:	66d3      	str	r3, [r2, #108]	; 0x6c
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
 1004dd2:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
 1004dd6:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
 1004dda:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
 1004dde:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
 1004de2:	4770      	bx	lr
    ldr r1, =_kernel
 1004de4:	21007f8c 	.word	0x21007f8c
    ldr v4, =_SCS_ICSR
 1004de8:	e000ed04 	.word	0xe000ed04

01004dec <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
 1004dec:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
 1004df0:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
 1004df2:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
 1004df6:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
 1004dfa:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
 1004dfc:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
 1004e00:	2902      	cmp	r1, #2
    beq _oops
 1004e02:	d0ff      	beq.n	1004e04 <_oops>

01004e04 <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
 1004e04:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
 1004e06:	f011 fd8d 	bl	1016924 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
 1004e0a:	bd01      	pop	{r0, pc}

01004e0c <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
 1004e0c:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
 1004e0e:	2b00      	cmp	r3, #0
 1004e10:	db08      	blt.n	1004e24 <arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 1004e12:	2201      	movs	r2, #1
 1004e14:	f000 001f 	and.w	r0, r0, #31
 1004e18:	fa02 f000 	lsl.w	r0, r2, r0
 1004e1c:	4a02      	ldr	r2, [pc, #8]	; (1004e28 <arch_irq_enable+0x1c>)
 1004e1e:	095b      	lsrs	r3, r3, #5
 1004e20:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
 1004e24:	4770      	bx	lr
 1004e26:	bf00      	nop
 1004e28:	e000e100 	.word	0xe000e100

01004e2c <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
 1004e2c:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
 1004e2e:	2b00      	cmp	r3, #0
 1004e30:	db0d      	blt.n	1004e4e <arch_irq_disable+0x22>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 1004e32:	2201      	movs	r2, #1
 1004e34:	f000 001f 	and.w	r0, r0, #31
 1004e38:	fa02 f000 	lsl.w	r0, r2, r0
 1004e3c:	095b      	lsrs	r3, r3, #5
 1004e3e:	4a04      	ldr	r2, [pc, #16]	; (1004e50 <arch_irq_disable+0x24>)
 1004e40:	3320      	adds	r3, #32
 1004e42:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 1004e46:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 1004e4a:	f3bf 8f6f 	isb	sy
}
 1004e4e:	4770      	bx	lr
 1004e50:	e000e100 	.word	0xe000e100

01004e54 <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
 1004e54:	4b05      	ldr	r3, [pc, #20]	; (1004e6c <arch_irq_is_enabled+0x18>)
 1004e56:	0942      	lsrs	r2, r0, #5
 1004e58:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 1004e5c:	2301      	movs	r3, #1
 1004e5e:	f000 001f 	and.w	r0, r0, #31
 1004e62:	fa03 f000 	lsl.w	r0, r3, r0
}
 1004e66:	4010      	ands	r0, r2
 1004e68:	4770      	bx	lr
 1004e6a:	bf00      	nop
 1004e6c:	e000e100 	.word	0xe000e100

01004e70 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
 1004e70:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 1004e72:	2b00      	cmp	r3, #0
	prio += _IRQ_PRIO_OFFSET;
 1004e74:	f101 0101 	add.w	r1, r1, #1
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1004e78:	bfac      	ite	ge
 1004e7a:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1004e7e:	4b06      	ldrlt	r3, [pc, #24]	; (1004e98 <z_arm_irq_priority_set+0x28>)
 1004e80:	ea4f 1141 	mov.w	r1, r1, lsl #5
 1004e84:	b2c9      	uxtb	r1, r1
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1004e86:	bfab      	itete	ge
 1004e88:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1004e8c:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1004e90:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1004e94:	5419      	strblt	r1, [r3, r0]
}
 1004e96:	4770      	bx	lr
 1004e98:	e000ed14 	.word	0xe000ed14

01004e9c <_arch_isr_direct_pm>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
}

#ifdef CONFIG_SYS_POWER_MANAGEMENT
void _arch_isr_direct_pm(void)
{
 1004e9c:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
 1004e9e:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
 1004ea0:	4b04      	ldr	r3, [pc, #16]	; (1004eb4 <_arch_isr_direct_pm+0x18>)
 1004ea2:	6a18      	ldr	r0, [r3, #32]
 1004ea4:	b118      	cbz	r0, 1004eae <_arch_isr_direct_pm+0x12>
		s32_t idle_val = _kernel.idle;

		_kernel.idle = 0;
 1004ea6:	2200      	movs	r2, #0
 1004ea8:	621a      	str	r2, [r3, #32]
		z_sys_power_save_idle_exit(idle_val);
 1004eaa:	f012 fc15 	bl	10176d8 <z_sys_power_save_idle_exit>

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
 1004eae:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
 1004eb0:	bd08      	pop	{r3, pc}
 1004eb2:	bf00      	nop
 1004eb4:	21007f8c 	.word	0x21007f8c

01004eb8 <arch_new_thread>:
#ifdef CONFIG_INIT_STACKS
	memset(stack, 0xaa, stack_size);
#endif
#if defined(CONFIG_THREAD_STACK_INFO)
	thread->stack_info.start = (uintptr_t)stack;
	thread->stack_info.size = stack_size;
 1004eb8:	e9c0 1218 	strd	r1, r2, [r0, #96]	; 0x60
			- MPU_GUARD_ALIGN_AND_SIZE;
		stackSize -= MPU_GUARD_ALIGN_AND_SIZE_FLOAT
			- MPU_GUARD_ALIGN_AND_SIZE;
	}
#endif
	stackEnd = pStackMem + stackSize;
 1004ebc:	440a      	add	r2, r1
	 *
	 * The initial carved stack frame only needs to contain the basic
	 * stack frame (state context), because no FP operations have been
	 * performed yet for this thread.
	 */
	pInitCtx = (struct __esf *)(Z_STACK_PTR_ALIGN(stackEnd -
 1004ebe:	3a20      	subs	r2, #32
 1004ec0:	f022 0207 	bic.w	r2, r2, #7
#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	pInitCtx->basic.pc &= 0xfffffffe;
#endif

	pInitCtx->basic.a1 = (u32_t)pEntry;
 1004ec4:	6013      	str	r3, [r2, #0]
	pInitCtx->basic.a2 = (u32_t)parameter1;
 1004ec6:	9b00      	ldr	r3, [sp, #0]
	pInitCtx->basic.pc &= 0xfffffffe;
 1004ec8:	4907      	ldr	r1, [pc, #28]	; (1004ee8 <arch_new_thread+0x30>)
	pInitCtx->basic.a2 = (u32_t)parameter1;
 1004eca:	6053      	str	r3, [r2, #4]
	pInitCtx->basic.a3 = (u32_t)parameter2;
 1004ecc:	9b01      	ldr	r3, [sp, #4]
	pInitCtx->basic.pc &= 0xfffffffe;
 1004ece:	f021 0101 	bic.w	r1, r1, #1
	pInitCtx->basic.a3 = (u32_t)parameter2;
 1004ed2:	6093      	str	r3, [r2, #8]
	pInitCtx->basic.a4 = (u32_t)parameter3;
 1004ed4:	9b02      	ldr	r3, [sp, #8]
	pInitCtx->basic.pc &= 0xfffffffe;
 1004ed6:	6191      	str	r1, [r2, #24]
	pInitCtx->basic.a4 = (u32_t)parameter3;
 1004ed8:	60d3      	str	r3, [r2, #12]

#if defined(CONFIG_CPU_CORTEX_M)
	pInitCtx->basic.xpsr =
 1004eda:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 1004ede:	61d3      	str	r3, [r2, #28]
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (u32_t)pInitCtx;

	thread->arch.basepri = 0;
 1004ee0:	2300      	movs	r3, #0
	thread->callee_saved.psp = (u32_t)pInitCtx;
 1004ee2:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
 1004ee4:	66c3      	str	r3, [r0, #108]	; 0x6c

	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
 1004ee6:	4770      	bx	lr
 1004ee8:	01014f6b 	.word	0x01014f6b

01004eec <arch_switch_to_main_thread>:

void arch_switch_to_main_thread(struct k_thread *main_thread,
				k_thread_stack_t *main_stack,
				size_t main_stack_size,
				k_thread_entry_t _main)
{
 1004eec:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1004eee:	460c      	mov	r4, r1
 1004ef0:	4617      	mov	r7, r2
 1004ef2:	4606      	mov	r6, r0
 1004ef4:	461d      	mov	r5, r3
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
 1004ef6:	f000 fb07 	bl	1005508 <z_arm_configure_static_mpu_regions>
	start_of_main_stack =
		Z_THREAD_STACK_BUFFER(main_stack) + main_stack_size;

	start_of_main_stack = (char *)Z_STACK_PTR_ALIGN(start_of_main_stack);

	_current = main_thread;
 1004efa:	4b09      	ldr	r3, [pc, #36]	; (1004f20 <arch_switch_to_main_thread+0x34>)
	start_of_main_stack =
 1004efc:	443c      	add	r4, r7
	start_of_main_stack = (char *)Z_STACK_PTR_ALIGN(start_of_main_stack);
 1004efe:	f024 0407 	bic.w	r4, r4, #7
	_current = main_thread;
 1004f02:	609e      	str	r6, [r3, #8]

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
 1004f04:	4628      	mov	r0, r5
 1004f06:	f384 8809 	msr	PSP, r4
 1004f0a:	2100      	movs	r1, #0
 1004f0c:	b663      	cpsie	if
 1004f0e:	f381 8811 	msr	BASEPRI, r1
 1004f12:	f3bf 8f6f 	isb	sy
 1004f16:	2200      	movs	r2, #0
 1004f18:	2300      	movs	r3, #0
 1004f1a:	f010 f826 	bl	1014f6a <z_thread_entry>
	:
	: "r" (_main), "r" (start_of_main_stack)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
 1004f1e:	bf00      	nop
 1004f20:	21007f8c 	.word	0x21007f8c

01004f24 <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
 1004f24:	4901      	ldr	r1, [pc, #4]	; (1004f2c <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
 1004f26:	2210      	movs	r2, #16
	str	r2, [r1]
 1004f28:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
 1004f2a:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
 1004f2c:	e000ed10 	.word	0xe000ed10

01004f30 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
 1004f30:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
 1004f32:	4040      	eors	r0, r0
	msr	BASEPRI, r0
 1004f34:	f380 8811 	msr	BASEPRI, r0
	isb
 1004f38:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
 1004f3c:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
 1004f40:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
 1004f42:	b662      	cpsie	i
	isb
 1004f44:	f3bf 8f6f 	isb	sy

	bx	lr
 1004f48:	4770      	bx	lr
 1004f4a:	bf00      	nop

01004f4c <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
 1004f4c:	b573      	push	{r0, r1, r4, r5, r6, lr}
 1004f4e:	4606      	mov	r6, r0

	if (esf != NULL) {
 1004f50:	460c      	mov	r4, r1
 1004f52:	b301      	cbz	r1, 1004f96 <z_arm_fatal_error+0x4a>
	return ((u8_t *)data - (u8_t *)__log_const_start)/
 1004f54:	4b13      	ldr	r3, [pc, #76]	; (1004fa4 <z_arm_fatal_error+0x58>)
 1004f56:	4d14      	ldr	r5, [pc, #80]	; (1004fa8 <z_arm_fatal_error+0x5c>)
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
 1004f58:	4814      	ldr	r0, [pc, #80]	; (1004fac <z_arm_fatal_error+0x60>)
 1004f5a:	1aed      	subs	r5, r5, r3
 1004f5c:	08ed      	lsrs	r5, r5, #3
 1004f5e:	01ad      	lsls	r5, r5, #6
 1004f60:	f045 0501 	orr.w	r5, r5, #1
 1004f64:	f8ad 5000 	strh.w	r5, [sp]
 1004f68:	e9d1 2301 	ldrd	r2, r3, [r1, #4]
 1004f6c:	6809      	ldr	r1, [r1, #0]
 1004f6e:	f010 faf8 	bl	1015562 <log_3>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
 1004f72:	f8ad 5000 	strh.w	r5, [sp]
 1004f76:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
 1004f7a:	68e1      	ldr	r1, [r4, #12]
 1004f7c:	480c      	ldr	r0, [pc, #48]	; (1004fb0 <z_arm_fatal_error+0x64>)
 1004f7e:	f010 faf0 	bl	1015562 <log_3>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
 1004f82:	462a      	mov	r2, r5
 1004f84:	69e1      	ldr	r1, [r4, #28]
 1004f86:	480b      	ldr	r0, [pc, #44]	; (1004fb4 <z_arm_fatal_error+0x68>)
 1004f88:	f010 fabe 	bl	1015508 <log_1>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
 1004f8c:	462a      	mov	r2, r5
 1004f8e:	69a1      	ldr	r1, [r4, #24]
 1004f90:	4809      	ldr	r0, [pc, #36]	; (1004fb8 <z_arm_fatal_error+0x6c>)
 1004f92:	f010 fab9 	bl	1015508 <log_1>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
 1004f96:	4621      	mov	r1, r4
 1004f98:	4630      	mov	r0, r6
}
 1004f9a:	b002      	add	sp, #8
 1004f9c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_fatal_error(reason, esf);
 1004fa0:	f00e bed8 	b.w	1013d54 <z_fatal_error>
 1004fa4:	01018208 	.word	0x01018208
 1004fa8:	01018310 	.word	0x01018310
 1004fac:	01019403 	.word	0x01019403
 1004fb0:	01019432 	.word	0x01019432
 1004fb4:	01019461 	.word	0x01019461
 1004fb8:	01019470 	.word	0x01019470

01004fbc <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
 1004fbc:	bf30      	wfi
    b z_SysNmiOnReset
 1004fbe:	f7ff bffd 	b.w	1004fbc <z_SysNmiOnReset>
 1004fc2:	bf00      	nop

01004fc4 <z_arm_prep_c>:
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
 1004fc4:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
 1004fc6:	4b08      	ldr	r3, [pc, #32]	; (1004fe8 <z_arm_prep_c+0x24>)
 1004fc8:	4a08      	ldr	r2, [pc, #32]	; (1004fec <z_arm_prep_c+0x28>)
 1004fca:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 1004fce:	6093      	str	r3, [r2, #8]
  __ASM volatile ("dsb 0xF":::"memory");
 1004fd0:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 1004fd4:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
 1004fd8:	f00e ff3a 	bl	1013e50 <z_bss_zero>
	z_data_copy();
 1004fdc:	f00e ff42 	bl	1013e64 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
 1004fe0:	f000 fa60 	bl	10054a4 <z_arm_interrupt_init>
	z_cstart();
 1004fe4:	f00e ff7c 	bl	1013ee0 <z_cstart>
 1004fe8:	01000000 	.word	0x01000000
 1004fec:	e000ed00 	.word	0xe000ed00

01004ff0 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
 1004ff0:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
 1004ff2:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
 1004ff4:	4a0b      	ldr	r2, [pc, #44]	; (1005024 <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
 1004ff6:	6a10      	ldr	r0, [r2, #32]
	cmp r0, #0
 1004ff8:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_sys_power_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
 1004ffa:	bf1e      	ittt	ne
	movne	r1, #0
 1004ffc:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
 1004ffe:	6211      	strne	r1, [r2, #32]
		blne	z_sys_power_save_idle_exit
 1005000:	f012 fb6a 	blne	10176d8 <z_sys_power_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
 1005004:	b662      	cpsie	i
#endif

#endif /* CONFIG_SYS_POWER_MANAGEMENT */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
 1005006:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
 100500a:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
 100500e:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	 * interface function.
	 */
	cpsie i
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
 1005012:	4905      	ldr	r1, [pc, #20]	; (1005028 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
 1005014:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
 1005016:	c909      	ldmia	r1!, {r0, r3}
#ifdef CONFIG_EXECUTION_BENCHMARKING
	push {r0, r3}	/* Save r0 and r3 into stack */
	bl read_timer_end_of_isr
	pop {r0, r3}	/* Restore r0 and r3 regs */
#endif /* CONFIG_EXECUTION_BENCHMARKING */
	blx r3		/* call ISR */
 1005018:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
 100501a:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
 100501e:	4903      	ldr	r1, [pc, #12]	; (100502c <_isr_wrapper+0x3c>)
	bx r1
 1005020:	4708      	bx	r1
 1005022:	0000      	.short	0x0000
	ldr r2, =_kernel
 1005024:	21007f8c 	.word	0x21007f8c
	ldr r1, =_sw_isr_table
 1005028:	01018118 	.word	0x01018118
	ldr r1, =z_arm_int_exit
 100502c:	01005465 	.word	0x01005465

01005030 <__start>:
 * search for a __start symbol instead, so create that alias here.
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
 1005030:	f010 fa18 	bl	1015464 <z_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 1005034:	2020      	movs	r0, #32
    msr BASEPRI, r0
 1005036:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
 100503a:	4808      	ldr	r0, [pc, #32]	; (100505c <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
 100503c:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
 1005040:	1840      	adds	r0, r0, r1
    msr PSP, r0
 1005042:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
 1005046:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
 100504a:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
 100504c:	4308      	orrs	r0, r1
    msr CONTROL, r0
 100504e:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
 1005052:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
 1005056:	f7ff ffb5 	bl	1004fc4 <z_arm_prep_c>
 100505a:	0000      	.short	0x0000
    ldr r0, =z_interrupt_stacks
 100505c:	210098e8 	.word	0x210098e8

01005060 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
 1005060:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
 1005064:	f3ef 8109 	mrs	r1, PSP
	mov r2, lr /* EXC_RETURN */
 1005068:	4672      	mov	r2, lr

	push {r0, lr}
 100506a:	b501      	push	{r0, lr}

	bl z_arm_fault
 100506c:	f000 f926 	bl	10052bc <z_arm_fault>

	pop {r0, pc}
 1005070:	bd01      	pop	{r0, pc}
 1005072:	bf00      	nop

01005074 <usage_fault.isra.0>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t usage_fault(const z_arch_esf_t *esf)
 1005074:	b570      	push	{r4, r5, r6, lr}
 1005076:	4b27      	ldr	r3, [pc, #156]	; (1005114 <usage_fault.isra.0+0xa0>)
 1005078:	4c27      	ldr	r4, [pc, #156]	; (1005118 <usage_fault.isra.0+0xa4>)
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
 100507a:	4d28      	ldr	r5, [pc, #160]	; (100511c <usage_fault.isra.0+0xa8>)
 100507c:	1ae4      	subs	r4, r4, r3
 100507e:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** USAGE FAULT *****");
 1005080:	01a4      	lsls	r4, r4, #6
 1005082:	f044 0601 	orr.w	r6, r4, #1
 1005086:	4631      	mov	r1, r6
 1005088:	4825      	ldr	r0, [pc, #148]	; (1005120 <usage_fault.isra.0+0xac>)
 100508a:	f010 fa30 	bl	10154ee <log_0>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
 100508e:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 1005090:	0192      	lsls	r2, r2, #6
 1005092:	d503      	bpl.n	100509c <usage_fault.isra.0+0x28>
		PR_FAULT_INFO("  Division by zero");
 1005094:	4631      	mov	r1, r6
 1005096:	4823      	ldr	r0, [pc, #140]	; (1005124 <usage_fault.isra.0+0xb0>)
 1005098:	f010 fa29 	bl	10154ee <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
 100509c:	6aab      	ldr	r3, [r5, #40]	; 0x28
 100509e:	01db      	lsls	r3, r3, #7
 10050a0:	d504      	bpl.n	10050ac <usage_fault.isra.0+0x38>
		PR_FAULT_INFO("  Unaligned memory access");
 10050a2:	4821      	ldr	r0, [pc, #132]	; (1005128 <usage_fault.isra.0+0xb4>)
 10050a4:	f044 0101 	orr.w	r1, r4, #1
 10050a8:	f010 fa21 	bl	10154ee <log_0>
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
 10050ac:	4d1b      	ldr	r5, [pc, #108]	; (100511c <usage_fault.isra.0+0xa8>)
 10050ae:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 10050b0:	02d6      	lsls	r6, r2, #11
 10050b2:	d504      	bpl.n	10050be <usage_fault.isra.0+0x4a>
		PR_FAULT_INFO("  Stack overflow (context area not valid)");
 10050b4:	481d      	ldr	r0, [pc, #116]	; (100512c <usage_fault.isra.0+0xb8>)
 10050b6:	f044 0101 	orr.w	r1, r4, #1
 10050ba:	f010 fa18 	bl	10154ee <log_0>
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
 10050be:	6aab      	ldr	r3, [r5, #40]	; 0x28
 10050c0:	0318      	lsls	r0, r3, #12
 10050c2:	d504      	bpl.n	10050ce <usage_fault.isra.0+0x5a>
		PR_FAULT_INFO("  No coprocessor instructions");
 10050c4:	481a      	ldr	r0, [pc, #104]	; (1005130 <usage_fault.isra.0+0xbc>)
 10050c6:	f044 0101 	orr.w	r1, r4, #1
 10050ca:	f010 fa10 	bl	10154ee <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
 10050ce:	4d13      	ldr	r5, [pc, #76]	; (100511c <usage_fault.isra.0+0xa8>)
 10050d0:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 10050d2:	0351      	lsls	r1, r2, #13
 10050d4:	d504      	bpl.n	10050e0 <usage_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
 10050d6:	4817      	ldr	r0, [pc, #92]	; (1005134 <usage_fault.isra.0+0xc0>)
 10050d8:	f044 0101 	orr.w	r1, r4, #1
 10050dc:	f010 fa07 	bl	10154ee <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
 10050e0:	6aab      	ldr	r3, [r5, #40]	; 0x28
 10050e2:	039a      	lsls	r2, r3, #14
 10050e4:	d504      	bpl.n	10050f0 <usage_fault.isra.0+0x7c>
		PR_FAULT_INFO("  Illegal use of the EPSR");
 10050e6:	4814      	ldr	r0, [pc, #80]	; (1005138 <usage_fault.isra.0+0xc4>)
 10050e8:	f044 0101 	orr.w	r1, r4, #1
 10050ec:	f010 f9ff 	bl	10154ee <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
 10050f0:	4d0a      	ldr	r5, [pc, #40]	; (100511c <usage_fault.isra.0+0xa8>)
 10050f2:	6aab      	ldr	r3, [r5, #40]	; 0x28
 10050f4:	03db      	lsls	r3, r3, #15
 10050f6:	d504      	bpl.n	1005102 <usage_fault.isra.0+0x8e>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
 10050f8:	4810      	ldr	r0, [pc, #64]	; (100513c <usage_fault.isra.0+0xc8>)
 10050fa:	f044 0101 	orr.w	r1, r4, #1
 10050fe:	f010 f9f6 	bl	10154ee <log_0>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
 1005102:	6aab      	ldr	r3, [r5, #40]	; 0x28

	return reason;
}
 1005104:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
 1005106:	ea6f 4303 	mvn.w	r3, r3, lsl #16
 100510a:	ea6f 4313 	mvn.w	r3, r3, lsr #16
 100510e:	62ab      	str	r3, [r5, #40]	; 0x28
}
 1005110:	bd70      	pop	{r4, r5, r6, pc}
 1005112:	bf00      	nop
 1005114:	01018208 	.word	0x01018208
 1005118:	01018310 	.word	0x01018310
 100511c:	e000ed00 	.word	0xe000ed00
 1005120:	0101949e 	.word	0x0101949e
 1005124:	010194b6 	.word	0x010194b6
 1005128:	010194c9 	.word	0x010194c9
 100512c:	010194e3 	.word	0x010194e3
 1005130:	0101950d 	.word	0x0101950d
 1005134:	0101952b 	.word	0x0101952b
 1005138:	01019550 	.word	0x01019550
 100513c:	0101956a 	.word	0x0101956a

01005140 <mem_manage_fault.isra.0>:
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
 1005140:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1005144:	4b22      	ldr	r3, [pc, #136]	; (10051d0 <mem_manage_fault.isra.0+0x90>)
 1005146:	4c23      	ldr	r4, [pc, #140]	; (10051d4 <mem_manage_fault.isra.0+0x94>)
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
 1005148:	4d23      	ldr	r5, [pc, #140]	; (10051d8 <mem_manage_fault.isra.0+0x98>)
 100514a:	1ae4      	subs	r4, r4, r3
 100514c:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** MPU FAULT *****");
 100514e:	01a4      	lsls	r4, r4, #6
 1005150:	f044 0801 	orr.w	r8, r4, #1
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
 1005154:	4607      	mov	r7, r0
 1005156:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
 1005158:	4820      	ldr	r0, [pc, #128]	; (10051dc <mem_manage_fault.isra.0+0x9c>)
 100515a:	4641      	mov	r1, r8
 100515c:	f010 f9c7 	bl	10154ee <log_0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
 1005160:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 1005162:	06d3      	lsls	r3, r2, #27
 1005164:	d503      	bpl.n	100516e <mem_manage_fault.isra.0+0x2e>
		PR_FAULT_INFO("  Stacking error (context area might be"
 1005166:	4641      	mov	r1, r8
 1005168:	481d      	ldr	r0, [pc, #116]	; (10051e0 <mem_manage_fault.isra.0+0xa0>)
 100516a:	f010 f9c0 	bl	10154ee <log_0>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
 100516e:	6aab      	ldr	r3, [r5, #40]	; 0x28
 1005170:	0718      	lsls	r0, r3, #28
 1005172:	d504      	bpl.n	100517e <mem_manage_fault.isra.0+0x3e>
		PR_FAULT_INFO("  Unstacking error");
 1005174:	481b      	ldr	r0, [pc, #108]	; (10051e4 <mem_manage_fault.isra.0+0xa4>)
 1005176:	f044 0101 	orr.w	r1, r4, #1
 100517a:	f010 f9b8 	bl	10154ee <log_0>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
 100517e:	4d16      	ldr	r5, [pc, #88]	; (10051d8 <mem_manage_fault.isra.0+0x98>)
 1005180:	6aab      	ldr	r3, [r5, #40]	; 0x28
 1005182:	0799      	lsls	r1, r3, #30
 1005184:	d512      	bpl.n	10051ac <mem_manage_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Data Access Violation");
 1005186:	f044 0801 	orr.w	r8, r4, #1
 100518a:	4641      	mov	r1, r8
 100518c:	4816      	ldr	r0, [pc, #88]	; (10051e8 <mem_manage_fault.isra.0+0xa8>)
 100518e:	f010 f9ae 	bl	10154ee <log_0>
		mmfar = SCB->MMFAR;
 1005192:	6b69      	ldr	r1, [r5, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
 1005194:	6aab      	ldr	r3, [r5, #40]	; 0x28
 1005196:	061a      	lsls	r2, r3, #24
 1005198:	d508      	bpl.n	10051ac <mem_manage_fault.isra.0+0x6c>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
 100519a:	4642      	mov	r2, r8
 100519c:	4813      	ldr	r0, [pc, #76]	; (10051ec <mem_manage_fault.isra.0+0xac>)
 100519e:	f010 f9b3 	bl	1015508 <log_1>
			if (from_hard_fault) {
 10051a2:	b11f      	cbz	r7, 10051ac <mem_manage_fault.isra.0+0x6c>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
 10051a4:	6aab      	ldr	r3, [r5, #40]	; 0x28
 10051a6:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 10051aa:	62ab      	str	r3, [r5, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
 10051ac:	4d0a      	ldr	r5, [pc, #40]	; (10051d8 <mem_manage_fault.isra.0+0x98>)
 10051ae:	6aab      	ldr	r3, [r5, #40]	; 0x28
 10051b0:	07db      	lsls	r3, r3, #31
 10051b2:	d504      	bpl.n	10051be <mem_manage_fault.isra.0+0x7e>
		PR_FAULT_INFO("  Instruction Access Violation");
 10051b4:	480e      	ldr	r0, [pc, #56]	; (10051f0 <mem_manage_fault.isra.0+0xb0>)
 10051b6:	f044 0101 	orr.w	r1, r4, #1
 10051ba:	f010 f998 	bl	10154ee <log_0>
	*recoverable = memory_fault_recoverable(esf);
 10051be:	2000      	movs	r0, #0
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
 10051c0:	6aab      	ldr	r3, [r5, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
 10051c2:	6aab      	ldr	r3, [r5, #40]	; 0x28
 10051c4:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
 10051c8:	62ab      	str	r3, [r5, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
 10051ca:	7030      	strb	r0, [r6, #0]
}
 10051cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 10051d0:	01018208 	.word	0x01018208
 10051d4:	01018310 	.word	0x01018310
 10051d8:	e000ed00 	.word	0xe000ed00
 10051dc:	01019595 	.word	0x01019595
 10051e0:	010195ab 	.word	0x010195ab
 10051e4:	010195de 	.word	0x010195de
 10051e8:	010195f1 	.word	0x010195f1
 10051ec:	01019609 	.word	0x01019609
 10051f0:	0101961f 	.word	0x0101961f

010051f4 <bus_fault.isra.0>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
 10051f4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 10051f8:	4b26      	ldr	r3, [pc, #152]	; (1005294 <bus_fault.isra.0+0xa0>)
 10051fa:	4c27      	ldr	r4, [pc, #156]	; (1005298 <bus_fault.isra.0+0xa4>)
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
 10051fc:	4d27      	ldr	r5, [pc, #156]	; (100529c <bus_fault.isra.0+0xa8>)
 10051fe:	1ae4      	subs	r4, r4, r3
 1005200:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** BUS FAULT *****");
 1005202:	01a4      	lsls	r4, r4, #6
 1005204:	f044 0801 	orr.w	r8, r4, #1
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
 1005208:	4607      	mov	r7, r0
 100520a:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
 100520c:	4824      	ldr	r0, [pc, #144]	; (10052a0 <bus_fault.isra.0+0xac>)
 100520e:	4641      	mov	r1, r8
 1005210:	f010 f96d 	bl	10154ee <log_0>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
 1005214:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 1005216:	04d1      	lsls	r1, r2, #19
 1005218:	d503      	bpl.n	1005222 <bus_fault.isra.0+0x2e>
		PR_FAULT_INFO("  Stacking error");
 100521a:	4641      	mov	r1, r8
 100521c:	4821      	ldr	r0, [pc, #132]	; (10052a4 <bus_fault.isra.0+0xb0>)
 100521e:	f010 f966 	bl	10154ee <log_0>
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
 1005222:	6aab      	ldr	r3, [r5, #40]	; 0x28
 1005224:	051a      	lsls	r2, r3, #20
 1005226:	d504      	bpl.n	1005232 <bus_fault.isra.0+0x3e>
		PR_FAULT_INFO("  Unstacking error");
 1005228:	481f      	ldr	r0, [pc, #124]	; (10052a8 <bus_fault.isra.0+0xb4>)
 100522a:	f044 0101 	orr.w	r1, r4, #1
 100522e:	f010 f95e 	bl	10154ee <log_0>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
 1005232:	4d1a      	ldr	r5, [pc, #104]	; (100529c <bus_fault.isra.0+0xa8>)
 1005234:	6aab      	ldr	r3, [r5, #40]	; 0x28
 1005236:	059b      	lsls	r3, r3, #22
 1005238:	d512      	bpl.n	1005260 <bus_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Precise data bus error");
 100523a:	f044 0801 	orr.w	r8, r4, #1
 100523e:	4641      	mov	r1, r8
 1005240:	481a      	ldr	r0, [pc, #104]	; (10052ac <bus_fault.isra.0+0xb8>)
 1005242:	f010 f954 	bl	10154ee <log_0>
		STORE_xFAR(bfar, SCB->BFAR);
 1005246:	6ba9      	ldr	r1, [r5, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
 1005248:	6aab      	ldr	r3, [r5, #40]	; 0x28
 100524a:	0418      	lsls	r0, r3, #16
 100524c:	d508      	bpl.n	1005260 <bus_fault.isra.0+0x6c>
			PR_EXC("  BFAR Address: 0x%x", bfar);
 100524e:	4642      	mov	r2, r8
 1005250:	4817      	ldr	r0, [pc, #92]	; (10052b0 <bus_fault.isra.0+0xbc>)
 1005252:	f010 f959 	bl	1015508 <log_1>
			if (from_hard_fault) {
 1005256:	b11f      	cbz	r7, 1005260 <bus_fault.isra.0+0x6c>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
 1005258:	6aab      	ldr	r3, [r5, #40]	; 0x28
 100525a:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 100525e:	62ab      	str	r3, [r5, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
 1005260:	4d0e      	ldr	r5, [pc, #56]	; (100529c <bus_fault.isra.0+0xa8>)
 1005262:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 1005264:	0552      	lsls	r2, r2, #21
 1005266:	d504      	bpl.n	1005272 <bus_fault.isra.0+0x7e>
		PR_FAULT_INFO("  Imprecise data bus error");
 1005268:	4812      	ldr	r0, [pc, #72]	; (10052b4 <bus_fault.isra.0+0xc0>)
 100526a:	f044 0101 	orr.w	r1, r4, #1
 100526e:	f010 f93e 	bl	10154ee <log_0>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
 1005272:	6aab      	ldr	r3, [r5, #40]	; 0x28
 1005274:	05db      	lsls	r3, r3, #23
 1005276:	d504      	bpl.n	1005282 <bus_fault.isra.0+0x8e>
		PR_FAULT_INFO("  Instruction bus error");
 1005278:	480f      	ldr	r0, [pc, #60]	; (10052b8 <bus_fault.isra.0+0xc4>)
 100527a:	f044 0101 	orr.w	r1, r4, #1
 100527e:	f010 f936 	bl	10154ee <log_0>
	*recoverable = memory_fault_recoverable(esf);
 1005282:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
 1005284:	4a05      	ldr	r2, [pc, #20]	; (100529c <bus_fault.isra.0+0xa8>)
 1005286:	6a93      	ldr	r3, [r2, #40]	; 0x28
 1005288:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
 100528c:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
 100528e:	7030      	strb	r0, [r6, #0]
}
 1005290:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 1005294:	01018208 	.word	0x01018208
 1005298:	01018310 	.word	0x01018310
 100529c:	e000ed00 	.word	0xe000ed00
 10052a0:	0101963e 	.word	0x0101963e
 10052a4:	01019654 	.word	0x01019654
 10052a8:	010195de 	.word	0x010195de
 10052ac:	01019665 	.word	0x01019665
 10052b0:	0101967e 	.word	0x0101967e
 10052b4:	01019693 	.word	0x01019693
 10052b8:	010196ae 	.word	0x010196ae

010052bc <z_arm_fault>:
 * @param psp PSP value immediately after the exception occurred
 * @param exc_return EXC_RETURN value present in LR after exception entry.
 *
 */
void z_arm_fault(u32_t msp, u32_t psp, u32_t exc_return)
{
 10052bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 10052c0:	4b56      	ldr	r3, [pc, #344]	; (100541c <z_arm_fault+0x160>)
{
 10052c2:	460f      	mov	r7, r1
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 10052c4:	685e      	ldr	r6, [r3, #4]
 10052c6:	2500      	movs	r5, #0
{
 10052c8:	b08a      	sub	sp, #40	; 0x28
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 10052ca:	f3c6 0408 	ubfx	r4, r6, #0, #9
 10052ce:	f385 8811 	msr	BASEPRI, r5
 10052d2:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
 10052d6:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
 10052da:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
 10052de:	d10d      	bne.n	10052fc <z_arm_fault+0x40>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
 10052e0:	f002 030c 	and.w	r3, r2, #12
 10052e4:	2b08      	cmp	r3, #8
 10052e6:	d10b      	bne.n	1005300 <z_arm_fault+0x44>
 10052e8:	494d      	ldr	r1, [pc, #308]	; (1005420 <z_arm_fault+0x164>)
 10052ea:	4b4e      	ldr	r3, [pc, #312]	; (1005424 <z_arm_fault+0x168>)
		PR_EXC("SPSEL in thread mode does not indicate PSP");
 10052ec:	484e      	ldr	r0, [pc, #312]	; (1005428 <z_arm_fault+0x16c>)
 10052ee:	1ac9      	subs	r1, r1, r3
 10052f0:	08c9      	lsrs	r1, r1, #3
 10052f2:	0189      	lsls	r1, r1, #6
 10052f4:	f041 0101 	orr.w	r1, r1, #1
 10052f8:	f010 f8f9 	bl	10154ee <log_0>
		return NULL;
 10052fc:	462f      	mov	r7, r5
 10052fe:	e003      	b.n	1005308 <z_arm_fault+0x4c>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
 1005300:	0712      	lsls	r2, r2, #28
 1005302:	d401      	bmi.n	1005308 <z_arm_fault+0x4c>
			ptr_esf = (z_arch_esf_t *)msp;
 1005304:	4607      	mov	r7, r0
			*nested_exc = true;
 1005306:	2501      	movs	r5, #1
	*recoverable = false;
 1005308:	2300      	movs	r3, #0
 100530a:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (fault) {
 100530e:	1ee3      	subs	r3, r4, #3
 1005310:	2b09      	cmp	r3, #9
 1005312:	d86a      	bhi.n	10053ea <z_arm_fault+0x12e>
 1005314:	e8df f003 	tbb	[pc, r3]
 1005318:	3c5c5805 	.word	0x3c5c5805
 100531c:	69696969 	.word	0x69696969
 1005320:	6069      	.short	0x6069
	*recoverable = false;
 1005322:	f04f 0800 	mov.w	r8, #0
 1005326:	4b3f      	ldr	r3, [pc, #252]	; (1005424 <z_arm_fault+0x168>)
 1005328:	4e3d      	ldr	r6, [pc, #244]	; (1005420 <z_arm_fault+0x164>)
	PR_FAULT_INFO("***** HARD FAULT *****");
 100532a:	4840      	ldr	r0, [pc, #256]	; (100542c <z_arm_fault+0x170>)
 100532c:	1af6      	subs	r6, r6, r3
 100532e:	08f6      	lsrs	r6, r6, #3
 1005330:	01b6      	lsls	r6, r6, #6
 1005332:	f046 0601 	orr.w	r6, r6, #1
 1005336:	4631      	mov	r1, r6
 1005338:	f010 f8d9 	bl	10154ee <log_0>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
 100533c:	4b37      	ldr	r3, [pc, #220]	; (100541c <z_arm_fault+0x160>)
	*recoverable = false;
 100533e:	f88d 8007 	strb.w	r8, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
 1005342:	6adc      	ldr	r4, [r3, #44]	; 0x2c
 1005344:	f014 0402 	ands.w	r4, r4, #2
 1005348:	d005      	beq.n	1005356 <z_arm_fault+0x9a>
		PR_EXC("  Bus fault on vector table read");
 100534a:	4631      	mov	r1, r6
 100534c:	4838      	ldr	r0, [pc, #224]	; (1005430 <z_arm_fault+0x174>)
	PR_FAULT_INFO(
 100534e:	f010 f8ce 	bl	10154ee <log_0>
	u32_t reason = K_ERR_CPU_EXCEPTION;
 1005352:	2400      	movs	r4, #0
}
 1005354:	e01f      	b.n	1005396 <z_arm_fault+0xda>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
 1005356:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 1005358:	005b      	lsls	r3, r3, #1
 100535a:	d51c      	bpl.n	1005396 <z_arm_fault+0xda>
		PR_EXC("  Fault escalation (see below)");
 100535c:	4631      	mov	r1, r6
 100535e:	4835      	ldr	r0, [pc, #212]	; (1005434 <z_arm_fault+0x178>)
 1005360:	f010 f8c5 	bl	10154ee <log_0>
		if (SCB_MMFSR != 0) {
 1005364:	4b34      	ldr	r3, [pc, #208]	; (1005438 <z_arm_fault+0x17c>)
 1005366:	781b      	ldrb	r3, [r3, #0]
 1005368:	b12b      	cbz	r3, 1005376 <z_arm_fault+0xba>
			reason = mem_manage_fault(esf, 1, recoverable);
 100536a:	2001      	movs	r0, #1
 100536c:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
 1005370:	f7ff fee6 	bl	1005140 <mem_manage_fault.isra.0>
 1005374:	e00e      	b.n	1005394 <z_arm_fault+0xd8>
		} else if (SCB_BFSR != 0) {
 1005376:	4b31      	ldr	r3, [pc, #196]	; (100543c <z_arm_fault+0x180>)
 1005378:	781b      	ldrb	r3, [r3, #0]
 100537a:	b12b      	cbz	r3, 1005388 <z_arm_fault+0xcc>
			reason = bus_fault(esf, 1, recoverable);
 100537c:	2001      	movs	r0, #1
 100537e:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
 1005382:	f7ff ff37 	bl	10051f4 <bus_fault.isra.0>
 1005386:	e005      	b.n	1005394 <z_arm_fault+0xd8>
		} else if (SCB_UFSR != 0) {
 1005388:	4b2d      	ldr	r3, [pc, #180]	; (1005440 <z_arm_fault+0x184>)
 100538a:	881b      	ldrh	r3, [r3, #0]
 100538c:	b29b      	uxth	r3, r3
 100538e:	b113      	cbz	r3, 1005396 <z_arm_fault+0xda>
			reason = usage_fault(esf);
 1005390:	f7ff fe70 	bl	1005074 <usage_fault.isra.0>
 1005394:	4604      	mov	r4, r0
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
		"ESF could not be retrieved successfully. Shall never occur.");

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
 1005396:	f89d 3007 	ldrb.w	r3, [sp, #7]
 100539a:	b993      	cbnz	r3, 10053c2 <z_arm_fault+0x106>
		return;
	}

	/* Copy ESF */
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
 100539c:	2220      	movs	r2, #32
 100539e:	4639      	mov	r1, r7
 10053a0:	a802      	add	r0, sp, #8
 10053a2:	f011 fb39 	bl	1016a18 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
 10053a6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 10053a8:	b39d      	cbz	r5, 1005412 <z_arm_fault+0x156>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
 10053aa:	f3c3 0208 	ubfx	r2, r3, #0, #9
 10053ae:	b922      	cbnz	r2, 10053ba <z_arm_fault+0xfe>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
 10053b0:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 10053b4:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
 10053b8:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
 10053ba:	4620      	mov	r0, r4
 10053bc:	a902      	add	r1, sp, #8
 10053be:	f7ff fdc5 	bl	1004f4c <z_arm_fatal_error>
}
 10053c2:	b00a      	add	sp, #40	; 0x28
 10053c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		reason = mem_manage_fault(esf, 0, recoverable);
 10053c8:	2000      	movs	r0, #0
 10053ca:	f10d 0107 	add.w	r1, sp, #7
 10053ce:	e7cf      	b.n	1005370 <z_arm_fault+0xb4>
		reason = bus_fault(esf, 0, recoverable);
 10053d0:	2000      	movs	r0, #0
 10053d2:	f10d 0107 	add.w	r1, sp, #7
 10053d6:	e7d4      	b.n	1005382 <z_arm_fault+0xc6>
 10053d8:	4911      	ldr	r1, [pc, #68]	; (1005420 <z_arm_fault+0x164>)
 10053da:	4b12      	ldr	r3, [pc, #72]	; (1005424 <z_arm_fault+0x168>)
	PR_FAULT_INFO(
 10053dc:	4819      	ldr	r0, [pc, #100]	; (1005444 <z_arm_fault+0x188>)
 10053de:	1ac9      	subs	r1, r1, r3
 10053e0:	08c9      	lsrs	r1, r1, #3
 10053e2:	0189      	lsls	r1, r1, #6
 10053e4:	f041 0101 	orr.w	r1, r1, #1
 10053e8:	e7b1      	b.n	100534e <z_arm_fault+0x92>
 10053ea:	4a0e      	ldr	r2, [pc, #56]	; (1005424 <z_arm_fault+0x168>)
 10053ec:	4b0c      	ldr	r3, [pc, #48]	; (1005420 <z_arm_fault+0x164>)
	PR_FAULT_INFO("***** %s %d) *****",
 10053ee:	4816      	ldr	r0, [pc, #88]	; (1005448 <z_arm_fault+0x18c>)
 10053f0:	1a9b      	subs	r3, r3, r2
 10053f2:	08db      	lsrs	r3, r3, #3
 10053f4:	f416 7ff8 	tst.w	r6, #496	; 0x1f0
 10053f8:	ea4f 1383 	mov.w	r3, r3, lsl #6
 10053fc:	4913      	ldr	r1, [pc, #76]	; (100544c <z_arm_fault+0x190>)
 10053fe:	f043 0301 	orr.w	r3, r3, #1
 1005402:	bf18      	it	ne
 1005404:	4601      	movne	r1, r0
 1005406:	f1a4 0210 	sub.w	r2, r4, #16
 100540a:	4811      	ldr	r0, [pc, #68]	; (1005450 <z_arm_fault+0x194>)
 100540c:	f010 f890 	bl	1015530 <log_2>
 1005410:	e79f      	b.n	1005352 <z_arm_fault+0x96>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
 1005412:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 1005416:	f023 0301 	bic.w	r3, r3, #1
 100541a:	e7cd      	b.n	10053b8 <z_arm_fault+0xfc>
 100541c:	e000ed00 	.word	0xe000ed00
 1005420:	01018310 	.word	0x01018310
 1005424:	01018208 	.word	0x01018208
 1005428:	010196c6 	.word	0x010196c6
 100542c:	010196f1 	.word	0x010196f1
 1005430:	01019708 	.word	0x01019708
 1005434:	01019729 	.word	0x01019729
 1005438:	e000ed28 	.word	0xe000ed28
 100543c:	e000ed29 	.word	0xe000ed29
 1005440:	e000ed2a 	.word	0xe000ed2a
 1005444:	01019748 	.word	0x01019748
 1005448:	01019793 	.word	0x01019793
 100544c:	0101977e 	.word	0x0101977e
 1005450:	010197ac 	.word	0x010197ac

01005454 <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
 1005454:	4a02      	ldr	r2, [pc, #8]	; (1005460 <z_arm_fault_init+0xc>)
 1005456:	6953      	ldr	r3, [r2, #20]
 1005458:	f043 0310 	orr.w	r3, r3, #16
 100545c:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
 100545e:	4770      	bx	lr
 1005460:	e000ed00 	.word	0xe000ed00

01005464 <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
 1005464:	4b04      	ldr	r3, [pc, #16]	; (1005478 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
 1005466:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
 1005468:	6a58      	ldr	r0, [r3, #36]	; 0x24
	cmp r0, r1
 100546a:	4288      	cmp	r0, r1
	beq _EXIT_EXC
 100546c:	d003      	beq.n	1005476 <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
 100546e:	4903      	ldr	r1, [pc, #12]	; (100547c <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
 1005470:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
 1005474:	600a      	str	r2, [r1, #0]

01005476 <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
 1005476:	4770      	bx	lr
	ldr r3, =_kernel
 1005478:	21007f8c 	.word	0x21007f8c
	ldr r1, =_SCS_ICSR
 100547c:	e000ed04 	.word	0xe000ed04

01005480 <sys_arch_reboot>:
  __ASM volatile ("dsb 0xF":::"memory");
 1005480:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 1005484:	4905      	ldr	r1, [pc, #20]	; (100549c <sys_arch_reboot+0x1c>)
 1005486:	4b06      	ldr	r3, [pc, #24]	; (10054a0 <sys_arch_reboot+0x20>)
 1005488:	68ca      	ldr	r2, [r1, #12]
 100548a:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 100548e:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 1005490:	60cb      	str	r3, [r1, #12]
 1005492:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 1005496:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 1005498:	e7fd      	b.n	1005496 <sys_arch_reboot+0x16>
 100549a:	bf00      	nop
 100549c:	e000ed00 	.word	0xe000ed00
 10054a0:	05fa0004 	.word	0x05fa0004

010054a4 <z_arm_interrupt_init>:
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
 10054a4:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 10054a6:	2120      	movs	r1, #32
 10054a8:	4803      	ldr	r0, [pc, #12]	; (10054b8 <z_arm_interrupt_init+0x14>)
 10054aa:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
 10054ac:	3301      	adds	r3, #1
 10054ae:	2b1e      	cmp	r3, #30
 10054b0:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
 10054b4:	d1f9      	bne.n	10054aa <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
 10054b6:	4770      	bx	lr
 10054b8:	e000e100 	.word	0xe000e100

010054bc <z_impl_k_thread_abort>:
#include <sys/__assert.h>

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
 10054bc:	b538      	push	{r3, r4, r5, lr}
 10054be:	4604      	mov	r4, r0
	__asm__ volatile(
 10054c0:	f04f 0320 	mov.w	r3, #32
 10054c4:	f3ef 8511 	mrs	r5, BASEPRI
 10054c8:	f383 8811 	msr	BASEPRI, r3
 10054cc:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
		 "essential thread aborted");

	z_thread_single_abort(thread);
 10054d0:	f00f f80e 	bl	10144f0 <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	if (_current == thread) {
 10054d4:	4b0a      	ldr	r3, [pc, #40]	; (1005500 <z_impl_k_thread_abort+0x44>)
 10054d6:	689b      	ldr	r3, [r3, #8]
 10054d8:	42a3      	cmp	r3, r4
 10054da:	d10b      	bne.n	10054f4 <z_impl_k_thread_abort+0x38>
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
 10054dc:	4b09      	ldr	r3, [pc, #36]	; (1005504 <z_impl_k_thread_abort+0x48>)
 10054de:	685a      	ldr	r2, [r3, #4]
 10054e0:	f3c2 0208 	ubfx	r2, r2, #0, #9
 10054e4:	b912      	cbnz	r2, 10054ec <z_impl_k_thread_abort+0x30>
	int ret;
	z_check_stack_sentinel();
#ifndef CONFIG_ARM
	sys_trace_thread_switched_out();
#endif
	ret = arch_swap(key);
 10054e6:	4628      	mov	r0, r5
 10054e8:	f7ff fc42 	bl	1004d70 <arch_swap>
			(void)z_swap_irqlock(key);
			CODE_UNREACHABLE;
		} else {
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 10054ec:	685a      	ldr	r2, [r3, #4]
 10054ee:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 10054f2:	605a      	str	r2, [r3, #4]
		}
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
 10054f4:	4628      	mov	r0, r5
}
 10054f6:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_irqlock(key);
 10054fa:	f012 baa7 	b.w	1017a4c <z_reschedule_irqlock>
 10054fe:	bf00      	nop
 1005500:	21007f8c 	.word	0x21007f8c
 1005504:	e000ed00 	.word	0xe000ed00

01005508 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
 1005508:	b510      	push	{r4, lr}
		.size = (u32_t)&_nocache_ram_size,
		.attr = K_MEM_PARTITION_P_RW_U_NA_NOCACHE,
		};
#endif /* CONFIG_NOCACHE_MEMORY */
#if defined(CONFIG_ARCH_HAS_RAMFUNC_SUPPORT)
		const struct k_mem_partition ramfunc_region =
 100550a:	4b0e      	ldr	r3, [pc, #56]	; (1005544 <z_arm_configure_static_mpu_regions+0x3c>)
{
 100550c:	b088      	sub	sp, #32
		const struct k_mem_partition ramfunc_region =
 100550e:	9302      	str	r3, [sp, #8]
 1005510:	4b0d      	ldr	r3, [pc, #52]	; (1005548 <z_arm_configure_static_mpu_regions+0x40>)
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
 1005512:	4c0e      	ldr	r4, [pc, #56]	; (100554c <z_arm_configure_static_mpu_regions+0x44>)
		const struct k_mem_partition ramfunc_region =
 1005514:	9303      	str	r3, [sp, #12]
 1005516:	4b0e      	ldr	r3, [pc, #56]	; (1005550 <z_arm_configure_static_mpu_regions+0x48>)
	arm_core_mpu_configure_static_mpu_regions(static_regions,
 1005518:	4a0e      	ldr	r2, [pc, #56]	; (1005554 <z_arm_configure_static_mpu_regions+0x4c>)
		const struct k_mem_partition ramfunc_region =
 100551a:	9304      	str	r3, [sp, #16]
	const struct k_mem_partition *static_regions[] = {
 100551c:	ab02      	add	r3, sp, #8
 100551e:	9301      	str	r3, [sp, #4]
	arm_core_mpu_configure_static_mpu_regions(static_regions,
 1005520:	a801      	add	r0, sp, #4
 1005522:	4623      	mov	r3, r4
 1005524:	2101      	movs	r1, #1
 1005526:	f000 f93d 	bl	10057a4 <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of k_mem_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct k_mem_partition dyn_region_areas[] = {
 100552a:	2300      	movs	r3, #0
 100552c:	9307      	str	r3, [sp, #28]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
 100552e:	4b0a      	ldr	r3, [pc, #40]	; (1005558 <z_arm_configure_static_mpu_regions+0x50>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
 1005530:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
 1005532:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
 1005534:	a805      	add	r0, sp, #20
	const struct k_mem_partition dyn_region_areas[] = {
 1005536:	9305      	str	r3, [sp, #20]
 1005538:	9406      	str	r4, [sp, #24]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
 100553a:	f000 f93d 	bl	10057b8 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
 100553e:	b008      	add	sp, #32
 1005540:	bd10      	pop	{r4, pc}
 1005542:	bf00      	nop
 1005544:	21000000 	.word	0x21000000
 1005548:	00000000 	.word	0x00000000
 100554c:	21010000 	.word	0x21010000
 1005550:	00010006 	.word	0x00010006
 1005554:	21000000 	.word	0x21000000
 1005558:	210006b8 	.word	0x210006b8

0100555c <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const u32_t index,
	const struct arm_mpu_region *region_conf)
{
 100555c:	b510      	push	{r4, lr}
	ARM_MPU_SetRegion(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
 100555e:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
 1005560:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
 1005562:	f023 021f 	bic.w	r2, r3, #31
		| (region_conf->attr.rbar &
 1005566:	f004 031f 	and.w	r3, r4, #31
 100556a:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
 100556c:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
 100556e:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
 1005570:	f023 031f 	bic.w	r3, r3, #31
* \param rbar Value for RBAR register.
* \param rlar Value for RLAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegionEx(MPU_Type* mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
  mpu->RNR = rnr;
 1005574:	4904      	ldr	r1, [pc, #16]	; (1005588 <region_init+0x2c>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
 1005576:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
 100557a:	f043 0301 	orr.w	r3, r3, #1
 100557e:	6088      	str	r0, [r1, #8]
  mpu->RBAR = rbar;
 1005580:	60ca      	str	r2, [r1, #12]
  mpu->RLAR = rlar;
 1005582:	610b      	str	r3, [r1, #16]
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
 1005584:	bd10      	pop	{r4, pc}
 1005586:	bf00      	nop
 1005588:	e000ed90 	.word	0xe000ed90

0100558c <region_allocate_and_init.part.0>:
#include <arm_mpu_v8_internal.h>
#else
#error "Unsupported ARM CPU"
#endif

static int region_allocate_and_init(const u8_t index,
 100558c:	b508      	push	{r3, lr}
 100558e:	4a07      	ldr	r2, [pc, #28]	; (10055ac <region_allocate_and_init.part.0+0x20>)
 1005590:	4b07      	ldr	r3, [pc, #28]	; (10055b0 <region_allocate_and_init.part.0+0x24>)
 1005592:	4601      	mov	r1, r0
 1005594:	1ad2      	subs	r2, r2, r3
 1005596:	08d2      	lsrs	r2, r2, #3
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1)) {

		/* No available MPU region index. */
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
 1005598:	0192      	lsls	r2, r2, #6
 100559a:	4806      	ldr	r0, [pc, #24]	; (10055b4 <region_allocate_and_init.part.0+0x28>)
 100559c:	f042 0201 	orr.w	r2, r2, #1
 10055a0:	f00f ffb2 	bl	1015508 <log_1>

	/* Program region */
	region_init(index, region_conf);

	return index;
}
 10055a4:	f06f 0015 	mvn.w	r0, #21
 10055a8:	bd08      	pop	{r3, pc}
 10055aa:	bf00      	nop
 10055ac:	01018300 	.word	0x01018300
 10055b0:	01018208 	.word	0x01018208
 10055b4:	010197c3 	.word	0x010197c3

010055b8 <mpu_configure_regions_and_partition.constprop.0>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct k_mem_partition
 10055b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10055bc:	4607      	mov	r7, r0
 10055be:	4688      	mov	r8, r1
 10055c0:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
 10055c2:	2600      	movs	r6, #0
	MPU->RNR = index;
 10055c4:	4d56      	ldr	r5, [pc, #344]	; (1005720 <mpu_configure_regions_and_partition.constprop.0+0x168>)
static int mpu_configure_regions_and_partition(const struct k_mem_partition
 10055c6:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
 10055c8:	4546      	cmp	r6, r8
 10055ca:	da35      	bge.n	1005638 <mpu_configure_regions_and_partition.constprop.0+0x80>
		if (regions[i]->size == 0U) {
 10055cc:	f857 3026 	ldr.w	r3, [r7, r6, lsl #2]
 10055d0:	f8d3 9004 	ldr.w	r9, [r3, #4]
 10055d4:	f1b9 0f00 	cmp.w	r9, #0
 10055d8:	d051      	beq.n	100567e <mpu_configure_regions_and_partition.constprop.0+0xc6>
		&&
 10055da:	f1b9 0f1f 	cmp.w	r9, #31
 10055de:	d91e      	bls.n	100561e <mpu_configure_regions_and_partition.constprop.0+0x66>
		&&
 10055e0:	f019 0f1f 	tst.w	r9, #31
 10055e4:	d11b      	bne.n	100561e <mpu_configure_regions_and_partition.constprop.0+0x66>
		((part->start &
 10055e6:	f8d3 a000 	ldr.w	sl, [r3]
		&&
 10055ea:	f01a 0f1f 	tst.w	sl, #31
 10055ee:	d116      	bne.n	100561e <mpu_configure_regions_and_partition.constprop.0+0x66>
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
 10055f0:	4650      	mov	r0, sl
 10055f2:	f011 f9c3 	bl	101697c <arm_cmse_mpu_region_get>
 10055f6:	4683      	mov	fp, r0
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
 10055f8:	eb09 000a 	add.w	r0, r9, sl
 10055fc:	3801      	subs	r0, #1
 10055fe:	f011 f9bd 	bl	101697c <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
 1005602:	4583      	cmp	fp, r0
 1005604:	d01c      	beq.n	1005640 <mpu_configure_regions_and_partition.constprop.0+0x88>
	return -EINVAL;
 1005606:	f06f 0b15 	mvn.w	fp, #21
 100560a:	4a46      	ldr	r2, [pc, #280]	; (1005724 <mpu_configure_regions_and_partition.constprop.0+0x16c>)
 100560c:	4b46      	ldr	r3, [pc, #280]	; (1005728 <mpu_configure_regions_and_partition.constprop.0+0x170>)
		int u_reg_index =
			get_region_index(regions[i]->start, regions[i]->size);

		if ((u_reg_index == -EINVAL) ||
			(u_reg_index > (reg_index - 1))) {
			LOG_ERR("Invalid underlying region index %u",
 100560e:	4659      	mov	r1, fp
 1005610:	1ad2      	subs	r2, r2, r3
 1005612:	08d2      	lsrs	r2, r2, #3
 1005614:	0192      	lsls	r2, r2, #6
 1005616:	4845      	ldr	r0, [pc, #276]	; (100572c <mpu_configure_regions_and_partition.constprop.0+0x174>)
 1005618:	f042 0201 	orr.w	r2, r2, #1
 100561c:	e008      	b.n	1005630 <mpu_configure_regions_and_partition.constprop.0+0x78>
			LOG_ERR("Partition %u: sanity check failed.", i);
 100561e:	4631      	mov	r1, r6
 1005620:	4a40      	ldr	r2, [pc, #256]	; (1005724 <mpu_configure_regions_and_partition.constprop.0+0x16c>)
 1005622:	4b41      	ldr	r3, [pc, #260]	; (1005728 <mpu_configure_regions_and_partition.constprop.0+0x170>)
 1005624:	4842      	ldr	r0, [pc, #264]	; (1005730 <mpu_configure_regions_and_partition.constprop.0+0x178>)
 1005626:	1ad2      	subs	r2, r2, r3
 1005628:	08d2      	lsrs	r2, r2, #3
 100562a:	0192      	lsls	r2, r2, #6
 100562c:	f042 0201 	orr.w	r2, r2, #1
			LOG_ERR("Invalid underlying region index %u",
 1005630:	f00f ff6a 	bl	1015508 <log_1>

			reg_index =
				mpu_configure_region(reg_index, regions[i]);

			if (reg_index == -EINVAL) {
				return reg_index;
 1005634:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
 1005638:	4620      	mov	r0, r4
 100563a:	b005      	add	sp, #20
 100563c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((u_reg_index == -EINVAL) ||
 1005640:	f11b 0f16 	cmn.w	fp, #22
 1005644:	d0e1      	beq.n	100560a <mpu_configure_regions_and_partition.constprop.0+0x52>
			(u_reg_index > (reg_index - 1))) {
 1005646:	1e63      	subs	r3, r4, #1
		if ((u_reg_index == -EINVAL) ||
 1005648:	455b      	cmp	r3, fp
 100564a:	dbde      	blt.n	100560a <mpu_configure_regions_and_partition.constprop.0+0x52>
	MPU->RNR = index;
 100564c:	f8c5 b008 	str.w	fp, [r5, #8]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
 1005650:	68e8      	ldr	r0, [r5, #12]
	MPU->RNR = index;
 1005652:	f8c5 b008 	str.w	fp, [r5, #8]
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
 1005656:	692b      	ldr	r3, [r5, #16]
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
 1005658:	f857 1026 	ldr.w	r1, [r7, r6, lsl #2]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
 100565c:	f020 001f 	bic.w	r0, r0, #31
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
 1005660:	f043 0a1f 	orr.w	sl, r3, #31
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
 1005664:	e9d1 3200 	ldrd	r3, r2, [r1]
 1005668:	441a      	add	r2, r3
		if ((regions[i]->start == u_reg_base) &&
 100566a:	4298      	cmp	r0, r3
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
 100566c:	f102 39ff 	add.w	r9, r2, #4294967295
		if ((regions[i]->start == u_reg_base) &&
 1005670:	d118      	bne.n	10056a4 <mpu_configure_regions_and_partition.constprop.0+0xec>
 1005672:	45ca      	cmp	sl, r9
 1005674:	d105      	bne.n	1005682 <mpu_configure_regions_and_partition.constprop.0+0xca>
			mpu_configure_region(u_reg_index, regions[i]);
 1005676:	fa5f f08b 	uxtb.w	r0, fp
 100567a:	f011 f95e 	bl	101693a <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
 100567e:	3601      	adds	r6, #1
 1005680:	e7a2      	b.n	10055c8 <mpu_configure_regions_and_partition.constprop.0+0x10>
	MPU->RNR = index;
 1005682:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
 1005686:	68eb      	ldr	r3, [r5, #12]
		| (base & MPU_RBAR_BASE_Msk);
 1005688:	f022 021f 	bic.w	r2, r2, #31
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
 100568c:	f003 031f 	and.w	r3, r3, #31
		| (base & MPU_RBAR_BASE_Msk);
 1005690:	431a      	orrs	r2, r3
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
 1005692:	60ea      	str	r2, [r5, #12]
				mpu_configure_region(reg_index, regions[i]);
 1005694:	b2e0      	uxtb	r0, r4
				mpu_configure_region(reg_index, regions[i]);
 1005696:	f011 f950 	bl	101693a <mpu_configure_region>
			if (reg_index == -EINVAL) {
 100569a:	f110 0f16 	cmn.w	r0, #22
 100569e:	d0c9      	beq.n	1005634 <mpu_configure_regions_and_partition.constprop.0+0x7c>
			reg_index++;
 10056a0:	1c44      	adds	r4, r0, #1
 10056a2:	e7ec      	b.n	100567e <mpu_configure_regions_and_partition.constprop.0+0xc6>
	MPU->RNR = index;
 10056a4:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
 10056a8:	692a      	ldr	r2, [r5, #16]
 10056aa:	3b01      	subs	r3, #1
 10056ac:	f023 031f 	bic.w	r3, r3, #31
 10056b0:	f002 021f 	and.w	r2, r2, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
 10056b4:	4313      	orrs	r3, r2
		} else if (reg_last == u_reg_last) {
 10056b6:	45ca      	cmp	sl, r9
 10056b8:	b2e0      	uxtb	r0, r4
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
 10056ba:	612b      	str	r3, [r5, #16]
		} else if (reg_last == u_reg_last) {
 10056bc:	d0eb      	beq.n	1005696 <mpu_configure_regions_and_partition.constprop.0+0xde>
				mpu_configure_region(reg_index, regions[i]);
 10056be:	f011 f93c 	bl	101693a <mpu_configure_region>
			if (reg_index == -EINVAL) {
 10056c2:	f110 0f16 	cmn.w	r0, #22
 10056c6:	d0b5      	beq.n	1005634 <mpu_configure_regions_and_partition.constprop.0+0x7c>
	MPU->RNR = index;
 10056c8:	f8c5 b008 	str.w	fp, [r5, #8]
	attr->rbar = MPU->RBAR &
 10056cc:	68ea      	ldr	r2, [r5, #12]
 10056ce:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i]->start +
 10056d2:	f10a 3aff 	add.w	sl, sl, #4294967295
	attr->rbar = MPU->RBAR &
 10056d6:	f362 0304 	bfi	r3, r2, #0, #5
 10056da:	f88d 3008 	strb.w	r3, [sp, #8]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
 10056de:	692b      	ldr	r3, [r5, #16]
 10056e0:	f89d 2008 	ldrb.w	r2, [sp, #8]
 10056e4:	085b      	lsrs	r3, r3, #1
 10056e6:	f363 1247 	bfi	r2, r3, #5, #3
			fill_region.base = regions[i]->start +
 10056ea:	f857 3026 	ldr.w	r3, [r7, r6, lsl #2]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
 10056ee:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i]->start +
 10056f2:	e9d3 1300 	ldrd	r1, r3, [r3]
 10056f6:	440b      	add	r3, r1
 10056f8:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i]->start +
 10056fa:	f023 031f 	bic.w	r3, r3, #31
			reg_index++;
 10056fe:	1c44      	adds	r4, r0, #1
			REGION_LIMIT_ADDR((regions[i]->start +
 1005700:	4453      	add	r3, sl
 1005702:	eba3 0309 	sub.w	r3, r3, r9
				region_allocate_and_init(reg_index,
 1005706:	b2e0      	uxtb	r0, r4
			REGION_LIMIT_ADDR((regions[i]->start +
 1005708:	f023 031f 	bic.w	r3, r3, #31
	if (index > (get_num_regions() - 1)) {
 100570c:	280f      	cmp	r0, #15
			fill_region.attr.r_limit =
 100570e:	9303      	str	r3, [sp, #12]
 1005710:	d902      	bls.n	1005718 <mpu_configure_regions_and_partition.constprop.0+0x160>
 1005712:	f7ff ff3b 	bl	100558c <region_allocate_and_init.part.0>
 1005716:	e7c0      	b.n	100569a <mpu_configure_regions_and_partition.constprop.0+0xe2>
	region_init(index, region_conf);
 1005718:	4669      	mov	r1, sp
 100571a:	f7ff ff1f 	bl	100555c <region_init>
			if (reg_index == -EINVAL) {
 100571e:	e7bf      	b.n	10056a0 <mpu_configure_regions_and_partition.constprop.0+0xe8>
 1005720:	e000ed90 	.word	0xe000ed90
 1005724:	01018300 	.word	0x01018300
 1005728:	01018208 	.word	0x01018208
 100572c:	0101980c 	.word	0x0101980c
 1005730:	010197e9 	.word	0x010197e9

01005734 <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
 1005734:	2205      	movs	r2, #5
 1005736:	4b03      	ldr	r3, [pc, #12]	; (1005744 <arm_core_mpu_enable+0x10>)
 1005738:	605a      	str	r2, [r3, #4]
 100573a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 100573e:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
 1005742:	4770      	bx	lr
 1005744:	e000ed90 	.word	0xe000ed90

01005748 <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
 1005748:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
 100574c:	2200      	movs	r2, #0
 100574e:	4b01      	ldr	r3, [pc, #4]	; (1005754 <arm_core_mpu_disable+0xc>)
 1005750:	605a      	str	r2, [r3, #4]
}
 1005752:	4770      	bx	lr
 1005754:	e000ed90 	.word	0xe000ed90

01005758 <arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
static int arm_mpu_init(struct device *arg)
{
 1005758:	b538      	push	{r3, r4, r5, lr}
	u32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
 100575a:	4c0e      	ldr	r4, [pc, #56]	; (1005794 <arm_mpu_init+0x3c>)
 100575c:	6825      	ldr	r5, [r4, #0]
 100575e:	2d10      	cmp	r5, #16
 1005760:	d814      	bhi.n	100578c <arm_mpu_init+0x34>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
 1005762:	f7ff fff1 	bl	1005748 <arm_core_mpu_disable>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
 1005766:	2000      	movs	r0, #0
	MPU->MAIR0 =
 1005768:	4b0b      	ldr	r3, [pc, #44]	; (1005798 <arm_mpu_init+0x40>)
 100576a:	4a0c      	ldr	r2, [pc, #48]	; (100579c <arm_mpu_init+0x44>)
 100576c:	631a      	str	r2, [r3, #48]	; 0x30
 100576e:	4285      	cmp	r5, r0
 1005770:	d105      	bne.n	100577e <arm_mpu_init+0x26>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
 1005772:	4b0b      	ldr	r3, [pc, #44]	; (10057a0 <arm_mpu_init+0x48>)
 1005774:	701d      	strb	r5, [r3, #0]


	arm_core_mpu_enable();
 1005776:	f7ff ffdd 	bl	1005734 <arm_core_mpu_enable>
	__ASSERT(
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
 100577a:	2000      	movs	r0, #0
}
 100577c:	bd38      	pop	{r3, r4, r5, pc}
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
 100577e:	6861      	ldr	r1, [r4, #4]
 1005780:	eb01 1100 	add.w	r1, r1, r0, lsl #4
 1005784:	f7ff feea 	bl	100555c <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
 1005788:	3001      	adds	r0, #1
 100578a:	e7f0      	b.n	100576e <arm_mpu_init+0x16>
		return -1;
 100578c:	f04f 30ff 	mov.w	r0, #4294967295
 1005790:	e7f4      	b.n	100577c <arm_mpu_init+0x24>
 1005792:	bf00      	nop
 1005794:	010184a0 	.word	0x010184a0
 1005798:	e000ed90 	.word	0xe000ed90
 100579c:	0044ffaa 	.word	0x0044ffaa
 10057a0:	21008063 	.word	0x21008063

010057a4 <arm_core_mpu_configure_static_mpu_regions>:
{
 10057a4:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const u8_t regions_num,
	const u32_t background_area_base,
	const u32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
 10057a6:	4c03      	ldr	r4, [pc, #12]	; (10057b4 <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
 10057a8:	7822      	ldrb	r2, [r4, #0]
 10057aa:	f7ff ff05 	bl	10055b8 <mpu_configure_regions_and_partition.constprop.0>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
 10057ae:	7020      	strb	r0, [r4, #0]
}
 10057b0:	bd10      	pop	{r4, pc}
 10057b2:	bf00      	nop
 10057b4:	21008063 	.word	0x21008063

010057b8 <arm_core_mpu_mark_areas_for_dynamic_regions>:
{
 10057b8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10057bc:	4d26      	ldr	r5, [pc, #152]	; (1005858 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa0>)
 10057be:	468a      	mov	sl, r1
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
 10057c0:	4606      	mov	r6, r0
 10057c2:	f04f 0800 	mov.w	r8, #0
 10057c6:	46ab      	mov	fp, r5
	MPU->RNR = index;
 10057c8:	4f24      	ldr	r7, [pc, #144]	; (100585c <arm_core_mpu_mark_areas_for_dynamic_regions+0xa4>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
 10057ca:	45d0      	cmp	r8, sl
 10057cc:	da1b      	bge.n	1005806 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
		if (dyn_region_areas[i].size == 0U) {
 10057ce:	f8d6 9004 	ldr.w	r9, [r6, #4]
 10057d2:	f1b9 0f00 	cmp.w	r9, #0
 10057d6:	d039      	beq.n	100584c <arm_core_mpu_mark_areas_for_dynamic_regions+0x94>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
 10057d8:	6831      	ldr	r1, [r6, #0]
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
 10057da:	4608      	mov	r0, r1
 10057dc:	9101      	str	r1, [sp, #4]
 10057de:	f011 f8cd 	bl	101697c <arm_cmse_mpu_region_get>
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
 10057e2:	9901      	ldr	r1, [sp, #4]
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
 10057e4:	4604      	mov	r4, r0
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
 10057e6:	eb09 0001 	add.w	r0, r9, r1
 10057ea:	3801      	subs	r0, #1
 10057ec:	f011 f8c6 	bl	101697c <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
 10057f0:	4284      	cmp	r4, r0
 10057f2:	f04f 0214 	mov.w	r2, #20
 10057f6:	4b1a      	ldr	r3, [pc, #104]	; (1005860 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa8>)
 10057f8:	d008      	beq.n	100580c <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
		dyn_reg_info[i].index =
 10057fa:	f06f 0315 	mvn.w	r3, #21
 10057fe:	fb02 f808 	mul.w	r8, r2, r8
 1005802:	f84b 3008 	str.w	r3, [fp, r8]
}
 1005806:	b003      	add	sp, #12
 1005808:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
 100580c:	f114 0f16 	cmn.w	r4, #22
		dyn_reg_info[i].index =
 1005810:	602c      	str	r4, [r5, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
 1005812:	d0f8      	beq.n	1005806 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
 1005814:	7819      	ldrb	r1, [r3, #0]
 1005816:	42a1      	cmp	r1, r4
 1005818:	ddf5      	ble.n	1005806 <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
	attr->rbar = MPU->RBAR &
 100581a:	fb02 b008 	mla	r0, r2, r8, fp
	MPU->RNR = index;
 100581e:	60bc      	str	r4, [r7, #8]
	MPU->RNR = index;
 1005820:	60bc      	str	r4, [r7, #8]
	attr->rbar = MPU->RBAR &
 1005822:	68fc      	ldr	r4, [r7, #12]
 1005824:	f100 0108 	add.w	r1, r0, #8
 1005828:	7b00      	ldrb	r0, [r0, #12]
 100582a:	f364 0004 	bfi	r0, r4, #0, #5
 100582e:	7108      	strb	r0, [r1, #4]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
 1005830:	6938      	ldr	r0, [r7, #16]
 1005832:	790c      	ldrb	r4, [r1, #4]
 1005834:	0840      	lsrs	r0, r0, #1
 1005836:	f360 1447 	bfi	r4, r0, #5, #3
 100583a:	710c      	strb	r4, [r1, #4]
	region_conf->base = (MPU->RBAR & MPU_RBAR_BASE_Msk);
 100583c:	68f9      	ldr	r1, [r7, #12]
 100583e:	f021 011f 	bic.w	r1, r1, #31
 1005842:	6069      	str	r1, [r5, #4]
	region_conf->attr.r_limit = MPU->RLAR & MPU_RLAR_LIMIT_Msk;
 1005844:	6939      	ldr	r1, [r7, #16]
 1005846:	f021 011f 	bic.w	r1, r1, #31
 100584a:	6129      	str	r1, [r5, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
 100584c:	f108 0801 	add.w	r8, r8, #1
 1005850:	3514      	adds	r5, #20
 1005852:	360c      	adds	r6, #12
 1005854:	e7b9      	b.n	10057ca <arm_core_mpu_mark_areas_for_dynamic_regions+0x12>
 1005856:	bf00      	nop
 1005858:	210009c4 	.word	0x210009c4
 100585c:	e000ed90 	.word	0xe000ed90
 1005860:	21008063 	.word	0x21008063

01005864 <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
 1005864:	4b01      	ldr	r3, [pc, #4]	; (100586c <__stdout_hook_install+0x8>)
 1005866:	6018      	str	r0, [r3, #0]
}
 1005868:	4770      	bx	lr
 100586a:	bf00      	nop
 100586c:	21000074 	.word	0x21000074

01005870 <bt_hci_driver_register>:
struct bt_hci_raw_cmd_ext *cmd_ext;
static size_t cmd_ext_size;

int bt_hci_driver_register(const struct bt_hci_driver *drv)
{
	if (bt_dev.drv) {
 1005870:	4a07      	ldr	r2, [pc, #28]	; (1005890 <bt_hci_driver_register+0x20>)
{
 1005872:	4603      	mov	r3, r0
	if (bt_dev.drv) {
 1005874:	6810      	ldr	r0, [r2, #0]
 1005876:	b928      	cbnz	r0, 1005884 <bt_hci_driver_register+0x14>
		return -EALREADY;
	}

	if (!drv->open || !drv->send) {
 1005878:	68d9      	ldr	r1, [r3, #12]
 100587a:	b131      	cbz	r1, 100588a <bt_hci_driver_register+0x1a>
 100587c:	6919      	ldr	r1, [r3, #16]
 100587e:	b121      	cbz	r1, 100588a <bt_hci_driver_register+0x1a>
		return -EINVAL;
	}

	bt_dev.drv = drv;
 1005880:	6013      	str	r3, [r2, #0]
	BT_DBG("Registered %s", drv->name ? drv->name : "");

	bt_monitor_new_index(BT_MONITOR_TYPE_PRIMARY, drv->bus,
			     BT_ADDR_ANY, drv->name ? drv->name : "bt0");

	return 0;
 1005882:	4770      	bx	lr
		return -EALREADY;
 1005884:	f06f 0044 	mvn.w	r0, #68	; 0x44
 1005888:	4770      	bx	lr
		return -EINVAL;
 100588a:	f06f 0015 	mvn.w	r0, #21
}
 100588e:	4770      	bx	lr
 1005890:	210009d8 	.word	0x210009d8

01005894 <bt_buf_get_rx>:

struct net_buf *bt_buf_get_rx(enum bt_buf_type type, k_timeout_t timeout)
{
 1005894:	b570      	push	{r4, r5, r6, lr}
	struct net_buf *buf;

	switch (type) {
 1005896:	f000 06fd 	and.w	r6, r0, #253	; 0xfd
 100589a:	2e01      	cmp	r6, #1
{
 100589c:	4605      	mov	r5, r0
	switch (type) {
 100589e:	d00d      	beq.n	10058bc <bt_buf_get_rx+0x28>
 10058a0:	4b0c      	ldr	r3, [pc, #48]	; (10058d4 <bt_buf_get_rx+0x40>)
 10058a2:	4a0d      	ldr	r2, [pc, #52]	; (10058d8 <bt_buf_get_rx+0x44>)
	case BT_BUF_EVT:
	case BT_BUF_ACL_IN:
		break;
	default:
		BT_ERR("Invalid type: %u", type);
 10058a4:	4601      	mov	r1, r0
 10058a6:	1ad2      	subs	r2, r2, r3
 10058a8:	08d2      	lsrs	r2, r2, #3
 10058aa:	0192      	lsls	r2, r2, #6
 10058ac:	480b      	ldr	r0, [pc, #44]	; (10058dc <bt_buf_get_rx+0x48>)
 10058ae:	f042 0201 	orr.w	r2, r2, #1
 10058b2:	f00f fe29 	bl	1015508 <log_1>
		return NULL;
 10058b6:	2400      	movs	r4, #0

	net_buf_reserve(buf, BT_BUF_RESERVE);
	bt_buf_set_type(buf, type);

	return buf;
}
 10058b8:	4620      	mov	r0, r4
 10058ba:	bd70      	pop	{r4, r5, r6, pc}
	buf = net_buf_alloc(&hci_rx_pool, timeout);
 10058bc:	4808      	ldr	r0, [pc, #32]	; (10058e0 <bt_buf_get_rx+0x4c>)
 10058be:	f011 f989 	bl	1016bd4 <net_buf_alloc_fixed>
	if (!buf) {
 10058c2:	4604      	mov	r4, r0
 10058c4:	2800      	cmp	r0, #0
 10058c6:	d0f7      	beq.n	10058b8 <bt_buf_get_rx+0x24>
	net_buf_reserve(buf, BT_BUF_RESERVE);
 10058c8:	4631      	mov	r1, r6
 10058ca:	3008      	adds	r0, #8
 10058cc:	f011 f9a1 	bl	1016c12 <net_buf_simple_reserve>
	*(u8_t *)net_buf_user_data(buf) = type;
 10058d0:	7525      	strb	r5, [r4, #20]
	return buf;
 10058d2:	e7f1      	b.n	10058b8 <bt_buf_get_rx+0x24>
 10058d4:	01018208 	.word	0x01018208
 10058d8:	010182c8 	.word	0x010182c8
 10058dc:	01019845 	.word	0x01019845
 10058e0:	2100068c 	.word	0x2100068c

010058e4 <bt_buf_get_tx>:

struct net_buf *bt_buf_get_tx(enum bt_buf_type type, k_timeout_t timeout,
			      const void *data, size_t size)
{
 10058e4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct net_buf_pool *pool;
	struct net_buf *buf;

	switch (type) {
 10058e8:	4605      	mov	r5, r0
{
 10058ea:	e9dd 7806 	ldrd	r7, r8, [sp, #24]
	switch (type) {
 10058ee:	b180      	cbz	r0, 1005912 <bt_buf_get_tx+0x2e>
 10058f0:	2802      	cmp	r0, #2
 10058f2:	d026      	beq.n	1005942 <bt_buf_get_tx+0x5e>
 10058f4:	4b14      	ldr	r3, [pc, #80]	; (1005948 <bt_buf_get_tx+0x64>)
 10058f6:	4a15      	ldr	r2, [pc, #84]	; (100594c <bt_buf_get_tx+0x68>)
			size--;
			break;
		}
	/* Fallthrough */
	default:
		BT_ERR("Invalid type: %u", type);
 10058f8:	4601      	mov	r1, r0
 10058fa:	1ad2      	subs	r2, r2, r3
 10058fc:	08d2      	lsrs	r2, r2, #3
 10058fe:	0192      	lsls	r2, r2, #6
 1005900:	4813      	ldr	r0, [pc, #76]	; (1005950 <bt_buf_get_tx+0x6c>)
 1005902:	f042 0201 	orr.w	r2, r2, #1
 1005906:	f00f fdff 	bl	1015508 <log_1>
		return NULL;
 100590a:	2400      	movs	r4, #0
	if (data && size) {
		net_buf_add_mem(buf, data, size);
	}

	return buf;
}
 100590c:	4620      	mov	r0, r4
 100590e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (type) {
 1005912:	4810      	ldr	r0, [pc, #64]	; (1005954 <bt_buf_get_tx+0x70>)
	buf = net_buf_alloc(pool, timeout);
 1005914:	f011 f95e 	bl	1016bd4 <net_buf_alloc_fixed>
	if (!buf) {
 1005918:	4604      	mov	r4, r0
 100591a:	2800      	cmp	r0, #0
 100591c:	d0f6      	beq.n	100590c <bt_buf_get_tx+0x28>
	net_buf_reserve(buf, BT_BUF_RESERVE);
 100591e:	f100 0608 	add.w	r6, r0, #8
 1005922:	2101      	movs	r1, #1
 1005924:	4630      	mov	r0, r6
 1005926:	f011 f974 	bl	1016c12 <net_buf_simple_reserve>
 100592a:	7525      	strb	r5, [r4, #20]
	if (data && size) {
 100592c:	2f00      	cmp	r7, #0
 100592e:	d0ed      	beq.n	100590c <bt_buf_get_tx+0x28>
 1005930:	f1b8 0f00 	cmp.w	r8, #0
 1005934:	d0ea      	beq.n	100590c <bt_buf_get_tx+0x28>
		net_buf_add_mem(buf, data, size);
 1005936:	4642      	mov	r2, r8
 1005938:	4639      	mov	r1, r7
 100593a:	4630      	mov	r0, r6
 100593c:	f011 f980 	bl	1016c40 <net_buf_simple_add_mem>
 1005940:	e7e4      	b.n	100590c <bt_buf_get_tx+0x28>
		pool = &hci_acl_pool;
 1005942:	4805      	ldr	r0, [pc, #20]	; (1005958 <bt_buf_get_tx+0x74>)
 1005944:	e7e6      	b.n	1005914 <bt_buf_get_tx+0x30>
 1005946:	bf00      	nop
 1005948:	01018208 	.word	0x01018208
 100594c:	010182c8 	.word	0x010182c8
 1005950:	01019845 	.word	0x01019845
 1005954:	21000664 	.word	0x21000664
 1005958:	2100063c 	.word	0x2100063c

0100595c <bt_recv>:
{
	return bt_buf_get_rx(BT_BUF_EVT, timeout);
}

int bt_recv(struct net_buf *buf)
{
 100595c:	b508      	push	{r3, lr}
			return -EINVAL;
		}
	}

	/* Queue to RAW rx queue */
	net_buf_put(raw_rx, buf);
 100595e:	4b03      	ldr	r3, [pc, #12]	; (100596c <bt_recv+0x10>)
{
 1005960:	4601      	mov	r1, r0
	net_buf_put(raw_rx, buf);
 1005962:	6818      	ldr	r0, [r3, #0]
 1005964:	f011 f959 	bl	1016c1a <net_buf_put>

	return 0;
}
 1005968:	2000      	movs	r0, #0
 100596a:	bd08      	pop	{r3, pc}
 100596c:	210009dc 	.word	0x210009dc

01005970 <bt_enable_raw>:
		cmd_ext_size = size;
	}
}

int bt_enable_raw(struct k_fifo *rx_queue)
{
 1005970:	b538      	push	{r3, r4, r5, lr}
 1005972:	4a13      	ldr	r2, [pc, #76]	; (10059c0 <bt_enable_raw+0x50>)
	const struct bt_hci_driver *drv = bt_dev.drv;
 1005974:	4b13      	ldr	r3, [pc, #76]	; (10059c4 <bt_enable_raw+0x54>)
 1005976:	4c14      	ldr	r4, [pc, #80]	; (10059c8 <bt_enable_raw+0x58>)
 1005978:	681d      	ldr	r5, [r3, #0]
	int err;

	BT_DBG("");

	raw_rx = rx_queue;
 100597a:	1aa4      	subs	r4, r4, r2
 100597c:	4b13      	ldr	r3, [pc, #76]	; (10059cc <bt_enable_raw+0x5c>)
 100597e:	08e4      	lsrs	r4, r4, #3
 1005980:	6018      	str	r0, [r3, #0]

	if (!bt_dev.drv) {
 1005982:	01a4      	lsls	r4, r4, #6
 1005984:	b945      	cbnz	r5, 1005998 <bt_enable_raw+0x28>
		BT_ERR("No HCI driver registered");
 1005986:	4812      	ldr	r0, [pc, #72]	; (10059d0 <bt_enable_raw+0x60>)
 1005988:	f044 0101 	orr.w	r1, r4, #1
 100598c:	f00f fdaf 	bl	10154ee <log_0>
		return -ENODEV;
 1005990:	f06f 0512 	mvn.w	r5, #18
	}

	BT_INFO("Bluetooth enabled in RAW mode");

	return 0;
}
 1005994:	4628      	mov	r0, r5
 1005996:	bd38      	pop	{r3, r4, r5, pc}
		bt_hci_ecc_init();
 1005998:	f000 f96c 	bl	1005c74 <bt_hci_ecc_init>
	err = drv->open();
 100599c:	68eb      	ldr	r3, [r5, #12]
 100599e:	4798      	blx	r3
	if (err) {
 10059a0:	4605      	mov	r5, r0
 10059a2:	b130      	cbz	r0, 10059b2 <bt_enable_raw+0x42>
		BT_ERR("HCI driver open failed (%d)", err);
 10059a4:	4601      	mov	r1, r0
 10059a6:	f044 0201 	orr.w	r2, r4, #1
 10059aa:	480a      	ldr	r0, [pc, #40]	; (10059d4 <bt_enable_raw+0x64>)
 10059ac:	f00f fdac 	bl	1015508 <log_1>
		return err;
 10059b0:	e7f0      	b.n	1005994 <bt_enable_raw+0x24>
	BT_INFO("Bluetooth enabled in RAW mode");
 10059b2:	4809      	ldr	r0, [pc, #36]	; (10059d8 <bt_enable_raw+0x68>)
 10059b4:	f044 0103 	orr.w	r1, r4, #3
 10059b8:	f00f fd99 	bl	10154ee <log_0>
	return 0;
 10059bc:	e7ea      	b.n	1005994 <bt_enable_raw+0x24>
 10059be:	bf00      	nop
 10059c0:	01018208 	.word	0x01018208
 10059c4:	210009d8 	.word	0x210009d8
 10059c8:	010182c8 	.word	0x010182c8
 10059cc:	210009dc 	.word	0x210009dc
 10059d0:	01019856 	.word	0x01019856
 10059d4:	0101986f 	.word	0x0101986f
 10059d8:	0101988b 	.word	0x0101988b

010059dc <ecc_thread>:

	bt_recv(buf);
}

static void ecc_thread(void *p1, void *p2, void *p3)
{
 10059dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 10059e0:	f8df 8194 	ldr.w	r8, [pc, #404]	; 1005b78 <ecc_thread+0x19c>
 10059e4:	4d5b      	ldr	r5, [pc, #364]	; (1005b54 <ecc_thread+0x178>)
 10059e6:	4647      	mov	r7, r8
 10059e8:	4b5b      	ldr	r3, [pc, #364]	; (1005b58 <ecc_thread+0x17c>)
	return z_impl_k_sem_take(sem, timeout);
 10059ea:	f8df 9190 	ldr.w	r9, [pc, #400]	; 1005b7c <ecc_thread+0x1a0>
 10059ee:	1aed      	subs	r5, r5, r3
 10059f0:	08ed      	lsrs	r5, r5, #3
 10059f2:	f04f 32ff 	mov.w	r2, #4294967295
 10059f6:	f04f 33ff 	mov.w	r3, #4294967295
 10059fa:	4648      	mov	r0, r9
 10059fc:	f00e fefa 	bl	10147f4 <z_impl_k_sem_take>
 1005a00:	e8d8 4faf 	lda	r4, [r8]
	while (true) {
		k_sem_take(&cmd_sem, K_FOREVER);

		if (atomic_test_bit(flags, PENDING_PUB_KEY)) {
 1005a04:	f014 0401 	ands.w	r4, r4, #1
 1005a08:	d056      	beq.n	1005ab8 <ecc_thread+0xdc>
		rc = uECC_make_key(ecc.pk, ecc.private_key, &curve_secp256r1);
 1005a0a:	f8df a164 	ldr.w	sl, [pc, #356]	; 1005b70 <ecc_thread+0x194>
 1005a0e:	4c53      	ldr	r4, [pc, #332]	; (1005b5c <ecc_thread+0x180>)
	} while (memcmp(ecc.private_key, debug_private_key, 32) == 0);
 1005a10:	4e53      	ldr	r6, [pc, #332]	; (1005b60 <ecc_thread+0x184>)
		rc = uECC_make_key(ecc.pk, ecc.private_key, &curve_secp256r1);
 1005a12:	4652      	mov	r2, sl
 1005a14:	4621      	mov	r1, r4
 1005a16:	4853      	ldr	r0, [pc, #332]	; (1005b64 <ecc_thread+0x188>)
 1005a18:	f010 f890 	bl	1015b3c <uECC_make_key>
		if (rc == TC_CRYPTO_FAIL) {
 1005a1c:	bbc8      	cbnz	r0, 1005a92 <ecc_thread+0xb6>
			BT_ERR("Failed to create ECC public/private pair");
 1005a1e:	01a9      	lsls	r1, r5, #6
 1005a20:	4851      	ldr	r0, [pc, #324]	; (1005b68 <ecc_thread+0x18c>)
 1005a22:	f041 0101 	orr.w	r1, r1, #1
 1005a26:	f00f fd62 	bl	10154ee <log_0>
			return BT_HCI_ERR_UNSPECIFIED;
 1005a2a:	f04f 0a1f 	mov.w	sl, #31
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 1005a2e:	f04f 32ff 	mov.w	r2, #4294967295
 1005a32:	f04f 33ff 	mov.w	r3, #4294967295
 1005a36:	2001      	movs	r0, #1
 1005a38:	f7ff ff2c 	bl	1005894 <bt_buf_get_rx>
	hdr = net_buf_add(buf, sizeof(*hdr));
 1005a3c:	f100 0608 	add.w	r6, r0, #8
 1005a40:	2102      	movs	r1, #2
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 1005a42:	4604      	mov	r4, r0
	hdr = net_buf_add(buf, sizeof(*hdr));
 1005a44:	4630      	mov	r0, r6
 1005a46:	f011 f8f5 	bl	1016c34 <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_LE_META_EVENT;
 1005a4a:	233e      	movs	r3, #62	; 0x3e
 1005a4c:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*meta) + sizeof(*evt);
 1005a4e:	2342      	movs	r3, #66	; 0x42
	meta = net_buf_add(buf, sizeof(*meta));
 1005a50:	2101      	movs	r1, #1
	hdr->len = sizeof(*meta) + sizeof(*evt);
 1005a52:	7043      	strb	r3, [r0, #1]
	meta = net_buf_add(buf, sizeof(*meta));
 1005a54:	4630      	mov	r0, r6
 1005a56:	f011 f8ed 	bl	1016c34 <net_buf_simple_add>
	meta->subevent = BT_HCI_EVT_LE_P256_PUBLIC_KEY_COMPLETE;
 1005a5a:	2308      	movs	r3, #8
	evt = net_buf_add(buf, sizeof(*evt));
 1005a5c:	2141      	movs	r1, #65	; 0x41
	meta->subevent = BT_HCI_EVT_LE_P256_PUBLIC_KEY_COMPLETE;
 1005a5e:	7003      	strb	r3, [r0, #0]
	evt = net_buf_add(buf, sizeof(*evt));
 1005a60:	4630      	mov	r0, r6
 1005a62:	f011 f8e7 	bl	1016c34 <net_buf_simple_add>
 1005a66:	4606      	mov	r6, r0
	evt->status = status;
 1005a68:	f800 ab01 	strb.w	sl, [r0], #1
	if (status) {
 1005a6c:	f1ba 0f00 	cmp.w	sl, #0
 1005a70:	d019      	beq.n	1005aa6 <ecc_thread+0xca>
		(void)memset(evt->key, 0, sizeof(evt->key));
 1005a72:	2240      	movs	r2, #64	; 0x40
 1005a74:	2100      	movs	r1, #0
 1005a76:	f010 fffa 	bl	1016a6e <memset>
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 1005a7a:	e8d7 3fef 	ldaex	r3, [r7]
 1005a7e:	f023 0301 	bic.w	r3, r3, #1
 1005a82:	e8c7 3fe2 	stlex	r2, r3, [r7]
 1005a86:	2a00      	cmp	r2, #0
 1005a88:	d1f7      	bne.n	1005a7a <ecc_thread+0x9e>
	bt_recv(buf);
 1005a8a:	4620      	mov	r0, r4
	bt_recv(buf);
 1005a8c:	f7ff ff66 	bl	100595c <bt_recv>
	while (true) {
 1005a90:	e7af      	b.n	10059f2 <ecc_thread+0x16>
	} while (memcmp(ecc.private_key, debug_private_key, 32) == 0);
 1005a92:	2220      	movs	r2, #32
 1005a94:	4631      	mov	r1, r6
 1005a96:	4620      	mov	r0, r4
 1005a98:	f010 ffae 	bl	10169f8 <memcmp>
 1005a9c:	2800      	cmp	r0, #0
 1005a9e:	d0b8      	beq.n	1005a12 <ecc_thread+0x36>
	return 0;
 1005aa0:	f04f 0a00 	mov.w	sl, #0
 1005aa4:	e7c3      	b.n	1005a2e <ecc_thread+0x52>
		sys_memcpy_swap(evt->key, ecc.pk, 32);
 1005aa6:	492f      	ldr	r1, [pc, #188]	; (1005b64 <ecc_thread+0x188>)
 1005aa8:	f011 f882 	bl	1016bb0 <sys_memcpy_swap.constprop.0>
		sys_memcpy_swap(&evt->key[32], &ecc.pk[32], 32);
 1005aac:	492f      	ldr	r1, [pc, #188]	; (1005b6c <ecc_thread+0x190>)
 1005aae:	f106 0021 	add.w	r0, r6, #33	; 0x21
 1005ab2:	f011 f87d 	bl	1016bb0 <sys_memcpy_swap.constprop.0>
 1005ab6:	e7e0      	b.n	1005a7a <ecc_thread+0x9e>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 1005ab8:	e8d8 3faf 	lda	r3, [r8]
			emulate_le_p256_public_key_cmd();
		} else if (atomic_test_bit(flags, PENDING_DHKEY)) {
 1005abc:	079b      	lsls	r3, r3, #30
 1005abe:	d598      	bpl.n	10059f2 <ecc_thread+0x16>
	ret = uECC_valid_public_key(ecc.pk, &curve_secp256r1);
 1005ac0:	492b      	ldr	r1, [pc, #172]	; (1005b70 <ecc_thread+0x194>)
 1005ac2:	4828      	ldr	r0, [pc, #160]	; (1005b64 <ecc_thread+0x188>)
 1005ac4:	f010 ff07 	bl	10168d6 <uECC_valid_public_key>
	if (ret < 0) {
 1005ac8:	1e01      	subs	r1, r0, #0
 1005aca:	da34      	bge.n	1005b36 <ecc_thread+0x15a>
		BT_ERR("public key is not valid (ret %d)", ret);
 1005acc:	01aa      	lsls	r2, r5, #6
 1005ace:	4829      	ldr	r0, [pc, #164]	; (1005b74 <ecc_thread+0x198>)
 1005ad0:	f042 0201 	orr.w	r2, r2, #1
 1005ad4:	f00f fd18 	bl	1015508 <log_1>
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 1005ad8:	f04f 32ff 	mov.w	r2, #4294967295
 1005adc:	f04f 33ff 	mov.w	r3, #4294967295
 1005ae0:	2001      	movs	r0, #1
 1005ae2:	f7ff fed7 	bl	1005894 <bt_buf_get_rx>
	hdr = net_buf_add(buf, sizeof(*hdr));
 1005ae6:	f100 0a08 	add.w	sl, r0, #8
 1005aea:	2102      	movs	r1, #2
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 1005aec:	4606      	mov	r6, r0
	hdr = net_buf_add(buf, sizeof(*hdr));
 1005aee:	4650      	mov	r0, sl
 1005af0:	f011 f8a0 	bl	1016c34 <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_LE_META_EVENT;
 1005af4:	233e      	movs	r3, #62	; 0x3e
 1005af6:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*meta) + sizeof(*evt);
 1005af8:	2322      	movs	r3, #34	; 0x22
	meta = net_buf_add(buf, sizeof(*meta));
 1005afa:	2101      	movs	r1, #1
	hdr->len = sizeof(*meta) + sizeof(*evt);
 1005afc:	7043      	strb	r3, [r0, #1]
	meta = net_buf_add(buf, sizeof(*meta));
 1005afe:	4650      	mov	r0, sl
 1005b00:	f011 f898 	bl	1016c34 <net_buf_simple_add>
	meta->subevent = BT_HCI_EVT_LE_GENERATE_DHKEY_COMPLETE;
 1005b04:	2309      	movs	r3, #9
	evt = net_buf_add(buf, sizeof(*evt));
 1005b06:	2121      	movs	r1, #33	; 0x21
	meta->subevent = BT_HCI_EVT_LE_GENERATE_DHKEY_COMPLETE;
 1005b08:	7003      	strb	r3, [r0, #0]
	evt = net_buf_add(buf, sizeof(*evt));
 1005b0a:	4650      	mov	r0, sl
 1005b0c:	f011 f892 	bl	1016c34 <net_buf_simple_add>
 1005b10:	4603      	mov	r3, r0
	if (ret == TC_CRYPTO_FAIL) {
 1005b12:	3001      	adds	r0, #1
 1005b14:	b9c4      	cbnz	r4, 1005b48 <ecc_thread+0x16c>
		evt->status = BT_HCI_ERR_UNSPECIFIED;
 1005b16:	221f      	movs	r2, #31
		(void)memset(evt->dhkey, 0, sizeof(evt->dhkey));
 1005b18:	4621      	mov	r1, r4
		evt->status = BT_HCI_ERR_UNSPECIFIED;
 1005b1a:	701a      	strb	r2, [r3, #0]
		(void)memset(evt->dhkey, 0, sizeof(evt->dhkey));
 1005b1c:	2220      	movs	r2, #32
 1005b1e:	f010 ffa6 	bl	1016a6e <memset>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 1005b22:	e8d7 3fef 	ldaex	r3, [r7]
 1005b26:	f023 0302 	bic.w	r3, r3, #2
 1005b2a:	e8c7 3fe2 	stlex	r2, r3, [r7]
 1005b2e:	2a00      	cmp	r2, #0
 1005b30:	d1f7      	bne.n	1005b22 <ecc_thread+0x146>
	bt_recv(buf);
 1005b32:	4630      	mov	r0, r6
 1005b34:	e7aa      	b.n	1005a8c <ecc_thread+0xb0>
		ret = uECC_shared_secret(ecc.pk, ecc.private_key, ecc.dhkey,
 1005b36:	4a0b      	ldr	r2, [pc, #44]	; (1005b64 <ecc_thread+0x188>)
 1005b38:	4b0d      	ldr	r3, [pc, #52]	; (1005b70 <ecc_thread+0x194>)
 1005b3a:	4610      	mov	r0, r2
 1005b3c:	f1a2 0120 	sub.w	r1, r2, #32
 1005b40:	f010 f84b 	bl	1015bda <uECC_shared_secret>
 1005b44:	4604      	mov	r4, r0
 1005b46:	e7c7      	b.n	1005ad8 <ecc_thread+0xfc>
		evt->status = 0U;
 1005b48:	2200      	movs	r2, #0
		sys_memcpy_swap(evt->dhkey, ecc.dhkey, sizeof(ecc.dhkey));
 1005b4a:	4906      	ldr	r1, [pc, #24]	; (1005b64 <ecc_thread+0x188>)
		evt->status = 0U;
 1005b4c:	701a      	strb	r2, [r3, #0]
		sys_memcpy_swap(evt->dhkey, ecc.dhkey, sizeof(ecc.dhkey));
 1005b4e:	f011 f82f 	bl	1016bb0 <sys_memcpy_swap.constprop.0>
 1005b52:	e7e6      	b.n	1005b22 <ecc_thread+0x146>
 1005b54:	010182c0 	.word	0x010182c0
 1005b58:	01018208 	.word	0x01018208
 1005b5c:	21008064 	.word	0x21008064
 1005b60:	010185a8 	.word	0x010185a8
 1005b64:	21008084 	.word	0x21008084
 1005b68:	010198b4 	.word	0x010198b4
 1005b6c:	210080a4 	.word	0x210080a4
 1005b70:	010184f8 	.word	0x010184f8
 1005b74:	010198dd 	.word	0x010198dd
 1005b78:	21000a54 	.word	0x21000a54
 1005b7c:	210005b0 	.word	0x210005b0

01005b80 <bt_hci_ecc_send>:

	send_cmd_status(BT_HCI_OP_LE_P256_PUBLIC_KEY, status);
}

int bt_hci_ecc_send(struct net_buf *buf)
{
 1005b80:	b570      	push	{r4, r5, r6, lr}
	return (enum bt_buf_type)(*(u8_t *)net_buf_user_data(buf));
 1005b82:	7d05      	ldrb	r5, [r0, #20]
 1005b84:	4604      	mov	r4, r0
	if (bt_buf_get_type(buf) == BT_BUF_CMD) {
 1005b86:	b9ad      	cbnz	r5, 1005bb4 <bt_hci_ecc_send+0x34>
		struct bt_hci_cmd_hdr *chdr = (void *)buf->data;

		switch (sys_le16_to_cpu(chdr->opcode)) {
 1005b88:	f242 0125 	movw	r1, #8229	; 0x2025
		struct bt_hci_cmd_hdr *chdr = (void *)buf->data;
 1005b8c:	6883      	ldr	r3, [r0, #8]
		switch (sys_le16_to_cpu(chdr->opcode)) {
 1005b8e:	881a      	ldrh	r2, [r3, #0]
 1005b90:	428a      	cmp	r2, r1
 1005b92:	d016      	beq.n	1005bc2 <bt_hci_ecc_send+0x42>
 1005b94:	f242 0126 	movw	r1, #8230	; 0x2026
 1005b98:	428a      	cmp	r2, r1
 1005b9a:	d034      	beq.n	1005c06 <bt_hci_ecc_send+0x86>
 1005b9c:	f242 0101 	movw	r1, #8193	; 0x2001
 1005ba0:	428a      	cmp	r2, r1
 1005ba2:	d107      	bne.n	1005bb4 <bt_hci_ecc_send+0x34>
	cmd->events[0] &= ~0x80; /* LE Read Local P-256 PKey Compl */
 1005ba4:	78da      	ldrb	r2, [r3, #3]
 1005ba6:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 1005baa:	70da      	strb	r2, [r3, #3]
	cmd->events[1] &= ~0x01; /* LE Generate DHKey Compl Event */
 1005bac:	791a      	ldrb	r2, [r3, #4]
 1005bae:	f022 0201 	bic.w	r2, r2, #1
 1005bb2:	711a      	strb	r2, [r3, #4]
		default:
			break;
		}
	}

	return bt_dev.drv->send(buf);
 1005bb4:	4b2a      	ldr	r3, [pc, #168]	; (1005c60 <bt_hci_ecc_send+0xe0>)
 1005bb6:	4620      	mov	r0, r4
}
 1005bb8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_dev.drv->send(buf);
 1005bbc:	681b      	ldr	r3, [r3, #0]
 1005bbe:	691b      	ldr	r3, [r3, #16]
 1005bc0:	4718      	bx	r3
			net_buf_pull(buf, sizeof(*chdr));
 1005bc2:	2103      	movs	r1, #3
 1005bc4:	3008      	adds	r0, #8
 1005bc6:	f011 f84d 	bl	1016c64 <net_buf_simple_pull>
	net_buf_unref(buf);
 1005bca:	4620      	mov	r0, r4
 1005bcc:	f00c ff6e 	bl	1012aac <net_buf_unref>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 1005bd0:	4b24      	ldr	r3, [pc, #144]	; (1005c64 <bt_hci_ecc_send+0xe4>)
 1005bd2:	e8d3 2faf 	lda	r2, [r3]
	if (atomic_test_bit(flags, PENDING_DHKEY)) {
 1005bd6:	0790      	lsls	r0, r2, #30
 1005bd8:	d507      	bpl.n	1005bea <bt_hci_ecc_send+0x6a>
		status = BT_HCI_ERR_CMD_DISALLOWED;
 1005bda:	250c      	movs	r5, #12
	send_cmd_status(BT_HCI_OP_LE_P256_PUBLIC_KEY, status);
 1005bdc:	4629      	mov	r1, r5
 1005bde:	f242 0025 	movw	r0, #8229	; 0x2025
	send_cmd_status(BT_HCI_OP_LE_GENERATE_DHKEY, status);
 1005be2:	f010 ffc1 	bl	1016b68 <send_cmd_status>
}
 1005be6:	2000      	movs	r0, #0
 1005be8:	bd70      	pop	{r4, r5, r6, pc}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 1005bea:	e8d3 2fef 	ldaex	r2, [r3]
 1005bee:	f042 0101 	orr.w	r1, r2, #1
 1005bf2:	e8c3 1fe0 	stlex	r0, r1, [r3]
 1005bf6:	2800      	cmp	r0, #0
 1005bf8:	d1f7      	bne.n	1005bea <bt_hci_ecc_send+0x6a>
	} else if (atomic_test_and_set_bit(flags, PENDING_PUB_KEY)) {
 1005bfa:	07d1      	lsls	r1, r2, #31
 1005bfc:	d4ed      	bmi.n	1005bda <bt_hci_ecc_send+0x5a>
	z_impl_k_sem_give(sem);
 1005bfe:	481a      	ldr	r0, [pc, #104]	; (1005c68 <bt_hci_ecc_send+0xe8>)
 1005c00:	f00e fdd2 	bl	10147a8 <z_impl_k_sem_give>
}
 1005c04:	e7ea      	b.n	1005bdc <bt_hci_ecc_send+0x5c>
			net_buf_pull(buf, sizeof(*chdr));
 1005c06:	2103      	movs	r1, #3
 1005c08:	3008      	adds	r0, #8
 1005c0a:	f011 f82b 	bl	1016c64 <net_buf_simple_pull>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 1005c0e:	4b15      	ldr	r3, [pc, #84]	; (1005c64 <bt_hci_ecc_send+0xe4>)
 1005c10:	e8d3 2faf 	lda	r2, [r3]
	if (atomic_test_bit(flags, PENDING_PUB_KEY)) {
 1005c14:	07d2      	lsls	r2, r2, #31
 1005c16:	d507      	bpl.n	1005c28 <bt_hci_ecc_send+0xa8>
		status = BT_HCI_ERR_CMD_DISALLOWED;
 1005c18:	250c      	movs	r5, #12
	net_buf_unref(buf);
 1005c1a:	4620      	mov	r0, r4
 1005c1c:	f00c ff46 	bl	1012aac <net_buf_unref>
	send_cmd_status(BT_HCI_OP_LE_GENERATE_DHKEY, status);
 1005c20:	4629      	mov	r1, r5
 1005c22:	f242 0026 	movw	r0, #8230	; 0x2026
 1005c26:	e7dc      	b.n	1005be2 <bt_hci_ecc_send+0x62>
	if (buf->len < sizeof(struct bt_hci_cp_le_generate_dhkey)) {
 1005c28:	89a2      	ldrh	r2, [r4, #12]
 1005c2a:	2a3f      	cmp	r2, #63	; 0x3f
 1005c2c:	d915      	bls.n	1005c5a <bt_hci_ecc_send+0xda>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 1005c2e:	e8d3 2fef 	ldaex	r2, [r3]
 1005c32:	f042 0102 	orr.w	r1, r2, #2
 1005c36:	e8c3 1fe0 	stlex	r0, r1, [r3]
 1005c3a:	2800      	cmp	r0, #0
 1005c3c:	d1f7      	bne.n	1005c2e <bt_hci_ecc_send+0xae>
	if (atomic_test_and_set_bit(flags, PENDING_DHKEY)) {
 1005c3e:	0793      	lsls	r3, r2, #30
 1005c40:	d4ea      	bmi.n	1005c18 <bt_hci_ecc_send+0x98>
	cmd = (void *)buf->data;
 1005c42:	68a1      	ldr	r1, [r4, #8]
	sys_memcpy_swap(ecc.pk, cmd->key, 32);
 1005c44:	4809      	ldr	r0, [pc, #36]	; (1005c6c <bt_hci_ecc_send+0xec>)
 1005c46:	f010 ffb3 	bl	1016bb0 <sys_memcpy_swap.constprop.0>
	sys_memcpy_swap(&ecc.pk[32], &cmd->key[32], 32);
 1005c4a:	4809      	ldr	r0, [pc, #36]	; (1005c70 <bt_hci_ecc_send+0xf0>)
 1005c4c:	3120      	adds	r1, #32
 1005c4e:	f010 ffaf 	bl	1016bb0 <sys_memcpy_swap.constprop.0>
	z_impl_k_sem_give(sem);
 1005c52:	4805      	ldr	r0, [pc, #20]	; (1005c68 <bt_hci_ecc_send+0xe8>)
 1005c54:	f00e fda8 	bl	10147a8 <z_impl_k_sem_give>
}
 1005c58:	e7df      	b.n	1005c1a <bt_hci_ecc_send+0x9a>
		status = BT_HCI_ERR_INVALID_PARAM;
 1005c5a:	2512      	movs	r5, #18
 1005c5c:	e7dd      	b.n	1005c1a <bt_hci_ecc_send+0x9a>
 1005c5e:	bf00      	nop
 1005c60:	210009d8 	.word	0x210009d8
 1005c64:	21000a54 	.word	0x21000a54
 1005c68:	210005b0 	.word	0x210005b0
 1005c6c:	21008084 	.word	0x21008084
 1005c70:	210080a4 	.word	0x210080a4

01005c74 <bt_hci_ecc_init>:
{
	return !bt_rand(dst, len);
}

void bt_hci_ecc_init(void)
{
 1005c74:	b510      	push	{r4, lr}
 1005c76:	b088      	sub	sp, #32
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 1005c78:	2200      	movs	r2, #0
 1005c7a:	2300      	movs	r3, #0
 1005c7c:	e9cd 2306 	strd	r2, r3, [sp, #24]
 1005c80:	2300      	movs	r3, #0
 1005c82:	220a      	movs	r2, #10
 1005c84:	4c09      	ldr	r4, [pc, #36]	; (1005cac <bt_hci_ecc_init+0x38>)
 1005c86:	e9cd 2303 	strd	r2, r3, [sp, #12]
 1005c8a:	e9cd 3301 	strd	r3, r3, [sp, #4]
 1005c8e:	9300      	str	r3, [sp, #0]
 1005c90:	f240 424c 	movw	r2, #1100	; 0x44c
 1005c94:	4620      	mov	r0, r4
 1005c96:	4b06      	ldr	r3, [pc, #24]	; (1005cb0 <bt_hci_ecc_init+0x3c>)
 1005c98:	4906      	ldr	r1, [pc, #24]	; (1005cb4 <bt_hci_ecc_init+0x40>)
 1005c9a:	f00e fe13 	bl	10148c4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
 1005c9e:	4620      	mov	r0, r4
 1005ca0:	4905      	ldr	r1, [pc, #20]	; (1005cb8 <bt_hci_ecc_init+0x44>)
	k_thread_create(&ecc_thread_data, ecc_thread_stack,
			K_THREAD_STACK_SIZEOF(ecc_thread_stack), ecc_thread,
			NULL, NULL, NULL, K_PRIO_PREEMPT(10), 0, K_NO_WAIT);
	k_thread_name_set(&ecc_thread_data, "BT ECC");
}
 1005ca2:	b008      	add	sp, #32
 1005ca4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 1005ca8:	f011 bfd1 	b.w	1017c4e <z_impl_k_thread_name_set>
 1005cac:	210009e0 	.word	0x210009e0
 1005cb0:	010059dd 	.word	0x010059dd
 1005cb4:	210087d8 	.word	0x210087d8
 1005cb8:	010198fe 	.word	0x010198fe

01005cbc <mem_init>:

#include "mem.h"

void mem_init(void *mem_pool, u16_t mem_size, u16_t mem_count,
	      void **mem_head)
{
 1005cbc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1005cc0:	4614      	mov	r4, r2
	*mem_head = mem_pool;

	/* Store free mem_count after the list's next pointer at an 32-bit
	 * aligned memory location to ensure atomic read/write (in ARM for now).
	 */
	*((u16_t *)MROUND((u8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
 1005cc2:	1dc2      	adds	r2, r0, #7

	/* Initialize next pointers to form a free list,
	 * next pointer is stored in the first 32-bit of each block
	 */
	(void)memset(((u8_t *)mem_pool + (mem_size * (--mem_count))), 0,
 1005cc4:	1e66      	subs	r6, r4, #1
	*((u16_t *)MROUND((u8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
 1005cc6:	f022 0203 	bic.w	r2, r2, #3
	(void)memset(((u8_t *)mem_pool + (mem_size * (--mem_count))), 0,
 1005cca:	b2b6      	uxth	r6, r6
	*mem_head = mem_pool;
 1005ccc:	6018      	str	r0, [r3, #0]
{
 1005cce:	4605      	mov	r5, r0
 1005cd0:	460f      	mov	r7, r1
	(void)memset(((u8_t *)mem_pool + (mem_size * (--mem_count))), 0,
 1005cd2:	fb01 0006 	mla	r0, r1, r6, r0
{
 1005cd6:	b082      	sub	sp, #8
	*((u16_t *)MROUND((u8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
 1005cd8:	8014      	strh	r4, [r2, #0]
	(void)memset(((u8_t *)mem_pool + (mem_size * (--mem_count))), 0,
 1005cda:	2100      	movs	r1, #0
 1005cdc:	2204      	movs	r2, #4
 1005cde:	f010 fec6 	bl	1016a6e <memset>
		     sizeof(mem_pool));
	while (mem_count--) {
 1005ce2:	b1b6      	cbz	r6, 1005d12 <mem_init+0x56>
 1005ce4:	f64f 78ff 	movw	r8, #65535	; 0xffff
 1005ce8:	3c02      	subs	r4, #2
 1005cea:	b2a4      	uxth	r4, r4
 1005cec:	fb04 7307 	mla	r3, r4, r7, r7
 1005cf0:	fb04 f607 	mul.w	r6, r4, r7
 1005cf4:	441d      	add	r5, r3
 1005cf6:	1af6      	subs	r6, r6, r3
		u32_t next;

		next = (u32_t)((u8_t *) mem_pool +
			       (mem_size * (mem_count + 1)));
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
 1005cf8:	2204      	movs	r2, #4
	while (mem_count--) {
 1005cfa:	3c01      	subs	r4, #1
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
 1005cfc:	19a8      	adds	r0, r5, r6
 1005cfe:	eb0d 0102 	add.w	r1, sp, r2
	while (mem_count--) {
 1005d02:	b2a4      	uxth	r4, r4
		next = (u32_t)((u8_t *) mem_pool +
 1005d04:	9501      	str	r5, [sp, #4]
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
 1005d06:	f010 fe87 	bl	1016a18 <memcpy>
	while (mem_count--) {
 1005d0a:	4544      	cmp	r4, r8
 1005d0c:	eba5 0507 	sub.w	r5, r5, r7
 1005d10:	d1f2      	bne.n	1005cf8 <mem_init+0x3c>
		       (void *)&next, sizeof(next));
	}
}
 1005d12:	b002      	add	sp, #8
 1005d14:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

01005d18 <mem_acquire>:

void *mem_acquire(void **mem_head)
{
 1005d18:	b570      	push	{r4, r5, r6, lr}
	if (*mem_head) {
 1005d1a:	6805      	ldr	r5, [r0, #0]
{
 1005d1c:	b082      	sub	sp, #8
	if (*mem_head) {
 1005d1e:	b195      	cbz	r5, 1005d46 <mem_acquire+0x2e>
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
					       sizeof(mem_head)));
		free_count--;

		mem = *mem_head;
		memcpy(&head, mem, sizeof(head));
 1005d20:	2204      	movs	r2, #4
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
 1005d22:	1deb      	adds	r3, r5, #7
 1005d24:	f023 0303 	bic.w	r3, r3, #3
 1005d28:	4604      	mov	r4, r0
		memcpy(&head, mem, sizeof(head));
 1005d2a:	4629      	mov	r1, r5
 1005d2c:	eb0d 0002 	add.w	r0, sp, r2
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
 1005d30:	881e      	ldrh	r6, [r3, #0]
		memcpy(&head, mem, sizeof(head));
 1005d32:	f010 fe71 	bl	1016a18 <memcpy>

		/* Store free mem_count after the list's next pointer */
		if (head) {
 1005d36:	9a01      	ldr	r2, [sp, #4]
 1005d38:	b122      	cbz	r2, 1005d44 <mem_acquire+0x2c>
			*((u16_t *)MROUND((u8_t *)head + sizeof(head))) =
 1005d3a:	1dd3      	adds	r3, r2, #7
		free_count--;
 1005d3c:	3e01      	subs	r6, #1
			*((u16_t *)MROUND((u8_t *)head + sizeof(head))) =
 1005d3e:	f023 0303 	bic.w	r3, r3, #3
 1005d42:	801e      	strh	r6, [r3, #0]
				free_count;
		}

		*mem_head = head;
 1005d44:	6022      	str	r2, [r4, #0]
		return mem;
	}

	return NULL;
}
 1005d46:	4628      	mov	r0, r5
 1005d48:	b002      	add	sp, #8
 1005d4a:	bd70      	pop	{r4, r5, r6, pc}

01005d4c <mem_release>:
void mem_release(void *mem, void **mem_head)
{
	u16_t free_count = 0U;

	/* Get the free count from the list and increment it */
	if (*mem_head) {
 1005d4c:	680b      	ldr	r3, [r1, #0]
{
 1005d4e:	b570      	push	{r4, r5, r6, lr}
 1005d50:	460c      	mov	r4, r1
 1005d52:	4605      	mov	r5, r0
	if (*mem_head) {
 1005d54:	b183      	cbz	r3, 1005d78 <mem_release+0x2c>
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
 1005d56:	3307      	adds	r3, #7
 1005d58:	f023 0303 	bic.w	r3, r3, #3
 1005d5c:	881e      	ldrh	r6, [r3, #0]
 1005d5e:	3601      	adds	r6, #1
 1005d60:	b2b6      	uxth	r6, r6
					       sizeof(mem_head)));
	}
	free_count++;

	memcpy(mem, mem_head, sizeof(mem));
 1005d62:	2204      	movs	r2, #4
 1005d64:	4621      	mov	r1, r4
 1005d66:	4628      	mov	r0, r5
 1005d68:	f010 fe56 	bl	1016a18 <memcpy>

	/* Store free mem_count after the list's next pointer */
	*((u16_t *)MROUND((u8_t *)mem + sizeof(mem))) = free_count;
 1005d6c:	1deb      	adds	r3, r5, #7
 1005d6e:	f023 0303 	bic.w	r3, r3, #3
 1005d72:	801e      	strh	r6, [r3, #0]

	*mem_head = mem;
 1005d74:	6025      	str	r5, [r4, #0]
}
 1005d76:	bd70      	pop	{r4, r5, r6, pc}
 1005d78:	2601      	movs	r6, #1
 1005d7a:	e7f2      	b.n	1005d62 <mem_release+0x16>

01005d7c <mem_get>:
}

void *mem_get(void *mem_pool, u16_t mem_size, u16_t index)
{
	return ((void *)((u8_t *)mem_pool + (mem_size * index)));
}
 1005d7c:	fb02 0001 	mla	r0, r2, r1, r0
 1005d80:	4770      	bx	lr
 1005d82:	bf00      	nop

01005d84 <mem_index_get>:

u16_t mem_index_get(void *mem, void *mem_pool, u16_t mem_size)
{
	return ((u16_t)((u8_t *)mem - (u8_t *)mem_pool) / mem_size);
 1005d84:	1a40      	subs	r0, r0, r1
 1005d86:	b280      	uxth	r0, r0
}
 1005d88:	fbb0 f0f2 	udiv	r0, r0, r2
 1005d8c:	4770      	bx	lr
 1005d8e:	bf00      	nop

01005d90 <mem_rcopy>:
 * @details Example: [ 0x11 0x22 0x33 ] -> [ 0x33 0x22 0x11 ]
 */
void mem_rcopy(u8_t *dst, u8_t const *src, u16_t len)
{
	src += len;
	while (len--) {
 1005d90:	1e53      	subs	r3, r2, #1
	src += len;
 1005d92:	4411      	add	r1, r2
	while (len--) {
 1005d94:	b29b      	uxth	r3, r3
 1005d96:	b142      	cbz	r2, 1005daa <mem_rcopy+0x1a>
 1005d98:	43db      	mvns	r3, r3
 1005d9a:	3801      	subs	r0, #1
 1005d9c:	18ca      	adds	r2, r1, r3
		*dst++ = *--src;
 1005d9e:	f811 3d01 	ldrb.w	r3, [r1, #-1]!
	while (len--) {
 1005da2:	4291      	cmp	r1, r2
		*dst++ = *--src;
 1005da4:	f800 3f01 	strb.w	r3, [r0, #1]!
	while (len--) {
 1005da8:	d1f9      	bne.n	1005d9e <mem_rcopy+0xe>
	}
}
 1005daa:	4770      	bx	lr

01005dac <mem_nz>:
 * @brief Determine if src[0..len-1] contains one or more non-zero bytes
 * @return 0 if all bytes are zero; otherwise 1
 */
u8_t mem_nz(u8_t *src, u16_t len)
{
	while (len--) {
 1005dac:	4401      	add	r1, r0
 1005dae:	e002      	b.n	1005db6 <mem_nz+0xa>
		if (*src++) {
 1005db0:	f810 3b01 	ldrb.w	r3, [r0], #1
 1005db4:	b91b      	cbnz	r3, 1005dbe <mem_nz+0x12>
	while (len--) {
 1005db6:	4288      	cmp	r0, r1
 1005db8:	d1fa      	bne.n	1005db0 <mem_nz+0x4>
			return 1;
		}
	}

	return 0;
 1005dba:	2000      	movs	r0, #0
 1005dbc:	4770      	bx	lr
			return 1;
 1005dbe:	2001      	movs	r0, #1
}
 1005dc0:	4770      	bx	lr
 1005dc2:	bf00      	nop

01005dc4 <memq_init>:
 * @return          Initial link-element
 */
memq_link_t *memq_init(memq_link_t *link, memq_link_t **head, memq_link_t **tail)
{
	/* Head and tail pointer to the initial link - forms an empty queue */
	*head = *tail = link;
 1005dc4:	6010      	str	r0, [r2, #0]
 1005dc6:	6008      	str	r0, [r1, #0]

	return link;
}
 1005dc8:	4770      	bx	lr
 1005dca:	bf00      	nop

01005dcc <memq_deinit>:
memq_link_t *memq_deinit(memq_link_t **head, memq_link_t **tail)
{
	memq_link_t *old_head;

	/* If head and tail are not equal, then queue is not empty */
	if (*head != *tail) {
 1005dcc:	680a      	ldr	r2, [r1, #0]
{
 1005dce:	4603      	mov	r3, r0
	if (*head != *tail) {
 1005dd0:	6800      	ldr	r0, [r0, #0]
 1005dd2:	4290      	cmp	r0, r2
		return NULL;
	}

	old_head = *head;
	*head = *tail = NULL;
 1005dd4:	bf09      	itett	eq
 1005dd6:	2200      	moveq	r2, #0
		return NULL;
 1005dd8:	2000      	movne	r0, #0
	*head = *tail = NULL;
 1005dda:	600a      	streq	r2, [r1, #0]
 1005ddc:	601a      	streq	r2, [r3, #0]

	return old_head;
}
 1005dde:	4770      	bx	lr

01005de0 <memq_enqueue>:
 * @param mem[in]      The memory payload to be enqueued. Pointed to by old tail
 * @param tail[in,out] Tail of queue. Will be updated to point to link
 * @return             New tail. Note: Does not point to the new mem
 */
memq_link_t *memq_enqueue(memq_link_t *link, void *mem, memq_link_t **tail)
{
 1005de0:	b410      	push	{r4}
	/* Let the old tail element point to the new tail element */
	(*tail)->next = link;
 1005de2:	6814      	ldr	r4, [r2, #0]
 1005de4:	6020      	str	r0, [r4, #0]

	/* Let the old tail element point the the new memory */
	(*tail)->mem = mem;
 1005de6:	6814      	ldr	r4, [r2, #0]
 1005de8:	6061      	str	r1, [r4, #4]
	 * The new tail-element is not expected to point to anything sensible
	 */
	*tail = link;

	return link;
}
 1005dea:	bc10      	pop	{r4}
	*tail = link;
 1005dec:	6010      	str	r0, [r2, #0]
}
 1005dee:	4770      	bx	lr

01005df0 <memq_peek>:
 * @return         head or NULL if queue is empty
 */
memq_link_t *memq_peek(memq_link_t *head, memq_link_t *tail, void **mem)
{
	/* If head and tail are equal, then queue empty */
	if (head == tail) {
 1005df0:	4288      	cmp	r0, r1
 1005df2:	d003      	beq.n	1005dfc <memq_peek+0xc>
		return NULL;
	}

	/* Extract the head link-element's memory */
	if (mem) {
 1005df4:	b11a      	cbz	r2, 1005dfe <memq_peek+0xe>
		*mem = head->mem;
 1005df6:	6843      	ldr	r3, [r0, #4]
 1005df8:	6013      	str	r3, [r2, #0]
 1005dfa:	4770      	bx	lr
		return NULL;
 1005dfc:	2000      	movs	r0, #0
	}

	return head; /* queue was not empty */
}
 1005dfe:	4770      	bx	lr

01005e00 <memq_dequeue>:
memq_link_t *memq_dequeue(memq_link_t *tail, memq_link_t **head, void **mem)
{
	memq_link_t *old_head;

	/* Use memq peek to get the old head and its mem */
	old_head = memq_peek(*head, tail, mem);
 1005e00:	680b      	ldr	r3, [r1, #0]
	if (head == tail) {
 1005e02:	4283      	cmp	r3, r0
 1005e04:	d009      	beq.n	1005e1a <memq_dequeue+0x1a>
	if (mem) {
 1005e06:	b12a      	cbz	r2, 1005e14 <memq_dequeue+0x14>
		*mem = head->mem;
 1005e08:	6858      	ldr	r0, [r3, #4]
 1005e0a:	6010      	str	r0, [r2, #0]
	if (old_head == NULL) {
		return NULL; /* queue is empty */
	}

	/* Update the head-pointer to point to the new head element */
	*head = old_head->next;
 1005e0c:	681a      	ldr	r2, [r3, #0]
 1005e0e:	600a      	str	r2, [r1, #0]

	return old_head;
}
 1005e10:	4618      	mov	r0, r3
 1005e12:	4770      	bx	lr
	if (old_head == NULL) {
 1005e14:	2b00      	cmp	r3, #0
 1005e16:	d1f9      	bne.n	1005e0c <memq_dequeue+0xc>
 1005e18:	e7fa      	b.n	1005e10 <memq_dequeue+0x10>
		return NULL; /* queue is empty */
 1005e1a:	2300      	movs	r3, #0
 1005e1c:	e7f8      	b.n	1005e10 <memq_dequeue+0x10>
 1005e1e:	bf00      	nop

01005e20 <mayfly_init>:
#if defined(MAYFLY_UT)
static u8_t _state;
#endif /* MAYFLY_UT */

void mayfly_init(void)
{
 1005e20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1005e24:	270c      	movs	r7, #12
 1005e26:	f8df 8034 	ldr.w	r8, [pc, #52]	; 1005e5c <mayfly_init+0x3c>
 1005e2a:	4e0b      	ldr	r6, [pc, #44]	; (1005e58 <mayfly_init+0x38>)
 1005e2c:	4645      	mov	r5, r8
 1005e2e:	f106 0430 	add.w	r4, r6, #48	; 0x30
	while (callee_id--) {
		u8_t caller_id;

		caller_id = MAYFLY_CALLER_COUNT;
		while (caller_id--) {
			memq_init(&mfl[callee_id][caller_id],
 1005e32:	4621      	mov	r1, r4
 1005e34:	4628      	mov	r0, r5
 1005e36:	1d22      	adds	r2, r4, #4
 1005e38:	3c0c      	subs	r4, #12
 1005e3a:	f7ff ffc3 	bl	1005dc4 <memq_init>
		while (caller_id--) {
 1005e3e:	42b4      	cmp	r4, r6
 1005e40:	f1a5 0508 	sub.w	r5, r5, #8
 1005e44:	d1f5      	bne.n	1005e32 <mayfly_init+0x12>
	while (callee_id--) {
 1005e46:	3f04      	subs	r7, #4
 1005e48:	1d3b      	adds	r3, r7, #4
 1005e4a:	f1a8 0820 	sub.w	r8, r8, #32
 1005e4e:	f1a4 0630 	sub.w	r6, r4, #48	; 0x30
 1005e52:	d1eb      	bne.n	1005e2c <mayfly_init+0xc>
				  &mft[callee_id][caller_id].head,
				  &mft[callee_id][caller_id].tail);
		}
	}
}
 1005e54:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 1005e58:	21000b60 	.word	0x21000b60
 1005e5c:	21000ad0 	.word	0x21000ad0

01005e60 <mayfly_enable>:

void mayfly_enable(u8_t caller_id, u8_t callee_id, u8_t enable)
{
 1005e60:	b430      	push	{r4, r5}
 1005e62:	4603      	mov	r3, r0
 1005e64:	460c      	mov	r4, r1
	if (enable) {
 1005e66:	b19a      	cbz	r2, 1005e90 <mayfly_enable+0x30>
		if (mft[callee_id][caller_id].enable_req ==
 1005e68:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 1005e6c:	0108      	lsls	r0, r1, #4
 1005e6e:	4d14      	ldr	r5, [pc, #80]	; (1005ec0 <mayfly_enable+0x60>)
 1005e70:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 1005e74:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 1005e78:	4429      	add	r1, r5
 1005e7a:	7a48      	ldrb	r0, [r1, #9]
 1005e7c:	7a0d      	ldrb	r5, [r1, #8]
 1005e7e:	42a8      	cmp	r0, r5
		    mft[callee_id][caller_id].enable_ack) {
			mft[callee_id][caller_id].enable_req++;
 1005e80:	bf04      	itt	eq
 1005e82:	3001      	addeq	r0, #1
 1005e84:	7208      	strbeq	r0, [r1, #8]
		}

		mayfly_enable_cb(caller_id, callee_id, enable);
 1005e86:	4621      	mov	r1, r4

			/* pend the callee for execution */
			mayfly_pend(caller_id, callee_id);
		}
	}
}
 1005e88:	bc30      	pop	{r4, r5}
		mayfly_enable_cb(caller_id, callee_id, enable);
 1005e8a:	4618      	mov	r0, r3
 1005e8c:	f00c bbba 	b.w	1012604 <mayfly_enable_cb>
		if (mft[callee_id][caller_id].disable_req ==
 1005e90:	eb01 0241 	add.w	r2, r1, r1, lsl #1
 1005e94:	4d0a      	ldr	r5, [pc, #40]	; (1005ec0 <mayfly_enable+0x60>)
 1005e96:	0112      	lsls	r2, r2, #4
 1005e98:	eb00 0340 	add.w	r3, r0, r0, lsl #1
 1005e9c:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 1005ea0:	442b      	add	r3, r5
 1005ea2:	7a9d      	ldrb	r5, [r3, #10]
 1005ea4:	7ada      	ldrb	r2, [r3, #11]
 1005ea6:	42aa      	cmp	r2, r5
 1005ea8:	d001      	beq.n	1005eae <mayfly_enable+0x4e>
}
 1005eaa:	bc30      	pop	{r4, r5}
 1005eac:	4770      	bx	lr
			mfp[callee_id] = 1U;
 1005eae:	2501      	movs	r5, #1
			mft[callee_id][caller_id].disable_req++;
 1005eb0:	442a      	add	r2, r5
 1005eb2:	729a      	strb	r2, [r3, #10]
			mfp[callee_id] = 1U;
 1005eb4:	4b03      	ldr	r3, [pc, #12]	; (1005ec4 <mayfly_enable+0x64>)
 1005eb6:	545d      	strb	r5, [r3, r1]
}
 1005eb8:	bc30      	pop	{r4, r5}
			mayfly_pend(caller_id, callee_id);
 1005eba:	f00c bbe9 	b.w	1012690 <mayfly_pend>
 1005ebe:	bf00      	nop
 1005ec0:	21000adc 	.word	0x21000adc
 1005ec4:	21000ad8 	.word	0x21000ad8

01005ec8 <mayfly_enqueue>:

u32_t mayfly_enqueue(u8_t caller_id, u8_t callee_id, u8_t chain,
			struct mayfly *m)
{
 1005ec8:	b570      	push	{r4, r5, r6, lr}
 1005eca:	461c      	mov	r4, r3
 1005ecc:	4606      	mov	r6, r0
 1005ece:	460d      	mov	r5, r1
	u8_t state;
	u8_t ack;

	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
		!mayfly_is_enabled(caller_id, callee_id) ||
 1005ed0:	b32a      	cbz	r2, 1005f1e <mayfly_enqueue+0x56>
		(mft[callee_id][caller_id].disable_req !=
		 mft[callee_id][caller_id].disable_ack);

	/* shadow the ack */
	ack = m->_ack;
 1005ed2:	7863      	ldrb	r3, [r4, #1]

	/* already in queue */
	state = (m->_req - ack) & 0x03;
 1005ed4:	7822      	ldrb	r2, [r4, #0]
 1005ed6:	1ad2      	subs	r2, r2, r3
	if (state != 0U) {
 1005ed8:	f012 0203 	ands.w	r2, r2, #3
 1005edc:	d005      	beq.n	1005eea <mayfly_enqueue+0x22>
		if (chain) {
			if (state != 1U) {
 1005ede:	2a01      	cmp	r2, #1
 1005ee0:	d041      	beq.n	1005f66 <mayfly_enqueue+0x9e>
				/* mark as ready in queue */
				m->_req = ack + 1;
 1005ee2:	3301      	adds	r3, #1
 1005ee4:	b2db      	uxtb	r3, r3
 1005ee6:	7023      	strb	r3, [r4, #0]

				goto mayfly_enqueue_pend;
 1005ee8:	e010      	b.n	1005f0c <mayfly_enqueue+0x44>
		return 0;
	}

	/* new, add as ready in the queue */
	m->_req = ack + 1;
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
 1005eea:	eb05 0245 	add.w	r2, r5, r5, lsl #1
 1005eee:	0112      	lsls	r2, r2, #4
 1005ef0:	1d11      	adds	r1, r2, #4
 1005ef2:	eb06 0246 	add.w	r2, r6, r6, lsl #1
 1005ef6:	eb01 0282 	add.w	r2, r1, r2, lsl #2
	m->_req = ack + 1;
 1005efa:	3301      	adds	r3, #1
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
 1005efc:	491b      	ldr	r1, [pc, #108]	; (1005f6c <mayfly_enqueue+0xa4>)
	m->_req = ack + 1;
 1005efe:	b2db      	uxtb	r3, r3
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
 1005f00:	440a      	add	r2, r1
 1005f02:	6860      	ldr	r0, [r4, #4]
 1005f04:	4621      	mov	r1, r4
	m->_req = ack + 1;
 1005f06:	7023      	strb	r3, [r4, #0]
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
 1005f08:	f7ff ff6a 	bl	1005de0 <memq_enqueue>

mayfly_enqueue_pend:
	/* set mayfly callee pending */
	mfp[callee_id] = 1U;
 1005f0c:	2201      	movs	r2, #1
 1005f0e:	4b18      	ldr	r3, [pc, #96]	; (1005f70 <mayfly_enqueue+0xa8>)

	/* pend the callee for execution */
	mayfly_pend(caller_id, callee_id);
 1005f10:	4630      	mov	r0, r6
 1005f12:	4629      	mov	r1, r5
	mfp[callee_id] = 1U;
 1005f14:	555a      	strb	r2, [r3, r5]
	mayfly_pend(caller_id, callee_id);
 1005f16:	f00c fbbb 	bl	1012690 <mayfly_pend>

	return 0;
 1005f1a:	2000      	movs	r0, #0
}
 1005f1c:	bd70      	pop	{r4, r5, r6, pc}
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
 1005f1e:	f00c fb99 	bl	1012654 <mayfly_prio_is_equal>
 1005f22:	2800      	cmp	r0, #0
 1005f24:	d0d5      	beq.n	1005ed2 <mayfly_enqueue+0xa>
		!mayfly_is_enabled(caller_id, callee_id) ||
 1005f26:	4629      	mov	r1, r5
 1005f28:	4630      	mov	r0, r6
 1005f2a:	f00c fb7f 	bl	101262c <mayfly_is_enabled>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
 1005f2e:	2800      	cmp	r0, #0
 1005f30:	d0cf      	beq.n	1005ed2 <mayfly_enqueue+0xa>
		(mft[callee_id][caller_id].disable_req !=
 1005f32:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 1005f36:	011a      	lsls	r2, r3, #4
 1005f38:	490c      	ldr	r1, [pc, #48]	; (1005f6c <mayfly_enqueue+0xa4>)
 1005f3a:	eb06 0346 	add.w	r3, r6, r6, lsl #1
 1005f3e:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 1005f42:	440b      	add	r3, r1
		!mayfly_is_enabled(caller_id, callee_id) ||
 1005f44:	7a9a      	ldrb	r2, [r3, #10]
 1005f46:	7adb      	ldrb	r3, [r3, #11]
 1005f48:	429a      	cmp	r2, r3
 1005f4a:	d1c2      	bne.n	1005ed2 <mayfly_enqueue+0xa>
	ack = m->_ack;
 1005f4c:	7863      	ldrb	r3, [r4, #1]
	state = (m->_req - ack) & 0x03;
 1005f4e:	7822      	ldrb	r2, [r4, #0]
 1005f50:	1ad2      	subs	r2, r2, r3
	if (state != 0U) {
 1005f52:	0792      	lsls	r2, r2, #30
 1005f54:	d002      	beq.n	1005f5c <mayfly_enqueue+0x94>
		m->_req = ack + 2;
 1005f56:	3302      	adds	r3, #2
 1005f58:	b2db      	uxtb	r3, r3
 1005f5a:	7023      	strb	r3, [r4, #0]
		m->fp(m->param);
 1005f5c:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
 1005f60:	4798      	blx	r3
		return 0;
 1005f62:	2000      	movs	r0, #0
}
 1005f64:	bd70      	pop	{r4, r5, r6, pc}
			return 1;
 1005f66:	4610      	mov	r0, r2
}
 1005f68:	bd70      	pop	{r4, r5, r6, pc}
 1005f6a:	bf00      	nop
 1005f6c:	21000adc 	.word	0x21000adc
 1005f70:	21000ad8 	.word	0x21000ad8

01005f74 <mayfly_run>:
{
	u8_t disable = 0U;
	u8_t enable = 0U;
	u8_t caller_id;

	if (!mfp[callee_id]) {
 1005f74:	494c      	ldr	r1, [pc, #304]	; (10060a8 <mayfly_run+0x134>)
 1005f76:	5c0b      	ldrb	r3, [r1, r0]
 1005f78:	2b00      	cmp	r3, #0
 1005f7a:	f000 8093 	beq.w	10060a4 <mayfly_run+0x130>
		return;
	}
	mfp[callee_id] = 0U;
 1005f7e:	2200      	movs	r2, #0
{
 1005f80:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
 1005f84:	4b49      	ldr	r3, [pc, #292]	; (10060ac <mayfly_run+0x138>)
 1005f86:	ebc0 1b00 	rsb	fp, r0, r0, lsl #4
{
 1005f8a:	b087      	sub	sp, #28
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
 1005f8c:	eb03 0b8b 	add.w	fp, r3, fp, lsl #2
	u8_t enable = 0U;
 1005f90:	9203      	str	r2, [sp, #12]
	u8_t disable = 0U;
 1005f92:	9201      	str	r2, [sp, #4]
	mfp[callee_id] = 0U;
 1005f94:	540a      	strb	r2, [r1, r0]
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
 1005f96:	f10b 0204 	add.w	r2, fp, #4

	/* iterate through each caller queue to this callee_id */
	caller_id = MAYFLY_CALLER_COUNT;
	while (caller_id--) {
 1005f9a:	f04f 0803 	mov.w	r8, #3
 1005f9e:	4691      	mov	r9, r2
 1005fa0:	eb00 0740 	add.w	r7, r0, r0, lsl #1
 1005fa4:	eb03 1707 	add.w	r7, r3, r7, lsl #4
 1005fa8:	9002      	str	r0, [sp, #8]
		memq_link_t *link;
		struct mayfly *m = 0;
 1005faa:	2300      	movs	r3, #0

		/* fetch mayfly in callee queue, if any */
		link = memq_peek(mft[callee_id][caller_id].head,
 1005fac:	e9d7 0109 	ldrd	r0, r1, [r7, #36]	; 0x24
 1005fb0:	aa05      	add	r2, sp, #20
		struct mayfly *m = 0;
 1005fb2:	9305      	str	r3, [sp, #20]
		link = memq_peek(mft[callee_id][caller_id].head,
 1005fb4:	f7ff ff1c 	bl	1005df0 <memq_peek>
				 mft[callee_id][caller_id].tail,
				 (void **)&m);
		while (link) {
 1005fb8:	f107 0624 	add.w	r6, r7, #36	; 0x24
 1005fbc:	4683      	mov	fp, r0
 1005fbe:	b380      	cbz	r0, 1006022 <mayfly_run+0xae>
#if defined(MAYFLY_UT)
			_state = 0U;
#endif /* MAYFLY_UT */

			/* execute work if ready */
			state = (m->_req - m->_ack) & 0x03;
 1005fc0:	9c05      	ldr	r4, [sp, #20]
 1005fc2:	7825      	ldrb	r5, [r4, #0]
 1005fc4:	7863      	ldrb	r3, [r4, #1]
 1005fc6:	1aed      	subs	r5, r5, r3
 1005fc8:	f005 0503 	and.w	r5, r5, #3
			if (state == 1U) {
 1005fcc:	2d01      	cmp	r5, #1
 1005fce:	d106      	bne.n	1005fde <mayfly_run+0x6a>
#if defined(MAYFLY_UT)
				_state = 1U;
#endif /* MAYFLY_UT */

				/* mark mayfly as ran */
				m->_ack--;
 1005fd0:	3b01      	subs	r3, #1
 1005fd2:	7063      	strb	r3, [r4, #1]

				/* call the mayfly function */
				m->fp(m->param);
 1005fd4:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
 1005fd8:	4798      	blx	r3
 1005fda:	9c05      	ldr	r4, [sp, #20]
 1005fdc:	7863      	ldrb	r3, [r4, #1]
	req = m->_req;
 1005fde:	7822      	ldrb	r2, [r4, #0]
	if (((req - m->_ack) & 0x03) != 1U) {
 1005fe0:	1ad3      	subs	r3, r2, r3
 1005fe2:	f003 0303 	and.w	r3, r3, #3
 1005fe6:	2b01      	cmp	r3, #1
	req = m->_req;
 1005fe8:	fa5f fa82 	uxtb.w	sl, r2
	if (((req - m->_ack) & 0x03) != 1U) {
 1005fec:	d00f      	beq.n	100600e <mayfly_run+0x9a>
		memq_dequeue(mft[callee_id][caller_id].tail,
 1005fee:	2200      	movs	r2, #0
 1005ff0:	4631      	mov	r1, r6
 1005ff2:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 1005ff4:	f7ff ff04 	bl	1005e00 <memq_dequeue>
		ack = m->_ack;
 1005ff8:	7862      	ldrb	r2, [r4, #1]
		if (((m->_req - ack) & 0x03) == 1U) {
 1005ffa:	7823      	ldrb	r3, [r4, #0]
		m->_link = link;
 1005ffc:	f8c4 b004 	str.w	fp, [r4, #4]
		if (((m->_req - ack) & 0x03) == 1U) {
 1006000:	1a9b      	subs	r3, r3, r2
 1006002:	f003 0303 	and.w	r3, r3, #3
 1006006:	2b01      	cmp	r3, #1
		m->_ack = req;
 1006008:	f884 a001 	strb.w	sl, [r4, #1]
		if (((m->_req - ack) & 0x03) == 1U) {
 100600c:	d043      	beq.n	1006096 <mayfly_run+0x122>

			/* dequeue if not re-pended */
			dequeue(callee_id, caller_id, link, m);

			/* fetch next mayfly in callee queue, if any */
			link = memq_peek(mft[callee_id][caller_id].head,
 100600e:	e9d7 0109 	ldrd	r0, r1, [r7, #36]	; 0x24
 1006012:	aa05      	add	r2, sp, #20
 1006014:	f7ff feec 	bl	1005df0 <memq_peek>
 */
#if defined(CONFIG_BT_MAYFLY_YIELD_AFTER_CALL)
			/* yield out of mayfly_run if a mayfly function was
			 * called.
			 */
			if (state == 1U) {
 1006018:	2d01      	cmp	r5, #1
			link = memq_peek(mft[callee_id][caller_id].head,
 100601a:	4683      	mov	fp, r0
			if (state == 1U) {
 100601c:	d029      	beq.n	1006072 <mayfly_run+0xfe>
		while (link) {
 100601e:	2800      	cmp	r0, #0
 1006020:	d1ce      	bne.n	1005fc0 <mayfly_run+0x4c>
				}
			}
#endif
		}

		if (mft[callee_id][caller_id].disable_req !=
 1006022:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 1006026:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
 100602a:	429a      	cmp	r2, r3
 100602c:	d003      	beq.n	1006036 <mayfly_run+0xc2>
		    mft[callee_id][caller_id].disable_ack) {
			disable = 1U;
 100602e:	2201      	movs	r2, #1

			mft[callee_id][caller_id].disable_ack =
 1006030:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
			disable = 1U;
 1006034:	9201      	str	r2, [sp, #4]
				mft[callee_id][caller_id].disable_req;
		}

		if (mft[callee_id][caller_id].enable_req !=
 1006036:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 100603a:	f897 202d 	ldrb.w	r2, [r7, #45]	; 0x2d
 100603e:	429a      	cmp	r2, r3
 1006040:	d003      	beq.n	100604a <mayfly_run+0xd6>
		    mft[callee_id][caller_id].enable_ack) {
			enable = 1U;
 1006042:	2201      	movs	r2, #1

			mft[callee_id][caller_id].enable_ack =
 1006044:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
			enable = 1U;
 1006048:	9203      	str	r2, [sp, #12]
	while (caller_id--) {
 100604a:	f108 38ff 	add.w	r8, r8, #4294967295
 100604e:	fa5f f888 	uxtb.w	r8, r8
 1006052:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
 1006056:	f1a7 070c 	sub.w	r7, r7, #12
 100605a:	d1a6      	bne.n	1005faa <mayfly_run+0x36>
				mft[callee_id][caller_id].enable_req;
		}
	}

	if (disable && !enable) {
 100605c:	e9dd 3a01 	ldrd	r3, sl, [sp, #4]
 1006060:	b1b3      	cbz	r3, 1006090 <mayfly_run+0x11c>
 1006062:	9b03      	ldr	r3, [sp, #12]
 1006064:	b9a3      	cbnz	r3, 1006090 <mayfly_run+0x11c>
		mayfly_enable_cb(callee_id, callee_id, 0);
 1006066:	461a      	mov	r2, r3
 1006068:	4651      	mov	r1, sl
 100606a:	4650      	mov	r0, sl
 100606c:	f00c faca 	bl	1012604 <mayfly_enable_cb>
 1006070:	e00e      	b.n	1006090 <mayfly_run+0x11c>
				if (caller_id || link) {
 1006072:	f1b8 0f00 	cmp.w	r8, #0
 1006076:	d101      	bne.n	100607c <mayfly_run+0x108>
 1006078:	2800      	cmp	r0, #0
 100607a:	d0d2      	beq.n	1006022 <mayfly_run+0xae>
					mfp[callee_id] = 1U;
 100607c:	2301      	movs	r3, #1
 100607e:	f8dd a008 	ldr.w	sl, [sp, #8]
 1006082:	4a09      	ldr	r2, [pc, #36]	; (10060a8 <mayfly_run+0x134>)
					mayfly_pend(callee_id, callee_id);
 1006084:	4651      	mov	r1, sl
 1006086:	4650      	mov	r0, sl
					mfp[callee_id] = 1U;
 1006088:	f802 300a 	strb.w	r3, [r2, sl]
					mayfly_pend(callee_id, callee_id);
 100608c:	f00c fb00 	bl	1012690 <mayfly_pend>
	}
}
 1006090:	b007      	add	sp, #28
 1006092:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			m->_ack = ack;
 1006096:	7062      	strb	r2, [r4, #1]
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
 1006098:	4621      	mov	r1, r4
 100609a:	4658      	mov	r0, fp
 100609c:	464a      	mov	r2, r9
 100609e:	f7ff fe9f 	bl	1005de0 <memq_enqueue>
 10060a2:	e7b4      	b.n	100600e <mayfly_run+0x9a>
 10060a4:	4770      	bx	lr
 10060a6:	bf00      	nop
 10060a8:	21000ad8 	.word	0x21000ad8
 10060ac:	21000adc 	.word	0x21000adc

010060b0 <util_ones_count_get>:
 */
u8_t util_ones_count_get(u8_t *octets, u8_t octets_len)
{
	u8_t one_count = 0U;

	while (octets_len--) {
 10060b0:	b1a9      	cbz	r1, 10060de <util_ones_count_get+0x2e>
 10060b2:	4603      	mov	r3, r0
	u8_t one_count = 0U;
 10060b4:	2000      	movs	r0, #0
 10060b6:	1e4a      	subs	r2, r1, #1
 10060b8:	b2d2      	uxtb	r2, r2
{
 10060ba:	b410      	push	{r4}
 10060bc:	1e59      	subs	r1, r3, #1
 10060be:	189c      	adds	r4, r3, r2
		u8_t bite;

		bite = *octets;
 10060c0:	f811 3f01 	ldrb.w	r3, [r1, #1]!
		while (bite) {
 10060c4:	b13b      	cbz	r3, 10060d6 <util_ones_count_get+0x26>
			bite &= (bite - 1);
 10060c6:	b25b      	sxtb	r3, r3
 10060c8:	1e5a      	subs	r2, r3, #1
 10060ca:	4013      	ands	r3, r2
			one_count++;
 10060cc:	3001      	adds	r0, #1
		while (bite) {
 10060ce:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
			one_count++;
 10060d2:	b2c0      	uxtb	r0, r0
		while (bite) {
 10060d4:	d1f7      	bne.n	10060c6 <util_ones_count_get+0x16>
	while (octets_len--) {
 10060d6:	42a1      	cmp	r1, r4
 10060d8:	d1f2      	bne.n	10060c0 <util_ones_count_get+0x10>
		}
		octets++;
	}

	return one_count;
}
 10060da:	bc10      	pop	{r4}
 10060dc:	4770      	bx	lr
	u8_t one_count = 0U;
 10060de:	4608      	mov	r0, r1
}
 10060e0:	4770      	bx	lr
 10060e2:	bf00      	nop

010060e4 <ticker_worker>:
	u32_t ticks_elapsed;
	u32_t ticks_expired;
	u8_t ticker_id_head;

	/* Defer worker if job running */
	instance->worker_trigger = 1U;
 10060e4:	2301      	movs	r3, #1
{
 10060e6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (instance->job_guard) {
 10060ea:	7f82      	ldrb	r2, [r0, #30]
{
 10060ec:	b089      	sub	sp, #36	; 0x24
	if (instance->job_guard) {
 10060ee:	9203      	str	r2, [sp, #12]
	instance->worker_trigger = 1U;
 10060f0:	77c3      	strb	r3, [r0, #31]
	if (instance->job_guard) {
 10060f2:	2a00      	cmp	r2, #0
 10060f4:	f040 80a5 	bne.w	1006242 <ticker_worker+0x15e>
		return;
	}

	/* If no tickers queued (active), do nothing */
	if (instance->ticker_id_head == TICKER_NULL) {
 10060f8:	7f43      	ldrb	r3, [r0, #29]
 10060fa:	4681      	mov	r9, r0
 10060fc:	2bff      	cmp	r3, #255	; 0xff
 10060fe:	f000 809f 	beq.w	1006240 <ticker_worker+0x15c>
		instance->worker_trigger = 0U;
		return;
	}

	/* Get ticks elapsed since last job execution */
	ticks_elapsed = ticker_ticks_diff_get(cntr_cnt_get(),
 1006102:	f00b fce5 	bl	1011ad0 <cntr_cnt_get>
 * @param ticks_now Highest tick count (now)
 * @param ticks_old Tick count to subtract from ticks_now
 */
u32_t ticker_ticks_diff_get(u32_t ticks_now, u32_t ticks_old)
{
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1006106:	f8d9 2014 	ldr.w	r2, [r9, #20]
	if (instance->ticker_id_slot_previous != TICKER_NULL) {
 100610a:	f899 301c 	ldrb.w	r3, [r9, #28]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 100610e:	1a80      	subs	r0, r0, r2
	if (instance->ticker_id_slot_previous != TICKER_NULL) {
 1006110:	2bff      	cmp	r3, #255	; 0xff
	ticker_id_head = instance->ticker_id_head;
 1006112:	f899 501d 	ldrb.w	r5, [r9, #29]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1006116:	f020 4a7f 	bic.w	sl, r0, #4278190080	; 0xff000000
	if (instance->ticker_id_slot_previous != TICKER_NULL) {
 100611a:	f000 8101 	beq.w	1006320 <ticker_worker+0x23c>
		if (instance->ticks_slot_previous > ticks_elapsed) {
 100611e:	f8d9 3018 	ldr.w	r3, [r9, #24]
	u8_t slot_reserved = 0;
 1006122:	4553      	cmp	r3, sl
 1006124:	bf94      	ite	ls
 1006126:	2300      	movls	r3, #0
 1006128:	2301      	movhi	r3, #1
 100612a:	9301      	str	r3, [sp, #4]
	while (ticker_id_head != TICKER_NULL) {
 100612c:	2dff      	cmp	r5, #255	; 0xff
	node = &instance->nodes[0];
 100612e:	f8d9 8000 	ldr.w	r8, [r9]
	while (ticker_id_head != TICKER_NULL) {
 1006132:	f000 80f8 	beq.w	1006326 <ticker_worker+0x242>
	ticks_expired = 0U;
 1006136:	2600      	movs	r6, #0
			ticker->ext_data->ticks_drift = 0U;
 1006138:	f8cd 9008 	str.w	r9, [sp, #8]
		ticker = &node[ticker_id_head];
 100613c:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 1006140:	eb08 1405 	add.w	r4, r8, r5, lsl #4
		ticks_to_expire = ticker->ticks_to_expire;
 1006144:	68a3      	ldr	r3, [r4, #8]
		ticker = &node[ticker_id_head];
 1006146:	012d      	lsls	r5, r5, #4
		if (ticks_elapsed < ticks_to_expire) {
 1006148:	4553      	cmp	r3, sl
 100614a:	d855      	bhi.n	10061f8 <ticker_worker+0x114>
		if (ticker->ticks_slot != 0U &&
 100614c:	69a7      	ldr	r7, [r4, #24]
		ticker_id_head = ticker->next;
 100614e:	f818 5005 	ldrb.w	r5, [r8, r5]
		ticks_elapsed -= ticks_to_expire;
 1006152:	ebaa 0a03 	sub.w	sl, sl, r3
		ticks_expired += ticks_to_expire;
 1006156:	441e      	add	r6, r3
		if (ticker->ticks_slot != 0U &&
 1006158:	2f00      	cmp	r7, #0
 100615a:	d078      	beq.n	100624e <ticker_worker+0x16a>
 100615c:	9b01      	ldr	r3, [sp, #4]
 100615e:	2b00      	cmp	r3, #0
 1006160:	d07b      	beq.n	100625a <ticker_worker+0x176>
 1006162:	f8b4 c01e 	ldrh.w	ip, [r4, #30]
			struct ticker_ext *ext_data = ticker->ext_data;
 1006166:	6aa3      	ldr	r3, [r4, #40]	; 0x28
			if (ext_data &&
 1006168:	b153      	cbz	r3, 1006180 <ticker_worker+0x9c>
 100616a:	681a      	ldr	r2, [r3, #0]
 100616c:	b12a      	cbz	r2, 100617a <ticker_worker+0x96>
			    ext_data->ticks_slot_window != 0U &&
 100616e:	7a1a      	ldrb	r2, [r3, #8]
 1006170:	b91a      	cbnz	r2, 100617a <ticker_worker+0x96>
			    TICKER_RESCHEDULE_STATE_NONE &&
 1006172:	8ba2      	ldrh	r2, [r4, #28]
 1006174:	4562      	cmp	r2, ip
 1006176:	f240 80cf 	bls.w	1006318 <ticker_worker+0x234>
				ext_data->reschedule_state =
 100617a:	f04f 0200 	mov.w	r2, #0
 100617e:	721a      	strb	r2, [r3, #8]
			ticker->lazy_current++;
 1006180:	f10c 0c01 	add.w	ip, ip, #1
			if ((ticker->must_expire == 0U) ||
 1006184:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
			ticker->lazy_current++;
 1006188:	fa1f fc8c 	uxth.w	ip, ip
 100618c:	f8a4 c01e 	strh.w	ip, [r4, #30]
			if ((ticker->must_expire == 0U) ||
 1006190:	2a00      	cmp	r2, #0
 1006192:	d02f      	beq.n	10061f4 <ticker_worker+0x110>
 1006194:	8ba2      	ldrh	r2, [r4, #28]
 1006196:	4562      	cmp	r2, ip
 1006198:	d22c      	bcs.n	10061f4 <ticker_worker+0x110>
			    (ticker->lazy_periodic >= ticker->lazy_current) ||
 100619a:	2b00      	cmp	r3, #0
 100619c:	f000 80ba 	beq.w	1006314 <ticker_worker+0x230>
			    TICKER_RESCHEDULE_PENDING(ticker)) {
 10061a0:	7a1a      	ldrb	r2, [r3, #8]
 10061a2:	2a01      	cmp	r2, #1
 10061a4:	d026      	beq.n	10061f4 <ticker_worker+0x110>
			must_expire_skip = 1U;
 10061a6:	2701      	movs	r7, #1
			ticker->ext_data->ticks_drift = 0U;
 10061a8:	2200      	movs	r2, #0
 10061aa:	605a      	str	r2, [r3, #4]
			ticker->ext_data->reschedule_state =
 10061ac:	721a      	strb	r2, [r3, #8]
		if (((ticker->req - ticker->ack) & 0xff) != 1U) {
 10061ae:	78a2      	ldrb	r2, [r4, #2]
 10061b0:	7863      	ldrb	r3, [r4, #1]
 10061b2:	1a9b      	subs	r3, r3, r2
 10061b4:	b2db      	uxtb	r3, r3
 10061b6:	2b01      	cmp	r3, #1
 10061b8:	d11c      	bne.n	10061f4 <ticker_worker+0x110>
		if (ticker->timeout_func) {
 10061ba:	f8d4 900c 	ldr.w	r9, [r4, #12]
		ticker->ack--;
 10061be:	3a01      	subs	r2, #1
 10061c0:	70a2      	strb	r2, [r4, #2]
		if (ticker->timeout_func) {
 10061c2:	f1b9 0f00 	cmp.w	r9, #0
 10061c6:	d015      	beq.n	10061f4 <ticker_worker+0x110>
					   ticks_expired -
 10061c8:	9a02      	ldr	r2, [sp, #8]
 10061ca:	6963      	ldr	r3, [r4, #20]
 10061cc:	6950      	ldr	r0, [r2, #20]
 10061ce:	1af3      	subs	r3, r6, r3
 10061d0:	4418      	add	r0, r3
			ticker->timeout_func(ticks_at_expire,
 10061d2:	6a61      	ldr	r1, [r4, #36]	; 0x24
 10061d4:	6923      	ldr	r3, [r4, #16]
			ticks_at_expire = (instance->ticks_current +
 10061d6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			ticker->timeout_func(ticks_at_expire,
 10061da:	2f00      	cmp	r7, #0
 10061dc:	f040 8096 	bne.w	100630c <ticker_worker+0x228>
 10061e0:	8be2      	ldrh	r2, [r4, #30]
 10061e2:	47c8      	blx	r9
				if (ticker->ticks_slot != 0U) {
 10061e4:	69a3      	ldr	r3, [r4, #24]
				ticker->lazy_current = 0U;
 10061e6:	83e7      	strh	r7, [r4, #30]
					slot_reserved = 1U;
 10061e8:	2b00      	cmp	r3, #0
 10061ea:	9b01      	ldr	r3, [sp, #4]
 10061ec:	bf18      	it	ne
 10061ee:	2301      	movne	r3, #1
				ticker->force = 0U;
 10061f0:	70e7      	strb	r7, [r4, #3]
					slot_reserved = 1U;
 10061f2:	9301      	str	r3, [sp, #4]
	while (ticker_id_head != TICKER_NULL) {
 10061f4:	2dff      	cmp	r5, #255	; 0xff
 10061f6:	d1a1      	bne.n	100613c <ticker_worker+0x58>
 10061f8:	4631      	mov	r1, r6
 10061fa:	f8dd 9008 	ldr.w	r9, [sp, #8]
	if (instance->ticks_elapsed_first == instance->ticks_elapsed_last) {
 10061fe:	f899 300b 	ldrb.w	r3, [r9, #11]
 1006202:	f899 200a 	ldrb.w	r2, [r9, #10]
 1006206:	429a      	cmp	r2, r3
 1006208:	d109      	bne.n	100621e <ticker_worker+0x13a>
	u8_t idx = *ticks_elapsed_index + 1;
 100620a:	3201      	adds	r2, #1
 100620c:	b2d2      	uxtb	r2, r2
	if (idx == DOUBLE_BUFFER_SIZE) {
 100620e:	2a02      	cmp	r2, #2
 1006210:	bf16      	itet	ne
 1006212:	4613      	movne	r3, r2
 1006214:	2300      	moveq	r3, #0
	*ticks_elapsed_index = idx;
 1006216:	9303      	strne	r3, [sp, #12]
 1006218:	9a03      	ldr	r2, [sp, #12]
 100621a:	f889 200b 	strb.w	r2, [r9, #11]
	instance->worker_trigger = 0U;
 100621e:	2200      	movs	r2, #0
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
 1006220:	f8d9 4024 	ldr.w	r4, [r9, #36]	; 0x24
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
 1006224:	eb09 0383 	add.w	r3, r9, r3, lsl #2
 1006228:	60d9      	str	r1, [r3, #12]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
 100622a:	2003      	movs	r0, #3
	instance->worker_trigger = 0U;
 100622c:	f889 201f 	strb.w	r2, [r9, #31]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
 1006230:	464b      	mov	r3, r9
 1006232:	2201      	movs	r2, #1
 1006234:	2104      	movs	r1, #4
 1006236:	46a4      	mov	ip, r4
}
 1006238:	b009      	add	sp, #36	; 0x24
 100623a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
 100623e:	4760      	bx	ip
		instance->worker_trigger = 0U;
 1006240:	77c2      	strb	r2, [r0, #31]
}
 1006242:	b009      	add	sp, #36	; 0x24
 1006244:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1006248:	4674      	mov	r4, lr
 100624a:	e9dd 6506 	ldrd	r6, r5, [sp, #24]
		if (ticker->ext_data) {
 100624e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1006250:	b10b      	cbz	r3, 1006256 <ticker_worker+0x172>
 1006252:	2700      	movs	r7, #0
 1006254:	e7a8      	b.n	10061a8 <ticker_worker+0xc4>
 1006256:	461f      	mov	r7, r3
 1006258:	e7a9      	b.n	10061ae <ticker_worker+0xca>
	if ((ticker->priority != TICKER_PRIORITY_CRITICAL) &&
 100625a:	f994 302d 	ldrsb.w	r3, [r4, #45]	; 0x2d
 100625e:	9304      	str	r3, [sp, #16]
 1006260:	3380      	adds	r3, #128	; 0x80
 1006262:	d0f4      	beq.n	100624e <ticker_worker+0x16a>
 1006264:	2dff      	cmp	r5, #255	; 0xff
 1006266:	d0f2      	beq.n	100624e <ticker_worker+0x16a>
		s32_t lazy_current = ticker->lazy_current;
 1006268:	f8b4 c01e 	ldrh.w	ip, [r4, #30]
		u32_t current_age = ticker->ticks_periodic +
 100626c:	46ab      	mov	fp, r5
		s32_t lazy_current = ticker->lazy_current;
 100626e:	4662      	mov	r2, ip
		if (lazy_current >= ticker->lazy_periodic) {
 1006270:	8ba3      	ldrh	r3, [r4, #28]
		u32_t current_age = ticker->ticks_periodic +
 1006272:	6861      	ldr	r1, [r4, #4]
		if (lazy_current >= ticker->lazy_periodic) {
 1006274:	459c      	cmp	ip, r3
			lazy_current -= ticker->lazy_periodic;
 1006276:	bf28      	it	cs
 1006278:	ebac 0203 	subcs.w	r2, ip, r3
				(lazy_current - ticker->priority);
 100627c:	9b04      	ldr	r3, [sp, #16]
		u32_t current_age = ticker->ticks_periodic +
 100627e:	e9cd 6506 	strd	r6, r5, [sp, #24]
				(lazy_current - ticker->priority);
 1006282:	1ad3      	subs	r3, r2, r3
		u32_t current_age = ticker->ticks_periodic +
 1006284:	fb02 1201 	mla	r2, r2, r1, r1
				(lazy_current - ticker->priority);
 1006288:	9305      	str	r3, [sp, #20]
		u32_t current_age = ticker->ticks_periodic +
 100628a:	9d04      	ldr	r5, [sp, #16]
		u32_t acc_ticks_to_expire = 0U;
 100628c:	2000      	movs	r0, #0
		u32_t current_age = ticker->ticks_periodic +
 100628e:	f8cd c010 	str.w	ip, [sp, #16]
 1006292:	46a6      	mov	lr, r4
 1006294:	4616      	mov	r6, r2
 1006296:	46bc      	mov	ip, r7
 1006298:	465b      	mov	r3, fp
 100629a:	f8dd 9014 	ldr.w	r9, [sp, #20]
 100629e:	e003      	b.n	10062a8 <ticker_worker+0x1c4>
			id_head = ticker_next->next;
 10062a0:	f818 3003 	ldrb.w	r3, [r8, r3]
		while (id_head != TICKER_NULL) {
 10062a4:	2bff      	cmp	r3, #255	; 0xff
 10062a6:	d0cf      	beq.n	1006248 <ticker_worker+0x164>
			struct ticker_node *ticker_next = &nodes[id_head];
 10062a8:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 10062ac:	eb08 1203 	add.w	r2, r8, r3, lsl #4
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
 10062b0:	6897      	ldr	r7, [r2, #8]
			struct ticker_node *ticker_next = &nodes[id_head];
 10062b2:	011b      	lsls	r3, r3, #4
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
 10062b4:	4438      	add	r0, r7
			if (acc_ticks_to_expire > ticker->ticks_slot) {
 10062b6:	4584      	cmp	ip, r0
 10062b8:	d3c6      	bcc.n	1006248 <ticker_worker+0x164>
			if (ticker_next->ticks_slot == 0U) {
 10062ba:	6991      	ldr	r1, [r2, #24]
 10062bc:	2900      	cmp	r1, #0
 10062be:	d0ef      	beq.n	10062a0 <ticker_worker+0x1bc>
			s32_t lazy_next = ticker_next->lazy_current;
 10062c0:	f8b2 b01e 	ldrh.w	fp, [r2, #30]
				ticker_next->lazy_periodic > lazy_next;
 10062c4:	8b91      	ldrh	r1, [r2, #28]
			if (!lazy_next_periodic_skip) {
 10062c6:	458b      	cmp	fp, r1
 10062c8:	d3ea      	bcc.n	10062a0 <ticker_worker+0x1bc>
			u32_t next_age = (ticker_next->ticks_periodic == 0U ?
 10062ca:	6854      	ldr	r4, [r2, #4]
				lazy_next -= ticker_next->lazy_periodic;
 10062cc:	ebab 0101 	sub.w	r1, fp, r1
				ticker_next->priority;
 10062d0:	f992 b02d 	ldrsb.w	fp, [r2, #45]	; 0x2d
					  0U :
 10062d4:	b114      	cbz	r4, 10062dc <ticker_worker+0x1f8>
 10062d6:	1be7      	subs	r7, r4, r7
			u32_t next_age = (ticker_next->ticks_periodic == 0U ?
 10062d8:	fb04 7401 	mla	r4, r4, r1, r7
			u8_t next_force = (ticker_next->force > ticker->force);
 10062dc:	78d2      	ldrb	r2, [r2, #3]
 10062de:	f89e 7003 	ldrb.w	r7, [lr, #3]
				(lazy_next - ticker_next->priority) >
 10062e2:	eba1 010b 	sub.w	r1, r1, fp
			if (!lazy_next_periodic_skip &&
 10062e6:	4297      	cmp	r7, r2
 10062e8:	d30a      	bcc.n	1006300 <ticker_worker+0x21c>
			    (next_force ||
 10062ea:	f11b 0f80 	cmn.w	fp, #128	; 0x80
 10062ee:	d007      	beq.n	1006300 <ticker_worker+0x21c>
			     next_is_critical ||
 10062f0:	4589      	cmp	r9, r1
 10062f2:	da01      	bge.n	10062f8 <ticker_worker+0x214>
			    (next_has_priority && !current_is_older) ||
 10062f4:	42a6      	cmp	r6, r4
 10062f6:	d903      	bls.n	1006300 <ticker_worker+0x21c>
 10062f8:	455d      	cmp	r5, fp
 10062fa:	d1d1      	bne.n	10062a0 <ticker_worker+0x1bc>
			    (equal_priority && next_is_older))) {
 10062fc:	42a6      	cmp	r6, r4
 10062fe:	d2cf      	bcs.n	10062a0 <ticker_worker+0x1bc>
 1006300:	4674      	mov	r4, lr
 1006302:	e9dd 6506 	ldrd	r6, r5, [sp, #24]
 1006306:	f8dd c010 	ldr.w	ip, [sp, #16]
 100630a:	e72c      	b.n	1006166 <ticker_worker+0x82>
			ticker->timeout_func(ticks_at_expire,
 100630c:	f64f 72ff 	movw	r2, #65535	; 0xffff
 1006310:	47c8      	blx	r9
			if (must_expire_skip == 0U) {
 1006312:	e76f      	b.n	10061f4 <ticker_worker+0x110>
			must_expire_skip = 1U;
 1006314:	2701      	movs	r7, #1
 1006316:	e74a      	b.n	10061ae <ticker_worker+0xca>
				ext_data->reschedule_state =
 1006318:	f04f 0201 	mov.w	r2, #1
 100631c:	721a      	strb	r2, [r3, #8]
 100631e:	e72f      	b.n	1006180 <ticker_worker+0x9c>
	u8_t slot_reserved = 0;
 1006320:	9b03      	ldr	r3, [sp, #12]
 1006322:	9301      	str	r3, [sp, #4]
 1006324:	e702      	b.n	100612c <ticker_worker+0x48>
	ticks_expired = 0U;
 1006326:	2300      	movs	r3, #0
 1006328:	4619      	mov	r1, r3
 100632a:	e768      	b.n	10061fe <ticker_worker+0x11a>

0100632c <ticker_job>:
	if (instance->worker_trigger) {
 100632c:	7fc2      	ldrb	r2, [r0, #31]
 100632e:	2a00      	cmp	r2, #0
 1006330:	f040 8600 	bne.w	1006f34 <ticker_job+0xc08>
{
 1006334:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1006338:	4683      	mov	fp, r0
	instance->job_guard = 1U;
 100633a:	2001      	movs	r0, #1
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
 100633c:	f89b 300a 	ldrb.w	r3, [fp, #10]
 1006340:	f89b 100b 	ldrb.w	r1, [fp, #11]
	instance->job_guard = 1U;
 1006344:	f88b 001e 	strb.w	r0, [fp, #30]
	ticks_previous = instance->ticks_current;
 1006348:	f8db 0014 	ldr.w	r0, [fp, #20]
{
 100634c:	b08f      	sub	sp, #60	; 0x3c
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
 100634e:	4299      	cmp	r1, r3
	ticks_previous = instance->ticks_current;
 1006350:	9005      	str	r0, [sp, #20]
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
 1006352:	f000 8094 	beq.w	100647e <ticker_job+0x152>
	u8_t idx = *ticks_elapsed_index + 1;
 1006356:	3301      	adds	r3, #1
 1006358:	b2db      	uxtb	r3, r3
	if (idx == DOUBLE_BUFFER_SIZE) {
 100635a:	2b02      	cmp	r3, #2
		idx = 0U;
 100635c:	bf08      	it	eq
 100635e:	4613      	moveq	r3, r2
		flag_elapsed = 1U;
 1006360:	2201      	movs	r2, #1
	*ticks_elapsed_index = idx;
 1006362:	f88b 300a 	strb.w	r3, [fp, #10]
		ticks_elapsed =
 1006366:	eb0b 0383 	add.w	r3, fp, r3, lsl #2
 100636a:	68db      	ldr	r3, [r3, #12]
		flag_elapsed = 1U;
 100636c:	920d      	str	r2, [sp, #52]	; 0x34
		instance->ticks_current += ticks_elapsed;
 100636e:	9a05      	ldr	r2, [sp, #20]
		ticks_elapsed =
 1006370:	9302      	str	r3, [sp, #8]
		instance->ticks_current += ticks_elapsed;
 1006372:	18d3      	adds	r3, r2, r3
		instance->ticks_current &= HAL_TICKER_CNTR_MASK;
 1006374:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 1006378:	f8cb 3014 	str.w	r3, [fp, #20]
	node = &instance->nodes[0];
 100637c:	f8db 1000 	ldr.w	r1, [fp]
	count_user = instance->count_user;
 1006380:	f89b 2009 	ldrb.w	r2, [fp, #9]
	ticker_id_old_head = instance->ticker_id_head;
 1006384:	f89b 301d 	ldrb.w	r3, [fp, #29]
	node = &instance->nodes[0];
 1006388:	9104      	str	r1, [sp, #16]
	users = &instance->users[0];
 100638a:	f8db 1004 	ldr.w	r1, [fp, #4]
	ticker_id_old_head = instance->ticker_id_head;
 100638e:	9306      	str	r3, [sp, #24]
	while (count_user--) {
 1006390:	1e53      	subs	r3, r2, #1
	count_user = instance->count_user;
 1006392:	9207      	str	r2, [sp, #28]
	while (count_user--) {
 1006394:	b2db      	uxtb	r3, r3
	users = &instance->users[0];
 1006396:	910c      	str	r1, [sp, #48]	; 0x30
	while (count_user--) {
 1006398:	2a00      	cmp	r2, #0
 100639a:	f000 830b 	beq.w	10069b4 <ticker_job+0x688>
 100639e:	eb01 06c3 	add.w	r6, r1, r3, lsl #3
	pending = 0U;
 10063a2:	2300      	movs	r3, #0
 10063a4:	9308      	str	r3, [sp, #32]
	insert_head = TICKER_NULL;
 10063a6:	23ff      	movs	r3, #255	; 0xff
 10063a8:	4637      	mov	r7, r6
 10063aa:	46d9      	mov	r9, fp
 10063ac:	9301      	str	r3, [sp, #4]
		user_ops = &user->user_op[0];
 10063ae:	46ba      	mov	sl, r7
 10063b0:	687b      	ldr	r3, [r7, #4]
 10063b2:	f897 c003 	ldrb.w	ip, [r7, #3]
 10063b6:	9307      	str	r3, [sp, #28]
		while (user->middle != user->last) {
 10063b8:	78bb      	ldrb	r3, [r7, #2]
 10063ba:	4563      	cmp	r3, ip
					ticks_used = 0;
 10063bc:	4698      	mov	r8, r3
			user_op = &user_ops[user->middle];
 10063be:	f04f 0134 	mov.w	r1, #52	; 0x34
 10063c2:	9807      	ldr	r0, [sp, #28]
			middle = user->middle + 1;
 10063c4:	f103 0201 	add.w	r2, r3, #1
		while (user->middle != user->last) {
 10063c8:	f000 8188 	beq.w	10066dc <ticker_job+0x3b0>
			if (middle == user->count_user_op) {
 10063cc:	f89a 4000 	ldrb.w	r4, [sl]
			user_op = &user_ops[user->middle];
 10063d0:	fb01 f503 	mul.w	r5, r1, r3
			middle = user->middle + 1;
 10063d4:	b2d3      	uxtb	r3, r2
				middle = 0U;
 10063d6:	429c      	cmp	r4, r3
 10063d8:	bf08      	it	eq
 10063da:	2300      	moveq	r3, #0
			user->middle = middle;
 10063dc:	f88a 3002 	strb.w	r3, [sl, #2]
			if (user_op->op < TICKER_USER_OP_TYPE_UPDATE) {
 10063e0:	5d42      	ldrb	r2, [r0, r5]
			user_op = &user_ops[user->middle];
 10063e2:	4405      	add	r5, r0
			if (user_op->op < TICKER_USER_OP_TYPE_UPDATE) {
 10063e4:	2a04      	cmp	r2, #4
 10063e6:	f240 8173 	bls.w	10066d0 <ticker_job+0x3a4>
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
 10063ea:	2a07      	cmp	r2, #7
 10063ec:	f200 8086 	bhi.w	10064fc <ticker_job+0x1d0>
			ticker = &node[user_op->id];
 10063f0:	7869      	ldrb	r1, [r5, #1]
 10063f2:	9804      	ldr	r0, [sp, #16]
 10063f4:	eb01 0641 	add.w	r6, r1, r1, lsl #1
 10063f8:	eb00 1406 	add.w	r4, r0, r6, lsl #4
			state = (ticker->req - ticker->ack) & 0xff;
 10063fc:	78a7      	ldrb	r7, [r4, #2]
 10063fe:	7860      	ldrb	r0, [r4, #1]
			ticker = &node[user_op->id];
 1006400:	0136      	lsls	r6, r6, #4
			state = (ticker->req - ticker->ack) & 0xff;
 1006402:	1bc0      	subs	r0, r0, r7
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
 1006404:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
			ticker = &node[user_op->id];
 1006408:	960a      	str	r6, [sp, #40]	; 0x28
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
 100640a:	d077      	beq.n	10064fc <ticker_job+0x1d0>
			    (state == 0U) ||
 100640c:	2a05      	cmp	r2, #5
 100640e:	d065      	beq.n	10064dc <ticker_job+0x1b0>
			if (state == 1U) {
 1006410:	2801      	cmp	r0, #1
 1006412:	d137      	bne.n	1006484 <ticker_job+0x158>
	previous = instance->ticker_id_head;
 1006414:	f899 c01d 	ldrb.w	ip, [r9, #29]
	ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
 1006418:	f8d9 6000 	ldr.w	r6, [r9]
	while (current != TICKER_NULL) {
 100641c:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
 1006420:	d017      	beq.n	1006452 <ticker_job+0x126>
		ticker_current = &node[current];
 1006422:	eb0c 004c 	add.w	r0, ip, ip, lsl #1
		if (current == id) {
 1006426:	4561      	cmp	r1, ip
		ticker_current = &node[current];
 1006428:	eb06 1000 	add.w	r0, r6, r0, lsl #4
		if (current == id) {
 100642c:	f000 814d 	beq.w	10066ca <ticker_job+0x39e>
	total = 0U;
 1006430:	2300      	movs	r3, #0
 1006432:	e001      	b.n	1006438 <ticker_job+0x10c>
		if (current == id) {
 1006434:	4561      	cmp	r1, ip
 1006436:	d070      	beq.n	100651a <ticker_job+0x1ee>
		total += ticker_current->ticks_to_expire;
 1006438:	46e6      	mov	lr, ip
		current = ticker_current->next;
 100643a:	f890 c000 	ldrb.w	ip, [r0]
		total += ticker_current->ticks_to_expire;
 100643e:	f8d0 8008 	ldr.w	r8, [r0, #8]
	while (current != TICKER_NULL) {
 1006442:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
		ticker_current = &node[current];
 1006446:	eb0c 004c 	add.w	r0, ip, ip, lsl #1
		total += ticker_current->ticks_to_expire;
 100644a:	4443      	add	r3, r8
		ticker_current = &node[current];
 100644c:	eb06 1000 	add.w	r0, r6, r0, lsl #4
	while (current != TICKER_NULL) {
 1006450:	d1f0      	bne.n	1006434 <ticker_job+0x108>
	ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
 1006452:	2600      	movs	r6, #0
	if (user_op->op == TICKER_USER_OP_TYPE_UPDATE) {
 1006454:	2a05      	cmp	r2, #5
	ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
 1006456:	60a6      	str	r6, [r4, #8]
	if (user_op->op == TICKER_USER_OP_TYPE_UPDATE) {
 1006458:	f000 8122 	beq.w	10066a0 <ticker_job+0x374>
		ticker->req = ticker->ack;
 100645c:	7067      	strb	r7, [r4, #1]
		if (instance->ticker_id_slot_previous == user_op->id) {
 100645e:	f899 301c 	ldrb.w	r3, [r9, #28]
 1006462:	428b      	cmp	r3, r1
 1006464:	d022      	beq.n	10064ac <ticker_job+0x180>
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 1006466:	2000      	movs	r0, #0
	if (user_op->fp_op_func) {
 1006468:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 100646a:	7028      	strb	r0, [r5, #0]
	user_op->status = status;
 100646c:	62a8      	str	r0, [r5, #40]	; 0x28
	if (user_op->fp_op_func) {
 100646e:	b10b      	cbz	r3, 1006474 <ticker_job+0x148>
		user_op->fp_op_func(user_op->status, user_op->op_context);
 1006470:	6b29      	ldr	r1, [r5, #48]	; 0x30
 1006472:	4798      	blx	r3
 1006474:	f89a c003 	ldrb.w	ip, [sl, #3]
 1006478:	f89a 3002 	ldrb.w	r3, [sl, #2]
 100647c:	e79d      	b.n	10063ba <ticker_job+0x8e>
		flag_elapsed = 0U;
 100647e:	920d      	str	r2, [sp, #52]	; 0x34
		ticks_elapsed = 0U;
 1006480:	9202      	str	r2, [sp, #8]
 1006482:	e77b      	b.n	100637c <ticker_job+0x50>
				instance->sched_cb(TICKER_CALL_ID_JOB,
 1006484:	2104      	movs	r1, #4
 1006486:	4657      	mov	r7, sl
 1006488:	464b      	mov	r3, r9
 100648a:	2201      	movs	r2, #1
 100648c:	4608      	mov	r0, r1
 100648e:	f8d9 4024 	ldr.w	r4, [r9, #36]	; 0x24
 1006492:	47a0      	blx	r4
				pending = 1U;
 1006494:	2301      	movs	r3, #1
	while (count_user--) {
 1006496:	9a0c      	ldr	r2, [sp, #48]	; 0x30
				pending = 1U;
 1006498:	9308      	str	r3, [sp, #32]
	while (count_user--) {
 100649a:	42ba      	cmp	r2, r7
				user->middle = prev;
 100649c:	f88a 8002 	strb.w	r8, [sl, #2]
	while (count_user--) {
 10064a0:	f1a7 0308 	sub.w	r3, r7, #8
 10064a4:	f000 8121 	beq.w	10066ea <ticker_job+0x3be>
 10064a8:	461f      	mov	r7, r3
 10064aa:	e780      	b.n	10063ae <ticker_job+0x82>
			instance->ticker_id_slot_previous = TICKER_NULL;
 10064ac:	23ff      	movs	r3, #255	; 0xff
			if (user_op->op == TICKER_USER_OP_TYPE_STOP_ABS) {
 10064ae:	2a07      	cmp	r2, #7
			instance->ticker_id_slot_previous = TICKER_NULL;
 10064b0:	f889 301c 	strb.w	r3, [r9, #28]
			if (user_op->op == TICKER_USER_OP_TYPE_STOP_ABS) {
 10064b4:	f040 81d5 	bne.w	1006862 <ticker_job+0x536>
				ticks_at_stop =
 10064b8:	6868      	ldr	r0, [r5, #4]
			ticks_current = instance->ticks_current;
 10064ba:	f8d9 3014 	ldr.w	r3, [r9, #20]
			if (!((ticks_at_stop - ticks_current) &
 10064be:	1ac2      	subs	r2, r0, r3
 10064c0:	0211      	lsls	r1, r2, #8
 10064c2:	f100 81c5 	bmi.w	1006850 <ticker_job+0x524>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 10064c6:	f022 437f 	bic.w	r3, r2, #4278190080	; 0xff000000
				ticks_used = ticks_elapsed +
 10064ca:	9a02      	ldr	r2, [sp, #8]
 10064cc:	4413      	add	r3, r2
			if (instance->ticks_slot_previous > ticks_used) {
 10064ce:	f8d9 2018 	ldr.w	r2, [r9, #24]
 10064d2:	429a      	cmp	r2, r3
				instance->ticks_slot_previous = ticks_used;
 10064d4:	bf88      	it	hi
 10064d6:	f8c9 3018 	strhi.w	r3, [r9, #24]
 10064da:	e7c4      	b.n	1006466 <ticker_job+0x13a>
			    ((user_op->op == TICKER_USER_OP_TYPE_UPDATE) &&
 10064dc:	686e      	ldr	r6, [r5, #4]
 10064de:	2e00      	cmp	r6, #0
 10064e0:	d196      	bne.n	1006410 <ticker_job+0xe4>
			     (user_op->params.update.ticks_drift_plus == 0U) &&
 10064e2:	68ae      	ldr	r6, [r5, #8]
 10064e4:	2e00      	cmp	r6, #0
 10064e6:	d193      	bne.n	1006410 <ticker_job+0xe4>
			     (user_op->params.update.ticks_drift_minus == 0U) &&
 10064e8:	68ee      	ldr	r6, [r5, #12]
 10064ea:	2e00      	cmp	r6, #0
 10064ec:	d190      	bne.n	1006410 <ticker_job+0xe4>
			     (user_op->params.update.ticks_slot_plus == 0U) &&
 10064ee:	692e      	ldr	r6, [r5, #16]
 10064f0:	2e00      	cmp	r6, #0
 10064f2:	d18d      	bne.n	1006410 <ticker_job+0xe4>
			     (user_op->params.update.lazy == 0U) &&
 10064f4:	696e      	ldr	r6, [r5, #20]
 10064f6:	f036 467f 	bics.w	r6, r6, #4278190080	; 0xff000000
 10064fa:	d189      	bne.n	1006410 <ticker_job+0xe4>
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 10064fc:	2100      	movs	r1, #0
	user_op->status = status;
 10064fe:	2001      	movs	r0, #1
	if (user_op->fp_op_func) {
 1006500:	6aea      	ldr	r2, [r5, #44]	; 0x2c
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 1006502:	7029      	strb	r1, [r5, #0]
	user_op->status = status;
 1006504:	62a8      	str	r0, [r5, #40]	; 0x28
	if (user_op->fp_op_func) {
 1006506:	2a00      	cmp	r2, #0
 1006508:	f43f af57 	beq.w	10063ba <ticker_job+0x8e>
		user_op->fp_op_func(user_op->status, user_op->op_context);
 100650c:	6b29      	ldr	r1, [r5, #48]	; 0x30
 100650e:	4790      	blx	r2
 1006510:	f89a c003 	ldrb.w	ip, [sl, #3]
 1006514:	f89a 3002 	ldrb.w	r3, [sl, #2]
 1006518:	e74f      	b.n	10063ba <ticker_job+0x8e>
	if (previous == current) {
 100651a:	458e      	cmp	lr, r1
 100651c:	d016      	beq.n	100654c <ticker_job+0x220>
 100651e:	eb0e 0e4e 	add.w	lr, lr, lr, lsl #1
 1006522:	eb06 110e 	add.w	r1, r6, lr, lsl #4
	node[previous].next = ticker_current->next;
 1006526:	7807      	ldrb	r7, [r0, #0]
	timeout = ticker_current->ticks_to_expire;
 1006528:	6880      	ldr	r0, [r0, #8]
	if (ticker_current->next != TICKER_NULL) {
 100652a:	2fff      	cmp	r7, #255	; 0xff
	node[previous].next = ticker_current->next;
 100652c:	700f      	strb	r7, [r1, #0]
	if (ticker_current->next != TICKER_NULL) {
 100652e:	d006      	beq.n	100653e <ticker_job+0x212>
		node[ticker_current->next].ticks_to_expire += timeout;
 1006530:	eb07 0747 	add.w	r7, r7, r7, lsl #1
 1006534:	eb06 1707 	add.w	r7, r6, r7, lsl #4
 1006538:	68b9      	ldr	r1, [r7, #8]
 100653a:	4401      	add	r1, r0
 100653c:	60b9      	str	r1, [r7, #8]
	return (total + timeout);
 100653e:	18c6      	adds	r6, r0, r3
	if (user_op->op == TICKER_USER_OP_TYPE_UPDATE) {
 1006540:	2a05      	cmp	r2, #5
	ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
 1006542:	60a6      	str	r6, [r4, #8]
	if (user_op->op == TICKER_USER_OP_TYPE_UPDATE) {
 1006544:	d008      	beq.n	1006558 <ticker_job+0x22c>
 1006546:	78a7      	ldrb	r7, [r4, #2]
 1006548:	7869      	ldrb	r1, [r5, #1]
 100654a:	e787      	b.n	100645c <ticker_job+0x130>
 100654c:	4601      	mov	r1, r0
		instance->ticker_id_head = ticker_current->next;
 100654e:	7802      	ldrb	r2, [r0, #0]
 1006550:	f889 201d 	strb.w	r2, [r9, #29]
 1006554:	782a      	ldrb	r2, [r5, #0]
 1006556:	e7e6      	b.n	1006526 <ticker_job+0x1fa>
		ticker_job_node_update(ticker, user_op, instance->ticks_current,
 1006558:	f8d9 7014 	ldr.w	r7, [r9, #20]
 100655c:	9703      	str	r7, [sp, #12]
	ticks_now = cntr_cnt_get();
 100655e:	f00b fab7 	bl	1011ad0 <cntr_cnt_get>
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
 1006562:	9b02      	ldr	r3, [sp, #8]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1006564:	eba0 0c07 	sub.w	ip, r0, r7
 1006568:	f02c 477f 	bic.w	r7, ip, #4278190080	; 0xff000000
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
 100656c:	443b      	add	r3, r7
	if (ticks_to_expire > ticks_elapsed) {
 100656e:	429e      	cmp	r6, r3
	ticks_now = cntr_cnt_get();
 1006570:	4680      	mov	r8, r0
	if (ticks_to_expire > ticks_elapsed) {
 1006572:	f240 80a1 	bls.w	10066b8 <ticker_job+0x38c>
		ticks_to_expire -= ticks_elapsed;
 1006576:	1af2      	subs	r2, r6, r3
 1006578:	6963      	ldr	r3, [r4, #20]
	if ((ticker->ticks_periodic != 0U) &&
 100657a:	6866      	ldr	r6, [r4, #4]
 100657c:	2e00      	cmp	r6, #0
 100657e:	d053      	beq.n	1006628 <ticker_job+0x2fc>
	    (user_op->params.update.lazy != 0U)) {
 1006580:	8aa8      	ldrh	r0, [r5, #20]
	if ((ticker->ticks_periodic != 0U) &&
 1006582:	2800      	cmp	r0, #0
 1006584:	d050      	beq.n	1006628 <ticker_job+0x2fc>
		user_op->params.update.lazy--;
 1006586:	3801      	subs	r0, #1
 1006588:	b280      	uxth	r0, r0
		while ((ticks_to_expire > ticker->ticks_periodic) &&
 100658a:	4296      	cmp	r6, r2
 100658c:	8be1      	ldrh	r1, [r4, #30]
		user_op->params.update.lazy--;
 100658e:	82a8      	strh	r0, [r5, #20]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
 1006590:	d225      	bcs.n	10065de <ticker_job+0x2b2>
 1006592:	f106 0b01 	add.w	fp, r6, #1
 1006596:	930b      	str	r3, [sp, #44]	; 0x2c
 1006598:	e011      	b.n	10065be <ticker_job+0x292>
 100659a:	46de      	mov	lr, fp
		ticker->remainder_current += HAL_TICKER_REMAINDER_RANGE;
 100659c:	f100 70e8 	add.w	r0, r0, #30408704	; 0x1d00000
 10065a0:	f500 30d4 	add.w	r0, r0, #108544	; 0x1a800
 10065a4:	f500 70a5 	add.w	r0, r0, #330	; 0x14a
	ticker->remainder_current -= ticker->remainder_periodic;
 10065a8:	9b09      	ldr	r3, [sp, #36]	; 0x24
			ticker->lazy_current--;
 10065aa:	3901      	subs	r1, #1
			ticks_to_expire -= ticker->ticks_periodic +
 10065ac:	eba2 020e 	sub.w	r2, r2, lr
			ticker->lazy_current--;
 10065b0:	b289      	uxth	r1, r1
	ticker->remainder_current -= ticker->remainder_periodic;
 10065b2:	1ac0      	subs	r0, r0, r3
		while ((ticks_to_expire > ticker->ticks_periodic) &&
 10065b4:	4296      	cmp	r6, r2
			ticker->lazy_current--;
 10065b6:	83e1      	strh	r1, [r4, #30]
	ticker->remainder_current -= ticker->remainder_periodic;
 10065b8:	6260      	str	r0, [r4, #36]	; 0x24
		while ((ticks_to_expire > ticker->ticks_periodic) &&
 10065ba:	d20e      	bcs.n	10065da <ticker_job+0x2ae>
 10065bc:	8aa8      	ldrh	r0, [r5, #20]
 10065be:	4288      	cmp	r0, r1
 10065c0:	f080 81ab 	bcs.w	100691a <ticker_job+0x5ee>
					   ticker_remainder_dec(ticker);
 10065c4:	e9d4 3008 	ldrd	r3, r0, [r4, #32]
	if ((ticker->remainder_current >= BIT(31)) ||
 10065c8:	f8df e2c0 	ldr.w	lr, [pc, #704]	; 100688c <ticker_job+0x560>
					   ticker_remainder_dec(ticker);
 10065cc:	9309      	str	r3, [sp, #36]	; 0x24
	if ((ticker->remainder_current >= BIT(31)) ||
 10065ce:	4bae      	ldr	r3, [pc, #696]	; (1006888 <ticker_job+0x55c>)
 10065d0:	4486      	add	lr, r0
 10065d2:	459e      	cmp	lr, r3
 10065d4:	d8e1      	bhi.n	100659a <ticker_job+0x26e>
 10065d6:	46b6      	mov	lr, r6
 10065d8:	e7e6      	b.n	10065a8 <ticker_job+0x27c>
 10065da:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 10065dc:	8aa8      	ldrh	r0, [r5, #20]
		while (ticker->lazy_current < user_op->params.update.lazy) {
 10065de:	4281      	cmp	r1, r0
 10065e0:	d221      	bcs.n	1006626 <ticker_job+0x2fa>
					   ticker_remainder_inc(ticker);
 10065e2:	6a20      	ldr	r0, [r4, #32]
 10065e4:	f106 0e01 	add.w	lr, r6, #1
 10065e8:	9009      	str	r0, [sp, #36]	; 0x24
 10065ea:	930b      	str	r3, [sp, #44]	; 0x2c
 10065ec:	e007      	b.n	10065fe <ticker_job+0x2d2>
	ticker->remainder_current += ticker->remainder_periodic;
 10065ee:	46b3      	mov	fp, r6
 10065f0:	6260      	str	r0, [r4, #36]	; 0x24
		while (ticker->lazy_current < user_op->params.update.lazy) {
 10065f2:	8aa8      	ldrh	r0, [r5, #20]
			ticker->lazy_current++;
 10065f4:	3101      	adds	r1, #1
 10065f6:	b289      	uxth	r1, r1
		while (ticker->lazy_current < user_op->params.update.lazy) {
 10065f8:	4281      	cmp	r1, r0
			ticks_to_expire += ticker->ticks_periodic +
 10065fa:	445a      	add	r2, fp
		while (ticker->lazy_current < user_op->params.update.lazy) {
 10065fc:	d211      	bcs.n	1006622 <ticker_job+0x2f6>
	ticker->remainder_current += ticker->remainder_periodic;
 10065fe:	9b09      	ldr	r3, [sp, #36]	; 0x24
 1006600:	6a60      	ldr	r0, [r4, #36]	; 0x24
	if ((ticker->remainder_current < BIT(31)) &&
 1006602:	f8df b288 	ldr.w	fp, [pc, #648]	; 100688c <ticker_job+0x560>
	ticker->remainder_current += ticker->remainder_periodic;
 1006606:	4418      	add	r0, r3
	if ((ticker->remainder_current < BIT(31)) &&
 1006608:	4b9f      	ldr	r3, [pc, #636]	; (1006888 <ticker_job+0x55c>)
 100660a:	4483      	add	fp, r0
 100660c:	459b      	cmp	fp, r3
 100660e:	d8ee      	bhi.n	10065ee <ticker_job+0x2c2>
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 1006610:	f1a0 70e8 	sub.w	r0, r0, #30408704	; 0x1d00000
 1006614:	f5a0 30d4 	sub.w	r0, r0, #108544	; 0x1a800
 1006618:	f5a0 70a5 	sub.w	r0, r0, #330	; 0x14a
 100661c:	46f3      	mov	fp, lr
 100661e:	6260      	str	r0, [r4, #36]	; 0x24
		return 1;
 1006620:	e7e7      	b.n	10065f2 <ticker_job+0x2c6>
 1006622:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 1006624:	83e1      	strh	r1, [r4, #30]
		ticker->lazy_periodic = user_op->params.update.lazy;
 1006626:	83a0      	strh	r0, [r4, #28]
	struct ticker_ext *ext_data = ticker->ext_data;
 1006628:	6aa6      	ldr	r6, [r4, #40]	; 0x28
				user_op->params.update.ticks_drift_minus;
 100662a:	e9d5 0e01 	ldrd	r0, lr, [r5, #4]
	ticker->ticks_to_expire = ticks_to_expire +
 100662e:	4402      	add	r2, r0
	ticker->ticks_to_expire_minus +=
 1006630:	4473      	add	r3, lr
	ticker->ticks_to_expire = ticks_to_expire +
 1006632:	60a2      	str	r2, [r4, #8]
	ticker->ticks_to_expire_minus +=
 1006634:	6163      	str	r3, [r4, #20]
	if (ext_data && ext_data->ticks_slot_window != 0U) {
 1006636:	b136      	cbz	r6, 1006646 <ticker_job+0x31a>
 1006638:	6831      	ldr	r1, [r6, #0]
 100663a:	b121      	cbz	r1, 1006646 <ticker_job+0x31a>
			user_op->params.update.ticks_drift_plus -
 100663c:	eba0 000e 	sub.w	r0, r0, lr
		ext_data->ticks_drift =
 1006640:	6070      	str	r0, [r6, #4]
 1006642:	68a2      	ldr	r2, [r4, #8]
 1006644:	6963      	ldr	r3, [r4, #20]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
 1006646:	f41c 0f00 	tst.w	ip, #8388608	; 0x800000
 100664a:	d120      	bne.n	100668e <ticker_job+0x362>
		ticks_to_expire += ticker_ticks_diff_get(ticks_at_start,
 100664c:	443a      	add	r2, r7
	if (ticks_to_expire > ticks_to_expire_minus) {
 100664e:	429a      	cmp	r2, r3
 1006650:	d91a      	bls.n	1006688 <ticker_job+0x35c>
		ticks_to_expire -= ticks_to_expire_minus;
 1006652:	1ad2      	subs	r2, r2, r3
		ticks_to_expire_minus = 0U;
 1006654:	2300      	movs	r3, #0
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
 1006656:	6163      	str	r3, [r4, #20]
	ticker->ticks_to_expire = ticks_to_expire;
 1006658:	60a2      	str	r2, [r4, #8]
	ticker->ticks_slot += user_op->params.update.ticks_slot_plus;
 100665a:	68e9      	ldr	r1, [r5, #12]
 100665c:	69a3      	ldr	r3, [r4, #24]
	if (ticker->ticks_slot > user_op->params.update.ticks_slot_minus) {
 100665e:	692a      	ldr	r2, [r5, #16]
	ticker->ticks_slot += user_op->params.update.ticks_slot_plus;
 1006660:	440b      	add	r3, r1
	if (ticker->ticks_slot > user_op->params.update.ticks_slot_minus) {
 1006662:	4293      	cmp	r3, r2
		ticker->ticks_slot = 0U;
 1006664:	bf94      	ite	ls
 1006666:	2300      	movls	r3, #0
		ticker->ticks_slot -= user_op->params.update.ticks_slot_minus;
 1006668:	1a9b      	subhi	r3, r3, r2
	if (user_op->params.update.force != 0U) {
 100666a:	7daa      	ldrb	r2, [r5, #22]
 100666c:	61a3      	str	r3, [r4, #24]
 100666e:	b102      	cbz	r2, 1006672 <ticker_job+0x346>
		ticker->force = user_op->params.update.force;
 1006670:	70e2      	strb	r2, [r4, #3]
	ticker->next = *insert_head;
 1006672:	9b04      	ldr	r3, [sp, #16]
 1006674:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 1006676:	4619      	mov	r1, r3
 1006678:	9b01      	ldr	r3, [sp, #4]
 100667a:	548b      	strb	r3, [r1, r2]
		ticker->req++;
 100667c:	7863      	ldrb	r3, [r4, #1]
	*insert_head = user_op->id;
 100667e:	786a      	ldrb	r2, [r5, #1]
		ticker->req++;
 1006680:	3301      	adds	r3, #1
	*insert_head = user_op->id;
 1006682:	9201      	str	r2, [sp, #4]
		ticker->req++;
 1006684:	7063      	strb	r3, [r4, #1]
 1006686:	e6ee      	b.n	1006466 <ticker_job+0x13a>
 1006688:	1a9b      	subs	r3, r3, r2
		ticks_to_expire = 0U;
 100668a:	2200      	movs	r2, #0
 100668c:	e7e3      	b.n	1006656 <ticker_job+0x32a>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 100668e:	9903      	ldr	r1, [sp, #12]
 1006690:	eba1 0708 	sub.w	r7, r1, r8
 1006694:	f027 477f 	bic.w	r7, r7, #4278190080	; 0xff000000
		if (ticks_to_expire > delta_current_start) {
 1006698:	4297      	cmp	r7, r2
 100669a:	d213      	bcs.n	10066c4 <ticker_job+0x398>
			ticks_to_expire -= delta_current_start;
 100669c:	1bd2      	subs	r2, r2, r7
 100669e:	e7d6      	b.n	100664e <ticker_job+0x322>
		ticker_job_node_update(ticker, user_op, instance->ticks_current,
 10066a0:	f8d9 7014 	ldr.w	r7, [r9, #20]
 10066a4:	9703      	str	r7, [sp, #12]
	ticks_now = cntr_cnt_get();
 10066a6:	f00b fa13 	bl	1011ad0 <cntr_cnt_get>
 10066aa:	4680      	mov	r8, r0
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
 10066ac:	9b02      	ldr	r3, [sp, #8]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 10066ae:	eba0 0c07 	sub.w	ip, r0, r7
 10066b2:	f02c 477f 	bic.w	r7, ip, #4278190080	; 0xff000000
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
 10066b6:	443b      	add	r3, r7
		ticker->ticks_to_expire_minus += ticks_elapsed -
 10066b8:	6961      	ldr	r1, [r4, #20]
		ticks_to_expire = 0U;
 10066ba:	2200      	movs	r2, #0
		ticker->ticks_to_expire_minus += ticks_elapsed -
 10066bc:	440b      	add	r3, r1
 10066be:	1b9b      	subs	r3, r3, r6
 10066c0:	6163      	str	r3, [r4, #20]
		ticks_to_expire = 0U;
 10066c2:	e75a      	b.n	100657a <ticker_job+0x24e>
			ticks_to_expire_minus +=
 10066c4:	443b      	add	r3, r7
 10066c6:	1a9b      	subs	r3, r3, r2
	if (ticks_to_expire > ticks_to_expire_minus) {
 10066c8:	e7df      	b.n	100668a <ticker_job+0x35e>
		if (current == id) {
 10066ca:	4601      	mov	r1, r0
	total = 0U;
 10066cc:	2300      	movs	r3, #0
 10066ce:	e73e      	b.n	100654e <ticker_job+0x222>
		while (user->middle != user->last) {
 10066d0:	4563      	cmp	r3, ip
 10066d2:	4698      	mov	r8, r3
			middle = user->middle + 1;
 10066d4:	f103 0201 	add.w	r2, r3, #1
		while (user->middle != user->last) {
 10066d8:	f47f ae78 	bne.w	10063cc <ticker_job+0xa0>
 10066dc:	4657      	mov	r7, sl
	while (count_user--) {
 10066de:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 10066e0:	f1a7 0308 	sub.w	r3, r7, #8
 10066e4:	42ba      	cmp	r2, r7
 10066e6:	f47f aedf 	bne.w	10064a8 <ticker_job+0x17c>
 10066ea:	f899 a01d 	ldrb.w	sl, [r9, #29]
 10066ee:	9b06      	ldr	r3, [sp, #24]
 10066f0:	46cb      	mov	fp, r9
 10066f2:	ebb3 030a 	subs.w	r3, r3, sl
 10066f6:	bf18      	it	ne
 10066f8:	2301      	movne	r3, #1
 10066fa:	9307      	str	r3, [sp, #28]
	if (flag_elapsed) {
 10066fc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 10066fe:	2b00      	cmp	r3, #0
 1006700:	f040 8160 	bne.w	10069c4 <ticker_job+0x698>
	node = &instance->nodes[0];
 1006704:	f8d9 3000 	ldr.w	r3, [r9]
	count_user = instance->count_user;
 1006708:	f899 2009 	ldrb.w	r2, [r9, #9]
	users = &instance->users[0];
 100670c:	f8d9 1004 	ldr.w	r1, [r9, #4]
	node = &instance->nodes[0];
 1006710:	9304      	str	r3, [sp, #16]
	while (count_user--) {
 1006712:	1e53      	subs	r3, r2, #1
 1006714:	b2db      	uxtb	r3, r3
	users = &instance->users[0];
 1006716:	9109      	str	r1, [sp, #36]	; 0x24
	while (count_user--) {
 1006718:	2a00      	cmp	r2, #0
 100671a:	f000 8102 	beq.w	1006922 <ticker_job+0x5f6>
 100671e:	eb01 08c3 	add.w	r8, r1, r3, lsl #3
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 1006722:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 1006724:	9303      	str	r3, [sp, #12]
		user_ops = (void *)&user->user_op[0];
 1006726:	f8d8 3004 	ldr.w	r3, [r8, #4]
		user_ops_first = user->first;
 100672a:	f898 4001 	ldrb.w	r4, [r8, #1]
		user_ops = (void *)&user->user_op[0];
 100672e:	9305      	str	r3, [sp, #20]
		while ((insert_head != TICKER_NULL) ||
 1006730:	9b01      	ldr	r3, [sp, #4]
 1006732:	2bff      	cmp	r3, #255	; 0xff
 1006734:	d055      	beq.n	10067e2 <ticker_job+0x4b6>
				ticker = &node[id_insert];
 1006736:	9a01      	ldr	r2, [sp, #4]
 1006738:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 100673c:	4692      	mov	sl, r2
 100673e:	9a04      	ldr	r2, [sp, #16]
 1006740:	ea4f 1c03 	mov.w	ip, r3, lsl #4
 1006744:	eb02 1303 	add.w	r3, r2, r3, lsl #4
				insert_head = ticker->next;
 1006748:	f812 200c 	ldrb.w	r2, [r2, ip]
 100674c:	9201      	str	r2, [sp, #4]
				user_op = NULL;
 100674e:	2200      	movs	r2, #0
	ticker->next = TICKER_NULL;
 1006750:	20ff      	movs	r0, #255	; 0xff
 1006752:	7018      	strb	r0, [r3, #0]
	(void)ticker_enqueue(instance, id_insert);
 1006754:	f8db 7000 	ldr.w	r7, [fp]
	current = instance->ticker_id_head;
 1006758:	f89b 101d 	ldrb.w	r1, [fp, #29]
	ticker_new = &node[id];
 100675c:	eb07 060c 	add.w	r6, r7, ip
	while ((current != TICKER_NULL) && (ticks_to_expire >=
 1006760:	4281      	cmp	r1, r0
	ticks_to_expire = ticker_new->ticks_to_expire;
 1006762:	68b5      	ldr	r5, [r6, #8]
	previous = TICKER_NULL;
 1006764:	bf18      	it	ne
 1006766:	9302      	strne	r3, [sp, #8]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
 1006768:	d110      	bne.n	100678c <ticker_job+0x460>
 100676a:	e088      	b.n	100687e <ticker_job+0x552>
		if (ticks_to_expire == 0 && (ticker_new->lazy_current >
 100676c:	ebb5 050c 	subs.w	r5, r5, ip
 1006770:	d105      	bne.n	100677e <ticker_job+0x452>
 1006772:	f8be e01e 	ldrh.w	lr, [lr, #30]
 1006776:	8bf3      	ldrh	r3, [r6, #30]
 1006778:	4573      	cmp	r3, lr
 100677a:	f200 80cb 	bhi.w	1006914 <ticker_job+0x5e8>
		current = ticker_current->next;
 100677e:	f817 c009 	ldrb.w	ip, [r7, r9]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
 1006782:	4608      	mov	r0, r1
 1006784:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
 1006788:	d06e      	beq.n	1006868 <ticker_job+0x53c>
 100678a:	4661      	mov	r1, ip
		(ticker_current = &node[current])->ticks_to_expire))) {
 100678c:	eb01 0941 	add.w	r9, r1, r1, lsl #1
 1006790:	eb07 1e09 	add.w	lr, r7, r9, lsl #4
		(ticks_to_expire_current =
 1006794:	f8de c008 	ldr.w	ip, [lr, #8]
		(ticker_current = &node[current])->ticks_to_expire))) {
 1006798:	ea4f 1909 	mov.w	r9, r9, lsl #4
	while ((current != TICKER_NULL) && (ticks_to_expire >=
 100679c:	45ac      	cmp	ip, r5
 100679e:	d9e5      	bls.n	100676c <ticker_job+0x440>
 10067a0:	9b02      	ldr	r3, [sp, #8]
	if (previous == TICKER_NULL) {
 10067a2:	28ff      	cmp	r0, #255	; 0xff
	ticker_new->ticks_to_expire = ticks_to_expire;
 10067a4:	60b5      	str	r5, [r6, #8]
	ticker_new->next = current;
 10067a6:	7031      	strb	r1, [r6, #0]
	if (previous == TICKER_NULL) {
 10067a8:	d163      	bne.n	1006872 <ticker_job+0x546>
		instance->ticker_id_head = id;
 10067aa:	f88b a01d 	strb.w	sl, [fp, #29]
	if (current != TICKER_NULL) {
 10067ae:	29ff      	cmp	r1, #255	; 0xff
 10067b0:	d006      	beq.n	10067c0 <ticker_job+0x494>
		node[current].ticks_to_expire -= ticks_to_expire;
 10067b2:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 10067b6:	eb07 1701 	add.w	r7, r7, r1, lsl #4
 10067ba:	68b9      	ldr	r1, [r7, #8]
 10067bc:	1b4d      	subs	r5, r1, r5
 10067be:	60bd      	str	r5, [r7, #8]
	ticker->req = ticker->ack + 1;
 10067c0:	7899      	ldrb	r1, [r3, #2]
 10067c2:	3101      	adds	r1, #1
 10067c4:	7059      	strb	r1, [r3, #1]
			if (user_op) {
 10067c6:	2a00      	cmp	r2, #0
 10067c8:	d0b2      	beq.n	1006730 <ticker_job+0x404>
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 10067ca:	9903      	ldr	r1, [sp, #12]
	if (user_op->fp_op_func) {
 10067cc:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 10067ce:	7011      	strb	r1, [r2, #0]
	user_op->status = status;
 10067d0:	6291      	str	r1, [r2, #40]	; 0x28
	if (user_op->fp_op_func) {
 10067d2:	2b00      	cmp	r3, #0
 10067d4:	d0ac      	beq.n	1006730 <ticker_job+0x404>
		user_op->fp_op_func(user_op->status, user_op->op_context);
 10067d6:	2000      	movs	r0, #0
 10067d8:	6b11      	ldr	r1, [r2, #48]	; 0x30
 10067da:	4798      	blx	r3
		while ((insert_head != TICKER_NULL) ||
 10067dc:	9b01      	ldr	r3, [sp, #4]
 10067de:	2bff      	cmp	r3, #255	; 0xff
 10067e0:	d1a9      	bne.n	1006736 <ticker_job+0x40a>
 10067e2:	f898 3002 	ldrb.w	r3, [r8, #2]
 10067e6:	42a3      	cmp	r3, r4
 10067e8:	d02b      	beq.n	1006842 <ticker_job+0x516>
	user_op->status = status;
 10067ea:	2501      	movs	r5, #1
 10067ec:	9e05      	ldr	r6, [sp, #20]
				user_op = &user_ops[user_ops_first];
 10067ee:	2234      	movs	r2, #52	; 0x34
 10067f0:	fb02 f104 	mul.w	r1, r2, r4
				if (first == user->count_user_op) {
 10067f4:	f898 2000 	ldrb.w	r2, [r8]
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
 10067f8:	5c70      	ldrb	r0, [r6, r1]
				first = user_ops_first + 1;
 10067fa:	3401      	adds	r4, #1
 10067fc:	b2e4      	uxtb	r4, r4
					first = 0U;
 10067fe:	42a2      	cmp	r2, r4
 1006800:	bf08      	it	eq
 1006802:	2400      	moveq	r4, #0
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
 1006804:	2804      	cmp	r0, #4
				user_op = &user_ops[user_ops_first];
 1006806:	eb06 0201 	add.w	r2, r6, r1
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
 100680a:	d118      	bne.n	100683e <ticker_job+0x512>
				id_insert = user_op->id;
 100680c:	f892 a001 	ldrb.w	sl, [r2, #1]
				ticker = &node[id_insert];
 1006810:	9b04      	ldr	r3, [sp, #16]
 1006812:	eb0a 0c4a 	add.w	ip, sl, sl, lsl #1
 1006816:	eb03 130c 	add.w	r3, r3, ip, lsl #4
				if (((ticker->req -
 100681a:	7858      	ldrb	r0, [r3, #1]
				      ticker->ack) & 0xff) != 0U) {
 100681c:	789f      	ldrb	r7, [r3, #2]
				ticker = &node[id_insert];
 100681e:	ea4f 1c0c 	mov.w	ip, ip, lsl #4
				if (((ticker->req -
 1006822:	1bc0      	subs	r0, r0, r7
 1006824:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
 1006828:	d032      	beq.n	1006890 <ticker_job+0x564>
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 100682a:	9b03      	ldr	r3, [sp, #12]
 100682c:	5473      	strb	r3, [r6, r1]
	if (user_op->fp_op_func) {
 100682e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	user_op->status = status;
 1006830:	6295      	str	r5, [r2, #40]	; 0x28
	if (user_op->fp_op_func) {
 1006832:	b113      	cbz	r3, 100683a <ticker_job+0x50e>
		user_op->fp_op_func(user_op->status, user_op->op_context);
 1006834:	2001      	movs	r0, #1
 1006836:	6b11      	ldr	r1, [r2, #48]	; 0x30
 1006838:	4798      	blx	r3
		while ((insert_head != TICKER_NULL) ||
 100683a:	f898 3002 	ldrb.w	r3, [r8, #2]
 100683e:	42a3      	cmp	r3, r4
 1006840:	d1d5      	bne.n	10067ee <ticker_job+0x4c2>
	while (count_user--) {
 1006842:	9a09      	ldr	r2, [sp, #36]	; 0x24
 1006844:	f1a8 0308 	sub.w	r3, r8, #8
 1006848:	4542      	cmp	r2, r8
 100684a:	d068      	beq.n	100691e <ticker_job+0x5f2>
 100684c:	4698      	mov	r8, r3
 100684e:	e76a      	b.n	1006726 <ticker_job+0x3fa>
				if (ticks_elapsed > ticks_used) {
 1006850:	9a02      	ldr	r2, [sp, #8]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1006852:	1a1b      	subs	r3, r3, r0
 1006854:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
				if (ticks_elapsed > ticks_used) {
 1006858:	429a      	cmp	r2, r3
					ticks_used = 0;
 100685a:	bf94      	ite	ls
 100685c:	2300      	movls	r3, #0
					ticks_used = ticks_elapsed -
 100685e:	1ad3      	subhi	r3, r2, r3
 1006860:	e635      	b.n	10064ce <ticker_job+0x1a2>
				ticks_at_stop = cntr_cnt_get();
 1006862:	f00b f935 	bl	1011ad0 <cntr_cnt_get>
 1006866:	e628      	b.n	10064ba <ticker_job+0x18e>
	ticker_new->next = current;
 1006868:	4661      	mov	r1, ip
 100686a:	9b02      	ldr	r3, [sp, #8]
	ticker_new->ticks_to_expire = ticks_to_expire;
 100686c:	60b5      	str	r5, [r6, #8]
	ticker_new->next = current;
 100686e:	f886 c000 	strb.w	ip, [r6]
		node[previous].next = id;
 1006872:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 1006876:	0100      	lsls	r0, r0, #4
 1006878:	f807 a000 	strb.w	sl, [r7, r0]
 100687c:	e797      	b.n	10067ae <ticker_job+0x482>
	ticker_new->next = current;
 100687e:	f807 100c 	strb.w	r1, [r7, ip]
		instance->ticker_id_head = id;
 1006882:	f88b a01d 	strb.w	sl, [fp, #29]
	if (current != TICKER_NULL) {
 1006886:	e79b      	b.n	10067c0 <ticker_job+0x494>
 1006888:	7f172b59 	.word	0x7f172b59
 100688c:	ff172b5a 	.word	0xff172b5a
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
 1006890:	f64f 71ff 	movw	r1, #65535	; 0xffff
 1006894:	8a97      	ldrh	r7, [r2, #20]
				ticker_job_op_start(ticker, user_op,
 1006896:	f8db 5014 	ldr.w	r5, [fp, #20]
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
 100689a:	428f      	cmp	r7, r1
 100689c:	d02f      	beq.n	10068fe <ticker_job+0x5d2>
 100689e:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c
	ticker->ext_data = start->ext_data;
 10068a2:	6a51      	ldr	r1, [r2, #36]	; 0x24
	ticker->ticks_periodic = start->ticks_periodic;
 10068a4:	68d6      	ldr	r6, [r2, #12]
	ticker->ext_data = start->ext_data;
 10068a6:	6299      	str	r1, [r3, #40]	; 0x28
	ticker->remainder_periodic = start->remainder_periodic;
 10068a8:	6911      	ldr	r1, [r2, #16]
	ticker->ticks_periodic = start->ticks_periodic;
 10068aa:	605e      	str	r6, [r3, #4]
	ticker->remainder_periodic = start->remainder_periodic;
 10068ac:	6219      	str	r1, [r3, #32]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
 10068ae:	6856      	ldr	r6, [r2, #4]
	ticker->timeout_func = start->fp_timeout_func;
 10068b0:	e9d2 1e06 	ldrd	r1, lr, [r2, #24]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
 10068b4:	839f      	strh	r7, [r3, #28]
	ticker->ticks_slot = start->ticks_slot;
 10068b6:	6199      	str	r1, [r3, #24]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
 10068b8:	1b77      	subs	r7, r6, r5
	ticker->context = start->context;
 10068ba:	6a11      	ldr	r1, [r2, #32]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
 10068bc:	f417 0f00 	tst.w	r7, #8388608	; 0x800000
	ticker->context = start->context;
 10068c0:	e9c3 e103 	strd	lr, r1, [r3, #12]
	ticker->ticks_to_expire = start->ticks_first;
 10068c4:	6891      	ldr	r1, [r2, #8]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
 10068c6:	d10b      	bne.n	10068e0 <ticker_job+0x5b4>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 10068c8:	f027 477f 	bic.w	r7, r7, #4278190080	; 0xff000000
		ticks_to_expire += ticker_ticks_diff_get(ticks_at_start,
 10068cc:	4439      	add	r1, r7
	if (ticks_to_expire > ticks_to_expire_minus) {
 10068ce:	b179      	cbz	r1, 10068f0 <ticker_job+0x5c4>
	ticker->force = 1U;
 10068d0:	2501      	movs	r5, #1
	ticker->ticks_to_expire = ticks_to_expire;
 10068d2:	6099      	str	r1, [r3, #8]
	ticker->remainder_current = 0U;
 10068d4:	9903      	ldr	r1, [sp, #12]
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
 10068d6:	6158      	str	r0, [r3, #20]
	ticker->remainder_current = 0U;
 10068d8:	6259      	str	r1, [r3, #36]	; 0x24
	ticker->lazy_current = 0U;
 10068da:	83d9      	strh	r1, [r3, #30]
	ticker->force = 1U;
 10068dc:	70dd      	strb	r5, [r3, #3]
}
 10068de:	e737      	b.n	1006750 <ticker_job+0x424>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 10068e0:	1bad      	subs	r5, r5, r6
 10068e2:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		if (ticks_to_expire > delta_current_start) {
 10068e6:	42a9      	cmp	r1, r5
 10068e8:	d905      	bls.n	10068f6 <ticker_job+0x5ca>
			ticks_to_expire -= delta_current_start;
 10068ea:	1b49      	subs	r1, r1, r5
	if (ticks_to_expire > ticks_to_expire_minus) {
 10068ec:	2900      	cmp	r1, #0
 10068ee:	d1ef      	bne.n	10068d0 <ticker_job+0x5a4>
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
 10068f0:	4608      	mov	r0, r1
		ticks_to_expire = 0U;
 10068f2:	2100      	movs	r1, #0
 10068f4:	e7ec      	b.n	10068d0 <ticker_job+0x5a4>
			    (delta_current_start - ticks_to_expire);
 10068f6:	1a69      	subs	r1, r5, r1
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
 10068f8:	4608      	mov	r0, r1
		ticks_to_expire = 0U;
 10068fa:	2100      	movs	r1, #0
 10068fc:	e7e8      	b.n	10068d0 <ticker_job+0x5a4>
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
 10068fe:	2101      	movs	r1, #1
 1006900:	f883 102c 	strb.w	r1, [r3, #44]	; 0x2c
	ticker->ext_data = start->ext_data;
 1006904:	6a51      	ldr	r1, [r2, #36]	; 0x24
	ticker->ticks_periodic = start->ticks_periodic;
 1006906:	68d6      	ldr	r6, [r2, #12]
	ticker->ext_data = start->ext_data;
 1006908:	6299      	str	r1, [r3, #40]	; 0x28
	ticker->remainder_periodic = start->remainder_periodic;
 100690a:	6911      	ldr	r1, [r2, #16]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
 100690c:	4607      	mov	r7, r0
	ticker->ticks_periodic = start->ticks_periodic;
 100690e:	605e      	str	r6, [r3, #4]
	ticker->remainder_periodic = start->remainder_periodic;
 1006910:	6219      	str	r1, [r3, #32]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
 1006912:	e7cc      	b.n	10068ae <ticker_job+0x582>
 1006914:	4665      	mov	r5, ip
 1006916:	9b02      	ldr	r3, [sp, #8]
 1006918:	e743      	b.n	10067a2 <ticker_job+0x476>
 100691a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 100691c:	e65f      	b.n	10065de <ticker_job+0x2b2>
 100691e:	f89b a01d 	ldrb.w	sl, [fp, #29]
	if (instance->ticker_id_head != ticker_id_old_head) {
 1006922:	9b06      	ldr	r3, [sp, #24]
 1006924:	459a      	cmp	sl, r3
 1006926:	f000 830f 	beq.w	1006f48 <ticker_job+0xc1c>
	if (!pending) {
 100692a:	9b08      	ldr	r3, [sp, #32]
 100692c:	2b00      	cmp	r3, #0
 100692e:	f000 832e 	beq.w	1006f8e <ticker_job+0xc62>
	instance->job_guard = 0U;
 1006932:	2300      	movs	r3, #0
 1006934:	f89b a01d 	ldrb.w	sl, [fp, #29]
 1006938:	f88b 301e 	strb.w	r3, [fp, #30]
	if (instance->ticker_id_head == TICKER_NULL) {
 100693c:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
 1006940:	f000 83b3 	beq.w	10070aa <ticker_job+0xd7e>
	if (ticker_id_old_head == TICKER_NULL) {
 1006944:	9b06      	ldr	r3, [sp, #24]
 1006946:	2bff      	cmp	r3, #255	; 0xff
 1006948:	f000 83ca 	beq.w	10070e0 <ticker_job+0xdb4>
	i = 10U;
 100694c:	270a      	movs	r7, #10
	ticks_to_expire = ticker->ticks_to_expire;
 100694e:	f8db 3000 	ldr.w	r3, [fp]
 1006952:	eb0a 024a 	add.w	r2, sl, sl, lsl #1
 1006956:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 100695a:	689d      	ldr	r5, [r3, #8]
		LL_ASSERT(i);
 100695c:	4e94      	ldr	r6, [pc, #592]	; (1006bb0 <ticker_job+0x884>)
		ctr = cntr_cnt_get();
 100695e:	f00b f8b7 	bl	1011ad0 <cntr_cnt_get>
		cc = instance->ticks_current;
 1006962:	f8db 3014 	ldr.w	r3, [fp, #20]
		ctr = cntr_cnt_get();
 1006966:	4680      	mov	r8, r0
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1006968:	1ac4      	subs	r4, r0, r3
 100696a:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
		ticks_elapsed = ticker_ticks_diff_get(ctr, cc) +
 100696e:	3403      	adds	r4, #3
		cc += MAX(ticks_elapsed, ticks_to_expire);
 1006970:	42ac      	cmp	r4, r5
 1006972:	bf2c      	ite	cs
 1006974:	191b      	addcs	r3, r3, r4
 1006976:	195b      	addcc	r3, r3, r5
		cc &= HAL_TICKER_CNTR_MASK;
 1006978:	f023 447f 	bic.w	r4, r3, #4278190080	; 0xff000000
		instance->trigger_set_cb(cc);
 100697c:	4620      	mov	r0, r4
 100697e:	f8db 2028 	ldr.w	r2, [fp, #40]	; 0x28
 1006982:	4790      	blx	r2
		ctr_post = cntr_cnt_get();
 1006984:	f00b f8a4 	bl	1011ad0 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1006988:	eba0 0008 	sub.w	r0, r0, r8
 100698c:	eba4 0408 	sub.w	r4, r4, r8
 1006990:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 1006994:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
	} while ((ticker_ticks_diff_get(ctr_post, ctr) +
 1006998:	3003      	adds	r0, #3
		  ticker_ticks_diff_get(cc, ctr));
 100699a:	42a0      	cmp	r0, r4
		i--;
 100699c:	f107 37ff 	add.w	r7, r7, #4294967295
		  ticker_ticks_diff_get(cc, ctr));
 10069a0:	f240 82dd 	bls.w	1006f5e <ticker_job+0xc32>
		LL_ASSERT(i);
 10069a4:	2f00      	cmp	r7, #0
 10069a6:	d1da      	bne.n	100695e <ticker_job+0x632>
 10069a8:	f640 0171 	movw	r1, #2161	; 0x871
 10069ac:	4630      	mov	r0, r6
 10069ae:	f7fc fe67 	bl	1003680 <bt_ctlr_assert_handle>
 10069b2:	e7d4      	b.n	100695e <ticker_job+0x632>
	if (flag_elapsed) {
 10069b4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 10069b6:	2b00      	cmp	r3, #0
 10069b8:	f000 82df 	beq.w	1006f7a <ticker_job+0xc4e>
	pending = 0U;
 10069bc:	9b07      	ldr	r3, [sp, #28]
 10069be:	9308      	str	r3, [sp, #32]
	insert_head = TICKER_NULL;
 10069c0:	23ff      	movs	r3, #255	; 0xff
 10069c2:	9301      	str	r3, [sp, #4]
	ticks_now = cntr_cnt_get();
 10069c4:	f00b f884 	bl	1011ad0 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 10069c8:	9b05      	ldr	r3, [sp, #20]
	while (instance->ticker_id_head != TICKER_NULL) {
 10069ca:	f89b a01d 	ldrb.w	sl, [fp, #29]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 10069ce:	1ac0      	subs	r0, r0, r3
 10069d0:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
 10069d4:	9304      	str	r3, [sp, #16]
	node = &instance->nodes[0];
 10069d6:	f8db 3000 	ldr.w	r3, [fp]
	while (instance->ticker_id_head != TICKER_NULL) {
 10069da:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
	node = &instance->nodes[0];
 10069de:	9303      	str	r3, [sp, #12]
	while (instance->ticker_id_head != TICKER_NULL) {
 10069e0:	f000 80b0 	beq.w	1006b44 <ticker_job+0x818>
	ticks_expired = 0U;
 10069e4:	f04f 0800 	mov.w	r8, #0
	while (instance->ticker_id_head != TICKER_NULL) {
 10069e8:	f8dd 9008 	ldr.w	r9, [sp, #8]
 10069ec:	e02e      	b.n	1006a4c <ticker_job+0x720>
		is_must_expire_skip = (ticker->must_expire &&
 10069ee:	8bdc      	ldrh	r4, [r3, #30]
 10069f0:	3c00      	subs	r4, #0
 10069f2:	bf18      	it	ne
 10069f4:	2401      	movne	r4, #1
		if (instance->ticks_slot_previous > ticks_to_expire) {
 10069f6:	f8db 1018 	ldr.w	r1, [fp, #24]
 10069fa:	428a      	cmp	r2, r1
			instance->ticker_id_slot_previous = TICKER_NULL;
 10069fc:	bf22      	ittt	cs
 10069fe:	f04f 32ff 	movcs.w	r2, #4294967295
 1006a02:	f88b 201c 	strbcs.w	r2, [fp, #28]
			instance->ticks_slot_previous = 0U;
 1006a06:	2200      	movcs	r2, #0
		if ((ticker->ticks_slot != 0U) &&
 1006a08:	699d      	ldr	r5, [r3, #24]
			instance->ticks_slot_previous -= ticks_to_expire;
 1006a0a:	bf38      	it	cc
 1006a0c:	1a8a      	subcc	r2, r1, r2
			instance->ticks_slot_previous = 0U;
 1006a0e:	f8cb 2018 	str.w	r2, [fp, #24]
		if ((ticker->ticks_slot != 0U) &&
 1006a12:	b135      	cbz	r5, 1006a22 <ticker_job+0x6f6>
		    (((ticker->req - ticker->ack) & 0xff) == 2U) &&
 1006a14:	785a      	ldrb	r2, [r3, #1]
 1006a16:	7899      	ldrb	r1, [r3, #2]
 1006a18:	1a52      	subs	r2, r2, r1
 1006a1a:	b2d2      	uxtb	r2, r2
		if ((ticker->ticks_slot != 0U) &&
 1006a1c:	2a02      	cmp	r2, #2
 1006a1e:	f000 814f 	beq.w	1006cc0 <ticker_job+0x994>
 1006a22:	6a99      	ldr	r1, [r3, #40]	; 0x28
		ticker->ticks_to_expire = 0U;
 1006a24:	2200      	movs	r2, #0
 1006a26:	609a      	str	r2, [r3, #8]
		instance->ticker_id_head = ticker->next;
 1006a28:	9a03      	ldr	r2, [sp, #12]
 1006a2a:	f812 200e 	ldrb.w	r2, [r2, lr]
 1006a2e:	f88b 201d 	strb.w	r2, [fp, #29]
		if ((ticker->ticks_periodic != 0U) ||
 1006a32:	685c      	ldr	r4, [r3, #4]
 1006a34:	bb0c      	cbnz	r4, 1006a7a <ticker_job+0x74e>
 1006a36:	b111      	cbz	r1, 1006a3e <ticker_job+0x712>
		    TICKER_RESCHEDULE_PENDING(ticker)) {
 1006a38:	7a0a      	ldrb	r2, [r1, #8]
 1006a3a:	2a01      	cmp	r2, #1
 1006a3c:	d05e      	beq.n	1006afc <ticker_job+0x7d0>
			ticker->req = ticker->ack;
 1006a3e:	789a      	ldrb	r2, [r3, #2]
 1006a40:	705a      	strb	r2, [r3, #1]
	while (instance->ticker_id_head != TICKER_NULL) {
 1006a42:	f89b a01d 	ldrb.w	sl, [fp, #29]
 1006a46:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
 1006a4a:	d07b      	beq.n	1006b44 <ticker_job+0x818>
		ticker = &node[id_expired];
 1006a4c:	9b03      	ldr	r3, [sp, #12]
 1006a4e:	eb0a 014a 	add.w	r1, sl, sl, lsl #1
 1006a52:	eb03 1301 	add.w	r3, r3, r1, lsl #4
		ticks_to_expire = ticker->ticks_to_expire;
 1006a56:	689a      	ldr	r2, [r3, #8]
		ticker = &node[id_expired];
 1006a58:	ea4f 1e01 	mov.w	lr, r1, lsl #4
		if (ticks_elapsed < ticks_to_expire) {
 1006a5c:	454a      	cmp	r2, r9
 1006a5e:	f200 8292 	bhi.w	1006f86 <ticker_job+0xc5a>
		ticks_latency -= ticks_to_expire;
 1006a62:	9904      	ldr	r1, [sp, #16]
		is_must_expire_skip = (ticker->must_expire &&
 1006a64:	f893 002c 	ldrb.w	r0, [r3, #44]	; 0x2c
		ticks_latency -= ticks_to_expire;
 1006a68:	1a89      	subs	r1, r1, r2
		ticks_elapsed -= ticks_to_expire;
 1006a6a:	eba9 0902 	sub.w	r9, r9, r2
		ticks_expired += ticks_to_expire;
 1006a6e:	4490      	add	r8, r2
		ticks_latency -= ticks_to_expire;
 1006a70:	9104      	str	r1, [sp, #16]
		is_must_expire_skip = (ticker->must_expire &&
 1006a72:	2800      	cmp	r0, #0
 1006a74:	d1bb      	bne.n	10069ee <ticker_job+0x6c2>
 1006a76:	4604      	mov	r4, r0
 1006a78:	e7bd      	b.n	10069f6 <ticker_job+0x6ca>
			if (TICKER_RESCHEDULE_PENDING(ticker)) {
 1006a7a:	b111      	cbz	r1, 1006a82 <ticker_job+0x756>
 1006a7c:	7a0a      	ldrb	r2, [r1, #8]
 1006a7e:	2a01      	cmp	r2, #1
 1006a80:	d03c      	beq.n	1006afc <ticker_job+0x7d0>
				if (!ticker->lazy_current) {
 1006a82:	8bda      	ldrh	r2, [r3, #30]
 1006a84:	920b      	str	r2, [sp, #44]	; 0x2c
 1006a86:	2a00      	cmp	r2, #0
 1006a88:	f040 812b 	bne.w	1006ce2 <ticker_job+0x9b6>
					lazy_periodic = ticker->lazy_periodic;
 1006a8c:	8b9a      	ldrh	r2, [r3, #28]
 1006a8e:	785d      	ldrb	r5, [r3, #1]
 1006a90:	4694      	mov	ip, r2
 1006a92:	9209      	str	r2, [sp, #36]	; 0x24
				while (count--) {
 1006a94:	1c66      	adds	r6, r4, #1
 1006a96:	960a      	str	r6, [sp, #40]	; 0x28
				ticks_to_expire = 0U;
 1006a98:	2200      	movs	r2, #0
 1006a9a:	e9d3 7108 	ldrd	r7, r1, [r3, #32]
 1006a9e:	4666      	mov	r6, ip
 1006aa0:	930c      	str	r3, [sp, #48]	; 0x30
 1006aa2:	e004      	b.n	1006aae <ticker_job+0x782>
 1006aa4:	46a4      	mov	ip, r4
				while (count--) {
 1006aa6:	3e01      	subs	r6, #1
 1006aa8:	1c73      	adds	r3, r6, #1
					ticks_to_expire +=
 1006aaa:	4462      	add	r2, ip
				while (count--) {
 1006aac:	d012      	beq.n	1006ad4 <ticker_job+0x7a8>
	if ((ticker->remainder_current < BIT(31)) &&
 1006aae:	f8df c108 	ldr.w	ip, [pc, #264]	; 1006bb8 <ticker_job+0x88c>
 1006ab2:	4b40      	ldr	r3, [pc, #256]	; (1006bb4 <ticker_job+0x888>)
	ticker->remainder_current += ticker->remainder_periodic;
 1006ab4:	4439      	add	r1, r7
	if ((ticker->remainder_current < BIT(31)) &&
 1006ab6:	448c      	add	ip, r1
 1006ab8:	459c      	cmp	ip, r3
 1006aba:	d8f3      	bhi.n	1006aa4 <ticker_job+0x778>
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 1006abc:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
 1006ac0:	f1a1 71e8 	sub.w	r1, r1, #30408704	; 0x1d00000
				while (count--) {
 1006ac4:	3e01      	subs	r6, #1
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 1006ac6:	f5a1 31d4 	sub.w	r1, r1, #108544	; 0x1a800
				while (count--) {
 1006aca:	1c73      	adds	r3, r6, #1
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 1006acc:	f5a1 71a5 	sub.w	r1, r1, #330	; 0x14a
					ticks_to_expire +=
 1006ad0:	4462      	add	r2, ip
				while (count--) {
 1006ad2:	d1ec      	bne.n	1006aae <ticker_job+0x782>
 1006ad4:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 1006ad6:	970a      	str	r7, [sp, #40]	; 0x28
 1006ad8:	6259      	str	r1, [r3, #36]	; 0x24
				if (!ticker->must_expire) {
 1006ada:	2800      	cmp	r0, #0
 1006adc:	f000 8200 	beq.w	1006ee0 <ticker_job+0xbb4>
				ticker->lazy_current += (lazy_periodic + lazy);
 1006ae0:	990b      	ldr	r1, [sp, #44]	; 0x2c
 1006ae2:	9809      	ldr	r0, [sp, #36]	; 0x24
 1006ae4:	4401      	add	r1, r0
 1006ae6:	83d9      	strh	r1, [r3, #30]
 1006ae8:	e00a      	b.n	1006b00 <ticker_job+0x7d4>
		instance->ticker_id_head = ticker->next;
 1006aea:	9a03      	ldr	r2, [sp, #12]
		ticker->ticks_to_expire = 0U;
 1006aec:	609c      	str	r4, [r3, #8]
		instance->ticker_id_head = ticker->next;
 1006aee:	f812 200e 	ldrb.w	r2, [r2, lr]
 1006af2:	f88b 201d 	strb.w	r2, [fp, #29]
		if ((ticker->ticks_periodic != 0U) ||
 1006af6:	685a      	ldr	r2, [r3, #4]
 1006af8:	2a00      	cmp	r2, #0
 1006afa:	d09d      	beq.n	1006a38 <ticker_job+0x70c>
				ticker->req = ticker->ack;
 1006afc:	464a      	mov	r2, r9
 1006afe:	789d      	ldrb	r5, [r3, #2]
			ticks_to_expire_prep(ticker, instance->ticks_current,
 1006b00:	9805      	ldr	r0, [sp, #20]
 1006b02:	f8db 1014 	ldr.w	r1, [fp, #20]
 1006b06:	eb00 0608 	add.w	r6, r0, r8
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
 1006b0a:	1a74      	subs	r4, r6, r1
 1006b0c:	0227      	lsls	r7, r4, #8
	u32_t ticks_to_expire_minus = ticker->ticks_to_expire_minus;
 1006b0e:	6958      	ldr	r0, [r3, #20]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
 1006b10:	f100 80ca 	bmi.w	1006ca8 <ticker_job+0x97c>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1006b14:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
		ticks_to_expire += ticker_ticks_diff_get(ticks_at_start,
 1006b18:	4422      	add	r2, r4
	if (ticks_to_expire > ticks_to_expire_minus) {
 1006b1a:	4290      	cmp	r0, r2
 1006b1c:	f080 80cd 	bcs.w	1006cba <ticker_job+0x98e>
		ticks_to_expire -= ticks_to_expire_minus;
 1006b20:	1a12      	subs	r2, r2, r0
		ticks_to_expire_minus = 0U;
 1006b22:	2000      	movs	r0, #0
	ticker->ticks_to_expire = ticks_to_expire;
 1006b24:	609a      	str	r2, [r3, #8]
			ticker->next = *insert_head;
 1006b26:	9a03      	ldr	r2, [sp, #12]
			ticker->req++;
 1006b28:	3501      	adds	r5, #1
			ticker->next = *insert_head;
 1006b2a:	4611      	mov	r1, r2
 1006b2c:	9a01      	ldr	r2, [sp, #4]
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
 1006b2e:	6158      	str	r0, [r3, #20]
			ticker->next = *insert_head;
 1006b30:	f801 200e 	strb.w	r2, [r1, lr]
			ticker->req++;
 1006b34:	705d      	strb	r5, [r3, #1]
 1006b36:	f8cd a004 	str.w	sl, [sp, #4]
	while (instance->ticker_id_head != TICKER_NULL) {
 1006b3a:	f89b a01d 	ldrb.w	sl, [fp, #29]
 1006b3e:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
 1006b42:	d183      	bne.n	1006a4c <ticker_job+0x720>
			flag_compare_update = 1U;
 1006b44:	e9dd 1306 	ldrd	r1, r3, [sp, #24]
 1006b48:	4551      	cmp	r1, sl
 1006b4a:	bf18      	it	ne
 1006b4c:	2301      	movne	r3, #1
	count_user = instance->count_user;
 1006b4e:	f89b 2009 	ldrb.w	r2, [fp, #9]
	users = &instance->users[0];
 1006b52:	f8db 1004 	ldr.w	r1, [fp, #4]
			flag_compare_update = 1U;
 1006b56:	9307      	str	r3, [sp, #28]
	while (count_user--) {
 1006b58:	1e53      	subs	r3, r2, #1
 1006b5a:	b2db      	uxtb	r3, r3
	users = &instance->users[0];
 1006b5c:	9109      	str	r1, [sp, #36]	; 0x24
	while (count_user--) {
 1006b5e:	2a00      	cmp	r2, #0
 1006b60:	f000 811a 	beq.w	1006d98 <ticker_job+0xa6c>
 1006b64:	9a09      	ldr	r2, [sp, #36]	; 0x24
 1006b66:	eb02 08c3 	add.w	r8, r2, r3, lsl #3
		user_ops = (void *)&user->user_op[0];
 1006b6a:	f8d8 3004 	ldr.w	r3, [r8, #4]
		user_ops_first = user->first;
 1006b6e:	f898 4001 	ldrb.w	r4, [r8, #1]
		user_ops = (void *)&user->user_op[0];
 1006b72:	9305      	str	r3, [sp, #20]
		while ((insert_head != TICKER_NULL) ||
 1006b74:	9b01      	ldr	r3, [sp, #4]
 1006b76:	2bff      	cmp	r3, #255	; 0xff
 1006b78:	d05e      	beq.n	1006c38 <ticker_job+0x90c>
				ticker = &node[id_insert];
 1006b7a:	9a01      	ldr	r2, [sp, #4]
 1006b7c:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 1006b80:	4692      	mov	sl, r2
 1006b82:	9a03      	ldr	r2, [sp, #12]
 1006b84:	ea4f 1c03 	mov.w	ip, r3, lsl #4
 1006b88:	eb02 1303 	add.w	r3, r2, r3, lsl #4
				insert_head = ticker->next;
 1006b8c:	f812 200c 	ldrb.w	r2, [r2, ip]
 1006b90:	9201      	str	r2, [sp, #4]
				user_op = NULL;
 1006b92:	2200      	movs	r2, #0
	ticker->next = TICKER_NULL;
 1006b94:	20ff      	movs	r0, #255	; 0xff
 1006b96:	7018      	strb	r0, [r3, #0]
	(void)ticker_enqueue(instance, id_insert);
 1006b98:	f8db 7000 	ldr.w	r7, [fp]
	current = instance->ticker_id_head;
 1006b9c:	f89b 101d 	ldrb.w	r1, [fp, #29]
	ticker_new = &node[id];
 1006ba0:	eb07 060c 	add.w	r6, r7, ip
	while ((current != TICKER_NULL) && (ticks_to_expire >=
 1006ba4:	4281      	cmp	r1, r0
	ticks_to_expire = ticker_new->ticks_to_expire;
 1006ba6:	68b5      	ldr	r5, [r6, #8]
	previous = TICKER_NULL;
 1006ba8:	bf18      	it	ne
 1006baa:	9304      	strne	r3, [sp, #16]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
 1006bac:	d117      	bne.n	1006bde <ticker_job+0x8b2>
 1006bae:	e0df      	b.n	1006d70 <ticker_job+0xa44>
 1006bb0:	010185c8 	.word	0x010185c8
 1006bb4:	7f172b59 	.word	0x7f172b59
 1006bb8:	ff172b5a 	.word	0xff172b5a
		if (ticks_to_expire == 0 && (ticker_new->lazy_current >
 1006bbc:	ebb5 050c 	subs.w	r5, r5, ip
 1006bc0:	d105      	bne.n	1006bce <ticker_job+0x8a2>
 1006bc2:	f8be e01e 	ldrh.w	lr, [lr, #30]
 1006bc6:	8bf3      	ldrh	r3, [r6, #30]
 1006bc8:	4573      	cmp	r3, lr
 1006bca:	f200 809b 	bhi.w	1006d04 <ticker_job+0x9d8>
		current = ticker_current->next;
 1006bce:	f817 c009 	ldrb.w	ip, [r7, r9]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
 1006bd2:	4608      	mov	r0, r1
 1006bd4:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
 1006bd8:	f000 8089 	beq.w	1006cee <ticker_job+0x9c2>
 1006bdc:	4661      	mov	r1, ip
		(ticker_current = &node[current])->ticks_to_expire))) {
 1006bde:	eb01 0941 	add.w	r9, r1, r1, lsl #1
 1006be2:	eb07 1e09 	add.w	lr, r7, r9, lsl #4
		(ticks_to_expire_current =
 1006be6:	f8de c008 	ldr.w	ip, [lr, #8]
		(ticker_current = &node[current])->ticks_to_expire))) {
 1006bea:	ea4f 1909 	mov.w	r9, r9, lsl #4
	while ((current != TICKER_NULL) && (ticks_to_expire >=
 1006bee:	45ac      	cmp	ip, r5
 1006bf0:	d9e4      	bls.n	1006bbc <ticker_job+0x890>
 1006bf2:	9b04      	ldr	r3, [sp, #16]
	if (previous == TICKER_NULL) {
 1006bf4:	28ff      	cmp	r0, #255	; 0xff
	ticker_new->ticks_to_expire = ticks_to_expire;
 1006bf6:	60b5      	str	r5, [r6, #8]
	ticker_new->next = current;
 1006bf8:	7031      	strb	r1, [r6, #0]
	if (previous == TICKER_NULL) {
 1006bfa:	d17d      	bne.n	1006cf8 <ticker_job+0x9cc>
		instance->ticker_id_head = id;
 1006bfc:	f88b a01d 	strb.w	sl, [fp, #29]
	if (current != TICKER_NULL) {
 1006c00:	29ff      	cmp	r1, #255	; 0xff
 1006c02:	d006      	beq.n	1006c12 <ticker_job+0x8e6>
		node[current].ticks_to_expire -= ticks_to_expire;
 1006c04:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 1006c08:	eb07 1701 	add.w	r7, r7, r1, lsl #4
 1006c0c:	68b9      	ldr	r1, [r7, #8]
 1006c0e:	1b4d      	subs	r5, r1, r5
 1006c10:	60bd      	str	r5, [r7, #8]
	ticker->req = ticker->ack + 1;
 1006c12:	7899      	ldrb	r1, [r3, #2]
 1006c14:	3101      	adds	r1, #1
 1006c16:	7059      	strb	r1, [r3, #1]
			if (user_op) {
 1006c18:	2a00      	cmp	r2, #0
 1006c1a:	d0ab      	beq.n	1006b74 <ticker_job+0x848>
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 1006c1c:	f04f 0100 	mov.w	r1, #0
 1006c20:	7011      	strb	r1, [r2, #0]
	user_op->status = status;
 1006c22:	2100      	movs	r1, #0
	if (user_op->fp_op_func) {
 1006c24:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	user_op->status = status;
 1006c26:	6291      	str	r1, [r2, #40]	; 0x28
	if (user_op->fp_op_func) {
 1006c28:	2b00      	cmp	r3, #0
 1006c2a:	d0a3      	beq.n	1006b74 <ticker_job+0x848>
		user_op->fp_op_func(user_op->status, user_op->op_context);
 1006c2c:	2000      	movs	r0, #0
 1006c2e:	6b11      	ldr	r1, [r2, #48]	; 0x30
 1006c30:	4798      	blx	r3
		while ((insert_head != TICKER_NULL) ||
 1006c32:	9b01      	ldr	r3, [sp, #4]
 1006c34:	2bff      	cmp	r3, #255	; 0xff
 1006c36:	d1a0      	bne.n	1006b7a <ticker_job+0x84e>
 1006c38:	f898 3002 	ldrb.w	r3, [r8, #2]
 1006c3c:	42a3      	cmp	r3, r4
 1006c3e:	d02c      	beq.n	1006c9a <ticker_job+0x96e>
	user_op->status = status;
 1006c40:	2501      	movs	r5, #1
 1006c42:	9e05      	ldr	r6, [sp, #20]
				user_op = &user_ops[user_ops_first];
 1006c44:	2234      	movs	r2, #52	; 0x34
 1006c46:	fb02 f104 	mul.w	r1, r2, r4
				if (first == user->count_user_op) {
 1006c4a:	f898 2000 	ldrb.w	r2, [r8]
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
 1006c4e:	5c70      	ldrb	r0, [r6, r1]
				first = user_ops_first + 1;
 1006c50:	3401      	adds	r4, #1
 1006c52:	b2e4      	uxtb	r4, r4
					first = 0U;
 1006c54:	42a2      	cmp	r2, r4
 1006c56:	bf08      	it	eq
 1006c58:	2400      	moveq	r4, #0
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
 1006c5a:	2804      	cmp	r0, #4
				user_op = &user_ops[user_ops_first];
 1006c5c:	eb06 0201 	add.w	r2, r6, r1
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
 1006c60:	d119      	bne.n	1006c96 <ticker_job+0x96a>
				id_insert = user_op->id;
 1006c62:	f892 a001 	ldrb.w	sl, [r2, #1]
				ticker = &node[id_insert];
 1006c66:	9b03      	ldr	r3, [sp, #12]
 1006c68:	eb0a 0c4a 	add.w	ip, sl, sl, lsl #1
 1006c6c:	eb03 130c 	add.w	r3, r3, ip, lsl #4
				if (((ticker->req -
 1006c70:	7858      	ldrb	r0, [r3, #1]
				      ticker->ack) & 0xff) != 0U) {
 1006c72:	789f      	ldrb	r7, [r3, #2]
				ticker = &node[id_insert];
 1006c74:	ea4f 1c0c 	mov.w	ip, ip, lsl #4
				if (((ticker->req -
 1006c78:	1bc0      	subs	r0, r0, r7
 1006c7a:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
 1006c7e:	d044      	beq.n	1006d0a <ticker_job+0x9de>
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 1006c80:	f04f 0300 	mov.w	r3, #0
 1006c84:	5473      	strb	r3, [r6, r1]
	if (user_op->fp_op_func) {
 1006c86:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	user_op->status = status;
 1006c88:	6295      	str	r5, [r2, #40]	; 0x28
	if (user_op->fp_op_func) {
 1006c8a:	b113      	cbz	r3, 1006c92 <ticker_job+0x966>
		user_op->fp_op_func(user_op->status, user_op->op_context);
 1006c8c:	2001      	movs	r0, #1
 1006c8e:	6b11      	ldr	r1, [r2, #48]	; 0x30
 1006c90:	4798      	blx	r3
		while ((insert_head != TICKER_NULL) ||
 1006c92:	f898 3002 	ldrb.w	r3, [r8, #2]
 1006c96:	42a3      	cmp	r3, r4
 1006c98:	d1d4      	bne.n	1006c44 <ticker_job+0x918>
	while (count_user--) {
 1006c9a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 1006c9c:	f1a8 0308 	sub.w	r3, r8, #8
 1006ca0:	4542      	cmp	r2, r8
 1006ca2:	d079      	beq.n	1006d98 <ticker_job+0xa6c>
 1006ca4:	4698      	mov	r8, r3
 1006ca6:	e760      	b.n	1006b6a <ticker_job+0x83e>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1006ca8:	1b89      	subs	r1, r1, r6
 1006caa:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
		if (ticks_to_expire > delta_current_start) {
 1006cae:	4291      	cmp	r1, r2
 1006cb0:	d214      	bcs.n	1006cdc <ticker_job+0x9b0>
			ticks_to_expire -= delta_current_start;
 1006cb2:	1a52      	subs	r2, r2, r1
	if (ticks_to_expire > ticks_to_expire_minus) {
 1006cb4:	4290      	cmp	r0, r2
 1006cb6:	f4ff af33 	bcc.w	1006b20 <ticker_job+0x7f4>
 1006cba:	1a80      	subs	r0, r0, r2
		ticks_to_expire = 0U;
 1006cbc:	2200      	movs	r2, #0
 1006cbe:	e731      	b.n	1006b24 <ticker_job+0x7f8>
		    !TICKER_RESCHEDULE_PENDING(ticker)) {
 1006cc0:	6a99      	ldr	r1, [r3, #40]	; 0x28
		    (((ticker->req - ticker->ack) & 0xff) == 2U) &&
 1006cc2:	2c00      	cmp	r4, #0
 1006cc4:	f47f aeae 	bne.w	1006a24 <ticker_job+0x6f8>
		    !is_must_expire_skip &&
 1006cc8:	b119      	cbz	r1, 1006cd2 <ticker_job+0x9a6>
		    !TICKER_RESCHEDULE_PENDING(ticker)) {
 1006cca:	7a0a      	ldrb	r2, [r1, #8]
 1006ccc:	2a01      	cmp	r2, #1
 1006cce:	f43f af0c 	beq.w	1006aea <ticker_job+0x7be>
			instance->ticker_id_slot_previous = id_expired;
 1006cd2:	f88b a01c 	strb.w	sl, [fp, #28]
			instance->ticks_slot_previous = ticker->ticks_slot;
 1006cd6:	f8cb 5018 	str.w	r5, [fp, #24]
 1006cda:	e6a3      	b.n	1006a24 <ticker_job+0x6f8>
			ticks_to_expire_minus +=
 1006cdc:	4408      	add	r0, r1
 1006cde:	1a80      	subs	r0, r0, r2
	if (ticks_to_expire > ticks_to_expire_minus) {
 1006ce0:	e7ec      	b.n	1006cbc <ticker_job+0x990>
					ticker->req = ticker->ack;
 1006ce2:	f04f 0c00 	mov.w	ip, #0
 1006ce6:	789d      	ldrb	r5, [r3, #2]
					lazy_periodic = 0U;
 1006ce8:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 1006cec:	e6d2      	b.n	1006a94 <ticker_job+0x768>
	ticker_new->next = current;
 1006cee:	4661      	mov	r1, ip
 1006cf0:	9b04      	ldr	r3, [sp, #16]
	ticker_new->ticks_to_expire = ticks_to_expire;
 1006cf2:	60b5      	str	r5, [r6, #8]
	ticker_new->next = current;
 1006cf4:	f886 c000 	strb.w	ip, [r6]
		node[previous].next = id;
 1006cf8:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 1006cfc:	0100      	lsls	r0, r0, #4
 1006cfe:	f807 a000 	strb.w	sl, [r7, r0]
 1006d02:	e77d      	b.n	1006c00 <ticker_job+0x8d4>
 1006d04:	4665      	mov	r5, ip
 1006d06:	9b04      	ldr	r3, [sp, #16]
 1006d08:	e774      	b.n	1006bf4 <ticker_job+0x8c8>
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
 1006d0a:	f64f 71ff 	movw	r1, #65535	; 0xffff
 1006d0e:	8a97      	ldrh	r7, [r2, #20]
				ticker_job_op_start(ticker, user_op,
 1006d10:	f8db 5014 	ldr.w	r5, [fp, #20]
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
 1006d14:	428f      	cmp	r7, r1
 1006d16:	d030      	beq.n	1006d7a <ticker_job+0xa4e>
 1006d18:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c
	ticker->ext_data = start->ext_data;
 1006d1c:	6a51      	ldr	r1, [r2, #36]	; 0x24
	ticker->ticks_periodic = start->ticks_periodic;
 1006d1e:	68d6      	ldr	r6, [r2, #12]
	ticker->ext_data = start->ext_data;
 1006d20:	6299      	str	r1, [r3, #40]	; 0x28
	ticker->remainder_periodic = start->remainder_periodic;
 1006d22:	6911      	ldr	r1, [r2, #16]
	ticker->ticks_periodic = start->ticks_periodic;
 1006d24:	605e      	str	r6, [r3, #4]
	ticker->remainder_periodic = start->remainder_periodic;
 1006d26:	6219      	str	r1, [r3, #32]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
 1006d28:	6856      	ldr	r6, [r2, #4]
	ticker->timeout_func = start->fp_timeout_func;
 1006d2a:	e9d2 1e06 	ldrd	r1, lr, [r2, #24]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
 1006d2e:	839f      	strh	r7, [r3, #28]
	ticker->ticks_slot = start->ticks_slot;
 1006d30:	6199      	str	r1, [r3, #24]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
 1006d32:	1b77      	subs	r7, r6, r5
	ticker->context = start->context;
 1006d34:	6a11      	ldr	r1, [r2, #32]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
 1006d36:	f417 0f00 	tst.w	r7, #8388608	; 0x800000
	ticker->context = start->context;
 1006d3a:	e9c3 e103 	strd	lr, r1, [r3, #12]
	ticker->ticks_to_expire = start->ticks_first;
 1006d3e:	6891      	ldr	r1, [r2, #8]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
 1006d40:	d10b      	bne.n	1006d5a <ticker_job+0xa2e>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1006d42:	f027 477f 	bic.w	r7, r7, #4278190080	; 0xff000000
		ticks_to_expire += ticker_ticks_diff_get(ticks_at_start,
 1006d46:	4439      	add	r1, r7
	if (ticks_to_expire > ticks_to_expire_minus) {
 1006d48:	b179      	cbz	r1, 1006d6a <ticker_job+0xa3e>
	ticker->force = 1U;
 1006d4a:	2501      	movs	r5, #1
	ticker->ticks_to_expire = ticks_to_expire;
 1006d4c:	6099      	str	r1, [r3, #8]
	ticker->remainder_current = 0U;
 1006d4e:	2100      	movs	r1, #0
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
 1006d50:	6158      	str	r0, [r3, #20]
	ticker->remainder_current = 0U;
 1006d52:	6259      	str	r1, [r3, #36]	; 0x24
	ticker->lazy_current = 0U;
 1006d54:	83d9      	strh	r1, [r3, #30]
	ticker->force = 1U;
 1006d56:	70dd      	strb	r5, [r3, #3]
}
 1006d58:	e71c      	b.n	1006b94 <ticker_job+0x868>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1006d5a:	1bad      	subs	r5, r5, r6
 1006d5c:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		if (ticks_to_expire > delta_current_start) {
 1006d60:	42a9      	cmp	r1, r5
 1006d62:	d915      	bls.n	1006d90 <ticker_job+0xa64>
			ticks_to_expire -= delta_current_start;
 1006d64:	1b49      	subs	r1, r1, r5
	if (ticks_to_expire > ticks_to_expire_minus) {
 1006d66:	2900      	cmp	r1, #0
 1006d68:	d1ef      	bne.n	1006d4a <ticker_job+0xa1e>
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
 1006d6a:	4608      	mov	r0, r1
		ticks_to_expire = 0U;
 1006d6c:	2100      	movs	r1, #0
 1006d6e:	e7ec      	b.n	1006d4a <ticker_job+0xa1e>
	ticker_new->next = current;
 1006d70:	f807 100c 	strb.w	r1, [r7, ip]
		instance->ticker_id_head = id;
 1006d74:	f88b a01d 	strb.w	sl, [fp, #29]
	if (current != TICKER_NULL) {
 1006d78:	e74b      	b.n	1006c12 <ticker_job+0x8e6>
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
 1006d7a:	2101      	movs	r1, #1
 1006d7c:	f883 102c 	strb.w	r1, [r3, #44]	; 0x2c
	ticker->ext_data = start->ext_data;
 1006d80:	6a51      	ldr	r1, [r2, #36]	; 0x24
	ticker->ticks_periodic = start->ticks_periodic;
 1006d82:	68d6      	ldr	r6, [r2, #12]
	ticker->ext_data = start->ext_data;
 1006d84:	6299      	str	r1, [r3, #40]	; 0x28
	ticker->remainder_periodic = start->remainder_periodic;
 1006d86:	6911      	ldr	r1, [r2, #16]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
 1006d88:	4607      	mov	r7, r0
	ticker->ticks_periodic = start->ticks_periodic;
 1006d8a:	605e      	str	r6, [r3, #4]
	ticker->remainder_periodic = start->remainder_periodic;
 1006d8c:	6219      	str	r1, [r3, #32]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
 1006d8e:	e7cb      	b.n	1006d28 <ticker_job+0x9fc>
			    (delta_current_start - ticks_to_expire);
 1006d90:	1a69      	subs	r1, r5, r1
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
 1006d92:	4608      	mov	r0, r1
		ticks_to_expire = 0U;
 1006d94:	2100      	movs	r1, #0
 1006d96:	e7d8      	b.n	1006d4a <ticker_job+0xa1e>
	u8_t  rescheduled = 0U;
 1006d98:	2200      	movs	r2, #0
	nodes = &instance->nodes[0];
 1006d9a:	f8db 4000 	ldr.w	r4, [fp]
	while (rescheduling) {
 1006d9e:	f89b a01d 	ldrb.w	sl, [fp, #29]
 1006da2:	f8cd b004 	str.w	fp, [sp, #4]
		while (ticker_id_head != TICKER_NULL) {
 1006da6:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
 1006daa:	d00f      	beq.n	1006dcc <ticker_job+0xaa0>
 1006dac:	46d6      	mov	lr, sl
			ticker = &nodes[ticker_id_head];
 1006dae:	eb0e 034e 	add.w	r3, lr, lr, lsl #1
 1006db2:	eb04 1103 	add.w	r1, r4, r3, lsl #4
			ext_data = ticker->ext_data;
 1006db6:	6a88      	ldr	r0, [r1, #40]	; 0x28
			ticker = &nodes[ticker_id_head];
 1006db8:	011b      	lsls	r3, r3, #4
			if (ext_data && ext_data->reschedule_state ==
 1006dba:	b110      	cbz	r0, 1006dc2 <ticker_job+0xa96>
 1006dbc:	7a05      	ldrb	r5, [r0, #8]
 1006dbe:	2d01      	cmp	r5, #1
 1006dc0:	d015      	beq.n	1006dee <ticker_job+0xac2>
			ticker_id_head = ticker->next;
 1006dc2:	f814 e003 	ldrb.w	lr, [r4, r3]
		while (ticker_id_head != TICKER_NULL) {
 1006dc6:	f1be 0fff 	cmp.w	lr, #255	; 0xff
 1006dca:	d1f0      	bne.n	1006dae <ticker_job+0xa82>
	return rescheduled;
 1006dcc:	f8dd b004 	ldr.w	fp, [sp, #4]
		if (ticker_job_reschedule_in_window(instance, ticks_elapsed)) {
 1006dd0:	2a00      	cmp	r2, #0
 1006dd2:	f43f ada6 	beq.w	1006922 <ticker_job+0x5f6>
	if (instance->ticker_id_head != ticker_id_old_head) {
 1006dd6:	9b06      	ldr	r3, [sp, #24]
 1006dd8:	4553      	cmp	r3, sl
 1006dda:	f47f ada6 	bne.w	100692a <ticker_job+0x5fe>
	if (!pending) {
 1006dde:	9b08      	ldr	r3, [sp, #32]
 1006de0:	2b00      	cmp	r3, #0
 1006de2:	f000 8170 	beq.w	10070c6 <ticker_job+0xd9a>
	instance->job_guard = 0U;
 1006de6:	2300      	movs	r3, #0
 1006de8:	f88b 301e 	strb.w	r3, [fp, #30]
	if (flag_compare_update) {
 1006dec:	e5a6      	b.n	100693c <ticker_job+0x610>
		if (instance->ticker_id_slot_previous != TICKER_NULL &&
 1006dee:	9b01      	ldr	r3, [sp, #4]
 1006df0:	4684      	mov	ip, r0
 1006df2:	7f1b      	ldrb	r3, [r3, #28]
 1006df4:	2bff      	cmp	r3, #255	; 0xff
 1006df6:	d04f      	beq.n	1006e98 <ticker_job+0xb6c>
			instance->ticks_slot_previous > ticks_elapsed) {
 1006df8:	9b01      	ldr	r3, [sp, #4]
 1006dfa:	6998      	ldr	r0, [r3, #24]
		if (instance->ticker_id_slot_previous != TICKER_NULL &&
 1006dfc:	9b02      	ldr	r3, [sp, #8]
 1006dfe:	4283      	cmp	r3, r0
 1006e00:	d24a      	bcs.n	1006e98 <ticker_job+0xb6c>
			window_start_ticks = instance->ticks_slot_previous -
 1006e02:	1ac0      	subs	r0, r0, r3
		if (ext_data->ticks_drift < ext_data->ticks_slot_window) {
 1006e04:	e9dc 5300 	ldrd	r5, r3, [ip]
 1006e08:	42ab      	cmp	r3, r5
		ticker_id_iter = nodes[ticker_id_head].next;
 1006e0a:	780f      	ldrb	r7, [r1, #0]
		if (ext_data->ticks_drift < ext_data->ticks_slot_window) {
 1006e0c:	d239      	bcs.n	1006e82 <ticker_job+0xb56>
		while (ticker_id_iter != TICKER_NULL &&
 1006e0e:	2fff      	cmp	r7, #255	; 0xff
			ticks_slot_window = ext_data->ticks_slot_window -
 1006e10:	eba5 0503 	sub.w	r5, r5, r3
		while (ticker_id_iter != TICKER_NULL &&
 1006e14:	d035      	beq.n	1006e82 <ticker_job+0xb56>
		       ticks_start_offset + ticker->ticks_slot <=
 1006e16:	698e      	ldr	r6, [r1, #24]
		while (ticker_id_iter != TICKER_NULL &&
 1006e18:	2300      	movs	r3, #0
 1006e1a:	42b5      	cmp	r5, r6
 1006e1c:	d33f      	bcc.n	1006e9e <ticker_job+0xb72>
 1006e1e:	46b1      	mov	r9, r6
 1006e20:	4698      	mov	r8, r3
 1006e22:	463a      	mov	r2, r7
 1006e24:	9103      	str	r1, [sp, #12]
 1006e26:	e01b      	b.n	1006e60 <ticker_job+0xb34>
			if (node->ticks_to_expire >
 1006e28:	f8d1 b008 	ldr.w	fp, [r1, #8]
					MIN(ticks_slot_window,
 1006e2c:	f1ab 0304 	sub.w	r3, fp, #4
			if (node->ticks_to_expire >
 1006e30:	f1bb 0f04 	cmp.w	fp, #4
					MIN(ticks_slot_window,
 1006e34:	4443      	add	r3, r8
			if (node->ticks_to_expire >
 1006e36:	d908      	bls.n	1006e4a <ticker_job+0xb1e>
				window_end_ticks =
 1006e38:	42ab      	cmp	r3, r5
 1006e3a:	bf28      	it	cs
 1006e3c:	462b      	movcs	r3, r5
			if (window_end_ticks > ticks_start_offset +
 1006e3e:	454b      	cmp	r3, r9
 1006e40:	d903      	bls.n	1006e4a <ticker_job+0xb1e>
			if (ticks_to_expire != 0U &&
 1006e42:	1b9b      	subs	r3, r3, r6
 1006e44:	d001      	beq.n	1006e4a <ticker_job+0xb1e>
 1006e46:	4283      	cmp	r3, r0
 1006e48:	d228      	bcs.n	1006e9c <ticker_job+0xb70>
			window_start_ticks  = node->ticks_to_expire +
 1006e4a:	6988      	ldr	r0, [r1, #24]
			ticker_id_iter = node->next;
 1006e4c:	5ca2      	ldrb	r2, [r4, r2]
			window_start_ticks  = node->ticks_to_expire +
 1006e4e:	4458      	add	r0, fp
			ticks_start_offset += node->ticks_to_expire;
 1006e50:	44d8      	add	r8, fp
			ticks_to_expire     = ticks_slot_window -
 1006e52:	1bab      	subs	r3, r5, r6
		while (ticker_id_iter != TICKER_NULL &&
 1006e54:	2aff      	cmp	r2, #255	; 0xff
		       ticks_start_offset + ticker->ticks_slot <=
 1006e56:	eb08 0906 	add.w	r9, r8, r6
		while (ticker_id_iter != TICKER_NULL &&
 1006e5a:	d01f      	beq.n	1006e9c <ticker_job+0xb70>
 1006e5c:	454d      	cmp	r5, r9
 1006e5e:	d31d      	bcc.n	1006e9c <ticker_job+0xb70>
			node = &nodes[ticker_id_iter];
 1006e60:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 1006e64:	eb04 1102 	add.w	r1, r4, r2, lsl #4
			if (node->ext_data &&
 1006e68:	f8d1 b028 	ldr.w	fp, [r1, #40]	; 0x28
			node = &nodes[ticker_id_iter];
 1006e6c:	0112      	lsls	r2, r2, #4
			if (node->ext_data &&
 1006e6e:	f1bb 0f00 	cmp.w	fp, #0
 1006e72:	d0d9      	beq.n	1006e28 <ticker_job+0xafc>
 1006e74:	f89b b008 	ldrb.w	fp, [fp, #8]
 1006e78:	f1bb 0f01 	cmp.w	fp, #1
 1006e7c:	d1d4      	bne.n	1006e28 <ticker_job+0xafc>
				ticker_id_iter = node->next;
 1006e7e:	5ca2      	ldrb	r2, [r4, r2]
				continue;
 1006e80:	e7e8      	b.n	1006e54 <ticker_job+0xb28>
		ticker->ticks_to_expire = ticks_to_expire;
 1006e82:	2300      	movs	r3, #0
 1006e84:	608b      	str	r3, [r1, #8]
		ticker->lazy_current--;
 1006e86:	8bcb      	ldrh	r3, [r1, #30]
		rescheduled  = 1U;
 1006e88:	2201      	movs	r2, #1
		ticker->lazy_current--;
 1006e8a:	3b01      	subs	r3, #1
 1006e8c:	83cb      	strh	r3, [r1, #30]
		ext_data->reschedule_state =
 1006e8e:	f04f 0302 	mov.w	r3, #2
 1006e92:	f88c 3008 	strb.w	r3, [ip, #8]
		rescheduled  = 1U;
 1006e96:	e786      	b.n	1006da6 <ticker_job+0xa7a>
		window_start_ticks = 0U;
 1006e98:	2000      	movs	r0, #0
 1006e9a:	e7b3      	b.n	1006e04 <ticker_job+0xad8>
 1006e9c:	9903      	ldr	r1, [sp, #12]
		ticker->ticks_to_expire = ticks_to_expire;
 1006e9e:	463a      	mov	r2, r7
 1006ea0:	f04f 08ff 	mov.w	r8, #255	; 0xff
 1006ea4:	608b      	str	r3, [r1, #8]
		while (ticker_id_iter != TICKER_NULL) {
 1006ea6:	e000      	b.n	1006eaa <ticker_job+0xb7e>
 1006ea8:	462a      	mov	r2, r5
			node = &nodes[ticker_id_iter];
 1006eaa:	eb02 0042 	add.w	r0, r2, r2, lsl #1
 1006eae:	eb04 1900 	add.w	r9, r4, r0, lsl #4
			if (ticker->ticks_to_expire > node->ticks_to_expire) {
 1006eb2:	f8d9 6008 	ldr.w	r6, [r9, #8]
			node = &nodes[ticker_id_iter];
 1006eb6:	0105      	lsls	r5, r0, #4
			if (ticker->ticks_to_expire > node->ticks_to_expire) {
 1006eb8:	429e      	cmp	r6, r3
			node = &nodes[ticker_id_iter];
 1006eba:	ea4f 0042 	mov.w	r0, r2, lsl #1
			if (ticker->ticks_to_expire > node->ticks_to_expire) {
 1006ebe:	d23a      	bcs.n	1006f36 <ticker_job+0xc0a>
				ticker->ticks_to_expire -=
 1006ec0:	1b9b      	subs	r3, r3, r6
 1006ec2:	608b      	str	r3, [r1, #8]
			ticker_id_iter = node->next;
 1006ec4:	5d65      	ldrb	r5, [r4, r5]
		while (ticker_id_iter != TICKER_NULL) {
 1006ec6:	4690      	mov	r8, r2
 1006ec8:	2dff      	cmp	r5, #255	; 0xff
 1006eca:	d1ed      	bne.n	1006ea8 <ticker_job+0xb7c>
			instance->ticker_id_head = nodes[ticker_id_head].next;
 1006ecc:	9b01      	ldr	r3, [sp, #4]
			nodes[ticker_id_head].next = nodes[ticker_id_prev].next;
 1006ece:	4402      	add	r2, r0
			instance->ticker_id_head = nodes[ticker_id_head].next;
 1006ed0:	775f      	strb	r7, [r3, #29]
			nodes[ticker_id_head].next = nodes[ticker_id_prev].next;
 1006ed2:	0112      	lsls	r2, r2, #4
 1006ed4:	5ca3      	ldrb	r3, [r4, r2]
			nodes[ticker_id_prev].next = ticker_id_head;
 1006ed6:	46ba      	mov	sl, r7
			nodes[ticker_id_head].next = nodes[ticker_id_prev].next;
 1006ed8:	700b      	strb	r3, [r1, #0]
			nodes[ticker_id_prev].next = ticker_id_head;
 1006eda:	f804 e002 	strb.w	lr, [r4, r2]
 1006ede:	e7d2      	b.n	1006e86 <ticker_job+0xb5a>
					while (ticks_to_expire <
 1006ee0:	9e04      	ldr	r6, [sp, #16]
 1006ee2:	4296      	cmp	r6, r2
 1006ee4:	f67f adfc 	bls.w	1006ae0 <ticker_job+0x7b4>
 1006ee8:	4633      	mov	r3, r6
 1006eea:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 1006eec:	f104 0c01 	add.w	ip, r4, #1
 1006ef0:	950d      	str	r5, [sp, #52]	; 0x34
 1006ef2:	e005      	b.n	1006f00 <ticker_job+0xbd4>
 1006ef4:	4626      	mov	r6, r4
						ticks_to_expire +=
 1006ef6:	4432      	add	r2, r6
						lazy++;
 1006ef8:	3001      	adds	r0, #1
					while (ticks_to_expire <
 1006efa:	4293      	cmp	r3, r2
						lazy++;
 1006efc:	b280      	uxth	r0, r0
					while (ticks_to_expire <
 1006efe:	d911      	bls.n	1006f24 <ticker_job+0xbf8>
	if ((ticker->remainder_current < BIT(31)) &&
 1006f00:	4e80      	ldr	r6, [pc, #512]	; (1007104 <ticker_job+0xdd8>)
 1006f02:	4d81      	ldr	r5, [pc, #516]	; (1007108 <ticker_job+0xddc>)
	ticker->remainder_current += ticker->remainder_periodic;
 1006f04:	4439      	add	r1, r7
	if ((ticker->remainder_current < BIT(31)) &&
 1006f06:	198e      	adds	r6, r1, r6
 1006f08:	42ae      	cmp	r6, r5
 1006f0a:	d8f3      	bhi.n	1006ef4 <ticker_job+0xbc8>
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 1006f0c:	4666      	mov	r6, ip
 1006f0e:	f1a1 71e8 	sub.w	r1, r1, #30408704	; 0x1d00000
						ticks_to_expire +=
 1006f12:	4432      	add	r2, r6
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 1006f14:	f5a1 31d4 	sub.w	r1, r1, #108544	; 0x1a800
						lazy++;
 1006f18:	3001      	adds	r0, #1
					while (ticks_to_expire <
 1006f1a:	4293      	cmp	r3, r2
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 1006f1c:	f5a1 71a5 	sub.w	r1, r1, #330	; 0x14a
						lazy++;
 1006f20:	b280      	uxth	r0, r0
					while (ticks_to_expire <
 1006f22:	d8ed      	bhi.n	1006f00 <ticker_job+0xbd4>
 1006f24:	e9dd 350c 	ldrd	r3, r5, [sp, #48]	; 0x30
 1006f28:	9c09      	ldr	r4, [sp, #36]	; 0x24
 1006f2a:	6259      	str	r1, [r3, #36]	; 0x24
 1006f2c:	4404      	add	r4, r0
 1006f2e:	b2a0      	uxth	r0, r4
 1006f30:	9009      	str	r0, [sp, #36]	; 0x24
 1006f32:	e5d5      	b.n	1006ae0 <ticker_job+0x7b4>
 1006f34:	4770      	bx	lr
				node->ticks_to_expire -=
 1006f36:	1af3      	subs	r3, r6, r3
		if (ticker_id_prev != TICKER_NULL) {
 1006f38:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
				node->ticks_to_expire -=
 1006f3c:	f8c9 3008 	str.w	r3, [r9, #8]
		if (ticker_id_prev != TICKER_NULL) {
 1006f40:	d0a1      	beq.n	1006e86 <ticker_job+0xb5a>
 1006f42:	4642      	mov	r2, r8
 1006f44:	0050      	lsls	r0, r2, #1
 1006f46:	e7c1      	b.n	1006ecc <ticker_job+0xba0>
	if (!pending) {
 1006f48:	9b08      	ldr	r3, [sp, #32]
 1006f4a:	2b00      	cmp	r3, #0
 1006f4c:	f000 80a2 	beq.w	1007094 <ticker_job+0xd68>
	instance->job_guard = 0U;
 1006f50:	2300      	movs	r3, #0
 1006f52:	f88b 301e 	strb.w	r3, [fp, #30]
	if (flag_compare_update) {
 1006f56:	9b07      	ldr	r3, [sp, #28]
 1006f58:	2b00      	cmp	r3, #0
 1006f5a:	f040 80be 	bne.w	10070da <ticker_job+0xdae>
 1006f5e:	f89b 201f 	ldrb.w	r2, [fp, #31]
	if (instance->worker_trigger) {
 1006f62:	b16a      	cbz	r2, 1006f80 <ticker_job+0xc54>
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
 1006f64:	f8db 4024 	ldr.w	r4, [fp, #36]	; 0x24
 1006f68:	465b      	mov	r3, fp
 1006f6a:	2201      	movs	r2, #1
 1006f6c:	2103      	movs	r1, #3
 1006f6e:	2004      	movs	r0, #4
 1006f70:	46a4      	mov	ip, r4
}
 1006f72:	b00f      	add	sp, #60	; 0x3c
 1006f74:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
 1006f78:	4760      	bx	ip
	instance->job_guard = 0U;
 1006f7a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 1006f7c:	f88b 301e 	strb.w	r3, [fp, #30]
}
 1006f80:	b00f      	add	sp, #60	; 0x3c
 1006f82:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			ticker->ticks_to_expire -= ticks_elapsed;
 1006f86:	eba2 0209 	sub.w	r2, r2, r9
 1006f8a:	609a      	str	r2, [r3, #8]
			break;
 1006f8c:	e5da      	b.n	1006b44 <ticker_job+0x818>
	count_user = instance->count_user;
 1006f8e:	f89b 3009 	ldrb.w	r3, [fp, #9]
	users = &instance->users[0];
 1006f92:	f8db 2004 	ldr.w	r2, [fp, #4]
	while (count_user--) {
 1006f96:	1e5c      	subs	r4, r3, #1
	users = &instance->users[0];
 1006f98:	9201      	str	r2, [sp, #4]
	while (count_user--) {
 1006f9a:	b2e4      	uxtb	r4, r4
 1006f9c:	2b00      	cmp	r3, #0
 1006f9e:	f43f acc8 	beq.w	1006932 <ticker_job+0x606>
		flag_compare_update = 1U;
 1006fa2:	2301      	movs	r3, #1
 1006fa4:	9307      	str	r3, [sp, #28]
 1006fa6:	9b01      	ldr	r3, [sp, #4]
 1006fa8:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
		while (user->first != user->last) {
 1006fac:	7863      	ldrb	r3, [r4, #1]
 1006fae:	78e2      	ldrb	r2, [r4, #3]
		user_op = &user->user_op[0];
 1006fb0:	6866      	ldr	r6, [r4, #4]
		while (user->first != user->last) {
 1006fb2:	429a      	cmp	r2, r3
 1006fb4:	d05b      	beq.n	100706e <ticker_job+0xd42>
			uop->status = TICKER_STATUS_FAILURE;
 1006fb6:	f04f 0801 	mov.w	r8, #1
 1006fba:	e00b      	b.n	1006fd4 <ticker_job+0xca8>
	switch (uop->op) {
 1006fbc:	2901      	cmp	r1, #1
 1006fbe:	d052      	beq.n	1007066 <ticker_job+0xd3a>
			first = user->first + 1;
 1006fc0:	7863      	ldrb	r3, [r4, #1]
			if (first == user->count_user_op) {
 1006fc2:	7821      	ldrb	r1, [r4, #0]
			first = user->first + 1;
 1006fc4:	3301      	adds	r3, #1
 1006fc6:	b2db      	uxtb	r3, r3
				first = 0U;
 1006fc8:	4299      	cmp	r1, r3
 1006fca:	bf08      	it	eq
 1006fcc:	2300      	moveq	r3, #0
		while (user->first != user->last) {
 1006fce:	429a      	cmp	r2, r3
			user->first = first;
 1006fd0:	7063      	strb	r3, [r4, #1]
		while (user->first != user->last) {
 1006fd2:	d04c      	beq.n	100706e <ticker_job+0xd42>
			ticker_job_op_inquire(instance, &user_op[user->first]);
 1006fd4:	2134      	movs	r1, #52	; 0x34
 1006fd6:	fb01 f303 	mul.w	r3, r1, r3
	switch (uop->op) {
 1006fda:	5cf1      	ldrb	r1, [r6, r3]
			ticker_job_op_inquire(instance, &user_op[user->first]);
 1006fdc:	4433      	add	r3, r6
	switch (uop->op) {
 1006fde:	2902      	cmp	r1, #2
 1006fe0:	d01b      	beq.n	100701a <ticker_job+0xcee>
 1006fe2:	2903      	cmp	r1, #3
 1006fe4:	d1ea      	bne.n	1006fbc <ticker_job+0xc90>
		if (uop->id < instance->count_node) {
 1006fe6:	785a      	ldrb	r2, [r3, #1]
 1006fe8:	f89b 1008 	ldrb.w	r1, [fp, #8]
 1006fec:	4291      	cmp	r1, r2
 1006fee:	d911      	bls.n	1007014 <ticker_job+0xce8>
			node[uop->id].priority =
 1006ff0:	f8db 1000 	ldr.w	r1, [fp]
 1006ff4:	7918      	ldrb	r0, [r3, #4]
 1006ff6:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 1006ffa:	eb01 1202 	add.w	r2, r1, r2, lsl #4
 1006ffe:	f882 002d 	strb.w	r0, [r2, #45]	; 0x2d
			uop->status = TICKER_STATUS_SUCCESS;
 1007002:	2200      	movs	r2, #0
 1007004:	629a      	str	r2, [r3, #40]	; 0x28
		fp_op_func = uop->fp_op_func;
 1007006:	6ada      	ldr	r2, [r3, #44]	; 0x2c
	if (fp_op_func) {
 1007008:	b112      	cbz	r2, 1007010 <ticker_job+0xce4>
		fp_op_func(uop->status, uop->op_context);
 100700a:	6b19      	ldr	r1, [r3, #48]	; 0x30
 100700c:	6a98      	ldr	r0, [r3, #40]	; 0x28
 100700e:	4790      	blx	r2
 1007010:	78e2      	ldrb	r2, [r4, #3]
 1007012:	e7d5      	b.n	1006fc0 <ticker_job+0xc94>
			uop->status = TICKER_STATUS_FAILURE;
 1007014:	f8c3 8028 	str.w	r8, [r3, #40]	; 0x28
 1007018:	e7f5      	b.n	1007006 <ticker_job+0xcda>
		ticker_by_next_slot_get(instance,
 100701a:	e9d3 c101 	ldrd	ip, r1, [r3, #4]
	_ticker_id_head = *ticker_id_head;
 100701e:	f89c 2000 	ldrb.w	r2, [ip]
		ticker_by_next_slot_get(instance,
 1007022:	f8d3 e00c 	ldr.w	lr, [r3, #12]
	if ((_ticker_id_head == TICKER_NULL) ||
 1007026:	2aff      	cmp	r2, #255	; 0xff
	node = instance->nodes;
 1007028:	f8db 5000 	ldr.w	r5, [fp]
	if ((_ticker_id_head == TICKER_NULL) ||
 100702c:	f8db 0014 	ldr.w	r0, [fp, #20]
 1007030:	d002      	beq.n	1007038 <ticker_job+0xd0c>
 1007032:	680f      	ldr	r7, [r1, #0]
 1007034:	4287      	cmp	r7, r0
 1007036:	d026      	beq.n	1007086 <ticker_job+0xd5a>
		_ticker_id_head = instance->ticker_id_head;
 1007038:	f89b 201d 	ldrb.w	r2, [fp, #29]
		*ticks_current = instance->ticks_current;
 100703c:	6008      	str	r0, [r1, #0]
		_ticks_to_expire = 0U;
 100703e:	2100      	movs	r1, #0
 1007040:	e00b      	b.n	100705a <ticker_job+0xd2e>
	       ((ticker = &node[_ticker_id_head])->ticks_slot == 0U)) {
 1007042:	eb02 0042 	add.w	r0, r2, r2, lsl #1
 1007046:	eb05 1a00 	add.w	sl, r5, r0, lsl #4
	while ((_ticker_id_head != TICKER_NULL) &&
 100704a:	f8da 7018 	ldr.w	r7, [sl, #24]
	       ((ticker = &node[_ticker_id_head])->ticks_slot == 0U)) {
 100704e:	0100      	lsls	r0, r0, #4
	while ((_ticker_id_head != TICKER_NULL) &&
 1007050:	b9af      	cbnz	r7, 100707e <ticker_job+0xd52>
		_ticks_to_expire += ticker->ticks_to_expire;
 1007052:	f8da 9008 	ldr.w	r9, [sl, #8]
		_ticker_id_head = ticker->next;
 1007056:	5c2a      	ldrb	r2, [r5, r0]
		_ticks_to_expire += ticker->ticks_to_expire;
 1007058:	4449      	add	r1, r9
	while ((_ticker_id_head != TICKER_NULL) &&
 100705a:	2aff      	cmp	r2, #255	; 0xff
 100705c:	d1f1      	bne.n	1007042 <ticker_job+0xd16>
	*ticker_id_head = _ticker_id_head;
 100705e:	f88c 2000 	strb.w	r2, [ip]
	*ticks_to_expire = _ticks_to_expire;
 1007062:	f8ce 1000 	str.w	r1, [lr]
		uop->status = TICKER_STATUS_SUCCESS;
 1007066:	2200      	movs	r2, #0
 1007068:	629a      	str	r2, [r3, #40]	; 0x28
		fp_op_func = uop->fp_op_func;
 100706a:	6ada      	ldr	r2, [r3, #44]	; 0x2c
		break;
 100706c:	e7cc      	b.n	1007008 <ticker_job+0xcdc>
	while (count_user--) {
 100706e:	9a01      	ldr	r2, [sp, #4]
 1007070:	f1a4 0308 	sub.w	r3, r4, #8
 1007074:	42a2      	cmp	r2, r4
 1007076:	f43f af6b 	beq.w	1006f50 <ticker_job+0xc24>
 100707a:	461c      	mov	r4, r3
 100707c:	e796      	b.n	1006fac <ticker_job+0xc80>
		_ticks_to_expire += ticker->ticks_to_expire;
 100707e:	f8da 0008 	ldr.w	r0, [sl, #8]
 1007082:	4401      	add	r1, r0
 1007084:	e7eb      	b.n	100705e <ticker_job+0xd32>
		ticker = &node[_ticker_id_head];
 1007086:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 100708a:	0112      	lsls	r2, r2, #4
		_ticker_id_head = ticker->next;
 100708c:	5caa      	ldrb	r2, [r5, r2]
	_ticks_to_expire = *ticks_to_expire;
 100708e:	f8de 1000 	ldr.w	r1, [lr]
	while ((_ticker_id_head != TICKER_NULL) &&
 1007092:	e7e2      	b.n	100705a <ticker_job+0xd2e>
	count_user = instance->count_user;
 1007094:	f89b 3009 	ldrb.w	r3, [fp, #9]
	users = &instance->users[0];
 1007098:	f8db 2004 	ldr.w	r2, [fp, #4]
	while (count_user--) {
 100709c:	1e5c      	subs	r4, r3, #1
	users = &instance->users[0];
 100709e:	9201      	str	r2, [sp, #4]
	while (count_user--) {
 10070a0:	b2e4      	uxtb	r4, r4
 10070a2:	2b00      	cmp	r3, #0
 10070a4:	f47f af7f 	bne.w	1006fa6 <ticker_job+0xc7a>
 10070a8:	e752      	b.n	1006f50 <ticker_job+0xc24>
		if (cntr_stop() == 0) {
 10070aa:	f00a fcf7 	bl	1011a9c <cntr_stop>
 10070ae:	2800      	cmp	r0, #0
 10070b0:	f47f af55 	bne.w	1006f5e <ticker_job+0xc32>
			instance->ticks_slot_previous = 0U;
 10070b4:	f8cb 0018 	str.w	r0, [fp, #24]
			instance->ticks_current = cntr_cnt_get();
 10070b8:	f00a fd0a 	bl	1011ad0 <cntr_cnt_get>
 10070bc:	f89b 201f 	ldrb.w	r2, [fp, #31]
 10070c0:	f8cb 0014 	str.w	r0, [fp, #20]
 10070c4:	e74d      	b.n	1006f62 <ticker_job+0xc36>
	count_user = instance->count_user;
 10070c6:	f89b 3009 	ldrb.w	r3, [fp, #9]
	users = &instance->users[0];
 10070ca:	f8db 1004 	ldr.w	r1, [fp, #4]
	while (count_user--) {
 10070ce:	1e5c      	subs	r4, r3, #1
	users = &instance->users[0];
 10070d0:	9101      	str	r1, [sp, #4]
	while (count_user--) {
 10070d2:	b2e4      	uxtb	r4, r4
 10070d4:	b18b      	cbz	r3, 10070fa <ticker_job+0xdce>
			flag_compare_update = 1U;
 10070d6:	9207      	str	r2, [sp, #28]
 10070d8:	e765      	b.n	1006fa6 <ticker_job+0xc7a>
 10070da:	f89b a01d 	ldrb.w	sl, [fp, #29]
 10070de:	e42d      	b.n	100693c <ticker_job+0x610>
		ticks_current = cntr_cnt_get();
 10070e0:	f00a fcf6 	bl	1011ad0 <cntr_cnt_get>
 10070e4:	4604      	mov	r4, r0
		if (cntr_start() == 0) {
 10070e6:	f00a fcc9 	bl	1011a7c <cntr_start>
 10070ea:	f89b a01d 	ldrb.w	sl, [fp, #29]
 10070ee:	2800      	cmp	r0, #0
 10070f0:	f47f ac2c 	bne.w	100694c <ticker_job+0x620>
			instance->ticks_current = ticks_current;
 10070f4:	f8cb 4014 	str.w	r4, [fp, #20]
 10070f8:	e428      	b.n	100694c <ticker_job+0x620>
	instance->job_guard = 0U;
 10070fa:	9b08      	ldr	r3, [sp, #32]
 10070fc:	f88b 301e 	strb.w	r3, [fp, #30]
	if (flag_compare_update) {
 1007100:	e41c      	b.n	100693c <ticker_job+0x610>
 1007102:	bf00      	nop
 1007104:	ff172b5a 	.word	0xff172b5a
 1007108:	7f172b59 	.word	0x7f172b59

0100710c <ticker_init>:
{
 100710c:	b4f0      	push	{r4, r5, r6, r7}
 100710e:	9f04      	ldr	r7, [sp, #16]
 1007110:	f89d 5014 	ldrb.w	r5, [sp, #20]
 1007114:	9e06      	ldr	r6, [sp, #24]
	if (instance_index >= TICKER_INSTANCE_MAX) {
 1007116:	2800      	cmp	r0, #0
 1007118:	d13c      	bne.n	1007194 <ticker_init+0x88>
	instance->count_node = count_node;
 100711a:	f8df c080 	ldr.w	ip, [pc, #128]	; 100719c <ticker_init+0x90>
	while (count_node--) {
 100711e:	1e4c      	subs	r4, r1, #1
	instance->count_node = count_node;
 1007120:	f88c 1008 	strb.w	r1, [ip, #8]
	instance->nodes = node;
 1007124:	f8cc 2000 	str.w	r2, [ip]
	while (count_node--) {
 1007128:	b2e4      	uxtb	r4, r4
 100712a:	b149      	cbz	r1, 1007140 <ticker_init+0x34>
 100712c:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 1007130:	eb02 1104 	add.w	r1, r2, r4, lsl #4
 1007134:	4291      	cmp	r1, r2
		instance->nodes[count_node].priority = 0;
 1007136:	f881 002d 	strb.w	r0, [r1, #45]	; 0x2d
	while (count_node--) {
 100713a:	f1a1 0130 	sub.w	r1, r1, #48	; 0x30
 100713e:	d1f9      	bne.n	1007134 <ticker_init+0x28>
	while (count_user--) {
 1007140:	1e5a      	subs	r2, r3, #1
	instance->count_user = count_user;
 1007142:	f88c 3009 	strb.w	r3, [ip, #9]
	instance->users = user;
 1007146:	f8cc 7004 	str.w	r7, [ip, #4]
	while (count_user--) {
 100714a:	b2d2      	uxtb	r2, r2
 100714c:	b16b      	cbz	r3, 100716a <ticker_init+0x5e>
		user_op_ += users[count_user].count_user_op;
 100714e:	2034      	movs	r0, #52	; 0x34
 1007150:	eb07 03c2 	add.w	r3, r7, r2, lsl #3
		users[count_user].user_op = user_op_;
 1007154:	4619      	mov	r1, r3
 1007156:	605e      	str	r6, [r3, #4]
		user_op_ += users[count_user].count_user_op;
 1007158:	f813 2908 	ldrb.w	r2, [r3], #-8
	while (count_user--) {
 100715c:	428f      	cmp	r7, r1
		count_op -= users[count_user].count_user_op;
 100715e:	eba5 0502 	sub.w	r5, r5, r2
		user_op_ += users[count_user].count_user_op;
 1007162:	fb00 6602 	mla	r6, r0, r2, r6
		count_op -= users[count_user].count_user_op;
 1007166:	b2ed      	uxtb	r5, r5
	while (count_user--) {
 1007168:	d1f4      	bne.n	1007154 <ticker_init+0x48>
	if (count_op) {
 100716a:	b99d      	cbnz	r5, 1007194 <ticker_init+0x88>
	instance->ticker_id_slot_previous = TICKER_NULL;
 100716c:	f64f 73ff 	movw	r3, #65535	; 0xffff
	instance->caller_id_get_cb = caller_id_get_cb;
 1007170:	9a07      	ldr	r2, [sp, #28]
	return TICKER_STATUS_SUCCESS;
 1007172:	4628      	mov	r0, r5
	instance->caller_id_get_cb = caller_id_get_cb;
 1007174:	f8cc 2020 	str.w	r2, [ip, #32]
	instance->sched_cb = sched_cb;
 1007178:	9a08      	ldr	r2, [sp, #32]
	instance->ticks_slot_previous = 0U;
 100717a:	e9cc 5505 	strd	r5, r5, [ip, #20]
	instance->sched_cb = sched_cb;
 100717e:	f8cc 2024 	str.w	r2, [ip, #36]	; 0x24
	instance->trigger_set_cb = trigger_set_cb;
 1007182:	9a09      	ldr	r2, [sp, #36]	; 0x24
	instance->ticks_elapsed_first = 0U;
 1007184:	f8ac 500a 	strh.w	r5, [ip, #10]
	instance->trigger_set_cb = trigger_set_cb;
 1007188:	f8cc 2028 	str.w	r2, [ip, #40]	; 0x28
	instance->ticker_id_slot_previous = TICKER_NULL;
 100718c:	f8ac 301c 	strh.w	r3, [ip, #28]
}
 1007190:	bcf0      	pop	{r4, r5, r6, r7}
 1007192:	4770      	bx	lr
		return TICKER_STATUS_FAILURE;
 1007194:	2001      	movs	r0, #1
}
 1007196:	bcf0      	pop	{r4, r5, r6, r7}
 1007198:	4770      	bx	lr
 100719a:	bf00      	nop
 100719c:	21000b9c 	.word	0x21000b9c

010071a0 <ticker_trigger>:
	if (instance->sched_cb) {
 10071a0:	222c      	movs	r2, #44	; 0x2c
 10071a2:	4b07      	ldr	r3, [pc, #28]	; (10071c0 <ticker_trigger+0x20>)
{
 10071a4:	b410      	push	{r4}
	if (instance->sched_cb) {
 10071a6:	fb02 3300 	mla	r3, r2, r0, r3
 10071aa:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 10071ac:	b12c      	cbz	r4, 10071ba <ticker_trigger+0x1a>
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
 10071ae:	46a4      	mov	ip, r4
 10071b0:	2201      	movs	r2, #1
 10071b2:	2103      	movs	r1, #3
 10071b4:	2002      	movs	r0, #2
}
 10071b6:	bc10      	pop	{r4}
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
 10071b8:	4760      	bx	ip
}
 10071ba:	bc10      	pop	{r4}
 10071bc:	4770      	bx	lr
 10071be:	bf00      	nop
 10071c0:	21000b9c 	.word	0x21000b9c

010071c4 <ticker_start_ext>:
{
 10071c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct ticker_instance *instance = &_instance[instance_index];
 10071c8:	262c      	movs	r6, #44	; 0x2c
{
 10071ca:	460c      	mov	r4, r1
	struct ticker_instance *instance = &_instance[instance_index];
 10071cc:	4923      	ldr	r1, [pc, #140]	; (100725c <ticker_start_ext+0x98>)
 10071ce:	fb06 1600 	mla	r6, r6, r0, r1
	user = &instance->users[user_id];
 10071d2:	6871      	ldr	r1, [r6, #4]
 10071d4:	eb01 07c4 	add.w	r7, r1, r4, lsl #3
	last = user->last + 1;
 10071d8:	78f8      	ldrb	r0, [r7, #3]
	if (last >= user->count_user_op) {
 10071da:	f811 1034 	ldrb.w	r1, [r1, r4, lsl #3]
	last = user->last + 1;
 10071de:	1c45      	adds	r5, r0, #1
 10071e0:	b2ed      	uxtb	r5, r5
		last = 0U;
 10071e2:	42a9      	cmp	r1, r5
 10071e4:	bf98      	it	ls
 10071e6:	2500      	movls	r5, #0
	if (last == user->first) {
 10071e8:	f897 c001 	ldrb.w	ip, [r7, #1]
{
 10071ec:	f8bd 102c 	ldrh.w	r1, [sp, #44]	; 0x2c
	if (last == user->first) {
 10071f0:	45ac      	cmp	ip, r5
 10071f2:	d030      	beq.n	1007256 <ticker_start_ext+0x92>
	user_op = &user->user_op[user->last];
 10071f4:	f04f 0c34 	mov.w	ip, #52	; 0x34
	user_op->op = TICKER_USER_OP_TYPE_START;
 10071f8:	f04f 0804 	mov.w	r8, #4
	user_op->status = TICKER_STATUS_BUSY;
 10071fc:	f04f 0e02 	mov.w	lr, #2
	user_op = &user->user_op[user->last];
 1007200:	fb0c fc00 	mul.w	ip, ip, r0
 1007204:	f8d7 9004 	ldr.w	r9, [r7, #4]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
 1007208:	4620      	mov	r0, r4
	user_op = &user->user_op[user->last];
 100720a:	eb09 040c 	add.w	r4, r9, ip
	user_op->op = TICKER_USER_OP_TYPE_START;
 100720e:	f809 800c 	strb.w	r8, [r9, ip]
	user_op->params.start.ticks_at_start = ticks_anchor;
 1007212:	6063      	str	r3, [r4, #4]
	user_op->params.start.ticks_first = ticks_first;
 1007214:	9b08      	ldr	r3, [sp, #32]
	user_op->id = ticker_id;
 1007216:	7062      	strb	r2, [r4, #1]
	user_op->params.start.ticks_first = ticks_first;
 1007218:	60a3      	str	r3, [r4, #8]
	user_op->params.start.ticks_periodic = ticks_periodic;
 100721a:	9b09      	ldr	r3, [sp, #36]	; 0x24
	user_op->params.start.lazy = lazy;
 100721c:	82a1      	strh	r1, [r4, #20]
	user_op->params.start.ticks_periodic = ticks_periodic;
 100721e:	60e3      	str	r3, [r4, #12]
	user_op->params.start.remainder_periodic = remainder_periodic;
 1007220:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	user_op->status = TICKER_STATUS_BUSY;
 1007222:	f8c4 e028 	str.w	lr, [r4, #40]	; 0x28
	user_op->params.start.remainder_periodic = remainder_periodic;
 1007226:	6123      	str	r3, [r4, #16]
	user_op->params.start.ticks_slot = ticks_slot;
 1007228:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 100722a:	61a3      	str	r3, [r4, #24]
	user_op->params.start.ext_data = ext_data;
 100722c:	9b11      	ldr	r3, [sp, #68]	; 0x44
 100722e:	6263      	str	r3, [r4, #36]	; 0x24
	user_op->params.start.fp_timeout_func = fp_timeout_func;
 1007230:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 1007232:	61e3      	str	r3, [r4, #28]
	user_op->params.start.context = context;
 1007234:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 1007236:	6223      	str	r3, [r4, #32]
	user_op->fp_op_func = fp_op_func;
 1007238:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 100723a:	62e3      	str	r3, [r4, #44]	; 0x2c
	user_op->op_context = op_context;
 100723c:	9b10      	ldr	r3, [sp, #64]	; 0x40
 100723e:	6323      	str	r3, [r4, #48]	; 0x30
	user->last = last;
 1007240:	70fd      	strb	r5, [r7, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
 1007242:	e9d6 3508 	ldrd	r3, r5, [r6, #32]
 1007246:	4798      	blx	r3
 1007248:	4633      	mov	r3, r6
 100724a:	4641      	mov	r1, r8
 100724c:	2200      	movs	r2, #0
 100724e:	47a8      	blx	r5
	return user_op->status;
 1007250:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
 1007252:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return TICKER_STATUS_FAILURE;
 1007256:	2001      	movs	r0, #1
}
 1007258:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 100725c:	21000b9c 	.word	0x21000b9c

01007260 <ticker_start>:
{
 1007260:	b530      	push	{r4, r5, lr}
	return ticker_start_ext(instance_index, user_id, ticker_id,
 1007262:	2500      	movs	r5, #0
{
 1007264:	b08b      	sub	sp, #44	; 0x2c
 1007266:	9c0e      	ldr	r4, [sp, #56]	; 0x38
	return ticker_start_ext(instance_index, user_id, ticker_id,
 1007268:	9509      	str	r5, [sp, #36]	; 0x24
 100726a:	9400      	str	r4, [sp, #0]
{
 100726c:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 100726e:	9c10      	ldr	r4, [sp, #64]	; 0x40
	return ticker_start_ext(instance_index, user_id, ticker_id,
 1007270:	9501      	str	r5, [sp, #4]
 1007272:	9402      	str	r4, [sp, #8]
{
 1007274:	f8bd 5044 	ldrh.w	r5, [sp, #68]	; 0x44
 1007278:	9c12      	ldr	r4, [sp, #72]	; 0x48
	return ticker_start_ext(instance_index, user_id, ticker_id,
 100727a:	9503      	str	r5, [sp, #12]
 100727c:	9404      	str	r4, [sp, #16]
{
 100727e:	9d13      	ldr	r5, [sp, #76]	; 0x4c
 1007280:	9c14      	ldr	r4, [sp, #80]	; 0x50
	return ticker_start_ext(instance_index, user_id, ticker_id,
 1007282:	9505      	str	r5, [sp, #20]
 1007284:	9406      	str	r4, [sp, #24]
{
 1007286:	9d15      	ldr	r5, [sp, #84]	; 0x54
 1007288:	9c16      	ldr	r4, [sp, #88]	; 0x58
	return ticker_start_ext(instance_index, user_id, ticker_id,
 100728a:	e9cd 5407 	strd	r5, r4, [sp, #28]
 100728e:	f7ff ff99 	bl	10071c4 <ticker_start_ext>
}
 1007292:	b00b      	add	sp, #44	; 0x2c
 1007294:	bd30      	pop	{r4, r5, pc}
 1007296:	bf00      	nop

01007298 <ticker_update>:
{
 1007298:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	struct ticker_instance *instance = &_instance[instance_index];
 100729c:	262c      	movs	r6, #44	; 0x2c
 100729e:	4c22      	ldr	r4, [pc, #136]	; (1007328 <ticker_update+0x90>)
{
 10072a0:	f8bd 802c 	ldrh.w	r8, [sp, #44]	; 0x2c
	struct ticker_instance *instance = &_instance[instance_index];
 10072a4:	fb06 4600 	mla	r6, r6, r0, r4
	user = &instance->users[user_id];
 10072a8:	6870      	ldr	r0, [r6, #4]
{
 10072aa:	f89d e030 	ldrb.w	lr, [sp, #48]	; 0x30
	user = &instance->users[user_id];
 10072ae:	eb00 07c1 	add.w	r7, r0, r1, lsl #3
	last = user->last + 1;
 10072b2:	f897 c003 	ldrb.w	ip, [r7, #3]
	if (last >= user->count_user_op) {
 10072b6:	f810 0031 	ldrb.w	r0, [r0, r1, lsl #3]
	last = user->last + 1;
 10072ba:	f10c 0501 	add.w	r5, ip, #1
 10072be:	b2ed      	uxtb	r5, r5
		last = 0U;
 10072c0:	42a8      	cmp	r0, r5
 10072c2:	bf98      	it	ls
 10072c4:	2500      	movls	r5, #0
	if (last == user->first) {
 10072c6:	7878      	ldrb	r0, [r7, #1]
 10072c8:	42a8      	cmp	r0, r5
 10072ca:	d029      	beq.n	1007320 <ticker_update+0x88>
	user_op = &user->user_op[user->last];
 10072cc:	2434      	movs	r4, #52	; 0x34
	user_op->op = TICKER_USER_OP_TYPE_UPDATE;
 10072ce:	f04f 0a05 	mov.w	sl, #5
	user_op->status = TICKER_STATUS_BUSY;
 10072d2:	f04f 0902 	mov.w	r9, #2
	user_op = &user->user_op[user->last];
 10072d6:	fb04 f40c 	mul.w	r4, r4, ip
 10072da:	f8d7 c004 	ldr.w	ip, [r7, #4]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
 10072de:	4608      	mov	r0, r1
	user_op->op = TICKER_USER_OP_TYPE_UPDATE;
 10072e0:	f80c a004 	strb.w	sl, [ip, r4]
	user_op = &user->user_op[user->last];
 10072e4:	4464      	add	r4, ip
	user_op->params.update.ticks_drift_plus = ticks_drift_plus;
 10072e6:	6063      	str	r3, [r4, #4]
	user_op->params.update.ticks_drift_minus = ticks_drift_minus;
 10072e8:	9b08      	ldr	r3, [sp, #32]
	user_op->id = ticker_id;
 10072ea:	7062      	strb	r2, [r4, #1]
	user_op->params.update.ticks_drift_minus = ticks_drift_minus;
 10072ec:	60a3      	str	r3, [r4, #8]
	user_op->params.update.ticks_slot_plus = ticks_slot_plus;
 10072ee:	9b09      	ldr	r3, [sp, #36]	; 0x24
	user_op->params.update.force = force;
 10072f0:	f884 e016 	strb.w	lr, [r4, #22]
	user_op->params.update.ticks_slot_plus = ticks_slot_plus;
 10072f4:	60e3      	str	r3, [r4, #12]
	user_op->params.update.ticks_slot_minus = ticks_slot_minus;
 10072f6:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	user_op->params.update.lazy = lazy;
 10072f8:	f8a4 8014 	strh.w	r8, [r4, #20]
	user_op->params.update.ticks_slot_minus = ticks_slot_minus;
 10072fc:	6123      	str	r3, [r4, #16]
	user_op->fp_op_func = fp_op_func;
 10072fe:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	user_op->status = TICKER_STATUS_BUSY;
 1007300:	f8c4 9028 	str.w	r9, [r4, #40]	; 0x28
	user_op->fp_op_func = fp_op_func;
 1007304:	62e3      	str	r3, [r4, #44]	; 0x2c
	user_op->op_context = op_context;
 1007306:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 1007308:	6323      	str	r3, [r4, #48]	; 0x30
	user->last = last;
 100730a:	70fd      	strb	r5, [r7, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
 100730c:	e9d6 3508 	ldrd	r3, r5, [r6, #32]
 1007310:	4798      	blx	r3
 1007312:	4633      	mov	r3, r6
 1007314:	2200      	movs	r2, #0
 1007316:	2104      	movs	r1, #4
 1007318:	47a8      	blx	r5
	return user_op->status;
 100731a:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
 100731c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return TICKER_STATUS_FAILURE;
 1007320:	2001      	movs	r0, #1
}
 1007322:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 1007326:	bf00      	nop
 1007328:	21000b9c 	.word	0x21000b9c

0100732c <ticker_stop>:
{
 100732c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct ticker_instance *instance = &_instance[instance_index];
 1007330:	272c      	movs	r7, #44	; 0x2c
 1007332:	4c1a      	ldr	r4, [pc, #104]	; (100739c <ticker_stop+0x70>)
 1007334:	fb07 4700 	mla	r7, r7, r0, r4
	user = &instance->users[user_id];
 1007338:	687c      	ldr	r4, [r7, #4]
 100733a:	eb04 0cc1 	add.w	ip, r4, r1, lsl #3
	last = user->last + 1;
 100733e:	f89c 6003 	ldrb.w	r6, [ip, #3]
	if (last >= user->count_user_op) {
 1007342:	f814 0031 	ldrb.w	r0, [r4, r1, lsl #3]
	last = user->last + 1;
 1007346:	1c74      	adds	r4, r6, #1
 1007348:	b2e4      	uxtb	r4, r4
		last = 0U;
 100734a:	42a0      	cmp	r0, r4
 100734c:	bf98      	it	ls
 100734e:	2400      	movls	r4, #0
	if (last == user->first) {
 1007350:	f89c 0001 	ldrb.w	r0, [ip, #1]
 1007354:	42a0      	cmp	r0, r4
 1007356:	d01e      	beq.n	1007396 <ticker_stop+0x6a>
	user_op = &user->user_op[user->last];
 1007358:	2534      	movs	r5, #52	; 0x34
	user_op->op = TICKER_USER_OP_TYPE_STOP;
 100735a:	f04f 0806 	mov.w	r8, #6
	user_op->status = TICKER_STATUS_BUSY;
 100735e:	f04f 0e02 	mov.w	lr, #2
	user_op = &user->user_op[user->last];
 1007362:	fb05 f506 	mul.w	r5, r5, r6
 1007366:	f8dc 6004 	ldr.w	r6, [ip, #4]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
 100736a:	4608      	mov	r0, r1
	user_op->op = TICKER_USER_OP_TYPE_STOP;
 100736c:	f806 8005 	strb.w	r8, [r6, r5]
	user_op = &user->user_op[user->last];
 1007370:	4435      	add	r5, r6
	user_op->fp_op_func = fp_op_func;
 1007372:	62eb      	str	r3, [r5, #44]	; 0x2c
	user_op->op_context = op_context;
 1007374:	9b06      	ldr	r3, [sp, #24]
	user_op->id = ticker_id;
 1007376:	706a      	strb	r2, [r5, #1]
	user_op->op_context = op_context;
 1007378:	632b      	str	r3, [r5, #48]	; 0x30
	user_op->status = TICKER_STATUS_BUSY;
 100737a:	f8c5 e028 	str.w	lr, [r5, #40]	; 0x28
	user->last = last;
 100737e:	f88c 4003 	strb.w	r4, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
 1007382:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
 1007386:	4798      	blx	r3
 1007388:	463b      	mov	r3, r7
 100738a:	2200      	movs	r2, #0
 100738c:	2104      	movs	r1, #4
 100738e:	47a0      	blx	r4
	return user_op->status;
 1007390:	6aa8      	ldr	r0, [r5, #40]	; 0x28
}
 1007392:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TICKER_STATUS_FAILURE;
 1007396:	2001      	movs	r0, #1
}
 1007398:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 100739c:	21000b9c 	.word	0x21000b9c

010073a0 <ticker_ticks_now_get>:
	return cntr_cnt_get();
 10073a0:	f00a bb96 	b.w	1011ad0 <cntr_cnt_get>

010073a4 <ticker_ticks_diff_get>:
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 10073a4:	1a40      	subs	r0, r0, r1
}
 10073a6:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 10073aa:	4770      	bx	lr

010073ac <ll_addr_get>:
static u8_t pub_addr[BDADDR_SIZE];
static u8_t rnd_addr[BDADDR_SIZE];

u8_t *ll_addr_get(u8_t addr_type, u8_t *bdaddr)
{
	if (addr_type > 1) {
 10073ac:	2801      	cmp	r0, #1
 10073ae:	d813      	bhi.n	10073d8 <ll_addr_get+0x2c>
{
 10073b0:	b508      	push	{r3, lr}
		return NULL;
	}

	if (addr_type) {
 10073b2:	b948      	cbnz	r0, 10073c8 <ll_addr_get+0x1c>
		}

		return rnd_addr;
	}

	if (bdaddr) {
 10073b4:	b131      	cbz	r1, 10073c4 <ll_addr_get+0x18>
		memcpy(bdaddr, pub_addr, BDADDR_SIZE);
 10073b6:	4608      	mov	r0, r1
 10073b8:	2206      	movs	r2, #6
 10073ba:	4909      	ldr	r1, [pc, #36]	; (10073e0 <ll_addr_get+0x34>)
 10073bc:	f00f fb2c 	bl	1016a18 <memcpy>
	}

	return pub_addr;
 10073c0:	4807      	ldr	r0, [pc, #28]	; (10073e0 <ll_addr_get+0x34>)
}
 10073c2:	bd08      	pop	{r3, pc}
	return pub_addr;
 10073c4:	4806      	ldr	r0, [pc, #24]	; (10073e0 <ll_addr_get+0x34>)
}
 10073c6:	bd08      	pop	{r3, pc}
		if (bdaddr) {
 10073c8:	b141      	cbz	r1, 10073dc <ll_addr_get+0x30>
			memcpy(bdaddr, rnd_addr, BDADDR_SIZE);
 10073ca:	4608      	mov	r0, r1
 10073cc:	2206      	movs	r2, #6
 10073ce:	4905      	ldr	r1, [pc, #20]	; (10073e4 <ll_addr_get+0x38>)
 10073d0:	f00f fb22 	bl	1016a18 <memcpy>
		return rnd_addr;
 10073d4:	4803      	ldr	r0, [pc, #12]	; (10073e4 <ll_addr_get+0x38>)
}
 10073d6:	bd08      	pop	{r3, pc}
		return NULL;
 10073d8:	2000      	movs	r0, #0
}
 10073da:	4770      	bx	lr
		return rnd_addr;
 10073dc:	4801      	ldr	r0, [pc, #4]	; (10073e4 <ll_addr_get+0x38>)
}
 10073de:	bd08      	pop	{r3, pc}
 10073e0:	21000bc8 	.word	0x21000bc8
 10073e4:	21000bd0 	.word	0x21000bd0

010073e8 <ll_addr_set>:

u32_t ll_addr_set(u8_t addr_type, u8_t const *const bdaddr)
{
 10073e8:	b570      	push	{r4, r5, r6, lr}
 10073ea:	4606      	mov	r6, r0
	if (IS_ENABLED(CONFIG_BT_BROADCASTER) &&
	    ull_adv_is_enabled(0)) {
 10073ec:	2000      	movs	r0, #0
{
 10073ee:	460d      	mov	r5, r1
	    ull_adv_is_enabled(0)) {
 10073f0:	f003 fc7a 	bl	100ace8 <ull_adv_is_enabled>
	if (IS_ENABLED(CONFIG_BT_BROADCASTER) &&
 10073f4:	b988      	cbnz	r0, 100741a <ll_addr_set+0x32>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	if (IS_ENABLED(CONFIG_BT_OBSERVER) &&
	    (ull_scan_is_enabled(0) & (BIT(1) | BIT(2)))) {
 10073f6:	f003 fdc5 	bl	100af84 <ull_scan_is_enabled>
	if (IS_ENABLED(CONFIG_BT_OBSERVER) &&
 10073fa:	f010 0406 	ands.w	r4, r0, #6
 10073fe:	d10c      	bne.n	100741a <ll_addr_set+0x32>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	if (addr_type) {
		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
 1007400:	4629      	mov	r1, r5
 1007402:	2206      	movs	r2, #6
	if (addr_type) {
 1007404:	b926      	cbnz	r6, 1007410 <ll_addr_set+0x28>
	} else {
		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
 1007406:	4806      	ldr	r0, [pc, #24]	; (1007420 <ll_addr_set+0x38>)
 1007408:	f00f fb06 	bl	1016a18 <memcpy>
	}

	return 0;
}
 100740c:	4620      	mov	r0, r4
 100740e:	bd70      	pop	{r4, r5, r6, pc}
		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
 1007410:	4804      	ldr	r0, [pc, #16]	; (1007424 <ll_addr_set+0x3c>)
 1007412:	f00f fb01 	bl	1016a18 <memcpy>
}
 1007416:	4620      	mov	r0, r4
 1007418:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100741a:	240c      	movs	r4, #12
}
 100741c:	4620      	mov	r0, r4
 100741e:	bd70      	pop	{r4, r5, r6, pc}
 1007420:	21000bc8 	.word	0x21000bc8
 1007424:	21000bd0 	.word	0x21000bd0

01007428 <ll_tx_pwr_lvl_get>:
#include "ull_conn_internal.h"

u8_t ll_tx_pwr_lvl_get(u8_t handle_type,
		       u16_t handle, u8_t type, s8_t *tx_pwr_lvl)
{
	switch (handle_type) {
 1007428:	2802      	cmp	r0, #2
 100742a:	d001      	beq.n	1007430 <ll_tx_pwr_lvl_get+0x8>
			}
			break;
		}
#endif /* CONFIG_BT_CONN */
		default: {
			return BT_HCI_ERR_UNKNOWN_CMD;
 100742c:	2001      	movs	r0, #1
		}
	}

	return BT_HCI_ERR_SUCCESS;
}
 100742e:	4770      	bx	lr
{
 1007430:	b538      	push	{r3, r4, r5, lr}
 1007432:	4604      	mov	r4, r0
			conn = ll_connected_get(handle);
 1007434:	4608      	mov	r0, r1
 1007436:	461d      	mov	r5, r3
 1007438:	f004 f94c 	bl	100b6d4 <ll_connected_get>
			if (!conn) {
 100743c:	b110      	cbz	r0, 1007444 <ll_tx_pwr_lvl_get+0x1c>
				*tx_pwr_lvl = RADIO_TXP_DEFAULT;
 100743e:	2000      	movs	r0, #0
 1007440:	7028      	strb	r0, [r5, #0]
}
 1007442:	bd38      	pop	{r3, r4, r5, pc}
				return BT_HCI_ERR_UNKNOWN_CONN_ID;
 1007444:	4620      	mov	r0, r4
}
 1007446:	bd38      	pop	{r3, r4, r5, pc}

01007448 <ll_tx_pwr_get>:
{
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	*min = lll_radio_tx_pwr_min_get();
	*max = lll_radio_tx_pwr_max_get();
#else
	*min = RADIO_TXP_DEFAULT;
 1007448:	2300      	movs	r3, #0
 100744a:	7003      	strb	r3, [r0, #0]
	*max = RADIO_TXP_DEFAULT;
 100744c:	700b      	strb	r3, [r1, #0]
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */
}
 100744e:	4770      	bx	lr

01007450 <hci_driver_init>:
	.open	= hci_driver_open,
	.send	= hci_driver_send,
};

static int hci_driver_init(struct device *unused)
{
 1007450:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	bt_hci_driver_register(&drv);
 1007452:	4802      	ldr	r0, [pc, #8]	; (100745c <hci_driver_init+0xc>)
 1007454:	f7fe fa0c 	bl	1005870 <bt_hci_driver_register>

	return 0;
}
 1007458:	2000      	movs	r0, #0
 100745a:	bd08      	pop	{r3, pc}
 100745c:	010186d4 	.word	0x010186d4

01007460 <prio_recv_thread>:
{
 1007460:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return z_impl_k_sem_take(sem, timeout);
 1007464:	f8df 80b4 	ldr.w	r8, [pc, #180]	; 100751c <prio_recv_thread+0xbc>
				k_fifo_put(&recv_fifo, node_rx);
 1007468:	4f2b      	ldr	r7, [pc, #172]	; (1007518 <prio_recv_thread+0xb8>)
{
 100746a:	b082      	sub	sp, #8
 100746c:	e012      	b.n	1007494 <prio_recv_thread+0x34>
			buf = bt_buf_get_evt(BT_HCI_EVT_NUM_COMPLETED_PACKETS,
 100746e:	f04f 33ff 	mov.w	r3, #4294967295
 1007472:	f04f 32ff 	mov.w	r2, #4294967295
 1007476:	2100      	movs	r1, #0
 1007478:	2013      	movs	r0, #19
 100747a:	f00f fb65 	bl	1016b48 <bt_buf_get_evt>
			hci_num_cmplt_encode(buf, handle, num_cmplt);
 100747e:	4622      	mov	r2, r4
			buf = bt_buf_get_evt(BT_HCI_EVT_NUM_COMPLETED_PACKETS,
 1007480:	4604      	mov	r4, r0
			hci_num_cmplt_encode(buf, handle, num_cmplt);
 1007482:	f8bd 1002 	ldrh.w	r1, [sp, #2]
 1007486:	f001 fec9 	bl	100921c <hci_num_cmplt_encode>
			bt_recv_prio(buf);
 100748a:	4620      	mov	r0, r4
 100748c:	f00f fb5f 	bl	1016b4e <bt_recv_prio>
	z_impl_k_yield();
 1007490:	f00d f918 	bl	10146c4 <z_impl_k_yield>
		while ((num_cmplt = ll_rx_get((void *)&node_rx, &handle))) {
 1007494:	f10d 0102 	add.w	r1, sp, #2
 1007498:	a801      	add	r0, sp, #4
 100749a:	f002 fbcd 	bl	1009c38 <ll_rx_get>
 100749e:	4604      	mov	r4, r0
 10074a0:	2800      	cmp	r0, #0
 10074a2:	d1e4      	bne.n	100746e <prio_recv_thread+0xe>
		if (node_rx) {
 10074a4:	9b01      	ldr	r3, [sp, #4]
 10074a6:	b193      	cbz	r3, 10074ce <prio_recv_thread+0x6e>
			ll_rx_dequeue();
 10074a8:	f002 fc92 	bl	1009dd0 <ll_rx_dequeue>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
 10074ac:	9e01      	ldr	r6, [sp, #4]
 10074ae:	4630      	mov	r0, r6
 10074b0:	f001 fecc 	bl	100924c <hci_get_class>
			buf = process_prio_evt(node_rx, &evt_flags);
 10074b4:	9d01      	ldr	r5, [sp, #4]
			node_rx->hdr.user_meta = hci_get_class(node_rx);
 10074b6:	7170      	strb	r0, [r6, #5]
	if (node_rx->hdr.user_meta == HCI_CLASS_EVT_CONNECTION) {
 10074b8:	796b      	ldrb	r3, [r5, #5]
 10074ba:	2b03      	cmp	r3, #3
 10074bc:	d102      	bne.n	10074c4 <prio_recv_thread+0x64>
		if (node_rx->hdr.type == NODE_RX_TYPE_TERMINATE) {
 10074be:	792b      	ldrb	r3, [r5, #4]
 10074c0:	2b09      	cmp	r3, #9
 10074c2:	d00c      	beq.n	10074de <prio_recv_thread+0x7e>
				k_fifo_put(&recv_fifo, node_rx);
 10074c4:	4629      	mov	r1, r5
 10074c6:	4638      	mov	r0, r7
 10074c8:	f010 fa3d 	bl	1017946 <k_queue_append>
			continue;
 10074cc:	e7e2      	b.n	1007494 <prio_recv_thread+0x34>
	return z_impl_k_sem_take(sem, timeout);
 10074ce:	f04f 32ff 	mov.w	r2, #4294967295
 10074d2:	f04f 33ff 	mov.w	r3, #4294967295
 10074d6:	4640      	mov	r0, r8
 10074d8:	f00d f98c 	bl	10147f4 <z_impl_k_sem_take>
		while ((num_cmplt = ll_rx_get((void *)&node_rx, &handle))) {
 10074dc:	e7da      	b.n	1007494 <prio_recv_thread+0x34>
			buf = bt_buf_get_evt(BT_HCI_EVT_DISCONN_COMPLETE, false,
 10074de:	4621      	mov	r1, r4
 10074e0:	f04f 32ff 	mov.w	r2, #4294967295
 10074e4:	f04f 33ff 	mov.w	r3, #4294967295
 10074e8:	2005      	movs	r0, #5
		handle = node_rx->hdr.handle;
 10074ea:	88ee      	ldrh	r6, [r5, #6]
			buf = bt_buf_get_evt(BT_HCI_EVT_DISCONN_COMPLETE, false,
 10074ec:	f00f fb2c 	bl	1016b48 <bt_buf_get_evt>
 10074f0:	4604      	mov	r4, r0
			hci_disconn_complete_encode(pdu_data, handle, buf);
 10074f2:	4631      	mov	r1, r6
 10074f4:	f105 0020 	add.w	r0, r5, #32
 10074f8:	4622      	mov	r2, r4
 10074fa:	f001 f9bb 	bl	1008874 <hci_disconn_complete_encode>
			hci_disconn_complete_process(handle);
 10074fe:	4630      	mov	r0, r6
 1007500:	f001 f9ca 	bl	1008898 <hci_disconn_complete_process>
			if (buf) {
 1007504:	b12c      	cbz	r4, 1007512 <prio_recv_thread+0xb2>
				bt_recv_prio(buf);
 1007506:	4620      	mov	r0, r4
 1007508:	f00f fb21 	bl	1016b4e <bt_recv_prio>
					net_buf_unref(buf);
 100750c:	4620      	mov	r0, r4
 100750e:	f00b facd 	bl	1012aac <net_buf_unref>
 1007512:	9d01      	ldr	r5, [sp, #4]
 1007514:	e7d6      	b.n	10074c4 <prio_recv_thread+0x64>
 1007516:	bf00      	nop
 1007518:	21000624 	.word	0x21000624
 100751c:	210005c8 	.word	0x210005c8

01007520 <hci_driver_send>:
{
 1007520:	b530      	push	{r4, r5, lr}
	if (!buf->len) {
 1007522:	8983      	ldrh	r3, [r0, #12]
{
 1007524:	b083      	sub	sp, #12
	if (!buf->len) {
 1007526:	2b00      	cmp	r3, #0
 1007528:	d03a      	beq.n	10075a0 <hci_driver_send+0x80>
 100752a:	7d03      	ldrb	r3, [r0, #20]
	switch (type) {
 100752c:	4604      	mov	r4, r0
 100752e:	b31b      	cbz	r3, 1007578 <hci_driver_send+0x58>
 1007530:	2b02      	cmp	r3, #2
 1007532:	d00f      	beq.n	1007554 <hci_driver_send+0x34>
 1007534:	4821      	ldr	r0, [pc, #132]	; (10075bc <hci_driver_send+0x9c>)
 1007536:	4a22      	ldr	r2, [pc, #136]	; (10075c0 <hci_driver_send+0xa0>)
		BT_ERR("Unknown HCI type %u", type);
 1007538:	4619      	mov	r1, r3
 100753a:	1a12      	subs	r2, r2, r0
 100753c:	08d2      	lsrs	r2, r2, #3
 100753e:	0192      	lsls	r2, r2, #6
 1007540:	4820      	ldr	r0, [pc, #128]	; (10075c4 <hci_driver_send+0xa4>)
 1007542:	f042 0201 	orr.w	r2, r2, #1
 1007546:	f00d ffdf 	bl	1015508 <log_1>
		return -EINVAL;
 100754a:	f06f 0515 	mvn.w	r5, #21
}
 100754e:	4628      	mov	r0, r5
 1007550:	b003      	add	sp, #12
 1007552:	bd30      	pop	{r4, r5, pc}
	err = hci_acl_handle(buf, &evt);
 1007554:	a901      	add	r1, sp, #4
 1007556:	f001 f8f5 	bl	1008744 <hci_acl_handle>
	if (evt) {
 100755a:	9b01      	ldr	r3, [sp, #4]
	err = hci_acl_handle(buf, &evt);
 100755c:	4605      	mov	r5, r0
	if (evt) {
 100755e:	b113      	cbz	r3, 1007566 <hci_driver_send+0x46>
		bt_recv_prio(evt);
 1007560:	4618      	mov	r0, r3
 1007562:	f00f faf4 	bl	1016b4e <bt_recv_prio>
	if (!err) {
 1007566:	2d00      	cmp	r5, #0
 1007568:	d1f1      	bne.n	100754e <hci_driver_send+0x2e>
		net_buf_unref(buf);
 100756a:	2500      	movs	r5, #0
 100756c:	4620      	mov	r0, r4
 100756e:	f00b fa9d 	bl	1012aac <net_buf_unref>
}
 1007572:	4628      	mov	r0, r5
 1007574:	b003      	add	sp, #12
 1007576:	bd30      	pop	{r4, r5, pc}
	evt = hci_cmd_handle(buf, (void **) &node_rx);
 1007578:	a901      	add	r1, sp, #4
	struct node_rx_pdu *node_rx = NULL;
 100757a:	9301      	str	r3, [sp, #4]
	evt = hci_cmd_handle(buf, (void **) &node_rx);
 100757c:	f000 fbd4 	bl	1007d28 <hci_cmd_handle>
	if (evt) {
 1007580:	2800      	cmp	r0, #0
 1007582:	d0f2      	beq.n	100756a <hci_driver_send+0x4a>
		bt_recv_prio(evt);
 1007584:	f00f fae3 	bl	1016b4e <bt_recv_prio>
		if (node_rx) {
 1007588:	9d01      	ldr	r5, [sp, #4]
 100758a:	2d00      	cmp	r5, #0
 100758c:	d0ed      	beq.n	100756a <hci_driver_send+0x4a>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
 100758e:	4628      	mov	r0, r5
 1007590:	f001 fe5c 	bl	100924c <hci_get_class>
 1007594:	7168      	strb	r0, [r5, #5]
			k_fifo_put(&recv_fifo, node_rx);
 1007596:	9901      	ldr	r1, [sp, #4]
 1007598:	480b      	ldr	r0, [pc, #44]	; (10075c8 <hci_driver_send+0xa8>)
 100759a:	f010 f9d4 	bl	1017946 <k_queue_append>
	if (!err) {
 100759e:	e7e4      	b.n	100756a <hci_driver_send+0x4a>
 10075a0:	4b06      	ldr	r3, [pc, #24]	; (10075bc <hci_driver_send+0x9c>)
 10075a2:	4907      	ldr	r1, [pc, #28]	; (10075c0 <hci_driver_send+0xa0>)
		BT_ERR("Empty HCI packet");
 10075a4:	4809      	ldr	r0, [pc, #36]	; (10075cc <hci_driver_send+0xac>)
 10075a6:	1ac9      	subs	r1, r1, r3
 10075a8:	08c9      	lsrs	r1, r1, #3
 10075aa:	0189      	lsls	r1, r1, #6
 10075ac:	f041 0101 	orr.w	r1, r1, #1
 10075b0:	f00d ff9d 	bl	10154ee <log_0>
		return -EINVAL;
 10075b4:	f06f 0515 	mvn.w	r5, #21
 10075b8:	e7c9      	b.n	100754e <hci_driver_send+0x2e>
 10075ba:	bf00      	nop
 10075bc:	01018208 	.word	0x01018208
 10075c0:	01018238 	.word	0x01018238
 10075c4:	0101862c 	.word	0x0101862c
 10075c8:	21000624 	.word	0x21000624
 10075cc:	01018618 	.word	0x01018618

010075d0 <hci_driver_open>:
{
 10075d0:	b5d0      	push	{r4, r6, r7, lr}
	err = ll_init(&sem_prio_recv);
 10075d2:	4822      	ldr	r0, [pc, #136]	; (100765c <hci_driver_open+0x8c>)
{
 10075d4:	b088      	sub	sp, #32
	err = ll_init(&sem_prio_recv);
 10075d6:	f002 f885 	bl	10096e4 <ll_init>
	if (err) {
 10075da:	4604      	mov	r4, r0
 10075dc:	2800      	cmp	r0, #0
 10075de:	d12f      	bne.n	1007640 <hci_driver_open+0x70>
	hci_init(&hbuf_signal);
 10075e0:	481f      	ldr	r0, [pc, #124]	; (1007660 <hci_driver_open+0x90>)
 10075e2:	f001 fe4b 	bl	100927c <hci_init>
	k_thread_create(&prio_recv_thread_data, prio_recv_thread_stack,
 10075e6:	2600      	movs	r6, #0
 10075e8:	2700      	movs	r7, #0
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 10075ea:	f06f 0309 	mvn.w	r3, #9
 10075ee:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
 10075f2:	9303      	str	r3, [sp, #12]
 10075f4:	e9cd 6706 	strd	r6, r7, [sp, #24]
 10075f8:	e9cd 4401 	strd	r4, r4, [sp, #4]
 10075fc:	4b19      	ldr	r3, [pc, #100]	; (1007664 <hci_driver_open+0x94>)
 10075fe:	491a      	ldr	r1, [pc, #104]	; (1007668 <hci_driver_open+0x98>)
 1007600:	9404      	str	r4, [sp, #16]
 1007602:	9400      	str	r4, [sp, #0]
 1007604:	4819      	ldr	r0, [pc, #100]	; (100766c <hci_driver_open+0x9c>)
 1007606:	f00d f95d 	bl	10148c4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
 100760a:	4919      	ldr	r1, [pc, #100]	; (1007670 <hci_driver_open+0xa0>)
 100760c:	4817      	ldr	r0, [pc, #92]	; (100766c <hci_driver_open+0x9c>)
 100760e:	f010 fb1e 	bl	1017c4e <z_impl_k_thread_name_set>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 1007612:	f06f 0307 	mvn.w	r3, #7
 1007616:	f44f 7200 	mov.w	r2, #512	; 0x200
 100761a:	9303      	str	r3, [sp, #12]
 100761c:	e9cd 6706 	strd	r6, r7, [sp, #24]
 1007620:	e9cd 4401 	strd	r4, r4, [sp, #4]
 1007624:	4b13      	ldr	r3, [pc, #76]	; (1007674 <hci_driver_open+0xa4>)
 1007626:	4914      	ldr	r1, [pc, #80]	; (1007678 <hci_driver_open+0xa8>)
 1007628:	9404      	str	r4, [sp, #16]
 100762a:	9400      	str	r4, [sp, #0]
 100762c:	4813      	ldr	r0, [pc, #76]	; (100767c <hci_driver_open+0xac>)
 100762e:	f00d f949 	bl	10148c4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
 1007632:	4913      	ldr	r1, [pc, #76]	; (1007680 <hci_driver_open+0xb0>)
 1007634:	4811      	ldr	r0, [pc, #68]	; (100767c <hci_driver_open+0xac>)
 1007636:	f010 fb0a 	bl	1017c4e <z_impl_k_thread_name_set>
}
 100763a:	4620      	mov	r0, r4
 100763c:	b008      	add	sp, #32
 100763e:	bdd0      	pop	{r4, r6, r7, pc}
 1007640:	4b10      	ldr	r3, [pc, #64]	; (1007684 <hci_driver_open+0xb4>)
 1007642:	4a11      	ldr	r2, [pc, #68]	; (1007688 <hci_driver_open+0xb8>)
		BT_ERR("LL initialization failed: %d", err);
 1007644:	4601      	mov	r1, r0
 1007646:	1ad2      	subs	r2, r2, r3
 1007648:	08d2      	lsrs	r2, r2, #3
 100764a:	0192      	lsls	r2, r2, #6
 100764c:	480f      	ldr	r0, [pc, #60]	; (100768c <hci_driver_open+0xbc>)
 100764e:	f042 0201 	orr.w	r2, r2, #1
 1007652:	f00d ff59 	bl	1015508 <log_1>
}
 1007656:	4620      	mov	r0, r4
 1007658:	b008      	add	sp, #32
 100765a:	bdd0      	pop	{r4, r6, r7, pc}
 100765c:	210005c8 	.word	0x210005c8
 1007660:	210000a0 	.word	0x210000a0
 1007664:	01007461 	.word	0x01007461
 1007668:	21008c28 	.word	0x21008c28
 100766c:	21000be4 	.word	0x21000be4
 1007670:	01018660 	.word	0x01018660
 1007674:	01007691 	.word	0x01007691
 1007678:	21008de8 	.word	0x21008de8
 100767c:	21000c58 	.word	0x21000c58
 1007680:	0101866c 	.word	0x0101866c
 1007684:	01018208 	.word	0x01018208
 1007688:	01018238 	.word	0x01018238
 100768c:	01018640 	.word	0x01018640

01007690 <recv_thread>:
{
 1007690:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1007694:	4cb0      	ldr	r4, [pc, #704]	; (1007958 <recv_thread+0x2c8>)
 1007696:	4fb1      	ldr	r7, [pc, #708]	; (100795c <recv_thread+0x2cc>)
 1007698:	f8df 92d4 	ldr.w	r9, [pc, #724]	; 1007970 <recv_thread+0x2e0>
 100769c:	f8df 82d4 	ldr.w	r8, [pc, #724]	; 1007974 <recv_thread+0x2e4>
		LL_ASSERT(err == 0);
 10076a0:	f8df a2d4 	ldr.w	sl, [pc, #724]	; 1007978 <recv_thread+0x2e8>
{
 10076a4:	b085      	sub	sp, #20
		parm0.val = timeout;
		return (int) arch_syscall_invoke4(*(uintptr_t *)&events, *(uintptr_t *)&num_events, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll(events, num_events, timeout);
 10076a6:	f04f 32ff 	mov.w	r2, #4294967295
 10076aa:	f04f 33ff 	mov.w	r3, #4294967295
 10076ae:	2102      	movs	r1, #2
 10076b0:	48a9      	ldr	r0, [pc, #676]	; (1007958 <recv_thread+0x2c8>)
 10076b2:	f00d fb91 	bl	1014dd8 <z_impl_k_poll>
		LL_ASSERT(err == 0);
 10076b6:	2800      	cmp	r0, #0
 10076b8:	f040 809c 	bne.w	10077f4 <recv_thread+0x164>
		if (events[0].state == K_POLL_STATE_SIGNALED) {
 10076bc:	68e3      	ldr	r3, [r4, #12]
 10076be:	f403 33f8 	and.w	r3, r3, #126976	; 0x1f000
 10076c2:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 10076c6:	f000 8090 	beq.w	10077ea <recv_thread+0x15a>
		} else if (events[1].state ==
 10076ca:	6a23      	ldr	r3, [r4, #32]
 10076cc:	f403 33f8 	and.w	r3, r3, #126976	; 0x1f000
 10076d0:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 10076d4:	f000 80db 	beq.w	100788e <recv_thread+0x1fe>
		struct node_rx_pdu *node_rx = NULL;
 10076d8:	2500      	movs	r5, #0
		events[0].state = K_POLL_STATE_NOT_READY;
 10076da:	68e2      	ldr	r2, [r4, #12]
		events[1].state = K_POLL_STATE_NOT_READY;
 10076dc:	6a23      	ldr	r3, [r4, #32]
	s32_t hbuf_total = hci_hbuf_total;
 10076de:	49a0      	ldr	r1, [pc, #640]	; (1007960 <recv_thread+0x2d0>)
		events[0].state = K_POLL_STATE_NOT_READY;
 10076e0:	f36f 3210 	bfc	r2, #12, #5
	s32_t hbuf_total = hci_hbuf_total;
 10076e4:	f8d1 b000 	ldr.w	fp, [r1]
		events[1].state = K_POLL_STATE_NOT_READY;
 10076e8:	f36f 3310 	bfc	r3, #12, #5
		events[0].state = K_POLL_STATE_NOT_READY;
 10076ec:	60e2      	str	r2, [r4, #12]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 10076ee:	4a9d      	ldr	r2, [pc, #628]	; (1007964 <recv_thread+0x2d4>)
		events[1].state = K_POLL_STATE_NOT_READY;
 10076f0:	6223      	str	r3, [r4, #32]
 10076f2:	e8d2 3fef 	ldaex	r3, [r2]
 10076f6:	f023 0101 	bic.w	r1, r3, #1
 10076fa:	e8c2 1fe0 	stlex	r0, r1, [r2]
 10076fe:	2800      	cmp	r0, #0
 1007700:	d1f7      	bne.n	10076f2 <recv_thread+0x62>
	if (reset) {
 1007702:	07db      	lsls	r3, r3, #31
	list->head = NULL;
 1007704:	bf44      	itt	mi
 1007706:	2300      	movmi	r3, #0
	list->tail = NULL;
 1007708:	e9c7 3300 	strdmi	r3, r3, [r7]
	if (hbuf_total <= 0) {
 100770c:	f1bb 0f00 	cmp.w	fp, #0
 1007710:	f340 80c4 	ble.w	100789c <recv_thread+0x20c>
	hbuf_count = hbuf_total - (hci_hbuf_sent - hci_hbuf_acked);
 1007714:	f8d9 3000 	ldr.w	r3, [r9]
 1007718:	f8d8 2000 	ldr.w	r2, [r8]
 100771c:	ebab 0303 	sub.w	r3, fp, r3
 1007720:	4413      	add	r3, r2
	node_rx = (void *)sys_slist_peek_head(&hbuf_pend);
 1007722:	683e      	ldr	r6, [r7, #0]
	hbuf_count = hbuf_total - (hci_hbuf_sent - hci_hbuf_acked);
 1007724:	4a90      	ldr	r2, [pc, #576]	; (1007968 <recv_thread+0x2d8>)
 1007726:	6013      	str	r3, [r2, #0]
	if (!node_rx) {
 1007728:	2e00      	cmp	r6, #0
 100772a:	f000 80e1 	beq.w	10078f0 <recv_thread+0x260>
	class = node_rx->hdr.user_meta;
 100772e:	7972      	ldrb	r2, [r6, #5]
	if (n) {
 1007730:	2d00      	cmp	r5, #0
 1007732:	d168      	bne.n	1007806 <recv_thread+0x176>
	switch (class) {
 1007734:	2a04      	cmp	r2, #4
 1007736:	d839      	bhi.n	10077ac <recv_thread+0x11c>
 1007738:	2a02      	cmp	r2, #2
 100773a:	f200 8090 	bhi.w	100785e <recv_thread+0x1ce>
		LL_ASSERT(0);
 100773e:	f44f 71a1 	mov.w	r1, #322	; 0x142
 1007742:	4650      	mov	r0, sl
 1007744:	9201      	str	r2, [sp, #4]
 1007746:	f7fb ff9b 	bl	1003680 <bt_ctlr_assert_handle>
	switch (class) {
 100774a:	9a01      	ldr	r2, [sp, #4]
 100774c:	9603      	str	r6, [sp, #12]
 100774e:	2a00      	cmp	r2, #0
 1007750:	f040 808b 	bne.w	100786a <recv_thread+0x1da>
		LL_ASSERT(0);
 1007754:	21d4      	movs	r1, #212	; 0xd4
 1007756:	4650      	mov	r0, sl
 1007758:	f7fb ff92 	bl	1003680 <bt_ctlr_assert_handle>
	node_rx->hdr.next = NULL;
 100775c:	2200      	movs	r2, #0
 100775e:	9b03      	ldr	r3, [sp, #12]
	ll_rx_mem_release((void **)&node_rx);
 1007760:	a803      	add	r0, sp, #12
	node_rx->hdr.next = NULL;
 1007762:	601a      	str	r2, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
 1007764:	f002 fbc8 	bl	1009ef8 <ll_rx_mem_release>
		hbuf_count = hbuf_total - (hci_hbuf_sent - hci_hbuf_acked);
 1007768:	f8d9 3000 	ldr.w	r3, [r9]
 100776c:	f8d8 1000 	ldr.w	r1, [r8]
 1007770:	ebab 0303 	sub.w	r3, fp, r3
 1007774:	440b      	add	r3, r1
		node_rx = (void *)sys_slist_peek_head(&hbuf_pend);
 1007776:	683a      	ldr	r2, [r7, #0]
		hbuf_count = hbuf_total - (hci_hbuf_sent - hci_hbuf_acked);
 1007778:	497b      	ldr	r1, [pc, #492]	; (1007968 <recv_thread+0x2d8>)
 100777a:	600b      	str	r3, [r1, #0]
		if (node_rx) {
 100777c:	b12a      	cbz	r2, 100778a <recv_thread+0xfa>
			class = node_rx->hdr.user_meta;
 100777e:	7952      	ldrb	r2, [r2, #5]
			if (class == HCI_CLASS_EVT_CONNECTION ||
 1007780:	1ed1      	subs	r1, r2, #3
 1007782:	2901      	cmp	r1, #1
 1007784:	d90d      	bls.n	10077a2 <recv_thread+0x112>
			    class == HCI_CLASS_EVT_LLCP ||
 1007786:	2a05      	cmp	r2, #5
 1007788:	d009      	beq.n	100779e <recv_thread+0x10e>
		if (buf) {
 100778a:	b12d      	cbz	r5, 1007798 <recv_thread+0x108>
			if (buf->len) {
 100778c:	89ab      	ldrh	r3, [r5, #12]
				bt_recv(buf);
 100778e:	4628      	mov	r0, r5
			if (buf->len) {
 1007790:	2b00      	cmp	r3, #0
 1007792:	d035      	beq.n	1007800 <recv_thread+0x170>
				bt_recv(buf);
 1007794:	f7fe f8e2 	bl	100595c <bt_recv>
	z_impl_k_yield();
 1007798:	f00c ff94 	bl	10146c4 <z_impl_k_yield>
	while (1) {
 100779c:	e783      	b.n	10076a6 <recv_thread+0x16>
			    (class == HCI_CLASS_ACL_DATA && hbuf_count)) {
 100779e:	2b00      	cmp	r3, #0
 10077a0:	d0f3      	beq.n	100778a <recv_thread+0xfa>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&signal, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(signal, result);
 10077a2:	2100      	movs	r1, #0
 10077a4:	4871      	ldr	r0, [pc, #452]	; (100796c <recv_thread+0x2dc>)
 10077a6:	f00d fb77 	bl	1014e98 <z_impl_k_poll_signal_raise>
 10077aa:	e7ee      	b.n	100778a <recv_thread+0xfa>
	switch (class) {
 10077ac:	2a05      	cmp	r2, #5
 10077ae:	d115      	bne.n	10077dc <recv_thread+0x14c>
		if (hbuf_count) {
 10077b0:	2b00      	cmp	r3, #0
 10077b2:	d0f1      	beq.n	1007798 <recv_thread+0x108>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 10077b4:	687a      	ldr	r2, [r7, #4]
 10077b6:	6833      	ldr	r3, [r6, #0]
 10077b8:	4296      	cmp	r6, r2
	list->head = node;
 10077ba:	603b      	str	r3, [r7, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 10077bc:	f000 80b6 	beq.w	100792c <recv_thread+0x29c>
		buf = bt_buf_get_rx(BT_BUF_ACL_IN, K_FOREVER);
 10077c0:	f04f 32ff 	mov.w	r2, #4294967295
 10077c4:	f04f 33ff 	mov.w	r3, #4294967295
 10077c8:	2003      	movs	r0, #3
 10077ca:	9603      	str	r6, [sp, #12]
 10077cc:	f7fe f862 	bl	1005894 <bt_buf_get_rx>
 10077d0:	4605      	mov	r5, r0
		hci_acl_encode(node_rx, buf);
 10077d2:	9803      	ldr	r0, [sp, #12]
 10077d4:	4629      	mov	r1, r5
 10077d6:	f001 f881 	bl	10088dc <hci_acl_encode>
		break;
 10077da:	e7bf      	b.n	100775c <recv_thread+0xcc>
		LL_ASSERT(0);
 10077dc:	f44f 71a1 	mov.w	r1, #322	; 0x142
 10077e0:	4650      	mov	r0, sl
 10077e2:	f7fb ff4d 	bl	1003680 <bt_ctlr_assert_handle>
		buf = encode_node(node_rx, class);
 10077e6:	9603      	str	r6, [sp, #12]
	switch (class) {
 10077e8:	e7b4      	b.n	1007754 <recv_thread+0xc4>
			events[0].signal->signaled = 0U;
 10077ea:	2300      	movs	r3, #0
 10077ec:	6922      	ldr	r2, [r4, #16]
		struct node_rx_pdu *node_rx = NULL;
 10077ee:	461d      	mov	r5, r3
			events[0].signal->signaled = 0U;
 10077f0:	6093      	str	r3, [r2, #8]
 10077f2:	e772      	b.n	10076da <recv_thread+0x4a>
		LL_ASSERT(err == 0);
 10077f4:	f44f 71bd 	mov.w	r1, #378	; 0x17a
 10077f8:	4650      	mov	r0, sl
 10077fa:	f7fb ff41 	bl	1003680 <bt_ctlr_assert_handle>
 10077fe:	e75d      	b.n	10076bc <recv_thread+0x2c>
				net_buf_unref(buf);
 1007800:	f00b f954 	bl	1012aac <net_buf_unref>
 1007804:	e7c8      	b.n	1007798 <recv_thread+0x108>
		if (class == HCI_CLASS_EVT_CONNECTION ||
 1007806:	1ed1      	subs	r1, r2, #3
 1007808:	2901      	cmp	r1, #1
 100780a:	d961      	bls.n	10078d0 <recv_thread+0x240>
		    class == HCI_CLASS_EVT_LLCP ||
 100780c:	2a05      	cmp	r2, #5
 100780e:	d072      	beq.n	10078f6 <recv_thread+0x266>
	if (hbuf_count != -1) {
 1007810:	3301      	adds	r3, #1
	u8_t class = node_rx->hdr.user_meta;
 1007812:	796a      	ldrb	r2, [r5, #5]
	if (hbuf_count != -1) {
 1007814:	d04a      	beq.n	10078ac <recv_thread+0x21c>
 1007816:	683e      	ldr	r6, [r7, #0]
		switch (class) {
 1007818:	2a04      	cmp	r2, #4
 100781a:	d860      	bhi.n	10078de <recv_thread+0x24e>
 100781c:	2a02      	cmp	r2, #2
 100781e:	f200 808d 	bhi.w	100793c <recv_thread+0x2ac>
 1007822:	1e53      	subs	r3, r2, #1
 1007824:	2b01      	cmp	r3, #1
 1007826:	f200 8083 	bhi.w	1007930 <recv_thread+0x2a0>
	buf = encode_node(node_rx, class);
 100782a:	9503      	str	r5, [sp, #12]
		if (class == HCI_CLASS_EVT_DISCARDABLE) {
 100782c:	2a02      	cmp	r2, #2
 100782e:	f000 80ab 	beq.w	1007988 <recv_thread+0x2f8>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 1007832:	f04f 32ff 	mov.w	r2, #4294967295
 1007836:	f04f 33ff 	mov.w	r3, #4294967295
 100783a:	2001      	movs	r0, #1
 100783c:	f7fe f82a 	bl	1005894 <bt_buf_get_rx>
 1007840:	4605      	mov	r5, r0
		if (buf) {
 1007842:	2d00      	cmp	r5, #0
 1007844:	f000 809a 	beq.w	100797c <recv_thread+0x2ec>
			hci_evt_encode(node_rx, buf);
 1007848:	4629      	mov	r1, r5
 100784a:	9803      	ldr	r0, [sp, #12]
 100784c:	f001 f8a0 	bl	1008990 <hci_evt_encode>
	node_rx->hdr.next = NULL;
 1007850:	2200      	movs	r2, #0
 1007852:	9b03      	ldr	r3, [sp, #12]
	ll_rx_mem_release((void **)&node_rx);
 1007854:	a803      	add	r0, sp, #12
	node_rx->hdr.next = NULL;
 1007856:	601a      	str	r2, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
 1007858:	f002 fb4e 	bl	1009ef8 <ll_rx_mem_release>
	return buf;
 100785c:	e795      	b.n	100778a <recv_thread+0xfa>
 100785e:	6879      	ldr	r1, [r7, #4]
 1007860:	6833      	ldr	r3, [r6, #0]
 1007862:	428e      	cmp	r6, r1
	list->head = node;
 1007864:	603b      	str	r3, [r7, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 1007866:	d052      	beq.n	100790e <recv_thread+0x27e>
		buf = encode_node(node_rx, class);
 1007868:	9603      	str	r6, [sp, #12]
		if (class == HCI_CLASS_EVT_DISCARDABLE) {
 100786a:	2a02      	cmp	r2, #2
 100786c:	d047      	beq.n	10078fe <recv_thread+0x26e>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 100786e:	f04f 32ff 	mov.w	r2, #4294967295
 1007872:	f04f 33ff 	mov.w	r3, #4294967295
 1007876:	2001      	movs	r0, #1
 1007878:	f7fe f80c 	bl	1005894 <bt_buf_get_rx>
 100787c:	4605      	mov	r5, r0
		if (buf) {
 100787e:	2d00      	cmp	r5, #0
 1007880:	f43f af6c 	beq.w	100775c <recv_thread+0xcc>
			hci_evt_encode(node_rx, buf);
 1007884:	4629      	mov	r1, r5
 1007886:	9803      	ldr	r0, [sp, #12]
 1007888:	f001 f882 	bl	1008990 <hci_evt_encode>
 100788c:	e766      	b.n	100775c <recv_thread+0xcc>
			node_rx = k_fifo_get(events[1].fifo, K_NO_WAIT);
 100788e:	6a60      	ldr	r0, [r4, #36]	; 0x24
	return z_impl_k_queue_get(queue, timeout);
 1007890:	2200      	movs	r2, #0
 1007892:	2300      	movs	r3, #0
 1007894:	f00c fc52 	bl	101413c <z_impl_k_queue_get>
 1007898:	4605      	mov	r5, r0
 100789a:	e71e      	b.n	10076da <recv_thread+0x4a>
		hbuf_count = -1;
 100789c:	f04f 33ff 	mov.w	r3, #4294967295
 10078a0:	4a31      	ldr	r2, [pc, #196]	; (1007968 <recv_thread+0x2d8>)
 10078a2:	6013      	str	r3, [r2, #0]
		if (node_rx && !buf) {
 10078a4:	2d00      	cmp	r5, #0
 10078a6:	f43f af77 	beq.w	1007798 <recv_thread+0x108>
	u8_t class = node_rx->hdr.user_meta;
 10078aa:	796a      	ldrb	r2, [r5, #5]
	switch (class) {
 10078ac:	2a04      	cmp	r2, #4
 10078ae:	9503      	str	r5, [sp, #12]
 10078b0:	d92f      	bls.n	1007912 <recv_thread+0x282>
 10078b2:	2a05      	cmp	r2, #5
 10078b4:	d12f      	bne.n	1007916 <recv_thread+0x286>
		buf = bt_buf_get_rx(BT_BUF_ACL_IN, K_FOREVER);
 10078b6:	f04f 32ff 	mov.w	r2, #4294967295
 10078ba:	f04f 33ff 	mov.w	r3, #4294967295
 10078be:	2003      	movs	r0, #3
 10078c0:	f7fd ffe8 	bl	1005894 <bt_buf_get_rx>
 10078c4:	4605      	mov	r5, r0
		hci_acl_encode(node_rx, buf);
 10078c6:	9803      	ldr	r0, [sp, #12]
 10078c8:	4629      	mov	r1, r5
 10078ca:	f001 f807 	bl	10088dc <hci_acl_encode>
		break;
 10078ce:	e7bf      	b.n	1007850 <recv_thread+0x1c0>
	return z_impl_k_poll_signal_raise(signal, result);
 10078d0:	2100      	movs	r1, #0
 10078d2:	4826      	ldr	r0, [pc, #152]	; (100796c <recv_thread+0x2dc>)
 10078d4:	f00d fae0 	bl	1014e98 <z_impl_k_poll_signal_raise>
		if (node_rx && !buf) {
 10078d8:	4b23      	ldr	r3, [pc, #140]	; (1007968 <recv_thread+0x2d8>)
 10078da:	681b      	ldr	r3, [r3, #0]
 10078dc:	e798      	b.n	1007810 <recv_thread+0x180>
		switch (class) {
 10078de:	2a05      	cmp	r2, #5
 10078e0:	d126      	bne.n	1007930 <recv_thread+0x2a0>
			if (pend || !hbuf_count) {
 10078e2:	2e00      	cmp	r6, #0
 10078e4:	d130      	bne.n	1007948 <recv_thread+0x2b8>
 10078e6:	4b20      	ldr	r3, [pc, #128]	; (1007968 <recv_thread+0x2d8>)
 10078e8:	681b      	ldr	r3, [r3, #0]
 10078ea:	b36b      	cbz	r3, 1007948 <recv_thread+0x2b8>
	buf = encode_node(node_rx, class);
 10078ec:	9503      	str	r5, [sp, #12]
	switch (class) {
 10078ee:	e7e2      	b.n	10078b6 <recv_thread+0x226>
		if (node_rx && !buf) {
 10078f0:	2d00      	cmp	r5, #0
 10078f2:	d18d      	bne.n	1007810 <recv_thread+0x180>
 10078f4:	e750      	b.n	1007798 <recv_thread+0x108>
		    (class == HCI_CLASS_ACL_DATA && hbuf_count)) {
 10078f6:	2b00      	cmp	r3, #0
 10078f8:	d1ea      	bne.n	10078d0 <recv_thread+0x240>
	u8_t class = node_rx->hdr.user_meta;
 10078fa:	796a      	ldrb	r2, [r5, #5]
	if (hbuf_count != -1) {
 10078fc:	e78c      	b.n	1007818 <recv_thread+0x188>
			buf = bt_buf_get_evt(BT_HCI_EVT_UNKNOWN, true,
 10078fe:	2200      	movs	r2, #0
 1007900:	2300      	movs	r3, #0
 1007902:	2101      	movs	r1, #1
 1007904:	2000      	movs	r0, #0
 1007906:	f00f f91f 	bl	1016b48 <bt_buf_get_evt>
 100790a:	4605      	mov	r5, r0
 100790c:	e7b7      	b.n	100787e <recv_thread+0x1ee>
	list->tail = node;
 100790e:	607b      	str	r3, [r7, #4]
}
 1007910:	e7aa      	b.n	1007868 <recv_thread+0x1d8>
	switch (class) {
 1007912:	2a00      	cmp	r2, #0
 1007914:	d18a      	bne.n	100782c <recv_thread+0x19c>
		LL_ASSERT(0);
 1007916:	4650      	mov	r0, sl
 1007918:	21d4      	movs	r1, #212	; 0xd4
 100791a:	f7fb feb1 	bl	1003680 <bt_ctlr_assert_handle>
	node_rx->hdr.next = NULL;
 100791e:	2200      	movs	r2, #0
 1007920:	9b03      	ldr	r3, [sp, #12]
	ll_rx_mem_release((void **)&node_rx);
 1007922:	a803      	add	r0, sp, #12
	node_rx->hdr.next = NULL;
 1007924:	601a      	str	r2, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
 1007926:	f002 fae7 	bl	1009ef8 <ll_rx_mem_release>
		if (buf) {
 100792a:	e735      	b.n	1007798 <recv_thread+0x108>
	list->tail = node;
 100792c:	607b      	str	r3, [r7, #4]
}
 100792e:	e747      	b.n	10077c0 <recv_thread+0x130>
			LL_ASSERT(0);
 1007930:	21f9      	movs	r1, #249	; 0xf9
 1007932:	4650      	mov	r0, sl
 1007934:	f7fb fea4 	bl	1003680 <bt_ctlr_assert_handle>
	buf = encode_node(node_rx, class);
 1007938:	9503      	str	r5, [sp, #12]
	switch (class) {
 100793a:	e7ec      	b.n	1007916 <recv_thread+0x286>
			hbuf_count = 1;
 100793c:	2301      	movs	r3, #1
 100793e:	4a0a      	ldr	r2, [pc, #40]	; (1007968 <recv_thread+0x2d8>)
 1007940:	6013      	str	r3, [r2, #0]
			if (pend || !hbuf_count) {
 1007942:	b90e      	cbnz	r6, 1007948 <recv_thread+0x2b8>
	buf = encode_node(node_rx, class);
 1007944:	9503      	str	r5, [sp, #12]
		if (class == HCI_CLASS_EVT_DISCARDABLE) {
 1007946:	e774      	b.n	1007832 <recv_thread+0x1a2>
	parent->next = child;
 1007948:	2200      	movs	r2, #0
Z_GENLIST_APPEND(slist, snode)
 100794a:	687b      	ldr	r3, [r7, #4]
	parent->next = child;
 100794c:	602a      	str	r2, [r5, #0]
Z_GENLIST_APPEND(slist, snode)
 100794e:	b31b      	cbz	r3, 1007998 <recv_thread+0x308>
	parent->next = child;
 1007950:	601d      	str	r5, [r3, #0]
	list->tail = node;
 1007952:	607d      	str	r5, [r7, #4]
		if (buf) {
 1007954:	e720      	b.n	1007798 <recv_thread+0x108>
 1007956:	bf00      	nop
 1007958:	21000078 	.word	0x21000078
 100795c:	21000bdc 	.word	0x21000bdc
 1007960:	21000d84 	.word	0x21000d84
 1007964:	21000d88 	.word	0x21000d88
 1007968:	21000bd8 	.word	0x21000bd8
 100796c:	210000a0 	.word	0x210000a0
 1007970:	21000d80 	.word	0x21000d80
 1007974:	21000d5c 	.word	0x21000d5c
 1007978:	01018674 	.word	0x01018674
	node_rx->hdr.next = NULL;
 100797c:	9b03      	ldr	r3, [sp, #12]
	ll_rx_mem_release((void **)&node_rx);
 100797e:	a803      	add	r0, sp, #12
	node_rx->hdr.next = NULL;
 1007980:	601d      	str	r5, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
 1007982:	f002 fab9 	bl	1009ef8 <ll_rx_mem_release>
		if (buf) {
 1007986:	e707      	b.n	1007798 <recv_thread+0x108>
			buf = bt_buf_get_evt(BT_HCI_EVT_UNKNOWN, true,
 1007988:	2200      	movs	r2, #0
 100798a:	2300      	movs	r3, #0
 100798c:	2101      	movs	r1, #1
 100798e:	2000      	movs	r0, #0
 1007990:	f00f f8da 	bl	1016b48 <bt_buf_get_evt>
 1007994:	4605      	mov	r5, r0
 1007996:	e754      	b.n	1007842 <recv_thread+0x1b2>
	list->head = node;
 1007998:	e9c7 5500 	strd	r5, r5, [r7]
		if (buf) {
 100799c:	e6fc      	b.n	1007798 <recv_thread+0x108>
 100799e:	bf00      	nop

010079a0 <meta_evt>:
{
	return bt_hci_cmd_status_create(_opcode, status);
}

static void *meta_evt(struct net_buf *buf, u8_t subevt, u8_t melen)
{
 10079a0:	b570      	push	{r4, r5, r6, lr}
	hdr = net_buf_add(buf, sizeof(*hdr));
 10079a2:	f100 0408 	add.w	r4, r0, #8
{
 10079a6:	4615      	mov	r5, r2
 10079a8:	460e      	mov	r6, r1
	hdr = net_buf_add(buf, sizeof(*hdr));
 10079aa:	4620      	mov	r0, r4
 10079ac:	2102      	movs	r1, #2
 10079ae:	f00f f941 	bl	1016c34 <net_buf_simple_add>
	hdr->evt = evt;
 10079b2:	223e      	movs	r2, #62	; 0x3e
	struct bt_hci_evt_le_meta_event *me;

	hci_evt_create(buf, BT_HCI_EVT_LE_META_EVENT, sizeof(*me) + melen);
 10079b4:	1c6b      	adds	r3, r5, #1
	me = net_buf_add(buf, sizeof(*me));
 10079b6:	2101      	movs	r1, #1
	hdr->evt = evt;
 10079b8:	7002      	strb	r2, [r0, #0]
	hdr->len = len;
 10079ba:	7043      	strb	r3, [r0, #1]
	me = net_buf_add(buf, sizeof(*me));
 10079bc:	4620      	mov	r0, r4
 10079be:	f00f f939 	bl	1016c34 <net_buf_simple_add>
	me->subevent = subevt;
 10079c2:	7006      	strb	r6, [r0, #0]

	return net_buf_add(buf, melen);
 10079c4:	4629      	mov	r1, r5
 10079c6:	4620      	mov	r0, r4
}
 10079c8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return net_buf_add(buf, melen);
 10079cc:	f00f b932 	b.w	1016c34 <net_buf_simple_add>

010079d0 <le_remote_feat_complete>:
}
#endif /* CONFIG_BT_CTLR_LE_ENC */

static void le_remote_feat_complete(u8_t status, struct pdu_data *pdu_data,
				    u16_t handle, struct net_buf *buf)
{
 10079d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct bt_hci_evt_le_remote_feat_complete *sep;

	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 10079d4:	f04f 0900 	mov.w	r9, #0
 10079d8:	464c      	mov	r4, r9
 10079da:	4f16      	ldr	r7, [pc, #88]	; (1007a34 <le_remote_feat_complete+0x64>)
{
 10079dc:	4606      	mov	r6, r0
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 10079de:	6878      	ldr	r0, [r7, #4]
{
 10079e0:	4617      	mov	r7, r2
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 10079e2:	f000 5500 	and.w	r5, r0, #536870912	; 0x20000000
 10079e6:	ea54 0205 	orrs.w	r2, r4, r5
 10079ea:	d008      	beq.n	10079fe <le_remote_feat_complete+0x2e>
 10079ec:	4688      	mov	r8, r1
	    !(le_event_mask & BT_EVT_MASK_LE_REMOTE_FEAT_COMPLETE)) {
 10079ee:	4649      	mov	r1, r9
 10079f0:	4a11      	ldr	r2, [pc, #68]	; (1007a38 <le_remote_feat_complete+0x68>)
 10079f2:	6812      	ldr	r2, [r2, #0]
 10079f4:	f002 0008 	and.w	r0, r2, #8
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 10079f8:	ea50 0201 	orrs.w	r2, r0, r1
 10079fc:	d101      	bne.n	1007a02 <le_remote_feat_complete+0x32>
		       &pdu_data->llctrl.feature_rsp.features[0],
		       sizeof(sep->features));
	} else {
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
	}
}
 10079fe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	sep = meta_evt(buf, BT_HCI_EV_LE_REMOTE_FEAT_COMPLETE, sizeof(*sep));
 1007a02:	4618      	mov	r0, r3
 1007a04:	220b      	movs	r2, #11
 1007a06:	2104      	movs	r1, #4
 1007a08:	f7ff ffca 	bl	10079a0 <meta_evt>
	sep->status = status;
 1007a0c:	7006      	strb	r6, [r0, #0]
	sep->handle = sys_cpu_to_le16(handle);
 1007a0e:	f8a0 7001 	strh.w	r7, [r0, #1]
	if (!status) {
 1007a12:	b93e      	cbnz	r6, 1007a24 <le_remote_feat_complete+0x54>
		memcpy(&sep->features[0],
 1007a14:	f108 0104 	add.w	r1, r8, #4
 1007a18:	2208      	movs	r2, #8
}
 1007a1a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		memcpy(&sep->features[0],
 1007a1e:	3003      	adds	r0, #3
 1007a20:	f00e bffa 	b.w	1016a18 <memcpy>
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
 1007a24:	4649      	mov	r1, r9
}
 1007a26:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
 1007a2a:	2208      	movs	r2, #8
 1007a2c:	3003      	adds	r0, #3
 1007a2e:	f00f b81e 	b.w	1016a6e <memset>
 1007a32:	bf00      	nop
 1007a34:	21000000 	.word	0x21000000
 1007a38:	21000008 	.word	0x21000008

01007a3c <encrypt_change.part.0>:
static void encrypt_change(u8_t err, u16_t handle,
 1007a3c:	b570      	push	{r4, r5, r6, lr}
	hdr = net_buf_add(buf, sizeof(*hdr));
 1007a3e:	f102 0508 	add.w	r5, r2, #8
static void encrypt_change(u8_t err, u16_t handle,
 1007a42:	4604      	mov	r4, r0
 1007a44:	460e      	mov	r6, r1
	hdr = net_buf_add(buf, sizeof(*hdr));
 1007a46:	4628      	mov	r0, r5
 1007a48:	2102      	movs	r1, #2
 1007a4a:	f00f f8f3 	bl	1016c34 <net_buf_simple_add>
	hdr->evt = evt;
 1007a4e:	2208      	movs	r2, #8
	hdr = net_buf_add(buf, sizeof(*hdr));
 1007a50:	4603      	mov	r3, r0
	hdr->len = len;
 1007a52:	2104      	movs	r1, #4
	hdr->evt = evt;
 1007a54:	701a      	strb	r2, [r3, #0]
	hdr->len = len;
 1007a56:	7059      	strb	r1, [r3, #1]
	ep = net_buf_add(buf, sizeof(*ep));
 1007a58:	4628      	mov	r0, r5
 1007a5a:	f00f f8eb 	bl	1016c34 <net_buf_simple_add>
	ep->encrypt = !err ? 1 : 0;
 1007a5e:	fab4 f384 	clz	r3, r4
 1007a62:	095b      	lsrs	r3, r3, #5
	ep->status = err;
 1007a64:	7004      	strb	r4, [r0, #0]
	ep->encrypt = !err ? 1 : 0;
 1007a66:	70c3      	strb	r3, [r0, #3]
	ep->handle = sys_cpu_to_le16(handle);
 1007a68:	f8a0 6001 	strh.w	r6, [r0, #1]
}
 1007a6c:	bd70      	pop	{r4, r5, r6, pc}
 1007a6e:	bf00      	nop

01007a70 <hci_disconn_complete_encode.part.0>:
void hci_disconn_complete_encode(struct pdu_data *pdu_data, u16_t handle,
 1007a70:	b538      	push	{r3, r4, r5, lr}
	hdr = net_buf_add(buf, sizeof(*hdr));
 1007a72:	f101 0408 	add.w	r4, r1, #8
void hci_disconn_complete_encode(struct pdu_data *pdu_data, u16_t handle,
 1007a76:	4605      	mov	r5, r0
	hdr = net_buf_add(buf, sizeof(*hdr));
 1007a78:	2102      	movs	r1, #2
 1007a7a:	4620      	mov	r0, r4
 1007a7c:	f00f f8da 	bl	1016c34 <net_buf_simple_add>
	hdr->evt = evt;
 1007a80:	2205      	movs	r2, #5
	hdr = net_buf_add(buf, sizeof(*hdr));
 1007a82:	4603      	mov	r3, r0
	hdr->len = len;
 1007a84:	2104      	movs	r1, #4
	hdr->evt = evt;
 1007a86:	701a      	strb	r2, [r3, #0]
	hdr->len = len;
 1007a88:	7059      	strb	r1, [r3, #1]
	ep = net_buf_add(buf, sizeof(*ep));
 1007a8a:	4620      	mov	r0, r4
 1007a8c:	f00f f8d2 	bl	1016c34 <net_buf_simple_add>
	ep->status = 0x00;
 1007a90:	2300      	movs	r3, #0
 1007a92:	7003      	strb	r3, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
 1007a94:	f8a0 5001 	strh.w	r5, [r0, #1]
}
 1007a98:	bd38      	pop	{r3, r4, r5, pc}
 1007a9a:	bf00      	nop

01007a9c <bt_hci_evt_create>:
{
 1007a9c:	b570      	push	{r4, r5, r6, lr}
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
 1007a9e:	f04f 32ff 	mov.w	r2, #4294967295
{
 1007aa2:	460e      	mov	r6, r1
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
 1007aa4:	f04f 33ff 	mov.w	r3, #4294967295
 1007aa8:	2100      	movs	r1, #0
{
 1007aaa:	4605      	mov	r5, r0
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
 1007aac:	f00f f84c 	bl	1016b48 <bt_buf_get_evt>
	hdr = net_buf_add(buf, sizeof(*hdr));
 1007ab0:	2102      	movs	r1, #2
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
 1007ab2:	4604      	mov	r4, r0
	hdr = net_buf_add(buf, sizeof(*hdr));
 1007ab4:	3008      	adds	r0, #8
 1007ab6:	f00f f8bd 	bl	1016c34 <net_buf_simple_add>
 1007aba:	4603      	mov	r3, r0
	hdr->len = len;
 1007abc:	705e      	strb	r6, [r3, #1]
	hdr->evt = evt;
 1007abe:	701d      	strb	r5, [r3, #0]
}
 1007ac0:	4620      	mov	r0, r4
 1007ac2:	bd70      	pop	{r4, r5, r6, pc}

01007ac4 <bt_hci_cmd_complete_create>:
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
 1007ac4:	3103      	adds	r1, #3
{
 1007ac6:	b538      	push	{r3, r4, r5, lr}
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
 1007ac8:	b2c9      	uxtb	r1, r1
{
 1007aca:	4605      	mov	r5, r0
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
 1007acc:	200e      	movs	r0, #14
 1007ace:	f7ff ffe5 	bl	1007a9c <bt_hci_evt_create>
	cc = net_buf_add(buf, sizeof(*cc));
 1007ad2:	2103      	movs	r1, #3
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
 1007ad4:	4604      	mov	r4, r0
	cc = net_buf_add(buf, sizeof(*cc));
 1007ad6:	3008      	adds	r0, #8
 1007ad8:	f00f f8ac 	bl	1016c34 <net_buf_simple_add>
	cc->ncmd = 1U;
 1007adc:	2201      	movs	r2, #1
	cc = net_buf_add(buf, sizeof(*cc));
 1007ade:	4603      	mov	r3, r0
	cc->ncmd = 1U;
 1007ae0:	701a      	strb	r2, [r3, #0]
}
 1007ae2:	4620      	mov	r0, r4
	cc->opcode = sys_cpu_to_le16(op);
 1007ae4:	f8a3 5001 	strh.w	r5, [r3, #1]
}
 1007ae8:	bd38      	pop	{r3, r4, r5, pc}
 1007aea:	bf00      	nop

01007aec <bt_hci_cmd_status_create>:
{
 1007aec:	b570      	push	{r4, r5, r6, lr}
 1007aee:	4605      	mov	r5, r0
 1007af0:	460e      	mov	r6, r1
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_STATUS, sizeof(*cs));
 1007af2:	200f      	movs	r0, #15
 1007af4:	2104      	movs	r1, #4
 1007af6:	f7ff ffd1 	bl	1007a9c <bt_hci_evt_create>
	cs = net_buf_add(buf, sizeof(*cs));
 1007afa:	2104      	movs	r1, #4
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_STATUS, sizeof(*cs));
 1007afc:	4604      	mov	r4, r0
	cs = net_buf_add(buf, sizeof(*cs));
 1007afe:	3008      	adds	r0, #8
 1007b00:	f00f f898 	bl	1016c34 <net_buf_simple_add>
	cs->ncmd = 1U;
 1007b04:	2201      	movs	r2, #1
	cs = net_buf_add(buf, sizeof(*cs));
 1007b06:	4603      	mov	r3, r0
	cs->status = status;
 1007b08:	701e      	strb	r6, [r3, #0]
	cs->ncmd = 1U;
 1007b0a:	705a      	strb	r2, [r3, #1]
}
 1007b0c:	4620      	mov	r0, r4
	cs->opcode = sys_cpu_to_le16(op);
 1007b0e:	805d      	strh	r5, [r3, #2]
}
 1007b10:	bd70      	pop	{r4, r5, r6, pc}
 1007b12:	bf00      	nop

01007b14 <hci_cmd_complete>:
{
 1007b14:	b538      	push	{r3, r4, r5, lr}
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1007b16:	4b06      	ldr	r3, [pc, #24]	; (1007b30 <hci_cmd_complete+0x1c>)
{
 1007b18:	4604      	mov	r4, r0
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1007b1a:	8818      	ldrh	r0, [r3, #0]
{
 1007b1c:	460d      	mov	r5, r1
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1007b1e:	f7ff ffd1 	bl	1007ac4 <bt_hci_cmd_complete_create>
	return net_buf_add(*buf, plen);
 1007b22:	4629      	mov	r1, r5
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 1007b24:	6020      	str	r0, [r4, #0]
	return net_buf_add(*buf, plen);
 1007b26:	3008      	adds	r0, #8
}
 1007b28:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return net_buf_add(*buf, plen);
 1007b2c:	f00f b882 	b.w	1016c34 <net_buf_simple_add>
 1007b30:	21008058 	.word	0x21008058

01007b34 <reset>:
{
 1007b34:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	event_mask = DEFAULT_EVENT_MASK;
 1007b38:	f04f 32ff 	mov.w	r2, #4294967295
 1007b3c:	f641 73ff 	movw	r3, #8191	; 0x1fff
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
 1007b40:	f04f 0800 	mov.w	r8, #0
 1007b44:	f04f 0900 	mov.w	r9, #0
	dup_count = -1;
 1007b48:	f04f 3cff 	mov.w	ip, #4294967295
	le_event_mask = DEFAULT_LE_EVENT_MASK;
 1007b4c:	261f      	movs	r6, #31
 1007b4e:	2700      	movs	r7, #0
{
 1007b50:	460c      	mov	r4, r1
	if (buf) {
 1007b52:	4601      	mov	r1, r0
	event_mask = DEFAULT_EVENT_MASK;
 1007b54:	481f      	ldr	r0, [pc, #124]	; (1007bd4 <reset+0xa0>)
	dup_count = -1;
 1007b56:	4d20      	ldr	r5, [pc, #128]	; (1007bd8 <reset+0xa4>)
	event_mask = DEFAULT_EVENT_MASK;
 1007b58:	e9c0 2300 	strd	r2, r3, [r0]
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
 1007b5c:	4b1f      	ldr	r3, [pc, #124]	; (1007bdc <reset+0xa8>)
	dup_count = -1;
 1007b5e:	f8c5 c000 	str.w	ip, [r5]
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
 1007b62:	e9c3 8900 	strd	r8, r9, [r3]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
 1007b66:	4b1e      	ldr	r3, [pc, #120]	; (1007be0 <reset+0xac>)
 1007b68:	e9c3 6700 	strd	r6, r7, [r3]
	if (buf) {
 1007b6c:	b321      	cbz	r1, 1007bb8 <reset+0x84>
		ll_reset();
 1007b6e:	f001 ff0b 	bl	1009988 <ll_reset>
		ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1007b72:	4620      	mov	r0, r4
 1007b74:	2101      	movs	r1, #1
 1007b76:	f7ff ffcd 	bl	1007b14 <hci_cmd_complete>
		ccst->status = 0x00;
 1007b7a:	2400      	movs	r4, #0
	conn_count = 0U;
 1007b7c:	4a19      	ldr	r2, [pc, #100]	; (1007be4 <reset+0xb0>)
	hci_hbuf_acked = 0U;
 1007b7e:	4b1a      	ldr	r3, [pc, #104]	; (1007be8 <reset+0xb4>)
	hci_hbuf_total = 0;
 1007b80:	4e1a      	ldr	r6, [pc, #104]	; (1007bec <reset+0xb8>)
	hci_hbuf_sent = 0U;
 1007b82:	4d1b      	ldr	r5, [pc, #108]	; (1007bf0 <reset+0xbc>)
		ccst->status = 0x00;
 1007b84:	7004      	strb	r4, [r0, #0]
	conn_count = 0U;
 1007b86:	6014      	str	r4, [r2, #0]
	(void)memset(hci_hbuf_pend, 0, sizeof(hci_hbuf_pend));
 1007b88:	4621      	mov	r1, r4
 1007b8a:	2220      	movs	r2, #32
 1007b8c:	4819      	ldr	r0, [pc, #100]	; (1007bf4 <reset+0xc0>)
	hci_hbuf_acked = 0U;
 1007b8e:	601c      	str	r4, [r3, #0]
	hci_hbuf_total = 0;
 1007b90:	6034      	str	r4, [r6, #0]
	hci_hbuf_sent = 0U;
 1007b92:	602c      	str	r4, [r5, #0]
	(void)memset(hci_hbuf_pend, 0, sizeof(hci_hbuf_pend));
 1007b94:	f00e ff6b 	bl	1016a6e <memset>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 1007b98:	4b17      	ldr	r3, [pc, #92]	; (1007bf8 <reset+0xc4>)
 1007b9a:	e8d3 2fef 	ldaex	r2, [r3]
 1007b9e:	f042 0201 	orr.w	r2, r2, #1
 1007ba2:	e8c3 2fe1 	stlex	r1, r2, [r3]
 1007ba6:	2900      	cmp	r1, #0
 1007ba8:	d1f7      	bne.n	1007b9a <reset+0x66>
		k_poll_signal_raise(hbuf_signal, 0x0);
 1007baa:	4b14      	ldr	r3, [pc, #80]	; (1007bfc <reset+0xc8>)
 1007bac:	6818      	ldr	r0, [r3, #0]
 1007bae:	4621      	mov	r1, r4
}
 1007bb0:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1007bb4:	f00d b970 	b.w	1014e98 <z_impl_k_poll_signal_raise>
	conn_count = 0U;
 1007bb8:	4a0a      	ldr	r2, [pc, #40]	; (1007be4 <reset+0xb0>)
	hci_hbuf_total = 0;
 1007bba:	480c      	ldr	r0, [pc, #48]	; (1007bec <reset+0xb8>)
	hci_hbuf_sent = 0U;
 1007bbc:	4c0c      	ldr	r4, [pc, #48]	; (1007bf0 <reset+0xbc>)
	hci_hbuf_acked = 0U;
 1007bbe:	4b0a      	ldr	r3, [pc, #40]	; (1007be8 <reset+0xb4>)
	conn_count = 0U;
 1007bc0:	6011      	str	r1, [r2, #0]
	hci_hbuf_total = 0;
 1007bc2:	6001      	str	r1, [r0, #0]
	hci_hbuf_sent = 0U;
 1007bc4:	6021      	str	r1, [r4, #0]
	hci_hbuf_acked = 0U;
 1007bc6:	6019      	str	r1, [r3, #0]
	(void)memset(hci_hbuf_pend, 0, sizeof(hci_hbuf_pend));
 1007bc8:	2220      	movs	r2, #32
}
 1007bca:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	(void)memset(hci_hbuf_pend, 0, sizeof(hci_hbuf_pend));
 1007bce:	4809      	ldr	r0, [pc, #36]	; (1007bf4 <reset+0xc0>)
 1007bd0:	f00e bf4d 	b.w	1016a6e <memset>
 1007bd4:	21000000 	.word	0x21000000
 1007bd8:	21000cd0 	.word	0x21000cd0
 1007bdc:	21000718 	.word	0x21000718
 1007be0:	21000008 	.word	0x21000008
 1007be4:	21000ccc 	.word	0x21000ccc
 1007be8:	21000d5c 	.word	0x21000d5c
 1007bec:	21000d84 	.word	0x21000d84
 1007bf0:	21000d80 	.word	0x21000d80
 1007bf4:	21000d60 	.word	0x21000d60
 1007bf8:	21000d88 	.word	0x21000d88
 1007bfc:	21000d58 	.word	0x21000d58

01007c00 <hci_vendor_cmd_handle_common>:
{
 1007c00:	b570      	push	{r4, r5, r6, lr}
 1007c02:	1e43      	subs	r3, r0, #1
 1007c04:	4614      	mov	r4, r2
 1007c06:	b086      	sub	sp, #24
 1007c08:	2b09      	cmp	r3, #9
 1007c0a:	d806      	bhi.n	1007c1a <hci_vendor_cmd_handle_common+0x1a>
 1007c0c:	e8df f003 	tbb	[pc, r3]
 1007c10:	05382109 	.word	0x05382109
 1007c14:	54054605 	.word	0x54054605
 1007c18:	7b6b      	.short	0x7b6b
	return 0;
 1007c1a:	f06f 0015 	mvn.w	r0, #21
}
 1007c1e:	b006      	add	sp, #24
 1007c20:	bd70      	pop	{r4, r5, r6, pc}
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007c22:	4620      	mov	r0, r4
 1007c24:	210d      	movs	r1, #13
 1007c26:	f7ff ff75 	bl	1007b14 <hci_cmd_complete>
	rp->status = 0x00;
 1007c2a:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007c2c:	4603      	mov	r3, r0
	rp->status = 0x00;
 1007c2e:	7001      	strb	r1, [r0, #0]
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
 1007c30:	7081      	strb	r1, [r0, #2]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
 1007c32:	7101      	strb	r1, [r0, #4]
	rp->fw_variant = 0U;
 1007c34:	7141      	strb	r1, [r0, #5]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
 1007c36:	7201      	strb	r1, [r0, #8]
	rp->fw_build = sys_cpu_to_le32(KERNEL_PATCHLEVEL & 0xffff);
 1007c38:	7241      	strb	r1, [r0, #9]
 1007c3a:	7281      	strb	r1, [r0, #10]
 1007c3c:	72c1      	strb	r1, [r0, #11]
 1007c3e:	7301      	strb	r1, [r0, #12]
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
 1007c40:	2402      	movs	r4, #2
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
 1007c42:	2203      	movs	r2, #3
	return 0;
 1007c44:	4608      	mov	r0, r1
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
 1007c46:	705c      	strb	r4, [r3, #1]
	rp->fw_version = (KERNEL_VERSION_MAJOR & 0xff);
 1007c48:	719c      	strb	r4, [r3, #6]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
 1007c4a:	70da      	strb	r2, [r3, #3]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
 1007c4c:	71da      	strb	r2, [r3, #7]
}
 1007c4e:	b006      	add	sp, #24
 1007c50:	bd70      	pop	{r4, r5, r6, pc}
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007c52:	4620      	mov	r0, r4
 1007c54:	2141      	movs	r1, #65	; 0x41
 1007c56:	f7ff ff5d 	bl	1007b14 <hci_cmd_complete>
	rp->status = 0x00;
 1007c5a:	2400      	movs	r4, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007c5c:	4605      	mov	r5, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
 1007c5e:	4621      	mov	r1, r4
 1007c60:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
 1007c62:	f800 4b01 	strb.w	r4, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
 1007c66:	f00e ff02 	bl	1016a6e <memset>
	return 0;
 1007c6a:	4620      	mov	r0, r4
	rp->commands[0] |= BIT(5) | BIT(7);
 1007c6c:	786a      	ldrb	r2, [r5, #1]
	rp->commands[1] |= BIT(0) | BIT(1);
 1007c6e:	78ab      	ldrb	r3, [r5, #2]
	rp->commands[0] |= BIT(5) | BIT(7);
 1007c70:	f062 0258 	orn	r2, r2, #88	; 0x58
	rp->commands[1] |= BIT(0) | BIT(1);
 1007c74:	f043 0303 	orr.w	r3, r3, #3
	rp->commands[0] |= BIT(5) | BIT(7);
 1007c78:	706a      	strb	r2, [r5, #1]
	rp->commands[1] |= BIT(0) | BIT(1);
 1007c7a:	70ab      	strb	r3, [r5, #2]
}
 1007c7c:	b006      	add	sp, #24
 1007c7e:	bd70      	pop	{r4, r5, r6, pc}
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007c80:	4620      	mov	r0, r4
 1007c82:	2109      	movs	r1, #9
 1007c84:	f7ff ff46 	bl	1007b14 <hci_cmd_complete>
	rp->status = 0x00;
 1007c88:	2400      	movs	r4, #0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
 1007c8a:	2208      	movs	r2, #8
 1007c8c:	4621      	mov	r1, r4
	rp->status = 0x00;
 1007c8e:	f800 4b01 	strb.w	r4, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
 1007c92:	f00e feec 	bl	1016a6e <memset>
	return 0;
 1007c96:	4620      	mov	r0, r4
}
 1007c98:	b006      	add	sp, #24
 1007c9a:	bd70      	pop	{r4, r5, r6, pc}
	ll_addr_set(0, &cmd->bdaddr.val[0]);
 1007c9c:	6889      	ldr	r1, [r1, #8]
 1007c9e:	2000      	movs	r0, #0
 1007ca0:	f7ff fba2 	bl	10073e8 <ll_addr_set>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1007ca4:	4620      	mov	r0, r4
 1007ca6:	2101      	movs	r1, #1
 1007ca8:	f7ff ff34 	bl	1007b14 <hci_cmd_complete>
	ccst->status = 0x00;
 1007cac:	2200      	movs	r2, #0
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1007cae:	4603      	mov	r3, r0
	return 0;
 1007cb0:	4610      	mov	r0, r2
	ccst->status = 0x00;
 1007cb2:	701a      	strb	r2, [r3, #0]
}
 1007cb4:	b006      	add	sp, #24
 1007cb6:	bd70      	pop	{r4, r5, r6, pc}
	const char build_info[] = HCI_VS_BUILD_INFO;
 1007cb8:	466d      	mov	r5, sp
 1007cba:	4e1a      	ldr	r6, [pc, #104]	; (1007d24 <hci_vendor_cmd_handle_common+0x124>)
 1007cbc:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 1007cbe:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 1007cc0:	e896 0003 	ldmia.w	r6, {r0, r1}
 1007cc4:	f845 0b04 	str.w	r0, [r5], #4
 1007cc8:	7029      	strb	r1, [r5, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp) + sizeof(build_info));
 1007cca:	4620      	mov	r0, r4
 1007ccc:	2116      	movs	r1, #22
 1007cce:	f7ff ff21 	bl	1007b14 <hci_cmd_complete>
	rp->status = 0x00;
 1007cd2:	2400      	movs	r4, #0
	memcpy(rp->info, build_info, sizeof(build_info));
 1007cd4:	2215      	movs	r2, #21
 1007cd6:	4669      	mov	r1, sp
	rp->status = 0x00;
 1007cd8:	f800 4b01 	strb.w	r4, [r0], #1
	memcpy(rp->info, build_info, sizeof(build_info));
 1007cdc:	f00e fe9c 	bl	1016a18 <memcpy>
	return 0;
 1007ce0:	4620      	mov	r0, r4
}
 1007ce2:	b006      	add	sp, #24
 1007ce4:	bd70      	pop	{r4, r5, r6, pc}
	rp = hci_cmd_complete(evt, sizeof(*rp) +
 1007ce6:	4620      	mov	r0, r4
 1007ce8:	2118      	movs	r1, #24
 1007cea:	f7ff ff13 	bl	1007b14 <hci_cmd_complete>
	rp->status = 0x00;
 1007cee:	2400      	movs	r4, #0
	rp = hci_cmd_complete(evt, sizeof(*rp) +
 1007cf0:	4605      	mov	r5, r0
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
 1007cf2:	2101      	movs	r1, #1
	rp->status = 0x00;
 1007cf4:	f800 4b02 	strb.w	r4, [r0], #2
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
 1007cf8:	f00a fd70 	bl	10127dc <hci_vendor_read_static_addr>
 1007cfc:	4603      	mov	r3, r0
	return 0;
 1007cfe:	4620      	mov	r0, r4
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
 1007d00:	706b      	strb	r3, [r5, #1]
}
 1007d02:	b006      	add	sp, #24
 1007d04:	bd70      	pop	{r4, r5, r6, pc}
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007d06:	4620      	mov	r0, r4
 1007d08:	2121      	movs	r1, #33	; 0x21
 1007d0a:	f7ff ff03 	bl	1007b14 <hci_cmd_complete>
	rp->status = 0x00;
 1007d0e:	2400      	movs	r4, #0
 1007d10:	4601      	mov	r1, r0
	hci_vendor_read_key_hierarchy_roots(rp->ir, rp->er);
 1007d12:	3001      	adds	r0, #1
	rp->status = 0x00;
 1007d14:	f801 4b11 	strb.w	r4, [r1], #17
	hci_vendor_read_key_hierarchy_roots(rp->ir, rp->er);
 1007d18:	f00a fdcc 	bl	10128b4 <hci_vendor_read_key_hierarchy_roots>
	return 0;
 1007d1c:	4620      	mov	r0, r4
}
 1007d1e:	b006      	add	sp, #24
 1007d20:	bd70      	pop	{r4, r5, r6, pc}
 1007d22:	bf00      	nop
 1007d24:	010186e8 	.word	0x010186e8

01007d28 <hci_cmd_handle>:
{
 1007d28:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct net_buf *evt = NULL;
 1007d2a:	2500      	movs	r5, #0
	if (cmd->len < sizeof(*chdr)) {
 1007d2c:	8983      	ldrh	r3, [r0, #12]
{
 1007d2e:	b08f      	sub	sp, #60	; 0x3c
	if (cmd->len < sizeof(*chdr)) {
 1007d30:	2b02      	cmp	r3, #2
	struct net_buf *evt = NULL;
 1007d32:	9509      	str	r5, [sp, #36]	; 0x24
	if (cmd->len < sizeof(*chdr)) {
 1007d34:	f240 80e0 	bls.w	1007ef8 <hci_cmd_handle+0x1d0>
	chdr = net_buf_pull_mem(cmd, sizeof(*chdr));
 1007d38:	4604      	mov	r4, r0
 1007d3a:	460e      	mov	r6, r1
 1007d3c:	3008      	adds	r0, #8
 1007d3e:	2103      	movs	r1, #3
 1007d40:	f00e ff98 	bl	1016c74 <net_buf_simple_pull_mem>
	if (cmd->len < chdr->param_len) {
 1007d44:	89a2      	ldrh	r2, [r4, #12]
 1007d46:	7883      	ldrb	r3, [r0, #2]
 1007d48:	429a      	cmp	r2, r3
 1007d4a:	f0c0 80fb 	bcc.w	1007f44 <hci_cmd_handle+0x21c>
	_opcode = sys_le16_to_cpu(chdr->opcode);
 1007d4e:	8803      	ldrh	r3, [r0, #0]
 1007d50:	4d86      	ldr	r5, [pc, #536]	; (1007f6c <hci_cmd_handle+0x244>)
	switch (BT_OGF(_opcode)) {
 1007d52:	f3c3 2285 	ubfx	r2, r3, #10, #6
 1007d56:	2a08      	cmp	r2, #8
	_opcode = sys_le16_to_cpu(chdr->opcode);
 1007d58:	b298      	uxth	r0, r3
 1007d5a:	802b      	strh	r3, [r5, #0]
	ocf = BT_OCF(_opcode);
 1007d5c:	f3c3 0309 	ubfx	r3, r3, #0, #10
	switch (BT_OGF(_opcode)) {
 1007d60:	d86b      	bhi.n	1007e3a <hci_cmd_handle+0x112>
 1007d62:	2a00      	cmp	r2, #0
 1007d64:	d073      	beq.n	1007e4e <hci_cmd_handle+0x126>
 1007d66:	3a01      	subs	r2, #1
 1007d68:	2a07      	cmp	r2, #7
 1007d6a:	d870      	bhi.n	1007e4e <hci_cmd_handle+0x126>
 1007d6c:	e8df f002 	tbb	[pc, r2]
 1007d70:	579c6f8e 	.word	0x579c6f8e
 1007d74:	046f6f74 	.word	0x046f6f74
	switch (ocf) {
 1007d78:	3b01      	subs	r3, #1
 1007d7a:	2b4d      	cmp	r3, #77	; 0x4d
 1007d7c:	d867      	bhi.n	1007e4e <hci_cmd_handle+0x126>
 1007d7e:	e8df f013 	tbh	[pc, r3, lsl #1]
 1007d82:	02e6      	.short	0x02e6
 1007d84:	02620274 	.word	0x02620274
 1007d88:	025d0066 	.word	0x025d0066
 1007d8c:	04670242 	.word	0x04670242
 1007d90:	045b0461 	.word	0x045b0461
 1007d94:	02ac0456 	.word	0x02ac0456
 1007d98:	0282029b 	.word	0x0282029b
 1007d9c:	044a0303 	.word	0x044a0303
 1007da0:	043c0440 	.word	0x043c0440
 1007da4:	03270438 	.word	0x03270438
 1007da8:	03130323 	.word	0x03130323
 1007dac:	0387039b 	.word	0x0387039b
 1007db0:	036d037b 	.word	0x036d037b
 1007db4:	03600368 	.word	0x03600368
 1007db8:	0066034d 	.word	0x0066034d
 1007dbc:	00660066 	.word	0x00660066
 1007dc0:	0471033e 	.word	0x0471033e
 1007dc4:	0224023a 	.word	0x0224023a
 1007dc8:	0066021e 	.word	0x0066021e
 1007dcc:	02170066 	.word	0x02170066
 1007dd0:	0203020d 	.word	0x0203020d
 1007dd4:	042701f7 	.word	0x042701f7
 1007dd8:	04090416 	.word	0x04090416
 1007ddc:	03dc03fd 	.word	0x03dc03fd
 1007de0:	03a403b5 	.word	0x03a403b5
 1007de4:	006602b8 	.word	0x006602b8
 1007de8:	00660066 	.word	0x00660066
 1007dec:	00660066 	.word	0x00660066
 1007df0:	00660066 	.word	0x00660066
 1007df4:	00660066 	.word	0x00660066
 1007df8:	00660066 	.word	0x00660066
 1007dfc:	00660066 	.word	0x00660066
 1007e00:	00660066 	.word	0x00660066
 1007e04:	00660066 	.word	0x00660066
 1007e08:	00660066 	.word	0x00660066
 1007e0c:	00660066 	.word	0x00660066
 1007e10:	00660066 	.word	0x00660066
 1007e14:	03070066 	.word	0x03070066
 1007e18:	00660066 	.word	0x00660066
 1007e1c:	0339      	.short	0x0339
	switch (ocf) {
 1007e1e:	3b01      	subs	r3, #1
 1007e20:	2b08      	cmp	r3, #8
 1007e22:	d814      	bhi.n	1007e4e <hci_cmd_handle+0x126>
 1007e24:	e8df f013 	tbh	[pc, r3, lsl #1]
 1007e28:	00ae0102 	.word	0x00ae0102
 1007e2c:	00130092 	.word	0x00130092
 1007e30:	00130013 	.word	0x00130013
 1007e34:	00130013 	.word	0x00130013
 1007e38:	0119      	.short	0x0119
	switch (BT_OGF(_opcode)) {
 1007e3a:	2a3f      	cmp	r2, #63	; 0x3f
 1007e3c:	d107      	bne.n	1007e4e <hci_cmd_handle+0x126>

/* Map vendor command handler directly to common implementation */
inline int hci_vendor_cmd_handle(u16_t ocf, struct net_buf *cmd,
				 struct net_buf **evt)
{
	return hci_vendor_cmd_handle_common(ocf, cmd, evt);
 1007e3e:	4621      	mov	r1, r4
 1007e40:	4618      	mov	r0, r3
 1007e42:	aa09      	add	r2, sp, #36	; 0x24
 1007e44:	f7ff fedc 	bl	1007c00 <hci_vendor_cmd_handle_common>
	if (err == -EINVAL) {
 1007e48:	3016      	adds	r0, #22
 1007e4a:	d11c      	bne.n	1007e86 <hci_cmd_handle+0x15e>
 1007e4c:	8828      	ldrh	r0, [r5, #0]
	return bt_hci_cmd_status_create(_opcode, status);
 1007e4e:	2101      	movs	r1, #1
 1007e50:	f7ff fe4c 	bl	1007aec <bt_hci_cmd_status_create>
}
 1007e54:	b00f      	add	sp, #60	; 0x3c
 1007e56:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (ocf) {
 1007e58:	2b05      	cmp	r3, #5
 1007e5a:	d1f8      	bne.n	1007e4e <hci_cmd_handle+0x126>
	handle = sys_le16_to_cpu(cmd->handle);
 1007e5c:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007e5e:	2104      	movs	r1, #4
 1007e60:	a809      	add	r0, sp, #36	; 0x24
	handle = sys_le16_to_cpu(cmd->handle);
 1007e62:	881d      	ldrh	r5, [r3, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007e64:	f7ff fe56 	bl	1007b14 <hci_cmd_complete>
 1007e68:	4604      	mov	r4, r0
	handle = sys_le16_to_cpu(cmd->handle);
 1007e6a:	b2a8      	uxth	r0, r5
	rp->status = ll_rssi_get(handle, &rp->rssi);
 1007e6c:	1ce1      	adds	r1, r4, #3
 1007e6e:	f003 feab 	bl	100bbc8 <ll_rssi_get>
	rp->handle = sys_cpu_to_le16(handle);
 1007e72:	f8a4 5001 	strh.w	r5, [r4, #1]
	rp->status = ll_rssi_get(handle, &rp->rssi);
 1007e76:	7020      	strb	r0, [r4, #0]
	rp->rssi = (!rp->status) ? -rp->rssi : 127;
 1007e78:	2800      	cmp	r0, #0
 1007e7a:	f040 83ff 	bne.w	100867c <hci_cmd_handle+0x954>
 1007e7e:	78e3      	ldrb	r3, [r4, #3]
 1007e80:	425b      	negs	r3, r3
 1007e82:	b25b      	sxtb	r3, r3
 1007e84:	70e3      	strb	r3, [r4, #3]
	if (err == -EINVAL) {
 1007e86:	9809      	ldr	r0, [sp, #36]	; 0x24
}
 1007e88:	b00f      	add	sp, #60	; 0x3c
 1007e8a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (ocf) {
 1007e8c:	2b06      	cmp	r3, #6
 1007e8e:	f000 83f8 	beq.w	1008682 <hci_cmd_handle+0x95a>
 1007e92:	2b1d      	cmp	r3, #29
 1007e94:	d1db      	bne.n	1007e4e <hci_cmd_handle+0x126>
	handle = sys_le16_to_cpu(cmd->handle);
 1007e96:	68a3      	ldr	r3, [r4, #8]
	status = ll_version_ind_send(handle);
 1007e98:	8818      	ldrh	r0, [r3, #0]
 1007e9a:	f003 fd89 	bl	100b9b0 <ll_version_ind_send>
 1007e9e:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
 1007ea0:	8828      	ldrh	r0, [r5, #0]
 1007ea2:	f7ff fe23 	bl	1007aec <bt_hci_cmd_status_create>
}
 1007ea6:	e7d5      	b.n	1007e54 <hci_cmd_handle+0x12c>
	switch (ocf) {
 1007ea8:	2b35      	cmp	r3, #53	; 0x35
 1007eaa:	d832      	bhi.n	1007f12 <hci_cmd_handle+0x1ea>
 1007eac:	2b2c      	cmp	r3, #44	; 0x2c
 1007eae:	d80a      	bhi.n	1007ec6 <hci_cmd_handle+0x19e>
 1007eb0:	2b01      	cmp	r3, #1
 1007eb2:	f000 83f9 	beq.w	10086a8 <hci_cmd_handle+0x980>
 1007eb6:	2b03      	cmp	r3, #3
 1007eb8:	d1c9      	bne.n	1007e4e <hci_cmd_handle+0x126>
		reset(cmd, evt);
 1007eba:	4620      	mov	r0, r4
 1007ebc:	a909      	add	r1, sp, #36	; 0x24
 1007ebe:	f7ff fe39 	bl	1007b34 <reset>
		break;
 1007ec2:	9809      	ldr	r0, [sp, #36]	; 0x24
 1007ec4:	e7c6      	b.n	1007e54 <hci_cmd_handle+0x12c>
 1007ec6:	3b2d      	subs	r3, #45	; 0x2d
 1007ec8:	2b08      	cmp	r3, #8
 1007eca:	d8c0      	bhi.n	1007e4e <hci_cmd_handle+0x126>
 1007ecc:	a201      	add	r2, pc, #4	; (adr r2, 1007ed4 <hci_cmd_handle+0x1ac>)
 1007ece:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 1007ed2:	bf00      	nop
 1007ed4:	010080fd 	.word	0x010080fd
 1007ed8:	01007e4f 	.word	0x01007e4f
 1007edc:	01007e4f 	.word	0x01007e4f
 1007ee0:	01007e4f 	.word	0x01007e4f
 1007ee4:	01008123 	.word	0x01008123
 1007ee8:	01007e4f 	.word	0x01007e4f
 1007eec:	010080d7 	.word	0x010080d7
 1007ef0:	01007e4f 	.word	0x01007e4f
 1007ef4:	01008073 	.word	0x01008073
 1007ef8:	491d      	ldr	r1, [pc, #116]	; (1007f70 <hci_cmd_handle+0x248>)
 1007efa:	4b1e      	ldr	r3, [pc, #120]	; (1007f74 <hci_cmd_handle+0x24c>)
		BT_ERR("No HCI Command header");
 1007efc:	481e      	ldr	r0, [pc, #120]	; (1007f78 <hci_cmd_handle+0x250>)
 1007efe:	1ac9      	subs	r1, r1, r3
 1007f00:	08c9      	lsrs	r1, r1, #3
		BT_ERR("Invalid HCI CMD packet length");
 1007f02:	0189      	lsls	r1, r1, #6
 1007f04:	f041 0101 	orr.w	r1, r1, #1
 1007f08:	f00d faf1 	bl	10154ee <log_0>
		return NULL;
 1007f0c:	4628      	mov	r0, r5
}
 1007f0e:	b00f      	add	sp, #60	; 0x3c
 1007f10:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (ocf) {
 1007f12:	2b7b      	cmp	r3, #123	; 0x7b
 1007f14:	f000 83d7 	beq.w	10086c6 <hci_cmd_handle+0x99e>
 1007f18:	2b7c      	cmp	r3, #124	; 0x7c
 1007f1a:	d10e      	bne.n	1007f3a <hci_cmd_handle+0x212>
		write_auth_payload_timeout(cmd, evt);
 1007f1c:	68a3      	ldr	r3, [r4, #8]
	handle = sys_le16_to_cpu(cmd->handle);
 1007f1e:	881d      	ldrh	r5, [r3, #0]
	status = ll_apto_set(handle, auth_payload_timeout);
 1007f20:	8859      	ldrh	r1, [r3, #2]
 1007f22:	b2a8      	uxth	r0, r5
 1007f24:	f003 fe92 	bl	100bc4c <ll_apto_set>
	status = ll_start_enc_req_send(handle, 0x00, &cmd->ltk[0]);
 1007f28:	4604      	mov	r4, r0
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007f2a:	2103      	movs	r1, #3
 1007f2c:	a809      	add	r0, sp, #36	; 0x24
 1007f2e:	f7ff fdf1 	bl	1007b14 <hci_cmd_complete>
	rp->status = status;
 1007f32:	7004      	strb	r4, [r0, #0]
	rp->handle = sys_cpu_to_le16(handle);
 1007f34:	f8a0 5001 	strh.w	r5, [r0, #1]
	if (err == -EINVAL) {
 1007f38:	e7a5      	b.n	1007e86 <hci_cmd_handle+0x15e>
	switch (ocf) {
 1007f3a:	2b63      	cmp	r3, #99	; 0x63
 1007f3c:	d187      	bne.n	1007e4e <hci_cmd_handle+0x126>
 *
 *  @return 64-bit integer in host endianness.
 */
static inline u64_t sys_get_le64(const u8_t src[8])
{
	return ((u64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
 1007f3e:	68a2      	ldr	r2, [r4, #8]
	event_mask_page_2 = sys_get_le64(cmd->events_page_2);
 1007f40:	4b0e      	ldr	r3, [pc, #56]	; (1007f7c <hci_cmd_handle+0x254>)
 1007f42:	e206      	b.n	1008352 <hci_cmd_handle+0x62a>
 1007f44:	490a      	ldr	r1, [pc, #40]	; (1007f70 <hci_cmd_handle+0x248>)
 1007f46:	4b0b      	ldr	r3, [pc, #44]	; (1007f74 <hci_cmd_handle+0x24c>)
		BT_ERR("Invalid HCI CMD packet length");
 1007f48:	480d      	ldr	r0, [pc, #52]	; (1007f80 <hci_cmd_handle+0x258>)
 1007f4a:	e7d8      	b.n	1007efe <hci_cmd_handle+0x1d6>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007f4c:	2109      	movs	r1, #9
 1007f4e:	a809      	add	r0, sp, #36	; 0x24
 1007f50:	f7ff fde0 	bl	1007b14 <hci_cmd_complete>
	rp->status = 0x00;
 1007f54:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007f56:	4604      	mov	r4, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
 1007f58:	2208      	movs	r2, #8
	rp->status = 0x00;
 1007f5a:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
 1007f5e:	f00e fd86 	bl	1016a6e <memset>
	rp->features[4] = (1 << 5) | (1 << 6);
 1007f62:	2360      	movs	r3, #96	; 0x60
 1007f64:	9809      	ldr	r0, [sp, #36]	; 0x24
 1007f66:	7163      	strb	r3, [r4, #5]
}
 1007f68:	e774      	b.n	1007e54 <hci_cmd_handle+0x12c>
 1007f6a:	bf00      	nop
 1007f6c:	21008058 	.word	0x21008058
 1007f70:	01018230 	.word	0x01018230
 1007f74:	01018208 	.word	0x01018208
 1007f78:	01018700 	.word	0x01018700
 1007f7c:	21000718 	.word	0x21000718
 1007f80:	01018718 	.word	0x01018718
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007f84:	2141      	movs	r1, #65	; 0x41
 1007f86:	a809      	add	r0, sp, #36	; 0x24
 1007f88:	f7ff fdc4 	bl	1007b14 <hci_cmd_complete>
	rp->status = 0x00;
 1007f8c:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007f8e:	4604      	mov	r4, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
 1007f90:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
 1007f92:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
 1007f96:	f00e fd6a 	bl	1016a6e <memset>
	rp->commands[26] |= BIT(4) | BIT(5);
 1007f9a:	23ff      	movs	r3, #255	; 0xff
	rp->commands[2] |= BIT(7);
 1007f9c:	78e5      	ldrb	r5, [r4, #3]
	rp->commands[0] |= BIT(5);
 1007f9e:	7860      	ldrb	r0, [r4, #1]
	rp->commands[5] |= BIT(6) | BIT(7);
 1007fa0:	79a1      	ldrb	r1, [r4, #6]
	rp->commands[10] |= BIT(5) | BIT(6) | BIT(7);
 1007fa2:	7ae2      	ldrb	r2, [r4, #11]
	rp->commands[2] |= BIT(7);
 1007fa4:	f065 057f 	orn	r5, r5, #127	; 0x7f
	rp->commands[0] |= BIT(5);
 1007fa8:	f040 0020 	orr.w	r0, r0, #32
	rp->commands[5] |= BIT(6) | BIT(7);
 1007fac:	f061 013f 	orn	r1, r1, #63	; 0x3f
	rp->commands[10] |= BIT(5) | BIT(6) | BIT(7);
 1007fb0:	f062 021b 	orn	r2, r2, #27
	rp->commands[14] |= BIT(3) | BIT(5);
 1007fb4:	7be6      	ldrb	r6, [r4, #15]
	rp->commands[2] |= BIT(7);
 1007fb6:	70e5      	strb	r5, [r4, #3]
	rp->commands[0] |= BIT(5);
 1007fb8:	7060      	strb	r0, [r4, #1]
	rp->commands[15] |= BIT(5);
 1007fba:	7c25      	ldrb	r5, [r4, #16]
	rp->commands[22] |= BIT(2);
 1007fbc:	7de0      	ldrb	r0, [r4, #23]
	rp->commands[5] |= BIT(6) | BIT(7);
 1007fbe:	71a1      	strb	r1, [r4, #6]
	rp->commands[10] |= BIT(5) | BIT(6) | BIT(7);
 1007fc0:	72e2      	strb	r2, [r4, #11]
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
 1007fc2:	7ea1      	ldrb	r1, [r4, #26]
	rp->commands[28] |= BIT(3);
 1007fc4:	7f62      	ldrb	r2, [r4, #29]
	rp->commands[14] |= BIT(3) | BIT(5);
 1007fc6:	f046 0628 	orr.w	r6, r6, #40	; 0x28
	rp->commands[15] |= BIT(5);
 1007fca:	f045 0522 	orr.w	r5, r5, #34	; 0x22
	rp->commands[22] |= BIT(2);
 1007fce:	f040 0004 	orr.w	r0, r0, #4
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
 1007fd2:	f061 0108 	orn	r1, r1, #8
	rp->commands[28] |= BIT(1) | BIT(2);
 1007fd6:	f042 020f 	orr.w	r2, r2, #15
	rp->commands[14] |= BIT(3) | BIT(5);
 1007fda:	73e6      	strb	r6, [r4, #15]
	rp->commands[15] |= BIT(5);
 1007fdc:	7425      	strb	r5, [r4, #16]
	rp->commands[32] |= BIT(4) | BIT(5);
 1007fde:	f894 6021 	ldrb.w	r6, [r4, #33]	; 0x21
	rp->commands[33] |= BIT(4) | BIT(5);
 1007fe2:	f894 5022 	ldrb.w	r5, [r4, #34]	; 0x22
	rp->commands[22] |= BIT(2);
 1007fe6:	75e0      	strb	r0, [r4, #23]
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
 1007fe8:	76a1      	strb	r1, [r4, #26]
	rp->commands[35] |= BIT(0) | BIT(1) | BIT(2);
 1007fea:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
	rp->commands[39] |= BIT(2);
 1007fee:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
	rp->commands[28] |= BIT(1) | BIT(2);
 1007ff2:	7762      	strb	r2, [r4, #29]
	rp->commands[38] |= BIT(7);
 1007ff4:	f894 2027 	ldrb.w	r2, [r4, #39]	; 0x27
	rp->commands[35] |= BIT(0) | BIT(1) | BIT(2);
 1007ff8:	f040 007f 	orr.w	r0, r0, #127	; 0x7f
	rp->commands[32] |= BIT(4) | BIT(5);
 1007ffc:	f046 0630 	orr.w	r6, r6, #48	; 0x30
	rp->commands[33] |= BIT(6) | BIT(7);
 1008000:	f065 050f 	orn	r5, r5, #15
	rp->commands[39] |= BIT(2);
 1008004:	f041 0104 	orr.w	r1, r1, #4
	rp->commands[38] |= BIT(7);
 1008008:	f062 027f 	orn	r2, r2, #127	; 0x7f
	rp->commands[35] |= BIT(0) | BIT(1) | BIT(2);
 100800c:	f884 0024 	strb.w	r0, [r4, #36]	; 0x24
	rp->commands[32] |= BIT(4) | BIT(5);
 1008010:	f884 6021 	strb.w	r6, [r4, #33]	; 0x21
 1008014:	9809      	ldr	r0, [sp, #36]	; 0x24
	rp->commands[33] |= BIT(6) | BIT(7);
 1008016:	f884 5022 	strb.w	r5, [r4, #34]	; 0x22
	rp->commands[39] |= BIT(2);
 100801a:	f884 1028 	strb.w	r1, [r4, #40]	; 0x28
	rp->commands[38] |= BIT(7);
 100801e:	f884 2027 	strb.w	r2, [r4, #39]	; 0x27
	rp->commands[26] |= BIT(4) | BIT(5);
 1008022:	76e3      	strb	r3, [r4, #27]
	rp->commands[27] |= BIT(2) | BIT(4) | BIT(5);
 1008024:	7723      	strb	r3, [r4, #28]
	rp->commands[34] |= BIT(1) | BIT(2);
 1008026:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
}
 100802a:	e713      	b.n	1007e54 <hci_cmd_handle+0x12c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 100802c:	2109      	movs	r1, #9
 100802e:	a809      	add	r0, sp, #36	; 0x24
 1008030:	f7ff fd70 	bl	1007b14 <hci_cmd_complete>
	rp->status = 0x00;
 1008034:	2200      	movs	r2, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1008036:	4603      	mov	r3, r0
	rp->hci_version = LL_VERSION_NUMBER;
 1008038:	200b      	movs	r0, #11
	rp->lmp_subversion = sys_cpu_to_le16(ll_settings_subversion_number());
 100803a:	f04f 31ff 	mov.w	r1, #4294967295
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
 100803e:	f06f 050e 	mvn.w	r5, #14
 1008042:	2405      	movs	r4, #5
	rp->status = 0x00;
 1008044:	701a      	strb	r2, [r3, #0]
	rp->hci_version = LL_VERSION_NUMBER;
 1008046:	7058      	strb	r0, [r3, #1]
	rp->lmp_version = LL_VERSION_NUMBER;
 1008048:	7118      	strb	r0, [r3, #4]
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
 100804a:	715d      	strb	r5, [r3, #5]
 100804c:	9809      	ldr	r0, [sp, #36]	; 0x24
 100804e:	719c      	strb	r4, [r3, #6]
	rp->hci_revision = sys_cpu_to_le16(0);
 1008050:	709a      	strb	r2, [r3, #2]
 1008052:	70da      	strb	r2, [r3, #3]
	rp->lmp_subversion = sys_cpu_to_le16(ll_settings_subversion_number());
 1008054:	71d9      	strb	r1, [r3, #7]
 1008056:	7219      	strb	r1, [r3, #8]
	if (err == -EINVAL) {
 1008058:	e6fc      	b.n	1007e54 <hci_cmd_handle+0x12c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 100805a:	2107      	movs	r1, #7
 100805c:	a809      	add	r0, sp, #36	; 0x24
 100805e:	f7ff fd59 	bl	1007b14 <hci_cmd_complete>
 1008062:	4601      	mov	r1, r0
	rp->status = 0x00;
 1008064:	2000      	movs	r0, #0
 1008066:	f801 0b01 	strb.w	r0, [r1], #1
	ll_addr_get(0, &rp->bdaddr.val[0]);
 100806a:	f7ff f99f 	bl	10073ac <ll_addr_get>
 100806e:	9809      	ldr	r0, [sp, #36]	; 0x24
}
 1008070:	e6f0      	b.n	1007e54 <hci_cmd_handle+0x12c>
	if (hci_hbuf_total <= 0) {
 1008072:	4bbd      	ldr	r3, [pc, #756]	; (1008368 <hci_cmd_handle+0x640>)
 1008074:	681b      	ldr	r3, [r3, #0]
 1008076:	2b00      	cmp	r3, #0
 1008078:	f340 830e 	ble.w	1008698 <hci_cmd_handle+0x970>
	} else if (!conn_count) {
 100807c:	4bbb      	ldr	r3, [pc, #748]	; (100836c <hci_cmd_handle+0x644>)
 100807e:	681b      	ldr	r3, [r3, #0]
 1008080:	b30b      	cbz	r3, 10080c6 <hci_cmd_handle+0x39e>
		host_num_completed_packets(cmd, evt);
 1008082:	68a7      	ldr	r7, [r4, #8]
	for (i = 0; i < cmd->num_handles; i++) {
 1008084:	f897 c000 	ldrb.w	ip, [r7]
	u32_t count = 0U;
 1008088:	4664      	mov	r4, ip
	for (i = 0; i < cmd->num_handles; i++) {
 100808a:	f1bc 0f00 	cmp.w	ip, #0
 100808e:	f000 8330 	beq.w	10086f2 <hci_cmd_handle+0x9ca>
	u32_t count = 0U;
 1008092:	2400      	movs	r4, #0
		    (c > hci_hbuf_pend[h])) {
 1008094:	4db6      	ldr	r5, [pc, #728]	; (1008370 <hci_cmd_handle+0x648>)
	for (i = 0; i < cmd->num_handles; i++) {
 1008096:	4623      	mov	r3, r4
 1008098:	e00a      	b.n	10080b0 <hci_cmd_handle+0x388>
		    (c > hci_hbuf_pend[h])) {
 100809a:	f835 0011 	ldrh.w	r0, [r5, r1, lsl #1]
		if ((h >= ARRAY_SIZE(hci_hbuf_pend)) ||
 100809e:	4282      	cmp	r2, r0
		hci_hbuf_pend[h] -= c;
 10080a0:	eba0 0602 	sub.w	r6, r0, r2
		if ((h >= ARRAY_SIZE(hci_hbuf_pend)) ||
 10080a4:	d80f      	bhi.n	10080c6 <hci_cmd_handle+0x39e>
	for (i = 0; i < cmd->num_handles; i++) {
 10080a6:	4563      	cmp	r3, ip
		hci_hbuf_pend[h] -= c;
 10080a8:	f825 6011 	strh.w	r6, [r5, r1, lsl #1]
	for (i = 0; i < cmd->num_handles; i++) {
 10080ac:	f000 8321 	beq.w	10086f2 <hci_cmd_handle+0x9ca>
		hci_hbuf_pend[h] -= c;
 10080b0:	eb07 0283 	add.w	r2, r7, r3, lsl #2
		u16_t h = sys_le16_to_cpu(cmd->h[i].handle);
 10080b4:	f8b2 1001 	ldrh.w	r1, [r2, #1]
		u16_t c = sys_le16_to_cpu(cmd->h[i].count);
 10080b8:	f8b2 2003 	ldrh.w	r2, [r2, #3]
		if ((h >= ARRAY_SIZE(hci_hbuf_pend)) ||
 10080bc:	290f      	cmp	r1, #15
	for (i = 0; i < cmd->num_handles; i++) {
 10080be:	f103 0301 	add.w	r3, r3, #1
		count += c;
 10080c2:	4414      	add	r4, r2
		if ((h >= ARRAY_SIZE(hci_hbuf_pend)) ||
 10080c4:	d9e9      	bls.n	100809a <hci_cmd_handle+0x372>
		ccst = hci_cmd_complete(evt, sizeof(*ccst));
 10080c6:	2101      	movs	r1, #1
 10080c8:	a809      	add	r0, sp, #36	; 0x24
 10080ca:	f7ff fd23 	bl	1007b14 <hci_cmd_complete>
		ccst->status = BT_HCI_ERR_INVALID_PARAM;
 10080ce:	2312      	movs	r3, #18
 10080d0:	7003      	strb	r3, [r0, #0]
		return;
 10080d2:	9809      	ldr	r0, [sp, #36]	; 0x24
 10080d4:	e6be      	b.n	1007e54 <hci_cmd_handle+0x12c>
		host_buffer_size(cmd, evt);
 10080d6:	68a3      	ldr	r3, [r4, #8]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 10080d8:	2101      	movs	r1, #1
 10080da:	a809      	add	r0, sp, #36	; 0x24
	u16_t acl_pkts = sys_le16_to_cpu(cmd->acl_pkts);
 10080dc:	f8b3 4003 	ldrh.w	r4, [r3, #3]
	u16_t acl_mtu = sys_le16_to_cpu(cmd->acl_mtu);
 10080e0:	881d      	ldrh	r5, [r3, #0]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 10080e2:	f7ff fd17 	bl	1007b14 <hci_cmd_complete>
	if (hci_hbuf_total) {
 10080e6:	4ba0      	ldr	r3, [pc, #640]	; (1008368 <hci_cmd_handle+0x640>)
 10080e8:	681a      	ldr	r2, [r3, #0]
 10080ea:	2a00      	cmp	r2, #0
 10080ec:	f040 82d8 	bne.w	10086a0 <hci_cmd_handle+0x978>
	if (acl_mtu < LL_LENGTH_OCTETS_RX_MAX) {
 10080f0:	2dfa      	cmp	r5, #250	; 0xfa
 10080f2:	d9ec      	bls.n	10080ce <hci_cmd_handle+0x3a6>
	hci_hbuf_total = -acl_pkts;
 10080f4:	4264      	negs	r4, r4
 10080f6:	9809      	ldr	r0, [sp, #36]	; 0x24
 10080f8:	601c      	str	r4, [r3, #0]
 10080fa:	e6ab      	b.n	1007e54 <hci_cmd_handle+0x12c>
		read_tx_power_level(cmd, evt);
 10080fc:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
 10080fe:	2104      	movs	r1, #4
 1008100:	a809      	add	r0, sp, #36	; 0x24
	handle = sys_le16_to_cpu(cmd->handle);
 1008102:	881d      	ldrh	r5, [r3, #0]
	type = cmd->type;
 1008104:	789e      	ldrb	r6, [r3, #2]
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1008106:	f7ff fd05 	bl	1007b14 <hci_cmd_complete>
	status = ll_tx_pwr_lvl_get(BT_HCI_VS_LL_HANDLE_TYPE_CONN,
 100810a:	4632      	mov	r2, r6
	rp = hci_cmd_complete(evt, sizeof(*rp));
 100810c:	4604      	mov	r4, r0
	status = ll_tx_pwr_lvl_get(BT_HCI_VS_LL_HANDLE_TYPE_CONN,
 100810e:	1cc3      	adds	r3, r0, #3
	handle = sys_le16_to_cpu(cmd->handle);
 1008110:	b2a9      	uxth	r1, r5
	status = ll_tx_pwr_lvl_get(BT_HCI_VS_LL_HANDLE_TYPE_CONN,
 1008112:	2002      	movs	r0, #2
 1008114:	f7ff f988 	bl	1007428 <ll_tx_pwr_lvl_get>
	rp->status = status;
 1008118:	7020      	strb	r0, [r4, #0]
	rp->handle = sys_cpu_to_le16(handle);
 100811a:	9809      	ldr	r0, [sp, #36]	; 0x24
 100811c:	f8a4 5001 	strh.w	r5, [r4, #1]
}
 1008120:	e698      	b.n	1007e54 <hci_cmd_handle+0x12c>
	u8_t flow_enable = cmd->flow_enable;
 1008122:	68a3      	ldr	r3, [r4, #8]
	if (!hci_hbuf_total || conn_count) {
 1008124:	4c90      	ldr	r4, [pc, #576]	; (1008368 <hci_cmd_handle+0x640>)
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1008126:	2101      	movs	r1, #1
 1008128:	a809      	add	r0, sp, #36	; 0x24
	u8_t flow_enable = cmd->flow_enable;
 100812a:	781d      	ldrb	r5, [r3, #0]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 100812c:	f7ff fcf2 	bl	1007b14 <hci_cmd_complete>
	if (!hci_hbuf_total || conn_count) {
 1008130:	6823      	ldr	r3, [r4, #0]
 1008132:	2b00      	cmp	r3, #0
 1008134:	f000 82b4 	beq.w	10086a0 <hci_cmd_handle+0x978>
 1008138:	4a8c      	ldr	r2, [pc, #560]	; (100836c <hci_cmd_handle+0x644>)
 100813a:	6812      	ldr	r2, [r2, #0]
 100813c:	2a00      	cmp	r2, #0
 100813e:	f040 82af 	bne.w	10086a0 <hci_cmd_handle+0x978>
		ccst->status = 0x00;
 1008142:	7002      	strb	r2, [r0, #0]
	switch (flow_enable) {
 1008144:	2d00      	cmp	r5, #0
 1008146:	f000 82e5 	beq.w	1008714 <hci_cmd_handle+0x9ec>
 100814a:	2d01      	cmp	r5, #1
 100814c:	d1bf      	bne.n	10080ce <hci_cmd_handle+0x3a6>
		if (hci_hbuf_total > 0) {
 100814e:	2b00      	cmp	r3, #0
 1008150:	f73f ae99 	bgt.w	1007e86 <hci_cmd_handle+0x15e>
	hci_hbuf_sent = 0U;
 1008154:	2100      	movs	r1, #0
 1008156:	4887      	ldr	r0, [pc, #540]	; (1008374 <hci_cmd_handle+0x64c>)
	hci_hbuf_acked = 0U;
 1008158:	4b87      	ldr	r3, [pc, #540]	; (1008378 <hci_cmd_handle+0x650>)
	hci_hbuf_sent = 0U;
 100815a:	6001      	str	r1, [r0, #0]
	(void)memset(hci_hbuf_pend, 0, sizeof(hci_hbuf_pend));
 100815c:	2220      	movs	r2, #32
 100815e:	4884      	ldr	r0, [pc, #528]	; (1008370 <hci_cmd_handle+0x648>)
	hci_hbuf_acked = 0U;
 1008160:	6019      	str	r1, [r3, #0]
	(void)memset(hci_hbuf_pend, 0, sizeof(hci_hbuf_pend));
 1008162:	f00e fc84 	bl	1016a6e <memset>
	hci_hbuf_total = -hci_hbuf_total;
 1008166:	6823      	ldr	r3, [r4, #0]
 1008168:	9809      	ldr	r0, [sp, #36]	; 0x24
 100816a:	425b      	negs	r3, r3
 100816c:	6023      	str	r3, [r4, #0]
 100816e:	e671      	b.n	1007e54 <hci_cmd_handle+0x12c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1008170:	2102      	movs	r1, #2
 1008172:	a809      	add	r0, sp, #36	; 0x24
 1008174:	f7ff fcce 	bl	1007b14 <hci_cmd_complete>
 1008178:	4604      	mov	r4, r0
	rp->rl_size = ll_rl_size_get();
 100817a:	f006 fe57 	bl	100ee2c <ll_rl_size_get>
	rp->status = 0x00;
 100817e:	2300      	movs	r3, #0
	rp->rl_size = ll_rl_size_get();
 1008180:	7060      	strb	r0, [r4, #1]
	rp->status = 0x00;
 1008182:	7023      	strb	r3, [r4, #0]
	if (err == -EINVAL) {
 1008184:	9809      	ldr	r0, [sp, #36]	; 0x24
 1008186:	e665      	b.n	1007e54 <hci_cmd_handle+0x12c>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1008188:	2101      	movs	r1, #1
 100818a:	a809      	add	r0, sp, #36	; 0x24
 100818c:	f7ff fcc2 	bl	1007b14 <hci_cmd_complete>
 1008190:	4604      	mov	r4, r0
	ccst->status = ll_rl_clear();
 1008192:	f006 fe4d 	bl	100ee30 <ll_rl_clear>
 1008196:	7020      	strb	r0, [r4, #0]
	if (err == -EINVAL) {
 1008198:	9809      	ldr	r0, [sp, #36]	; 0x24
 100819a:	e65b      	b.n	1007e54 <hci_cmd_handle+0x12c>
	status = ll_rl_remove(&cmd->peer_id_addr);
 100819c:	68a0      	ldr	r0, [r4, #8]
 100819e:	f007 fa19 	bl	100f5d4 <ll_rl_remove>
	status = ll_phy_default_set(cmd->tx_phys, cmd->rx_phys);
 10081a2:	4604      	mov	r4, r0
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 10081a4:	2101      	movs	r1, #1
 10081a6:	a809      	add	r0, sp, #36	; 0x24
 10081a8:	f7ff fcb4 	bl	1007b14 <hci_cmd_complete>
	ccst->status = status;
 10081ac:	7004      	strb	r4, [r0, #0]
 10081ae:	e66a      	b.n	1007e86 <hci_cmd_handle+0x15e>
		le_add_dev_to_rl(cmd, evt);
 10081b0:	68a0      	ldr	r0, [r4, #8]
	status = ll_rl_add(&cmd->peer_id_addr, cmd->peer_irk, cmd->local_irk);
 10081b2:	f100 0217 	add.w	r2, r0, #23
 10081b6:	1dc1      	adds	r1, r0, #7
 10081b8:	f007 f956 	bl	100f468 <ll_rl_add>
 10081bc:	e7f1      	b.n	10081a2 <hci_cmd_handle+0x47a>
		le_write_default_data_len(cmd, evt);
 10081be:	68a3      	ldr	r3, [r4, #8]
	status = ll_length_default_set(max_tx_octets, max_tx_time);
 10081c0:	8859      	ldrh	r1, [r3, #2]
 10081c2:	8818      	ldrh	r0, [r3, #0]
 10081c4:	f003 fc6c 	bl	100baa0 <ll_length_default_set>
 10081c8:	e7eb      	b.n	10081a2 <hci_cmd_handle+0x47a>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 10081ca:	2105      	movs	r1, #5
 10081cc:	a809      	add	r0, sp, #36	; 0x24
 10081ce:	f7ff fca1 	bl	1007b14 <hci_cmd_complete>
 10081d2:	4604      	mov	r4, r0
	ll_length_default_get(&max_tx_octets, &max_tx_time);
 10081d4:	a90a      	add	r1, sp, #40	; 0x28
 10081d6:	f10d 0022 	add.w	r0, sp, #34	; 0x22
 10081da:	f003 fc55 	bl	100ba88 <ll_length_default_get>
	rp->status = 0x00;
 10081de:	2200      	movs	r2, #0
	rp->max_tx_octets = sys_cpu_to_le16(max_tx_octets);
 10081e0:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
 10081e4:	f8a4 3001 	strh.w	r3, [r4, #1]
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
 10081e8:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
	rp->status = 0x00;
 10081ec:	7022      	strb	r2, [r4, #0]
 10081ee:	9809      	ldr	r0, [sp, #36]	; 0x24
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
 10081f0:	f8a4 3003 	strh.w	r3, [r4, #3]
	if (err == -EINVAL) {
 10081f4:	e62e      	b.n	1007e54 <hci_cmd_handle+0x12c>
		le_set_data_len(cmd, evt);
 10081f6:	68a3      	ldr	r3, [r4, #8]
	handle = sys_le16_to_cpu(cmd->handle);
 10081f8:	881d      	ldrh	r5, [r3, #0]
	status = ll_length_req_send(handle, tx_octets, tx_time);
 10081fa:	889a      	ldrh	r2, [r3, #4]
 10081fc:	8859      	ldrh	r1, [r3, #2]
 10081fe:	b2a8      	uxth	r0, r5
 1008200:	f003 fbf6 	bl	100b9f0 <ll_length_req_send>
 1008204:	e690      	b.n	1007f28 <hci_cmd_handle+0x200>
		le_set_adv_param(cmd, evt);
 1008206:	68a4      	ldr	r4, [r4, #8]
	    (cmd->type != BT_HCI_ADV_DIRECT_IND)) {
 1008208:	7921      	ldrb	r1, [r4, #4]
	min_interval = sys_le16_to_cpu(cmd->min_interval);
 100820a:	8820      	ldrh	r0, [r4, #0]
	if (IS_ENABLED(CONFIG_BT_CTLR_PARAM_CHECK) &&
 100820c:	2901      	cmp	r1, #1
 100820e:	d00a      	beq.n	1008226 <hci_cmd_handle+0x4fe>
		u16_t max_interval = sys_le16_to_cpu(cmd->max_interval);
 1008210:	8863      	ldrh	r3, [r4, #2]
		if ((min_interval > max_interval) ||
 1008212:	4298      	cmp	r0, r3
 1008214:	f63f af57 	bhi.w	10080c6 <hci_cmd_handle+0x39e>
 1008218:	281f      	cmp	r0, #31
 100821a:	f67f af54 	bls.w	10080c6 <hci_cmd_handle+0x39e>
		    (min_interval < 0x0020) ||
 100821e:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 1008222:	f63f af50 	bhi.w	10080c6 <hci_cmd_handle+0x39e>
	status = ll_adv_params_set(min_interval, cmd->type,
 1008226:	7ba5      	ldrb	r5, [r4, #14]
 1008228:	79a3      	ldrb	r3, [r4, #6]
 100822a:	7962      	ldrb	r2, [r4, #5]
 100822c:	9502      	str	r5, [sp, #8]
 100822e:	7b65      	ldrb	r5, [r4, #13]
				   &cmd->direct_addr.a.val[0], cmd->channel_map,
 1008230:	3407      	adds	r4, #7
	status = ll_adv_params_set(min_interval, cmd->type,
 1008232:	e9cd 4500 	strd	r4, r5, [sp]
 1008236:	f002 fb87 	bl	100a948 <ll_adv_params_set>
 100823a:	e7b2      	b.n	10081a2 <hci_cmd_handle+0x47a>
	status = ll_addr_set(1, &cmd->bdaddr.val[0]);
 100823c:	68a1      	ldr	r1, [r4, #8]
 100823e:	2001      	movs	r0, #1
 1008240:	f7ff f8d2 	bl	10073e8 <ll_addr_set>
 1008244:	e7ad      	b.n	10081a2 <hci_cmd_handle+0x47a>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1008246:	2109      	movs	r1, #9
 1008248:	a809      	add	r0, sp, #36	; 0x24
 100824a:	f7ff fc63 	bl	1007b14 <hci_cmd_complete>
	rp->status = 0x00;
 100824e:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1008250:	4604      	mov	r4, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
 1008252:	2208      	movs	r2, #8
	rp->status = 0x00;
 1008254:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
 1008258:	f00e fc09 	bl	1016a6e <memset>
	dst[0] = val;
 100825c:	21ff      	movs	r1, #255	; 0xff
	dst[1] = val >> 8;
 100825e:	2249      	movs	r2, #73	; 0x49
	dst[2] = val >> 16;
 1008260:	2301      	movs	r3, #1
	dst[0] = val;
 1008262:	7061      	strb	r1, [r4, #1]
	dst[1] = val >> 8;
 1008264:	70a2      	strb	r2, [r4, #2]
	dst[2] = val >> 16;
 1008266:	70e3      	strb	r3, [r4, #3]
	if (err == -EINVAL) {
 1008268:	e60d      	b.n	1007e86 <hci_cmd_handle+0x15e>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 100826a:	2104      	movs	r1, #4
 100826c:	a809      	add	r0, sp, #36	; 0x24
 100826e:	f7ff fc51 	bl	1007b14 <hci_cmd_complete>
	rp->status = 0x00;
 1008272:	2300      	movs	r3, #0
	rp->le_max_num = CONFIG_BT_CTLR_TX_BUFFERS;
 1008274:	210a      	movs	r1, #10
	rp->le_max_len = sys_cpu_to_le16(CONFIG_BT_CTLR_TX_BUFFER_SIZE);
 1008276:	f06f 0204 	mvn.w	r2, #4
	rp->le_max_num = CONFIG_BT_CTLR_TX_BUFFERS;
 100827a:	70c1      	strb	r1, [r0, #3]
	rp->status = 0x00;
 100827c:	7003      	strb	r3, [r0, #0]
	rp->le_max_len = sys_cpu_to_le16(CONFIG_BT_CTLR_TX_BUFFER_SIZE);
 100827e:	7042      	strb	r2, [r0, #1]
 1008280:	7083      	strb	r3, [r0, #2]
	if (err == -EINVAL) {
 1008282:	9809      	ldr	r0, [sp, #36]	; 0x24
 1008284:	e5e6      	b.n	1007e54 <hci_cmd_handle+0x12c>
		le_create_connection(cmd, evt);
 1008286:	68a4      	ldr	r4, [r4, #8]
	status = ll_create_connection(scan_interval, scan_window,
 1008288:	f8b4 6013 	ldrh.w	r6, [r4, #19]
 100828c:	8861      	ldrh	r1, [r4, #2]
 100828e:	7963      	ldrb	r3, [r4, #5]
 1008290:	7922      	ldrb	r2, [r4, #4]
 1008292:	8820      	ldrh	r0, [r4, #0]
 1008294:	9604      	str	r6, [sp, #16]
 1008296:	f8b4 6011 	ldrh.w	r6, [r4, #17]
 100829a:	3406      	adds	r4, #6
 100829c:	9603      	str	r6, [sp, #12]
 100829e:	f8b4 6009 	ldrh.w	r6, [r4, #9]
 10082a2:	9602      	str	r6, [sp, #8]
 10082a4:	79a6      	ldrb	r6, [r4, #6]
 10082a6:	e9cd 4600 	strd	r4, r6, [sp]
 10082aa:	f006 f86f 	bl	100e38c <ll_create_connection>
 10082ae:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
 10082b0:	8828      	ldrh	r0, [r5, #0]
 10082b2:	f7ff fc1b 	bl	1007aec <bt_hci_cmd_status_create>
	if (err == -EINVAL) {
 10082b6:	e5cd      	b.n	1007e54 <hci_cmd_handle+0x12c>
		le_set_scan_enable(cmd, evt);
 10082b8:	68a3      	ldr	r3, [r4, #8]
	if (cmd->enable && cmd->filter_dup) {
 10082ba:	7818      	ldrb	r0, [r3, #0]
 10082bc:	2800      	cmp	r0, #0
 10082be:	f000 8224 	beq.w	100870a <hci_cmd_handle+0x9e2>
 10082c2:	785b      	ldrb	r3, [r3, #1]
 10082c4:	2b00      	cmp	r3, #0
 10082c6:	f000 8220 	beq.w	100870a <hci_cmd_handle+0x9e2>
		dup_count = 0;
 10082ca:	2300      	movs	r3, #0
 10082cc:	492b      	ldr	r1, [pc, #172]	; (100837c <hci_cmd_handle+0x654>)
		dup_curr = 0U;
 10082ce:	4a2c      	ldr	r2, [pc, #176]	; (1008380 <hci_cmd_handle+0x658>)
		dup_count = 0;
 10082d0:	600b      	str	r3, [r1, #0]
		dup_curr = 0U;
 10082d2:	6013      	str	r3, [r2, #0]
	status = ll_scan_enable(cmd->enable);
 10082d4:	f002 fdd4 	bl	100ae80 <ll_scan_enable>
 10082d8:	e763      	b.n	10081a2 <hci_cmd_handle+0x47a>
		le_set_scan_param(cmd, evt);
 10082da:	68a4      	ldr	r4, [r4, #8]
	status = ll_scan_params_set(cmd->scan_type, interval, window,
 10082dc:	7963      	ldrb	r3, [r4, #5]
 10082de:	f8b4 2003 	ldrh.w	r2, [r4, #3]
 10082e2:	f8b4 1001 	ldrh.w	r1, [r4, #1]
 10082e6:	7820      	ldrb	r0, [r4, #0]
 10082e8:	79a4      	ldrb	r4, [r4, #6]
 10082ea:	9400      	str	r4, [sp, #0]
 10082ec:	f7f8 fb60 	bl	10009b0 <ll_scan_params_set>
 10082f0:	e757      	b.n	10081a2 <hci_cmd_handle+0x47a>
		le_set_phy(cmd, evt);
 10082f2:	68a2      	ldr	r2, [r4, #8]
	if (cmd->all_phys & BT_HCI_LE_PHY_TX_ANY) {
 10082f4:	7893      	ldrb	r3, [r2, #2]
		cmd->tx_phys |= mask_phys;
 10082f6:	78d1      	ldrb	r1, [r2, #3]
	if (cmd->all_phys & BT_HCI_LE_PHY_TX_ANY) {
 10082f8:	07df      	lsls	r7, r3, #31
		cmd->tx_phys |= mask_phys;
 10082fa:	bf44      	itt	mi
 10082fc:	f041 0107 	orrmi.w	r1, r1, #7
 1008300:	70d1      	strbmi	r1, [r2, #3]
	if (cmd->all_phys & BT_HCI_LE_PHY_RX_ANY) {
 1008302:	f013 0f02 	tst.w	r3, #2
		cmd->rx_phys |= mask_phys;
 1008306:	7913      	ldrb	r3, [r2, #4]
	handle = sys_le16_to_cpu(cmd->handle);
 1008308:	8816      	ldrh	r6, [r2, #0]
		cmd->rx_phys |= mask_phys;
 100830a:	bf1c      	itt	ne
 100830c:	f043 0307 	orrne.w	r3, r3, #7
 1008310:	7113      	strbne	r3, [r2, #4]
	phy_opts = sys_le16_to_cpu(cmd->phy_opts);
 1008312:	f8b2 4005 	ldrh.w	r4, [r2, #5]
	if ((cmd->tx_phys | cmd->rx_phys) & ~mask_phys) {
 1008316:	ea43 0201 	orr.w	r2, r3, r1
 100831a:	f012 0ff8 	tst.w	r2, #248	; 0xf8
 100831e:	f040 8203 	bne.w	1008728 <hci_cmd_handle+0xa00>
	if (!(cmd->tx_phys & 0x07) ||
 1008322:	074f      	lsls	r7, r1, #29
 1008324:	f000 81fb 	beq.w	100871e <hci_cmd_handle+0x9f6>
 1008328:	075a      	lsls	r2, r3, #29
 100832a:	f000 81f8 	beq.w	100871e <hci_cmd_handle+0x9f6>
	if (phy_opts & 0x03) {
 100832e:	f014 0203 	ands.w	r2, r4, #3
		phy_opts -= 1U;
 1008332:	bf18      	it	ne
 1008334:	f104 34ff 	addne.w	r4, r4, #4294967295
	status = ll_phy_req_send(handle, cmd->tx_phys, phy_opts,
 1008338:	4630      	mov	r0, r6
		phy_opts &= 1;
 100833a:	bf18      	it	ne
 100833c:	f004 0201 	andne.w	r2, r4, #1
	status = ll_phy_req_send(handle, cmd->tx_phys, phy_opts,
 1008340:	f003 fbee 	bl	100bb20 <ll_phy_req_send>
 1008344:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
 1008346:	8828      	ldrh	r0, [r5, #0]
 1008348:	f7ff fbd0 	bl	1007aec <bt_hci_cmd_status_create>
 100834c:	e582      	b.n	1007e54 <hci_cmd_handle+0x12c>
	return ((u64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
 100834e:	68a2      	ldr	r2, [r4, #8]
	le_event_mask = sys_get_le64(cmd->events);
 1008350:	4b0c      	ldr	r3, [pc, #48]	; (1008384 <hci_cmd_handle+0x65c>)
 1008352:	6814      	ldr	r4, [r2, #0]
 1008354:	6852      	ldr	r2, [r2, #4]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1008356:	2101      	movs	r1, #1
	le_event_mask = sys_get_le64(cmd->events);
 1008358:	e9c3 4200 	strd	r4, r2, [r3]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 100835c:	a809      	add	r0, sp, #36	; 0x24
 100835e:	f7ff fbd9 	bl	1007b14 <hci_cmd_complete>
	ccst->status = 0x00;
 1008362:	2300      	movs	r3, #0
 1008364:	7003      	strb	r3, [r0, #0]
	if (err == -EINVAL) {
 1008366:	e58e      	b.n	1007e86 <hci_cmd_handle+0x15e>
 1008368:	21000d84 	.word	0x21000d84
 100836c:	21000ccc 	.word	0x21000ccc
 1008370:	21000d60 	.word	0x21000d60
 1008374:	21000d80 	.word	0x21000d80
 1008378:	21000d5c 	.word	0x21000d5c
 100837c:	21000cd0 	.word	0x21000cd0
 1008380:	21000cd4 	.word	0x21000cd4
 1008384:	21000008 	.word	0x21000008
	status = ll_connect_disable(node_rx);
 1008388:	4630      	mov	r0, r6
 100838a:	f006 fb15 	bl	100e9b8 <ll_connect_disable>
 100838e:	e708      	b.n	10081a2 <hci_cmd_handle+0x47a>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1008390:	2103      	movs	r1, #3
 1008392:	a809      	add	r0, sp, #36	; 0x24
 1008394:	f7ff fbbe 	bl	1007b14 <hci_cmd_complete>
	rp->status = 0x00;
 1008398:	2300      	movs	r3, #0
 100839a:	4601      	mov	r1, r0
	ll_tx_pwr_get(&rp->min_tx_power, &rp->max_tx_power);
 100839c:	3001      	adds	r0, #1
	rp->status = 0x00;
 100839e:	f801 3b02 	strb.w	r3, [r1], #2
	ll_tx_pwr_get(&rp->min_tx_power, &rp->max_tx_power);
 10083a2:	f7ff f851 	bl	1007448 <ll_tx_pwr_get>
	if (err == -EINVAL) {
 10083a6:	e56e      	b.n	1007e86 <hci_cmd_handle+0x15e>
	handle = sys_le16_to_cpu(cmd->handle);
 10083a8:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
 10083aa:	2108      	movs	r1, #8
 10083ac:	a809      	add	r0, sp, #36	; 0x24
	handle = sys_le16_to_cpu(cmd->handle);
 10083ae:	881d      	ldrh	r5, [r3, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
 10083b0:	f7ff fbb0 	bl	1007b14 <hci_cmd_complete>
 10083b4:	4604      	mov	r4, r0
	handle = sys_le16_to_cpu(cmd->handle);
 10083b6:	b2a8      	uxth	r0, r5
	status = ll_chm_get(handle, rp->ch_map);
 10083b8:	1ce1      	adds	r1, r4, #3
 10083ba:	f003 fa97 	bl	100b8ec <ll_chm_get>
	rp->status = status;
 10083be:	7020      	strb	r0, [r4, #0]
	rp->handle = sys_le16_to_cpu(handle);
 10083c0:	9809      	ldr	r0, [sp, #36]	; 0x24
 10083c2:	f8a4 5001 	strh.w	r5, [r4, #1]
	if (err == -EINVAL) {
 10083c6:	e545      	b.n	1007e54 <hci_cmd_handle+0x12c>
	status = ll_chm_update(&cmd->ch_map[0]);
 10083c8:	68a0      	ldr	r0, [r4, #8]
 10083ca:	f006 fb31 	bl	100ea30 <ll_chm_update>
 10083ce:	e6e8      	b.n	10081a2 <hci_cmd_handle+0x47a>
	status = ll_conn_update(handle, 0, 0, conn_interval_min,
 10083d0:	2200      	movs	r2, #0
		le_conn_update(cmd, evt);
 10083d2:	68a1      	ldr	r1, [r4, #8]
	status = ll_conn_update(handle, 0, 0, conn_interval_min,
 10083d4:	890c      	ldrh	r4, [r1, #8]
 10083d6:	884b      	ldrh	r3, [r1, #2]
 10083d8:	8808      	ldrh	r0, [r1, #0]
 10083da:	9402      	str	r4, [sp, #8]
 10083dc:	88cc      	ldrh	r4, [r1, #6]
 10083de:	9401      	str	r4, [sp, #4]
 10083e0:	8889      	ldrh	r1, [r1, #4]
 10083e2:	9100      	str	r1, [sp, #0]
 10083e4:	4611      	mov	r1, r2
 10083e6:	f003 f9f9 	bl	100b7dc <ll_conn_update>
 10083ea:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
 10083ec:	8828      	ldrh	r0, [r5, #0]
 10083ee:	f7ff fb7d 	bl	1007aec <bt_hci_cmd_status_create>
	if (err == -EINVAL) {
 10083f2:	e52f      	b.n	1007e54 <hci_cmd_handle+0x12c>
		le_set_privacy_mode(cmd, evt);
 10083f4:	68a0      	ldr	r0, [r4, #8]
	status = ll_priv_mode_set(&cmd->id_addr, cmd->mode);
 10083f6:	79c1      	ldrb	r1, [r0, #7]
 10083f8:	f007 f9d0 	bl	100f79c <ll_priv_mode_set>
 10083fc:	e6d1      	b.n	10081a2 <hci_cmd_handle+0x47a>
		le_conn_param_req_reply(cmd, evt);
 10083fe:	68a1      	ldr	r1, [r4, #8]
	status = ll_conn_update(handle, 2, 0, interval_min, interval_max,
 1008400:	2200      	movs	r2, #0
 1008402:	8908      	ldrh	r0, [r1, #8]
	handle = sys_le16_to_cpu(cmd->handle);
 1008404:	880d      	ldrh	r5, [r1, #0]
	status = ll_conn_update(handle, 2, 0, interval_min, interval_max,
 1008406:	884b      	ldrh	r3, [r1, #2]
 1008408:	9002      	str	r0, [sp, #8]
 100840a:	88c8      	ldrh	r0, [r1, #6]
 100840c:	9001      	str	r0, [sp, #4]
 100840e:	8889      	ldrh	r1, [r1, #4]
 1008410:	b2a8      	uxth	r0, r5
 1008412:	9100      	str	r1, [sp, #0]
 1008414:	2102      	movs	r1, #2
 1008416:	f003 f9e1 	bl	100b7dc <ll_conn_update>
 100841a:	e585      	b.n	1007f28 <hci_cmd_handle+0x200>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 100841c:	2109      	movs	r1, #9
 100841e:	a809      	add	r0, sp, #36	; 0x24
 1008420:	f7ff fb78 	bl	1007b14 <hci_cmd_complete>
	dst[0] = val;
 1008424:	243f      	movs	r4, #63	; 0x3f
 1008426:	23ff      	movs	r3, #255	; 0xff
	rp->status = 0x00;
 1008428:	2200      	movs	r2, #0
	dst[1] = val >> 8;
 100842a:	2103      	movs	r1, #3
	dst[0] = val;
 100842c:	70c4      	strb	r4, [r0, #3]
 100842e:	7002      	strb	r2, [r0, #0]
 1008430:	7043      	strb	r3, [r0, #1]
	dst[1] = val >> 8;
 1008432:	7083      	strb	r3, [r0, #2]
 1008434:	7181      	strb	r1, [r0, #6]
	dst[0] = val;
 1008436:	71c2      	strb	r2, [r0, #7]
	dst[1] = val >> 8;
 1008438:	7202      	strb	r2, [r0, #8]
 100843a:	7103      	strb	r3, [r0, #4]
	dst[0] = val;
 100843c:	7143      	strb	r3, [r0, #5]
	if (err == -EINVAL) {
 100843e:	9809      	ldr	r0, [sp, #36]	; 0x24
 1008440:	e508      	b.n	1007e54 <hci_cmd_handle+0x12c>
	status = ll_start_enc_req_send(handle, BT_HCI_ERR_PIN_OR_KEY_MISSING,
 1008442:	2200      	movs	r2, #0
 1008444:	2106      	movs	r1, #6
	handle = sys_le16_to_cpu(cmd->handle);
 1008446:	68a3      	ldr	r3, [r4, #8]
 1008448:	881d      	ldrh	r5, [r3, #0]
	status = ll_start_enc_req_send(handle, 0x00, &cmd->ltk[0]);
 100844a:	b2a8      	uxth	r0, r5
 100844c:	f005 ff04 	bl	100e258 <ll_start_enc_req_send>
 1008450:	e56a      	b.n	1007f28 <hci_cmd_handle+0x200>
	handle = sys_le16_to_cpu(cmd->handle);
 1008452:	68a2      	ldr	r2, [r4, #8]
	status = ll_start_enc_req_send(handle, 0x00, &cmd->ltk[0]);
 1008454:	2100      	movs	r1, #0
	handle = sys_le16_to_cpu(cmd->handle);
 1008456:	f832 5b02 	ldrh.w	r5, [r2], #2
 100845a:	e7f6      	b.n	100844a <hci_cmd_handle+0x722>
		le_start_encryption(cmd, evt);
 100845c:	68a2      	ldr	r2, [r4, #8]
				 (u8_t *)&cmd->rand,
 100845e:	4611      	mov	r1, r2
	status = ll_enc_req_send(handle,
 1008460:	f102 030c 	add.w	r3, r2, #12
 1008464:	f831 0b02 	ldrh.w	r0, [r1], #2
 1008468:	320a      	adds	r2, #10
 100846a:	f006 fb11 	bl	100ea90 <ll_enc_req_send>
 100846e:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
 1008470:	8828      	ldrh	r0, [r5, #0]
 1008472:	f7ff fb3b 	bl	1007aec <bt_hci_cmd_status_create>
	if (err == -EINVAL) {
 1008476:	e4ed      	b.n	1007e54 <hci_cmd_handle+0x12c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1008478:	2109      	movs	r1, #9
 100847a:	a809      	add	r0, sp, #36	; 0x24
 100847c:	f7ff fb4a 	bl	1007b14 <hci_cmd_complete>
	rp->status = 0x00;
 1008480:	2300      	movs	r3, #0
	lll_trng_get(rp->rand, count);
 1008482:	2108      	movs	r1, #8
	rp->status = 0x00;
 1008484:	f800 3b01 	strb.w	r3, [r0], #1
	lll_trng_get(rp->rand, count);
 1008488:	f007 fd24 	bl	100fed4 <lll_trng_get>
	if (err == -EINVAL) {
 100848c:	9809      	ldr	r0, [sp, #36]	; 0x24
 100848e:	e4e1      	b.n	1007e54 <hci_cmd_handle+0x12c>
		le_encrypt(cmd, evt);
 1008490:	68a0      	ldr	r0, [r4, #8]
	ecb_encrypt(cmd->key, cmd->plaintext, enc_data, NULL);
 1008492:	2300      	movs	r3, #0
 1008494:	f100 0110 	add.w	r1, r0, #16
 1008498:	aa0a      	add	r2, sp, #40	; 0x28
 100849a:	f009 fb51 	bl	1011b40 <ecb_encrypt>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 100849e:	2111      	movs	r1, #17
 10084a0:	a809      	add	r0, sp, #36	; 0x24
 10084a2:	f7ff fb37 	bl	1007b14 <hci_cmd_complete>
	rp->status = 0x00;
 10084a6:	2300      	movs	r3, #0
	memcpy(rp->enc_data, enc_data, 16);
 10084a8:	2210      	movs	r2, #16
	rp->status = 0x00;
 10084aa:	f800 3b01 	strb.w	r3, [r0], #1
	memcpy(rp->enc_data, enc_data, 16);
 10084ae:	a90a      	add	r1, sp, #40	; 0x28
 10084b0:	f00e fab2 	bl	1016a18 <memcpy>
	if (err == -EINVAL) {
 10084b4:	9809      	ldr	r0, [sp, #36]	; 0x24
 10084b6:	e4cd      	b.n	1007e54 <hci_cmd_handle+0x12c>
	handle = sys_le16_to_cpu(cmd->handle);
 10084b8:	68a3      	ldr	r3, [r4, #8]
	status = ll_feature_req_send(handle);
 10084ba:	8818      	ldrh	r0, [r3, #0]
 10084bc:	f003 fa58 	bl	100b970 <ll_feature_req_send>
 10084c0:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
 10084c2:	8828      	ldrh	r0, [r5, #0]
 10084c4:	f7ff fb12 	bl	1007aec <bt_hci_cmd_status_create>
	if (err == -EINVAL) {
 10084c8:	e4c4      	b.n	1007e54 <hci_cmd_handle+0x12c>
		le_set_default_phy(cmd, evt);
 10084ca:	68a3      	ldr	r3, [r4, #8]
	if (cmd->all_phys & BT_HCI_LE_PHY_TX_ANY) {
 10084cc:	781a      	ldrb	r2, [r3, #0]
 10084ce:	07d1      	lsls	r1, r2, #31
		cmd->tx_phys = 0x07;
 10084d0:	bf49      	itett	mi
 10084d2:	2107      	movmi	r1, #7
 10084d4:	7858      	ldrbpl	r0, [r3, #1]
 10084d6:	4608      	movmi	r0, r1
 10084d8:	7059      	strbmi	r1, [r3, #1]
	if (cmd->all_phys & BT_HCI_LE_PHY_RX_ANY) {
 10084da:	0792      	lsls	r2, r2, #30
		cmd->rx_phys = 0x07;
 10084dc:	bf49      	itett	mi
 10084de:	2207      	movmi	r2, #7
 10084e0:	7899      	ldrbpl	r1, [r3, #2]
 10084e2:	4611      	movmi	r1, r2
 10084e4:	709a      	strbmi	r2, [r3, #2]
	status = ll_phy_default_set(cmd->tx_phys, cmd->rx_phys);
 10084e6:	f003 fb11 	bl	100bb0c <ll_phy_default_set>
 10084ea:	e65a      	b.n	10081a2 <hci_cmd_handle+0x47a>
	handle = sys_le16_to_cpu(cmd->handle);
 10084ec:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
 10084ee:	2105      	movs	r1, #5
 10084f0:	a809      	add	r0, sp, #36	; 0x24
	handle = sys_le16_to_cpu(cmd->handle);
 10084f2:	881d      	ldrh	r5, [r3, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
 10084f4:	f7ff fb0e 	bl	1007b14 <hci_cmd_complete>
 10084f8:	4604      	mov	r4, r0
	handle = sys_le16_to_cpu(cmd->handle);
 10084fa:	b2a8      	uxth	r0, r5
	status = ll_phy_get(handle, &rp->tx_phy, &rp->rx_phy);
 10084fc:	1d22      	adds	r2, r4, #4
 10084fe:	1ce1      	adds	r1, r4, #3
 1008500:	f003 fae2 	bl	100bac8 <ll_phy_get>
 * @return least significant bit set, 0 if @a op is 0
 */

static ALWAYS_INLINE unsigned int find_lsb_set(u32_t op)
{
	return __builtin_ffs(op);
 1008504:	78e6      	ldrb	r6, [r4, #3]
 1008506:	7921      	ldrb	r1, [r4, #4]
 1008508:	fa96 f2a6 	rbit	r2, r6
 100850c:	fa91 f3a1 	rbit	r3, r1
 1008510:	2e00      	cmp	r6, #0
 1008512:	fab2 f282 	clz	r2, r2
 1008516:	bf08      	it	eq
 1008518:	f04f 32ff 	moveq.w	r2, #4294967295
 100851c:	2900      	cmp	r1, #0
 100851e:	fab3 f383 	clz	r3, r3
 1008522:	bf08      	it	eq
 1008524:	f04f 33ff 	moveq.w	r3, #4294967295
 1008528:	3201      	adds	r2, #1
	rp->status = status;
 100852a:	7020      	strb	r0, [r4, #0]
	rp->tx_phy = find_lsb_set(rp->tx_phy);
 100852c:	70e2      	strb	r2, [r4, #3]
 100852e:	3301      	adds	r3, #1
 1008530:	9809      	ldr	r0, [sp, #36]	; 0x24
	rp->handle = sys_cpu_to_le16(handle);
 1008532:	f8a4 5001 	strh.w	r5, [r4, #1]
	rp->rx_phy = find_lsb_set(rp->rx_phy);
 1008536:	7123      	strb	r3, [r4, #4]
	if (err == -EINVAL) {
 1008538:	e48c      	b.n	1007e54 <hci_cmd_handle+0x12c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 100853a:	2109      	movs	r1, #9
 100853c:	a809      	add	r0, sp, #36	; 0x24
 100853e:	f7ff fae9 	bl	1007b14 <hci_cmd_complete>
 1008542:	4604      	mov	r4, r0
	ll_length_max_get(&max_tx_octets, &max_tx_time,
 1008544:	ab0a      	add	r3, sp, #40	; 0x28
 1008546:	f10d 0222 	add.w	r2, sp, #34	; 0x22
 100854a:	a908      	add	r1, sp, #32
 100854c:	f10d 001e 	add.w	r0, sp, #30
 1008550:	f003 fab0 	bl	100bab4 <ll_length_max_get>
	rp->status = 0x00;
 1008554:	2200      	movs	r2, #0
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
 1008556:	f8bd 3020 	ldrh.w	r3, [sp, #32]
	rp->max_tx_octets = sys_cpu_to_le16(max_tx_octets);
 100855a:	f8bd 101e 	ldrh.w	r1, [sp, #30]
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
 100855e:	f8a4 3003 	strh.w	r3, [r4, #3]
	rp->max_tx_octets = sys_cpu_to_le16(max_tx_octets);
 1008562:	f8a4 1001 	strh.w	r1, [r4, #1]
	rp->max_rx_octets = sys_cpu_to_le16(max_rx_octets);
 1008566:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
 100856a:	f8a4 3005 	strh.w	r3, [r4, #5]
	rp->max_rx_time = sys_cpu_to_le16(max_rx_time);
 100856e:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
	rp->status = 0x00;
 1008572:	7022      	strb	r2, [r4, #0]
 1008574:	9809      	ldr	r0, [sp, #36]	; 0x24
	rp->max_rx_time = sys_cpu_to_le16(max_rx_time);
 1008576:	f8a4 3007 	strh.w	r3, [r4, #7]
	if (err == -EINVAL) {
 100857a:	e46b      	b.n	1007e54 <hci_cmd_handle+0x12c>
	u16_t timeout = sys_le16_to_cpu(cmd->rpa_timeout);
 100857c:	68a3      	ldr	r3, [r4, #8]
	ll_rl_timeout_set(timeout);
 100857e:	8818      	ldrh	r0, [r3, #0]
 1008580:	f006 fcb6 	bl	100eef0 <ll_rl_timeout_set>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1008584:	2101      	movs	r1, #1
 1008586:	a809      	add	r0, sp, #36	; 0x24
 1008588:	f7ff fac4 	bl	1007b14 <hci_cmd_complete>
	ccst->status = 0x00;
 100858c:	2300      	movs	r3, #0
 100858e:	7003      	strb	r3, [r0, #0]
	if (err == -EINVAL) {
 1008590:	9809      	ldr	r0, [sp, #36]	; 0x24
 1008592:	e45f      	b.n	1007e54 <hci_cmd_handle+0x12c>
	u8_t enable = cmd->enable;
 1008594:	68a3      	ldr	r3, [r4, #8]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1008596:	2101      	movs	r1, #1
 1008598:	a809      	add	r0, sp, #36	; 0x24
	u8_t enable = cmd->enable;
 100859a:	781d      	ldrb	r5, [r3, #0]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 100859c:	f7ff faba 	bl	1007b14 <hci_cmd_complete>
 10085a0:	4604      	mov	r4, r0
	ccst->status = ll_rl_enable(enable);
 10085a2:	4628      	mov	r0, r5
 10085a4:	f006 fc88 	bl	100eeb8 <ll_rl_enable>
 10085a8:	7020      	strb	r0, [r4, #0]
	if (err == -EINVAL) {
 10085aa:	9809      	ldr	r0, [sp, #36]	; 0x24
 10085ac:	e452      	b.n	1007e54 <hci_cmd_handle+0x12c>
	memcpy(dst, src, sizeof(*dst));
}

static inline void bt_addr_le_copy(bt_addr_le_t *dst, const bt_addr_le_t *src)
{
	memcpy(dst, src, sizeof(*dst));
 10085ae:	2207      	movs	r2, #7
 10085b0:	68a1      	ldr	r1, [r4, #8]
 10085b2:	a80a      	add	r0, sp, #40	; 0x28
 10085b4:	f00e fa30 	bl	1016a18 <memcpy>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 10085b8:	2107      	movs	r1, #7
 10085ba:	a809      	add	r0, sp, #36	; 0x24
 10085bc:	f7ff faaa 	bl	1007b14 <hci_cmd_complete>
 10085c0:	4604      	mov	r4, r0
	rp->status = ll_rl_lrpa_get(&peer_id_addr, &rp->local_rpa);
 10085c2:	a80a      	add	r0, sp, #40	; 0x28
 10085c4:	1c61      	adds	r1, r4, #1
 10085c6:	f007 f8cd 	bl	100f764 <ll_rl_lrpa_get>
 10085ca:	7020      	strb	r0, [r4, #0]
	if (err == -EINVAL) {
 10085cc:	9809      	ldr	r0, [sp, #36]	; 0x24
 10085ce:	e441      	b.n	1007e54 <hci_cmd_handle+0x12c>
 10085d0:	2207      	movs	r2, #7
 10085d2:	68a1      	ldr	r1, [r4, #8]
 10085d4:	a80a      	add	r0, sp, #40	; 0x28
 10085d6:	f00e fa1f 	bl	1016a18 <memcpy>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 10085da:	2107      	movs	r1, #7
 10085dc:	a809      	add	r0, sp, #36	; 0x24
 10085de:	f7ff fa99 	bl	1007b14 <hci_cmd_complete>
 10085e2:	4604      	mov	r4, r0
	rp->status = ll_rl_crpa_get(&peer_id_addr, &rp->peer_rpa);
 10085e4:	a80a      	add	r0, sp, #40	; 0x28
 10085e6:	1c61      	adds	r1, r4, #1
 10085e8:	f007 f898 	bl	100f71c <ll_rl_crpa_get>
 10085ec:	7020      	strb	r0, [r4, #0]
	if (err == -EINVAL) {
 10085ee:	9809      	ldr	r0, [sp, #36]	; 0x24
 10085f0:	e430      	b.n	1007e54 <hci_cmd_handle+0x12c>
	status = ll_wl_remove(&cmd->addr);
 10085f2:	68a0      	ldr	r0, [r4, #8]
 10085f4:	f006 fbb4 	bl	100ed60 <ll_wl_remove>
 10085f8:	e5d3      	b.n	10081a2 <hci_cmd_handle+0x47a>
	status = ll_wl_add(&cmd->addr);
 10085fa:	68a0      	ldr	r0, [r4, #8]
 10085fc:	f006 fecc 	bl	100f398 <ll_wl_add>
 1008600:	e5cf      	b.n	10081a2 <hci_cmd_handle+0x47a>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1008602:	2101      	movs	r1, #1
 1008604:	a809      	add	r0, sp, #36	; 0x24
 1008606:	f7ff fa85 	bl	1007b14 <hci_cmd_complete>
 100860a:	4604      	mov	r4, r0
	ccst->status = ll_wl_clear();
 100860c:	f006 fb78 	bl	100ed00 <ll_wl_clear>
 1008610:	7020      	strb	r0, [r4, #0]
	if (err == -EINVAL) {
 1008612:	9809      	ldr	r0, [sp, #36]	; 0x24
 1008614:	e41e      	b.n	1007e54 <hci_cmd_handle+0x12c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1008616:	2102      	movs	r1, #2
 1008618:	a809      	add	r0, sp, #36	; 0x24
 100861a:	f7ff fa7b 	bl	1007b14 <hci_cmd_complete>
	rp->status = 0x00;
 100861e:	2300      	movs	r3, #0
 1008620:	7003      	strb	r3, [r0, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1008622:	4604      	mov	r4, r0
	rp->wl_size = ll_wl_size_get();
 1008624:	f006 fb6a 	bl	100ecfc <ll_wl_size_get>
 1008628:	7060      	strb	r0, [r4, #1]
	if (err == -EINVAL) {
 100862a:	9809      	ldr	r0, [sp, #36]	; 0x24
 100862c:	e412      	b.n	1007e54 <hci_cmd_handle+0x12c>
	status = ll_adv_enable(cmd->enable);
 100862e:	68a3      	ldr	r3, [r4, #8]
 1008630:	7818      	ldrb	r0, [r3, #0]
 1008632:	f7f7 fed5 	bl	10003e0 <ll_adv_enable>
 1008636:	e5b4      	b.n	10081a2 <hci_cmd_handle+0x47a>
	status = ll_adv_scan_rsp_set(cmd->len, &cmd->data[0]);
 1008638:	68a1      	ldr	r1, [r4, #8]
 100863a:	f811 0b01 	ldrb.w	r0, [r1], #1
 100863e:	f002 fa69 	bl	100ab14 <ll_adv_scan_rsp_set>
 1008642:	e5ae      	b.n	10081a2 <hci_cmd_handle+0x47a>
	status = ll_adv_data_set(cmd->len, &cmd->data[0]);
 1008644:	68a1      	ldr	r1, [r4, #8]
 1008646:	f811 0b01 	ldrb.w	r0, [r1], #1
 100864a:	f002 fa17 	bl	100aa7c <ll_adv_data_set>
 100864e:	e5a8      	b.n	10081a2 <hci_cmd_handle+0x47a>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1008650:	2102      	movs	r1, #2
 1008652:	a809      	add	r0, sp, #36	; 0x24
 1008654:	f7ff fa5e 	bl	1007b14 <hci_cmd_complete>
	rp->status = 0x00;
 1008658:	2300      	movs	r3, #0
 100865a:	7003      	strb	r3, [r0, #0]
	rp->tx_power_level = 0;
 100865c:	7043      	strb	r3, [r0, #1]
	if (err == -EINVAL) {
 100865e:	9809      	ldr	r0, [sp, #36]	; 0x24
 1008660:	f7ff bbf8 	b.w	1007e54 <hci_cmd_handle+0x12c>
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0);
 1008664:	2300      	movs	r3, #0
		le_conn_param_req_neg_reply(cmd, evt);
 1008666:	68a2      	ldr	r2, [r4, #8]
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0);
 1008668:	2102      	movs	r1, #2
	handle = sys_le16_to_cpu(cmd->handle);
 100866a:	8815      	ldrh	r5, [r2, #0]
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0);
 100866c:	7892      	ldrb	r2, [r2, #2]
 100866e:	b2a8      	uxth	r0, r5
 1008670:	e9cd 3301 	strd	r3, r3, [sp, #4]
 1008674:	9300      	str	r3, [sp, #0]
 1008676:	f003 f8b1 	bl	100b7dc <ll_conn_update>
 100867a:	e455      	b.n	1007f28 <hci_cmd_handle+0x200>
	rp->rssi = (!rp->status) ? -rp->rssi : 127;
 100867c:	237f      	movs	r3, #127	; 0x7f
	dst[2] = val >> 16;
 100867e:	70e3      	strb	r3, [r4, #3]
	if (err == -EINVAL) {
 1008680:	e401      	b.n	1007e86 <hci_cmd_handle+0x15e>
		disconnect(cmd, evt);
 1008682:	68a3      	ldr	r3, [r4, #8]
	status = ll_terminate_ind_send(handle, cmd->reason);
 1008684:	7899      	ldrb	r1, [r3, #2]
 1008686:	8818      	ldrh	r0, [r3, #0]
 1008688:	f003 f954 	bl	100b934 <ll_terminate_ind_send>
 100868c:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
 100868e:	8828      	ldrh	r0, [r5, #0]
 1008690:	f7ff fa2c 	bl	1007aec <bt_hci_cmd_status_create>
	if (err == -EINVAL) {
 1008694:	f7ff bbde 	b.w	1007e54 <hci_cmd_handle+0x12c>
		ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1008698:	2101      	movs	r1, #1
 100869a:	a809      	add	r0, sp, #36	; 0x24
 100869c:	f7ff fa3a 	bl	1007b14 <hci_cmd_complete>
		ccst->status = BT_HCI_ERR_CMD_DISALLOWED;
 10086a0:	230c      	movs	r3, #12
 10086a2:	7003      	strb	r3, [r0, #0]
		return;
 10086a4:	f7ff bbef 	b.w	1007e86 <hci_cmd_handle+0x15e>
	return ((u64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
 10086a8:	68a1      	ldr	r1, [r4, #8]
	event_mask = sys_get_le64(cmd->events);
 10086aa:	4a22      	ldr	r2, [pc, #136]	; (1008734 <hci_cmd_handle+0xa0c>)
 10086ac:	680d      	ldr	r5, [r1, #0]
 10086ae:	684c      	ldr	r4, [r1, #4]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 10086b0:	a809      	add	r0, sp, #36	; 0x24
 10086b2:	4619      	mov	r1, r3
	event_mask = sys_get_le64(cmd->events);
 10086b4:	e9c2 5400 	strd	r5, r4, [r2]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 10086b8:	f7ff fa2c 	bl	1007b14 <hci_cmd_complete>
	ccst->status = 0x00;
 10086bc:	2300      	movs	r3, #0
 10086be:	7003      	strb	r3, [r0, #0]
	if (err == -EINVAL) {
 10086c0:	9809      	ldr	r0, [sp, #36]	; 0x24
 10086c2:	f7ff bbc7 	b.w	1007e54 <hci_cmd_handle+0x12c>
	handle = sys_le16_to_cpu(cmd->handle);
 10086c6:	68a3      	ldr	r3, [r4, #8]
	status = ll_apto_get(handle, &auth_payload_timeout);
 10086c8:	a90a      	add	r1, sp, #40	; 0x28
	handle = sys_le16_to_cpu(cmd->handle);
 10086ca:	881d      	ldrh	r5, [r3, #0]
	status = ll_apto_get(handle, &auth_payload_timeout);
 10086cc:	b2a8      	uxth	r0, r5
 10086ce:	f003 fa95 	bl	100bbfc <ll_apto_get>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 10086d2:	2105      	movs	r1, #5
	status = ll_apto_get(handle, &auth_payload_timeout);
 10086d4:	4604      	mov	r4, r0
	rp = hci_cmd_complete(evt, sizeof(*rp));
 10086d6:	a809      	add	r0, sp, #36	; 0x24
 10086d8:	f7ff fa1c 	bl	1007b14 <hci_cmd_complete>
 10086dc:	4603      	mov	r3, r0
	rp->status = status;
 10086de:	7004      	strb	r4, [r0, #0]
	rp->handle = sys_cpu_to_le16(handle);
 10086e0:	f8a0 5001 	strh.w	r5, [r0, #1]
	rp->auth_payload_timeout = sys_cpu_to_le16(auth_payload_timeout);
 10086e4:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
 10086e8:	9809      	ldr	r0, [sp, #36]	; 0x24
 10086ea:	f8a3 2003 	strh.w	r2, [r3, #3]
}
 10086ee:	f7ff bbb1 	b.w	1007e54 <hci_cmd_handle+0x12c>
	hci_hbuf_acked += count;
 10086f2:	4a11      	ldr	r2, [pc, #68]	; (1008738 <hci_cmd_handle+0xa10>)
	k_poll_signal_raise(hbuf_signal, 0x0);
 10086f4:	4911      	ldr	r1, [pc, #68]	; (100873c <hci_cmd_handle+0xa14>)
	hci_hbuf_acked += count;
 10086f6:	6813      	ldr	r3, [r2, #0]
	k_poll_signal_raise(hbuf_signal, 0x0);
 10086f8:	6808      	ldr	r0, [r1, #0]
	hci_hbuf_acked += count;
 10086fa:	4423      	add	r3, r4
 10086fc:	6013      	str	r3, [r2, #0]
 10086fe:	2100      	movs	r1, #0
 1008700:	f00c fbca 	bl	1014e98 <z_impl_k_poll_signal_raise>
 1008704:	9809      	ldr	r0, [sp, #36]	; 0x24
 1008706:	f7ff bba5 	b.w	1007e54 <hci_cmd_handle+0x12c>
		dup_count = -1;
 100870a:	f04f 32ff 	mov.w	r2, #4294967295
 100870e:	4b0c      	ldr	r3, [pc, #48]	; (1008740 <hci_cmd_handle+0xa18>)
 1008710:	601a      	str	r2, [r3, #0]
 1008712:	e5df      	b.n	10082d4 <hci_cmd_handle+0x5ac>
		if (hci_hbuf_total < 0) {
 1008714:	2b00      	cmp	r3, #0
 1008716:	f6bf ad1d 	bge.w	1008154 <hci_cmd_handle+0x42c>
 100871a:	f7ff bbb4 	b.w	1007e86 <hci_cmd_handle+0x15e>
	return bt_hci_cmd_status_create(_opcode, status);
 100871e:	2112      	movs	r1, #18
 1008720:	f7ff f9e4 	bl	1007aec <bt_hci_cmd_status_create>
	if (err == -EINVAL) {
 1008724:	f7ff bb96 	b.w	1007e54 <hci_cmd_handle+0x12c>
	return bt_hci_cmd_status_create(_opcode, status);
 1008728:	2111      	movs	r1, #17
 100872a:	f7ff f9df 	bl	1007aec <bt_hci_cmd_status_create>
		return;
 100872e:	f7ff bb91 	b.w	1007e54 <hci_cmd_handle+0x12c>
 1008732:	bf00      	nop
 1008734:	21000000 	.word	0x21000000
 1008738:	21000d5c 	.word	0x21000d5c
 100873c:	21000d58 	.word	0x21000d58
 1008740:	21000cd0 	.word	0x21000cd0

01008744 <hci_acl_handle>:
	*evt = NULL;
 1008744:	2200      	movs	r2, #0
	if (buf->len < sizeof(*acl)) {
 1008746:	8983      	ldrh	r3, [r0, #12]
{
 1008748:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (buf->len < sizeof(*acl)) {
 100874c:	2b03      	cmp	r3, #3
	*evt = NULL;
 100874e:	600a      	str	r2, [r1, #0]
	if (buf->len < sizeof(*acl)) {
 1008750:	d942      	bls.n	10087d8 <hci_acl_handle+0x94>
	acl = net_buf_pull_mem(buf, sizeof(*acl));
 1008752:	4605      	mov	r5, r0
 1008754:	460e      	mov	r6, r1
 1008756:	3008      	adds	r0, #8
 1008758:	2104      	movs	r1, #4
 100875a:	f00e fa8b 	bl	1016c74 <net_buf_simple_pull_mem>
	if (buf->len < len) {
 100875e:	89ab      	ldrh	r3, [r5, #12]
	len = sys_le16_to_cpu(acl->len);
 1008760:	8847      	ldrh	r7, [r0, #2]
	handle = sys_le16_to_cpu(acl->handle);
 1008762:	f8b0 8000 	ldrh.w	r8, [r0]
	if (buf->len < len) {
 1008766:	42bb      	cmp	r3, r7
 1008768:	d343      	bcc.n	10087f2 <hci_acl_handle+0xae>
	node_tx = ll_tx_mem_acquire();
 100876a:	f002 ffc7 	bl	100b6fc <ll_tx_mem_acquire>
	flags = bt_acl_flags(handle);
 100876e:	ea4f 3318 	mov.w	r3, r8, lsr #12
	if (!node_tx) {
 1008772:	4604      	mov	r4, r0
 1008774:	2800      	cmp	r0, #0
 1008776:	d040      	beq.n	10087fa <hci_acl_handle+0xb6>
	if (bt_acl_flags_bc(flags) != BT_ACL_POINT_TO_POINT) {
 1008778:	089a      	lsrs	r2, r3, #2
 100877a:	d102      	bne.n	1008782 <hci_acl_handle+0x3e>
	switch (bt_acl_flags_pb(flags)) {
 100877c:	b333      	cbz	r3, 10087cc <hci_acl_handle+0x88>
 100877e:	2b01      	cmp	r3, #1
 1008780:	d003      	beq.n	100878a <hci_acl_handle+0x46>
		return -EINVAL;
 1008782:	f06f 0015 	mvn.w	r0, #21
}
 1008786:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		pdu_data->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
 100878a:	7902      	ldrb	r2, [r0, #4]
 100878c:	f363 0201 	bfi	r2, r3, #0, #2
 1008790:	7102      	strb	r2, [r0, #4]
	pdu_data->len = len;
 1008792:	7167      	strb	r7, [r4, #5]
	memcpy(&pdu_data->lldata[0], buf->data, len);
 1008794:	68a9      	ldr	r1, [r5, #8]
 1008796:	463a      	mov	r2, r7
 1008798:	1de0      	adds	r0, r4, #7
 100879a:	f00e f93d 	bl	1016a18 <memcpy>
	if (ll_tx_mem_enqueue(handle, node_tx)) {
 100879e:	4621      	mov	r1, r4
 10087a0:	f3c8 000b 	ubfx	r0, r8, #0, #12
 10087a4:	f002 ffb6 	bl	100b714 <ll_tx_mem_enqueue>
 10087a8:	2800      	cmp	r0, #0
 10087aa:	d0ec      	beq.n	1008786 <hci_acl_handle+0x42>
 10087ac:	4b2a      	ldr	r3, [pc, #168]	; (1008858 <hci_acl_handle+0x114>)
 10087ae:	492b      	ldr	r1, [pc, #172]	; (100885c <hci_acl_handle+0x118>)
		BT_ERR("Invalid Tx Enqueue");
 10087b0:	482b      	ldr	r0, [pc, #172]	; (1008860 <hci_acl_handle+0x11c>)
 10087b2:	1ac9      	subs	r1, r1, r3
 10087b4:	08c9      	lsrs	r1, r1, #3
 10087b6:	0189      	lsls	r1, r1, #6
 10087b8:	f041 0101 	orr.w	r1, r1, #1
 10087bc:	f00c fe97 	bl	10154ee <log_0>
		ll_tx_mem_release(node_tx);
 10087c0:	4620      	mov	r0, r4
 10087c2:	f002 ffa1 	bl	100b708 <ll_tx_mem_release>
		return -EINVAL;
 10087c6:	f06f 0015 	mvn.w	r0, #21
 10087ca:	e7dc      	b.n	1008786 <hci_acl_handle+0x42>
		pdu_data->ll_id = PDU_DATA_LLID_DATA_START;
 10087cc:	2202      	movs	r2, #2
 10087ce:	7903      	ldrb	r3, [r0, #4]
 10087d0:	f362 0301 	bfi	r3, r2, #0, #2
 10087d4:	7103      	strb	r3, [r0, #4]
		break;
 10087d6:	e7dc      	b.n	1008792 <hci_acl_handle+0x4e>
 10087d8:	4920      	ldr	r1, [pc, #128]	; (100885c <hci_acl_handle+0x118>)
 10087da:	4b1f      	ldr	r3, [pc, #124]	; (1008858 <hci_acl_handle+0x114>)
		BT_ERR("No HCI ACL header");
 10087dc:	4821      	ldr	r0, [pc, #132]	; (1008864 <hci_acl_handle+0x120>)
 10087de:	1ac9      	subs	r1, r1, r3
 10087e0:	08c9      	lsrs	r1, r1, #3
		BT_ERR("Invalid HCI ACL packet length");
 10087e2:	0189      	lsls	r1, r1, #6
 10087e4:	f041 0101 	orr.w	r1, r1, #1
 10087e8:	f00c fe81 	bl	10154ee <log_0>
		return -EINVAL;
 10087ec:	f06f 0015 	mvn.w	r0, #21
 10087f0:	e7c9      	b.n	1008786 <hci_acl_handle+0x42>
 10087f2:	491a      	ldr	r1, [pc, #104]	; (100885c <hci_acl_handle+0x118>)
 10087f4:	4b18      	ldr	r3, [pc, #96]	; (1008858 <hci_acl_handle+0x114>)
		BT_ERR("Invalid HCI ACL packet length");
 10087f6:	481c      	ldr	r0, [pc, #112]	; (1008868 <hci_acl_handle+0x124>)
 10087f8:	e7f1      	b.n	10087de <hci_acl_handle+0x9a>
 10087fa:	4b17      	ldr	r3, [pc, #92]	; (1008858 <hci_acl_handle+0x114>)
 10087fc:	4917      	ldr	r1, [pc, #92]	; (100885c <hci_acl_handle+0x118>)
		BT_ERR("Tx Buffer Overflow");
 10087fe:	481b      	ldr	r0, [pc, #108]	; (100886c <hci_acl_handle+0x128>)
 1008800:	1ac9      	subs	r1, r1, r3
 1008802:	08c9      	lsrs	r1, r1, #3
 1008804:	0189      	lsls	r1, r1, #6
 1008806:	f041 0101 	orr.w	r1, r1, #1
 100880a:	f00c fe70 	bl	10154ee <log_0>
	if (!(event_mask & BT_EVT_MASK_DATA_BUFFER_OVERFLOW)) {
 100880e:	4623      	mov	r3, r4
 1008810:	4917      	ldr	r1, [pc, #92]	; (1008870 <hci_acl_handle+0x12c>)
 1008812:	6809      	ldr	r1, [r1, #0]
 1008814:	f001 7200 	and.w	r2, r1, #33554432	; 0x2000000
 1008818:	4313      	orrs	r3, r2
 100881a:	d102      	bne.n	1008822 <hci_acl_handle+0xde>
		return -ENOBUFS;
 100881c:	f06f 0036 	mvn.w	r0, #54	; 0x36
 1008820:	e7b1      	b.n	1008786 <hci_acl_handle+0x42>
	*buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 1008822:	f04f 33ff 	mov.w	r3, #4294967295
 1008826:	f04f 32ff 	mov.w	r2, #4294967295
 100882a:	2001      	movs	r0, #1
 100882c:	f7fd f832 	bl	1005894 <bt_buf_get_rx>
	hdr = net_buf_add(buf, sizeof(*hdr));
 1008830:	2102      	movs	r1, #2
	*buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 1008832:	6030      	str	r0, [r6, #0]
	hdr = net_buf_add(buf, sizeof(*hdr));
 1008834:	3008      	adds	r0, #8
 1008836:	f00e f9fd 	bl	1016c34 <net_buf_simple_add>
	hdr->len = len;
 100883a:	2401      	movs	r4, #1
	hdr->evt = evt;
 100883c:	221a      	movs	r2, #26
	hdr->len = len;
 100883e:	7044      	strb	r4, [r0, #1]
	hdr->evt = evt;
 1008840:	7002      	strb	r2, [r0, #0]
	ep = net_buf_add(*buf, sizeof(*ep));
 1008842:	6830      	ldr	r0, [r6, #0]
 1008844:	4621      	mov	r1, r4
 1008846:	3008      	adds	r0, #8
 1008848:	f00e f9f4 	bl	1016c34 <net_buf_simple_add>
 100884c:	4603      	mov	r3, r0
		return -ENOBUFS;
 100884e:	f06f 0036 	mvn.w	r0, #54	; 0x36
	ep->link_type = BT_OVERFLOW_LINK_ACL;
 1008852:	701c      	strb	r4, [r3, #0]
 1008854:	e797      	b.n	1008786 <hci_acl_handle+0x42>
 1008856:	bf00      	nop
 1008858:	01018208 	.word	0x01018208
 100885c:	01018230 	.word	0x01018230
 1008860:	01018780 	.word	0x01018780
 1008864:	01018738 	.word	0x01018738
 1008868:	0101874c 	.word	0x0101874c
 100886c:	0101876c 	.word	0x0101876c
 1008870:	21000000 	.word	0x21000000

01008874 <hci_disconn_complete_encode>:
{
 1008874:	b430      	push	{r4, r5}
	if (!(event_mask & BT_EVT_MASK_DISCONN_COMPLETE)) {
 1008876:	2500      	movs	r5, #0
 1008878:	4b06      	ldr	r3, [pc, #24]	; (1008894 <hci_disconn_complete_encode+0x20>)
 100887a:	681b      	ldr	r3, [r3, #0]
 100887c:	f003 0410 	and.w	r4, r3, #16
 1008880:	ea54 0305 	orrs.w	r3, r4, r5
 1008884:	d101      	bne.n	100888a <hci_disconn_complete_encode+0x16>
}
 1008886:	bc30      	pop	{r4, r5}
 1008888:	4770      	bx	lr
 100888a:	4608      	mov	r0, r1
 100888c:	bc30      	pop	{r4, r5}
 100888e:	4611      	mov	r1, r2
 1008890:	f7ff b8ee 	b.w	1007a70 <hci_disconn_complete_encode.part.0>
 1008894:	21000000 	.word	0x21000000

01008898 <hci_disconn_complete_process>:
	LL_ASSERT(handle < ARRAY_SIZE(hci_hbuf_pend));
 1008898:	280f      	cmp	r0, #15
{
 100889a:	b570      	push	{r4, r5, r6, lr}
 100889c:	4604      	mov	r4, r0
	LL_ASSERT(handle < ARRAY_SIZE(hci_hbuf_pend));
 100889e:	d80e      	bhi.n	10088be <hci_disconn_complete_process+0x26>
	hci_hbuf_pend[handle] = 0U;
 10088a0:	2600      	movs	r6, #0
	hci_hbuf_acked += hci_hbuf_pend[handle];
 10088a2:	4b0a      	ldr	r3, [pc, #40]	; (10088cc <hci_disconn_complete_process+0x34>)
 10088a4:	480a      	ldr	r0, [pc, #40]	; (10088d0 <hci_disconn_complete_process+0x38>)
	conn_count--;
 10088a6:	490b      	ldr	r1, [pc, #44]	; (10088d4 <hci_disconn_complete_process+0x3c>)
	hci_hbuf_acked += hci_hbuf_pend[handle];
 10088a8:	f833 2014 	ldrh.w	r2, [r3, r4, lsl #1]
 10088ac:	6805      	ldr	r5, [r0, #0]
	hci_hbuf_pend[handle] = 0U;
 10088ae:	f823 6014 	strh.w	r6, [r3, r4, lsl #1]
	conn_count--;
 10088b2:	680b      	ldr	r3, [r1, #0]
	hci_hbuf_acked += hci_hbuf_pend[handle];
 10088b4:	442a      	add	r2, r5
	conn_count--;
 10088b6:	3b01      	subs	r3, #1
	hci_hbuf_acked += hci_hbuf_pend[handle];
 10088b8:	6002      	str	r2, [r0, #0]
	conn_count--;
 10088ba:	600b      	str	r3, [r1, #0]
}
 10088bc:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(handle < ARRAY_SIZE(hci_hbuf_pend));
 10088be:	f640 3172 	movw	r1, #2930	; 0xb72
 10088c2:	4805      	ldr	r0, [pc, #20]	; (10088d8 <hci_disconn_complete_process+0x40>)
 10088c4:	f7fa fedc 	bl	1003680 <bt_ctlr_assert_handle>
 10088c8:	e7ea      	b.n	10088a0 <hci_disconn_complete_process+0x8>
 10088ca:	bf00      	nop
 10088cc:	21000d60 	.word	0x21000d60
 10088d0:	21000d5c 	.word	0x21000d5c
 10088d4:	21000ccc 	.word	0x21000ccc
 10088d8:	01018794 	.word	0x01018794

010088dc <hci_acl_encode>:
	u16_t handle;
	u8_t *data;

	handle = node_rx->hdr.handle;

	switch (pdu_data->ll_id) {
 10088dc:	f890 3020 	ldrb.w	r3, [r0, #32]
 10088e0:	f003 0303 	and.w	r3, r3, #3
 10088e4:	3b01      	subs	r3, #1
 10088e6:	2b01      	cmp	r3, #1
 10088e8:	d904      	bls.n	10088f4 <hci_acl_encode+0x18>
		}
#endif
		break;

	default:
		LL_ASSERT(0);
 10088ea:	f640 5161 	movw	r1, #3425	; 0xd61
 10088ee:	4823      	ldr	r0, [pc, #140]	; (100897c <hci_acl_encode+0xa0>)
 10088f0:	f7fa bec6 	b.w	1003680 <bt_ctlr_assert_handle>
{
 10088f4:	b570      	push	{r4, r5, r6, lr}
 10088f6:	4604      	mov	r4, r0
		acl = (void *)net_buf_add(buf, sizeof(*acl));
 10088f8:	f101 0508 	add.w	r5, r1, #8
 10088fc:	4628      	mov	r0, r5
 10088fe:	2104      	movs	r1, #4
	handle = node_rx->hdr.handle;
 1008900:	88e6      	ldrh	r6, [r4, #6]
		acl = (void *)net_buf_add(buf, sizeof(*acl));
 1008902:	f00e f997 	bl	1016c34 <net_buf_simple_add>
 1008906:	4603      	mov	r3, r0
		if (pdu_data->ll_id == PDU_DATA_LLID_DATA_START) {
 1008908:	f894 2020 	ldrb.w	r2, [r4, #32]
 100890c:	f002 0203 	and.w	r2, r2, #3
 1008910:	2a02      	cmp	r2, #2
			handle_flags = bt_acl_handle_pack(handle, BT_ACL_START);
 1008912:	bf0c      	ite	eq
 1008914:	f446 5200 	orreq.w	r2, r6, #8192	; 0x2000
			handle_flags = bt_acl_handle_pack(handle, BT_ACL_CONT);
 1008918:	f446 5280 	orrne.w	r2, r6, #4096	; 0x1000
		acl->handle = sys_cpu_to_le16(handle_flags);
 100891c:	8002      	strh	r2, [r0, #0]
		acl->len = sys_cpu_to_le16(pdu_data->len);
 100891e:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
		data = (void *)net_buf_add(buf, pdu_data->len);
 1008922:	4628      	mov	r0, r5
		acl->len = sys_cpu_to_le16(pdu_data->len);
 1008924:	8059      	strh	r1, [r3, #2]
		data = (void *)net_buf_add(buf, pdu_data->len);
 1008926:	f00e f985 	bl	1016c34 <net_buf_simple_add>
		memcpy(data, pdu_data->lldata, pdu_data->len);
 100892a:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
 100892e:	f104 0123 	add.w	r1, r4, #35	; 0x23
 1008932:	f00e f871 	bl	1016a18 <memcpy>
		if (hci_hbuf_total > 0) {
 1008936:	4b12      	ldr	r3, [pc, #72]	; (1008980 <hci_acl_encode+0xa4>)
 1008938:	681a      	ldr	r2, [r3, #0]
 100893a:	2a00      	cmp	r2, #0
 100893c:	dd10      	ble.n	1008960 <hci_acl_encode+0x84>
			LL_ASSERT((hci_hbuf_sent - hci_hbuf_acked) <
 100893e:	4c11      	ldr	r4, [pc, #68]	; (1008984 <hci_acl_encode+0xa8>)
 1008940:	4911      	ldr	r1, [pc, #68]	; (1008988 <hci_acl_encode+0xac>)
 1008942:	6823      	ldr	r3, [r4, #0]
 1008944:	6809      	ldr	r1, [r1, #0]
 1008946:	1a59      	subs	r1, r3, r1
 1008948:	4291      	cmp	r1, r2
 100894a:	d210      	bcs.n	100896e <hci_acl_encode+0x92>
			hci_hbuf_sent++;
 100894c:	3301      	adds	r3, #1
			LL_ASSERT(handle < ARRAY_SIZE(hci_hbuf_pend));
 100894e:	2e0f      	cmp	r6, #15
			hci_hbuf_sent++;
 1008950:	6023      	str	r3, [r4, #0]
			LL_ASSERT(handle < ARRAY_SIZE(hci_hbuf_pend));
 1008952:	d806      	bhi.n	1008962 <hci_acl_encode+0x86>
			hci_hbuf_pend[handle]++;
 1008954:	4a0d      	ldr	r2, [pc, #52]	; (100898c <hci_acl_encode+0xb0>)
 1008956:	f832 3016 	ldrh.w	r3, [r2, r6, lsl #1]
 100895a:	3301      	adds	r3, #1
 100895c:	f822 3016 	strh.w	r3, [r2, r6, lsl #1]
		break;
	}
}
 1008960:	bd70      	pop	{r4, r5, r6, pc}
			LL_ASSERT(handle < ARRAY_SIZE(hci_hbuf_pend));
 1008962:	f640 515a 	movw	r1, #3418	; 0xd5a
 1008966:	4805      	ldr	r0, [pc, #20]	; (100897c <hci_acl_encode+0xa0>)
 1008968:	f7fa fe8a 	bl	1003680 <bt_ctlr_assert_handle>
 100896c:	e7f2      	b.n	1008954 <hci_acl_encode+0x78>
			LL_ASSERT((hci_hbuf_sent - hci_hbuf_acked) <
 100896e:	f640 5154 	movw	r1, #3412	; 0xd54
 1008972:	4802      	ldr	r0, [pc, #8]	; (100897c <hci_acl_encode+0xa0>)
 1008974:	f7fa fe84 	bl	1003680 <bt_ctlr_assert_handle>
 1008978:	6823      	ldr	r3, [r4, #0]
 100897a:	e7e7      	b.n	100894c <hci_acl_encode+0x70>
 100897c:	01018794 	.word	0x01018794
 1008980:	21000d84 	.word	0x21000d84
 1008984:	21000d80 	.word	0x21000d80
 1008988:	21000d5c 	.word	0x21000d5c
 100898c:	21000d60 	.word	0x21000d60

01008990 <hci_evt_encode>:
#endif /* CONFIG_BT_CONN */

void hci_evt_encode(struct node_rx_pdu *node_rx, struct net_buf *buf)
{
 1008990:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct pdu_data *pdu_data = PDU_DATA(node_rx);

	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
 1008994:	7905      	ldrb	r5, [r0, #4]
{
 1008996:	4604      	mov	r4, r0
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
 1008998:	2d02      	cmp	r5, #2
{
 100899a:	460e      	mov	r6, r1
 100899c:	b08b      	sub	sp, #44	; 0x2c
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
 100899e:	d010      	beq.n	10089c2 <hci_evt_encode+0x32>
	handle = node_rx->hdr.handle;
 10089a0:	3d04      	subs	r5, #4
 10089a2:	88c7      	ldrh	r7, [r0, #6]
	switch (node_rx->hdr.type) {
 10089a4:	2d0a      	cmp	r5, #10
 10089a6:	d828      	bhi.n	10089fa <hci_evt_encode+0x6a>
 10089a8:	e8df f015 	tbh	[pc, r5, lsl #1]
 10089ac:	0027002f 	.word	0x0027002f
 10089b0:	00270027 	.word	0x00270027
 10089b4:	0198014b 	.word	0x0198014b
 10089b8:	01e501c0 	.word	0x01e501c0
 10089bc:	01300119 	.word	0x01300119
 10089c0:	00e0      	.short	0x00e0
		encode_control(node_rx, pdu_data, buf);
	} else if (IS_ENABLED(CONFIG_BT_CONN)) {
		encode_data_ctrl(node_rx, pdu_data, buf);
 10089c2:	f890 3023 	ldrb.w	r3, [r0, #35]	; 0x23
 10089c6:	88c5      	ldrh	r5, [r0, #6]
	switch (pdu_data->llctrl.opcode) {
 10089c8:	3b03      	subs	r3, #3
 10089ca:	2b12      	cmp	r3, #18
 10089cc:	f200 81ed 	bhi.w	1008daa <hci_evt_encode+0x41a>
 10089d0:	e8df f013 	tbh	[pc, r3, lsl #1]
 10089d4:	01eb0254 	.word	0x01eb0254
 10089d8:	02c401eb 	.word	0x02c401eb
 10089dc:	01eb02ac 	.word	0x01eb02ac
 10089e0:	01eb02bc 	.word	0x01eb02bc
 10089e4:	027a01eb 	.word	0x027a01eb
 10089e8:	01eb029d 	.word	0x01eb029d
 10089ec:	01eb0234 	.word	0x01eb0234
 10089f0:	01eb01eb 	.word	0x01eb01eb
 10089f4:	01f101eb 	.word	0x01f101eb
 10089f8:	01f1      	.short	0x01f1
		LL_ASSERT(0);
 10089fa:	f640 416c 	movw	r1, #3180	; 0xc6c
 10089fe:	48be      	ldr	r0, [pc, #760]	; (1008cf8 <hci_evt_encode+0x368>)
 1008a00:	f7fa fe3e 	bl	1003680 <bt_ctlr_assert_handle>
	}
}
 1008a04:	b00b      	add	sp, #44	; 0x2c
 1008a06:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	rssi = -(node_rx->hdr.rx_ftr.rssi);
 1008a0a:	7f03      	ldrb	r3, [r0, #28]
	const u8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
 1008a0c:	4abb      	ldr	r2, [pc, #748]	; (1008cfc <hci_evt_encode+0x36c>)
	if (adv->tx_addr) {
 1008a0e:	f890 5020 	ldrb.w	r5, [r0, #32]
	rssi = -(node_rx->hdr.rx_ftr.rssi);
 1008a12:	425b      	negs	r3, r3
	const u8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
 1008a14:	e892 0003 	ldmia.w	r2, {r0, r1}
	rssi = -(node_rx->hdr.rx_ftr.rssi);
 1008a18:	b25b      	sxtb	r3, r3
	const u8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
 1008a1a:	0c0a      	lsrs	r2, r1, #16
	if (adv->tx_addr) {
 1008a1c:	066f      	lsls	r7, r5, #25
	rl_idx = node_rx->hdr.rx_ftr.rl_idx;
 1008a1e:	f894 b01e 	ldrb.w	fp, [r4, #30]
	direct = node_rx->hdr.rx_ftr.direct;
 1008a22:	f894 801f 	ldrb.w	r8, [r4, #31]
	const u8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
 1008a26:	9006      	str	r0, [sp, #24]
 1008a28:	f8ad 101c 	strh.w	r1, [sp, #28]
 1008a2c:	f88d 201e 	strb.w	r2, [sp, #30]
	rssi = -(node_rx->hdr.rx_ftr.rssi);
 1008a30:	9305      	str	r3, [sp, #20]
	if (adv->tx_addr) {
 1008a32:	f100 82a1 	bmi.w	1008f78 <hci_evt_encode+0x5e8>
	if (direct) {
 1008a36:	f1b8 0f00 	cmp.w	r8, #0
 1008a3a:	f040 82d5 	bne.w	1008fe8 <hci_evt_encode+0x658>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008a3e:	4642      	mov	r2, r8
 1008a40:	49af      	ldr	r1, [pc, #700]	; (1008d00 <hci_evt_encode+0x370>)
 1008a42:	6849      	ldr	r1, [r1, #4]
 1008a44:	f001 5300 	and.w	r3, r1, #536870912	; 0x20000000
 1008a48:	4313      	orrs	r3, r2
 1008a4a:	d0db      	beq.n	1008a04 <hci_evt_encode+0x74>
	    !(le_event_mask & BT_EVT_MASK_LE_ADVERTISING_REPORT)) {
 1008a4c:	4643      	mov	r3, r8
 1008a4e:	49ad      	ldr	r1, [pc, #692]	; (1008d04 <hci_evt_encode+0x374>)
 1008a50:	6809      	ldr	r1, [r1, #0]
 1008a52:	f001 0202 	and.w	r2, r1, #2
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008a56:	4313      	orrs	r3, r2
 1008a58:	d0d4      	beq.n	1008a04 <hci_evt_encode+0x74>
	if (dup_count >= 0) {
 1008a5a:	f8df 92cc 	ldr.w	r9, [pc, #716]	; 1008d28 <hci_evt_encode+0x398>
 1008a5e:	f8d9 2000 	ldr.w	r2, [r9]
 1008a62:	2a00      	cmp	r2, #0
 1008a64:	db48      	blt.n	1008af8 <hci_evt_encode+0x168>
		for (i = 0; i < dup_count; i++) {
 1008a66:	bf08      	it	eq
 1008a68:	f104 0a22 	addeq.w	sl, r4, #34	; 0x22
 1008a6c:	d019      	beq.n	1008aa2 <hci_evt_encode+0x112>
 1008a6e:	4647      	mov	r7, r8
 1008a70:	4da5      	ldr	r5, [pc, #660]	; (1008d08 <hci_evt_encode+0x378>)
 1008a72:	f104 0a22 	add.w	sl, r4, #34	; 0x22
			if (!memcmp(&adv->adv_ind.addr[0],
 1008a76:	2206      	movs	r2, #6
 1008a78:	4629      	mov	r1, r5
 1008a7a:	4650      	mov	r0, sl
 1008a7c:	f00d ffbc 	bl	10169f8 <memcmp>
 1008a80:	b940      	cbnz	r0, 1008a94 <hci_evt_encode+0x104>
			    adv->tx_addr == dup_filter[i].addr.type) {
 1008a82:	f894 2020 	ldrb.w	r2, [r4, #32]
 1008a86:	f815 1c01 	ldrb.w	r1, [r5, #-1]
 1008a8a:	f3c2 1080 	ubfx	r0, r2, #6, #1
				    sizeof(bt_addr_t)) &&
 1008a8e:	4288      	cmp	r0, r1
 1008a90:	f000 8388 	beq.w	10091a4 <hci_evt_encode+0x814>
		for (i = 0; i < dup_count; i++) {
 1008a94:	f8d9 2000 	ldr.w	r2, [r9]
 1008a98:	3701      	adds	r7, #1
 1008a9a:	4297      	cmp	r7, r2
 1008a9c:	f105 0508 	add.w	r5, r5, #8
 1008aa0:	dbe9      	blt.n	1008a76 <hci_evt_encode+0xe6>
		memcpy(&dup_filter[dup_curr].addr.a.val[0],
 1008aa2:	4d9a      	ldr	r5, [pc, #616]	; (1008d0c <hci_evt_encode+0x37c>)
 1008aa4:	4f9a      	ldr	r7, [pc, #616]	; (1008d10 <hci_evt_encode+0x380>)
 1008aa6:	682a      	ldr	r2, [r5, #0]
 1008aa8:	4651      	mov	r1, sl
 1008aaa:	eb07 02c2 	add.w	r2, r7, r2, lsl #3
 1008aae:	1c90      	adds	r0, r2, #2
 1008ab0:	2206      	movs	r2, #6
 1008ab2:	f00d ffb1 	bl	1016a18 <memcpy>
		dup_filter[dup_curr].mask = BIT(adv->type);
 1008ab6:	2101      	movs	r1, #1
		dup_filter[dup_curr].addr.type = adv->tx_addr;
 1008ab8:	682a      	ldr	r2, [r5, #0]
 1008aba:	f894 0020 	ldrb.w	r0, [r4, #32]
 1008abe:	eb07 0cc2 	add.w	ip, r7, r2, lsl #3
 1008ac2:	f3c0 1080 	ubfx	r0, r0, #6, #1
 1008ac6:	f88c 0001 	strb.w	r0, [ip, #1]
		dup_filter[dup_curr].mask = BIT(adv->type);
 1008aca:	f894 0020 	ldrb.w	r0, [r4, #32]
		if (dup_count < CONFIG_BT_CTLR_DUP_FILTER_LEN) {
 1008ace:	f8d9 3000 	ldr.w	r3, [r9]
		dup_filter[dup_curr].mask = BIT(adv->type);
 1008ad2:	f000 000f 	and.w	r0, r0, #15
		if (dup_count < CONFIG_BT_CTLR_DUP_FILTER_LEN) {
 1008ad6:	2b0f      	cmp	r3, #15
		dup_filter[dup_curr].mask = BIT(adv->type);
 1008ad8:	fa01 f100 	lsl.w	r1, r1, r0
 1008adc:	f807 1032 	strb.w	r1, [r7, r2, lsl #3]
			dup_count++;
 1008ae0:	bfdb      	ittet	le
 1008ae2:	1c59      	addle	r1, r3, #1
			dup_curr = dup_count;
 1008ae4:	460a      	movle	r2, r1
			dup_curr++;
 1008ae6:	3201      	addgt	r2, #1
			dup_count++;
 1008ae8:	f8c9 1000 	strle.w	r1, [r9]
		if (dup_curr == CONFIG_BT_CTLR_DUP_FILTER_LEN) {
 1008aec:	2a10      	cmp	r2, #16
			dup_curr = 0U;
 1008aee:	bf08      	it	eq
 1008af0:	2300      	moveq	r3, #0
			dup_curr++;
 1008af2:	602a      	str	r2, [r5, #0]
			dup_curr = 0U;
 1008af4:	bf08      	it	eq
 1008af6:	602b      	streq	r3, [r5, #0]
	if (adv->type != PDU_ADV_TYPE_DIRECT_IND) {
 1008af8:	f894 3020 	ldrb.w	r3, [r4, #32]
 1008afc:	f003 030f 	and.w	r3, r3, #15
 1008b00:	2b01      	cmp	r3, #1
 1008b02:	f000 834c 	beq.w	100919e <hci_evt_encode+0x80e>
		data_len = (adv->len - BDADDR_SIZE);
 1008b06:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 1008b0a:	f1a3 0806 	sub.w	r8, r3, #6
 1008b0e:	fa5f f888 	uxtb.w	r8, r8
 1008b12:	4647      	mov	r7, r8
 1008b14:	3305      	adds	r3, #5
 1008b16:	b2da      	uxtb	r2, r3
	sep = meta_evt(buf, BT_HCI_EVT_LE_ADVERTISING_REPORT,
 1008b18:	2102      	movs	r1, #2
 1008b1a:	4630      	mov	r0, r6
 1008b1c:	f7fe ff40 	bl	10079a0 <meta_evt>
	sep->num_reports = 1U;
 1008b20:	2301      	movs	r3, #1
 1008b22:	7003      	strb	r3, [r0, #0]
	adv_info->evt_type = c_adv_type[adv->type];
 1008b24:	f894 3020 	ldrb.w	r3, [r4, #32]
 1008b28:	aa0a      	add	r2, sp, #40	; 0x28
 1008b2a:	f003 030f 	and.w	r3, r3, #15
 1008b2e:	4413      	add	r3, r2
 1008b30:	f813 3c10 	ldrb.w	r3, [r3, #-16]
	sep = meta_evt(buf, BT_HCI_EVT_LE_ADVERTISING_REPORT,
 1008b34:	4605      	mov	r5, r0
	adv_info->evt_type = c_adv_type[adv->type];
 1008b36:	7043      	strb	r3, [r0, #1]
	if (rl_idx < ll_rl_size_get()) {
 1008b38:	f006 f978 	bl	100ee2c <ll_rl_size_get>
 1008b3c:	4583      	cmp	fp, r0
 1008b3e:	f080 8322 	bcs.w	1009186 <hci_evt_encode+0x7f6>
		ll_rl_id_addr_get(rl_idx, &adv_info->addr.type,
 1008b42:	4658      	mov	r0, fp
 1008b44:	1cea      	adds	r2, r5, #3
 1008b46:	1ca9      	adds	r1, r5, #2
 1008b48:	f006 f944 	bl	100edd4 <ll_rl_id_addr_get>
		adv_info->addr.type += 2U;
 1008b4c:	78ab      	ldrb	r3, [r5, #2]
 1008b4e:	3302      	adds	r3, #2
 1008b50:	70ab      	strb	r3, [r5, #2]
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
 1008b52:	f105 060a 	add.w	r6, r5, #10
 1008b56:	4630      	mov	r0, r6
 1008b58:	463a      	mov	r2, r7
	adv_info->length = data_len;
 1008b5a:	f885 8009 	strb.w	r8, [r5, #9]
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
 1008b5e:	f104 0128 	add.w	r1, r4, #40	; 0x28
 1008b62:	f00d ff59 	bl	1016a18 <memcpy>
	*prssi = rssi;
 1008b66:	9b05      	ldr	r3, [sp, #20]
 1008b68:	55f3      	strb	r3, [r6, r7]
 1008b6a:	e74b      	b.n	1008a04 <hci_evt_encode+0x74>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008b6c:	2100      	movs	r1, #0
 1008b6e:	460a      	mov	r2, r1
 1008b70:	4863      	ldr	r0, [pc, #396]	; (1008d00 <hci_evt_encode+0x370>)
 1008b72:	6840      	ldr	r0, [r0, #4]
 1008b74:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
 1008b78:	4313      	orrs	r3, r2
 1008b7a:	d007      	beq.n	1008b8c <hci_evt_encode+0x1fc>
	    !(le_event_mask & BT_EVT_MASK_LE_PHY_UPDATE_COMPLETE)) {
 1008b7c:	460b      	mov	r3, r1
 1008b7e:	4861      	ldr	r0, [pc, #388]	; (1008d04 <hci_evt_encode+0x374>)
 1008b80:	6800      	ldr	r0, [r0, #0]
 1008b82:	f400 6200 	and.w	r2, r0, #2048	; 0x800
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008b86:	4313      	orrs	r3, r2
 1008b88:	f040 8135 	bne.w	1008df6 <hci_evt_encode+0x466>
 1008b8c:	f894 0021 	ldrb.w	r0, [r4, #33]	; 0x21
 1008b90:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 1008b94:	fa90 f1a0 	rbit	r1, r0
 1008b98:	fa93 f2a3 	rbit	r2, r3
 1008b9c:	2800      	cmp	r0, #0
 1008b9e:	fab1 f181 	clz	r1, r1
 1008ba2:	bf08      	it	eq
 1008ba4:	f04f 31ff 	moveq.w	r1, #4294967295
 1008ba8:	2b00      	cmp	r3, #0
 1008baa:	fab2 f282 	clz	r2, r2
 1008bae:	bf08      	it	eq
 1008bb0:	f04f 32ff 	moveq.w	r2, #4294967295
 1008bb4:	4857      	ldr	r0, [pc, #348]	; (1008d14 <hci_evt_encode+0x384>)
 1008bb6:	4b58      	ldr	r3, [pc, #352]	; (1008d18 <hci_evt_encode+0x388>)
		BT_WARN("handle: 0x%04x, status: %x, tx: %x, rx: %x.", handle,
 1008bb8:	f894 5020 	ldrb.w	r5, [r4, #32]
 1008bbc:	1a1b      	subs	r3, r3, r0
 1008bbe:	08db      	lsrs	r3, r3, #3
 1008bc0:	1c48      	adds	r0, r1, #1
 1008bc2:	019b      	lsls	r3, r3, #6
 1008bc4:	1c54      	adds	r4, r2, #1
 1008bc6:	9008      	str	r0, [sp, #32]
 1008bc8:	2204      	movs	r2, #4
 1008bca:	4854      	ldr	r0, [pc, #336]	; (1008d1c <hci_evt_encode+0x38c>)
 1008bcc:	f043 0302 	orr.w	r3, r3, #2
 1008bd0:	a906      	add	r1, sp, #24
 1008bd2:	9706      	str	r7, [sp, #24]
 1008bd4:	9409      	str	r4, [sp, #36]	; 0x24
 1008bd6:	9507      	str	r5, [sp, #28]
 1008bd8:	f00c fcdf 	bl	101559a <log_n>
		return;
 1008bdc:	e712      	b.n	1008a04 <hci_evt_encode+0x74>
	if (!(event_mask_page_2 & BT_EVT_MASK_AUTH_PAYLOAD_TIMEOUT_EXP)) {
 1008bde:	2300      	movs	r3, #0
 1008be0:	494f      	ldr	r1, [pc, #316]	; (1008d20 <hci_evt_encode+0x390>)
 1008be2:	6809      	ldr	r1, [r1, #0]
 1008be4:	f401 0200 	and.w	r2, r1, #8388608	; 0x800000
 1008be8:	4313      	orrs	r3, r2
 1008bea:	f43f af0b 	beq.w	1008a04 <hci_evt_encode+0x74>
	hdr = net_buf_add(buf, sizeof(*hdr));
 1008bee:	3608      	adds	r6, #8
 1008bf0:	2102      	movs	r1, #2
 1008bf2:	4630      	mov	r0, r6
 1008bf4:	f00e f81e 	bl	1016c34 <net_buf_simple_add>
	hdr->evt = evt;
 1008bf8:	2257      	movs	r2, #87	; 0x57
	hdr = net_buf_add(buf, sizeof(*hdr));
 1008bfa:	4603      	mov	r3, r0
	hdr->len = len;
 1008bfc:	2102      	movs	r1, #2
	ep = net_buf_add(buf, sizeof(*ep));
 1008bfe:	4630      	mov	r0, r6
	hdr->evt = evt;
 1008c00:	701a      	strb	r2, [r3, #0]
	hdr->len = len;
 1008c02:	7059      	strb	r1, [r3, #1]
	ep = net_buf_add(buf, sizeof(*ep));
 1008c04:	f00e f816 	bl	1016c34 <net_buf_simple_add>
	ep->handle = sys_cpu_to_le16(handle);
 1008c08:	8007      	strh	r7, [r0, #0]
 1008c0a:	e6fb      	b.n	1008a04 <hci_evt_encode+0x74>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008c0c:	2100      	movs	r1, #0
 1008c0e:	460a      	mov	r2, r1
 1008c10:	483b      	ldr	r0, [pc, #236]	; (1008d00 <hci_evt_encode+0x370>)
 1008c12:	6840      	ldr	r0, [r0, #4]
 1008c14:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
 1008c18:	4313      	orrs	r3, r2
 1008c1a:	f43f aef3 	beq.w	1008a04 <hci_evt_encode+0x74>
	    !(le_event_mask & BT_EVT_MASK_LE_CHAN_SEL_ALGO)) {
 1008c1e:	460b      	mov	r3, r1
 1008c20:	4838      	ldr	r0, [pc, #224]	; (1008d04 <hci_evt_encode+0x374>)
 1008c22:	6800      	ldr	r0, [r0, #0]
 1008c24:	f400 2200 	and.w	r2, r0, #524288	; 0x80000
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008c28:	4313      	orrs	r3, r2
 1008c2a:	f43f aeeb 	beq.w	1008a04 <hci_evt_encode+0x74>
	sep = meta_evt(buf, BT_HCI_EVT_LE_CHAN_SEL_ALGO, sizeof(*sep));
 1008c2e:	4630      	mov	r0, r6
 1008c30:	2203      	movs	r2, #3
 1008c32:	2114      	movs	r1, #20
 1008c34:	f7fe feb4 	bl	10079a0 <meta_evt>
	sep->handle = sys_cpu_to_le16(handle);
 1008c38:	8007      	strh	r7, [r0, #0]
	sep->chan_sel_algo = cs->csa;
 1008c3a:	f894 3020 	ldrb.w	r3, [r4, #32]
 1008c3e:	7083      	strb	r3, [r0, #2]
 1008c40:	e6e0      	b.n	1008a04 <hci_evt_encode+0x74>
	u8_t status = node_rx->status;
 1008c42:	f890 5020 	ldrb.w	r5, [r0, #32]
	if (!status) {
 1008c46:	2d00      	cmp	r5, #0
 1008c48:	f000 819e 	beq.w	1008f88 <hci_evt_encode+0x5f8>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008c4c:	f04f 0800 	mov.w	r8, #0
 1008c50:	4642      	mov	r2, r8
 1008c52:	492b      	ldr	r1, [pc, #172]	; (1008d00 <hci_evt_encode+0x370>)
 1008c54:	6849      	ldr	r1, [r1, #4]
 1008c56:	f001 5300 	and.w	r3, r1, #536870912	; 0x20000000
 1008c5a:	4313      	orrs	r3, r2
 1008c5c:	f43f aed2 	beq.w	1008a04 <hci_evt_encode+0x74>
	    (!(le_event_mask & BT_EVT_MASK_LE_CONN_COMPLETE) &&
 1008c60:	f240 2e01 	movw	lr, #513	; 0x201
 1008c64:	4643      	mov	r3, r8
 1008c66:	f8df c09c 	ldr.w	ip, [pc, #156]	; 1008d04 <hci_evt_encode+0x374>
	     !(le_event_mask & BT_EVT_MASK_LE_ENH_CONN_COMPLETE))) {
 1008c6a:	4641      	mov	r1, r8
	    (!(le_event_mask & BT_EVT_MASK_LE_CONN_COMPLETE) &&
 1008c6c:	f8dc c000 	ldr.w	ip, [ip]
 1008c70:	ea0c 020e 	and.w	r2, ip, lr
 1008c74:	4313      	orrs	r3, r2
	     !(le_event_mask & BT_EVT_MASK_LE_ENH_CONN_COMPLETE))) {
 1008c76:	f40c 7000 	and.w	r0, ip, #512	; 0x200
	    (!(le_event_mask & BT_EVT_MASK_LE_CONN_COMPLETE) &&
 1008c7a:	f43f aec3 	beq.w	1008a04 <hci_evt_encode+0x74>
	if (!status) {
 1008c7e:	2d00      	cmp	r5, #0
 1008c80:	f040 8196 	bne.w	1008fb0 <hci_evt_encode+0x620>
		conn_count++;
 1008c84:	4a27      	ldr	r2, [pc, #156]	; (1008d24 <hci_evt_encode+0x394>)
 1008c86:	6813      	ldr	r3, [r2, #0]
 1008c88:	3301      	adds	r3, #1
 1008c8a:	6013      	str	r3, [r2, #0]
	if (le_event_mask & BT_EVT_MASK_LE_ENH_CONN_COMPLETE) {
 1008c8c:	ea50 0301 	orrs.w	r3, r0, r1
		leecc = meta_evt(buf, BT_HCI_EVT_LE_ENH_CONN_COMPLETE,
 1008c90:	4630      	mov	r0, r6
	if (le_event_mask & BT_EVT_MASK_LE_ENH_CONN_COMPLETE) {
 1008c92:	f040 8249 	bne.w	1009128 <hci_evt_encode+0x798>
	lecc = meta_evt(buf, BT_HCI_EVT_LE_CONN_COMPLETE, sizeof(*lecc));
 1008c96:	2212      	movs	r2, #18
 1008c98:	2101      	movs	r1, #1
 1008c9a:	f7fe fe81 	bl	10079a0 <meta_evt>
 1008c9e:	4606      	mov	r6, r0
	lecc->status = 0x00;
 1008ca0:	7005      	strb	r5, [r0, #0]
	lecc->handle = sys_cpu_to_le16(handle);
 1008ca2:	f8a0 7001 	strh.w	r7, [r0, #1]
	lecc->role = node_rx->role;
 1008ca6:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
	memcpy(&lecc->peer_addr.a.val[0], &node_rx->peer_addr[0], BDADDR_SIZE);
 1008caa:	2206      	movs	r2, #6
	lecc->role = node_rx->role;
 1008cac:	70f3      	strb	r3, [r6, #3]
	lecc->peer_addr.type = node_rx->peer_addr_type & 0x1;
 1008cae:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
	memcpy(&lecc->peer_addr.a.val[0], &node_rx->peer_addr[0], BDADDR_SIZE);
 1008cb2:	f104 0123 	add.w	r1, r4, #35	; 0x23
	lecc->peer_addr.type = node_rx->peer_addr_type & 0x1;
 1008cb6:	f003 0301 	and.w	r3, r3, #1
 1008cba:	7133      	strb	r3, [r6, #4]
	memcpy(&lecc->peer_addr.a.val[0], &node_rx->peer_addr[0], BDADDR_SIZE);
 1008cbc:	3005      	adds	r0, #5
 1008cbe:	f00d feab 	bl	1016a18 <memcpy>
	lecc->supv_timeout = sys_cpu_to_le16(node_rx->timeout);
 1008cc2:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
	lecc->interval = sys_cpu_to_le16(node_rx->interval);
 1008cc4:	8ee1      	ldrh	r1, [r4, #54]	; 0x36
	lecc->latency = sys_cpu_to_le16(node_rx->latency);
 1008cc6:	8f22      	ldrh	r2, [r4, #56]	; 0x38
	lecc->interval = sys_cpu_to_le16(node_rx->interval);
 1008cc8:	f8a6 100b 	strh.w	r1, [r6, #11]
	lecc->latency = sys_cpu_to_le16(node_rx->latency);
 1008ccc:	f8a6 200d 	strh.w	r2, [r6, #13]
	lecc->supv_timeout = sys_cpu_to_le16(node_rx->timeout);
 1008cd0:	f8a6 300f 	strh.w	r3, [r6, #15]
	lecc->clock_accuracy = node_rx->sca;
 1008cd4:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 1008cd8:	7473      	strb	r3, [r6, #17]
 1008cda:	e693      	b.n	1008a04 <hci_evt_encode+0x74>
	if (!(event_mask & BT_EVT_MASK_DISCONN_COMPLETE)) {
 1008cdc:	2300      	movs	r3, #0
 1008cde:	4908      	ldr	r1, [pc, #32]	; (1008d00 <hci_evt_encode+0x370>)
 1008ce0:	6809      	ldr	r1, [r1, #0]
 1008ce2:	f001 0210 	and.w	r2, r1, #16
 1008ce6:	4313      	orrs	r3, r2
 1008ce8:	f43f ae8c 	beq.w	1008a04 <hci_evt_encode+0x74>
 1008cec:	4631      	mov	r1, r6
 1008cee:	4638      	mov	r0, r7
 1008cf0:	f7fe febe 	bl	1007a70 <hci_disconn_complete_encode.part.0>
 1008cf4:	e686      	b.n	1008a04 <hci_evt_encode+0x74>
 1008cf6:	bf00      	nop
 1008cf8:	01018794 	.word	0x01018794
 1008cfc:	01018340 	.word	0x01018340
 1008d00:	21000000 	.word	0x21000000
 1008d04:	21000008 	.word	0x21000008
 1008d08:	21000cda 	.word	0x21000cda
 1008d0c:	21000cd4 	.word	0x21000cd4
 1008d10:	21000cd8 	.word	0x21000cd8
 1008d14:	01018208 	.word	0x01018208
 1008d18:	01018230 	.word	0x01018230
 1008d1c:	010187d0 	.word	0x010187d0
 1008d20:	21000718 	.word	0x21000718
 1008d24:	21000ccc 	.word	0x21000ccc
 1008d28:	21000cd0 	.word	0x21000cd0
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008d2c:	2100      	movs	r1, #0
 1008d2e:	460a      	mov	r2, r1
 1008d30:	48a7      	ldr	r0, [pc, #668]	; (1008fd0 <hci_evt_encode+0x640>)
 1008d32:	6840      	ldr	r0, [r0, #4]
 1008d34:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
 1008d38:	4313      	orrs	r3, r2
 1008d3a:	f43f ae63 	beq.w	1008a04 <hci_evt_encode+0x74>
	    !(le_event_mask & BT_EVT_MASK_LE_CONN_UPDATE_COMPLETE)) {
 1008d3e:	460b      	mov	r3, r1
 1008d40:	48a4      	ldr	r0, [pc, #656]	; (1008fd4 <hci_evt_encode+0x644>)
 1008d42:	6800      	ldr	r0, [r0, #0]
 1008d44:	f000 0204 	and.w	r2, r0, #4
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008d48:	4313      	orrs	r3, r2
 1008d4a:	f43f ae5b 	beq.w	1008a04 <hci_evt_encode+0x74>
	sep = meta_evt(buf, BT_HCI_EVT_LE_CONN_UPDATE_COMPLETE, sizeof(*sep));
 1008d4e:	2209      	movs	r2, #9
 1008d50:	2103      	movs	r1, #3
 1008d52:	4630      	mov	r0, r6
 1008d54:	f7fe fe24 	bl	10079a0 <meta_evt>
	sep->status = cu->status;
 1008d58:	f894 3020 	ldrb.w	r3, [r4, #32]
	sep->handle = sys_cpu_to_le16(handle);
 1008d5c:	f8a0 7001 	strh.w	r7, [r0, #1]
	sep->status = cu->status;
 1008d60:	7003      	strb	r3, [r0, #0]
	sep->interval = sys_cpu_to_le16(cu->interval);
 1008d62:	8c61      	ldrh	r1, [r4, #34]	; 0x22
	sep->latency = sys_cpu_to_le16(cu->latency);
 1008d64:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
	sep->supv_timeout = sys_cpu_to_le16(cu->timeout);
 1008d66:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
	sep->interval = sys_cpu_to_le16(cu->interval);
 1008d68:	f8a0 1003 	strh.w	r1, [r0, #3]
	sep->latency = sys_cpu_to_le16(cu->latency);
 1008d6c:	f8a0 2005 	strh.w	r2, [r0, #5]
	sep->supv_timeout = sys_cpu_to_le16(cu->timeout);
 1008d70:	f8a0 3007 	strh.w	r3, [r0, #7]
 1008d74:	e646      	b.n	1008a04 <hci_evt_encode+0x74>
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_KEY_REFRESH_COMPLETE)) {
 1008d76:	2400      	movs	r4, #0
 1008d78:	4622      	mov	r2, r4
 1008d7a:	4995      	ldr	r1, [pc, #596]	; (1008fd0 <hci_evt_encode+0x640>)
 1008d7c:	6849      	ldr	r1, [r1, #4]
 1008d7e:	f401 4300 	and.w	r3, r1, #32768	; 0x8000
 1008d82:	4313      	orrs	r3, r2
 1008d84:	f43f ae3e 	beq.w	1008a04 <hci_evt_encode+0x74>
	hdr = net_buf_add(buf, sizeof(*hdr));
 1008d88:	3608      	adds	r6, #8
 1008d8a:	2102      	movs	r1, #2
 1008d8c:	4630      	mov	r0, r6
 1008d8e:	f00d ff51 	bl	1016c34 <net_buf_simple_add>
	hdr->evt = evt;
 1008d92:	2230      	movs	r2, #48	; 0x30
	hdr = net_buf_add(buf, sizeof(*hdr));
 1008d94:	4603      	mov	r3, r0
	hdr->len = len;
 1008d96:	2103      	movs	r1, #3
	ep = net_buf_add(buf, sizeof(*ep));
 1008d98:	4630      	mov	r0, r6
	hdr->evt = evt;
 1008d9a:	701a      	strb	r2, [r3, #0]
	hdr->len = len;
 1008d9c:	7059      	strb	r1, [r3, #1]
	ep = net_buf_add(buf, sizeof(*ep));
 1008d9e:	f00d ff49 	bl	1016c34 <net_buf_simple_add>
	ep->status = 0x00;
 1008da2:	7004      	strb	r4, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
 1008da4:	f8a0 7001 	strh.w	r7, [r0, #1]
 1008da8:	e62c      	b.n	1008a04 <hci_evt_encode+0x74>
		LL_ASSERT(0);
 1008daa:	f640 5135 	movw	r1, #3381	; 0xd35
 1008dae:	488a      	ldr	r0, [pc, #552]	; (1008fd8 <hci_evt_encode+0x648>)
 1008db0:	f7fa fc66 	bl	1003680 <bt_ctlr_assert_handle>
}
 1008db4:	e626      	b.n	1008a04 <hci_evt_encode+0x74>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008db6:	2100      	movs	r1, #0
 1008db8:	460a      	mov	r2, r1
 1008dba:	4885      	ldr	r0, [pc, #532]	; (1008fd0 <hci_evt_encode+0x640>)
 1008dbc:	6840      	ldr	r0, [r0, #4]
 1008dbe:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
 1008dc2:	4313      	orrs	r3, r2
 1008dc4:	f43f ae1e 	beq.w	1008a04 <hci_evt_encode+0x74>
	    !(le_event_mask & BT_EVT_MASK_LE_DATA_LEN_CHANGE)) {
 1008dc8:	460b      	mov	r3, r1
 1008dca:	4882      	ldr	r0, [pc, #520]	; (1008fd4 <hci_evt_encode+0x644>)
 1008dcc:	6800      	ldr	r0, [r0, #0]
 1008dce:	f000 0240 	and.w	r2, r0, #64	; 0x40
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008dd2:	4313      	orrs	r3, r2
 1008dd4:	f43f ae16 	beq.w	1008a04 <hci_evt_encode+0x74>
	sep = meta_evt(buf, BT_HCI_EVT_LE_DATA_LEN_CHANGE, sizeof(*sep));
 1008dd8:	4630      	mov	r0, r6
 1008dda:	220a      	movs	r2, #10
 1008ddc:	2107      	movs	r1, #7
 1008dde:	f7fe fddf 	bl	10079a0 <meta_evt>
	sep->handle = sys_cpu_to_le16(handle);
 1008de2:	8005      	strh	r5, [r0, #0]
	sep->max_tx_octets = pdu_data->llctrl.length_rsp.max_tx_octets;
 1008de4:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 1008de6:	8043      	strh	r3, [r0, #2]
	sep->max_tx_time = pdu_data->llctrl.length_rsp.max_tx_time;
 1008de8:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 1008dea:	8083      	strh	r3, [r0, #4]
	sep->max_rx_octets = pdu_data->llctrl.length_rsp.max_rx_octets;
 1008dec:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
 1008dee:	80c3      	strh	r3, [r0, #6]
	sep->max_rx_time = pdu_data->llctrl.length_rsp.max_rx_time;
 1008df0:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 1008df2:	8103      	strh	r3, [r0, #8]
 1008df4:	e606      	b.n	1008a04 <hci_evt_encode+0x74>
	sep = meta_evt(buf, BT_HCI_EVT_LE_PHY_UPDATE_COMPLETE, sizeof(*sep));
 1008df6:	2205      	movs	r2, #5
 1008df8:	4630      	mov	r0, r6
 1008dfa:	210c      	movs	r1, #12
 1008dfc:	f7fe fdd0 	bl	10079a0 <meta_evt>
	sep->status = pu->status;
 1008e00:	f894 3020 	ldrb.w	r3, [r4, #32]
	sep->handle = sys_cpu_to_le16(handle);
 1008e04:	f8a0 7001 	strh.w	r7, [r0, #1]
	sep->status = pu->status;
 1008e08:	7003      	strb	r3, [r0, #0]
 1008e0a:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
 1008e0e:	fa92 f3a2 	rbit	r3, r2
 1008e12:	2a00      	cmp	r2, #0
 1008e14:	fab3 f383 	clz	r3, r3
 1008e18:	bf08      	it	eq
 1008e1a:	f04f 33ff 	moveq.w	r3, #4294967295
 1008e1e:	3301      	adds	r3, #1
	sep->tx_phy = find_lsb_set(pu->tx);
 1008e20:	70c3      	strb	r3, [r0, #3]
 1008e22:	f894 2022 	ldrb.w	r2, [r4, #34]	; 0x22
 1008e26:	fa92 f3a2 	rbit	r3, r2
 1008e2a:	2a00      	cmp	r2, #0
 1008e2c:	fab3 f383 	clz	r3, r3
 1008e30:	bf08      	it	eq
 1008e32:	f04f 33ff 	moveq.w	r3, #4294967295
 1008e36:	3301      	adds	r3, #1
	sep->rx_phy = find_lsb_set(pu->rx);
 1008e38:	7103      	strb	r3, [r0, #4]
 1008e3a:	e5e3      	b.n	1008a04 <hci_evt_encode+0x74>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008e3c:	2100      	movs	r1, #0
 1008e3e:	460a      	mov	r2, r1
 1008e40:	4863      	ldr	r0, [pc, #396]	; (1008fd0 <hci_evt_encode+0x640>)
 1008e42:	6840      	ldr	r0, [r0, #4]
 1008e44:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
 1008e48:	4313      	orrs	r3, r2
 1008e4a:	f000 80a7 	beq.w	1008f9c <hci_evt_encode+0x60c>
	    !(le_event_mask & BT_EVT_MASK_LE_CONN_PARAM_REQ)) {
 1008e4e:	460b      	mov	r3, r1
 1008e50:	4860      	ldr	r0, [pc, #384]	; (1008fd4 <hci_evt_encode+0x644>)
 1008e52:	6800      	ldr	r0, [r0, #0]
 1008e54:	f000 0220 	and.w	r2, r0, #32
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008e58:	4313      	orrs	r3, r2
 1008e5a:	f000 809f 	beq.w	1008f9c <hci_evt_encode+0x60c>
	sep = meta_evt(buf, BT_HCI_EVT_LE_CONN_PARAM_REQ, sizeof(*sep));
 1008e5e:	4630      	mov	r0, r6
 1008e60:	220a      	movs	r2, #10
 1008e62:	2106      	movs	r1, #6
 1008e64:	f7fe fd9c 	bl	10079a0 <meta_evt>
	sep->handle = sys_cpu_to_le16(handle);
 1008e68:	8005      	strh	r5, [r0, #0]
	sep->interval_min = pdu_data->llctrl.conn_param_req.interval_min;
 1008e6a:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
 1008e6c:	8043      	strh	r3, [r0, #2]
	sep->interval_max = pdu_data->llctrl.conn_param_req.interval_max;
 1008e6e:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 1008e70:	8083      	strh	r3, [r0, #4]
	sep->latency = pdu_data->llctrl.conn_param_req.latency;
 1008e72:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 1008e74:	80c3      	strh	r3, [r0, #6]
	sep->timeout = pdu_data->llctrl.conn_param_req.timeout;
 1008e76:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 1008e78:	8103      	strh	r3, [r0, #8]
 1008e7a:	e5c3      	b.n	1008a04 <hci_evt_encode+0x74>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008e7c:	2100      	movs	r1, #0
 1008e7e:	460a      	mov	r2, r1
 1008e80:	4853      	ldr	r0, [pc, #332]	; (1008fd0 <hci_evt_encode+0x640>)
 1008e82:	6840      	ldr	r0, [r0, #4]
 1008e84:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
 1008e88:	4313      	orrs	r3, r2
 1008e8a:	f43f adbb 	beq.w	1008a04 <hci_evt_encode+0x74>
	    !(le_event_mask & BT_EVT_MASK_LE_LTK_REQUEST)) {
 1008e8e:	460b      	mov	r3, r1
 1008e90:	4850      	ldr	r0, [pc, #320]	; (1008fd4 <hci_evt_encode+0x644>)
 1008e92:	6800      	ldr	r0, [r0, #0]
 1008e94:	f000 0210 	and.w	r2, r0, #16
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008e98:	4313      	orrs	r3, r2
 1008e9a:	f43f adb3 	beq.w	1008a04 <hci_evt_encode+0x74>
	sep = meta_evt(buf, BT_HCI_EVT_LE_LTK_REQUEST, sizeof(*sep));
 1008e9e:	4630      	mov	r0, r6
 1008ea0:	220c      	movs	r2, #12
 1008ea2:	2105      	movs	r1, #5
 1008ea4:	f7fe fd7c 	bl	10079a0 <meta_evt>
 1008ea8:	4606      	mov	r6, r0
	memcpy(&sep->rand, pdu_data->llctrl.enc_req.rand, sizeof(u64_t));
 1008eaa:	f104 0124 	add.w	r1, r4, #36	; 0x24
 1008eae:	2208      	movs	r2, #8
	sep->handle = sys_cpu_to_le16(handle);
 1008eb0:	f820 5b02 	strh.w	r5, [r0], #2
	memcpy(&sep->rand, pdu_data->llctrl.enc_req.rand, sizeof(u64_t));
 1008eb4:	f00d fdb0 	bl	1016a18 <memcpy>
	memcpy(&sep->ediv, pdu_data->llctrl.enc_req.ediv, sizeof(u16_t));
 1008eb8:	2202      	movs	r2, #2
 1008eba:	f106 000a 	add.w	r0, r6, #10
 1008ebe:	f104 012c 	add.w	r1, r4, #44	; 0x2c
 1008ec2:	f00d fda9 	bl	1016a18 <memcpy>
 1008ec6:	e59d      	b.n	1008a04 <hci_evt_encode+0x74>
	if (!(event_mask & BT_EVT_MASK_REMOTE_VERSION_INFO)) {
 1008ec8:	2700      	movs	r7, #0
 1008eca:	463b      	mov	r3, r7
 1008ecc:	4940      	ldr	r1, [pc, #256]	; (1008fd0 <hci_evt_encode+0x640>)
 1008ece:	6809      	ldr	r1, [r1, #0]
 1008ed0:	f401 6200 	and.w	r2, r1, #2048	; 0x800
 1008ed4:	4313      	orrs	r3, r2
 1008ed6:	f43f ad95 	beq.w	1008a04 <hci_evt_encode+0x74>
	hdr = net_buf_add(buf, sizeof(*hdr));
 1008eda:	3608      	adds	r6, #8
 1008edc:	2102      	movs	r1, #2
 1008ede:	4630      	mov	r0, r6
 1008ee0:	f00d fea8 	bl	1016c34 <net_buf_simple_add>
	hdr->evt = evt;
 1008ee4:	220c      	movs	r2, #12
	hdr = net_buf_add(buf, sizeof(*hdr));
 1008ee6:	4603      	mov	r3, r0
	hdr->len = len;
 1008ee8:	2108      	movs	r1, #8
	hdr->evt = evt;
 1008eea:	701a      	strb	r2, [r3, #0]
	hdr->len = len;
 1008eec:	7059      	strb	r1, [r3, #1]
	ep = net_buf_add(buf, sizeof(*ep));
 1008eee:	4630      	mov	r0, r6
 1008ef0:	f00d fea0 	bl	1016c34 <net_buf_simple_add>
	ep->status = 0x00;
 1008ef4:	7007      	strb	r7, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
 1008ef6:	f8a0 5001 	strh.w	r5, [r0, #1]
	ep->version = ver_ind->version_number;
 1008efa:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 1008efe:	70c3      	strb	r3, [r0, #3]
	ep->manufacturer = ver_ind->company_id;
 1008f00:	f8b4 3025 	ldrh.w	r3, [r4, #37]	; 0x25
 1008f04:	8083      	strh	r3, [r0, #4]
	ep->subversion = ver_ind->sub_version_number;
 1008f06:	f8b4 3027 	ldrh.w	r3, [r4, #39]	; 0x27
 1008f0a:	80c3      	strh	r3, [r0, #6]
 1008f0c:	e57a      	b.n	1008a04 <hci_evt_encode+0x74>
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
 1008f0e:	2300      	movs	r3, #0
 1008f10:	492f      	ldr	r1, [pc, #188]	; (1008fd0 <hci_evt_encode+0x640>)
 1008f12:	6809      	ldr	r1, [r1, #0]
 1008f14:	f001 0280 	and.w	r2, r1, #128	; 0x80
 1008f18:	4313      	orrs	r3, r2
 1008f1a:	f43f ad73 	beq.w	1008a04 <hci_evt_encode+0x74>
 1008f1e:	4632      	mov	r2, r6
 1008f20:	4629      	mov	r1, r5
 1008f22:	f890 0024 	ldrb.w	r0, [r0, #36]	; 0x24
 1008f26:	f7fe fd89 	bl	1007a3c <encrypt_change.part.0>
 1008f2a:	e56b      	b.n	1008a04 <hci_evt_encode+0x74>
		le_unknown_rsp(pdu_data, handle, buf);
 1008f2c:	f890 1024 	ldrb.w	r1, [r0, #36]	; 0x24
	switch (pdu_data->llctrl.unknown_rsp.type) {
 1008f30:	290e      	cmp	r1, #14
 1008f32:	f000 80e6 	beq.w	1009102 <hci_evt_encode+0x772>
 1008f36:	4b29      	ldr	r3, [pc, #164]	; (1008fdc <hci_evt_encode+0x64c>)
 1008f38:	4a29      	ldr	r2, [pc, #164]	; (1008fe0 <hci_evt_encode+0x650>)
		BT_WARN("type: 0x%02x",	pdu_data->llctrl.unknown_rsp.type);
 1008f3a:	482a      	ldr	r0, [pc, #168]	; (1008fe4 <hci_evt_encode+0x654>)
 1008f3c:	1a9a      	subs	r2, r3, r2
 1008f3e:	08d2      	lsrs	r2, r2, #3
 1008f40:	0192      	lsls	r2, r2, #6
 1008f42:	f042 0202 	orr.w	r2, r2, #2
 1008f46:	f00c fadf 	bl	1015508 <log_1>
 1008f4a:	e55b      	b.n	1008a04 <hci_evt_encode+0x74>
		le_remote_feat_complete(0x00, pdu_data, handle, buf);
 1008f4c:	460b      	mov	r3, r1
 1008f4e:	462a      	mov	r2, r5
 1008f50:	f100 0120 	add.w	r1, r0, #32
 1008f54:	2000      	movs	r0, #0
 1008f56:	f7fe fd3b 	bl	10079d0 <le_remote_feat_complete>
		break;
 1008f5a:	e553      	b.n	1008a04 <hci_evt_encode+0x74>
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
 1008f5c:	2000      	movs	r0, #0
 1008f5e:	4603      	mov	r3, r0
 1008f60:	491b      	ldr	r1, [pc, #108]	; (1008fd0 <hci_evt_encode+0x640>)
 1008f62:	6809      	ldr	r1, [r1, #0]
 1008f64:	f001 0280 	and.w	r2, r1, #128	; 0x80
 1008f68:	4313      	orrs	r3, r2
 1008f6a:	f43f ad4b 	beq.w	1008a04 <hci_evt_encode+0x74>
 1008f6e:	4632      	mov	r2, r6
 1008f70:	4629      	mov	r1, r5
 1008f72:	f7fe fd63 	bl	1007a3c <encrypt_change.part.0>
 1008f76:	e545      	b.n	1008a04 <hci_evt_encode+0x74>
		ll_rl_crpa_set(0x00, NULL, rl_idx, &adv->adv_ind.addr[0]);
 1008f78:	2100      	movs	r1, #0
 1008f7a:	465a      	mov	r2, fp
 1008f7c:	4608      	mov	r0, r1
 1008f7e:	f104 0322 	add.w	r3, r4, #34	; 0x22
 1008f82:	f006 fba9 	bl	100f6d8 <ll_rl_crpa_set>
 1008f86:	e556      	b.n	1008a36 <hci_evt_encode+0xa6>
		ll_rl_crpa_set(node_rx->peer_addr_type,
 1008f88:	f100 0329 	add.w	r3, r0, #41	; 0x29
 1008f8c:	f100 0123 	add.w	r1, r0, #35	; 0x23
 1008f90:	22ff      	movs	r2, #255	; 0xff
 1008f92:	f890 0022 	ldrb.w	r0, [r0, #34]	; 0x22
 1008f96:	f006 fb9f 	bl	100f6d8 <ll_rl_crpa_set>
 1008f9a:	e657      	b.n	1008c4c <hci_evt_encode+0x2bc>
		ll_conn_update(handle, 2, BT_HCI_ERR_UNSUPP_REMOTE_FEATURE, 0,
 1008f9c:	2300      	movs	r3, #0
 1008f9e:	4628      	mov	r0, r5
 1008fa0:	221a      	movs	r2, #26
 1008fa2:	2102      	movs	r1, #2
 1008fa4:	e9cd 3301 	strd	r3, r3, [sp, #4]
 1008fa8:	9300      	str	r3, [sp, #0]
 1008faa:	f002 fc17 	bl	100b7dc <ll_conn_update>
		return;
 1008fae:	e529      	b.n	1008a04 <hci_evt_encode+0x74>
	if (le_event_mask & BT_EVT_MASK_LE_ENH_CONN_COMPLETE) {
 1008fb0:	ea50 0301 	orrs.w	r3, r0, r1
 1008fb4:	f040 80ac 	bne.w	1009110 <hci_evt_encode+0x780>
	lecc = meta_evt(buf, BT_HCI_EVT_LE_CONN_COMPLETE, sizeof(*lecc));
 1008fb8:	2212      	movs	r2, #18
 1008fba:	2101      	movs	r1, #1
 1008fbc:	4630      	mov	r0, r6
 1008fbe:	f7fe fcef 	bl	10079a0 <meta_evt>
 1008fc2:	4604      	mov	r4, r0
		(void)memset(lecc, 0x00, sizeof(*lecc));
 1008fc4:	4641      	mov	r1, r8
 1008fc6:	2212      	movs	r2, #18
 1008fc8:	f00d fd51 	bl	1016a6e <memset>
		lecc->status = status;
 1008fcc:	7025      	strb	r5, [r4, #0]
		return;
 1008fce:	e519      	b.n	1008a04 <hci_evt_encode+0x74>
 1008fd0:	21000000 	.word	0x21000000
 1008fd4:	21000008 	.word	0x21000008
 1008fd8:	01018794 	.word	0x01018794
 1008fdc:	01018230 	.word	0x01018230
 1008fe0:	01018208 	.word	0x01018208
 1008fe4:	010187fc 	.word	0x010187fc
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008fe8:	2100      	movs	r1, #0
 1008fea:	460a      	mov	r2, r1
 1008fec:	4884      	ldr	r0, [pc, #528]	; (1009200 <hci_evt_encode+0x870>)
 1008fee:	6840      	ldr	r0, [r0, #4]
 1008ff0:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
 1008ff4:	4313      	orrs	r3, r2
 1008ff6:	f43f ad05 	beq.w	1008a04 <hci_evt_encode+0x74>
	    !(le_event_mask & BT_EVT_MASK_LE_DIRECT_ADV_REPORT)) {
 1008ffa:	460b      	mov	r3, r1
 1008ffc:	4881      	ldr	r0, [pc, #516]	; (1009204 <hci_evt_encode+0x874>)
 1008ffe:	6800      	ldr	r0, [r0, #0]
 1009000:	f400 6280 	and.w	r2, r0, #1024	; 0x400
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1009004:	4313      	orrs	r3, r2
 1009006:	f43f acfd 	beq.w	1008a04 <hci_evt_encode+0x74>
	LL_ASSERT(adv->type == PDU_ADV_TYPE_DIRECT_IND);
 100900a:	f894 3020 	ldrb.w	r3, [r4, #32]
 100900e:	f003 030f 	and.w	r3, r3, #15
 1009012:	2b01      	cmp	r3, #1
 1009014:	d004      	beq.n	1009020 <hci_evt_encode+0x690>
 1009016:	f640 11a3 	movw	r1, #2467	; 0x9a3
 100901a:	487b      	ldr	r0, [pc, #492]	; (1009208 <hci_evt_encode+0x878>)
 100901c:	f7fa fb30 	bl	1003680 <bt_ctlr_assert_handle>
	if (dup_count >= 0) {
 1009020:	f8df 91f4 	ldr.w	r9, [pc, #500]	; 1009218 <hci_evt_encode+0x888>
 1009024:	f8d9 2000 	ldr.w	r2, [r9]
 1009028:	2a00      	cmp	r2, #0
 100902a:	db49      	blt.n	10090c0 <hci_evt_encode+0x730>
		for (i = 0; i < dup_count; i++) {
 100902c:	bf08      	it	eq
 100902e:	f104 0a22 	addeq.w	sl, r4, #34	; 0x22
 1009032:	d019      	beq.n	1009068 <hci_evt_encode+0x6d8>
 1009034:	2700      	movs	r7, #0
 1009036:	4d75      	ldr	r5, [pc, #468]	; (100920c <hci_evt_encode+0x87c>)
 1009038:	f104 0a22 	add.w	sl, r4, #34	; 0x22
			if (!memcmp(&adv->adv_ind.addr[0],
 100903c:	2206      	movs	r2, #6
 100903e:	4629      	mov	r1, r5
 1009040:	4650      	mov	r0, sl
 1009042:	f00d fcd9 	bl	10169f8 <memcmp>
 1009046:	b940      	cbnz	r0, 100905a <hci_evt_encode+0x6ca>
			    adv->tx_addr == dup_filter[i].addr.type) {
 1009048:	f894 2020 	ldrb.w	r2, [r4, #32]
 100904c:	f815 1c01 	ldrb.w	r1, [r5, #-1]
 1009050:	f3c2 1080 	ubfx	r0, r2, #6, #1
				    sizeof(bt_addr_t)) &&
 1009054:	4288      	cmp	r0, r1
 1009056:	f000 80c2 	beq.w	10091de <hci_evt_encode+0x84e>
		for (i = 0; i < dup_count; i++) {
 100905a:	f8d9 2000 	ldr.w	r2, [r9]
 100905e:	3701      	adds	r7, #1
 1009060:	4297      	cmp	r7, r2
 1009062:	f105 0508 	add.w	r5, r5, #8
 1009066:	dbe9      	blt.n	100903c <hci_evt_encode+0x6ac>
		memcpy(&dup_filter[dup_curr].addr.a.val[0],
 1009068:	4d69      	ldr	r5, [pc, #420]	; (1009210 <hci_evt_encode+0x880>)
 100906a:	4f6a      	ldr	r7, [pc, #424]	; (1009214 <hci_evt_encode+0x884>)
 100906c:	682a      	ldr	r2, [r5, #0]
 100906e:	4651      	mov	r1, sl
 1009070:	eb07 02c2 	add.w	r2, r7, r2, lsl #3
 1009074:	1c90      	adds	r0, r2, #2
 1009076:	2206      	movs	r2, #6
 1009078:	f00d fcce 	bl	1016a18 <memcpy>
		dup_filter[dup_curr].mask = BIT(adv->type);
 100907c:	2001      	movs	r0, #1
		dup_filter[dup_curr].addr.type = adv->tx_addr;
 100907e:	682a      	ldr	r2, [r5, #0]
 1009080:	f894 1020 	ldrb.w	r1, [r4, #32]
 1009084:	eb07 0cc2 	add.w	ip, r7, r2, lsl #3
 1009088:	f3c1 1180 	ubfx	r1, r1, #6, #1
 100908c:	f88c 1001 	strb.w	r1, [ip, #1]
		dup_filter[dup_curr].mask = BIT(adv->type);
 1009090:	f894 c020 	ldrb.w	ip, [r4, #32]
		if (dup_count < CONFIG_BT_CTLR_DUP_FILTER_LEN) {
 1009094:	f8d9 1000 	ldr.w	r1, [r9]
		dup_filter[dup_curr].mask = BIT(adv->type);
 1009098:	f00c 0c0f 	and.w	ip, ip, #15
		if (dup_count < CONFIG_BT_CTLR_DUP_FILTER_LEN) {
 100909c:	290f      	cmp	r1, #15
			dup_count++;
 100909e:	bfd8      	it	le
 10090a0:	3101      	addle	r1, #1
		dup_filter[dup_curr].mask = BIT(adv->type);
 10090a2:	fa00 f00c 	lsl.w	r0, r0, ip
 10090a6:	f807 0032 	strb.w	r0, [r7, r2, lsl #3]
			dup_curr = dup_count;
 10090aa:	bfd6      	itet	le
 10090ac:	460a      	movle	r2, r1
			dup_curr++;
 10090ae:	3201      	addgt	r2, #1
			dup_count++;
 10090b0:	f8c9 1000 	strle.w	r1, [r9]
		if (dup_curr == CONFIG_BT_CTLR_DUP_FILTER_LEN) {
 10090b4:	2a10      	cmp	r2, #16
			dup_curr = 0U;
 10090b6:	bf08      	it	eq
 10090b8:	2300      	moveq	r3, #0
			dup_curr++;
 10090ba:	602a      	str	r2, [r5, #0]
			dup_curr = 0U;
 10090bc:	bf08      	it	eq
 10090be:	602b      	streq	r3, [r5, #0]
	drp = meta_evt(buf, BT_HCI_EVT_LE_DIRECT_ADV_REPORT,
 10090c0:	2211      	movs	r2, #17
 10090c2:	210b      	movs	r1, #11
 10090c4:	4630      	mov	r0, r6
 10090c6:	f7fe fc6b 	bl	10079a0 <meta_evt>
	drp->num_reports = 1U;
 10090ca:	2301      	movs	r3, #1
 10090cc:	7003      	strb	r3, [r0, #0]
	dir_info->evt_type = BT_HCI_ADV_DIRECT_IND;
 10090ce:	7043      	strb	r3, [r0, #1]
	drp = meta_evt(buf, BT_HCI_EVT_LE_DIRECT_ADV_REPORT,
 10090d0:	4605      	mov	r5, r0
	if (rl_idx < ll_rl_size_get()) {
 10090d2:	f005 feab 	bl	100ee2c <ll_rl_size_get>
 10090d6:	4583      	cmp	fp, r0
 10090d8:	d275      	bcs.n	10091c6 <hci_evt_encode+0x836>
		ll_rl_id_addr_get(rl_idx, &dir_info->addr.type,
 10090da:	4658      	mov	r0, fp
 10090dc:	1cea      	adds	r2, r5, #3
 10090de:	1ca9      	adds	r1, r5, #2
 10090e0:	f005 fe78 	bl	100edd4 <ll_rl_id_addr_get>
		dir_info->addr.type += 2U;
 10090e4:	78ab      	ldrb	r3, [r5, #2]
 10090e6:	3302      	adds	r3, #2
 10090e8:	70ab      	strb	r3, [r5, #2]
	dir_info->dir_addr.type = 0x1;
 10090ea:	2301      	movs	r3, #1
	memcpy(&dir_info->dir_addr.a.val[0],
 10090ec:	2206      	movs	r2, #6
	dir_info->dir_addr.type = 0x1;
 10090ee:	726b      	strb	r3, [r5, #9]
	memcpy(&dir_info->dir_addr.a.val[0],
 10090f0:	f104 0128 	add.w	r1, r4, #40	; 0x28
 10090f4:	f105 000a 	add.w	r0, r5, #10
 10090f8:	f00d fc8e 	bl	1016a18 <memcpy>
	dir_info->rssi = rssi;
 10090fc:	9b05      	ldr	r3, [sp, #20]
 10090fe:	742b      	strb	r3, [r5, #16]
 1009100:	e480      	b.n	1008a04 <hci_evt_encode+0x74>
		le_remote_feat_complete(BT_HCI_ERR_UNSUPP_REMOTE_FEATURE,
 1009102:	4633      	mov	r3, r6
 1009104:	462a      	mov	r2, r5
 1009106:	2100      	movs	r1, #0
 1009108:	201a      	movs	r0, #26
 100910a:	f7fe fc61 	bl	10079d0 <le_remote_feat_complete>
		break;
 100910e:	e479      	b.n	1008a04 <hci_evt_encode+0x74>
		leecc = meta_evt(buf, BT_HCI_EVT_LE_ENH_CONN_COMPLETE,
 1009110:	221e      	movs	r2, #30
 1009112:	210a      	movs	r1, #10
 1009114:	4630      	mov	r0, r6
 1009116:	f7fe fc43 	bl	10079a0 <meta_evt>
 100911a:	4604      	mov	r4, r0
			(void)memset(leecc, 0x00, sizeof(*leecc));
 100911c:	4641      	mov	r1, r8
 100911e:	221e      	movs	r2, #30
 1009120:	f00d fca5 	bl	1016a6e <memset>
			leecc->status = status;
 1009124:	7025      	strb	r5, [r4, #0]
			return;
 1009126:	e46d      	b.n	1008a04 <hci_evt_encode+0x74>
		leecc = meta_evt(buf, BT_HCI_EVT_LE_ENH_CONN_COMPLETE,
 1009128:	221e      	movs	r2, #30
 100912a:	210a      	movs	r1, #10
 100912c:	f7fe fc38 	bl	10079a0 <meta_evt>
 1009130:	4606      	mov	r6, r0
		leecc->status = 0x00;
 1009132:	7005      	strb	r5, [r0, #0]
		leecc->handle = sys_cpu_to_le16(handle);
 1009134:	f8a0 7001 	strh.w	r7, [r0, #1]
		leecc->role = node_rx->role;
 1009138:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
		memcpy(&leecc->peer_addr.a.val[0], &node_rx->peer_addr[0],
 100913c:	2206      	movs	r2, #6
		leecc->role = node_rx->role;
 100913e:	70f3      	strb	r3, [r6, #3]
		leecc->peer_addr.type = node_rx->peer_addr_type;
 1009140:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
		memcpy(&leecc->peer_addr.a.val[0], &node_rx->peer_addr[0],
 1009144:	f104 0123 	add.w	r1, r4, #35	; 0x23
		leecc->peer_addr.type = node_rx->peer_addr_type;
 1009148:	7133      	strb	r3, [r6, #4]
		memcpy(&leecc->peer_addr.a.val[0], &node_rx->peer_addr[0],
 100914a:	3005      	adds	r0, #5
 100914c:	f00d fc64 	bl	1016a18 <memcpy>
		memcpy(&leecc->local_rpa.val[0], &node_rx->local_rpa[0],
 1009150:	2206      	movs	r2, #6
 1009152:	f104 012f 	add.w	r1, r4, #47	; 0x2f
 1009156:	f106 000b 	add.w	r0, r6, #11
 100915a:	f00d fc5d 	bl	1016a18 <memcpy>
		memcpy(&leecc->peer_rpa.val[0], &node_rx->peer_rpa[0],
 100915e:	2206      	movs	r2, #6
 1009160:	f104 0129 	add.w	r1, r4, #41	; 0x29
 1009164:	f106 0011 	add.w	r0, r6, #17
 1009168:	f00d fc56 	bl	1016a18 <memcpy>
		leecc->supv_timeout = sys_cpu_to_le16(node_rx->timeout);
 100916c:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
		leecc->interval = sys_cpu_to_le16(node_rx->interval);
 100916e:	8ee1      	ldrh	r1, [r4, #54]	; 0x36
		leecc->latency = sys_cpu_to_le16(node_rx->latency);
 1009170:	8f22      	ldrh	r2, [r4, #56]	; 0x38
		leecc->interval = sys_cpu_to_le16(node_rx->interval);
 1009172:	f8a6 1017 	strh.w	r1, [r6, #23]
		leecc->latency = sys_cpu_to_le16(node_rx->latency);
 1009176:	f8a6 2019 	strh.w	r2, [r6, #25]
		leecc->supv_timeout = sys_cpu_to_le16(node_rx->timeout);
 100917a:	f8a6 301b 	strh.w	r3, [r6, #27]
		leecc->clock_accuracy = node_rx->sca;
 100917e:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 1009182:	7773      	strb	r3, [r6, #29]
		return;
 1009184:	e43e      	b.n	1008a04 <hci_evt_encode+0x74>
		adv_info->addr.type = adv->tx_addr;
 1009186:	f894 3020 	ldrb.w	r3, [r4, #32]
		memcpy(&adv_info->addr.a.val[0], &adv->adv_ind.addr[0],
 100918a:	2206      	movs	r2, #6
		adv_info->addr.type = adv->tx_addr;
 100918c:	f3c3 1380 	ubfx	r3, r3, #6, #1
 1009190:	70ab      	strb	r3, [r5, #2]
		memcpy(&adv_info->addr.a.val[0], &adv->adv_ind.addr[0],
 1009192:	f104 0122 	add.w	r1, r4, #34	; 0x22
 1009196:	1ce8      	adds	r0, r5, #3
 1009198:	f00d fc3e 	bl	1016a18 <memcpy>
 100919c:	e4d9      	b.n	1008b52 <hci_evt_encode+0x1c2>
 100919e:	2700      	movs	r7, #0
 10091a0:	220b      	movs	r2, #11
 10091a2:	e4b9      	b.n	1008b18 <hci_evt_encode+0x188>
				if (dup_filter[i].mask & BIT(adv->type)) {
 10091a4:	491b      	ldr	r1, [pc, #108]	; (1009214 <hci_evt_encode+0x884>)
 10091a6:	f002 020f 	and.w	r2, r2, #15
 10091aa:	f811 3037 	ldrb.w	r3, [r1, r7, lsl #3]
 10091ae:	fa23 f002 	lsr.w	r0, r3, r2
 10091b2:	07c0      	lsls	r0, r0, #31
 10091b4:	f53f ac26 	bmi.w	1008a04 <hci_evt_encode+0x74>
				dup_filter[i].mask |= BIT(adv->type);
 10091b8:	2001      	movs	r0, #1
 10091ba:	fa00 f202 	lsl.w	r2, r0, r2
 10091be:	4313      	orrs	r3, r2
 10091c0:	f801 3037 	strb.w	r3, [r1, r7, lsl #3]
				return false;
 10091c4:	e498      	b.n	1008af8 <hci_evt_encode+0x168>
		dir_info->addr.type = adv->tx_addr;
 10091c6:	f894 3020 	ldrb.w	r3, [r4, #32]
		memcpy(&dir_info->addr.a.val[0], &adv->direct_ind.adv_addr[0],
 10091ca:	2206      	movs	r2, #6
		dir_info->addr.type = adv->tx_addr;
 10091cc:	f3c3 1380 	ubfx	r3, r3, #6, #1
 10091d0:	70ab      	strb	r3, [r5, #2]
		memcpy(&dir_info->addr.a.val[0], &adv->direct_ind.adv_addr[0],
 10091d2:	f104 0122 	add.w	r1, r4, #34	; 0x22
 10091d6:	1ce8      	adds	r0, r5, #3
 10091d8:	f00d fc1e 	bl	1016a18 <memcpy>
 10091dc:	e785      	b.n	10090ea <hci_evt_encode+0x75a>
				if (dup_filter[i].mask & BIT(adv->type)) {
 10091de:	480d      	ldr	r0, [pc, #52]	; (1009214 <hci_evt_encode+0x884>)
 10091e0:	f002 020f 	and.w	r2, r2, #15
 10091e4:	f810 3037 	ldrb.w	r3, [r0, r7, lsl #3]
 10091e8:	fa23 f102 	lsr.w	r1, r3, r2
 10091ec:	07cd      	lsls	r5, r1, #31
 10091ee:	f53f ac09 	bmi.w	1008a04 <hci_evt_encode+0x74>
				dup_filter[i].mask |= BIT(adv->type);
 10091f2:	2101      	movs	r1, #1
 10091f4:	fa01 f202 	lsl.w	r2, r1, r2
 10091f8:	4313      	orrs	r3, r2
 10091fa:	f800 3037 	strb.w	r3, [r0, r7, lsl #3]
				return false;
 10091fe:	e75f      	b.n	10090c0 <hci_evt_encode+0x730>
 1009200:	21000000 	.word	0x21000000
 1009204:	21000008 	.word	0x21000008
 1009208:	01018794 	.word	0x01018794
 100920c:	21000cda 	.word	0x21000cda
 1009210:	21000cd4 	.word	0x21000cd4
 1009214:	21000cd8 	.word	0x21000cd8
 1009218:	21000cd0 	.word	0x21000cd0

0100921c <hci_num_cmplt_encode>:

#if defined(CONFIG_BT_CONN)
void hci_num_cmplt_encode(struct net_buf *buf, u16_t handle, u8_t num)
{
 100921c:	b570      	push	{r4, r5, r6, lr}
	hdr = net_buf_add(buf, sizeof(*hdr));
 100921e:	f100 0408 	add.w	r4, r0, #8
{
 1009222:	460e      	mov	r6, r1
	hdr = net_buf_add(buf, sizeof(*hdr));
 1009224:	4620      	mov	r0, r4
 1009226:	2102      	movs	r1, #2
{
 1009228:	4615      	mov	r5, r2
	hdr = net_buf_add(buf, sizeof(*hdr));
 100922a:	f00d fd03 	bl	1016c34 <net_buf_simple_add>
	hdr->evt = evt;
 100922e:	2213      	movs	r2, #19
	hdr = net_buf_add(buf, sizeof(*hdr));
 1009230:	4603      	mov	r3, r0
	hdr->len = len;
 1009232:	2105      	movs	r1, #5
	hdr->evt = evt;
 1009234:	701a      	strb	r2, [r3, #0]
	hdr->len = len;
 1009236:	7059      	strb	r1, [r3, #1]
	num_handles = 1U;

	len = (sizeof(*ep) + (sizeof(*hc) * num_handles));
	hci_evt_create(buf, BT_HCI_EVT_NUM_COMPLETED_PACKETS, len);

	ep = net_buf_add(buf, len);
 1009238:	4620      	mov	r0, r4
 100923a:	f00d fcfb 	bl	1016c34 <net_buf_simple_add>
	ep->num_handles = num_handles;
 100923e:	2301      	movs	r3, #1
 1009240:	7003      	strb	r3, [r0, #0]
	hc = &ep->h[0];
	hc->handle = sys_cpu_to_le16(handle);
 1009242:	f8a0 6001 	strh.w	r6, [r0, #1]
	hc->count = sys_cpu_to_le16(num);
 1009246:	f8a0 5003 	strh.w	r5, [r0, #3]
}
 100924a:	bd70      	pop	{r4, r5, r6, pc}

0100924c <hci_get_class>:
{
#if defined(CONFIG_BT_CONN)
	struct pdu_data *pdu_data = PDU_DATA(node_rx);
#endif

	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
 100924c:	7903      	ldrb	r3, [r0, #4]
 100924e:	2b02      	cmp	r3, #2
 1009250:	d008      	beq.n	1009264 <hci_get_class+0x18>

		switch (node_rx->hdr.type) {
 1009252:	3b04      	subs	r3, #4
 1009254:	b2db      	uxtb	r3, r3
 1009256:	2b0a      	cmp	r3, #10
 1009258:	d901      	bls.n	100925e <hci_get_class+0x12>
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
 100925a:	2000      	movs	r0, #0
#else
	} else {
		return HCI_CLASS_NONE;
	}
#endif
}
 100925c:	4770      	bx	lr
 100925e:	4a06      	ldr	r2, [pc, #24]	; (1009278 <hci_get_class+0x2c>)
 1009260:	5cd0      	ldrb	r0, [r2, r3]
 1009262:	4770      	bx	lr
	} else if (pdu_data->ll_id == PDU_DATA_LLID_CTRL) {
 1009264:	f890 3020 	ldrb.w	r3, [r0, #32]
 1009268:	f003 0303 	and.w	r3, r3, #3
 100926c:	2b03      	cmp	r3, #3
		return HCI_CLASS_ACL_DATA;
 100926e:	bf0c      	ite	eq
 1009270:	2004      	moveq	r0, #4
 1009272:	2005      	movne	r0, #5
 1009274:	4770      	bx	lr
 1009276:	bf00      	nop
 1009278:	01018818 	.word	0x01018818

0100927c <hci_init>:
void hci_init(struct k_poll_signal *signal_host_buf)
{
#if defined(CONFIG_BT_HCI_ACL_FLOW_CONTROL)
	hbuf_signal = signal_host_buf;
#endif
	reset(NULL, NULL);
 100927c:	2100      	movs	r1, #0
{
 100927e:	4602      	mov	r2, r0
	hbuf_signal = signal_host_buf;
 1009280:	4b02      	ldr	r3, [pc, #8]	; (100928c <hci_init+0x10>)
	reset(NULL, NULL);
 1009282:	4608      	mov	r0, r1
	hbuf_signal = signal_host_buf;
 1009284:	601a      	str	r2, [r3, #0]
	reset(NULL, NULL);
 1009286:	f7fe bc55 	b.w	1007b34 <reset>
 100928a:	bf00      	nop
 100928c:	21000d58 	.word	0x21000d58

01009290 <bt_rand>:
#include "hal/ecb.h"
#include "lll.h"

int bt_rand(void *buf, size_t len)
{
	return lll_trng_get(buf, len);
 1009290:	f006 be20 	b.w	100fed4 <lll_trng_get>

01009294 <bt_encrypt_le>:
}

int bt_encrypt_le(const u8_t key[16], const u8_t plaintext[16],
		  u8_t enc_data[16])
{
 1009294:	b508      	push	{r3, lr}
	BT_DBG("key %s", bt_hex(key, 16));
	BT_DBG("plaintext %s", bt_hex(plaintext, 16));

	ecb_encrypt(key, plaintext, enc_data, NULL);
 1009296:	2300      	movs	r3, #0
 1009298:	f008 fc52 	bl	1011b40 <ecb_encrypt>

	BT_DBG("enc_data %s", bt_hex(enc_data, 16));

	return 0;
}
 100929c:	2000      	movs	r0, #0
 100929e:	bd08      	pop	{r3, pc}

010092a0 <perform_lll_reset>:

	return 0;
}

static void perform_lll_reset(void *param)
{
 10092a0:	b510      	push	{r4, lr}
 10092a2:	4604      	mov	r4, r0
	int err;

	/* Reset LLL */
	err = lll_reset();
 10092a4:	f006 fe38 	bl	100ff18 <lll_reset>
	LL_ASSERT(!err);
 10092a8:	b968      	cbnz	r0, 10092c6 <perform_lll_reset+0x26>

#if defined(CONFIG_BT_BROADCASTER)
	/* Reset adv state */
	err = lll_adv_reset();
 10092aa:	f007 fb69 	bl	1010980 <lll_adv_reset>
	LL_ASSERT(!err);
 10092ae:	b998      	cbnz	r0, 10092d8 <perform_lll_reset+0x38>
#endif /* CONFIG_BT_BROADCASTER */

#if defined(CONFIG_BT_OBSERVER)
	/* Reset scan state */
	err = lll_scan_reset();
 10092b0:	f007 fe10 	bl	1010ed4 <lll_scan_reset>
	LL_ASSERT(!err);
 10092b4:	b9c8      	cbnz	r0, 10092ea <perform_lll_reset+0x4a>
#endif /* CONFIG_BT_OBSERVER */

#if defined(CONFIG_BT_CONN)
	/* Reset conn role */
	err = lll_conn_reset();
 10092b6:	f007 fed5 	bl	1011064 <lll_conn_reset>
	LL_ASSERT(!err);
 10092ba:	b9f8      	cbnz	r0, 10092fc <perform_lll_reset+0x5c>
	z_impl_k_sem_give(sem);
 10092bc:	4620      	mov	r0, r4
#endif /* CONFIG_BT_CONN */

#if !defined(CONFIG_BT_CTLR_ZLI)
	k_sem_give(param);
#endif /* !CONFIG_BT_CTLR_ZLI */
}
 10092be:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 10092c2:	f00b ba71 	b.w	10147a8 <z_impl_k_sem_give>
	LL_ASSERT(!err);
 10092c6:	f240 41cf 	movw	r1, #1231	; 0x4cf
 10092ca:	4811      	ldr	r0, [pc, #68]	; (1009310 <perform_lll_reset+0x70>)
 10092cc:	f7fa f9d8 	bl	1003680 <bt_ctlr_assert_handle>
	err = lll_adv_reset();
 10092d0:	f007 fb56 	bl	1010980 <lll_adv_reset>
	LL_ASSERT(!err);
 10092d4:	2800      	cmp	r0, #0
 10092d6:	d0eb      	beq.n	10092b0 <perform_lll_reset+0x10>
 10092d8:	f240 41d4 	movw	r1, #1236	; 0x4d4
 10092dc:	480c      	ldr	r0, [pc, #48]	; (1009310 <perform_lll_reset+0x70>)
 10092de:	f7fa f9cf 	bl	1003680 <bt_ctlr_assert_handle>
	err = lll_scan_reset();
 10092e2:	f007 fdf7 	bl	1010ed4 <lll_scan_reset>
	LL_ASSERT(!err);
 10092e6:	2800      	cmp	r0, #0
 10092e8:	d0e5      	beq.n	10092b6 <perform_lll_reset+0x16>
 10092ea:	f240 41da 	movw	r1, #1242	; 0x4da
 10092ee:	4808      	ldr	r0, [pc, #32]	; (1009310 <perform_lll_reset+0x70>)
 10092f0:	f7fa f9c6 	bl	1003680 <bt_ctlr_assert_handle>
	err = lll_conn_reset();
 10092f4:	f007 feb6 	bl	1011064 <lll_conn_reset>
	LL_ASSERT(!err);
 10092f8:	2800      	cmp	r0, #0
 10092fa:	d0df      	beq.n	10092bc <perform_lll_reset+0x1c>
 10092fc:	f44f 619c 	mov.w	r1, #1248	; 0x4e0
 1009300:	4803      	ldr	r0, [pc, #12]	; (1009310 <perform_lll_reset+0x70>)
 1009302:	f7fa f9bd 	bl	1003680 <bt_ctlr_assert_handle>
 1009306:	4620      	mov	r0, r4
}
 1009308:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 100930c:	f00b ba4c 	b.w	10147a8 <z_impl_k_sem_give>
 1009310:	01018834 	.word	0x01018834

01009314 <disabled_cb>:
 1009314:	f00b ba48 	b.w	10147a8 <z_impl_k_sem_give>

01009318 <tx_cmplt_get>:
	}
}

#if defined(CONFIG_BT_CONN)
static u8_t tx_cmplt_get(u16_t *handle, u8_t *first, u8_t last)
{
 1009318:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100931c:	460d      	mov	r5, r1
 100931e:	4692      	mov	sl, r2
	struct lll_tx *tx;
	u8_t cmplt;

	tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
 1009320:	4f2e      	ldr	r7, [pc, #184]	; (10093dc <tx_cmplt_get+0xc4>)
					   u8_t first, u8_t last, u8_t *idx)
{
	void *p;
	u8_t i;

	if (*idx >= count) {
 1009322:	7809      	ldrb	r1, [r1, #0]
 1009324:	787c      	ldrb	r4, [r7, #1]
 1009326:	783a      	ldrb	r2, [r7, #0]
 1009328:	428c      	cmp	r4, r1
 100932a:	bf98      	it	ls
 100932c:	78b9      	ldrbls	r1, [r7, #2]
{
 100932e:	4683      	mov	fp, r0
		*idx = first;
 1009330:	bf98      	it	ls
 1009332:	7029      	strbls	r1, [r5, #0]
	}

	if (*idx == last) {
 1009334:	458a      	cmp	sl, r1
				    mfifo_tx_ack.n, mfifo_tx_ack.f, last,
				    first);
	if (!tx) {
		return 0;
 1009336:	f04f 0800 	mov.w	r8, #0
 100933a:	d044      	beq.n	10093c6 <tx_cmplt_get+0xae>
		return NULL;
	}

	i = *idx + 1;
 100933c:	1c4b      	adds	r3, r1, #1
 100933e:	b2db      	uxtb	r3, r3
	if (i == count) {
		i = 0U;
 1009340:	429c      	cmp	r4, r3
 1009342:	bf08      	it	eq
 1009344:	2300      	moveq	r3, #0
	}

	p = (void *)(fifo + (*idx) * size);
 1009346:	fb02 f101 	mul.w	r1, r2, r1
 100934a:	4e25      	ldr	r6, [pc, #148]	; (10093e0 <tx_cmplt_get+0xc8>)

	*idx = i;
 100934c:	702b      	strb	r3, [r5, #0]
	if (!tx) {
 100934e:	1873      	adds	r3, r6, r1
 1009350:	d039      	beq.n	10093c6 <tx_cmplt_get+0xae>
	}

	*handle = tx->handle;
 1009352:	5a71      	ldrh	r1, [r6, r1]
 1009354:	f04f 0901 	mov.w	r9, #1
 1009358:	8001      	strh	r1, [r0, #0]
	cmplt = 0U;
 100935a:	e020      	b.n	100939e <tx_cmplt_get+0x86>
		    (((u32_t)node_tx & ~3) &&
		     (p->ll_id == PDU_DATA_LLID_DATA_START ||
		      p->ll_id == PDU_DATA_LLID_DATA_CONTINUE))) {
			/* data packet, hence count num cmplt */
			tx->node = (void *)1;
			cmplt++;
 100935c:	f108 0801 	add.w	r8, r8, #1
 1009360:	f8c3 9004 	str.w	r9, [r3, #4]
		} else {
			/* ctrl packet or flushed, hence dont count num cmplt */
			tx->node = (void *)2;
		}

		if (((u32_t)node_tx & ~3)) {
 1009364:	f030 0303 	bics.w	r3, r0, #3
			cmplt++;
 1009368:	fa5f f888 	uxtb.w	r8, r8
		if (((u32_t)node_tx & ~3)) {
 100936c:	d125      	bne.n	10093ba <tx_cmplt_get+0xa2>
	if (*idx >= count) {
 100936e:	782c      	ldrb	r4, [r5, #0]
			ll_tx_mem_release(node_tx);
		}

		tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
 1009370:	7878      	ldrb	r0, [r7, #1]
 1009372:	7839      	ldrb	r1, [r7, #0]
 1009374:	42a0      	cmp	r0, r4
 1009376:	bf9c      	itt	ls
 1009378:	78bc      	ldrbls	r4, [r7, #2]
		*idx = first;
 100937a:	702c      	strbls	r4, [r5, #0]
	if (*idx == last) {
 100937c:	45a2      	cmp	sl, r4
 100937e:	d022      	beq.n	10093c6 <tx_cmplt_get+0xae>
	i = *idx + 1;
 1009380:	1c63      	adds	r3, r4, #1
 1009382:	b2db      	uxtb	r3, r3
		i = 0U;
 1009384:	4298      	cmp	r0, r3
 1009386:	bf08      	it	eq
 1009388:	2300      	moveq	r3, #0
	p = (void *)(fifo + (*idx) * size);
 100938a:	fb01 f404 	mul.w	r4, r1, r4
	*idx = i;
 100938e:	702b      	strb	r3, [r5, #0]
					    mfifo_tx_ack.n, mfifo_tx_ack.f,
					    last, first);
	} while (tx && tx->handle == *handle);
 1009390:	1933      	adds	r3, r6, r4
 1009392:	d018      	beq.n	10093c6 <tx_cmplt_get+0xae>
 1009394:	5b30      	ldrh	r0, [r6, r4]
 1009396:	f8bb 1000 	ldrh.w	r1, [fp]
 100939a:	4288      	cmp	r0, r1
 100939c:	d113      	bne.n	10093c6 <tx_cmplt_get+0xae>
		node_tx = tx->node;
 100939e:	6858      	ldr	r0, [r3, #4]
		if (!node_tx || (node_tx == (void *)1) ||
 10093a0:	2801      	cmp	r0, #1
 10093a2:	d9db      	bls.n	100935c <tx_cmplt_get+0x44>
 10093a4:	f030 0203 	bics.w	r2, r0, #3
 10093a8:	d00a      	beq.n	10093c0 <tx_cmplt_get+0xa8>
		     (p->ll_id == PDU_DATA_LLID_DATA_START ||
 10093aa:	7901      	ldrb	r1, [r0, #4]
 10093ac:	f001 0103 	and.w	r1, r1, #3
		    (((u32_t)node_tx & ~3) &&
 10093b0:	3901      	subs	r1, #1
 10093b2:	2901      	cmp	r1, #1
 10093b4:	d90a      	bls.n	10093cc <tx_cmplt_get+0xb4>
 10093b6:	2202      	movs	r2, #2
 10093b8:	605a      	str	r2, [r3, #4]
			ll_tx_mem_release(node_tx);
 10093ba:	f002 f9a5 	bl	100b708 <ll_tx_mem_release>
 10093be:	e7d6      	b.n	100936e <tx_cmplt_get+0x56>
 10093c0:	2202      	movs	r2, #2
 10093c2:	605a      	str	r2, [r3, #4]
		if (((u32_t)node_tx & ~3)) {
 10093c4:	e7d3      	b.n	100936e <tx_cmplt_get+0x56>

	return cmplt;
}
 10093c6:	4640      	mov	r0, r8
 10093c8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			cmplt++;
 10093cc:	f108 0801 	add.w	r8, r8, #1
 10093d0:	fa5f f888 	uxtb.w	r8, r8
 10093d4:	f8c3 9004 	str.w	r9, [r3, #4]
		if (((u32_t)node_tx & ~3)) {
 10093d8:	e7ef      	b.n	10093ba <tx_cmplt_get+0xa2>
 10093da:	bf00      	nop
 10093dc:	21000238 	.word	0x21000238
 10093e0:	2100023c 	.word	0x2100023c

010093e4 <rx_demux>:
		}
}
#endif /* CONFIG_BT_CONN */

static void rx_demux(void *param)
{
 10093e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10093e8:	4ead      	ldr	r6, [pc, #692]	; (10096a0 <rx_demux+0x2bc>)
	k_sem_give(sem_recv);
 10093ea:	f8df 82d0 	ldr.w	r8, [pc, #720]	; 10096bc <rx_demux+0x2d8>
#if defined(CONFIG_BT_CTLR_USER_EXT)
		/* Try proprietary demuxing */
		rx_demux_rx_proprietary(link, rx, memq_ull_rx.tail,
					&memq_ull_rx.head);
#else
		LL_ASSERT(0);
 10093ee:	f8df a2d0 	ldr.w	sl, [pc, #720]	; 10096c0 <rx_demux+0x2dc>
{
 10093f2:	b089      	sub	sp, #36	; 0x24
		link = memq_peek(memq_ull_rx.head, memq_ull_rx.tail,
 10093f4:	aa05      	add	r2, sp, #20
 10093f6:	e9d6 0100 	ldrd	r0, r1, [r6]
 10093fa:	f7fc fcf9 	bl	1005df0 <memq_peek>
		if (link) {
 10093fe:	4605      	mov	r5, r0
 1009400:	2800      	cmp	r0, #0
 1009402:	d040      	beq.n	1009486 <rx_demux+0xa2>
			LL_ASSERT(rx);
 1009404:	9b05      	ldr	r3, [sp, #20]
 1009406:	2b00      	cmp	r3, #0
 1009408:	f000 8117 	beq.w	100963a <rx_demux+0x256>
			link_tx = ull_conn_ack_by_last_peek(rx->ack_last,
 100940c:	7818      	ldrb	r0, [r3, #0]
 100940e:	aa06      	add	r2, sp, #24
 1009410:	a904      	add	r1, sp, #16
 1009412:	f004 fca3 	bl	100dd5c <ull_conn_ack_by_last_peek>
			if (link_tx) {
 1009416:	4604      	mov	r4, r0
 1009418:	2800      	cmp	r0, #0
 100941a:	d06a      	beq.n	10094f2 <rx_demux+0x10e>
				rx_demux_conn_tx_ack(rx->ack_last, handle,
 100941c:	e9dd 1205 	ldrd	r1, r2, [sp, #20]
 1009420:	f8bd 3010 	ldrh.w	r3, [sp, #16]
 1009424:	f891 b000 	ldrb.w	fp, [r1]
 1009428:	f10d 091c 	add.w	r9, sp, #28
 100942c:	9207      	str	r2, [sp, #28]
 100942e:	f8ad 3012 	strh.w	r3, [sp, #18]
static inline void rx_demux_conn_tx_ack(u8_t ack_last, u16_t handle,
 1009432:	f10d 0712 	add.w	r7, sp, #18
		ull_conn_ack_dequeue();
 1009436:	f004 fca7 	bl	100dd88 <ull_conn_ack_dequeue>
		conn = ull_conn_tx_ack(handle, link, node_tx);
 100943a:	4621      	mov	r1, r4
 100943c:	9a07      	ldr	r2, [sp, #28]
 100943e:	f8bd 0012 	ldrh.w	r0, [sp, #18]
 1009442:	f004 fcdd 	bl	100de00 <ull_conn_tx_ack>
 1009446:	4605      	mov	r5, r0
		ull_conn_link_tx_release(link);
 1009448:	4620      	mov	r0, r4
 100944a:	f004 fc61 	bl	100dd10 <ull_conn_link_tx_release>
		ull_conn_tx_demux(1);
 100944e:	2001      	movs	r0, #1
 1009450:	f004 f8f8 	bl	100d644 <ull_conn_tx_demux>
		if (conn) {
 1009454:	b11d      	cbz	r5, 100945e <rx_demux+0x7a>
			ull_conn_tx_lll_enqueue(conn, 1);
 1009456:	4628      	mov	r0, r5
 1009458:	2101      	movs	r1, #1
 100945a:	f004 fb71 	bl	100db40 <ull_conn_tx_lll_enqueue>
		link = ull_conn_ack_by_last_peek(ack_last, &handle, &node_tx);
 100945e:	464a      	mov	r2, r9
 1009460:	4639      	mov	r1, r7
 1009462:	4658      	mov	r0, fp
 1009464:	f004 fc7a 	bl	100dd5c <ull_conn_ack_by_last_peek>
	} while (link);
 1009468:	4604      	mov	r4, r0
 100946a:	2800      	cmp	r0, #0
 100946c:	d1e3      	bne.n	1009436 <rx_demux+0x52>
	k_sem_give(sem_recv);
 100946e:	f8d8 0000 	ldr.w	r0, [r8]
 1009472:	f00b f999 	bl	10147a8 <z_impl_k_sem_give>
		link = memq_peek(memq_ull_rx.head, memq_ull_rx.tail,
 1009476:	e9d6 0100 	ldrd	r0, r1, [r6]
 100947a:	aa05      	add	r2, sp, #20
 100947c:	f7fc fcb8 	bl	1005df0 <memq_peek>
		if (link) {
 1009480:	4605      	mov	r5, r0
 1009482:	2800      	cmp	r0, #0
 1009484:	d1be      	bne.n	1009404 <rx_demux+0x20>
			link = ull_conn_ack_peek(&ack_last, &handle, &node_tx);
 1009486:	aa06      	add	r2, sp, #24
 1009488:	a904      	add	r1, sp, #16
 100948a:	f10d 000f 	add.w	r0, sp, #15
 100948e:	f004 fc4b 	bl	100dd28 <ull_conn_ack_peek>
			if (link) {
 1009492:	4604      	mov	r4, r0
 1009494:	2800      	cmp	r0, #0
 1009496:	d062      	beq.n	100955e <rx_demux+0x17a>
				rx_demux_conn_tx_ack(ack_last, handle,
 1009498:	9a06      	ldr	r2, [sp, #24]
 100949a:	f8bd 3010 	ldrh.w	r3, [sp, #16]
 100949e:	f89d b00f 	ldrb.w	fp, [sp, #15]
 10094a2:	9207      	str	r2, [sp, #28]
 10094a4:	f8ad 3012 	strh.w	r3, [sp, #18]
static inline void rx_demux_conn_tx_ack(u8_t ack_last, u16_t handle,
 10094a8:	f10d 091c 	add.w	r9, sp, #28
 10094ac:	f10d 0712 	add.w	r7, sp, #18
		ull_conn_ack_dequeue();
 10094b0:	f004 fc6a 	bl	100dd88 <ull_conn_ack_dequeue>
		conn = ull_conn_tx_ack(handle, link, node_tx);
 10094b4:	4621      	mov	r1, r4
 10094b6:	9a07      	ldr	r2, [sp, #28]
 10094b8:	f8bd 0012 	ldrh.w	r0, [sp, #18]
 10094bc:	f004 fca0 	bl	100de00 <ull_conn_tx_ack>
 10094c0:	4605      	mov	r5, r0
		ull_conn_link_tx_release(link);
 10094c2:	4620      	mov	r0, r4
 10094c4:	f004 fc24 	bl	100dd10 <ull_conn_link_tx_release>
		ull_conn_tx_demux(1);
 10094c8:	2001      	movs	r0, #1
 10094ca:	f004 f8bb 	bl	100d644 <ull_conn_tx_demux>
		if (conn) {
 10094ce:	b11d      	cbz	r5, 10094d8 <rx_demux+0xf4>
			ull_conn_tx_lll_enqueue(conn, 1);
 10094d0:	4628      	mov	r0, r5
 10094d2:	2101      	movs	r1, #1
 10094d4:	f004 fb34 	bl	100db40 <ull_conn_tx_lll_enqueue>
		link = ull_conn_ack_by_last_peek(ack_last, &handle, &node_tx);
 10094d8:	464a      	mov	r2, r9
 10094da:	4639      	mov	r1, r7
 10094dc:	4658      	mov	r0, fp
 10094de:	f004 fc3d 	bl	100dd5c <ull_conn_ack_by_last_peek>
	} while (link);
 10094e2:	4604      	mov	r4, r0
 10094e4:	2800      	cmp	r0, #0
 10094e6:	d1e3      	bne.n	10094b0 <rx_demux+0xcc>
	k_sem_give(sem_recv);
 10094e8:	f8d8 0000 	ldr.w	r0, [r8]
 10094ec:	f00b f95c 	bl	10147a8 <z_impl_k_sem_give>
			if (nack) {
 10094f0:	e7c1      	b.n	1009476 <rx_demux+0x92>
				nack = rx_demux_rx(link, rx);
 10094f2:	9b05      	ldr	r3, [sp, #20]
 10094f4:	9307      	str	r3, [sp, #28]
	switch (rx->type) {
 10094f6:	791b      	ldrb	r3, [r3, #4]
 10094f8:	3b01      	subs	r3, #1
 10094fa:	2b08      	cmp	r3, #8
 10094fc:	d818      	bhi.n	1009530 <rx_demux+0x14c>
 10094fe:	e8df f003 	tbb	[pc, r3]
 1009502:	2731      	.short	0x2731
 1009504:	17170517 	.word	0x17170517
 1009508:	1d17      	.short	0x1d17
 100950a:	05          	.byte	0x05
 100950b:	00          	.byte	0x00
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
 100950c:	4964      	ldr	r1, [pc, #400]	; (10096a0 <rx_demux+0x2bc>)
 100950e:	2200      	movs	r2, #0
 1009510:	6870      	ldr	r0, [r6, #4]
 1009512:	f7fc fc75 	bl	1005e00 <memq_dequeue>
	memq_enqueue(link, rx, &memq_ll_rx.tail);
 1009516:	4628      	mov	r0, r5
	rx_hdr->ack_last = mfifo_tx_ack.l;
 1009518:	4b62      	ldr	r3, [pc, #392]	; (10096a4 <rx_demux+0x2c0>)
		ll_rx_put(link, rx);
 100951a:	9907      	ldr	r1, [sp, #28]
	rx_hdr->ack_last = mfifo_tx_ack.l;
 100951c:	78db      	ldrb	r3, [r3, #3]
	memq_enqueue(link, rx, &memq_ll_rx.tail);
 100951e:	4a62      	ldr	r2, [pc, #392]	; (10096a8 <rx_demux+0x2c4>)
	rx_hdr->ack_last = mfifo_tx_ack.l;
 1009520:	700b      	strb	r3, [r1, #0]
	memq_enqueue(link, rx, &memq_ll_rx.tail);
 1009522:	f7fc fc5d 	bl	1005de0 <memq_enqueue>
	k_sem_give(sem_recv);
 1009526:	f8d8 0000 	ldr.w	r0, [r8]
 100952a:	f00b f93d 	bl	10147a8 <z_impl_k_sem_give>
			if (nack) {
 100952e:	e7a2      	b.n	1009476 <rx_demux+0x92>
		LL_ASSERT(0);
 1009530:	f240 6162 	movw	r1, #1634	; 0x662
 1009534:	4650      	mov	r0, sl
 1009536:	f7fa f8a3 	bl	1003680 <bt_ctlr_assert_handle>
			if (nack) {
 100953a:	e75b      	b.n	10093f4 <rx_demux+0x10>
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
 100953c:	2200      	movs	r2, #0
 100953e:	4958      	ldr	r1, [pc, #352]	; (10096a0 <rx_demux+0x2bc>)
 1009540:	6870      	ldr	r0, [r6, #4]
 1009542:	f7fc fc5d 	bl	1005e00 <memq_dequeue>
		ull_conn_setup(link, rx);
 1009546:	4628      	mov	r0, r5
 1009548:	9907      	ldr	r1, [sp, #28]
 100954a:	f002 fc47 	bl	100bddc <ull_conn_setup>
			if (nack) {
 100954e:	e751      	b.n	10093f4 <rx_demux+0x10>
		nack = ull_conn_rx(link, (void *)&rx);
 1009550:	4628      	mov	r0, r5
 1009552:	a907      	add	r1, sp, #28
 1009554:	f002 fc52 	bl	100bdfc <ull_conn_rx>
		if (nack) {
 1009558:	2800      	cmp	r0, #0
 100955a:	f000 808e 	beq.w	100967a <rx_demux+0x296>
}
 100955e:	b009      	add	sp, #36	; 0x24
 1009560:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
 1009564:	2200      	movs	r2, #0
 1009566:	494e      	ldr	r1, [pc, #312]	; (10096a0 <rx_demux+0x2bc>)
 1009568:	6870      	ldr	r0, [r6, #4]
 100956a:	f7fc fc49 	bl	1005e00 <memq_dequeue>
		rx_demux_event_done(link, rx);
 100956e:	9c07      	ldr	r4, [sp, #28]

	/* Get the ull instance */
	ull_hdr = done->param;

	/* Process role dependent event done */
	switch (done->extra.type) {
 1009570:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
	ull_hdr = done->param;
 1009574:	f8d4 9020 	ldr.w	r9, [r4, #32]
	switch (done->extra.type) {
 1009578:	b133      	cbz	r3, 1009588 <rx_demux+0x1a4>
 100957a:	2b01      	cmp	r3, #1
 100957c:	d079      	beq.n	1009672 <rx_demux+0x28e>
	case EVENT_DONE_EXTRA_TYPE_NONE:
		/* ignore */
		break;

	default:
		LL_ASSERT(0);
 100957e:	f240 618a 	movw	r1, #1674	; 0x68a
 1009582:	4650      	mov	r0, sl
 1009584:	f7fa f87c 	bl	1003680 <bt_ctlr_assert_handle>
		break;
	}

	/* release done */
	done->extra.type = 0U;
 1009588:	2700      	movs	r7, #0
	if (!MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
 100958a:	4a48      	ldr	r2, [pc, #288]	; (10096ac <rx_demux+0x2c8>)
	done->extra.type = 0U;
 100958c:	f884 7024 	strb.w	r7, [r4, #36]	; 0x24
	if (!MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
 1009590:	78d0      	ldrb	r0, [r2, #3]
	if (last == count) {
 1009592:	7851      	ldrb	r1, [r2, #1]
	last = last + 1;
 1009594:	1c43      	adds	r3, r0, #1
 1009596:	b2db      	uxtb	r3, r3
		last = 0U;
 1009598:	4299      	cmp	r1, r3
 100959a:	bf08      	it	eq
 100959c:	463b      	moveq	r3, r7
 100959e:	7891      	ldrb	r1, [r2, #2]
	if (last == first) {
 10095a0:	4299      	cmp	r1, r3
 10095a2:	d077      	beq.n	1009694 <rx_demux+0x2b0>
	done->hdr.link = link;
 10095a4:	6025      	str	r5, [r4, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 10095a6:	7811      	ldrb	r1, [r2, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 10095a8:	fb00 2101 	mla	r1, r0, r1, r2
 10095ac:	604c      	str	r4, [r1, #4]
	*last = idx; /* Commit: Update write index */
 10095ae:	70d3      	strb	r3, [r2, #3]
	return MFIFO_DEQUEUE_GET(prep);
 10095b0:	4d3f      	ldr	r5, [pc, #252]	; (10096b0 <rx_demux+0x2cc>)
 10095b2:	78ab      	ldrb	r3, [r5, #2]
	if (first == last) {
 10095b4:	78ea      	ldrb	r2, [r5, #3]
 10095b6:	782c      	ldrb	r4, [r5, #0]
 10095b8:	429a      	cmp	r2, r3
 10095ba:	d026      	beq.n	100960a <rx_demux+0x226>
	return (void *)(fifo + first * size);
 10095bc:	4a3d      	ldr	r2, [pc, #244]	; (10096b4 <rx_demux+0x2d0>)
 10095be:	fb04 2403 	mla	r4, r4, r3, r2
	release = done_release(link, done);
	LL_ASSERT(release == done);

	/* dequeue prepare pipeline */
	next = ull_prepare_dequeue_get();
	while (next) {
 10095c2:	b314      	cbz	r4, 100960a <rx_demux+0x226>
		u8_t is_aborted = next->is_aborted;
 10095c4:	f894 3020 	ldrb.w	r3, [r4, #32]
		u8_t is_resume = next->is_resume;
 10095c8:	f003 0201 	and.w	r2, r3, #1
 10095cc:	9201      	str	r2, [sp, #4]

		if (!is_aborted) {
 10095ce:	079a      	lsls	r2, r3, #30
		u8_t is_aborted = next->is_aborted;
 10095d0:	f3c3 0b40 	ubfx	fp, r3, #1, #1
		if (!is_aborted) {
 10095d4:	d538      	bpl.n	1009648 <rx_demux+0x264>
			ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
					     TICKER_USER_ID_LLL, 0, &mfy);
			LL_ASSERT(!ret);
		}

		MFIFO_DEQUEUE(prep);
 10095d6:	78ea      	ldrb	r2, [r5, #3]
 * @return              Head buffer; or NULL if queue was empty
 */
static inline void *mfifo_dequeue(u8_t *fifo, u8_t size, u8_t count,
				  u8_t last, u8_t *first)
{
	u8_t _first = *first; /* Copy read-index */
 10095d8:	78ab      	ldrb	r3, [r5, #2]
 10095da:	782c      	ldrb	r4, [r5, #0]
	void *mem;

	/* Queue is empty if first == last */
	if (_first == last) {
 10095dc:	429a      	cmp	r2, r3
 10095de:	7869      	ldrb	r1, [r5, #1]
 10095e0:	d013      	beq.n	100960a <rx_demux+0x226>
	 * API 2: fifo is array of void-ptrs
	 */
	mem = *((void **)(fifo + _first * size));

	/* Circular buffer increment read-index modulo 'count' */
	_first += 1U;
 10095e2:	3301      	adds	r3, #1
 10095e4:	b2db      	uxtb	r3, r3
	if (_first == count) {
 10095e6:	4299      	cmp	r1, r3
 10095e8:	d03d      	beq.n	1009666 <rx_demux+0x282>
	if (first == last) {
 10095ea:	429a      	cmp	r2, r3
		_first = 0U;
	}

	*first = _first; /* Write back read-index */
 10095ec:	70ab      	strb	r3, [r5, #2]
	if (first == last) {
 10095ee:	d00c      	beq.n	100960a <rx_demux+0x226>
	return (void *)(fifo + first * size);
 10095f0:	4a30      	ldr	r2, [pc, #192]	; (10096b4 <rx_demux+0x2d0>)
 10095f2:	fb04 2403 	mla	r4, r4, r3, r2

		next = ull_prepare_dequeue_get();

		if (!next || (!is_aborted && (!is_resume || next->is_resume))) {
 10095f6:	b144      	cbz	r4, 100960a <rx_demux+0x226>
 10095f8:	f1bb 0f00 	cmp.w	fp, #0
 10095fc:	d1e2      	bne.n	10095c4 <rx_demux+0x1e0>
 10095fe:	9b01      	ldr	r3, [sp, #4]
 1009600:	b11b      	cbz	r3, 100960a <rx_demux+0x226>
 1009602:	f894 3020 	ldrb.w	r3, [r4, #32]
 1009606:	07db      	lsls	r3, r3, #31
 1009608:	d5dc      	bpl.n	10095c4 <rx_demux+0x1e0>
			break;
		}
	}

	/* ull instance will resume, dont decrement ref */
	if (!ull_hdr) {
 100960a:	f1b9 0f00 	cmp.w	r9, #0
 100960e:	f43f aef1 	beq.w	10093f4 <rx_demux+0x10>
		return;
	}

	/* Decrement prepare reference */
	LL_ASSERT(ull_hdr->ref);
 1009612:	f899 3000 	ldrb.w	r3, [r9]
 1009616:	2b00      	cmp	r3, #0
 1009618:	d054      	beq.n	10096c4 <rx_demux+0x2e0>
	return hdr->ref--;
 100961a:	3b01      	subs	r3, #1
 100961c:	b2db      	uxtb	r3, r3
 100961e:	f889 3000 	strb.w	r3, [r9]
	ull_ref_dec(ull_hdr);

	/* If disable initiated, signal the semaphore */
	if (!ull_hdr->ref && ull_hdr->disabled_cb) {
 1009622:	2b00      	cmp	r3, #0
 1009624:	f47f aee6 	bne.w	10093f4 <rx_demux+0x10>
 1009628:	f8d9 3004 	ldr.w	r3, [r9, #4]
 100962c:	2b00      	cmp	r3, #0
 100962e:	f43f aee1 	beq.w	10093f4 <rx_demux+0x10>
		ull_hdr->disabled_cb(ull_hdr->disabled_param);
 1009632:	f8d9 0008 	ldr.w	r0, [r9, #8]
 1009636:	4798      	blx	r3
			if (nack) {
 1009638:	e6dc      	b.n	10093f4 <rx_demux+0x10>
			LL_ASSERT(rx);
 100963a:	f240 51d1 	movw	r1, #1489	; 0x5d1
 100963e:	4650      	mov	r0, sl
 1009640:	f7fa f81e 	bl	1003680 <bt_ctlr_assert_handle>
 1009644:	9b05      	ldr	r3, [sp, #20]
 1009646:	e6e1      	b.n	100940c <rx_demux+0x28>
			ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 1009648:	4b1b      	ldr	r3, [pc, #108]	; (10096b8 <rx_demux+0x2d4>)
 100964a:	465a      	mov	r2, fp
 100964c:	4659      	mov	r1, fp
 100964e:	2001      	movs	r0, #1
			mfy.param = next;
 1009650:	609c      	str	r4, [r3, #8]
			ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 1009652:	f7fc fc39 	bl	1005ec8 <mayfly_enqueue>
			LL_ASSERT(!ret);
 1009656:	2800      	cmp	r0, #0
 1009658:	d0bd      	beq.n	10095d6 <rx_demux+0x1f2>
 100965a:	f240 61a2 	movw	r1, #1698	; 0x6a2
 100965e:	4650      	mov	r0, sl
 1009660:	f7fa f80e 	bl	1003680 <bt_ctlr_assert_handle>
 1009664:	e7b7      	b.n	10095d6 <rx_demux+0x1f2>
	*first = _first; /* Write back read-index */
 1009666:	2300      	movs	r3, #0
 1009668:	70ab      	strb	r3, [r5, #2]
	if (first == last) {
 100966a:	2a00      	cmp	r2, #0
 100966c:	d0cd      	beq.n	100960a <rx_demux+0x226>
	return (void *)(fifo + first * size);
 100966e:	4c11      	ldr	r4, [pc, #68]	; (10096b4 <rx_demux+0x2d0>)
 1009670:	e7c2      	b.n	10095f8 <rx_demux+0x214>
		ull_conn_done(done);
 1009672:	4620      	mov	r0, r4
 1009674:	f004 f8ce 	bl	100d814 <ull_conn_done>
		break;
 1009678:	e786      	b.n	1009588 <rx_demux+0x1a4>
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
 100967a:	4602      	mov	r2, r0
 100967c:	4908      	ldr	r1, [pc, #32]	; (10096a0 <rx_demux+0x2bc>)
 100967e:	6870      	ldr	r0, [r6, #4]
 1009680:	f7fc fbbe 	bl	1005e00 <memq_dequeue>
		if (rx) {
 1009684:	9907      	ldr	r1, [sp, #28]
 1009686:	2900      	cmp	r1, #0
 1009688:	f43f aeb4 	beq.w	10093f4 <rx_demux+0x10>
	rx_hdr->ack_last = mfifo_tx_ack.l;
 100968c:	4b05      	ldr	r3, [pc, #20]	; (10096a4 <rx_demux+0x2c0>)
	memq_enqueue(link, rx, &memq_ll_rx.tail);
 100968e:	4628      	mov	r0, r5
	rx_hdr->ack_last = mfifo_tx_ack.l;
 1009690:	78db      	ldrb	r3, [r3, #3]
 1009692:	e744      	b.n	100951e <rx_demux+0x13a>
	LL_ASSERT(release == done);
 1009694:	f240 6191 	movw	r1, #1681	; 0x691
 1009698:	4650      	mov	r0, sl
 100969a:	f7f9 fff1 	bl	1003680 <bt_ctlr_assert_handle>
 100969e:	e787      	b.n	10095b0 <rx_demux+0x1cc>
 10096a0:	210023e0 	.word	0x210023e0
 10096a4:	21000238 	.word	0x21000238
 10096a8:	210023dc 	.word	0x210023dc
 10096ac:	210000b0 	.word	0x210000b0
 10096b0:	21000114 	.word	0x21000114
 10096b4:	21000118 	.word	0x21000118
 10096b8:	210002c4 	.word	0x210002c4
 10096bc:	210023e8 	.word	0x210023e8
 10096c0:	01018834 	.word	0x01018834
	LL_ASSERT(ull_hdr->ref);
 10096c4:	f240 61b4 	movw	r1, #1716	; 0x6b4
 10096c8:	4650      	mov	r0, sl
 10096ca:	f7f9 ffd9 	bl	1003680 <bt_ctlr_assert_handle>
 10096ce:	f899 3000 	ldrb.w	r3, [r9]
 10096d2:	3b01      	subs	r3, #1
 10096d4:	b2db      	uxtb	r3, r3
 10096d6:	f889 3000 	strb.w	r3, [r9]
	if (!ull_hdr->ref && ull_hdr->disabled_cb) {
 10096da:	2b00      	cmp	r3, #0
 10096dc:	f47f ae8a 	bne.w	10093f4 <rx_demux+0x10>
 10096e0:	e7a2      	b.n	1009628 <rx_demux+0x244>
 10096e2:	bf00      	nop

010096e4 <ll_init>:
{
 10096e4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	sem_recv = sem_rx;
 10096e8:	4b94      	ldr	r3, [pc, #592]	; (100993c <ll_init+0x258>)
{
 10096ea:	b086      	sub	sp, #24
	sem_recv = sem_rx;
 10096ec:	6018      	str	r0, [r3, #0]
	cntr_init();
 10096ee:	f008 f9b7 	bl	1011a60 <cntr_init>
	mayfly_init();
 10096f2:	f7fc fb95 	bl	1005e20 <mayfly_init>
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
 10096f6:	210b      	movs	r1, #11
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
 10096f8:	2003      	movs	r0, #3
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
 10096fa:	2502      	movs	r5, #2
	ticker_users[MAYFLY_CALL_ID_1][0] = TICKER_USER_ULL_HIGH_OPS;
 10096fc:	2304      	movs	r3, #4
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
 10096fe:	4c90      	ldr	r4, [pc, #576]	; (1009940 <ll_init+0x25c>)
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
 1009700:	4a90      	ldr	r2, [pc, #576]	; (1009944 <ll_init+0x260>)
 1009702:	e9cd 4100 	strd	r4, r1, [sp]
 1009706:	9205      	str	r2, [sp, #20]
 1009708:	498f      	ldr	r1, [pc, #572]	; (1009948 <ll_init+0x264>)
 100970a:	4a90      	ldr	r2, [pc, #576]	; (100994c <ll_init+0x268>)
 100970c:	e9cd 2103 	strd	r2, r1, [sp, #12]
 1009710:	4a8f      	ldr	r2, [pc, #572]	; (1009950 <ll_init+0x26c>)
	ticker_users[MAYFLY_CALL_ID_1][0] = TICKER_USER_ULL_HIGH_OPS;
 1009712:	7223      	strb	r3, [r4, #8]
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
 1009714:	2115      	movs	r1, #21
 1009716:	9202      	str	r2, [sp, #8]
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
 1009718:	7020      	strb	r0, [r4, #0]
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
 100971a:	4a8e      	ldr	r2, [pc, #568]	; (1009954 <ll_init+0x270>)
 100971c:	2000      	movs	r0, #0
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
 100971e:	7425      	strb	r5, [r4, #16]
	ticker_users[MAYFLY_CALL_ID_PROGRAM][0] = TICKER_USER_APP_OPS;
 1009720:	7625      	strb	r5, [r4, #24]
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
 1009722:	f7fd fcf3 	bl	100710c <ticker_init>
	LL_ASSERT(!err);
 1009726:	2800      	cmp	r0, #0
 1009728:	f040 80f0 	bne.w	100990c <ll_init+0x228>
	return z_impl_k_sem_init(sem, initial_count, limit);
 100972c:	2201      	movs	r2, #1
 100972e:	2100      	movs	r1, #0
 1009730:	4889      	ldr	r0, [pc, #548]	; (1009958 <ll_init+0x274>)
 1009732:	f00e fa74 	bl	1017c1e <z_impl_k_sem_init>
	err = lll_init();
 1009736:	f006 fb9b 	bl	100fe70 <lll_init>
	if (err) {
 100973a:	4604      	mov	r4, r0
 100973c:	b118      	cbz	r0, 1009746 <ll_init+0x62>
}
 100973e:	4620      	mov	r0, r4
 1009740:	b006      	add	sp, #24
 1009742:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	mem_init(mem_done.pool, sizeof(struct node_rx_event_done),
 1009746:	4b85      	ldr	r3, [pc, #532]	; (100995c <ll_init+0x278>)
 1009748:	2203      	movs	r2, #3
 100974a:	1d18      	adds	r0, r3, #4
 100974c:	2138      	movs	r1, #56	; 0x38
 100974e:	f7fc fab5 	bl	1005cbc <mem_init>
	mem_init(mem_link_done.pool, sizeof(memq_link_t), EVENT_DONE_MAX,
 1009752:	4b83      	ldr	r3, [pc, #524]	; (1009960 <ll_init+0x27c>)
 1009754:	4d83      	ldr	r5, [pc, #524]	; (1009964 <ll_init+0x280>)
 1009756:	2203      	movs	r2, #3
 1009758:	2108      	movs	r1, #8
 100975a:	1d18      	adds	r0, r3, #4
 100975c:	f7fc faae 	bl	1005cbc <mem_init>
		link = mem_acquire(&mem_link_done.free);
 1009760:	f8df 81fc 	ldr.w	r8, [pc, #508]	; 1009960 <ll_init+0x27c>
 1009764:	78ec      	ldrb	r4, [r5, #3]
		rx = mem_acquire(&mem_done.free);
 1009766:	4f7d      	ldr	r7, [pc, #500]	; (100995c <ll_init+0x278>)
	if (last == count) {
 1009768:	786b      	ldrb	r3, [r5, #1]
	last = last + 1;
 100976a:	3401      	adds	r4, #1
 100976c:	b2e4      	uxtb	r4, r4
		last = 0U;
 100976e:	42a3      	cmp	r3, r4
 1009770:	bf08      	it	eq
 1009772:	2400      	moveq	r4, #0
	while (MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
 1009774:	78ab      	ldrb	r3, [r5, #2]
	if (last == first) {
 1009776:	429c      	cmp	r4, r3
 1009778:	d014      	beq.n	10097a4 <ll_init+0xc0>
		link = mem_acquire(&mem_link_done.free);
 100977a:	4640      	mov	r0, r8
 100977c:	f7fc facc 	bl	1005d18 <mem_acquire>
		if (!link) {
 1009780:	4606      	mov	r6, r0
 1009782:	b178      	cbz	r0, 10097a4 <ll_init+0xc0>
		rx = mem_acquire(&mem_done.free);
 1009784:	4638      	mov	r0, r7
 1009786:	f7fc fac7 	bl	1005d18 <mem_acquire>
		if (!rx) {
 100978a:	b138      	cbz	r0, 100979c <ll_init+0xb8>
		rx->link = link;
 100978c:	6006      	str	r6, [r0, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 100978e:	78eb      	ldrb	r3, [r5, #3]
 1009790:	782a      	ldrb	r2, [r5, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 1009792:	fb02 5303 	mla	r3, r2, r3, r5
 1009796:	6058      	str	r0, [r3, #4]
	*last = idx; /* Commit: Update write index */
 1009798:	70ec      	strb	r4, [r5, #3]
}
 100979a:	e7e5      	b.n	1009768 <ll_init+0x84>
			mem_release(link, &mem_link_done.free);
 100979c:	4630      	mov	r0, r6
 100979e:	4970      	ldr	r1, [pc, #448]	; (1009960 <ll_init+0x27c>)
 10097a0:	f7fc fad4 	bl	1005d4c <mem_release>
	mem_init(mem_pdu_rx.pool, (PDU_RX_NODE_POOL_ELEMENT_SIZE),
 10097a4:	4b70      	ldr	r3, [pc, #448]	; (1009968 <ll_init+0x284>)
 10097a6:	2212      	movs	r2, #18
 10097a8:	1d18      	adds	r0, r3, #4
 10097aa:	f44f 7190 	mov.w	r1, #288	; 0x120
 10097ae:	f7fc fa85 	bl	1005cbc <mem_init>
	mem_init(mem_link_rx.pool, sizeof(memq_link_t),
 10097b2:	4b6e      	ldr	r3, [pc, #440]	; (100996c <ll_init+0x288>)
 10097b4:	2222      	movs	r2, #34	; 0x22
 10097b6:	1d18      	adds	r0, r3, #4
 10097b8:	2108      	movs	r1, #8
 10097ba:	f7fc fa7f 	bl	1005cbc <mem_init>
	link = mem_acquire(&mem_link_rx.free);
 10097be:	486b      	ldr	r0, [pc, #428]	; (100996c <ll_init+0x288>)
 10097c0:	f7fc faaa 	bl	1005d18 <mem_acquire>
	LL_ASSERT(link);
 10097c4:	4604      	mov	r4, r0
 10097c6:	2800      	cmp	r0, #0
 10097c8:	f000 80ac 	beq.w	1009924 <ll_init+0x240>
	MEMQ_INIT(ull_rx, link);
 10097cc:	4a68      	ldr	r2, [pc, #416]	; (1009970 <ll_init+0x28c>)
 10097ce:	4620      	mov	r0, r4
 10097d0:	1f11      	subs	r1, r2, #4
 10097d2:	f7fc faf7 	bl	1005dc4 <memq_init>
	link = mem_acquire(&mem_link_rx.free);
 10097d6:	4865      	ldr	r0, [pc, #404]	; (100996c <ll_init+0x288>)
 10097d8:	f7fc fa9e 	bl	1005d18 <mem_acquire>
	LL_ASSERT(link);
 10097dc:	4604      	mov	r4, r0
 10097de:	2800      	cmp	r0, #0
 10097e0:	f000 809a 	beq.w	1009918 <ll_init+0x234>
	MEMQ_INIT(ll_rx, link);
 10097e4:	4a63      	ldr	r2, [pc, #396]	; (1009974 <ll_init+0x290>)
	mem_link_rx.quota_pdu = RX_CNT;
 10097e6:	4d64      	ldr	r5, [pc, #400]	; (1009978 <ll_init+0x294>)
	MEMQ_INIT(ll_rx, link);
 10097e8:	4620      	mov	r0, r4
 10097ea:	1f11      	subs	r1, r2, #4
 10097ec:	f7fc faea 	bl	1005dc4 <memq_init>
	mem_link_rx.quota_pdu = RX_CNT;
 10097f0:	462e      	mov	r6, r5
 10097f2:	2310      	movs	r3, #16
		link->mem = NULL;
 10097f4:	2700      	movs	r7, #0
 10097f6:	f8df 918c 	ldr.w	r9, [pc, #396]	; 1009984 <ll_init+0x2a0>
		rx = mem_acquire(&mem_pdu_rx.free);
 10097fa:	f8df 816c 	ldr.w	r8, [pc, #364]	; 1009968 <ll_init+0x284>
 10097fe:	f899 4003 	ldrb.w	r4, [r9, #3]
	mem_link_rx.quota_pdu = RX_CNT;
 1009802:	f806 3b04 	strb.w	r3, [r6], #4
	if (last == count) {
 1009806:	f899 3001 	ldrb.w	r3, [r9, #1]
	last = last + 1;
 100980a:	3401      	adds	r4, #1
 100980c:	b2e4      	uxtb	r4, r4
		last = 0U;
 100980e:	42a3      	cmp	r3, r4
 1009810:	bf08      	it	eq
 1009812:	2400      	moveq	r4, #0
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
 1009814:	f899 3002 	ldrb.w	r3, [r9, #2]
	if (last == first) {
 1009818:	429c      	cmp	r4, r3
 100981a:	d049      	beq.n	10098b0 <ll_init+0x1cc>
		link = mem_acquire(&mem_link_rx.free);
 100981c:	4630      	mov	r0, r6
 100981e:	f7fc fa7b 	bl	1005d18 <mem_acquire>
		if (!link) {
 1009822:	4682      	mov	sl, r0
 1009824:	2800      	cmp	r0, #0
 1009826:	d043      	beq.n	10098b0 <ll_init+0x1cc>
		rx = mem_acquire(&mem_pdu_rx.free);
 1009828:	4640      	mov	r0, r8
 100982a:	f7fc fa75 	bl	1005d18 <mem_acquire>
		if (!rx) {
 100982e:	2800      	cmp	r0, #0
 1009830:	d03a      	beq.n	10098a8 <ll_init+0x1c4>
		link->mem = NULL;
 1009832:	f8ca 7004 	str.w	r7, [sl, #4]
		rx->link = link;
 1009836:	f8c0 a000 	str.w	sl, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 100983a:	f899 2003 	ldrb.w	r2, [r9, #3]
 100983e:	f899 1000 	ldrb.w	r1, [r9]
	mem_link_rx.quota_pdu += delta;
 1009842:	782b      	ldrb	r3, [r5, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 1009844:	fb01 9202 	mla	r2, r1, r2, r9
 1009848:	3b01      	subs	r3, #1
 100984a:	b2db      	uxtb	r3, r3
 100984c:	6050      	str	r0, [r2, #4]
 100984e:	702b      	strb	r3, [r5, #0]
	*last = idx; /* Commit: Update write index */
 1009850:	f889 4003 	strb.w	r4, [r9, #3]
	while (mem_link_rx.quota_pdu &&
 1009854:	2b00      	cmp	r3, #0
 1009856:	d1d6      	bne.n	1009806 <ll_init+0x122>
	err = lll_adv_init();
 1009858:	f007 f890 	bl	101097c <lll_adv_init>
	if (err) {
 100985c:	4604      	mov	r4, r0
 100985e:	2800      	cmp	r0, #0
 1009860:	f47f af6d 	bne.w	100973e <ll_init+0x5a>
	err = ull_adv_init();
 1009864:	f001 f996 	bl	100ab94 <ull_adv_init>
	if (err) {
 1009868:	4604      	mov	r4, r0
 100986a:	2800      	cmp	r0, #0
 100986c:	f47f af67 	bne.w	100973e <ll_init+0x5a>
	err = lll_scan_init();
 1009870:	f007 fb2e 	bl	1010ed0 <lll_scan_init>
	if (err) {
 1009874:	4604      	mov	r4, r0
 1009876:	2800      	cmp	r0, #0
 1009878:	f47f af61 	bne.w	100973e <ll_init+0x5a>
	err = ull_scan_init();
 100987c:	f001 fa92 	bl	100ada4 <ull_scan_init>
	if (err) {
 1009880:	4604      	mov	r4, r0
 1009882:	2800      	cmp	r0, #0
 1009884:	f47f af5b 	bne.w	100973e <ll_init+0x5a>
	err = lll_conn_init();
 1009888:	f007 fbea 	bl	1011060 <lll_conn_init>
	if (err) {
 100988c:	4604      	mov	r4, r0
 100988e:	2800      	cmp	r0, #0
 1009890:	f47f af55 	bne.w	100973e <ll_init+0x5a>
	err = ull_conn_init();
 1009894:	f002 fa00 	bl	100bc98 <ull_conn_init>
	if (err) {
 1009898:	4604      	mov	r4, r0
 100989a:	2800      	cmp	r0, #0
 100989c:	f47f af4f 	bne.w	100973e <ll_init+0x5a>
		ull_filter_reset(true);
 10098a0:	2001      	movs	r0, #1
 10098a2:	f005 ffb1 	bl	100f808 <ull_filter_reset>
	return  0;
 10098a6:	e74a      	b.n	100973e <ll_init+0x5a>
			mem_release(link, &mem_link_rx.free);
 10098a8:	4650      	mov	r0, sl
 10098aa:	4930      	ldr	r1, [pc, #192]	; (100996c <ll_init+0x288>)
 10098ac:	f7fc fa4e 	bl	1005d4c <mem_release>
	if (max > mem_link_rx.quota_pdu) {
 10098b0:	782b      	ldrb	r3, [r5, #0]
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 10098b2:	1e5f      	subs	r7, r3, #1
 10098b4:	b2ff      	uxtb	r7, r7
 10098b6:	2b00      	cmp	r3, #0
 10098b8:	d0ce      	beq.n	1009858 <ll_init+0x174>
 10098ba:	4e30      	ldr	r6, [pc, #192]	; (100997c <ll_init+0x298>)
		link = mem_acquire(&mem_link_rx.free);
 10098bc:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 100996c <ll_init+0x288>
 10098c0:	78f4      	ldrb	r4, [r6, #3]
		rx = mem_acquire(&mem_pdu_rx.free);
 10098c2:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 1009968 <ll_init+0x284>
	if (last == count) {
 10098c6:	7873      	ldrb	r3, [r6, #1]
	last = last + 1;
 10098c8:	3401      	adds	r4, #1
 10098ca:	b2e4      	uxtb	r4, r4
		last = 0U;
 10098cc:	42a3      	cmp	r3, r4
 10098ce:	bf08      	it	eq
 10098d0:	2400      	moveq	r4, #0
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 10098d2:	78b3      	ldrb	r3, [r6, #2]
	if (last == first) {
 10098d4:	429c      	cmp	r4, r3
 10098d6:	d0bf      	beq.n	1009858 <ll_init+0x174>
		link = mem_acquire(&mem_link_rx.free);
 10098d8:	4648      	mov	r0, r9
 10098da:	f7fc fa1d 	bl	1005d18 <mem_acquire>
		if (!link) {
 10098de:	4682      	mov	sl, r0
 10098e0:	2800      	cmp	r0, #0
 10098e2:	d0b9      	beq.n	1009858 <ll_init+0x174>
		rx = mem_acquire(&mem_pdu_rx.free);
 10098e4:	4640      	mov	r0, r8
 10098e6:	f7fc fa17 	bl	1005d18 <mem_acquire>
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 10098ea:	3f01      	subs	r7, #1
 10098ec:	b2ff      	uxtb	r7, r7
		if (!rx) {
 10098ee:	b1f8      	cbz	r0, 1009930 <ll_init+0x24c>
		rx->link = link;
 10098f0:	f8c0 a000 	str.w	sl, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 10098f4:	78f2      	ldrb	r2, [r6, #3]
 10098f6:	7831      	ldrb	r1, [r6, #0]
	mem_link_rx.quota_pdu += delta;
 10098f8:	782b      	ldrb	r3, [r5, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 10098fa:	fb01 6202 	mla	r2, r1, r2, r6
 10098fe:	3b01      	subs	r3, #1
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1009900:	2fff      	cmp	r7, #255	; 0xff
 1009902:	6050      	str	r0, [r2, #4]
	mem_link_rx.quota_pdu += delta;
 1009904:	702b      	strb	r3, [r5, #0]
	*last = idx; /* Commit: Update write index */
 1009906:	70f4      	strb	r4, [r6, #3]
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1009908:	d1dd      	bne.n	10098c6 <ll_init+0x1e2>
 100990a:	e7a5      	b.n	1009858 <ll_init+0x174>
	LL_ASSERT(!err);
 100990c:	f240 1117 	movw	r1, #279	; 0x117
 1009910:	481b      	ldr	r0, [pc, #108]	; (1009980 <ll_init+0x29c>)
 1009912:	f7f9 feb5 	bl	1003680 <bt_ctlr_assert_handle>
 1009916:	e709      	b.n	100972c <ll_init+0x48>
	LL_ASSERT(link);
 1009918:	f240 41bd 	movw	r1, #1213	; 0x4bd
 100991c:	4818      	ldr	r0, [pc, #96]	; (1009980 <ll_init+0x29c>)
 100991e:	f7f9 feaf 	bl	1003680 <bt_ctlr_assert_handle>
 1009922:	e75f      	b.n	10097e4 <ll_init+0x100>
	LL_ASSERT(link);
 1009924:	f240 41b6 	movw	r1, #1206	; 0x4b6
 1009928:	4815      	ldr	r0, [pc, #84]	; (1009980 <ll_init+0x29c>)
 100992a:	f7f9 fea9 	bl	1003680 <bt_ctlr_assert_handle>
 100992e:	e74d      	b.n	10097cc <ll_init+0xe8>
			mem_release(link, &mem_link_rx.free);
 1009930:	4650      	mov	r0, sl
 1009932:	490e      	ldr	r1, [pc, #56]	; (100996c <ll_init+0x288>)
 1009934:	f7fc fa0a 	bl	1005d4c <mem_release>
			break;
 1009938:	e78e      	b.n	1009858 <ll_init+0x174>
 100993a:	bf00      	nop
 100993c:	210023e8 	.word	0x210023e8
 1009940:	21002a30 	.word	0x21002a30
 1009944:	010127d5 	.word	0x010127d5
 1009948:	010126fd 	.word	0x010126fd
 100994c:	010126c5 	.word	0x010126c5
 1009950:	210027f4 	.word	0x210027f4
 1009954:	21002404 	.word	0x21002404
 1009958:	210023ec 	.word	0x210023ec
 100995c:	21000db4 	.word	0x21000db4
 1009960:	21000e60 	.word	0x21000e60
 1009964:	210000b0 	.word	0x210000b0
 1009968:	21000f94 	.word	0x21000f94
 100996c:	21000e80 	.word	0x21000e80
 1009970:	210023e4 	.word	0x210023e4
 1009974:	210023dc 	.word	0x210023dc
 1009978:	21000e7c 	.word	0x21000e7c
 100997c:	210000d8 	.word	0x210000d8
 1009980:	01018834 	.word	0x01018834
 1009984:	210000c4 	.word	0x210000c4

01009988 <ll_reset>:
{
 1009988:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100998c:	b087      	sub	sp, #28
	err = ull_adv_reset();
 100998e:	f001 f903 	bl	100ab98 <ull_adv_reset>
	LL_ASSERT(!err);
 1009992:	2800      	cmp	r0, #0
 1009994:	f040 80eb 	bne.w	1009b6e <ll_reset+0x1e6>
	err = ull_scan_reset();
 1009998:	f001 fab6 	bl	100af08 <ull_scan_reset>
	LL_ASSERT(!err);
 100999c:	2800      	cmp	r0, #0
 100999e:	f040 80f0 	bne.w	1009b82 <ll_reset+0x1fa>
		err = ll_connect_disable(&rx);
 10099a2:	4668      	mov	r0, sp
 10099a4:	f005 f808 	bl	100e9b8 <ll_connect_disable>
		if (!err) {
 10099a8:	2800      	cmp	r0, #0
 10099aa:	f000 80f5 	beq.w	1009b98 <ll_reset+0x210>
	err = ull_conn_reset();
 10099ae:	f002 f975 	bl	100bc9c <ull_conn_reset>
	LL_ASSERT(!err);
 10099b2:	2800      	cmp	r0, #0
 10099b4:	f040 8101 	bne.w	1009bba <ll_reset+0x232>
	MFIFO_INIT(tx_ack);
 10099b8:	2400      	movs	r4, #0
 10099ba:	4b91      	ldr	r3, [pc, #580]	; (1009c00 <ll_reset+0x278>)
		ull_filter_reset(false);
 10099bc:	4620      	mov	r0, r4
	MFIFO_INIT(tx_ack);
 10099be:	805c      	strh	r4, [r3, #2]
		ull_filter_reset(false);
 10099c0:	f005 ff22 	bl	100f808 <ull_filter_reset>
	MFIFO_INIT(done);
 10099c4:	4e8f      	ldr	r6, [pc, #572]	; (1009c04 <ll_reset+0x27c>)
	MFIFO_INIT(pdu_rx_free);
 10099c6:	4f90      	ldr	r7, [pc, #576]	; (1009c08 <ll_reset+0x280>)
	MFIFO_INIT(prep);
 10099c8:	4b90      	ldr	r3, [pc, #576]	; (1009c0c <ll_reset+0x284>)
	MFIFO_INIT(ll_pdu_rx_free);
 10099ca:	4d91      	ldr	r5, [pc, #580]	; (1009c10 <ll_reset+0x288>)
	MFIFO_INIT(prep);
 10099cc:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(done);
 10099ce:	8074      	strh	r4, [r6, #2]
	MFIFO_INIT(pdu_rx_free);
 10099d0:	807c      	strh	r4, [r7, #2]
	MFIFO_INIT(ll_pdu_rx_free);
 10099d2:	806c      	strh	r4, [r5, #2]
 10099d4:	2201      	movs	r2, #1
 10099d6:	4621      	mov	r1, r4
 10099d8:	4668      	mov	r0, sp
 10099da:	f00e f920 	bl	1017c1e <z_impl_k_sem_init>
		mfy.param = &sem;
 10099de:	4b8d      	ldr	r3, [pc, #564]	; (1009c14 <ll_reset+0x28c>)
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
 10099e0:	4622      	mov	r2, r4
 10099e2:	4621      	mov	r1, r4
 10099e4:	2003      	movs	r0, #3
		mfy.param = &sem;
 10099e6:	f8c3 d008 	str.w	sp, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
 10099ea:	f7fc fa6d 	bl	1005ec8 <mayfly_enqueue>
		LL_ASSERT(!retval);
 10099ee:	2800      	cmp	r0, #0
 10099f0:	f040 80e9 	bne.w	1009bc6 <ll_reset+0x23e>
	return z_impl_k_sem_take(sem, timeout);
 10099f4:	f04f 32ff 	mov.w	r2, #4294967295
 10099f8:	f04f 33ff 	mov.w	r3, #4294967295
 10099fc:	4668      	mov	r0, sp
 10099fe:	f00a fef9 	bl	10147f4 <z_impl_k_sem_take>
	mem_init(mem_done.pool, sizeof(struct node_rx_event_done),
 1009a02:	4b85      	ldr	r3, [pc, #532]	; (1009c18 <ll_reset+0x290>)
 1009a04:	2203      	movs	r2, #3
 1009a06:	1d18      	adds	r0, r3, #4
 1009a08:	2138      	movs	r1, #56	; 0x38
 1009a0a:	f7fc f957 	bl	1005cbc <mem_init>
	mem_init(mem_link_done.pool, sizeof(memq_link_t), EVENT_DONE_MAX,
 1009a0e:	4b83      	ldr	r3, [pc, #524]	; (1009c1c <ll_reset+0x294>)
 1009a10:	2203      	movs	r2, #3
 1009a12:	2108      	movs	r1, #8
 1009a14:	1d18      	adds	r0, r3, #4
 1009a16:	f7fc f951 	bl	1005cbc <mem_init>
		link = mem_acquire(&mem_link_done.free);
 1009a1a:	f8df 9200 	ldr.w	r9, [pc, #512]	; 1009c1c <ll_reset+0x294>
 1009a1e:	78f4      	ldrb	r4, [r6, #3]
		rx = mem_acquire(&mem_done.free);
 1009a20:	f8df 81f4 	ldr.w	r8, [pc, #500]	; 1009c18 <ll_reset+0x290>
	if (last == count) {
 1009a24:	7873      	ldrb	r3, [r6, #1]
	last = last + 1;
 1009a26:	3401      	adds	r4, #1
 1009a28:	b2e4      	uxtb	r4, r4
		last = 0U;
 1009a2a:	42a3      	cmp	r3, r4
 1009a2c:	bf08      	it	eq
 1009a2e:	2400      	moveq	r4, #0
	while (MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
 1009a30:	78b3      	ldrb	r3, [r6, #2]
	if (last == first) {
 1009a32:	429c      	cmp	r4, r3
 1009a34:	d015      	beq.n	1009a62 <ll_reset+0xda>
		link = mem_acquire(&mem_link_done.free);
 1009a36:	4648      	mov	r0, r9
 1009a38:	f7fc f96e 	bl	1005d18 <mem_acquire>
		if (!link) {
 1009a3c:	4682      	mov	sl, r0
 1009a3e:	b180      	cbz	r0, 1009a62 <ll_reset+0xda>
		rx = mem_acquire(&mem_done.free);
 1009a40:	4640      	mov	r0, r8
 1009a42:	f7fc f969 	bl	1005d18 <mem_acquire>
		if (!rx) {
 1009a46:	b140      	cbz	r0, 1009a5a <ll_reset+0xd2>
		rx->link = link;
 1009a48:	f8c0 a000 	str.w	sl, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 1009a4c:	78f3      	ldrb	r3, [r6, #3]
 1009a4e:	7832      	ldrb	r2, [r6, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 1009a50:	fb02 6303 	mla	r3, r2, r3, r6
 1009a54:	6058      	str	r0, [r3, #4]
	*last = idx; /* Commit: Update write index */
 1009a56:	70f4      	strb	r4, [r6, #3]
}
 1009a58:	e7e4      	b.n	1009a24 <ll_reset+0x9c>
			mem_release(link, &mem_link_done.free);
 1009a5a:	4650      	mov	r0, sl
 1009a5c:	496f      	ldr	r1, [pc, #444]	; (1009c1c <ll_reset+0x294>)
 1009a5e:	f7fc f975 	bl	1005d4c <mem_release>
	mem_init(mem_pdu_rx.pool, (PDU_RX_NODE_POOL_ELEMENT_SIZE),
 1009a62:	4b6f      	ldr	r3, [pc, #444]	; (1009c20 <ll_reset+0x298>)
 1009a64:	2212      	movs	r2, #18
 1009a66:	1d18      	adds	r0, r3, #4
 1009a68:	f44f 7190 	mov.w	r1, #288	; 0x120
 1009a6c:	f7fc f926 	bl	1005cbc <mem_init>
	mem_init(mem_link_rx.pool, sizeof(memq_link_t),
 1009a70:	4b6c      	ldr	r3, [pc, #432]	; (1009c24 <ll_reset+0x29c>)
 1009a72:	2222      	movs	r2, #34	; 0x22
 1009a74:	1d18      	adds	r0, r3, #4
 1009a76:	2108      	movs	r1, #8
 1009a78:	f7fc f920 	bl	1005cbc <mem_init>
	link = mem_acquire(&mem_link_rx.free);
 1009a7c:	4869      	ldr	r0, [pc, #420]	; (1009c24 <ll_reset+0x29c>)
 1009a7e:	f7fc f94b 	bl	1005d18 <mem_acquire>
	LL_ASSERT(link);
 1009a82:	4604      	mov	r4, r0
 1009a84:	2800      	cmp	r0, #0
 1009a86:	f000 80aa 	beq.w	1009bde <ll_reset+0x256>
	MEMQ_INIT(ull_rx, link);
 1009a8a:	4a67      	ldr	r2, [pc, #412]	; (1009c28 <ll_reset+0x2a0>)
 1009a8c:	4620      	mov	r0, r4
 1009a8e:	1f11      	subs	r1, r2, #4
 1009a90:	f7fc f998 	bl	1005dc4 <memq_init>
	link = mem_acquire(&mem_link_rx.free);
 1009a94:	4863      	ldr	r0, [pc, #396]	; (1009c24 <ll_reset+0x29c>)
 1009a96:	f7fc f93f 	bl	1005d18 <mem_acquire>
	LL_ASSERT(link);
 1009a9a:	4604      	mov	r4, r0
 1009a9c:	2800      	cmp	r0, #0
 1009a9e:	f000 8098 	beq.w	1009bd2 <ll_reset+0x24a>
	MEMQ_INIT(ll_rx, link);
 1009aa2:	4a62      	ldr	r2, [pc, #392]	; (1009c2c <ll_reset+0x2a4>)
	mem_link_rx.quota_pdu = RX_CNT;
 1009aa4:	4e62      	ldr	r6, [pc, #392]	; (1009c30 <ll_reset+0x2a8>)
	MEMQ_INIT(ll_rx, link);
 1009aa6:	4620      	mov	r0, r4
 1009aa8:	1f11      	subs	r1, r2, #4
 1009aaa:	f7fc f98b 	bl	1005dc4 <memq_init>
	mem_link_rx.quota_pdu = RX_CNT;
 1009aae:	46b3      	mov	fp, r6
 1009ab0:	2310      	movs	r3, #16
		link->mem = NULL;
 1009ab2:	f04f 0800 	mov.w	r8, #0
 1009ab6:	78ec      	ldrb	r4, [r5, #3]
		rx = mem_acquire(&mem_pdu_rx.free);
 1009ab8:	f8df 9164 	ldr.w	r9, [pc, #356]	; 1009c20 <ll_reset+0x298>
	mem_link_rx.quota_pdu = RX_CNT;
 1009abc:	f80b 3b04 	strb.w	r3, [fp], #4
	if (last == count) {
 1009ac0:	786b      	ldrb	r3, [r5, #1]
	last = last + 1;
 1009ac2:	3401      	adds	r4, #1
 1009ac4:	b2e4      	uxtb	r4, r4
		last = 0U;
 1009ac6:	42a3      	cmp	r3, r4
 1009ac8:	bf08      	it	eq
 1009aca:	2400      	moveq	r4, #0
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
 1009acc:	78ab      	ldrb	r3, [r5, #2]
	if (last == first) {
 1009ace:	429c      	cmp	r4, r3
 1009ad0:	d01f      	beq.n	1009b12 <ll_reset+0x18a>
		link = mem_acquire(&mem_link_rx.free);
 1009ad2:	4658      	mov	r0, fp
 1009ad4:	f7fc f920 	bl	1005d18 <mem_acquire>
		if (!link) {
 1009ad8:	4682      	mov	sl, r0
 1009ada:	b1d0      	cbz	r0, 1009b12 <ll_reset+0x18a>
		rx = mem_acquire(&mem_pdu_rx.free);
 1009adc:	4648      	mov	r0, r9
 1009ade:	f7fc f91b 	bl	1005d18 <mem_acquire>
		if (!rx) {
 1009ae2:	b190      	cbz	r0, 1009b0a <ll_reset+0x182>
		link->mem = NULL;
 1009ae4:	f8ca 8004 	str.w	r8, [sl, #4]
		rx->link = link;
 1009ae8:	f8c0 a000 	str.w	sl, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 1009aec:	78ea      	ldrb	r2, [r5, #3]
 1009aee:	7829      	ldrb	r1, [r5, #0]
	mem_link_rx.quota_pdu += delta;
 1009af0:	7833      	ldrb	r3, [r6, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 1009af2:	fb01 5202 	mla	r2, r1, r2, r5
 1009af6:	3b01      	subs	r3, #1
 1009af8:	b2db      	uxtb	r3, r3
 1009afa:	6050      	str	r0, [r2, #4]
 1009afc:	7033      	strb	r3, [r6, #0]
	*last = idx; /* Commit: Update write index */
 1009afe:	70ec      	strb	r4, [r5, #3]
	while (mem_link_rx.quota_pdu &&
 1009b00:	2b00      	cmp	r3, #0
 1009b02:	d1dd      	bne.n	1009ac0 <ll_reset+0x138>
}
 1009b04:	b007      	add	sp, #28
 1009b06:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mem_release(link, &mem_link_rx.free);
 1009b0a:	4650      	mov	r0, sl
 1009b0c:	4945      	ldr	r1, [pc, #276]	; (1009c24 <ll_reset+0x29c>)
 1009b0e:	f7fc f91d 	bl	1005d4c <mem_release>
	if (max > mem_link_rx.quota_pdu) {
 1009b12:	7833      	ldrb	r3, [r6, #0]
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1009b14:	1e5d      	subs	r5, r3, #1
 1009b16:	b2ed      	uxtb	r5, r5
 1009b18:	2b00      	cmp	r3, #0
 1009b1a:	d0f3      	beq.n	1009b04 <ll_reset+0x17c>
 1009b1c:	78fc      	ldrb	r4, [r7, #3]
		link = mem_acquire(&mem_link_rx.free);
 1009b1e:	f8df 9104 	ldr.w	r9, [pc, #260]	; 1009c24 <ll_reset+0x29c>
		rx = mem_acquire(&mem_pdu_rx.free);
 1009b22:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 1009c20 <ll_reset+0x298>
	if (last == count) {
 1009b26:	787b      	ldrb	r3, [r7, #1]
	last = last + 1;
 1009b28:	3401      	adds	r4, #1
 1009b2a:	b2e4      	uxtb	r4, r4
		last = 0U;
 1009b2c:	42a3      	cmp	r3, r4
 1009b2e:	bf08      	it	eq
 1009b30:	2400      	moveq	r4, #0
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1009b32:	78bb      	ldrb	r3, [r7, #2]
	if (last == first) {
 1009b34:	429c      	cmp	r4, r3
 1009b36:	d0e5      	beq.n	1009b04 <ll_reset+0x17c>
		link = mem_acquire(&mem_link_rx.free);
 1009b38:	4648      	mov	r0, r9
 1009b3a:	f7fc f8ed 	bl	1005d18 <mem_acquire>
		if (!link) {
 1009b3e:	4682      	mov	sl, r0
 1009b40:	2800      	cmp	r0, #0
 1009b42:	d0df      	beq.n	1009b04 <ll_reset+0x17c>
		rx = mem_acquire(&mem_pdu_rx.free);
 1009b44:	4640      	mov	r0, r8
 1009b46:	f7fc f8e7 	bl	1005d18 <mem_acquire>
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1009b4a:	3d01      	subs	r5, #1
 1009b4c:	b2ed      	uxtb	r5, r5
		if (!rx) {
 1009b4e:	2800      	cmp	r0, #0
 1009b50:	d04b      	beq.n	1009bea <ll_reset+0x262>
		rx->link = link;
 1009b52:	f8c0 a000 	str.w	sl, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 1009b56:	78fa      	ldrb	r2, [r7, #3]
 1009b58:	7839      	ldrb	r1, [r7, #0]
	mem_link_rx.quota_pdu += delta;
 1009b5a:	7833      	ldrb	r3, [r6, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 1009b5c:	fb01 7202 	mla	r2, r1, r2, r7
 1009b60:	3b01      	subs	r3, #1
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1009b62:	2dff      	cmp	r5, #255	; 0xff
 1009b64:	6050      	str	r0, [r2, #4]
	mem_link_rx.quota_pdu += delta;
 1009b66:	7033      	strb	r3, [r6, #0]
	*last = idx; /* Commit: Update write index */
 1009b68:	70fc      	strb	r4, [r7, #3]
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1009b6a:	d1dc      	bne.n	1009b26 <ll_reset+0x19e>
 1009b6c:	e7ca      	b.n	1009b04 <ll_reset+0x17c>
	LL_ASSERT(!err);
 1009b6e:	f240 1165 	movw	r1, #357	; 0x165
 1009b72:	4830      	ldr	r0, [pc, #192]	; (1009c34 <ll_reset+0x2ac>)
 1009b74:	f7f9 fd84 	bl	1003680 <bt_ctlr_assert_handle>
	err = ull_scan_reset();
 1009b78:	f001 f9c6 	bl	100af08 <ull_scan_reset>
	LL_ASSERT(!err);
 1009b7c:	2800      	cmp	r0, #0
 1009b7e:	f43f af10 	beq.w	10099a2 <ll_reset+0x1a>
 1009b82:	482c      	ldr	r0, [pc, #176]	; (1009c34 <ll_reset+0x2ac>)
 1009b84:	f240 116b 	movw	r1, #363	; 0x16b
 1009b88:	f7f9 fd7a 	bl	1003680 <bt_ctlr_assert_handle>
		err = ll_connect_disable(&rx);
 1009b8c:	4668      	mov	r0, sp
 1009b8e:	f004 ff13 	bl	100e9b8 <ll_connect_disable>
		if (!err) {
 1009b92:	2800      	cmp	r0, #0
 1009b94:	f47f af0b 	bne.w	10099ae <ll_reset+0x26>
			scan = ull_scan_is_enabled_get(0);
 1009b98:	f001 f9d8 	bl	100af4c <ull_scan_is_enabled_get>
			LL_ASSERT(scan);
 1009b9c:	4604      	mov	r4, r0
 1009b9e:	b348      	cbz	r0, 1009bf4 <ll_reset+0x26c>
			scan->lll.conn = NULL;
 1009ba0:	2200      	movs	r2, #0
			scan->is_enabled = 0U;
 1009ba2:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
			scan->lll.conn = NULL;
 1009ba6:	6262      	str	r2, [r4, #36]	; 0x24
			scan->is_enabled = 0U;
 1009ba8:	f36f 0300 	bfc	r3, #0, #1
 1009bac:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
	err = ull_conn_reset();
 1009bb0:	f002 f874 	bl	100bc9c <ull_conn_reset>
	LL_ASSERT(!err);
 1009bb4:	2800      	cmp	r0, #0
 1009bb6:	f43f aeff 	beq.w	10099b8 <ll_reset+0x30>
 1009bba:	f240 1185 	movw	r1, #389	; 0x185
 1009bbe:	481d      	ldr	r0, [pc, #116]	; (1009c34 <ll_reset+0x2ac>)
 1009bc0:	f7f9 fd5e 	bl	1003680 <bt_ctlr_assert_handle>
 1009bc4:	e6f8      	b.n	10099b8 <ll_reset+0x30>
		LL_ASSERT(!retval);
 1009bc6:	f240 11b7 	movw	r1, #439	; 0x1b7
 1009bca:	481a      	ldr	r0, [pc, #104]	; (1009c34 <ll_reset+0x2ac>)
 1009bcc:	f7f9 fd58 	bl	1003680 <bt_ctlr_assert_handle>
 1009bd0:	e710      	b.n	10099f4 <ll_reset+0x6c>
	LL_ASSERT(link);
 1009bd2:	f240 41bd 	movw	r1, #1213	; 0x4bd
 1009bd6:	4817      	ldr	r0, [pc, #92]	; (1009c34 <ll_reset+0x2ac>)
 1009bd8:	f7f9 fd52 	bl	1003680 <bt_ctlr_assert_handle>
 1009bdc:	e761      	b.n	1009aa2 <ll_reset+0x11a>
	LL_ASSERT(link);
 1009bde:	f240 41b6 	movw	r1, #1206	; 0x4b6
 1009be2:	4814      	ldr	r0, [pc, #80]	; (1009c34 <ll_reset+0x2ac>)
 1009be4:	f7f9 fd4c 	bl	1003680 <bt_ctlr_assert_handle>
 1009be8:	e74f      	b.n	1009a8a <ll_reset+0x102>
			mem_release(link, &mem_link_rx.free);
 1009bea:	4650      	mov	r0, sl
 1009bec:	490d      	ldr	r1, [pc, #52]	; (1009c24 <ll_reset+0x29c>)
 1009bee:	f7fc f8ad 	bl	1005d4c <mem_release>
			break;
 1009bf2:	e787      	b.n	1009b04 <ll_reset+0x17c>
			LL_ASSERT(scan);
 1009bf4:	f240 1179 	movw	r1, #377	; 0x179
 1009bf8:	480e      	ldr	r0, [pc, #56]	; (1009c34 <ll_reset+0x2ac>)
 1009bfa:	f7f9 fd41 	bl	1003680 <bt_ctlr_assert_handle>
 1009bfe:	e7cf      	b.n	1009ba0 <ll_reset+0x218>
 1009c00:	21000238 	.word	0x21000238
 1009c04:	210000b0 	.word	0x210000b0
 1009c08:	210000d8 	.word	0x210000d8
 1009c0c:	21000114 	.word	0x21000114
 1009c10:	210000c4 	.word	0x210000c4
 1009c14:	21000294 	.word	0x21000294
 1009c18:	21000db4 	.word	0x21000db4
 1009c1c:	21000e60 	.word	0x21000e60
 1009c20:	21000f94 	.word	0x21000f94
 1009c24:	21000e80 	.word	0x21000e80
 1009c28:	210023e4 	.word	0x210023e4
 1009c2c:	210023dc 	.word	0x210023dc
 1009c30:	21000e7c 	.word	0x21000e7c
 1009c34:	01018834 	.word	0x01018834

01009c38 <ll_rx_get>:
{
 1009c38:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1009c3c:	b085      	sub	sp, #20
 1009c3e:	e9cd 0100 	strd	r0, r1, [sp]
 1009c42:	4c5a      	ldr	r4, [pc, #360]	; (1009dac <ll_rx_get+0x174>)
				mem_release(link, &mem_link_rx.free);
 1009c44:	4d5a      	ldr	r5, [pc, #360]	; (1009db0 <ll_rx_get+0x178>)
 1009c46:	f8df 9170 	ldr.w	r9, [pc, #368]	; 1009db8 <ll_rx_get+0x180>
	*node_rx = NULL;
 1009c4a:	2300      	movs	r3, #0
 1009c4c:	9a00      	ldr	r2, [sp, #0]
 1009c4e:	6013      	str	r3, [r2, #0]
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
 1009c50:	e9d9 0100 	ldrd	r0, r1, [r9]
 1009c54:	aa03      	add	r2, sp, #12
 1009c56:	f7fc f8cb 	bl	1005df0 <memq_peek>
	if (link) {
 1009c5a:	4607      	mov	r7, r0
 1009c5c:	2800      	cmp	r0, #0
 1009c5e:	f000 809a 	beq.w	1009d96 <ll_rx_get+0x15e>
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, rx->ack_last);
 1009c62:	9b03      	ldr	r3, [sp, #12]
 1009c64:	4953      	ldr	r1, [pc, #332]	; (1009db4 <ll_rx_get+0x17c>)
 1009c66:	781a      	ldrb	r2, [r3, #0]
 1009c68:	9801      	ldr	r0, [sp, #4]
 1009c6a:	f7ff fb55 	bl	1009318 <tx_cmplt_get>
		if (!cmplt) {
 1009c6e:	4603      	mov	r3, r0
 1009c70:	2800      	cmp	r0, #0
 1009c72:	f040 8087 	bne.w	1009d84 <ll_rx_get+0x14c>
			f = mfifo_tx_ack.f;
 1009c76:	78a2      	ldrb	r2, [r4, #2]
 1009c78:	f88d 2009 	strb.w	r2, [sp, #9]
				cmplt_curr = tx_cmplt_get(&h, &f,
 1009c7c:	78e2      	ldrb	r2, [r4, #3]
 1009c7e:	f10d 0109 	add.w	r1, sp, #9
 1009c82:	f10d 000a 	add.w	r0, sp, #10
 1009c86:	461e      	mov	r6, r3
 1009c88:	f7ff fb46 	bl	1009318 <tx_cmplt_get>
 1009c8c:	ea46 0200 	orr.w	r2, r6, r0
			} while ((cmplt_prev != 0U) ||
 1009c90:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
				cmplt_curr = tx_cmplt_get(&h, &f,
 1009c94:	4603      	mov	r3, r0
			} while ((cmplt_prev != 0U) ||
 1009c96:	d1f1      	bne.n	1009c7c <ll_rx_get+0x44>
			if (rx->type == NODE_RX_TYPE_DC_PDU_RELEASE) {
 1009c98:	9b03      	ldr	r3, [sp, #12]
 1009c9a:	7919      	ldrb	r1, [r3, #4]
 1009c9c:	2903      	cmp	r1, #3
 1009c9e:	d16e      	bne.n	1009d7e <ll_rx_get+0x146>
				(void)memq_dequeue(memq_ll_rx.tail,
 1009ca0:	4945      	ldr	r1, [pc, #276]	; (1009db8 <ll_rx_get+0x180>)
 1009ca2:	f8d9 0004 	ldr.w	r0, [r9, #4]
 1009ca6:	f7fc f8ab 	bl	1005e00 <memq_dequeue>
				mem_release(link, &mem_link_rx.free);
 1009caa:	4638      	mov	r0, r7
 1009cac:	4943      	ldr	r1, [pc, #268]	; (1009dbc <ll_rx_get+0x184>)
 1009cae:	f7fc f84d 	bl	1005d4c <mem_release>
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
 1009cb2:	782b      	ldrb	r3, [r5, #0]
 1009cb4:	2b0f      	cmp	r3, #15
 1009cb6:	d85b      	bhi.n	1009d70 <ll_rx_get+0x138>
	mem_link_rx.quota_pdu += delta;
 1009cb8:	3301      	adds	r3, #1
				mem_release(rx, &mem_pdu_rx.free);
 1009cba:	4941      	ldr	r1, [pc, #260]	; (1009dc0 <ll_rx_get+0x188>)
 1009cbc:	9803      	ldr	r0, [sp, #12]
	mem_link_rx.quota_pdu += delta;
 1009cbe:	702b      	strb	r3, [r5, #0]
				mem_release(rx, &mem_pdu_rx.free);
 1009cc0:	f7fc f844 	bl	1005d4c <mem_release>
	while (mem_link_rx.quota_pdu &&
 1009cc4:	782b      	ldrb	r3, [r5, #0]
 1009cc6:	2b00      	cmp	r3, #0
 1009cc8:	d0bf      	beq.n	1009c4a <ll_rx_get+0x12>
 1009cca:	4f3e      	ldr	r7, [pc, #248]	; (1009dc4 <ll_rx_get+0x18c>)
		link = mem_acquire(&mem_link_rx.free);
 1009ccc:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 1009dbc <ll_rx_get+0x184>
 1009cd0:	78fe      	ldrb	r6, [r7, #3]
		rx = mem_acquire(&mem_pdu_rx.free);
 1009cd2:	f8df a0ec 	ldr.w	sl, [pc, #236]	; 1009dc0 <ll_rx_get+0x188>
	if (last == count) {
 1009cd6:	787b      	ldrb	r3, [r7, #1]
	last = last + 1;
 1009cd8:	3601      	adds	r6, #1
 1009cda:	b2f6      	uxtb	r6, r6
		last = 0U;
 1009cdc:	42b3      	cmp	r3, r6
 1009cde:	bf08      	it	eq
 1009ce0:	2600      	moveq	r6, #0
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
 1009ce2:	78bb      	ldrb	r3, [r7, #2]
	if (last == first) {
 1009ce4:	429e      	cmp	r6, r3
 1009ce6:	d01e      	beq.n	1009d26 <ll_rx_get+0xee>
		link = mem_acquire(&mem_link_rx.free);
 1009ce8:	4640      	mov	r0, r8
 1009cea:	f7fc f815 	bl	1005d18 <mem_acquire>
		if (!link) {
 1009cee:	4683      	mov	fp, r0
 1009cf0:	b1c8      	cbz	r0, 1009d26 <ll_rx_get+0xee>
		rx = mem_acquire(&mem_pdu_rx.free);
 1009cf2:	4650      	mov	r0, sl
 1009cf4:	f7fc f810 	bl	1005d18 <mem_acquire>
		if (!rx) {
 1009cf8:	b188      	cbz	r0, 1009d1e <ll_rx_get+0xe6>
		link->mem = NULL;
 1009cfa:	2300      	movs	r3, #0
 1009cfc:	f8cb 3004 	str.w	r3, [fp, #4]
		rx->link = link;
 1009d00:	f8c0 b000 	str.w	fp, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 1009d04:	78fa      	ldrb	r2, [r7, #3]
 1009d06:	7839      	ldrb	r1, [r7, #0]
	mem_link_rx.quota_pdu += delta;
 1009d08:	782b      	ldrb	r3, [r5, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 1009d0a:	fb01 7202 	mla	r2, r1, r2, r7
 1009d0e:	3b01      	subs	r3, #1
 1009d10:	b2db      	uxtb	r3, r3
 1009d12:	6050      	str	r0, [r2, #4]
 1009d14:	702b      	strb	r3, [r5, #0]
	*last = idx; /* Commit: Update write index */
 1009d16:	70fe      	strb	r6, [r7, #3]
	while (mem_link_rx.quota_pdu &&
 1009d18:	2b00      	cmp	r3, #0
 1009d1a:	d1dc      	bne.n	1009cd6 <ll_rx_get+0x9e>
 1009d1c:	e795      	b.n	1009c4a <ll_rx_get+0x12>
			mem_release(link, &mem_link_rx.free);
 1009d1e:	4658      	mov	r0, fp
 1009d20:	4926      	ldr	r1, [pc, #152]	; (1009dbc <ll_rx_get+0x184>)
 1009d22:	f7fc f813 	bl	1005d4c <mem_release>
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1009d26:	782b      	ldrb	r3, [r5, #0]
 1009d28:	2b00      	cmp	r3, #0
 1009d2a:	d08e      	beq.n	1009c4a <ll_rx_get+0x12>
 1009d2c:	4f26      	ldr	r7, [pc, #152]	; (1009dc8 <ll_rx_get+0x190>)
	last = last + 1;
 1009d2e:	78fe      	ldrb	r6, [r7, #3]
	if (last == count) {
 1009d30:	787b      	ldrb	r3, [r7, #1]
	last = last + 1;
 1009d32:	3601      	adds	r6, #1
 1009d34:	b2f6      	uxtb	r6, r6
		last = 0U;
 1009d36:	42b3      	cmp	r3, r6
 1009d38:	bf08      	it	eq
 1009d3a:	2600      	moveq	r6, #0
 1009d3c:	78bb      	ldrb	r3, [r7, #2]
	if (last == first) {
 1009d3e:	429e      	cmp	r6, r3
 1009d40:	d083      	beq.n	1009c4a <ll_rx_get+0x12>
		link = mem_acquire(&mem_link_rx.free);
 1009d42:	481e      	ldr	r0, [pc, #120]	; (1009dbc <ll_rx_get+0x184>)
 1009d44:	f7fb ffe8 	bl	1005d18 <mem_acquire>
		if (!link) {
 1009d48:	4680      	mov	r8, r0
 1009d4a:	2800      	cmp	r0, #0
 1009d4c:	f43f af7d 	beq.w	1009c4a <ll_rx_get+0x12>
		rx = mem_acquire(&mem_pdu_rx.free);
 1009d50:	481b      	ldr	r0, [pc, #108]	; (1009dc0 <ll_rx_get+0x188>)
 1009d52:	f7fb ffe1 	bl	1005d18 <mem_acquire>
		if (!rx) {
 1009d56:	b1c8      	cbz	r0, 1009d8c <ll_rx_get+0x154>
		rx->link = link;
 1009d58:	f8c0 8000 	str.w	r8, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 1009d5c:	78fa      	ldrb	r2, [r7, #3]
 1009d5e:	7839      	ldrb	r1, [r7, #0]
	mem_link_rx.quota_pdu += delta;
 1009d60:	782b      	ldrb	r3, [r5, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 1009d62:	fb01 7202 	mla	r2, r1, r2, r7
 1009d66:	3b01      	subs	r3, #1
 1009d68:	6050      	str	r0, [r2, #4]
 1009d6a:	702b      	strb	r3, [r5, #0]
	*last = idx; /* Commit: Update write index */
 1009d6c:	70fe      	strb	r6, [r7, #3]
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1009d6e:	e76c      	b.n	1009c4a <ll_rx_get+0x12>
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
 1009d70:	f44f 7159 	mov.w	r1, #868	; 0x364
 1009d74:	4815      	ldr	r0, [pc, #84]	; (1009dcc <ll_rx_get+0x194>)
 1009d76:	f7f9 fc83 	bl	1003680 <bt_ctlr_assert_handle>
 1009d7a:	782b      	ldrb	r3, [r5, #0]
 1009d7c:	e79c      	b.n	1009cb8 <ll_rx_get+0x80>
			*node_rx = rx;
 1009d7e:	9900      	ldr	r1, [sp, #0]
 1009d80:	600b      	str	r3, [r1, #0]
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, rx->ack_last);
 1009d82:	4613      	mov	r3, r2
}
 1009d84:	4618      	mov	r0, r3
 1009d86:	b005      	add	sp, #20
 1009d88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mem_release(link, &mem_link_rx.free);
 1009d8c:	4640      	mov	r0, r8
 1009d8e:	490b      	ldr	r1, [pc, #44]	; (1009dbc <ll_rx_get+0x184>)
 1009d90:	f7fb ffdc 	bl	1005d4c <mem_release>
			break;
 1009d94:	e759      	b.n	1009c4a <ll_rx_get+0x12>
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, mfifo_tx_ack.l);
 1009d96:	78e2      	ldrb	r2, [r4, #3]
 1009d98:	9801      	ldr	r0, [sp, #4]
 1009d9a:	4906      	ldr	r1, [pc, #24]	; (1009db4 <ll_rx_get+0x17c>)
 1009d9c:	f7ff fabc 	bl	1009318 <tx_cmplt_get>
 1009da0:	4603      	mov	r3, r0
}
 1009da2:	4618      	mov	r0, r3
 1009da4:	b005      	add	sp, #20
 1009da6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1009daa:	bf00      	nop
 1009dac:	21000238 	.word	0x21000238
 1009db0:	21000e7c 	.word	0x21000e7c
 1009db4:	2100023a 	.word	0x2100023a
 1009db8:	210023d8 	.word	0x210023d8
 1009dbc:	21000e80 	.word	0x21000e80
 1009dc0:	21000f94 	.word	0x21000f94
 1009dc4:	210000c4 	.word	0x210000c4
 1009dc8:	210000d8 	.word	0x210000d8
 1009dcc:	01018834 	.word	0x01018834

01009dd0 <ll_rx_dequeue>:
	struct node_rx_hdr *rx = NULL;
 1009dd0:	2300      	movs	r3, #0
{
 1009dd2:	b570      	push	{r4, r5, r6, lr}
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
 1009dd4:	4944      	ldr	r1, [pc, #272]	; (1009ee8 <ll_rx_dequeue+0x118>)
{
 1009dd6:	b082      	sub	sp, #8
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
 1009dd8:	6848      	ldr	r0, [r1, #4]
 1009dda:	aa01      	add	r2, sp, #4
	struct node_rx_hdr *rx = NULL;
 1009ddc:	9301      	str	r3, [sp, #4]
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
 1009dde:	f7fc f80f 	bl	1005e00 <memq_dequeue>
	LL_ASSERT(link);
 1009de2:	4604      	mov	r4, r0
 1009de4:	2800      	cmp	r0, #0
 1009de6:	d04b      	beq.n	1009e80 <ll_rx_dequeue+0xb0>
	mem_release(link, &mem_link_rx.free);
 1009de8:	4620      	mov	r0, r4
 1009dea:	4940      	ldr	r1, [pc, #256]	; (1009eec <ll_rx_dequeue+0x11c>)
 1009dec:	f7fb ffae 	bl	1005d4c <mem_release>
	switch (rx->type) {
 1009df0:	9a01      	ldr	r2, [sp, #4]
 1009df2:	7913      	ldrb	r3, [r2, #4]
 1009df4:	2b0e      	cmp	r3, #14
 1009df6:	d80d      	bhi.n	1009e14 <ll_rx_dequeue+0x44>
 1009df8:	e8df f003 	tbb	[pc, r3]
 1009dfc:	0c080c08 	.word	0x0c080c08
 1009e00:	0c0c0c08 	.word	0x0c0c0c08
 1009e04:	08080813 	.word	0x08080813
 1009e08:	0808      	.short	0x0808
 1009e0a:	08          	.byte	0x08
 1009e0b:	00          	.byte	0x00
		LL_ASSERT(rx->type != NODE_RX_TYPE_NONE);
 1009e0c:	2b00      	cmp	r3, #0
 1009e0e:	d03d      	beq.n	1009e8c <ll_rx_dequeue+0xbc>
}
 1009e10:	b002      	add	sp, #8
 1009e12:	bd70      	pop	{r4, r5, r6, pc}
		LL_ASSERT(0);
 1009e14:	f240 21a5 	movw	r1, #677	; 0x2a5
 1009e18:	4835      	ldr	r0, [pc, #212]	; (1009ef0 <ll_rx_dequeue+0x120>)
 1009e1a:	f7f9 fc31 	bl	1003680 <bt_ctlr_assert_handle>
}
 1009e1e:	b002      	add	sp, #8
 1009e20:	bd70      	pop	{r4, r5, r6, pc}
		} else if ((cc->status == BT_HCI_ERR_ADV_TIMEOUT) || cc->role) {
 1009e22:	f892 3020 	ldrb.w	r3, [r2, #32]
 1009e26:	2b3c      	cmp	r3, #60	; 0x3c
 1009e28:	d037      	beq.n	1009e9a <ll_rx_dequeue+0xca>
 1009e2a:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
 1009e2e:	b1f3      	cbz	r3, 1009e6e <ll_rx_dequeue+0x9e>
			struct ll_adv_set *adv = (void *)HDR_LLL2EVT(lll);
 1009e30:	6893      	ldr	r3, [r2, #8]
 1009e32:	681c      	ldr	r4, [r3, #0]
				if (adv->node_rx_cc_free) {
 1009e34:	f8d4 00d4 	ldr.w	r0, [r4, #212]	; 0xd4
 1009e38:	b128      	cbz	r0, 1009e46 <ll_rx_dequeue+0x76>
					adv->node_rx_cc_free = NULL;
 1009e3a:	2300      	movs	r3, #0
					mem_release(rx_free, &mem_pdu_rx.free);
 1009e3c:	492d      	ldr	r1, [pc, #180]	; (1009ef4 <ll_rx_dequeue+0x124>)
					adv->node_rx_cc_free = NULL;
 1009e3e:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4
					mem_release(rx_free, &mem_pdu_rx.free);
 1009e42:	f7fb ff83 	bl	1005d4c <mem_release>
			adv->is_enabled = 0U;
 1009e46:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
 1009e4a:	f36f 0300 	bfc	r3, #0, #1
 1009e4e:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
			      ull_scan_is_enabled(0) << 1) |
 1009e52:	2000      	movs	r0, #0
 1009e54:	f001 f896 	bl	100af84 <ull_scan_is_enabled>
 1009e58:	4604      	mov	r4, r0
			      ull_adv_is_enabled(0));
 1009e5a:	2000      	movs	r0, #0
 1009e5c:	f000 ff44 	bl	100ace8 <ull_adv_is_enabled>
			if (!bm) {
 1009e60:	ea50 0044 	orrs.w	r0, r0, r4, lsl #1
 1009e64:	d1d4      	bne.n	1009e10 <ll_rx_dequeue+0x40>
				ull_filter_adv_scan_state_cb(0);
 1009e66:	f005 f84d 	bl	100ef04 <ull_filter_adv_scan_state_cb>
}
 1009e6a:	b002      	add	sp, #8
 1009e6c:	bd70      	pop	{r4, r5, r6, pc}
			struct ll_scan_set *scan = (void *)HDR_LLL2EVT(lll);
 1009e6e:	6892      	ldr	r2, [r2, #8]
 1009e70:	6812      	ldr	r2, [r2, #0]
			scan->is_enabled = 0U;
 1009e72:	f892 1048 	ldrb.w	r1, [r2, #72]	; 0x48
 1009e76:	f363 0100 	bfi	r1, r3, #0, #1
 1009e7a:	f882 1048 	strb.w	r1, [r2, #72]	; 0x48
 1009e7e:	e7e8      	b.n	1009e52 <ll_rx_dequeue+0x82>
	LL_ASSERT(link);
 1009e80:	f240 2115 	movw	r1, #533	; 0x215
 1009e84:	481a      	ldr	r0, [pc, #104]	; (1009ef0 <ll_rx_dequeue+0x120>)
 1009e86:	f7f9 fbfb 	bl	1003680 <bt_ctlr_assert_handle>
 1009e8a:	e7ad      	b.n	1009de8 <ll_rx_dequeue+0x18>
		LL_ASSERT(rx->type != NODE_RX_TYPE_NONE);
 1009e8c:	f240 21a1 	movw	r1, #673	; 0x2a1
 1009e90:	4817      	ldr	r0, [pc, #92]	; (1009ef0 <ll_rx_dequeue+0x120>)
 1009e92:	f7f9 fbf5 	bl	1003680 <bt_ctlr_assert_handle>
}
 1009e96:	b002      	add	sp, #8
 1009e98:	bd70      	pop	{r4, r5, r6, pc}
			struct lll_adv *lll = ftr->param;
 1009e9a:	6896      	ldr	r6, [r2, #8]
				conn_lll = lll->conn;
 1009e9c:	68b5      	ldr	r5, [r6, #8]
			struct ll_adv_set *adv = (void *)HDR_LLL2EVT(lll);
 1009e9e:	6834      	ldr	r4, [r6, #0]
				LL_ASSERT(conn_lll);
 1009ea0:	b1ad      	cbz	r5, 1009ece <ll_rx_dequeue+0xfe>
				lll->conn = NULL;
 1009ea2:	2200      	movs	r2, #0
				LL_ASSERT(!conn_lll->link_tx_free);
 1009ea4:	6deb      	ldr	r3, [r5, #92]	; 0x5c
				lll->conn = NULL;
 1009ea6:	60b2      	str	r2, [r6, #8]
				LL_ASSERT(!conn_lll->link_tx_free);
 1009ea8:	b123      	cbz	r3, 1009eb4 <ll_rx_dequeue+0xe4>
 1009eaa:	f240 2131 	movw	r1, #561	; 0x231
 1009eae:	4810      	ldr	r0, [pc, #64]	; (1009ef0 <ll_rx_dequeue+0x120>)
 1009eb0:	f7f9 fbe6 	bl	1003680 <bt_ctlr_assert_handle>
				link = memq_deinit(&conn_lll->memq_tx.head,
 1009eb4:	f105 0150 	add.w	r1, r5, #80	; 0x50
 1009eb8:	f105 004c 	add.w	r0, r5, #76	; 0x4c
 1009ebc:	f7fb ff86 	bl	1005dcc <memq_deinit>
				LL_ASSERT(link);
 1009ec0:	4606      	mov	r6, r0
 1009ec2:	b150      	cbz	r0, 1009eda <ll_rx_dequeue+0x10a>
				ll_conn_release(conn);
 1009ec4:	6828      	ldr	r0, [r5, #0]
				conn_lll->link_tx_free = link;
 1009ec6:	65ee      	str	r6, [r5, #92]	; 0x5c
				ll_conn_release(conn);
 1009ec8:	f001 fbee 	bl	100b6a8 <ll_conn_release>
 1009ecc:	e7bb      	b.n	1009e46 <ll_rx_dequeue+0x76>
				LL_ASSERT(conn_lll);
 1009ece:	f240 212e 	movw	r1, #558	; 0x22e
 1009ed2:	4807      	ldr	r0, [pc, #28]	; (1009ef0 <ll_rx_dequeue+0x120>)
 1009ed4:	f7f9 fbd4 	bl	1003680 <bt_ctlr_assert_handle>
 1009ed8:	e7e3      	b.n	1009ea2 <ll_rx_dequeue+0xd2>
				LL_ASSERT(link);
 1009eda:	f44f 710d 	mov.w	r1, #564	; 0x234
 1009ede:	4804      	ldr	r0, [pc, #16]	; (1009ef0 <ll_rx_dequeue+0x120>)
 1009ee0:	f7f9 fbce 	bl	1003680 <bt_ctlr_assert_handle>
 1009ee4:	e7ee      	b.n	1009ec4 <ll_rx_dequeue+0xf4>
 1009ee6:	bf00      	nop
 1009ee8:	210023d8 	.word	0x210023d8
 1009eec:	21000e80 	.word	0x21000e80
 1009ef0:	01018834 	.word	0x01018834
 1009ef4:	21000f94 	.word	0x21000f94

01009ef8 <ll_rx_mem_release>:
{
 1009ef8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	rx = *node_rx;
 1009efc:	6804      	ldr	r4, [r0, #0]
{
 1009efe:	4680      	mov	r8, r0
 1009f00:	4e8c      	ldr	r6, [pc, #560]	; (100a134 <ll_rx_mem_release+0x23c>)
 1009f02:	b082      	sub	sp, #8
	while (rx) {
 1009f04:	b38c      	cbz	r4, 1009f6a <ll_rx_mem_release+0x72>
			LL_ASSERT(0);
 1009f06:	4f8c      	ldr	r7, [pc, #560]	; (100a138 <ll_rx_mem_release+0x240>)
			mem_release(rx_free, &mem_pdu_rx.free);
 1009f08:	f8df 923c 	ldr.w	r9, [pc, #572]	; 100a148 <ll_rx_mem_release+0x250>
		switch (rx_free->type) {
 1009f0c:	7923      	ldrb	r3, [r4, #4]
 1009f0e:	4625      	mov	r5, r4
		rx = rx->next;
 1009f10:	6824      	ldr	r4, [r4, #0]
		switch (rx_free->type) {
 1009f12:	2b0e      	cmp	r3, #14
 1009f14:	d85b      	bhi.n	1009fce <ll_rx_mem_release+0xd6>
 1009f16:	e8df f003 	tbb	[pc, r3]
 1009f1a:	5a17      	.short	0x5a17
 1009f1c:	5a175a17 	.word	0x5a175a17
 1009f20:	62085a5a 	.word	0x62085a5a
 1009f24:	17171717 	.word	0x17171717
 1009f28:	17          	.byte	0x17
 1009f29:	00          	.byte	0x00
			} else if (cc->status == BT_HCI_ERR_ADV_TIMEOUT) {
 1009f2a:	f895 3020 	ldrb.w	r3, [r5, #32]
 1009f2e:	2b3c      	cmp	r3, #60	; 0x3c
 1009f30:	f000 80da 	beq.w	100a0e8 <ll_rx_mem_release+0x1f0>
			} else if (cc->status == BT_HCI_ERR_UNKNOWN_CONN_ID) {
 1009f34:	2b02      	cmp	r3, #2
 1009f36:	f000 80a8 	beq.w	100a08a <ll_rx_mem_release+0x192>
				LL_ASSERT(!cc->status);
 1009f3a:	b15b      	cbz	r3, 1009f54 <ll_rx_mem_release+0x5c>
 1009f3c:	f240 21fd 	movw	r1, #765	; 0x2fd
 1009f40:	4638      	mov	r0, r7
 1009f42:	f7f9 fb9d 	bl	1003680 <bt_ctlr_assert_handle>
 1009f46:	792b      	ldrb	r3, [r5, #4]
			LL_ASSERT(rx_free->type != NODE_RX_TYPE_NONE);
 1009f48:	b923      	cbnz	r3, 1009f54 <ll_rx_mem_release+0x5c>
 1009f4a:	f240 313e 	movw	r1, #830	; 0x33e
 1009f4e:	4638      	mov	r0, r7
 1009f50:	f7f9 fb96 	bl	1003680 <bt_ctlr_assert_handle>
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
 1009f54:	7833      	ldrb	r3, [r6, #0]
 1009f56:	2b0f      	cmp	r3, #15
 1009f58:	d85d      	bhi.n	100a016 <ll_rx_mem_release+0x11e>
	mem_link_rx.quota_pdu += delta;
 1009f5a:	3301      	adds	r3, #1
			mem_release(rx_free, &mem_pdu_rx.free);
 1009f5c:	4628      	mov	r0, r5
 1009f5e:	4649      	mov	r1, r9
	mem_link_rx.quota_pdu += delta;
 1009f60:	7033      	strb	r3, [r6, #0]
			mem_release(rx_free, &mem_pdu_rx.free);
 1009f62:	f7fb fef3 	bl	1005d4c <mem_release>
	while (rx) {
 1009f66:	2c00      	cmp	r4, #0
 1009f68:	d1d0      	bne.n	1009f0c <ll_rx_mem_release+0x14>
	*node_rx = rx;
 1009f6a:	2700      	movs	r7, #0
 1009f6c:	f8c8 7000 	str.w	r7, [r8]
	while (mem_link_rx.quota_pdu &&
 1009f70:	7833      	ldrb	r3, [r6, #0]
 1009f72:	b34b      	cbz	r3, 1009fc8 <ll_rx_mem_release+0xd0>
 1009f74:	4d71      	ldr	r5, [pc, #452]	; (100a13c <ll_rx_mem_release+0x244>)
		link = mem_acquire(&mem_link_rx.free);
 1009f76:	f8df 81c8 	ldr.w	r8, [pc, #456]	; 100a140 <ll_rx_mem_release+0x248>
 1009f7a:	78ec      	ldrb	r4, [r5, #3]
		rx = mem_acquire(&mem_pdu_rx.free);
 1009f7c:	f8df 91c8 	ldr.w	r9, [pc, #456]	; 100a148 <ll_rx_mem_release+0x250>
	if (last == count) {
 1009f80:	786b      	ldrb	r3, [r5, #1]
	last = last + 1;
 1009f82:	3401      	adds	r4, #1
 1009f84:	b2e4      	uxtb	r4, r4
		last = 0U;
 1009f86:	42a3      	cmp	r3, r4
 1009f88:	bf08      	it	eq
 1009f8a:	2400      	moveq	r4, #0
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
 1009f8c:	78ab      	ldrb	r3, [r5, #2]
	if (last == first) {
 1009f8e:	429c      	cmp	r4, r3
 1009f90:	d04c      	beq.n	100a02c <ll_rx_mem_release+0x134>
		link = mem_acquire(&mem_link_rx.free);
 1009f92:	4640      	mov	r0, r8
 1009f94:	f7fb fec0 	bl	1005d18 <mem_acquire>
		if (!link) {
 1009f98:	4682      	mov	sl, r0
 1009f9a:	2800      	cmp	r0, #0
 1009f9c:	d046      	beq.n	100a02c <ll_rx_mem_release+0x134>
		rx = mem_acquire(&mem_pdu_rx.free);
 1009f9e:	4648      	mov	r0, r9
 1009fa0:	f7fb feba 	bl	1005d18 <mem_acquire>
		if (!rx) {
 1009fa4:	2800      	cmp	r0, #0
 1009fa6:	d03d      	beq.n	100a024 <ll_rx_mem_release+0x12c>
		link->mem = NULL;
 1009fa8:	f8ca 7004 	str.w	r7, [sl, #4]
		rx->link = link;
 1009fac:	f8c0 a000 	str.w	sl, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 1009fb0:	78ea      	ldrb	r2, [r5, #3]
 1009fb2:	7829      	ldrb	r1, [r5, #0]
	mem_link_rx.quota_pdu += delta;
 1009fb4:	7833      	ldrb	r3, [r6, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 1009fb6:	fb01 5202 	mla	r2, r1, r2, r5
 1009fba:	3b01      	subs	r3, #1
 1009fbc:	b2db      	uxtb	r3, r3
 1009fbe:	6050      	str	r0, [r2, #4]
 1009fc0:	7033      	strb	r3, [r6, #0]
	*last = idx; /* Commit: Update write index */
 1009fc2:	70ec      	strb	r4, [r5, #3]
	while (mem_link_rx.quota_pdu &&
 1009fc4:	2b00      	cmp	r3, #0
 1009fc6:	d1db      	bne.n	1009f80 <ll_rx_mem_release+0x88>
}
 1009fc8:	b002      	add	sp, #8
 1009fca:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			LL_ASSERT(0);
 1009fce:	f44f 7156 	mov.w	r1, #856	; 0x358
 1009fd2:	4638      	mov	r0, r7
 1009fd4:	f7f9 fb54 	bl	1003680 <bt_ctlr_assert_handle>
	while (rx) {
 1009fd8:	2c00      	cmp	r4, #0
 1009fda:	d197      	bne.n	1009f0c <ll_rx_mem_release+0x14>
 1009fdc:	e7c5      	b.n	1009f6a <ll_rx_mem_release+0x72>
			conn = ll_conn_get(rx_free->handle);
 1009fde:	88e8      	ldrh	r0, [r5, #6]
 1009fe0:	f001 fb70 	bl	100b6c4 <ll_conn_get>
			LL_ASSERT(!conn->lll.link_tx_free);
 1009fe4:	6f83      	ldr	r3, [r0, #120]	; 0x78
			conn = ll_conn_get(rx_free->handle);
 1009fe6:	4605      	mov	r5, r0
			LL_ASSERT(!conn->lll.link_tx_free);
 1009fe8:	b123      	cbz	r3, 1009ff4 <ll_rx_mem_release+0xfc>
 1009fea:	f240 314b 	movw	r1, #843	; 0x34b
 1009fee:	4638      	mov	r0, r7
 1009ff0:	f7f9 fb46 	bl	1003680 <bt_ctlr_assert_handle>
			link = memq_deinit(&conn->lll.memq_tx.head,
 1009ff4:	f105 016c 	add.w	r1, r5, #108	; 0x6c
 1009ff8:	f105 0068 	add.w	r0, r5, #104	; 0x68
 1009ffc:	f7fb fee6 	bl	1005dcc <memq_deinit>
			LL_ASSERT(link);
 100a000:	4603      	mov	r3, r0
 100a002:	2800      	cmp	r0, #0
 100a004:	d078      	beq.n	100a0f8 <ll_rx_mem_release+0x200>
			ll_conn_release(conn);
 100a006:	4628      	mov	r0, r5
			conn->lll.link_tx_free = link;
 100a008:	67ab      	str	r3, [r5, #120]	; 0x78
			ll_conn_release(conn);
 100a00a:	f001 fb4d 	bl	100b6a8 <ll_conn_release>
	while (rx) {
 100a00e:	2c00      	cmp	r4, #0
 100a010:	f47f af7c 	bne.w	1009f0c <ll_rx_mem_release+0x14>
 100a014:	e7a9      	b.n	1009f6a <ll_rx_mem_release+0x72>
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
 100a016:	f44f 7159 	mov.w	r1, #868	; 0x364
 100a01a:	4638      	mov	r0, r7
 100a01c:	f7f9 fb30 	bl	1003680 <bt_ctlr_assert_handle>
 100a020:	7833      	ldrb	r3, [r6, #0]
 100a022:	e79a      	b.n	1009f5a <ll_rx_mem_release+0x62>
			mem_release(link, &mem_link_rx.free);
 100a024:	4650      	mov	r0, sl
 100a026:	4946      	ldr	r1, [pc, #280]	; (100a140 <ll_rx_mem_release+0x248>)
 100a028:	f7fb fe90 	bl	1005d4c <mem_release>
	if (max > mem_link_rx.quota_pdu) {
 100a02c:	7833      	ldrb	r3, [r6, #0]
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 100a02e:	1e5f      	subs	r7, r3, #1
 100a030:	b2ff      	uxtb	r7, r7
 100a032:	2b00      	cmp	r3, #0
 100a034:	d0c8      	beq.n	1009fc8 <ll_rx_mem_release+0xd0>
 100a036:	4d43      	ldr	r5, [pc, #268]	; (100a144 <ll_rx_mem_release+0x24c>)
		link = mem_acquire(&mem_link_rx.free);
 100a038:	f8df 8104 	ldr.w	r8, [pc, #260]	; 100a140 <ll_rx_mem_release+0x248>
 100a03c:	78ec      	ldrb	r4, [r5, #3]
		rx = mem_acquire(&mem_pdu_rx.free);
 100a03e:	f8df 9108 	ldr.w	r9, [pc, #264]	; 100a148 <ll_rx_mem_release+0x250>
	if (last == count) {
 100a042:	786b      	ldrb	r3, [r5, #1]
	last = last + 1;
 100a044:	3401      	adds	r4, #1
 100a046:	b2e4      	uxtb	r4, r4
		last = 0U;
 100a048:	42a3      	cmp	r3, r4
 100a04a:	bf08      	it	eq
 100a04c:	2400      	moveq	r4, #0
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 100a04e:	78ab      	ldrb	r3, [r5, #2]
	if (last == first) {
 100a050:	429c      	cmp	r4, r3
 100a052:	d0b9      	beq.n	1009fc8 <ll_rx_mem_release+0xd0>
		link = mem_acquire(&mem_link_rx.free);
 100a054:	4640      	mov	r0, r8
 100a056:	f7fb fe5f 	bl	1005d18 <mem_acquire>
		if (!link) {
 100a05a:	4682      	mov	sl, r0
 100a05c:	2800      	cmp	r0, #0
 100a05e:	d0b3      	beq.n	1009fc8 <ll_rx_mem_release+0xd0>
		rx = mem_acquire(&mem_pdu_rx.free);
 100a060:	4648      	mov	r0, r9
 100a062:	f7fb fe59 	bl	1005d18 <mem_acquire>
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 100a066:	3f01      	subs	r7, #1
 100a068:	b2ff      	uxtb	r7, r7
		if (!rx) {
 100a06a:	2800      	cmp	r0, #0
 100a06c:	d05a      	beq.n	100a124 <ll_rx_mem_release+0x22c>
		rx->link = link;
 100a06e:	f8c0 a000 	str.w	sl, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 100a072:	78ea      	ldrb	r2, [r5, #3]
 100a074:	7829      	ldrb	r1, [r5, #0]
	mem_link_rx.quota_pdu += delta;
 100a076:	7833      	ldrb	r3, [r6, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 100a078:	fb01 5202 	mla	r2, r1, r2, r5
 100a07c:	3b01      	subs	r3, #1
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 100a07e:	2fff      	cmp	r7, #255	; 0xff
 100a080:	6050      	str	r0, [r2, #4]
	mem_link_rx.quota_pdu += delta;
 100a082:	7033      	strb	r3, [r6, #0]
	*last = idx; /* Commit: Update write index */
 100a084:	70ec      	strb	r4, [r5, #3]
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 100a086:	d1dc      	bne.n	100a042 <ll_rx_mem_release+0x14a>
 100a088:	e79e      	b.n	1009fc8 <ll_rx_mem_release+0xd0>
				struct ll_scan_set *scan =
 100a08a:	68ab      	ldr	r3, [r5, #8]
 100a08c:	f8d3 a000 	ldr.w	sl, [r3]
				conn_lll = scan->lll.conn;
 100a090:	f8da 5024 	ldr.w	r5, [sl, #36]	; 0x24
				LL_ASSERT(conn_lll);
 100a094:	2d00      	cmp	r5, #0
 100a096:	d03f      	beq.n	100a118 <ll_rx_mem_release+0x220>
				scan->lll.conn = NULL;
 100a098:	2200      	movs	r2, #0
				LL_ASSERT(!conn_lll->link_tx_free);
 100a09a:	6deb      	ldr	r3, [r5, #92]	; 0x5c
				scan->lll.conn = NULL;
 100a09c:	f8ca 2024 	str.w	r2, [sl, #36]	; 0x24
				LL_ASSERT(!conn_lll->link_tx_free);
 100a0a0:	b123      	cbz	r3, 100a0ac <ll_rx_mem_release+0x1b4>
 100a0a2:	f240 21e6 	movw	r1, #742	; 0x2e6
 100a0a6:	4638      	mov	r0, r7
 100a0a8:	f7f9 faea 	bl	1003680 <bt_ctlr_assert_handle>
				link = memq_deinit(&conn_lll->memq_tx.head,
 100a0ac:	f105 0150 	add.w	r1, r5, #80	; 0x50
 100a0b0:	f105 004c 	add.w	r0, r5, #76	; 0x4c
 100a0b4:	f7fb fe8a 	bl	1005dcc <memq_deinit>
				LL_ASSERT(link);
 100a0b8:	4603      	mov	r3, r0
 100a0ba:	b328      	cbz	r0, 100a108 <ll_rx_mem_release+0x210>
				ll_conn_release(conn);
 100a0bc:	6828      	ldr	r0, [r5, #0]
				conn_lll->link_tx_free = link;
 100a0be:	65eb      	str	r3, [r5, #92]	; 0x5c
				ll_conn_release(conn);
 100a0c0:	f001 faf2 	bl	100b6a8 <ll_conn_release>
				scan->is_enabled = 0U;
 100a0c4:	f89a 3048 	ldrb.w	r3, [sl, #72]	; 0x48
				if (!ull_adv_is_enabled_get(0))
 100a0c8:	2000      	movs	r0, #0
				scan->is_enabled = 0U;
 100a0ca:	f36f 0300 	bfc	r3, #0, #1
 100a0ce:	f88a 3048 	strb.w	r3, [sl, #72]	; 0x48
				if (!ull_adv_is_enabled_get(0))
 100a0d2:	f000 fdfb 	bl	100accc <ull_adv_is_enabled_get>
 100a0d6:	2800      	cmp	r0, #0
 100a0d8:	f47f af45 	bne.w	1009f66 <ll_rx_mem_release+0x6e>
					ull_filter_adv_scan_state_cb(0);
 100a0dc:	f004 ff12 	bl	100ef04 <ull_filter_adv_scan_state_cb>
	while (rx) {
 100a0e0:	2c00      	cmp	r4, #0
 100a0e2:	f47f af13 	bne.w	1009f0c <ll_rx_mem_release+0x14>
 100a0e6:	e740      	b.n	1009f6a <ll_rx_mem_release+0x72>
				mem_release(rx_free, &mem_pdu_rx.free);
 100a0e8:	4628      	mov	r0, r5
 100a0ea:	4649      	mov	r1, r9
 100a0ec:	f7fb fe2e 	bl	1005d4c <mem_release>
	while (rx) {
 100a0f0:	2c00      	cmp	r4, #0
 100a0f2:	f47f af0b 	bne.w	1009f0c <ll_rx_mem_release+0x14>
 100a0f6:	e738      	b.n	1009f6a <ll_rx_mem_release+0x72>
 100a0f8:	9001      	str	r0, [sp, #4]
			LL_ASSERT(link);
 100a0fa:	f240 314e 	movw	r1, #846	; 0x34e
 100a0fe:	4638      	mov	r0, r7
 100a100:	f7f9 fabe 	bl	1003680 <bt_ctlr_assert_handle>
 100a104:	9b01      	ldr	r3, [sp, #4]
 100a106:	e77e      	b.n	100a006 <ll_rx_mem_release+0x10e>
 100a108:	9001      	str	r0, [sp, #4]
				LL_ASSERT(link);
 100a10a:	f240 21e9 	movw	r1, #745	; 0x2e9
 100a10e:	4638      	mov	r0, r7
 100a110:	f7f9 fab6 	bl	1003680 <bt_ctlr_assert_handle>
 100a114:	9b01      	ldr	r3, [sp, #4]
 100a116:	e7d1      	b.n	100a0bc <ll_rx_mem_release+0x1c4>
				LL_ASSERT(conn_lll);
 100a118:	f240 21e3 	movw	r1, #739	; 0x2e3
 100a11c:	4638      	mov	r0, r7
 100a11e:	f7f9 faaf 	bl	1003680 <bt_ctlr_assert_handle>
 100a122:	e7b9      	b.n	100a098 <ll_rx_mem_release+0x1a0>
			mem_release(link, &mem_link_rx.free);
 100a124:	4650      	mov	r0, sl
 100a126:	4906      	ldr	r1, [pc, #24]	; (100a140 <ll_rx_mem_release+0x248>)
}
 100a128:	b002      	add	sp, #8
 100a12a:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			mem_release(link, &mem_link_rx.free);
 100a12e:	f7fb be0d 	b.w	1005d4c <mem_release>
 100a132:	bf00      	nop
 100a134:	21000e7c 	.word	0x21000e7c
 100a138:	01018834 	.word	0x01018834
 100a13c:	210000c4 	.word	0x210000c4
 100a140:	21000e80 	.word	0x21000e80
 100a144:	210000d8 	.word	0x210000d8
 100a148:	21000f94 	.word	0x21000f94

0100a14c <ll_rx_link_alloc>:
	return mem_acquire(&mem_link_rx.free);
 100a14c:	4801      	ldr	r0, [pc, #4]	; (100a154 <ll_rx_link_alloc+0x8>)
 100a14e:	f7fb bde3 	b.w	1005d18 <mem_acquire>
 100a152:	bf00      	nop
 100a154:	21000e80 	.word	0x21000e80

0100a158 <ll_rx_link_release>:
	mem_release(link, &mem_link_rx.free);
 100a158:	4901      	ldr	r1, [pc, #4]	; (100a160 <ll_rx_link_release+0x8>)
 100a15a:	f7fb bdf7 	b.w	1005d4c <mem_release>
 100a15e:	bf00      	nop
 100a160:	21000e80 	.word	0x21000e80

0100a164 <ll_rx_alloc>:
	return mem_acquire(&mem_pdu_rx.free);
 100a164:	4801      	ldr	r0, [pc, #4]	; (100a16c <ll_rx_alloc+0x8>)
 100a166:	f7fb bdd7 	b.w	1005d18 <mem_acquire>
 100a16a:	bf00      	nop
 100a16c:	21000f94 	.word	0x21000f94

0100a170 <ll_rx_release>:
	mem_release(node_rx, &mem_pdu_rx.free);
 100a170:	4901      	ldr	r1, [pc, #4]	; (100a178 <ll_rx_release+0x8>)
 100a172:	f7fb bdeb 	b.w	1005d4c <mem_release>
 100a176:	bf00      	nop
 100a178:	21000f94 	.word	0x21000f94

0100a17c <ll_rx_put>:
	rx_hdr->ack_last = mfifo_tx_ack.l;
 100a17c:	4b02      	ldr	r3, [pc, #8]	; (100a188 <ll_rx_put+0xc>)
	memq_enqueue(link, rx, &memq_ll_rx.tail);
 100a17e:	4a03      	ldr	r2, [pc, #12]	; (100a18c <ll_rx_put+0x10>)
	rx_hdr->ack_last = mfifo_tx_ack.l;
 100a180:	78db      	ldrb	r3, [r3, #3]
 100a182:	700b      	strb	r3, [r1, #0]
	memq_enqueue(link, rx, &memq_ll_rx.tail);
 100a184:	f7fb be2c 	b.w	1005de0 <memq_enqueue>
 100a188:	21000238 	.word	0x21000238
 100a18c:	210023dc 	.word	0x210023dc

0100a190 <ll_rx_sched>:
	k_sem_give(sem_recv);
 100a190:	4b01      	ldr	r3, [pc, #4]	; (100a198 <ll_rx_sched+0x8>)
 100a192:	6818      	ldr	r0, [r3, #0]
	z_impl_k_sem_give(sem);
 100a194:	f00a bb08 	b.w	10147a8 <z_impl_k_sem_give>
 100a198:	210023e8 	.word	0x210023e8

0100a19c <ll_pdu_rx_alloc_peek>:
{
 100a19c:	b410      	push	{r4}
	if (count > MFIFO_AVAIL_COUNT_GET(ll_pdu_rx_free)) {
 100a19e:	4a0d      	ldr	r2, [pc, #52]	; (100a1d4 <ll_pdu_rx_alloc_peek+0x38>)
 100a1a0:	7893      	ldrb	r3, [r2, #2]
 100a1a2:	78d4      	ldrb	r4, [r2, #3]
	if (last >= first) {
 100a1a4:	42a3      	cmp	r3, r4
 100a1a6:	d809      	bhi.n	100a1bc <ll_pdu_rx_alloc_peek+0x20>
		return last - first;
 100a1a8:	1ae1      	subs	r1, r4, r3
 100a1aa:	b2c9      	uxtb	r1, r1
 100a1ac:	4288      	cmp	r0, r1
 100a1ae:	d802      	bhi.n	100a1b6 <ll_pdu_rx_alloc_peek+0x1a>
	if (first == last) {
 100a1b0:	42a3      	cmp	r3, r4
	return MFIFO_DEQUEUE_PEEK(ll_pdu_rx_free);
 100a1b2:	7811      	ldrb	r1, [r2, #0]
 100a1b4:	d109      	bne.n	100a1ca <ll_pdu_rx_alloc_peek+0x2e>
		return NULL;
 100a1b6:	2000      	movs	r0, #0
}
 100a1b8:	bc10      	pop	{r4}
 100a1ba:	4770      	bx	lr
		return count - first + last;
 100a1bc:	7851      	ldrb	r1, [r2, #1]
 100a1be:	1ac9      	subs	r1, r1, r3
 100a1c0:	4421      	add	r1, r4
	if (count > MFIFO_AVAIL_COUNT_GET(ll_pdu_rx_free)) {
 100a1c2:	b2c9      	uxtb	r1, r1
 100a1c4:	4288      	cmp	r0, r1
 100a1c6:	d8f6      	bhi.n	100a1b6 <ll_pdu_rx_alloc_peek+0x1a>
	return MFIFO_DEQUEUE_PEEK(ll_pdu_rx_free);
 100a1c8:	7811      	ldrb	r1, [r2, #0]
	return *((void **)(fifo + first * size));
 100a1ca:	fb01 2303 	mla	r3, r1, r3, r2
}
 100a1ce:	bc10      	pop	{r4}
 100a1d0:	6858      	ldr	r0, [r3, #4]
 100a1d2:	4770      	bx	lr
 100a1d4:	210000c4 	.word	0x210000c4

0100a1d8 <ll_pdu_rx_alloc>:
{
 100a1d8:	b410      	push	{r4}
	return MFIFO_DEQUEUE(ll_pdu_rx_free);
 100a1da:	4b0a      	ldr	r3, [pc, #40]	; (100a204 <ll_pdu_rx_alloc+0x2c>)
	u8_t _first = *first; /* Copy read-index */
 100a1dc:	7899      	ldrb	r1, [r3, #2]
	if (_first == last) {
 100a1de:	78da      	ldrb	r2, [r3, #3]
 100a1e0:	7818      	ldrb	r0, [r3, #0]
 100a1e2:	428a      	cmp	r2, r1
 100a1e4:	785c      	ldrb	r4, [r3, #1]
 100a1e6:	d00a      	beq.n	100a1fe <ll_pdu_rx_alloc+0x26>
	_first += 1U;
 100a1e8:	1c4a      	adds	r2, r1, #1
 100a1ea:	b2d2      	uxtb	r2, r2
		_first = 0U;
 100a1ec:	4294      	cmp	r4, r2
 100a1ee:	bf08      	it	eq
 100a1f0:	2200      	moveq	r2, #0
	mem = *((void **)(fifo + _first * size));
 100a1f2:	fb00 3101 	mla	r1, r0, r1, r3
 100a1f6:	6848      	ldr	r0, [r1, #4]
	*first = _first; /* Write back read-index */
 100a1f8:	709a      	strb	r2, [r3, #2]
}
 100a1fa:	bc10      	pop	{r4}
 100a1fc:	4770      	bx	lr
		return NULL;
 100a1fe:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(ll_pdu_rx_free);
 100a200:	e7fb      	b.n	100a1fa <ll_pdu_rx_alloc+0x22>
 100a202:	bf00      	nop
 100a204:	210000c4 	.word	0x210000c4

0100a208 <ll_tx_ack_put>:
{
 100a208:	b570      	push	{r4, r5, r6, lr}
	idx = MFIFO_ENQUEUE_GET(tx_ack, (void **)&tx);
 100a20a:	4c0f      	ldr	r4, [pc, #60]	; (100a248 <ll_tx_ack_put+0x40>)
 100a20c:	78e2      	ldrb	r2, [r4, #3]
	if (last == count) {
 100a20e:	7865      	ldrb	r5, [r4, #1]
	last = last + 1;
 100a210:	1c53      	adds	r3, r2, #1
 100a212:	b2db      	uxtb	r3, r3
		last = 0U;
 100a214:	429d      	cmp	r5, r3
 100a216:	bf08      	it	eq
 100a218:	2300      	moveq	r3, #0
 100a21a:	78a5      	ldrb	r5, [r4, #2]
	if (last == first) {
 100a21c:	429d      	cmp	r5, r3
 100a21e:	d00a      	beq.n	100a236 <ll_tx_ack_put+0x2e>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
 100a220:	4625      	mov	r5, r4
 100a222:	f815 6b04 	ldrb.w	r6, [r5], #4
 100a226:	fb02 f206 	mul.w	r2, r2, r6
	LL_ASSERT(tx);
 100a22a:	18ae      	adds	r6, r5, r2
 100a22c:	d003      	beq.n	100a236 <ll_tx_ack_put+0x2e>
	tx->handle = handle;
 100a22e:	52a8      	strh	r0, [r5, r2]
	tx->node = node_tx;
 100a230:	6071      	str	r1, [r6, #4]
	*last = idx; /* Commit: Update write index */
 100a232:	70e3      	strb	r3, [r4, #3]
}
 100a234:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(tx);
 100a236:	f240 31ae 	movw	r1, #942	; 0x3ae
 100a23a:	4804      	ldr	r0, [pc, #16]	; (100a24c <ll_tx_ack_put+0x44>)
 100a23c:	f7f9 fa20 	bl	1003680 <bt_ctlr_assert_handle>
	tx->handle = handle;
 100a240:	2300      	movs	r3, #0
 100a242:	801b      	strh	r3, [r3, #0]
 100a244:	deff      	udf	#255	; 0xff
 100a246:	bf00      	nop
 100a248:	21000238 	.word	0x21000238
 100a24c:	01018834 	.word	0x01018834

0100a250 <ull_ticker_status_give>:
	*((u32_t volatile *)param) = status;
 100a250:	6008      	str	r0, [r1, #0]
 100a252:	4801      	ldr	r0, [pc, #4]	; (100a258 <ull_ticker_status_give+0x8>)
 100a254:	f00a baa8 	b.w	10147a8 <z_impl_k_sem_give>
 100a258:	210023ec 	.word	0x210023ec

0100a25c <ull_ticker_status_take>:
{
 100a25c:	b510      	push	{r4, lr}
 100a25e:	f04f 32ff 	mov.w	r2, #4294967295
 100a262:	f04f 33ff 	mov.w	r3, #4294967295
 100a266:	460c      	mov	r4, r1
	return z_impl_k_sem_take(sem, timeout);
 100a268:	4802      	ldr	r0, [pc, #8]	; (100a274 <ull_ticker_status_take+0x18>)
 100a26a:	f00a fac3 	bl	10147f4 <z_impl_k_sem_take>
	return *ret_cb;
 100a26e:	6820      	ldr	r0, [r4, #0]
}
 100a270:	bd10      	pop	{r4, pc}
 100a272:	bf00      	nop
 100a274:	210023ec 	.word	0x210023ec

0100a278 <ull_disable_mark>:
	if (!*m) {
 100a278:	4a03      	ldr	r2, [pc, #12]	; (100a288 <ull_disable_mark+0x10>)
{
 100a27a:	4603      	mov	r3, r0
	if (!*m) {
 100a27c:	6810      	ldr	r0, [r2, #0]
 100a27e:	b100      	cbz	r0, 100a282 <ull_disable_mark+0xa>
}
 100a280:	4770      	bx	lr
		*m = param;
 100a282:	4618      	mov	r0, r3
 100a284:	6013      	str	r3, [r2, #0]
}
 100a286:	4770      	bx	lr
 100a288:	21000dac 	.word	0x21000dac

0100a28c <ull_disable_unmark>:
	if (*m && *m == param) {
 100a28c:	4a05      	ldr	r2, [pc, #20]	; (100a2a4 <ull_disable_unmark+0x18>)
{
 100a28e:	4603      	mov	r3, r0
	if (*m && *m == param) {
 100a290:	6810      	ldr	r0, [r2, #0]
 100a292:	b110      	cbz	r0, 100a29a <ull_disable_unmark+0xe>
 100a294:	4283      	cmp	r3, r0
 100a296:	d001      	beq.n	100a29c <ull_disable_unmark+0x10>
	return NULL;
 100a298:	2000      	movs	r0, #0
}
 100a29a:	4770      	bx	lr
		*m = NULL;
 100a29c:	2300      	movs	r3, #0
 100a29e:	6013      	str	r3, [r2, #0]
		return param;
 100a2a0:	4770      	bx	lr
 100a2a2:	bf00      	nop
 100a2a4:	21000dac 	.word	0x21000dac

0100a2a8 <ull_disable_mark_get>:
	return mark_get(mark_disable);
 100a2a8:	4b01      	ldr	r3, [pc, #4]	; (100a2b0 <ull_disable_mark_get+0x8>)
}
 100a2aa:	6818      	ldr	r0, [r3, #0]
 100a2ac:	4770      	bx	lr
 100a2ae:	bf00      	nop
 100a2b0:	21000dac 	.word	0x21000dac

0100a2b4 <ull_update_mark>:
	if (!*m) {
 100a2b4:	4a03      	ldr	r2, [pc, #12]	; (100a2c4 <ull_update_mark+0x10>)
{
 100a2b6:	4603      	mov	r3, r0
	if (!*m) {
 100a2b8:	6810      	ldr	r0, [r2, #0]
 100a2ba:	b100      	cbz	r0, 100a2be <ull_update_mark+0xa>
}
 100a2bc:	4770      	bx	lr
		*m = param;
 100a2be:	4618      	mov	r0, r3
 100a2c0:	6013      	str	r3, [r2, #0]
}
 100a2c2:	4770      	bx	lr
 100a2c4:	21000db0 	.word	0x21000db0

0100a2c8 <ull_update_unmark>:
	if (*m && *m == param) {
 100a2c8:	4a05      	ldr	r2, [pc, #20]	; (100a2e0 <ull_update_unmark+0x18>)
{
 100a2ca:	4603      	mov	r3, r0
	if (*m && *m == param) {
 100a2cc:	6810      	ldr	r0, [r2, #0]
 100a2ce:	b110      	cbz	r0, 100a2d6 <ull_update_unmark+0xe>
 100a2d0:	4283      	cmp	r3, r0
 100a2d2:	d001      	beq.n	100a2d8 <ull_update_unmark+0x10>
	return NULL;
 100a2d4:	2000      	movs	r0, #0
}
 100a2d6:	4770      	bx	lr
		*m = NULL;
 100a2d8:	2300      	movs	r3, #0
 100a2da:	6013      	str	r3, [r2, #0]
		return param;
 100a2dc:	4770      	bx	lr
 100a2de:	bf00      	nop
 100a2e0:	21000db0 	.word	0x21000db0

0100a2e4 <ull_update_mark_get>:
	return mark_get(mark_update);
 100a2e4:	4b01      	ldr	r3, [pc, #4]	; (100a2ec <ull_update_mark_get+0x8>)
}
 100a2e6:	6818      	ldr	r0, [r3, #0]
 100a2e8:	4770      	bx	lr
 100a2ea:	bf00      	nop
 100a2ec:	21000db0 	.word	0x21000db0

0100a2f0 <ull_disable>:
{
 100a2f0:	b530      	push	{r4, r5, lr}
	hdr = HDR_ULL(((struct lll_hdr *)lll)->parent);
 100a2f2:	6805      	ldr	r5, [r0, #0]
{
 100a2f4:	b087      	sub	sp, #28
	if (!hdr) {
 100a2f6:	f115 0f10 	cmn.w	r5, #16
 100a2fa:	d00b      	beq.n	100a314 <ull_disable+0x24>
	compiler_barrier();
 100a2fc:	4604      	mov	r4, r0
	return z_impl_k_sem_init(sem, initial_count, limit);
 100a2fe:	2201      	movs	r2, #1
 100a300:	4668      	mov	r0, sp
 100a302:	2100      	movs	r1, #0
 100a304:	f00d fc8b 	bl	1017c1e <z_impl_k_sem_init>
	hdr->disabled_cb = disabled_cb;
 100a308:	4a0f      	ldr	r2, [pc, #60]	; (100a348 <ull_disable+0x58>)
	if (!hdr->ref) {
 100a30a:	7c2b      	ldrb	r3, [r5, #16]
	hdr->disabled_param = &sem;
 100a30c:	f8c5 d018 	str.w	sp, [r5, #24]
	hdr->disabled_cb = disabled_cb;
 100a310:	616a      	str	r2, [r5, #20]
	if (!hdr->ref) {
 100a312:	b913      	cbnz	r3, 100a31a <ull_disable+0x2a>
		return ULL_STATUS_SUCCESS;
 100a314:	2000      	movs	r0, #0
}
 100a316:	b007      	add	sp, #28
 100a318:	bd30      	pop	{r4, r5, pc}
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
 100a31a:	2200      	movs	r2, #0
	mfy.param = lll;
 100a31c:	4b0b      	ldr	r3, [pc, #44]	; (100a34c <ull_disable+0x5c>)
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
 100a31e:	4611      	mov	r1, r2
 100a320:	2003      	movs	r0, #3
	mfy.param = lll;
 100a322:	609c      	str	r4, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
 100a324:	f7fb fdd0 	bl	1005ec8 <mayfly_enqueue>
	LL_ASSERT(!ret);
 100a328:	b940      	cbnz	r0, 100a33c <ull_disable+0x4c>
	return z_impl_k_sem_take(sem, timeout);
 100a32a:	f04f 32ff 	mov.w	r2, #4294967295
 100a32e:	f04f 33ff 	mov.w	r3, #4294967295
 100a332:	4668      	mov	r0, sp
 100a334:	f00a fa5e 	bl	10147f4 <z_impl_k_sem_take>
}
 100a338:	b007      	add	sp, #28
 100a33a:	bd30      	pop	{r4, r5, pc}
	LL_ASSERT(!ret);
 100a33c:	f240 4119 	movw	r1, #1049	; 0x419
 100a340:	4803      	ldr	r0, [pc, #12]	; (100a350 <ull_disable+0x60>)
 100a342:	f7f9 f99d 	bl	1003680 <bt_ctlr_assert_handle>
 100a346:	e7f0      	b.n	100a32a <ull_disable+0x3a>
 100a348:	01009315 	.word	0x01009315
 100a34c:	210002a4 	.word	0x210002a4
 100a350:	01018834 	.word	0x01018834

0100a354 <ull_pdu_rx_alloc_peek>:
{
 100a354:	b410      	push	{r4}
	if (count > MFIFO_AVAIL_COUNT_GET(pdu_rx_free)) {
 100a356:	4a0d      	ldr	r2, [pc, #52]	; (100a38c <ull_pdu_rx_alloc_peek+0x38>)
 100a358:	7893      	ldrb	r3, [r2, #2]
 100a35a:	78d4      	ldrb	r4, [r2, #3]
	if (last >= first) {
 100a35c:	42a3      	cmp	r3, r4
 100a35e:	d809      	bhi.n	100a374 <ull_pdu_rx_alloc_peek+0x20>
		return last - first;
 100a360:	1ae1      	subs	r1, r4, r3
 100a362:	b2c9      	uxtb	r1, r1
 100a364:	4288      	cmp	r0, r1
 100a366:	d802      	bhi.n	100a36e <ull_pdu_rx_alloc_peek+0x1a>
	if (first == last) {
 100a368:	42a3      	cmp	r3, r4
	return MFIFO_DEQUEUE_PEEK(pdu_rx_free);
 100a36a:	7811      	ldrb	r1, [r2, #0]
 100a36c:	d109      	bne.n	100a382 <ull_pdu_rx_alloc_peek+0x2e>
		return NULL;
 100a36e:	2000      	movs	r0, #0
}
 100a370:	bc10      	pop	{r4}
 100a372:	4770      	bx	lr
		return count - first + last;
 100a374:	7851      	ldrb	r1, [r2, #1]
 100a376:	1ac9      	subs	r1, r1, r3
 100a378:	4421      	add	r1, r4
	if (count > MFIFO_AVAIL_COUNT_GET(pdu_rx_free)) {
 100a37a:	b2c9      	uxtb	r1, r1
 100a37c:	4288      	cmp	r0, r1
 100a37e:	d8f6      	bhi.n	100a36e <ull_pdu_rx_alloc_peek+0x1a>
	return MFIFO_DEQUEUE_PEEK(pdu_rx_free);
 100a380:	7811      	ldrb	r1, [r2, #0]
	return *((void **)(fifo + first * size));
 100a382:	fb01 2303 	mla	r3, r1, r3, r2
}
 100a386:	bc10      	pop	{r4}
 100a388:	6858      	ldr	r0, [r3, #4]
 100a38a:	4770      	bx	lr
 100a38c:	210000d8 	.word	0x210000d8

0100a390 <ull_pdu_rx_alloc>:
{
 100a390:	b410      	push	{r4}
	return MFIFO_DEQUEUE(pdu_rx_free);
 100a392:	4b0a      	ldr	r3, [pc, #40]	; (100a3bc <ull_pdu_rx_alloc+0x2c>)
	u8_t _first = *first; /* Copy read-index */
 100a394:	7899      	ldrb	r1, [r3, #2]
	if (_first == last) {
 100a396:	78da      	ldrb	r2, [r3, #3]
 100a398:	7818      	ldrb	r0, [r3, #0]
 100a39a:	428a      	cmp	r2, r1
 100a39c:	785c      	ldrb	r4, [r3, #1]
 100a39e:	d00a      	beq.n	100a3b6 <ull_pdu_rx_alloc+0x26>
	_first += 1U;
 100a3a0:	1c4a      	adds	r2, r1, #1
 100a3a2:	b2d2      	uxtb	r2, r2
		_first = 0U;
 100a3a4:	4294      	cmp	r4, r2
 100a3a6:	bf08      	it	eq
 100a3a8:	2200      	moveq	r2, #0
	mem = *((void **)(fifo + _first * size));
 100a3aa:	fb00 3101 	mla	r1, r0, r1, r3
 100a3ae:	6848      	ldr	r0, [r1, #4]
	*first = _first; /* Write back read-index */
 100a3b0:	709a      	strb	r2, [r3, #2]
}
 100a3b2:	bc10      	pop	{r4}
 100a3b4:	4770      	bx	lr
		return NULL;
 100a3b6:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(pdu_rx_free);
 100a3b8:	e7fb      	b.n	100a3b2 <ull_pdu_rx_alloc+0x22>
 100a3ba:	bf00      	nop
 100a3bc:	210000d8 	.word	0x210000d8

0100a3c0 <ull_rx_put>:
{
 100a3c0:	b538      	push	{r3, r4, r5, lr}
 100a3c2:	460c      	mov	r4, r1
 100a3c4:	4605      	mov	r5, r0
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
 100a3c6:	f003 fca9 	bl	100dd1c <ull_conn_ack_last_idx_get>
	memq_enqueue(link, rx, &memq_ull_rx.tail);
 100a3ca:	4621      	mov	r1, r4
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
 100a3cc:	7020      	strb	r0, [r4, #0]
	memq_enqueue(link, rx, &memq_ull_rx.tail);
 100a3ce:	4a03      	ldr	r2, [pc, #12]	; (100a3dc <ull_rx_put+0x1c>)
 100a3d0:	4628      	mov	r0, r5
}
 100a3d2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	memq_enqueue(link, rx, &memq_ull_rx.tail);
 100a3d6:	f7fb bd03 	b.w	1005de0 <memq_enqueue>
 100a3da:	bf00      	nop
 100a3dc:	210023e4 	.word	0x210023e4

0100a3e0 <ull_rx_sched>:
	mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_ULL_HIGH, 1, &mfy);
 100a3e0:	2201      	movs	r2, #1
 100a3e2:	2000      	movs	r0, #0
 100a3e4:	4611      	mov	r1, r2
 100a3e6:	4b01      	ldr	r3, [pc, #4]	; (100a3ec <ull_rx_sched+0xc>)
 100a3e8:	f7fb bd6e 	b.w	1005ec8 <mayfly_enqueue>
 100a3ec:	210002b4 	.word	0x210002b4

0100a3f0 <ull_prepare_enqueue>:
{
 100a3f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
 100a3f4:	4e19      	ldr	r6, [pc, #100]	; (100a45c <ull_prepare_enqueue+0x6c>)
{
 100a3f6:	f89d a024 	ldrb.w	sl, [sp, #36]	; 0x24
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
 100a3fa:	78f4      	ldrb	r4, [r6, #3]
	if (last == count) {
 100a3fc:	7877      	ldrb	r7, [r6, #1]
	last = last + 1;
 100a3fe:	1c65      	adds	r5, r4, #1
 100a400:	b2ed      	uxtb	r5, r5
		last = 0U;
 100a402:	42af      	cmp	r7, r5
 100a404:	bf08      	it	eq
 100a406:	2500      	moveq	r5, #0
 100a408:	f896 c002 	ldrb.w	ip, [r6, #2]
	if (last == first) {
 100a40c:	45ac      	cmp	ip, r5
 100a40e:	d020      	beq.n	100a452 <ull_prepare_enqueue+0x62>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
 100a410:	4699      	mov	r9, r3
 100a412:	4633      	mov	r3, r6
 100a414:	460f      	mov	r7, r1
 100a416:	4611      	mov	r1, r2
 100a418:	f813 2b04 	ldrb.w	r2, [r3], #4
 100a41c:	fb04 3402 	mla	r4, r4, r2, r3
	if (!e) {
 100a420:	b1bc      	cbz	r4, 100a452 <ull_prepare_enqueue+0x62>
 100a422:	4680      	mov	r8, r0
	memcpy(&e->prepare_param, prepare_param, sizeof(e->prepare_param));
 100a424:	2210      	movs	r2, #16
 100a426:	4620      	mov	r0, r4
 100a428:	f00c faf6 	bl	1016a18 <memcpy>
	e->is_resume = is_resume;
 100a42c:	f894 2020 	ldrb.w	r2, [r4, #32]
	e->prio = prio;
 100a430:	9b08      	ldr	r3, [sp, #32]
	e->is_resume = is_resume;
 100a432:	f00a 0a01 	and.w	sl, sl, #1
 100a436:	f022 0203 	bic.w	r2, r2, #3
 100a43a:	ea42 020a 	orr.w	r2, r2, sl
	return 0;
 100a43e:	2000      	movs	r0, #0
	e->is_abort_cb = is_abort_cb;
 100a440:	e9c4 9804 	strd	r9, r8, [r4, #16]
	e->abort_cb = abort_cb;
 100a444:	61a7      	str	r7, [r4, #24]
	e->prio = prio;
 100a446:	61e3      	str	r3, [r4, #28]
	*last = idx; /* Commit: Update write index */
 100a448:	70f5      	strb	r5, [r6, #3]
	e->is_resume = is_resume;
 100a44a:	f884 2020 	strb.w	r2, [r4, #32]
}
 100a44e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return -ENOBUFS;
 100a452:	f06f 0036 	mvn.w	r0, #54	; 0x36
}
 100a456:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 100a45a:	bf00      	nop
 100a45c:	21000114 	.word	0x21000114

0100a460 <ull_prepare_dequeue_get>:
	return MFIFO_DEQUEUE_GET(prep);
 100a460:	4b05      	ldr	r3, [pc, #20]	; (100a478 <ull_prepare_dequeue_get+0x18>)
 100a462:	7898      	ldrb	r0, [r3, #2]
	if (first == last) {
 100a464:	78da      	ldrb	r2, [r3, #3]
 100a466:	7819      	ldrb	r1, [r3, #0]
 100a468:	4282      	cmp	r2, r0
	return (void *)(fifo + first * size);
 100a46a:	bf1a      	itte	ne
 100a46c:	3304      	addne	r3, #4
 100a46e:	fb01 3000 	mlane	r0, r1, r0, r3
		return NULL;
 100a472:	2000      	moveq	r0, #0
}
 100a474:	4770      	bx	lr
 100a476:	bf00      	nop
 100a478:	21000114 	.word	0x21000114

0100a47c <ull_prepare_dequeue_iter>:
{
 100a47c:	b430      	push	{r4, r5}
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
 100a47e:	4a0c      	ldr	r2, [pc, #48]	; (100a4b0 <ull_prepare_dequeue_iter+0x34>)
	if (*idx >= count) {
 100a480:	7803      	ldrb	r3, [r0, #0]
 100a482:	7851      	ldrb	r1, [r2, #1]
 100a484:	78d4      	ldrb	r4, [r2, #3]
 100a486:	4299      	cmp	r1, r3
 100a488:	bf98      	it	ls
 100a48a:	7893      	ldrbls	r3, [r2, #2]
 100a48c:	7815      	ldrb	r5, [r2, #0]
		*idx = first;
 100a48e:	bf98      	it	ls
 100a490:	7003      	strbls	r3, [r0, #0]
	if (*idx == last) {
 100a492:	429c      	cmp	r4, r3
 100a494:	d00a      	beq.n	100a4ac <ull_prepare_dequeue_iter+0x30>
	i = *idx + 1;
 100a496:	1c5a      	adds	r2, r3, #1
 100a498:	b2d2      	uxtb	r2, r2
		i = 0U;
 100a49a:	4291      	cmp	r1, r2
 100a49c:	bf08      	it	eq
 100a49e:	2200      	moveq	r2, #0
	p = (void *)(fifo + (*idx) * size);
 100a4a0:	4904      	ldr	r1, [pc, #16]	; (100a4b4 <ull_prepare_dequeue_iter+0x38>)
	*idx = i;
 100a4a2:	7002      	strb	r2, [r0, #0]
	p = (void *)(fifo + (*idx) * size);
 100a4a4:	fb05 1003 	mla	r0, r5, r3, r1
}
 100a4a8:	bc30      	pop	{r4, r5}
 100a4aa:	4770      	bx	lr
		return NULL;
 100a4ac:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
 100a4ae:	e7fb      	b.n	100a4a8 <ull_prepare_dequeue_iter+0x2c>
 100a4b0:	21000114 	.word	0x21000114
 100a4b4:	21000118 	.word	0x21000118

0100a4b8 <ull_event_done_extra_get>:
	evdone = MFIFO_DEQUEUE_PEEK(done);
 100a4b8:	4b06      	ldr	r3, [pc, #24]	; (100a4d4 <ull_event_done_extra_get+0x1c>)
 100a4ba:	789a      	ldrb	r2, [r3, #2]
	if (first == last) {
 100a4bc:	78d9      	ldrb	r1, [r3, #3]
 100a4be:	7818      	ldrb	r0, [r3, #0]
 100a4c0:	4291      	cmp	r1, r2
 100a4c2:	d005      	beq.n	100a4d0 <ull_event_done_extra_get+0x18>
	return *((void **)(fifo + first * size));
 100a4c4:	fb00 3302 	mla	r3, r0, r2, r3
 100a4c8:	6858      	ldr	r0, [r3, #4]
	if (!evdone) {
 100a4ca:	b110      	cbz	r0, 100a4d2 <ull_event_done_extra_get+0x1a>
	return &evdone->extra;
 100a4cc:	3024      	adds	r0, #36	; 0x24
 100a4ce:	4770      	bx	lr
		return NULL;
 100a4d0:	2000      	movs	r0, #0
}
 100a4d2:	4770      	bx	lr
 100a4d4:	210000b0 	.word	0x210000b0

0100a4d8 <ull_event_done>:
{
 100a4d8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	evdone = MFIFO_DEQUEUE(done);
 100a4da:	4b14      	ldr	r3, [pc, #80]	; (100a52c <ull_event_done+0x54>)
	u8_t _first = *first; /* Copy read-index */
 100a4dc:	7899      	ldrb	r1, [r3, #2]
	if (_first == last) {
 100a4de:	78da      	ldrb	r2, [r3, #3]
 100a4e0:	781c      	ldrb	r4, [r3, #0]
 100a4e2:	428a      	cmp	r2, r1
 100a4e4:	785d      	ldrb	r5, [r3, #1]
 100a4e6:	d01f      	beq.n	100a528 <ull_event_done+0x50>
	_first += 1U;
 100a4e8:	1c4a      	adds	r2, r1, #1
 100a4ea:	b2d2      	uxtb	r2, r2
		_first = 0U;
 100a4ec:	4295      	cmp	r5, r2
 100a4ee:	bf08      	it	eq
 100a4f0:	2200      	moveq	r2, #0
	mem = *((void **)(fifo + _first * size));
 100a4f2:	fb04 3101 	mla	r1, r4, r1, r3
 100a4f6:	684c      	ldr	r4, [r1, #4]
	*first = _first; /* Write back read-index */
 100a4f8:	709a      	strb	r2, [r3, #2]
	if (!evdone) {
 100a4fa:	b19c      	cbz	r4, 100a524 <ull_event_done+0x4c>
	evdone->hdr.type = NODE_RX_TYPE_EVENT_DONE;
 100a4fc:	2501      	movs	r5, #1
	evdone->hdr.link = NULL;
 100a4fe:	2600      	movs	r6, #0
	link = evdone->hdr.link;
 100a500:	6827      	ldr	r7, [r4, #0]
	evdone->param = param;
 100a502:	6220      	str	r0, [r4, #32]
	evdone->hdr.type = NODE_RX_TYPE_EVENT_DONE;
 100a504:	7125      	strb	r5, [r4, #4]
	evdone->hdr.link = NULL;
 100a506:	6026      	str	r6, [r4, #0]
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
 100a508:	f003 fc08 	bl	100dd1c <ull_conn_ack_last_idx_get>
	memq_enqueue(link, rx, &memq_ull_rx.tail);
 100a50c:	4621      	mov	r1, r4
 100a50e:	4a08      	ldr	r2, [pc, #32]	; (100a530 <ull_event_done+0x58>)
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
 100a510:	7020      	strb	r0, [r4, #0]
	memq_enqueue(link, rx, &memq_ull_rx.tail);
 100a512:	4638      	mov	r0, r7
 100a514:	f7fb fc64 	bl	1005de0 <memq_enqueue>
	mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_ULL_HIGH, 1, &mfy);
 100a518:	4630      	mov	r0, r6
 100a51a:	462a      	mov	r2, r5
 100a51c:	4629      	mov	r1, r5
 100a51e:	4b05      	ldr	r3, [pc, #20]	; (100a534 <ull_event_done+0x5c>)
 100a520:	f7fb fcd2 	bl	1005ec8 <mayfly_enqueue>
}
 100a524:	4620      	mov	r0, r4
 100a526:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return NULL;
 100a528:	2400      	movs	r4, #0
 100a52a:	e7fb      	b.n	100a524 <ull_event_done+0x4c>
 100a52c:	210000b0 	.word	0x210000b0
 100a530:	210023e4 	.word	0x210023e4
 100a534:	210002b4 	.word	0x210002b4

0100a538 <lll_chan_sel_1>:
#endif /* CONFIG_BT_CONN */

#if defined(CONFIG_BT_CONN)
u8_t lll_chan_sel_1(u8_t *chan_use, u8_t hop, u16_t latency, u8_t *chan_map,
		    u8_t chan_count)
{
 100a538:	b470      	push	{r4, r5, r6}
 100a53a:	4604      	mov	r4, r0
	u8_t chan_next;

	chan_next = ((*chan_use) + (hop * (1 + latency))) % 37;
 100a53c:	fb02 1101 	mla	r1, r2, r1, r1
 100a540:	7800      	ldrb	r0, [r0, #0]
 100a542:	4a1a      	ldr	r2, [pc, #104]	; (100a5ac <lll_chan_sel_1+0x74>)
 100a544:	4401      	add	r1, r0
 100a546:	fb82 0201 	smull	r0, r2, r2, r1
 100a54a:	440a      	add	r2, r1
 100a54c:	1152      	asrs	r2, r2, #5
 100a54e:	eb02 00c2 	add.w	r0, r2, r2, lsl #3
 100a552:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 100a556:	1a8a      	subs	r2, r1, r2
 100a558:	b2d0      	uxtb	r0, r2
	*chan_use = chan_next;

	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
 100a55a:	08c1      	lsrs	r1, r0, #3
	*chan_use = chan_next;
 100a55c:	7020      	strb	r0, [r4, #0]
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
 100a55e:	5c5c      	ldrb	r4, [r3, r1]
 100a560:	f002 0207 	and.w	r2, r2, #7
 100a564:	4114      	asrs	r4, r2
 100a566:	f014 0401 	ands.w	r4, r4, #1
{
 100a56a:	f89d 100c 	ldrb.w	r1, [sp, #12]
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
 100a56e:	d11b      	bne.n	100a5a8 <lll_chan_sel_1+0x70>
		u8_t chan_index;

		chan_index = chan_next % chan_count;
 100a570:	fbb0 f2f1 	udiv	r2, r0, r1
 100a574:	fb01 0212 	mls	r2, r1, r2, r0
 100a578:	1e5d      	subs	r5, r3, #1
 100a57a:	b2d2      	uxtb	r2, r2
	u8_t chan_next;
	u8_t byte_count;

	chan_next = 0U;
	byte_count = 5U;
	while (byte_count--) {
 100a57c:	1d1e      	adds	r6, r3, #4
		u8_t bite;
		u8_t bit_count;

		bite = *chan_map;
 100a57e:	f104 0108 	add.w	r1, r4, #8
 100a582:	f815 3f01 	ldrb.w	r3, [r5, #1]!
		bit_count = 8U;
		while (bit_count--) {
 100a586:	4620      	mov	r0, r4
 100a588:	b2cc      	uxtb	r4, r1
			if (bite & 0x01) {
 100a58a:	f013 0f01 	tst.w	r3, #1
				if (chan_index == 0U) {
					break;
				}
				chan_index--;
			}
			chan_next++;
 100a58e:	f100 0101 	add.w	r1, r0, #1
			bite >>= 1;
 100a592:	ea4f 0353 	mov.w	r3, r3, lsr #1
			if (bite & 0x01) {
 100a596:	d002      	beq.n	100a59e <lll_chan_sel_1+0x66>
				if (chan_index == 0U) {
 100a598:	b132      	cbz	r2, 100a5a8 <lll_chan_sel_1+0x70>
				chan_index--;
 100a59a:	3a01      	subs	r2, #1
 100a59c:	b2d2      	uxtb	r2, r2
			chan_next++;
 100a59e:	b2c8      	uxtb	r0, r1
		while (bit_count--) {
 100a5a0:	4284      	cmp	r4, r0
 100a5a2:	d1f2      	bne.n	100a58a <lll_chan_sel_1+0x52>
	while (byte_count--) {
 100a5a4:	42b5      	cmp	r5, r6
 100a5a6:	d1ea      	bne.n	100a57e <lll_chan_sel_1+0x46>
}
 100a5a8:	bc70      	pop	{r4, r5, r6}
 100a5aa:	4770      	bx	lr
 100a5ac:	dd67c8a7 	.word	0xdd67c8a7

0100a5b0 <lll_chan_sel_2>:
{
 100a5b0:	b5f0      	push	{r4, r5, r6, r7, lr}
static u16_t chan_prn(u16_t counter, u16_t chan_id)
{
	u8_t iterate;
	u16_t prn_e;

	prn_e = counter ^ chan_id;
 100a5b2:	2403      	movs	r4, #3
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
 100a5b4:	4f2e      	ldr	r7, [pc, #184]	; (100a670 <lll_chan_sel_2+0xc0>)
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
 100a5b6:	4e2f      	ldr	r6, [pc, #188]	; (100a674 <lll_chan_sel_2+0xc4>)
	prn_e = counter ^ chan_id;
 100a5b8:	ea80 0501 	eor.w	r5, r0, r1
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
 100a5bc:	0a28      	lsrs	r0, r5, #8
 100a5be:	b2ed      	uxtb	r5, r5
 100a5c0:	eb00 2080 	add.w	r0, r0, r0, lsl #10
 100a5c4:	eb05 2585 	add.w	r5, r5, r5, lsl #10
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
 100a5c8:	ea06 1e40 	and.w	lr, r6, r0, lsl #5
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
 100a5cc:	ea07 0c40 	and.w	ip, r7, r0, lsl #1
 100a5d0:	ea07 0045 	and.w	r0, r7, r5, lsl #1
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
 100a5d4:	ea06 1545 	and.w	r5, r6, r5, lsl #5
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
 100a5d8:	ea4c 0c0e 	orr.w	ip, ip, lr
 100a5dc:	4328      	orrs	r0, r5
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
 100a5de:	eb00 2500 	add.w	r5, r0, r0, lsl #8
 100a5e2:	eb0c 2e0c 	add.w	lr, ip, ip, lsl #8
 100a5e6:	eb00 2005 	add.w	r0, r0, r5, lsl #8
 100a5ea:	eb0c 2c0e 	add.w	ip, ip, lr, lsl #8
 100a5ee:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
	return (chan_rev_8((i >> 8) & 0xFF) << 8) | chan_rev_8(i & 0xFF);
 100a5f2:	f3c0 4007 	ubfx	r0, r0, #16, #8
 100a5f6:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
	return ((u32_t)a * 17U + b) & 0xFFFF;
 100a5fa:	eb00 1000 	add.w	r0, r0, r0, lsl #4
 100a5fe:	3c01      	subs	r4, #1
 100a600:	4408      	add	r0, r1

	for (iterate = 0U; iterate < 3; iterate++) {
 100a602:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
	return ((u32_t)a * 17U + b) & 0xFFFF;
 100a606:	b285      	uxth	r5, r0
	for (iterate = 0U; iterate < 3; iterate++) {
 100a608:	d1d8      	bne.n	100a5bc <lll_chan_sel_2+0xc>
	chan_next = prn_e % 37;
 100a60a:	481b      	ldr	r0, [pc, #108]	; (100a678 <lll_chan_sel_2+0xc8>)
		prn_e = chan_perm(prn_e);
		prn_e = chan_mam(prn_e, chan_id);
	}

	prn_e ^= chan_id;
 100a60c:	4069      	eors	r1, r5
	chan_next = prn_e % 37;
 100a60e:	fba0 5001 	umull	r5, r0, r0, r1
 100a612:	1a0d      	subs	r5, r1, r0
 100a614:	eb00 0055 	add.w	r0, r0, r5, lsr #1
 100a618:	0940      	lsrs	r0, r0, #5
 100a61a:	eb00 05c0 	add.w	r5, r0, r0, lsl #3
 100a61e:	eb00 0085 	add.w	r0, r0, r5, lsl #2
 100a622:	1a08      	subs	r0, r1, r0
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
 100a624:	f3c0 05c4 	ubfx	r5, r0, #3, #5
 100a628:	5d55      	ldrb	r5, [r2, r5]
 100a62a:	f000 0607 	and.w	r6, r0, #7
 100a62e:	4135      	asrs	r5, r6
 100a630:	07ed      	lsls	r5, r5, #31
	chan_next = prn_e % 37;
 100a632:	b2c0      	uxtb	r0, r0
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
 100a634:	d41a      	bmi.n	100a66c <lll_chan_sel_2+0xbc>
		chan_index = ((u32_t)chan_count * prn_e) >> 16;
 100a636:	fb01 f303 	mul.w	r3, r1, r3
 100a63a:	1e56      	subs	r6, r2, #1
 100a63c:	f3c3 4307 	ubfx	r3, r3, #16, #8
	while (byte_count--) {
 100a640:	3204      	adds	r2, #4
		bite = *chan_map;
 100a642:	f104 0508 	add.w	r5, r4, #8
 100a646:	f816 1f01 	ldrb.w	r1, [r6, #1]!
		while (bit_count--) {
 100a64a:	4620      	mov	r0, r4
 100a64c:	b2ec      	uxtb	r4, r5
			if (bite & 0x01) {
 100a64e:	f011 0f01 	tst.w	r1, #1
			chan_next++;
 100a652:	f100 0501 	add.w	r5, r0, #1
			bite >>= 1;
 100a656:	ea4f 0151 	mov.w	r1, r1, lsr #1
			if (bite & 0x01) {
 100a65a:	d002      	beq.n	100a662 <lll_chan_sel_2+0xb2>
				if (chan_index == 0U) {
 100a65c:	b133      	cbz	r3, 100a66c <lll_chan_sel_2+0xbc>
				chan_index--;
 100a65e:	3b01      	subs	r3, #1
 100a660:	b2db      	uxtb	r3, r3
			chan_next++;
 100a662:	b2e8      	uxtb	r0, r5
		while (bit_count--) {
 100a664:	42a0      	cmp	r0, r4
 100a666:	d1f2      	bne.n	100a64e <lll_chan_sel_2+0x9e>
	while (byte_count--) {
 100a668:	42b2      	cmp	r2, r6
 100a66a:	d1ea      	bne.n	100a642 <lll_chan_sel_2+0x92>
}
 100a66c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 100a66e:	bf00      	nop
 100a670:	00022110 	.word	0x00022110
 100a674:	00088440 	.word	0x00088440
 100a678:	bacf914d 	.word	0xbacf914d

0100a67c <disabled_cb>:
{
 100a67c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	adv = ((struct lll_hdr *)param)->parent;
 100a67e:	6805      	ldr	r5, [r0, #0]
{
 100a680:	4606      	mov	r6, r0
	LL_ASSERT(adv->link_cc_free);
 100a682:	f8d5 70d0 	ldr.w	r7, [r5, #208]	; 0xd0
 100a686:	b1f7      	cbz	r7, 100a6c6 <disabled_cb+0x4a>
	adv->link_cc_free = NULL;
 100a688:	2300      	movs	r3, #0
	LL_ASSERT(adv->node_rx_cc_free);
 100a68a:	f8d5 40d4 	ldr.w	r4, [r5, #212]	; 0xd4
	adv->link_cc_free = NULL;
 100a68e:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0
	LL_ASSERT(adv->node_rx_cc_free);
 100a692:	b334      	cbz	r4, 100a6e2 <disabled_cb+0x66>
	adv->node_rx_cc_free = NULL;
 100a694:	2100      	movs	r1, #0
	rx->hdr.handle = 0xffff;
 100a696:	f64f 73ff 	movw	r3, #65535	; 0xffff
	rx->hdr.type = NODE_RX_TYPE_CONNECTION;
 100a69a:	2208      	movs	r2, #8
	adv->node_rx_cc_free = NULL;
 100a69c:	f8c5 10d4 	str.w	r1, [r5, #212]	; 0xd4
	memset(cc, 0x00, sizeof(struct node_rx_cc));
 100a6a0:	f104 0020 	add.w	r0, r4, #32
	rx->hdr.type = NODE_RX_TYPE_CONNECTION;
 100a6a4:	7122      	strb	r2, [r4, #4]
	rx->hdr.handle = 0xffff;
 100a6a6:	80e3      	strh	r3, [r4, #6]
	memset(cc, 0x00, sizeof(struct node_rx_cc));
 100a6a8:	221e      	movs	r2, #30
 100a6aa:	f00c f9e0 	bl	1016a6e <memset>
	cc->status = BT_HCI_ERR_ADV_TIMEOUT;
 100a6ae:	233c      	movs	r3, #60	; 0x3c
	ll_rx_put(link, rx);
 100a6b0:	4638      	mov	r0, r7
 100a6b2:	4621      	mov	r1, r4
	ftr->param = param;
 100a6b4:	60a6      	str	r6, [r4, #8]
	cc->status = BT_HCI_ERR_ADV_TIMEOUT;
 100a6b6:	f884 3020 	strb.w	r3, [r4, #32]
	ll_rx_put(link, rx);
 100a6ba:	f7ff fd5f 	bl	100a17c <ll_rx_put>
}
 100a6be:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	ll_rx_sched();
 100a6c2:	f7ff bd65 	b.w	100a190 <ll_rx_sched>
	LL_ASSERT(adv->link_cc_free);
 100a6c6:	f240 41b2 	movw	r1, #1202	; 0x4b2
 100a6ca:	480a      	ldr	r0, [pc, #40]	; (100a6f4 <disabled_cb+0x78>)
 100a6cc:	f7f8 ffd8 	bl	1003680 <bt_ctlr_assert_handle>
	adv->link_cc_free = NULL;
 100a6d0:	2300      	movs	r3, #0
	LL_ASSERT(adv->node_rx_cc_free);
 100a6d2:	f8d5 40d4 	ldr.w	r4, [r5, #212]	; 0xd4
 100a6d6:	f8d5 70d0 	ldr.w	r7, [r5, #208]	; 0xd0
	adv->link_cc_free = NULL;
 100a6da:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0
	LL_ASSERT(adv->node_rx_cc_free);
 100a6de:	2c00      	cmp	r4, #0
 100a6e0:	d1d8      	bne.n	100a694 <disabled_cb+0x18>
 100a6e2:	f240 41b6 	movw	r1, #1206	; 0x4b6
 100a6e6:	4803      	ldr	r0, [pc, #12]	; (100a6f4 <disabled_cb+0x78>)
 100a6e8:	f7f8 ffca 	bl	1003680 <bt_ctlr_assert_handle>
 100a6ec:	f8d5 40d4 	ldr.w	r4, [r5, #212]	; 0xd4
 100a6f0:	e7d0      	b.n	100a694 <disabled_cb+0x18>
 100a6f2:	bf00      	nop
 100a6f4:	01018890 	.word	0x01018890

0100a6f8 <ticker_op_stop_cb>:
	if (status != TICKER_STATUS_SUCCESS) {
 100a6f8:	bb60      	cbnz	r0, 100a754 <ticker_op_stop_cb+0x5c>
{
 100a6fa:	b570      	push	{r4, r5, r6, lr}
	mfy.param = &adv->lll;
 100a6fc:	4d19      	ldr	r5, [pc, #100]	; (100a764 <ticker_op_stop_cb+0x6c>)
	if (hdr->ref) {
 100a6fe:	7c0a      	ldrb	r2, [r1, #16]
	mfy.param = &adv->lll;
 100a700:	f101 031c 	add.w	r3, r1, #28
 100a704:	460c      	mov	r4, r1
 100a706:	60ab      	str	r3, [r5, #8]
	if (hdr->ref) {
 100a708:	b1a2      	cbz	r2, 100a734 <ticker_op_stop_cb+0x3c>
		LL_ASSERT(!hdr->disabled_cb);
 100a70a:	694a      	ldr	r2, [r1, #20]
 100a70c:	b12a      	cbz	r2, 100a71a <ticker_op_stop_cb+0x22>
 100a70e:	f44f 6193 	mov.w	r1, #1176	; 0x498
 100a712:	4815      	ldr	r0, [pc, #84]	; (100a768 <ticker_op_stop_cb+0x70>)
 100a714:	f7f8 ffb4 	bl	1003680 <bt_ctlr_assert_handle>
 100a718:	68ab      	ldr	r3, [r5, #8]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
 100a71a:	2200      	movs	r2, #0
		hdr->disabled_cb = disabled_cb;
 100a71c:	4813      	ldr	r0, [pc, #76]	; (100a76c <ticker_op_stop_cb+0x74>)
		mfy.fp = lll_disable;
 100a71e:	4e14      	ldr	r6, [pc, #80]	; (100a770 <ticker_op_stop_cb+0x78>)
		hdr->disabled_param = mfy.param;
 100a720:	61a3      	str	r3, [r4, #24]
		hdr->disabled_cb = disabled_cb;
 100a722:	6160      	str	r0, [r4, #20]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
 100a724:	4611      	mov	r1, r2
 100a726:	2002      	movs	r0, #2
 100a728:	4b0e      	ldr	r3, [pc, #56]	; (100a764 <ticker_op_stop_cb+0x6c>)
		mfy.fp = lll_disable;
 100a72a:	60ee      	str	r6, [r5, #12]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
 100a72c:	f7fb fbcc 	bl	1005ec8 <mayfly_enqueue>
		LL_ASSERT(!ret);
 100a730:	b988      	cbnz	r0, 100a756 <ticker_op_stop_cb+0x5e>
}
 100a732:	bd70      	pop	{r4, r5, r6, pc}
		mfy.fp = disabled_cb;
 100a734:	4c0d      	ldr	r4, [pc, #52]	; (100a76c <ticker_op_stop_cb+0x74>)
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
 100a736:	462b      	mov	r3, r5
 100a738:	2101      	movs	r1, #1
 100a73a:	2002      	movs	r0, #2
		mfy.fp = disabled_cb;
 100a73c:	60ec      	str	r4, [r5, #12]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
 100a73e:	f7fb fbc3 	bl	1005ec8 <mayfly_enqueue>
		LL_ASSERT(!ret);
 100a742:	2800      	cmp	r0, #0
 100a744:	d0f5      	beq.n	100a732 <ticker_op_stop_cb+0x3a>
}
 100a746:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		LL_ASSERT(!ret);
 100a74a:	f240 41a4 	movw	r1, #1188	; 0x4a4
 100a74e:	4806      	ldr	r0, [pc, #24]	; (100a768 <ticker_op_stop_cb+0x70>)
 100a750:	f7f8 bf96 	b.w	1003680 <bt_ctlr_assert_handle>
 100a754:	4770      	bx	lr
		LL_ASSERT(!ret);
 100a756:	f240 419f 	movw	r1, #1183	; 0x49f
}
 100a75a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		LL_ASSERT(!ret);
 100a75e:	4802      	ldr	r0, [pc, #8]	; (100a768 <ticker_op_stop_cb+0x70>)
 100a760:	f7f8 bf8e 	b.w	1003680 <bt_ctlr_assert_handle>
 100a764:	210002e4 	.word	0x210002e4
 100a768:	01018890 	.word	0x01018890
 100a76c:	0100a67d 	.word	0x0100a67d
 100a770:	0100ff6d 	.word	0x0100ff6d

0100a774 <ticker_op_update_cb>:
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
 100a774:	b900      	cbnz	r0, 100a778 <ticker_op_update_cb+0x4>
 100a776:	4770      	bx	lr
{
 100a778:	b510      	push	{r4, lr}
 100a77a:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
 100a77c:	f7ff fd94 	bl	100a2a8 <ull_disable_mark_get>
 100a780:	4284      	cmp	r4, r0
 100a782:	d006      	beq.n	100a792 <ticker_op_update_cb+0x1e>
}
 100a784:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
 100a788:	f240 4159 	movw	r1, #1113	; 0x459
 100a78c:	4801      	ldr	r0, [pc, #4]	; (100a794 <ticker_op_update_cb+0x20>)
 100a78e:	f7f8 bf77 	b.w	1003680 <bt_ctlr_assert_handle>
}
 100a792:	bd10      	pop	{r4, pc}
 100a794:	01018890 	.word	0x01018890

0100a798 <ticker_stop_cb>:
{
 100a798:	b530      	push	{r4, r5, lr}
 100a79a:	461d      	mov	r5, r3
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
 100a79c:	4a12      	ldr	r2, [pc, #72]	; (100a7e8 <ticker_stop_cb+0x50>)
 100a79e:	4b13      	ldr	r3, [pc, #76]	; (100a7ec <ticker_stop_cb+0x54>)
 100a7a0:	1aaa      	subs	r2, r5, r2
 100a7a2:	0892      	lsrs	r2, r2, #2
 100a7a4:	fba3 3202 	umull	r3, r2, r3, r2
	LL_ASSERT(handle < BT_CTLR_ADV_MAX);
 100a7a8:	f3c2 034f 	ubfx	r3, r2, #1, #16
{
 100a7ac:	b083      	sub	sp, #12
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
 100a7ae:	0854      	lsrs	r4, r2, #1
	LL_ASSERT(handle < BT_CTLR_ADV_MAX);
 100a7b0:	b9a3      	cbnz	r3, 100a7dc <ticker_stop_cb+0x44>
			  TICKER_ID_ADV_BASE + handle,
 100a7b2:	1ca2      	adds	r2, r4, #2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
 100a7b4:	4b0e      	ldr	r3, [pc, #56]	; (100a7f0 <ticker_stop_cb+0x58>)
 100a7b6:	2101      	movs	r1, #1
 100a7b8:	2000      	movs	r0, #0
 100a7ba:	b2d2      	uxtb	r2, r2
 100a7bc:	9500      	str	r5, [sp, #0]
 100a7be:	f7fc fdb5 	bl	100732c <ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 100a7c2:	f030 0302 	bics.w	r3, r0, #2
 100a7c6:	d007      	beq.n	100a7d8 <ticker_stop_cb+0x40>
 100a7c8:	f240 417a 	movw	r1, #1146	; 0x47a
 100a7cc:	4809      	ldr	r0, [pc, #36]	; (100a7f4 <ticker_stop_cb+0x5c>)
}
 100a7ce:	b003      	add	sp, #12
 100a7d0:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 100a7d4:	f7f8 bf54 	b.w	1003680 <bt_ctlr_assert_handle>
}
 100a7d8:	b003      	add	sp, #12
 100a7da:	bd30      	pop	{r4, r5, pc}
	LL_ASSERT(handle < BT_CTLR_ADV_MAX);
 100a7dc:	f240 4175 	movw	r1, #1141	; 0x475
 100a7e0:	4804      	ldr	r0, [pc, #16]	; (100a7f4 <ticker_stop_cb+0x5c>)
 100a7e2:	f7f8 ff4d 	bl	1003680 <bt_ctlr_assert_handle>
 100a7e6:	e7e4      	b.n	100a7b2 <ticker_stop_cb+0x1a>
 100a7e8:	21002a60 	.word	0x21002a60
 100a7ec:	08fb823f 	.word	0x08fb823f
 100a7f0:	0100a6f9 	.word	0x0100a6f9
 100a7f4:	01018890 	.word	0x01018890

0100a7f8 <ticker_cb>:
{
 100a7f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100a7fc:	4615      	mov	r5, r2
	if (IS_ENABLED(CONFIG_BT_TICKER_COMPATIBILITY_MODE) ||
 100a7fe:	f64f 72ff 	movw	r2, #65535	; 0xffff
 100a802:	4295      	cmp	r5, r2
{
 100a804:	461c      	mov	r4, r3
 100a806:	b08a      	sub	sp, #40	; 0x28
	if (IS_ENABLED(CONFIG_BT_TICKER_COMPATIBILITY_MODE) ||
 100a808:	d017      	beq.n	100a83a <ticker_cb+0x42>
	return ++hdr->ref;
 100a80a:	7c1b      	ldrb	r3, [r3, #16]
 100a80c:	4680      	mov	r8, r0
 100a80e:	3301      	adds	r3, #1
 100a810:	b2db      	uxtb	r3, r3
 100a812:	460f      	mov	r7, r1
 100a814:	7423      	strb	r3, [r4, #16]
		LL_ASSERT(ref);
 100a816:	2b00      	cmp	r3, #0
 100a818:	d051      	beq.n	100a8be <ticker_cb+0xc6>
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 100a81a:	2200      	movs	r2, #0
		p.ticks_at_expire = ticks_at_expire;
 100a81c:	4e2b      	ldr	r6, [pc, #172]	; (100a8cc <ticker_cb+0xd4>)
		mfy.param = &p;
 100a81e:	4b2c      	ldr	r3, [pc, #176]	; (100a8d0 <ticker_cb+0xd8>)
	lll = &adv->lll;
 100a820:	f104 0c1c 	add.w	ip, r4, #28
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 100a824:	4611      	mov	r1, r2
 100a826:	2001      	movs	r0, #1
		p.remainder = remainder;
 100a828:	e9c6 8700 	strd	r8, r7, [r6]
		mfy.param = &p;
 100a82c:	609e      	str	r6, [r3, #8]
		p.lazy = lazy;
 100a82e:	8135      	strh	r5, [r6, #8]
		p.param = lll;
 100a830:	f8c6 c00c 	str.w	ip, [r6, #12]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 100a834:	f7fb fb48 	bl	1005ec8 <mayfly_enqueue>
		LL_ASSERT(!ret);
 100a838:	b938      	cbnz	r0, 100a84a <ticker_cb+0x52>
	if (!lll->is_hdcd)
 100a83a:	f894 5028 	ldrb.w	r5, [r4, #40]	; 0x28
 100a83e:	f015 0501 	ands.w	r5, r5, #1
 100a842:	d00c      	beq.n	100a85e <ticker_cb+0x66>
}
 100a844:	b00a      	add	sp, #40	; 0x28
 100a846:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		LL_ASSERT(!ret);
 100a84a:	f240 413a 	movw	r1, #1082	; 0x43a
 100a84e:	4821      	ldr	r0, [pc, #132]	; (100a8d4 <ticker_cb+0xdc>)
 100a850:	f7f8 ff16 	bl	1003680 <bt_ctlr_assert_handle>
	if (!lll->is_hdcd)
 100a854:	f894 5028 	ldrb.w	r5, [r4, #40]	; 0x28
 100a858:	f015 0501 	ands.w	r5, r5, #1
 100a85c:	d1f2      	bne.n	100a844 <ticker_cb+0x4c>
		random_delay %= ULL_ADV_RANDOM_DELAY;
 100a85e:	f240 1647 	movw	r6, #327	; 0x147
		lll_rng_isr_get(&random_delay, sizeof(random_delay));
 100a862:	2104      	movs	r1, #4
 100a864:	a809      	add	r0, sp, #36	; 0x24
 100a866:	f005 fb55 	bl	100ff14 <lll_rng_isr_get>
		random_delay %= ULL_ADV_RANDOM_DELAY;
 100a86a:	9809      	ldr	r0, [sp, #36]	; 0x24
 100a86c:	491a      	ldr	r1, [pc, #104]	; (100a8d8 <ticker_cb+0xe0>)
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
 100a86e:	4a1b      	ldr	r2, [pc, #108]	; (100a8dc <ticker_cb+0xe4>)
		random_delay %= ULL_ADV_RANDOM_DELAY;
 100a870:	fba1 3100 	umull	r3, r1, r1, r0
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
 100a874:	9406      	str	r4, [sp, #24]
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
 100a876:	1aa2      	subs	r2, r4, r2
 100a878:	4c19      	ldr	r4, [pc, #100]	; (100a8e0 <ticker_cb+0xe8>)
		random_delay %= ULL_ADV_RANDOM_DELAY;
 100a87a:	1a43      	subs	r3, r0, r1
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
 100a87c:	0892      	lsrs	r2, r2, #2
		random_delay %= ULL_ADV_RANDOM_DELAY;
 100a87e:	eb01 0353 	add.w	r3, r1, r3, lsr #1
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
 100a882:	fba4 1202 	umull	r1, r2, r4, r2
		random_delay %= ULL_ADV_RANDOM_DELAY;
 100a886:	0a1b      	lsrs	r3, r3, #8
 100a888:	fb06 0313 	mls	r3, r6, r3, r0
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
 100a88c:	4915      	ldr	r1, [pc, #84]	; (100a8e4 <ticker_cb+0xec>)
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
 100a88e:	0852      	lsrs	r2, r2, #1
				    (TICKER_ID_ADV_BASE +
 100a890:	3202      	adds	r2, #2
		random_delay += 1;
 100a892:	3301      	adds	r3, #1
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
 100a894:	9105      	str	r1, [sp, #20]
 100a896:	4628      	mov	r0, r5
 100a898:	2101      	movs	r1, #1
 100a89a:	e9cd 5503 	strd	r5, r5, [sp, #12]
 100a89e:	e9cd 5501 	strd	r5, r5, [sp, #4]
 100a8a2:	9500      	str	r5, [sp, #0]
 100a8a4:	b2d2      	uxtb	r2, r2
		random_delay += 1;
 100a8a6:	9309      	str	r3, [sp, #36]	; 0x24
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
 100a8a8:	f7fc fcf6 	bl	1007298 <ticker_update>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 100a8ac:	f030 0302 	bics.w	r3, r0, #2
 100a8b0:	d0c8      	beq.n	100a844 <ticker_cb+0x4c>
 100a8b2:	f44f 618a 	mov.w	r1, #1104	; 0x450
 100a8b6:	4807      	ldr	r0, [pc, #28]	; (100a8d4 <ticker_cb+0xdc>)
 100a8b8:	f7f8 fee2 	bl	1003680 <bt_ctlr_assert_handle>
}
 100a8bc:	e7c2      	b.n	100a844 <ticker_cb+0x4c>
		LL_ASSERT(ref);
 100a8be:	f240 412e 	movw	r1, #1070	; 0x42e
 100a8c2:	4804      	ldr	r0, [pc, #16]	; (100a8d4 <ticker_cb+0xdc>)
 100a8c4:	f7f8 fedc 	bl	1003680 <bt_ctlr_assert_handle>
 100a8c8:	e7a7      	b.n	100a81a <ticker_cb+0x22>
 100a8ca:	bf00      	nop
 100a8cc:	21002b50 	.word	0x21002b50
 100a8d0:	210002d4 	.word	0x210002d4
 100a8d4:	01018890 	.word	0x01018890
 100a8d8:	90d4f121 	.word	0x90d4f121
 100a8dc:	21002a60 	.word	0x21002a60
 100a8e0:	08fb823f 	.word	0x08fb823f
 100a8e4:	0100a775 	.word	0x0100a775

0100a8e8 <conn_release.constprop.0>:
static void conn_release(struct ll_adv_set *adv)
 100a8e8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct lll_conn *lll = adv->lll.conn;
 100a8ea:	4c15      	ldr	r4, [pc, #84]	; (100a940 <conn_release.constprop.0+0x58>)
 100a8ec:	6a65      	ldr	r5, [r4, #36]	; 0x24
	LL_ASSERT(!lll->link_tx_free);
 100a8ee:	6deb      	ldr	r3, [r5, #92]	; 0x5c
 100a8f0:	b123      	cbz	r3, 100a8fc <conn_release.constprop.0+0x14>
 100a8f2:	f240 41cd 	movw	r1, #1229	; 0x4cd
 100a8f6:	4813      	ldr	r0, [pc, #76]	; (100a944 <conn_release.constprop.0+0x5c>)
 100a8f8:	f7f8 fec2 	bl	1003680 <bt_ctlr_assert_handle>
	link = memq_deinit(&lll->memq_tx.head, &lll->memq_tx.tail);
 100a8fc:	f105 0150 	add.w	r1, r5, #80	; 0x50
 100a900:	f105 004c 	add.w	r0, r5, #76	; 0x4c
 100a904:	f7fb fa62 	bl	1005dcc <memq_deinit>
	LL_ASSERT(link);
 100a908:	4606      	mov	r6, r0
 100a90a:	b190      	cbz	r0, 100a932 <conn_release.constprop.0+0x4a>
	adv->lll.conn = NULL;
 100a90c:	2700      	movs	r7, #0
	ll_conn_release(lll->hdr.parent);
 100a90e:	6828      	ldr	r0, [r5, #0]
	lll->link_tx_free = link;
 100a910:	65ee      	str	r6, [r5, #92]	; 0x5c
	ll_conn_release(lll->hdr.parent);
 100a912:	f000 fec9 	bl	100b6a8 <ll_conn_release>
	ll_rx_release(adv->node_rx_cc_free);
 100a916:	f8d4 00d4 	ldr.w	r0, [r4, #212]	; 0xd4
	adv->lll.conn = NULL;
 100a91a:	6267      	str	r7, [r4, #36]	; 0x24
	ll_rx_release(adv->node_rx_cc_free);
 100a91c:	f7ff fc28 	bl	100a170 <ll_rx_release>
	ll_rx_link_release(adv->link_cc_free);
 100a920:	f8d4 00d0 	ldr.w	r0, [r4, #208]	; 0xd0
	adv->node_rx_cc_free = NULL;
 100a924:	f8c4 70d4 	str.w	r7, [r4, #212]	; 0xd4
	ll_rx_link_release(adv->link_cc_free);
 100a928:	f7ff fc16 	bl	100a158 <ll_rx_link_release>
	adv->link_cc_free = NULL;
 100a92c:	f8c4 70d0 	str.w	r7, [r4, #208]	; 0xd0
}
 100a930:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	LL_ASSERT(link);
 100a932:	f240 41cf 	movw	r1, #1231	; 0x4cf
 100a936:	4803      	ldr	r0, [pc, #12]	; (100a944 <conn_release.constprop.0+0x5c>)
 100a938:	f7f8 fea2 	bl	1003680 <bt_ctlr_assert_handle>
 100a93c:	e7e6      	b.n	100a90c <conn_release.constprop.0+0x24>
 100a93e:	bf00      	nop
 100a940:	21002a60 	.word	0x21002a60
 100a944:	01018890 	.word	0x01018890

0100a948 <ll_adv_params_set>:
{
 100a948:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (!adv || adv->is_enabled) {
 100a94c:	4c49      	ldr	r4, [pc, #292]	; (100aa74 <ll_adv_params_set+0x12c>)
{
 100a94e:	460e      	mov	r6, r1
	if (!adv || adv->is_enabled) {
 100a950:	f894 70cc 	ldrb.w	r7, [r4, #204]	; 0xcc
	u8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
 100a954:	4948      	ldr	r1, [pc, #288]	; (100aa78 <ll_adv_params_set+0x130>)
{
 100a956:	b083      	sub	sp, #12
	if (!adv || adv->is_enabled) {
 100a958:	f017 0701 	ands.w	r7, r7, #1
{
 100a95c:	4684      	mov	ip, r0
	u8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
 100a95e:	c903      	ldmia	r1, {r0, r1}
{
 100a960:	4615      	mov	r5, r2
 100a962:	4698      	mov	r8, r3
 100a964:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
 100a968:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
	u8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
 100a96c:	9000      	str	r0, [sp, #0]
 100a96e:	f88d 1004 	strb.w	r1, [sp, #4]
	if (!adv || adv->is_enabled) {
 100a972:	d16d      	bne.n	100aa50 <ll_adv_params_set+0x108>
	pdu->type = pdu_adv_type[adv_type];
 100a974:	a902      	add	r1, sp, #8
 100a976:	4431      	add	r1, r6
 100a978:	f811 0c08 	ldrb.w	r0, [r1, #-8]
		adv->interval = 0;
 100a97c:	2e01      	cmp	r6, #1
 100a97e:	bf08      	it	eq
 100a980:	f04f 0c00 	moveq.w	ip, #0
	if (IS_ENABLED(CONFIG_BT_CTLR_CHAN_SEL_2) &&
 100a984:	f010 0f0e 	tst.w	r0, #14
 100a988:	bf0c      	ite	eq
 100a98a:	2101      	moveq	r1, #1
 100a98c:	2100      	movne	r1, #0
 100a98e:	f894 602c 	ldrb.w	r6, [r4, #44]	; 0x2c
	adv->lll.chan_map = chan_map;
 100a992:	f002 0207 	and.w	r2, r2, #7
 100a996:	eb06 0e86 	add.w	lr, r6, r6, lsl #2
 100a99a:	f003 0303 	and.w	r3, r3, #3
 100a99e:	0052      	lsls	r2, r2, #1
 100a9a0:	ebc6 06ce 	rsb	r6, r6, lr, lsl #3
 100a9a4:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 100a9a8:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 100a9aa:	362d      	adds	r6, #45	; 0x2d
	pdu->type = pdu_adv_type[adv_type];
 100a9ac:	f814 e006 	ldrb.w	lr, [r4, r6]
	adv->lll.chan_map = chan_map;
 100a9b0:	f423 7343 	bic.w	r3, r3, #780	; 0x30c
 100a9b4:	f023 0302 	bic.w	r3, r3, #2
 100a9b8:	431a      	orrs	r2, r3
	pdu->type = pdu_adv_type[adv_type];
 100a9ba:	f000 000f 	and.w	r0, r0, #15
	adv->own_addr_type = own_addr_type;
 100a9be:	f894 30da 	ldrb.w	r3, [r4, #218]	; 0xda
	pdu->type = pdu_adv_type[adv_type];
 100a9c2:	f02e 0e1f 	bic.w	lr, lr, #31
 100a9c6:	ea40 000e 	orr.w	r0, r0, lr
	adv->own_addr_type = own_addr_type;
 100a9ca:	f365 0301 	bfi	r3, r5, #0, #2
 100a9ce:	f361 1045 	bfi	r0, r1, #5, #1
	adv->lll.chan_map = chan_map;
 100a9d2:	8522      	strh	r2, [r4, #40]	; 0x28
 100a9d4:	f8a4 c0d8 	strh.w	ip, [r4, #216]	; 0xd8
	if (adv->own_addr_type == BT_ADDR_LE_PUBLIC_ID ||
 100a9d8:	b2da      	uxtb	r2, r3
 100a9da:	55a0      	strb	r0, [r4, r6]
	adv->own_addr_type = own_addr_type;
 100a9dc:	f884 30da 	strb.w	r3, [r4, #218]	; 0xda
	if (adv->own_addr_type == BT_ADDR_LE_PUBLIC_ID ||
 100a9e0:	079b      	lsls	r3, r3, #30
 100a9e2:	eb04 0906 	add.w	r9, r4, r6
 100a9e6:	d427      	bmi.n	100aa38 <ll_adv_params_set+0xf0>
	pdu->tx_addr = own_addr_type & 0x1;
 100a9e8:	5da3      	ldrb	r3, [r4, r6]
 100a9ea:	f365 1386 	bfi	r3, r5, #6, #1
	pdu->rx_addr = 0;
 100a9ee:	f36f 13c7 	bfc	r3, #7, #1
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
 100a9f2:	f003 020f 	and.w	r2, r3, #15
 100a9f6:	2a01      	cmp	r2, #1
	pdu->rx_addr = 0;
 100a9f8:	55a3      	strb	r3, [r4, r6]
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
 100a9fa:	b2db      	uxtb	r3, r3
 100a9fc:	d02d      	beq.n	100aa5a <ll_adv_params_set+0x112>
	} else if (pdu->len == 0) {
 100a9fe:	f899 3001 	ldrb.w	r3, [r9, #1]
 100aa02:	b913      	cbnz	r3, 100aa0a <ll_adv_params_set+0xc2>
		pdu->len = BDADDR_SIZE;
 100aa04:	2306      	movs	r3, #6
 100aa06:	f889 3001 	strb.w	r3, [r9, #1]
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 100aa0a:	f894 307c 	ldrb.w	r3, [r4, #124]	; 0x7c
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
 100aa0e:	01ad      	lsls	r5, r5, #6
 100aa10:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 100aa14:	f005 0540 	and.w	r5, r5, #64	; 0x40
 100aa18:	ebc3 03c2 	rsb	r3, r3, r2, lsl #3
 100aa1c:	337d      	adds	r3, #125	; 0x7d
 100aa1e:	f045 0504 	orr.w	r5, r5, #4
 100aa22:	54e5      	strb	r5, [r4, r3]
 100aa24:	441c      	add	r4, r3
	if (pdu->len == 0) {
 100aa26:	7863      	ldrb	r3, [r4, #1]
 100aa28:	b913      	cbnz	r3, 100aa30 <ll_adv_params_set+0xe8>
		pdu->len = BDADDR_SIZE;
 100aa2a:	2206      	movs	r2, #6
	return 0;
 100aa2c:	461f      	mov	r7, r3
		pdu->len = BDADDR_SIZE;
 100aa2e:	7062      	strb	r2, [r4, #1]
}
 100aa30:	4638      	mov	r0, r7
 100aa32:	b003      	add	sp, #12
 100aa34:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		adv->id_addr_type = direct_addr_type;
 100aa38:	4613      	mov	r3, r2
 100aa3a:	f368 0382 	bfi	r3, r8, #2, #1
		memcpy(&adv->id_addr, direct_addr, BDADDR_SIZE);
 100aa3e:	2206      	movs	r2, #6
 100aa40:	990a      	ldr	r1, [sp, #40]	; 0x28
 100aa42:	f104 00db 	add.w	r0, r4, #219	; 0xdb
		adv->id_addr_type = direct_addr_type;
 100aa46:	f884 30da 	strb.w	r3, [r4, #218]	; 0xda
		memcpy(&adv->id_addr, direct_addr, BDADDR_SIZE);
 100aa4a:	f00b ffe5 	bl	1016a18 <memcpy>
 100aa4e:	e7cb      	b.n	100a9e8 <ll_adv_params_set+0xa0>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100aa50:	270c      	movs	r7, #12
}
 100aa52:	4638      	mov	r0, r7
 100aa54:	b003      	add	sp, #12
 100aa56:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		pdu->rx_addr = direct_addr_type;
 100aa5a:	f368 13c7 	bfi	r3, r8, #7, #1
 100aa5e:	55a3      	strb	r3, [r4, r6]
		memcpy(&pdu->direct_ind.tgt_addr[0], direct_addr, BDADDR_SIZE);
 100aa60:	2206      	movs	r2, #6
 100aa62:	990a      	ldr	r1, [sp, #40]	; 0x28
 100aa64:	f109 0008 	add.w	r0, r9, #8
 100aa68:	f00b ffd6 	bl	1016a18 <memcpy>
		pdu->len = sizeof(struct pdu_adv_direct_ind);
 100aa6c:	230c      	movs	r3, #12
 100aa6e:	f889 3001 	strb.w	r3, [r9, #1]
 100aa72:	e7ca      	b.n	100aa0a <ll_adv_params_set+0xc2>
 100aa74:	21002a60 	.word	0x21002a60
 100aa78:	01018348 	.word	0x01018348

0100aa7c <ll_adv_data_set>:
{
 100aa7c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 100aa80:	4e23      	ldr	r6, [pc, #140]	; (100ab10 <ll_adv_data_set+0x94>)
 100aa82:	460f      	mov	r7, r1
 100aa84:	f896 402c 	ldrb.w	r4, [r6, #44]	; 0x2c
 100aa88:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 100aa8c:	ebc4 03c3 	rsb	r3, r4, r3, lsl #3
 100aa90:	332d      	adds	r3, #45	; 0x2d
	if ((prev->type == PDU_ADV_TYPE_DIRECT_IND) ||
 100aa92:	5cf2      	ldrb	r2, [r6, r3]
 100aa94:	4433      	add	r3, r6
 100aa96:	f002 010f 	and.w	r1, r2, #15
 100aa9a:	2901      	cmp	r1, #1
 100aa9c:	d024      	beq.n	100aae8 <ll_adv_data_set+0x6c>
	if (pdu->first == pdu->last) {
 100aa9e:	f896 102b 	ldrb.w	r1, [r6, #43]	; 0x2b
 100aaa2:	4605      	mov	r5, r0
 100aaa4:	42a1      	cmp	r1, r4
 100aaa6:	d022      	beq.n	100aaee <ll_adv_data_set+0x72>
 100aaa8:	4698      	mov	r8, r3
	pdu->type = prev->type;
 100aaaa:	4640      	mov	r0, r8
		pdu->chan_sel = prev->chan_sel;
 100aaac:	f3c2 1c40 	ubfx	ip, r2, #5, #1
	pdu->type = prev->type;
 100aab0:	f3c2 0103 	ubfx	r1, r2, #0, #4
 100aab4:	ea41 114c 	orr.w	r1, r1, ip, lsl #5
	pdu->tx_addr = prev->tx_addr;
 100aab8:	f3c2 1c80 	ubfx	ip, r2, #6, #1
	pdu->type = prev->type;
 100aabc:	ea41 118c 	orr.w	r1, r1, ip, lsl #6
 100aac0:	f002 0280 	and.w	r2, r2, #128	; 0x80
 100aac4:	430a      	orrs	r2, r1
 100aac6:	f800 2b02 	strb.w	r2, [r0], #2
	memcpy(&pdu->adv_ind.addr[0], &prev->adv_ind.addr[0], BDADDR_SIZE);
 100aaca:	1c99      	adds	r1, r3, #2
 100aacc:	2206      	movs	r2, #6
 100aace:	f00b ffa3 	bl	1016a18 <memcpy>
	memcpy(&pdu->adv_ind.data[0], data, len);
 100aad2:	462a      	mov	r2, r5
 100aad4:	4639      	mov	r1, r7
 100aad6:	f108 0008 	add.w	r0, r8, #8
	pdu->len = BDADDR_SIZE + len;
 100aada:	3506      	adds	r5, #6
	memcpy(&pdu->adv_ind.data[0], data, len);
 100aadc:	f00b ff9c 	bl	1016a18 <memcpy>
	pdu->len = BDADDR_SIZE + len;
 100aae0:	f888 5001 	strb.w	r5, [r8, #1]
	pdu->last = idx;
 100aae4:	f886 402c 	strb.w	r4, [r6, #44]	; 0x2c
}
 100aae8:	2000      	movs	r0, #0
 100aaea:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		last = pdu->last + 1;
 100aaee:	3401      	adds	r4, #1
 100aaf0:	b2e4      	uxtb	r4, r4
		if (last == DOUBLE_BUFFER_SIZE) {
 100aaf2:	2c02      	cmp	r4, #2
 100aaf4:	d007      	beq.n	100ab06 <ll_adv_data_set+0x8a>
 100aaf6:	eb04 0884 	add.w	r8, r4, r4, lsl #2
 100aafa:	ebc4 08c8 	rsb	r8, r4, r8, lsl #3
 100aafe:	f108 082d 	add.w	r8, r8, #45	; 0x2d
 100ab02:	44b0      	add	r8, r6
 100ab04:	e7d1      	b.n	100aaaa <ll_adv_data_set+0x2e>
			last = 0U;
 100ab06:	2400      	movs	r4, #0
 100ab08:	f106 082d 	add.w	r8, r6, #45	; 0x2d
 100ab0c:	e7cd      	b.n	100aaaa <ll_adv_data_set+0x2e>
 100ab0e:	bf00      	nop
 100ab10:	21002a60 	.word	0x21002a60

0100ab14 <ll_adv_scan_rsp_set>:
{
 100ab14:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 100ab18:	4e1d      	ldr	r6, [pc, #116]	; (100ab90 <ll_adv_scan_rsp_set+0x7c>)
 100ab1a:	4688      	mov	r8, r1
 100ab1c:	f896 407c 	ldrb.w	r4, [r6, #124]	; 0x7c
	if (pdu->first == pdu->last) {
 100ab20:	f896 207b 	ldrb.w	r2, [r6, #123]	; 0x7b
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 100ab24:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 100ab28:	ebc4 03c3 	rsb	r3, r4, r3, lsl #3
 100ab2c:	337d      	adds	r3, #125	; 0x7d
	if (pdu->first == pdu->last) {
 100ab2e:	42a2      	cmp	r2, r4
 100ab30:	4607      	mov	r7, r0
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 100ab32:	eb06 0103 	add.w	r1, r6, r3
	if (pdu->first == pdu->last) {
 100ab36:	d01b      	beq.n	100ab70 <ll_adv_scan_rsp_set+0x5c>
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 100ab38:	460d      	mov	r5, r1
	pdu->tx_addr = prev->tx_addr;
 100ab3a:	5cf3      	ldrb	r3, [r6, r3]
	pdu->len = BDADDR_SIZE + len;
 100ab3c:	f107 0c06 	add.w	ip, r7, #6
	pdu->tx_addr = prev->tx_addr;
 100ab40:	f3c3 1380 	ubfx	r3, r3, #6, #1
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
 100ab44:	019b      	lsls	r3, r3, #6
 100ab46:	f043 0304 	orr.w	r3, r3, #4
 100ab4a:	702b      	strb	r3, [r5, #0]
	pdu->len = BDADDR_SIZE + len;
 100ab4c:	f885 c001 	strb.w	ip, [r5, #1]
	memcpy(&pdu->scan_rsp.addr[0], &prev->scan_rsp.addr[0], BDADDR_SIZE);
 100ab50:	2206      	movs	r2, #6
 100ab52:	3102      	adds	r1, #2
 100ab54:	1ca8      	adds	r0, r5, #2
 100ab56:	f00b ff5f 	bl	1016a18 <memcpy>
	memcpy(&pdu->scan_rsp.data[0], data, len);
 100ab5a:	463a      	mov	r2, r7
 100ab5c:	4641      	mov	r1, r8
 100ab5e:	f105 0008 	add.w	r0, r5, #8
 100ab62:	f00b ff59 	bl	1016a18 <memcpy>
}
 100ab66:	2000      	movs	r0, #0
	pdu->last = idx;
 100ab68:	f886 407c 	strb.w	r4, [r6, #124]	; 0x7c
 100ab6c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		last = pdu->last + 1;
 100ab70:	3401      	adds	r4, #1
 100ab72:	b2e4      	uxtb	r4, r4
		if (last == DOUBLE_BUFFER_SIZE) {
 100ab74:	2c02      	cmp	r4, #2
 100ab76:	d006      	beq.n	100ab86 <ll_adv_scan_rsp_set+0x72>
 100ab78:	eb04 0584 	add.w	r5, r4, r4, lsl #2
 100ab7c:	ebc4 05c5 	rsb	r5, r4, r5, lsl #3
 100ab80:	357d      	adds	r5, #125	; 0x7d
 100ab82:	4435      	add	r5, r6
 100ab84:	e7d9      	b.n	100ab3a <ll_adv_scan_rsp_set+0x26>
			last = 0U;
 100ab86:	2400      	movs	r4, #0
 100ab88:	f106 057d 	add.w	r5, r6, #125	; 0x7d
 100ab8c:	e7d5      	b.n	100ab3a <ll_adv_scan_rsp_set+0x26>
 100ab8e:	bf00      	nop
 100ab90:	21002a60 	.word	0x21002a60

0100ab94 <ull_adv_init>:
}
 100ab94:	2000      	movs	r0, #0
 100ab96:	4770      	bx	lr

0100ab98 <ull_adv_reset>:
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 100ab98:	2302      	movs	r3, #2
{
 100ab9a:	b530      	push	{r4, r5, lr}
	if (!adv || !adv->is_enabled) {
 100ab9c:	4c39      	ldr	r4, [pc, #228]	; (100ac84 <ull_adv_reset+0xec>)
{
 100ab9e:	b085      	sub	sp, #20
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 100aba0:	9303      	str	r3, [sp, #12]
	if (!adv || !adv->is_enabled) {
 100aba2:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
 100aba6:	07da      	lsls	r2, r3, #31
 100aba8:	d543      	bpl.n	100ac32 <ull_adv_reset+0x9a>
	mark = ull_disable_mark(adv);
 100abaa:	4620      	mov	r0, r4
 100abac:	f7ff fb64 	bl	100a278 <ull_disable_mark>
	LL_ASSERT(mark == adv);
 100abb0:	4284      	cmp	r4, r0
 100abb2:	d004      	beq.n	100abbe <ull_adv_reset+0x26>
 100abb4:	f240 41e9 	movw	r1, #1257	; 0x4e9
 100abb8:	4833      	ldr	r0, [pc, #204]	; (100ac88 <ull_adv_reset+0xf0>)
 100abba:	f7f8 fd61 	bl	1003680 <bt_ctlr_assert_handle>
	if (adv->lll.is_hdcd) {
 100abbe:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 100abc2:	ad03      	add	r5, sp, #12
	if (adv->lll.is_hdcd) {
 100abc4:	07db      	lsls	r3, r3, #31
 100abc6:	d50d      	bpl.n	100abe4 <ull_adv_reset+0x4c>
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 100abc8:	2103      	movs	r1, #3
 100abca:	2201      	movs	r2, #1
 100abcc:	2000      	movs	r0, #0
 100abce:	4b2f      	ldr	r3, [pc, #188]	; (100ac8c <ull_adv_reset+0xf4>)
 100abd0:	9500      	str	r5, [sp, #0]
 100abd2:	f7fc fbab 	bl	100732c <ticker_stop>
		ret = ull_ticker_status_take(ret, &ret_cb);
 100abd6:	4629      	mov	r1, r5
 100abd8:	f7ff fb40 	bl	100a25c <ull_ticker_status_take>
		if (ret) {
 100abdc:	2800      	cmp	r0, #0
 100abde:	d146      	bne.n	100ac6e <ull_adv_reset+0xd6>
		ret_cb = TICKER_STATUS_BUSY;
 100abe0:	2302      	movs	r3, #2
 100abe2:	9303      	str	r3, [sp, #12]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
 100abe4:	2103      	movs	r1, #3
 100abe6:	2202      	movs	r2, #2
 100abe8:	2000      	movs	r0, #0
 100abea:	4b28      	ldr	r3, [pc, #160]	; (100ac8c <ull_adv_reset+0xf4>)
 100abec:	9500      	str	r5, [sp, #0]
 100abee:	f7fc fb9d 	bl	100732c <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
 100abf2:	4629      	mov	r1, r5
 100abf4:	f7ff fb32 	bl	100a25c <ull_ticker_status_take>
	if (ret) {
 100abf8:	bb48      	cbnz	r0, 100ac4e <ull_adv_reset+0xb6>
	ret = ull_disable(&adv->lll);
 100abfa:	4825      	ldr	r0, [pc, #148]	; (100ac90 <ull_adv_reset+0xf8>)
 100abfc:	f7ff fb78 	bl	100a2f0 <ull_disable>
	LL_ASSERT(!ret);
 100ac00:	b9d0      	cbnz	r0, 100ac38 <ull_adv_reset+0xa0>
	mark = ull_disable_unmark(adv);
 100ac02:	4820      	ldr	r0, [pc, #128]	; (100ac84 <ull_adv_reset+0xec>)
 100ac04:	f7ff fb42 	bl	100a28c <ull_disable_unmark>
	LL_ASSERT(mark == adv);
 100ac08:	4284      	cmp	r4, r0
 100ac0a:	d004      	beq.n	100ac16 <ull_adv_reset+0x7e>
 100ac0c:	f240 510b 	movw	r1, #1291	; 0x50b
 100ac10:	481d      	ldr	r0, [pc, #116]	; (100ac88 <ull_adv_reset+0xf0>)
 100ac12:	f7f8 fd35 	bl	1003680 <bt_ctlr_assert_handle>
	if (adv->lll.conn) {
 100ac16:	6a63      	ldr	r3, [r4, #36]	; 0x24
 100ac18:	b10b      	cbz	r3, 100ac1e <ull_adv_reset+0x86>
		conn_release(adv);
 100ac1a:	f7ff fe65 	bl	100a8e8 <conn_release.constprop.0>
	adv->is_enabled = 0U;
 100ac1e:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
	if (IS_ENABLED(CONFIG_BT_OBSERVER) && !ull_scan_is_enabled_get(0)) {
 100ac22:	2000      	movs	r0, #0
	adv->is_enabled = 0U;
 100ac24:	f36f 0300 	bfc	r3, #0, #1
 100ac28:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
	if (IS_ENABLED(CONFIG_BT_OBSERVER) && !ull_scan_is_enabled_get(0)) {
 100ac2c:	f000 f98e 	bl	100af4c <ull_scan_is_enabled_get>
 100ac30:	b1c0      	cbz	r0, 100ac64 <ull_adv_reset+0xcc>
}
 100ac32:	2000      	movs	r0, #0
 100ac34:	b005      	add	sp, #20
 100ac36:	bd30      	pop	{r4, r5, pc}
	LL_ASSERT(!ret);
 100ac38:	f44f 61a1 	mov.w	r1, #1288	; 0x508
 100ac3c:	4812      	ldr	r0, [pc, #72]	; (100ac88 <ull_adv_reset+0xf0>)
 100ac3e:	f7f8 fd1f 	bl	1003680 <bt_ctlr_assert_handle>
	mark = ull_disable_unmark(adv);
 100ac42:	4810      	ldr	r0, [pc, #64]	; (100ac84 <ull_adv_reset+0xec>)
 100ac44:	f7ff fb22 	bl	100a28c <ull_disable_unmark>
	LL_ASSERT(mark == adv);
 100ac48:	4284      	cmp	r4, r0
 100ac4a:	d1df      	bne.n	100ac0c <ull_adv_reset+0x74>
 100ac4c:	e7e3      	b.n	100ac16 <ull_adv_reset+0x7e>
		mark = ull_disable_mark(adv);
 100ac4e:	480d      	ldr	r0, [pc, #52]	; (100ac84 <ull_adv_reset+0xec>)
 100ac50:	f7ff fb12 	bl	100a278 <ull_disable_mark>
		LL_ASSERT(mark == adv);
 100ac54:	4284      	cmp	r4, r0
 100ac56:	d0ec      	beq.n	100ac32 <ull_adv_reset+0x9a>
 100ac58:	f240 5102 	movw	r1, #1282	; 0x502
 100ac5c:	480a      	ldr	r0, [pc, #40]	; (100ac88 <ull_adv_reset+0xf0>)
 100ac5e:	f7f8 fd0f 	bl	1003680 <bt_ctlr_assert_handle>
 100ac62:	e7e6      	b.n	100ac32 <ull_adv_reset+0x9a>
		ull_filter_adv_scan_state_cb(0);
 100ac64:	f004 f94e 	bl	100ef04 <ull_filter_adv_scan_state_cb>
}
 100ac68:	2000      	movs	r0, #0
 100ac6a:	b005      	add	sp, #20
 100ac6c:	bd30      	pop	{r4, r5, pc}
			mark = ull_disable_mark(adv);
 100ac6e:	4805      	ldr	r0, [pc, #20]	; (100ac84 <ull_adv_reset+0xec>)
 100ac70:	f7ff fb02 	bl	100a278 <ull_disable_mark>
			LL_ASSERT(mark == adv);
 100ac74:	4284      	cmp	r4, r0
 100ac76:	d0dc      	beq.n	100ac32 <ull_adv_reset+0x9a>
 100ac78:	f240 41f3 	movw	r1, #1267	; 0x4f3
 100ac7c:	4802      	ldr	r0, [pc, #8]	; (100ac88 <ull_adv_reset+0xf0>)
 100ac7e:	f7f8 fcff 	bl	1003680 <bt_ctlr_assert_handle>
 100ac82:	e7d6      	b.n	100ac32 <ull_adv_reset+0x9a>
 100ac84:	21002a60 	.word	0x21002a60
 100ac88:	01018890 	.word	0x01018890
 100ac8c:	0100a251 	.word	0x0100a251
 100ac90:	21002a7c 	.word	0x21002a7c

0100ac94 <ull_adv_handle_get>:
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
 100ac94:	4a04      	ldr	r2, [pc, #16]	; (100aca8 <ull_adv_handle_get+0x14>)
 100ac96:	4b05      	ldr	r3, [pc, #20]	; (100acac <ull_adv_handle_get+0x18>)
 100ac98:	1a80      	subs	r0, r0, r2
 100ac9a:	0880      	lsrs	r0, r0, #2
 100ac9c:	fba3 3000 	umull	r3, r0, r3, r0
}
 100aca0:	f3c0 004f 	ubfx	r0, r0, #1, #16
 100aca4:	4770      	bx	lr
 100aca6:	bf00      	nop
 100aca8:	21002a60 	.word	0x21002a60
 100acac:	08fb823f 	.word	0x08fb823f

0100acb0 <ull_adv_lll_handle_get>:
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
 100acb0:	4a04      	ldr	r2, [pc, #16]	; (100acc4 <ull_adv_lll_handle_get+0x14>)
 100acb2:	6800      	ldr	r0, [r0, #0]
 100acb4:	4b04      	ldr	r3, [pc, #16]	; (100acc8 <ull_adv_lll_handle_get+0x18>)
 100acb6:	1a80      	subs	r0, r0, r2
 100acb8:	0880      	lsrs	r0, r0, #2
 100acba:	fba3 3000 	umull	r3, r0, r3, r0
}
 100acbe:	f3c0 004f 	ubfx	r0, r0, #1, #16
 100acc2:	4770      	bx	lr
 100acc4:	21002a60 	.word	0x21002a60
 100acc8:	08fb823f 	.word	0x08fb823f

0100accc <ull_adv_is_enabled_get>:
	if (handle >= BT_CTLR_ADV_MAX) {
 100accc:	b938      	cbnz	r0, 100acde <ull_adv_is_enabled_get+0x12>
	if (!adv || !adv->is_enabled) {
 100acce:	4805      	ldr	r0, [pc, #20]	; (100ace4 <ull_adv_is_enabled_get+0x18>)
 100acd0:	f890 30cc 	ldrb.w	r3, [r0, #204]	; 0xcc
	return &ll_adv[handle];
 100acd4:	f013 0f01 	tst.w	r3, #1
 100acd8:	bf08      	it	eq
 100acda:	2000      	moveq	r0, #0
 100acdc:	4770      	bx	lr
		return NULL;
 100acde:	2000      	movs	r0, #0
}
 100ace0:	4770      	bx	lr
 100ace2:	bf00      	nop
 100ace4:	21002a60 	.word	0x21002a60

0100ace8 <ull_adv_is_enabled>:
	if (handle >= BT_CTLR_ADV_MAX) {
 100ace8:	b928      	cbnz	r0, 100acf6 <ull_adv_is_enabled+0xe>
	if (!adv || !adv->is_enabled) {
 100acea:	4b04      	ldr	r3, [pc, #16]	; (100acfc <ull_adv_is_enabled+0x14>)
 100acec:	f893 00cc 	ldrb.w	r0, [r3, #204]	; 0xcc
 100acf0:	f000 0001 	and.w	r0, r0, #1
 100acf4:	4770      	bx	lr
		return 0;
 100acf6:	2000      	movs	r0, #0
}
 100acf8:	4770      	bx	lr
 100acfa:	bf00      	nop
 100acfc:	21002a60 	.word	0x21002a60

0100ad00 <ull_adv_filter_pol_get>:
	if (handle >= BT_CTLR_ADV_MAX) {
 100ad00:	b950      	cbnz	r0, 100ad18 <ull_adv_filter_pol_get+0x18>
	if (!adv || !adv->is_enabled) {
 100ad02:	4b06      	ldr	r3, [pc, #24]	; (100ad1c <ull_adv_filter_pol_get+0x1c>)
 100ad04:	f893 00cc 	ldrb.w	r0, [r3, #204]	; 0xcc
 100ad08:	f010 0001 	ands.w	r0, r0, #1
 100ad0c:	d005      	beq.n	100ad1a <ull_adv_filter_pol_get+0x1a>
	return adv->lll.filter_policy;
 100ad0e:	f893 0029 	ldrb.w	r0, [r3, #41]	; 0x29
 100ad12:	f000 0003 	and.w	r0, r0, #3
 100ad16:	4770      	bx	lr
		return 0;
 100ad18:	2000      	movs	r0, #0
}
 100ad1a:	4770      	bx	lr
 100ad1c:	21002a60 	.word	0x21002a60

0100ad20 <ticker_cb>:
	return 0;
}

static void ticker_cb(u32_t ticks_at_expire, u32_t remainder, u16_t lazy,
		      void *param)
{
 100ad20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100ad24:	461c      	mov	r4, r3
 100ad26:	7c1b      	ldrb	r3, [r3, #16]
 100ad28:	4607      	mov	r7, r0
 100ad2a:	3301      	adds	r3, #1
 100ad2c:	b2db      	uxtb	r3, r3
 100ad2e:	4688      	mov	r8, r1
 100ad30:	4616      	mov	r6, r2
 100ad32:	7423      	strb	r3, [r4, #16]

	DEBUG_RADIO_PREPARE_O(1);

	/* Increment prepare reference count */
	ref = ull_ref_inc(&scan->ull);
	LL_ASSERT(ref);
 100ad34:	b30b      	cbz	r3, 100ad7a <ticker_cb+0x5a>
	p.lazy = lazy;
	p.param = &scan->lll;
	mfy.param = &p;

	/* Kick LLL prepare */
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100ad36:	2200      	movs	r2, #0
	p.ticks_at_expire = ticks_at_expire;
 100ad38:	4d16      	ldr	r5, [pc, #88]	; (100ad94 <ticker_cb+0x74>)
	mfy.param = &p;
 100ad3a:	4b17      	ldr	r3, [pc, #92]	; (100ad98 <ticker_cb+0x78>)
	p.param = &scan->lll;
 100ad3c:	f104 0c1c 	add.w	ip, r4, #28
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100ad40:	4611      	mov	r1, r2
 100ad42:	2001      	movs	r0, #1
	p.remainder = remainder;
 100ad44:	e9c5 7800 	strd	r7, r8, [r5]
	mfy.param = &p;
 100ad48:	609d      	str	r5, [r3, #8]
	p.lazy = lazy;
 100ad4a:	812e      	strh	r6, [r5, #8]
	p.param = &scan->lll;
 100ad4c:	f8c5 c00c 	str.w	ip, [r5, #12]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100ad50:	f7fb f8ba 	bl	1005ec8 <mayfly_enqueue>
			     0, &mfy);
	LL_ASSERT(!ret);
 100ad54:	b958      	cbnz	r0, 100ad6e <ticker_cb+0x4e>

#if defined(CONFIG_BT_CENTRAL) && defined(CONFIG_BT_CTLR_SCHED_ADVANCED)
	/* calc next group in us for the anchor where first connection event
	 * to be placed
	 */
	if (scan->lll.conn) {
 100ad56:	6a63      	ldr	r3, [r4, #36]	; 0x24
 100ad58:	b13b      	cbz	r3, 100ad6a <ticker_cb+0x4a>
			ull_sched_mfy_after_mstr_offset_get};
		u32_t retval;

		s_mfy_sched_after_mstr_offset_get.param = (void *)scan;

		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 100ad5a:	2201      	movs	r2, #1
		s_mfy_sched_after_mstr_offset_get.param = (void *)scan;
 100ad5c:	4b0f      	ldr	r3, [pc, #60]	; (100ad9c <ticker_cb+0x7c>)
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 100ad5e:	4610      	mov	r0, r2
 100ad60:	2102      	movs	r1, #2
		s_mfy_sched_after_mstr_offset_get.param = (void *)scan;
 100ad62:	609c      	str	r4, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 100ad64:	f7fb f8b0 	bl	1005ec8 <mayfly_enqueue>
				TICKER_USER_ID_ULL_LOW, 1,
				&s_mfy_sched_after_mstr_offset_get);
		LL_ASSERT(!retval);
 100ad68:	b968      	cbnz	r0, 100ad86 <ticker_cb+0x66>
	}
#endif /* CONFIG_BT_CENTRAL && CONFIG_BT_CTLR_SCHED_ADVANCED */

	DEBUG_RADIO_PREPARE_O(1);
}
 100ad6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	LL_ASSERT(!ret);
 100ad6e:	f44f 71ca 	mov.w	r1, #404	; 0x194
 100ad72:	480b      	ldr	r0, [pc, #44]	; (100ada0 <ticker_cb+0x80>)
 100ad74:	f7f8 fc84 	bl	1003680 <bt_ctlr_assert_handle>
 100ad78:	e7ed      	b.n	100ad56 <ticker_cb+0x36>
	LL_ASSERT(ref);
 100ad7a:	f44f 71c4 	mov.w	r1, #392	; 0x188
 100ad7e:	4808      	ldr	r0, [pc, #32]	; (100ada0 <ticker_cb+0x80>)
 100ad80:	f7f8 fc7e 	bl	1003680 <bt_ctlr_assert_handle>
 100ad84:	e7d7      	b.n	100ad36 <ticker_cb+0x16>
		LL_ASSERT(!retval);
 100ad86:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
}
 100ad8a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		LL_ASSERT(!retval);
 100ad8e:	4804      	ldr	r0, [pc, #16]	; (100ada0 <ticker_cb+0x80>)
 100ad90:	f7f8 bc76 	b.w	1003680 <bt_ctlr_assert_handle>
 100ad94:	21002bb4 	.word	0x21002bb4
 100ad98:	210002f4 	.word	0x210002f4
 100ad9c:	21000304 	.word	0x21000304
 100ada0:	010188e0 	.word	0x010188e0

0100ada4 <ull_scan_init>:
}
 100ada4:	2000      	movs	r0, #0
 100ada6:	4770      	bx	lr

0100ada8 <ull_scan_disable>:
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 100ada8:	2302      	movs	r3, #2
{
 100adaa:	b530      	push	{r4, r5, lr}
 100adac:	4605      	mov	r5, r0
 100adae:	b085      	sub	sp, #20
	mark = ull_disable_mark(scan);
 100adb0:	4608      	mov	r0, r1
{
 100adb2:	460c      	mov	r4, r1
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 100adb4:	9303      	str	r3, [sp, #12]
	mark = ull_disable_mark(scan);
 100adb6:	f7ff fa5f 	bl	100a278 <ull_disable_mark>
	LL_ASSERT(mark == scan);
 100adba:	4284      	cmp	r4, r0
 100adbc:	d004      	beq.n	100adc8 <ull_scan_disable+0x20>
 100adbe:	f240 1113 	movw	r1, #275	; 0x113
 100adc2:	481d      	ldr	r0, [pc, #116]	; (100ae38 <ull_scan_disable+0x90>)
 100adc4:	f7f8 fc5c 	bl	1003680 <bt_ctlr_assert_handle>
			  TICKER_ID_SCAN_BASE + handle,
 100adc8:	1d2a      	adds	r2, r5, #4
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
 100adca:	ad03      	add	r5, sp, #12
 100adcc:	2103      	movs	r1, #3
 100adce:	2000      	movs	r0, #0
 100add0:	4b1a      	ldr	r3, [pc, #104]	; (100ae3c <ull_scan_disable+0x94>)
 100add2:	b2d2      	uxtb	r2, r2
 100add4:	9500      	str	r5, [sp, #0]
 100add6:	f7fc faa9 	bl	100732c <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
 100adda:	4629      	mov	r1, r5
 100addc:	f7ff fa3e 	bl	100a25c <ull_ticker_status_take>
	if (ret) {
 100ade0:	b9d0      	cbnz	r0, 100ae18 <ull_scan_disable+0x70>
	ret = ull_disable(&scan->lll);
 100ade2:	f104 001c 	add.w	r0, r4, #28
 100ade6:	f7ff fa83 	bl	100a2f0 <ull_disable>
	LL_ASSERT(!ret);
 100adea:	b978      	cbnz	r0, 100ae0c <ull_scan_disable+0x64>
	mark = ull_disable_unmark(scan);
 100adec:	4620      	mov	r0, r4
 100adee:	f7ff fa4d 	bl	100a28c <ull_disable_unmark>
	LL_ASSERT(mark == scan);
 100adf2:	4284      	cmp	r4, r0
 100adf4:	d007      	beq.n	100ae06 <ull_scan_disable+0x5e>
 100adf6:	f240 1125 	movw	r1, #293	; 0x125
 100adfa:	480f      	ldr	r0, [pc, #60]	; (100ae38 <ull_scan_disable+0x90>)
 100adfc:	f7f8 fc40 	bl	1003680 <bt_ctlr_assert_handle>
	return 0;
 100ae00:	2000      	movs	r0, #0
}
 100ae02:	b005      	add	sp, #20
 100ae04:	bd30      	pop	{r4, r5, pc}
	return 0;
 100ae06:	2000      	movs	r0, #0
}
 100ae08:	b005      	add	sp, #20
 100ae0a:	bd30      	pop	{r4, r5, pc}
	LL_ASSERT(!ret);
 100ae0c:	f44f 7191 	mov.w	r1, #290	; 0x122
 100ae10:	4809      	ldr	r0, [pc, #36]	; (100ae38 <ull_scan_disable+0x90>)
 100ae12:	f7f8 fc35 	bl	1003680 <bt_ctlr_assert_handle>
 100ae16:	e7e9      	b.n	100adec <ull_scan_disable+0x44>
		mark = ull_disable_unmark(scan);
 100ae18:	4620      	mov	r0, r4
 100ae1a:	f7ff fa37 	bl	100a28c <ull_disable_unmark>
		LL_ASSERT(mark == scan);
 100ae1e:	4284      	cmp	r4, r0
 100ae20:	d007      	beq.n	100ae32 <ull_scan_disable+0x8a>
 100ae22:	f44f 718e 	mov.w	r1, #284	; 0x11c
 100ae26:	4804      	ldr	r0, [pc, #16]	; (100ae38 <ull_scan_disable+0x90>)
 100ae28:	f7f8 fc2a 	bl	1003680 <bt_ctlr_assert_handle>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100ae2c:	200c      	movs	r0, #12
}
 100ae2e:	b005      	add	sp, #20
 100ae30:	bd30      	pop	{r4, r5, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100ae32:	200c      	movs	r0, #12
}
 100ae34:	b005      	add	sp, #20
 100ae36:	bd30      	pop	{r4, r5, pc}
 100ae38:	010188e0 	.word	0x010188e0
 100ae3c:	0100a251 	.word	0x0100a251

0100ae40 <disable.constprop.0>:

static u8_t disable(u16_t handle)
 100ae40:	b538      	push	{r3, r4, r5, lr}
	if (!scan || !scan->is_enabled) {
 100ae42:	4c0e      	ldr	r4, [pc, #56]	; (100ae7c <disable.constprop.0+0x3c>)
 100ae44:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 100ae48:	07db      	lsls	r3, r3, #31
 100ae4a:	d501      	bpl.n	100ae50 <disable.constprop.0+0x10>
	if (!scan) {
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

#if defined(CONFIG_BT_CENTRAL)
	if (scan->lll.conn) {
 100ae4c:	6a60      	ldr	r0, [r4, #36]	; 0x24
 100ae4e:	b110      	cbz	r0, 100ae56 <disable.constprop.0+0x16>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100ae50:	250c      	movs	r5, #12
		ull_filter_adv_scan_state_cb(0);
	}
#endif

	return 0;
}
 100ae52:	4628      	mov	r0, r5
 100ae54:	bd38      	pop	{r3, r4, r5, pc}
	ret = ull_scan_disable(handle, scan);
 100ae56:	4621      	mov	r1, r4
 100ae58:	f7ff ffa6 	bl	100ada8 <ull_scan_disable>
	if (ret) {
 100ae5c:	4605      	mov	r5, r0
 100ae5e:	2800      	cmp	r0, #0
 100ae60:	d1f7      	bne.n	100ae52 <disable.constprop.0+0x12>
	scan->is_enabled = 0U;
 100ae62:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 100ae66:	f360 0300 	bfi	r3, r0, #0, #1
 100ae6a:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
	if (!ull_adv_is_enabled_get(0))
 100ae6e:	f7ff ff2d 	bl	100accc <ull_adv_is_enabled_get>
 100ae72:	2800      	cmp	r0, #0
 100ae74:	d1ed      	bne.n	100ae52 <disable.constprop.0+0x12>
		ull_filter_adv_scan_state_cb(0);
 100ae76:	f004 f845 	bl	100ef04 <ull_filter_adv_scan_state_cb>
 100ae7a:	e7ea      	b.n	100ae52 <disable.constprop.0+0x12>
 100ae7c:	21002b68 	.word	0x21002b68

0100ae80 <ll_scan_enable>:
	if (!enable) {
 100ae80:	b358      	cbz	r0, 100aeda <ll_scan_enable+0x5a>
{
 100ae82:	b510      	push	{r4, lr}
	if (!scan || scan->is_enabled) {
 100ae84:	4c1f      	ldr	r4, [pc, #124]	; (100af04 <ll_scan_enable+0x84>)
 100ae86:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 100ae8a:	f013 0101 	ands.w	r1, r3, #1
 100ae8e:	d136      	bne.n	100aefe <ll_scan_enable+0x7e>
	if (scan->own_addr_type & 0x1) {
 100ae90:	079a      	lsls	r2, r3, #30
 100ae92:	d506      	bpl.n	100aea2 <ll_scan_enable+0x22>
		if (!mem_nz(ll_addr_get(1, NULL), BDADDR_SIZE)) {
 100ae94:	2001      	movs	r0, #1
 100ae96:	f7fc fa89 	bl	10073ac <ll_addr_get>
 100ae9a:	2106      	movs	r1, #6
 100ae9c:	f7fa ff86 	bl	1005dac <mem_nz>
 100aea0:	b1e8      	cbz	r0, 100aede <ll_scan_enable+0x5e>
	ull_filter_scan_update(lll->filter_policy);
 100aea2:	f894 0032 	ldrb.w	r0, [r4, #50]	; 0x32
 100aea6:	f3c0 00c1 	ubfx	r0, r0, #3, #2
 100aeaa:	f004 f86f 	bl	100ef8c <ull_filter_scan_update>
	lll->rl_idx = FILTER_IDX_NONE;
 100aeae:	21ff      	movs	r1, #255	; 0xff
	lll->rpa_gen = 0;
 100aeb0:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
	if ((lll->type & 0x1) &&
 100aeb4:	f894 2032 	ldrb.w	r2, [r4, #50]	; 0x32
	lll->rpa_gen = 0;
 100aeb8:	f36f 0300 	bfc	r3, #0, #1
 100aebc:	f884 3033 	strb.w	r3, [r4, #51]	; 0x33
	if ((lll->type & 0x1) &&
 100aec0:	09d3      	lsrs	r3, r2, #7
	lll->rl_idx = FILTER_IDX_NONE;
 100aec2:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
	if ((lll->type & 0x1) &&
 100aec6:	d003      	beq.n	100aed0 <ll_scan_enable+0x50>
 100aec8:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 100aecc:	075b      	lsls	r3, r3, #29
 100aece:	d408      	bmi.n	100aee2 <ll_scan_enable+0x62>
}
 100aed0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return ull_scan_enable(scan);
 100aed4:	480b      	ldr	r0, [pc, #44]	; (100af04 <ll_scan_enable+0x84>)
 100aed6:	f7f5 bdcf 	b.w	1000a78 <ull_scan_enable>
		return disable(0);
 100aeda:	f7ff bfb1 	b.w	100ae40 <disable.constprop.0>
			return BT_HCI_ERR_INVALID_PARAM;
 100aede:	2012      	movs	r0, #18
}
 100aee0:	bd10      	pop	{r4, pc}
		ull_filter_rpa_update(false);
 100aee2:	2000      	movs	r0, #0
 100aee4:	f004 f8f6 	bl	100f0d4 <ull_filter_rpa_update>
		lll->rpa_gen = 1;
 100aee8:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
	return ull_scan_enable(scan);
 100aeec:	4805      	ldr	r0, [pc, #20]	; (100af04 <ll_scan_enable+0x84>)
		lll->rpa_gen = 1;
 100aeee:	f043 0301 	orr.w	r3, r3, #1
 100aef2:	f884 3033 	strb.w	r3, [r4, #51]	; 0x33
}
 100aef6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return ull_scan_enable(scan);
 100aefa:	f7f5 bdbd 	b.w	1000a78 <ull_scan_enable>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100aefe:	200c      	movs	r0, #12
}
 100af00:	bd10      	pop	{r4, pc}
 100af02:	bf00      	nop
 100af04:	21002b68 	.word	0x21002b68

0100af08 <ull_scan_reset>:
{
 100af08:	b508      	push	{r3, lr}
		(void)disable(handle);
 100af0a:	f7ff ff99 	bl	100ae40 <disable.constprop.0>
}
 100af0e:	2000      	movs	r0, #0
 100af10:	bd08      	pop	{r3, pc}
 100af12:	bf00      	nop

0100af14 <ull_scan_handle_get>:
	return ((u8_t *)scan - (u8_t *)ll_scan) / sizeof(*scan);
 100af14:	4a04      	ldr	r2, [pc, #16]	; (100af28 <ull_scan_handle_get+0x14>)
 100af16:	4b05      	ldr	r3, [pc, #20]	; (100af2c <ull_scan_handle_get+0x18>)
 100af18:	1a80      	subs	r0, r0, r2
 100af1a:	0880      	lsrs	r0, r0, #2
 100af1c:	fba3 3000 	umull	r3, r0, r3, r0
}
 100af20:	f3c0 004f 	ubfx	r0, r0, #1, #16
 100af24:	4770      	bx	lr
 100af26:	bf00      	nop
 100af28:	21002b68 	.word	0x21002b68
 100af2c:	1af286bd 	.word	0x1af286bd

0100af30 <ull_scan_lll_handle_get>:
	return ((u8_t *)scan - (u8_t *)ll_scan) / sizeof(*scan);
 100af30:	4a04      	ldr	r2, [pc, #16]	; (100af44 <ull_scan_lll_handle_get+0x14>)
 100af32:	6800      	ldr	r0, [r0, #0]
 100af34:	4b04      	ldr	r3, [pc, #16]	; (100af48 <ull_scan_lll_handle_get+0x18>)
 100af36:	1a80      	subs	r0, r0, r2
 100af38:	0880      	lsrs	r0, r0, #2
 100af3a:	fba3 3000 	umull	r3, r0, r3, r0
}
 100af3e:	f3c0 004f 	ubfx	r0, r0, #1, #16
 100af42:	4770      	bx	lr
 100af44:	21002b68 	.word	0x21002b68
 100af48:	1af286bd 	.word	0x1af286bd

0100af4c <ull_scan_is_enabled_get>:
	if (handle >= BT_CTLR_SCAN_MAX) {
 100af4c:	b938      	cbnz	r0, 100af5e <ull_scan_is_enabled_get+0x12>
	if (!scan || !scan->is_enabled) {
 100af4e:	4805      	ldr	r0, [pc, #20]	; (100af64 <ull_scan_is_enabled_get+0x18>)
 100af50:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
	return &ll_scan[handle];
 100af54:	f013 0f01 	tst.w	r3, #1
 100af58:	bf08      	it	eq
 100af5a:	2000      	moveq	r0, #0
 100af5c:	4770      	bx	lr
		return NULL;
 100af5e:	2000      	movs	r0, #0
}
 100af60:	4770      	bx	lr
 100af62:	bf00      	nop
 100af64:	21002b68 	.word	0x21002b68

0100af68 <ull_scan_is_disabled_get>:
	if (handle >= BT_CTLR_SCAN_MAX) {
 100af68:	b938      	cbnz	r0, 100af7a <ull_scan_is_disabled_get+0x12>
	if (!scan || scan->is_enabled) {
 100af6a:	4805      	ldr	r0, [pc, #20]	; (100af80 <ull_scan_is_disabled_get+0x18>)
 100af6c:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
	return &ll_scan[handle];
 100af70:	f013 0f01 	tst.w	r3, #1
 100af74:	bf18      	it	ne
 100af76:	2000      	movne	r0, #0
 100af78:	4770      	bx	lr
		return NULL;
 100af7a:	2000      	movs	r0, #0
}
 100af7c:	4770      	bx	lr
 100af7e:	bf00      	nop
 100af80:	21002b68 	.word	0x21002b68

0100af84 <ull_scan_is_enabled>:
	if (handle >= BT_CTLR_SCAN_MAX) {
 100af84:	b988      	cbnz	r0, 100afaa <ull_scan_is_enabled+0x26>
	if (!scan || !scan->is_enabled) {
 100af86:	4a0a      	ldr	r2, [pc, #40]	; (100afb0 <ull_scan_is_enabled+0x2c>)
 100af88:	f892 3048 	ldrb.w	r3, [r2, #72]	; 0x48
 100af8c:	f013 0001 	ands.w	r0, r3, #1
 100af90:	d00c      	beq.n	100afac <ull_scan_is_enabled+0x28>
	return (((u32_t)scan->is_enabled << scan->lll.type) |
 100af92:	f892 0032 	ldrb.w	r0, [r2, #50]	; 0x32
		(scan->lll.conn ? BIT(2) : 0) |
 100af96:	6a52      	ldr	r2, [r2, #36]	; 0x24
	return (((u32_t)scan->is_enabled << scan->lll.type) |
 100af98:	f003 0301 	and.w	r3, r3, #1
 100af9c:	09c0      	lsrs	r0, r0, #7
 100af9e:	fa03 f000 	lsl.w	r0, r3, r0
		(scan->lll.conn ? BIT(2) : 0) |
 100afa2:	b11a      	cbz	r2, 100afac <ull_scan_is_enabled+0x28>
 100afa4:	f040 0004 	orr.w	r0, r0, #4
 100afa8:	4770      	bx	lr
		return 0;
 100afaa:	2000      	movs	r0, #0
}
 100afac:	4770      	bx	lr
 100afae:	bf00      	nop
 100afb0:	21002b68 	.word	0x21002b68

0100afb4 <ull_scan_filter_pol_get>:
	if (handle >= BT_CTLR_SCAN_MAX) {
 100afb4:	b950      	cbnz	r0, 100afcc <ull_scan_filter_pol_get+0x18>
	if (!scan || !scan->is_enabled) {
 100afb6:	4b06      	ldr	r3, [pc, #24]	; (100afd0 <ull_scan_filter_pol_get+0x1c>)
 100afb8:	f893 0048 	ldrb.w	r0, [r3, #72]	; 0x48
 100afbc:	f010 0001 	ands.w	r0, r0, #1
 100afc0:	d005      	beq.n	100afce <ull_scan_filter_pol_get+0x1a>
	return scan->lll.filter_policy;
 100afc2:	f893 0032 	ldrb.w	r0, [r3, #50]	; 0x32
 100afc6:	f3c0 00c1 	ubfx	r0, r0, #3, #2
 100afca:	4770      	bx	lr
		return 0;
 100afcc:	2000      	movs	r0, #0
}
 100afce:	4770      	bx	lr
 100afd0:	21002b68 	.word	0x21002b68

0100afd4 <tx_ull_dequeue>:
	if (!conn->tx_ctrl && (conn->tx_head != conn->tx_data)) {
 100afd4:	f8d0 21b4 	ldr.w	r2, [r0, #436]	; 0x1b4
{
 100afd8:	4603      	mov	r3, r0
 100afda:	b410      	push	{r4}
 100afdc:	4608      	mov	r0, r1
	if (!conn->tx_ctrl && (conn->tx_head != conn->tx_data)) {
 100afde:	b172      	cbz	r2, 100affe <tx_ull_dequeue+0x2a>
	if (conn->tx_head == conn->tx_ctrl) {
 100afe0:	f8d3 11b0 	ldr.w	r1, [r3, #432]	; 0x1b0
 100afe4:	428a      	cmp	r2, r1
 100afe6:	d02b      	beq.n	100b040 <tx_ull_dequeue+0x6c>
 100afe8:	f8d3 21bc 	ldr.w	r2, [r3, #444]	; 0x1bc
		if (conn->tx_head == conn->tx_data) {
 100afec:	4291      	cmp	r1, r2
 100afee:	d01a      	beq.n	100b026 <tx_ull_dequeue+0x52>
		tx->next = NULL;
 100aff0:	2200      	movs	r2, #0
		conn->tx_head = conn->tx_head->next;
 100aff2:	6809      	ldr	r1, [r1, #0]
}
 100aff4:	bc10      	pop	{r4}
		conn->tx_head = conn->tx_head->next;
 100aff6:	f8c3 11b0 	str.w	r1, [r3, #432]	; 0x1b0
		tx->next = NULL;
 100affa:	6002      	str	r2, [r0, #0]
}
 100affc:	4770      	bx	lr
	if (!conn->tx_ctrl && (conn->tx_head != conn->tx_data)) {
 100affe:	f8d3 21b0 	ldr.w	r2, [r3, #432]	; 0x1b0
 100b002:	f8d3 11bc 	ldr.w	r1, [r3, #444]	; 0x1bc
 100b006:	428a      	cmp	r2, r1
 100b008:	d025      	beq.n	100b056 <tx_ull_dequeue+0x82>
		if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
 100b00a:	7911      	ldrb	r1, [r2, #4]
 100b00c:	f001 0103 	and.w	r1, r1, #3
 100b010:	2903      	cmp	r1, #3
 100b012:	d00e      	beq.n	100b032 <tx_ull_dequeue+0x5e>
		conn->tx_head = conn->tx_head->next;
 100b014:	6812      	ldr	r2, [r2, #0]
 100b016:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
			conn->tx_ctrl = NULL;
 100b01a:	2200      	movs	r2, #0
			conn->tx_ctrl_last = NULL;
 100b01c:	e9c3 226d 	strd	r2, r2, [r3, #436]	; 0x1b4
}
 100b020:	bc10      	pop	{r4}
		tx->next = tx;
 100b022:	6000      	str	r0, [r0, #0]
}
 100b024:	4770      	bx	lr
 100b026:	4611      	mov	r1, r2
			conn->tx_data = conn->tx_data->next;
 100b028:	680c      	ldr	r4, [r1, #0]
 100b02a:	4611      	mov	r1, r2
 100b02c:	f8c3 41bc 	str.w	r4, [r3, #444]	; 0x1bc
 100b030:	e7de      	b.n	100aff0 <tx_ull_dequeue+0x1c>
		    ((pdu_data_tx->llctrl.opcode !=
 100b032:	79d1      	ldrb	r1, [r2, #7]
		if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
 100b034:	2903      	cmp	r1, #3
 100b036:	d001      	beq.n	100b03c <tx_ull_dequeue+0x68>
		      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
 100b038:	290a      	cmp	r1, #10
 100b03a:	d1eb      	bne.n	100b014 <tx_ull_dequeue+0x40>
 100b03c:	4611      	mov	r1, r2
 100b03e:	e7d7      	b.n	100aff0 <tx_ull_dequeue+0x1c>
 100b040:	f8d3 41b8 	ldr.w	r4, [r3, #440]	; 0x1b8
		conn->tx_head = conn->tx_head->next;
 100b044:	6809      	ldr	r1, [r1, #0]
		if (conn->tx_ctrl == conn->tx_ctrl_last) {
 100b046:	4294      	cmp	r4, r2
		conn->tx_head = conn->tx_head->next;
 100b048:	f8c3 11b0 	str.w	r1, [r3, #432]	; 0x1b0
			conn->tx_ctrl = conn->tx_head;
 100b04c:	bf18      	it	ne
 100b04e:	f8c3 11b4 	strne.w	r1, [r3, #436]	; 0x1b4
		if (conn->tx_ctrl == conn->tx_ctrl_last) {
 100b052:	d1e5      	bne.n	100b020 <tx_ull_dequeue+0x4c>
 100b054:	e7e1      	b.n	100b01a <tx_ull_dequeue+0x46>
	if (conn->tx_head == conn->tx_ctrl) {
 100b056:	2a00      	cmp	r2, #0
 100b058:	d1e6      	bne.n	100b028 <tx_ull_dequeue+0x54>
 100b05a:	4611      	mov	r1, r2
 100b05c:	f8d3 41b8 	ldr.w	r4, [r3, #440]	; 0x1b8
 100b060:	e7f0      	b.n	100b044 <tx_ull_dequeue+0x70>
 100b062:	bf00      	nop

0100b064 <calc_eff_time>:
	u16_t time = PKT_US(max_octets, phy);
 100b064:	074b      	lsls	r3, r1, #29
 100b066:	d50c      	bpl.n	100b082 <calc_eff_time+0x1e>
 100b068:	0181      	lsls	r1, r0, #6
	eff_time = MIN(eff_time, default_time);
 100b06a:	f501 7074 	add.w	r0, r1, #976	; 0x3d0
 100b06e:	4290      	cmp	r0, r2
 100b070:	bf28      	it	cs
 100b072:	4610      	movcs	r0, r2
	eff_time = MAX(eff_time, PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, phy));
 100b074:	f44f 6329 	mov.w	r3, #2704	; 0xa90
 100b078:	4298      	cmp	r0, r3
 100b07a:	bf38      	it	cc
 100b07c:	4618      	movcc	r0, r3
}
 100b07e:	b280      	uxth	r0, r0
 100b080:	4770      	bx	lr
{
 100b082:	b430      	push	{r4, r5}
	u16_t time = PKT_US(max_octets, phy);
 100b084:	f001 0503 	and.w	r5, r1, #3
 100b088:	f100 040d 	add.w	r4, r0, #13
 100b08c:	442c      	add	r4, r5
 100b08e:	f3c1 0140 	ubfx	r1, r1, #1, #1
 100b092:	00e4      	lsls	r4, r4, #3
 100b094:	40cc      	lsrs	r4, r1
	eff_time = MAX(PDU_DC_PAYLOAD_TIME_MIN, time);
 100b096:	b2a3      	uxth	r3, r4
 100b098:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
 100b09c:	bf38      	it	cc
 100b09e:	f44f 73a4 	movcc.w	r3, #328	; 0x148
	eff_time = MIN(eff_time, default_time);
 100b0a2:	429a      	cmp	r2, r3
 100b0a4:	bf28      	it	cs
 100b0a6:	461a      	movcs	r2, r3
	eff_time = MAX(eff_time, PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, phy));
 100b0a8:	f105 0328 	add.w	r3, r5, #40	; 0x28
 100b0ac:	00db      	lsls	r3, r3, #3
 100b0ae:	40cb      	lsrs	r3, r1
 100b0b0:	429a      	cmp	r2, r3
	eff_time = MIN(eff_time, default_time);
 100b0b2:	4610      	mov	r0, r2
}
 100b0b4:	bc30      	pop	{r4, r5}
	eff_time = MAX(eff_time, PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, phy));
 100b0b6:	bf38      	it	cc
 100b0b8:	4618      	movcc	r0, r3
}
 100b0ba:	b280      	uxth	r0, r0
 100b0bc:	4770      	bx	lr
 100b0be:	bf00      	nop

0100b0c0 <ticker_update_latency_cancel_op_cb>:
{
 100b0c0:	b510      	push	{r4, lr}
 100b0c2:	460c      	mov	r4, r1
	LL_ASSERT(ticker_status == TICKER_STATUS_SUCCESS);
 100b0c4:	b930      	cbnz	r0, 100b0d4 <ticker_update_latency_cancel_op_cb+0x14>
	conn->slave.latency_cancel = 0U;
 100b0c6:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
 100b0ca:	f36f 0341 	bfc	r3, #1, #1
 100b0ce:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
}
 100b0d2:	bd10      	pop	{r4, pc}
	LL_ASSERT(ticker_status == TICKER_STATUS_SUCCESS);
 100b0d4:	f44f 61cb 	mov.w	r1, #1624	; 0x658
 100b0d8:	4804      	ldr	r0, [pc, #16]	; (100b0ec <ticker_update_latency_cancel_op_cb+0x2c>)
 100b0da:	f7f8 fad1 	bl	1003680 <bt_ctlr_assert_handle>
	conn->slave.latency_cancel = 0U;
 100b0de:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
 100b0e2:	f36f 0341 	bfc	r3, #1, #1
 100b0e6:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
}
 100b0ea:	bd10      	pop	{r4, pc}
 100b0ec:	01018934 	.word	0x01018934

0100b0f0 <ctrl_tx_pause_enqueue>:
{
 100b0f0:	b538      	push	{r3, r4, r5, lr}
	    conn->tx_head &&
 100b0f2:	f8d0 31b0 	ldr.w	r3, [r0, #432]	; 0x1b0
{
 100b0f6:	4604      	mov	r4, r0
 100b0f8:	460d      	mov	r5, r1
	if (
 100b0fa:	b11b      	cbz	r3, 100b104 <ctrl_tx_pause_enqueue+0x14>
	    !conn->llcp_enc.pause_tx &&
 100b0fc:	f890 1152 	ldrb.w	r1, [r0, #338]	; 0x152
	    conn->tx_head &&
 100b100:	0788      	lsls	r0, r1, #30
 100b102:	d50d      	bpl.n	100b120 <ctrl_tx_pause_enqueue+0x30>
		if (!conn->tx_ctrl) {
 100b104:	f8d4 11b4 	ldr.w	r1, [r4, #436]	; 0x1b4
 100b108:	b319      	cbz	r1, 100b152 <ctrl_tx_pause_enqueue+0x62>
			LL_ASSERT(!pause);
 100b10a:	bb62      	cbnz	r2, 100b166 <ctrl_tx_pause_enqueue+0x76>
	tx->next = conn->tx_ctrl_last->next;
 100b10c:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 100b110:	681a      	ldr	r2, [r3, #0]
 100b112:	602a      	str	r2, [r5, #0]
	conn->tx_ctrl_last->next = tx;
 100b114:	601d      	str	r5, [r3, #0]
	conn->tx_ctrl_last = tx;
 100b116:	f8c4 51b8 	str.w	r5, [r4, #440]	; 0x1b8
 100b11a:	682b      	ldr	r3, [r5, #0]
	if (!tx->next) {
 100b11c:	b1b3      	cbz	r3, 100b14c <ctrl_tx_pause_enqueue+0x5c>
}
 100b11e:	bd38      	pop	{r3, r4, r5, pc}
	    !conn->llcp_phy.pause_tx &&
 100b120:	f894 11ab 	ldrb.w	r1, [r4, #427]	; 0x1ab
 100b124:	07c9      	lsls	r1, r1, #31
 100b126:	d4ed      	bmi.n	100b104 <ctrl_tx_pause_enqueue+0x14>
		if (conn->tx_head == conn->tx_data) {
 100b128:	f8d4 11bc 	ldr.w	r1, [r4, #444]	; 0x1bc
 100b12c:	428b      	cmp	r3, r1
			conn->tx_data = conn->tx_data->next;
 100b12e:	bf04      	itt	eq
 100b130:	6819      	ldreq	r1, [r3, #0]
 100b132:	f8c4 11bc 	streq.w	r1, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 100b136:	f8d4 11b4 	ldr.w	r1, [r4, #436]	; 0x1b4
 100b13a:	b1d1      	cbz	r1, 100b172 <ctrl_tx_pause_enqueue+0x82>
			LL_ASSERT(!pause);
 100b13c:	2a00      	cmp	r2, #0
 100b13e:	d0e5      	beq.n	100b10c <ctrl_tx_pause_enqueue+0x1c>
 100b140:	f240 716a 	movw	r1, #1898	; 0x76a
 100b144:	4810      	ldr	r0, [pc, #64]	; (100b188 <ctrl_tx_pause_enqueue+0x98>)
 100b146:	f7f8 fa9b 	bl	1003680 <bt_ctlr_assert_handle>
	tx->next = conn->tx_ctrl_last->next;
 100b14a:	e7df      	b.n	100b10c <ctrl_tx_pause_enqueue+0x1c>
		conn->tx_data_last = tx;
 100b14c:	f8c4 51c0 	str.w	r5, [r4, #448]	; 0x1c0
}
 100b150:	bd38      	pop	{r3, r4, r5, pc}
			tx->next = conn->tx_head;
 100b152:	602b      	str	r3, [r5, #0]
			conn->tx_head = tx;
 100b154:	f8c4 51b0 	str.w	r5, [r4, #432]	; 0x1b0
			if (!pause) {
 100b158:	2a00      	cmp	r2, #0
 100b15a:	d1df      	bne.n	100b11c <ctrl_tx_pause_enqueue+0x2c>
				conn->tx_ctrl_last = tx;
 100b15c:	e9c4 556d 	strd	r5, r5, [r4, #436]	; 0x1b4
	if (!tx->next) {
 100b160:	2b00      	cmp	r3, #0
 100b162:	d1dc      	bne.n	100b11e <ctrl_tx_pause_enqueue+0x2e>
 100b164:	e7f2      	b.n	100b14c <ctrl_tx_pause_enqueue+0x5c>
			LL_ASSERT(!pause);
 100b166:	f240 717c 	movw	r1, #1916	; 0x77c
 100b16a:	4807      	ldr	r0, [pc, #28]	; (100b188 <ctrl_tx_pause_enqueue+0x98>)
 100b16c:	f7f8 fa88 	bl	1003680 <bt_ctlr_assert_handle>
 100b170:	e7cc      	b.n	100b10c <ctrl_tx_pause_enqueue+0x1c>
			tx->next = conn->tx_head->next;
 100b172:	6819      	ldr	r1, [r3, #0]
 100b174:	6029      	str	r1, [r5, #0]
			conn->tx_head->next = tx;
 100b176:	601d      	str	r5, [r3, #0]
			if (!pause) {
 100b178:	2a00      	cmp	r2, #0
 100b17a:	d1ce      	bne.n	100b11a <ctrl_tx_pause_enqueue+0x2a>
				conn->tx_ctrl_last = tx;
 100b17c:	e9c4 556d 	strd	r5, r5, [r4, #436]	; 0x1b4
 100b180:	682b      	ldr	r3, [r5, #0]
	if (!tx->next) {
 100b182:	2b00      	cmp	r3, #0
 100b184:	d1cb      	bne.n	100b11e <ctrl_tx_pause_enqueue+0x2e>
 100b186:	e7e1      	b.n	100b14c <ctrl_tx_pause_enqueue+0x5c>
 100b188:	01018934 	.word	0x01018934

0100b18c <init_reset>:
{
 100b18c:	b538      	push	{r3, r4, r5, lr}
	mem_init(conn_pool, sizeof(struct ll_conn),
 100b18e:	2210      	movs	r2, #16
 100b190:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100b194:	4b12      	ldr	r3, [pc, #72]	; (100b1e0 <init_reset+0x54>)
 100b196:	4813      	ldr	r0, [pc, #76]	; (100b1e4 <init_reset+0x58>)
 100b198:	f7fa fd90 	bl	1005cbc <mem_init>
	mem_init(mem_conn_tx.pool, CONN_TX_BUF_SIZE, CONFIG_BT_CTLR_TX_BUFFERS,
 100b19c:	4b12      	ldr	r3, [pc, #72]	; (100b1e8 <init_reset+0x5c>)
 100b19e:	220a      	movs	r2, #10
 100b1a0:	1d18      	adds	r0, r3, #4
 100b1a2:	f44f 7182 	mov.w	r1, #260	; 0x104
 100b1a6:	f7fa fd89 	bl	1005cbc <mem_init>
	mem_init(mem_conn_tx_ctrl.pool, CONN_TX_CTRL_BUF_SIZE,
 100b1aa:	2204      	movs	r2, #4
 100b1ac:	4b0f      	ldr	r3, [pc, #60]	; (100b1ec <init_reset+0x60>)
 100b1ae:	2120      	movs	r1, #32
 100b1b0:	1898      	adds	r0, r3, r2
 100b1b2:	f7fa fd83 	bl	1005cbc <mem_init>
	mem_init(mem_link_tx.pool, sizeof(memq_link_t),
 100b1b6:	4b0e      	ldr	r3, [pc, #56]	; (100b1f0 <init_reset+0x64>)
	default_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
 100b1b8:	251b      	movs	r5, #27
	mem_init(mem_link_tx.pool, sizeof(memq_link_t),
 100b1ba:	1d18      	adds	r0, r3, #4
 100b1bc:	220e      	movs	r2, #14
 100b1be:	2108      	movs	r1, #8
 100b1c0:	f7fa fd7c 	bl	1005cbc <mem_init>
	default_phy_tx |= BIT(2);
 100b1c4:	2307      	movs	r3, #7
	default_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M);
 100b1c6:	f44f 74a4 	mov.w	r4, #328	; 0x148
	default_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
 100b1ca:	4a0a      	ldr	r2, [pc, #40]	; (100b1f4 <init_reset+0x68>)
	default_phy_tx |= BIT(2);
 100b1cc:	490a      	ldr	r1, [pc, #40]	; (100b1f8 <init_reset+0x6c>)
	default_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
 100b1ce:	8015      	strh	r5, [r2, #0]
	default_phy_rx |= BIT(2);
 100b1d0:	4a0a      	ldr	r2, [pc, #40]	; (100b1fc <init_reset+0x70>)
	default_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M);
 100b1d2:	480b      	ldr	r0, [pc, #44]	; (100b200 <init_reset+0x74>)
	default_phy_tx |= BIT(2);
 100b1d4:	700b      	strb	r3, [r1, #0]
	default_phy_rx |= BIT(2);
 100b1d6:	7013      	strb	r3, [r2, #0]
	default_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M);
 100b1d8:	8004      	strh	r4, [r0, #0]
}
 100b1da:	2000      	movs	r0, #0
 100b1dc:	bd38      	pop	{r3, r4, r5, pc}
 100b1de:	bf00      	nop
 100b1e0:	21002bcc 	.word	0x21002bcc
 100b1e4:	21002bd0 	.word	0x21002bd0
 100b1e8:	2100485c 	.word	0x2100485c
 100b1ec:	21005288 	.word	0x21005288
 100b1f0:	2100530c 	.word	0x2100530c
 100b1f4:	2100805a 	.word	0x2100805a
 100b1f8:	210080c5 	.word	0x210080c5
 100b1fc:	210080c4 	.word	0x210080c4
 100b200:	2100805c 	.word	0x2100805c

0100b204 <tx_lll_flush>:
{
 100b204:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 100b208:	4605      	mov	r5, r0
	struct ll_conn *conn = (void *)HDR_LLL2EVT(param);
 100b20a:	f8d0 8000 	ldr.w	r8, [r0]
{
 100b20e:	b083      	sub	sp, #12
	return mem_index_get(conn, conn_pool, sizeof(struct ll_conn));
 100b210:	f44f 72e4 	mov.w	r2, #456	; 0x1c8
 100b214:	492b      	ldr	r1, [pc, #172]	; (100b2c4 <tx_lll_flush+0xc0>)
 100b216:	4640      	mov	r0, r8
 100b218:	f7fa fdb4 	bl	1005d84 <mem_index_get>
	link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
 100b21c:	f105 064c 	add.w	r6, r5, #76	; 0x4c
	lll_conn_flush(handle, lll);
 100b220:	4629      	mov	r1, r5
 100b222:	f006 fa55 	bl	10116d0 <lll_conn_flush>
	link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
 100b226:	4631      	mov	r1, r6
 100b228:	6d28      	ldr	r0, [r5, #80]	; 0x50
 100b22a:	aa01      	add	r2, sp, #4
 100b22c:	f7fa fde8 	bl	1005e00 <memq_dequeue>
	while (link) {
 100b230:	b338      	cbz	r0, 100b282 <tx_lll_flush+0x7e>
		lll_tx->handle = 0xFFFF;
 100b232:	f64f 77ff 	movw	r7, #65535	; 0xffff
 100b236:	4c24      	ldr	r4, [pc, #144]	; (100b2c8 <tx_lll_flush+0xc4>)
	*mem = (void *)(fifo + last * size); /* preceding buffer */
 100b238:	f104 0904 	add.w	r9, r4, #4
		idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
 100b23c:	78e2      	ldrb	r2, [r4, #3]
	if (last == count) {
 100b23e:	7861      	ldrb	r1, [r4, #1]
	last = last + 1;
 100b240:	1c53      	adds	r3, r2, #1
 100b242:	b2db      	uxtb	r3, r3
		last = 0U;
 100b244:	4299      	cmp	r1, r3
 100b246:	bf08      	it	eq
 100b248:	2300      	moveq	r3, #0
 100b24a:	78a1      	ldrb	r1, [r4, #2]
	if (last == first) {
 100b24c:	4299      	cmp	r1, r3
 100b24e:	d030      	beq.n	100b2b2 <tx_lll_flush+0xae>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
 100b250:	7821      	ldrb	r1, [r4, #0]
 100b252:	fb02 f201 	mul.w	r2, r2, r1
		LL_ASSERT(lll_tx);
 100b256:	eb19 0e02 	adds.w	lr, r9, r2
 100b25a:	d02a      	beq.n	100b2b2 <tx_lll_flush+0xae>
		lll_tx->node = tx;
 100b25c:	f8dd c004 	ldr.w	ip, [sp, #4]
		lll_tx->handle = 0xFFFF;
 100b260:	f829 7002 	strh.w	r7, [r9, r2]
		link->next = tx->next; /* Indicates ctrl pool or data pool */
 100b264:	f8dc 1000 	ldr.w	r1, [ip]
		link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
 100b268:	aa01      	add	r2, sp, #4
		lll_tx->node = tx;
 100b26a:	f8ce c004 	str.w	ip, [lr, #4]
		link->next = tx->next; /* Indicates ctrl pool or data pool */
 100b26e:	6001      	str	r1, [r0, #0]
		tx->next = link;
 100b270:	f8cc 0000 	str.w	r0, [ip]
		link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
 100b274:	4631      	mov	r1, r6
 100b276:	6d28      	ldr	r0, [r5, #80]	; 0x50
	*last = idx; /* Commit: Update write index */
 100b278:	70e3      	strb	r3, [r4, #3]
 100b27a:	f7fa fdc1 	bl	1005e00 <memq_dequeue>
	while (link) {
 100b27e:	2800      	cmp	r0, #0
 100b280:	d1dc      	bne.n	100b23c <tx_lll_flush+0x38>
	LL_ASSERT(rx->hdr.link);
 100b282:	f8d8 012c 	ldr.w	r0, [r8, #300]	; 0x12c
	rx = (void *)&conn->llcp_terminate.node_rx;
 100b286:	f508 7496 	add.w	r4, r8, #300	; 0x12c
	LL_ASSERT(rx->hdr.link);
 100b28a:	b150      	cbz	r0, 100b2a2 <tx_lll_flush+0x9e>
	rx->hdr.link = NULL;
 100b28c:	2300      	movs	r3, #0
	ull_rx_put(link, rx);
 100b28e:	4621      	mov	r1, r4
	rx->hdr.link = NULL;
 100b290:	f8c8 312c 	str.w	r3, [r8, #300]	; 0x12c
	ull_rx_put(link, rx);
 100b294:	f7ff f894 	bl	100a3c0 <ull_rx_put>
	ull_rx_sched();
 100b298:	f7ff f8a2 	bl	100a3e0 <ull_rx_sched>
}
 100b29c:	b003      	add	sp, #12
 100b29e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	LL_ASSERT(rx->hdr.link);
 100b2a2:	480a      	ldr	r0, [pc, #40]	; (100b2cc <tx_lll_flush+0xc8>)
 100b2a4:	f240 710f 	movw	r1, #1807	; 0x70f
 100b2a8:	f7f8 f9ea 	bl	1003680 <bt_ctlr_assert_handle>
 100b2ac:	f8d8 012c 	ldr.w	r0, [r8, #300]	; 0x12c
 100b2b0:	e7ec      	b.n	100b28c <tx_lll_flush+0x88>
		LL_ASSERT(lll_tx);
 100b2b2:	f240 61fb 	movw	r1, #1787	; 0x6fb
 100b2b6:	4805      	ldr	r0, [pc, #20]	; (100b2cc <tx_lll_flush+0xc8>)
 100b2b8:	f7f8 f9e2 	bl	1003680 <bt_ctlr_assert_handle>
		lll_tx->handle = 0xFFFF;
 100b2bc:	2300      	movs	r3, #0
 100b2be:	801b      	strh	r3, [r3, #0]
 100b2c0:	deff      	udf	#255	; 0xff
 100b2c2:	bf00      	nop
 100b2c4:	21002bd0 	.word	0x21002bd0
 100b2c8:	2100031c 	.word	0x2100031c
 100b2cc:	01018934 	.word	0x01018934

0100b2d0 <ticker_op_stop_cb>:
{
 100b2d0:	b510      	push	{r4, lr}
 100b2d2:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 100b2d4:	b940      	cbnz	r0, 100b2e8 <ticker_op_stop_cb+0x18>
	retval = mayfly_enqueue(TICKER_USER_ID_ULL_LOW, TICKER_USER_ID_LLL, 0,
 100b2d6:	2200      	movs	r2, #0
	mfy.param = param;
 100b2d8:	4b0a      	ldr	r3, [pc, #40]	; (100b304 <ticker_op_stop_cb+0x34>)
	retval = mayfly_enqueue(TICKER_USER_ID_ULL_LOW, TICKER_USER_ID_LLL, 0,
 100b2da:	4611      	mov	r1, r2
 100b2dc:	2002      	movs	r0, #2
	mfy.param = param;
 100b2de:	609c      	str	r4, [r3, #8]
	retval = mayfly_enqueue(TICKER_USER_ID_ULL_LOW, TICKER_USER_ID_LLL, 0,
 100b2e0:	f7fa fdf2 	bl	1005ec8 <mayfly_enqueue>
	LL_ASSERT(!retval);
 100b2e4:	b930      	cbnz	r0, 100b2f4 <ticker_op_stop_cb+0x24>
}
 100b2e6:	bd10      	pop	{r4, pc}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 100b2e8:	f240 6181 	movw	r1, #1665	; 0x681
 100b2ec:	4806      	ldr	r0, [pc, #24]	; (100b308 <ticker_op_stop_cb+0x38>)
 100b2ee:	f7f8 f9c7 	bl	1003680 <bt_ctlr_assert_handle>
 100b2f2:	e7f0      	b.n	100b2d6 <ticker_op_stop_cb+0x6>
	LL_ASSERT(!retval);
 100b2f4:	f44f 61d1 	mov.w	r1, #1672	; 0x688
}
 100b2f8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LL_ASSERT(!retval);
 100b2fc:	4802      	ldr	r0, [pc, #8]	; (100b308 <ticker_op_stop_cb+0x38>)
 100b2fe:	f7f8 b9bf 	b.w	1003680 <bt_ctlr_assert_handle>
 100b302:	bf00      	nop
 100b304:	210003f4 	.word	0x210003f4
 100b308:	01018934 	.word	0x01018934

0100b30c <ticker_start_conn_op_cb>:
{
 100b30c:	b510      	push	{r4, lr}
 100b30e:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 100b310:	b960      	cbnz	r0, 100b32c <ticker_start_conn_op_cb+0x20>
	void *p = ull_update_unmark(param);
 100b312:	4620      	mov	r0, r4
 100b314:	f7fe ffd8 	bl	100a2c8 <ull_update_unmark>
	LL_ASSERT(p == param);
 100b318:	4284      	cmp	r4, r0
 100b31a:	d006      	beq.n	100b32a <ticker_start_conn_op_cb+0x1e>
}
 100b31c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LL_ASSERT(p == param);
 100b320:	f44f 61cf 	mov.w	r1, #1656	; 0x678
 100b324:	4804      	ldr	r0, [pc, #16]	; (100b338 <ticker_start_conn_op_cb+0x2c>)
 100b326:	f7f8 b9ab 	b.w	1003680 <bt_ctlr_assert_handle>
}
 100b32a:	bd10      	pop	{r4, pc}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 100b32c:	f240 6174 	movw	r1, #1652	; 0x674
 100b330:	4801      	ldr	r0, [pc, #4]	; (100b338 <ticker_start_conn_op_cb+0x2c>)
 100b332:	f7f8 f9a5 	bl	1003680 <bt_ctlr_assert_handle>
 100b336:	e7ec      	b.n	100b312 <ticker_start_conn_op_cb+0x6>
 100b338:	01018934 	.word	0x01018934

0100b33c <ticker_stop_conn_op_cb>:
{
 100b33c:	b510      	push	{r4, lr}
 100b33e:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 100b340:	b960      	cbnz	r0, 100b35c <ticker_stop_conn_op_cb+0x20>
	void *p = ull_update_mark(param);
 100b342:	4620      	mov	r0, r4
 100b344:	f7fe ffb6 	bl	100a2b4 <ull_update_mark>
	LL_ASSERT(p == param);
 100b348:	4284      	cmp	r4, r0
 100b34a:	d006      	beq.n	100b35a <ticker_stop_conn_op_cb+0x1e>
}
 100b34c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LL_ASSERT(p == param);
 100b350:	f240 616f 	movw	r1, #1647	; 0x66f
 100b354:	4804      	ldr	r0, [pc, #16]	; (100b368 <ticker_stop_conn_op_cb+0x2c>)
 100b356:	f7f8 b993 	b.w	1003680 <bt_ctlr_assert_handle>
}
 100b35a:	bd10      	pop	{r4, pc}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 100b35c:	f240 616b 	movw	r1, #1643	; 0x66b
 100b360:	4801      	ldr	r0, [pc, #4]	; (100b368 <ticker_stop_conn_op_cb+0x2c>)
 100b362:	f7f8 f98d 	bl	1003680 <bt_ctlr_assert_handle>
 100b366:	e7ec      	b.n	100b342 <ticker_stop_conn_op_cb+0x6>
 100b368:	01018934 	.word	0x01018934

0100b36c <ticker_update_conn_op_cb>:
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
 100b36c:	b900      	cbnz	r0, 100b370 <ticker_update_conn_op_cb+0x4>
 100b36e:	4770      	bx	lr
{
 100b370:	b510      	push	{r4, lr}
 100b372:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
 100b374:	f7fe ffb6 	bl	100a2e4 <ull_update_mark_get>
 100b378:	4284      	cmp	r4, r0
 100b37a:	d00a      	beq.n	100b392 <ticker_update_conn_op_cb+0x26>
 100b37c:	f7fe ff94 	bl	100a2a8 <ull_disable_mark_get>
 100b380:	4284      	cmp	r4, r0
 100b382:	d006      	beq.n	100b392 <ticker_update_conn_op_cb+0x26>
}
 100b384:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
 100b388:	f240 6164 	movw	r1, #1636	; 0x664
 100b38c:	4801      	ldr	r0, [pc, #4]	; (100b394 <ticker_update_conn_op_cb+0x28>)
 100b38e:	f7f8 b977 	b.w	1003680 <bt_ctlr_assert_handle>
}
 100b392:	bd10      	pop	{r4, pc}
 100b394:	01018934 	.word	0x01018934

0100b398 <reject_ext_ind_send.isra.0>:

	return 0;
}

#if defined(CONFIG_BT_CTLR_CONN_PARAM_REQ) || defined(CONFIG_BT_CTLR_PHY)
static int reject_ext_ind_send(struct ll_conn *conn, struct node_rx_pdu *rx,
 100b398:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100b39c:	4605      	mov	r5, r0
{
	struct pdu_data *pdu_ctrl_tx;
	struct node_tx *tx;

	/* acquire tx mem */
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100b39e:	4827      	ldr	r0, [pc, #156]	; (100b43c <reject_ext_ind_send.isra.0+0xa4>)
static int reject_ext_ind_send(struct ll_conn *conn, struct node_rx_pdu *rx,
 100b3a0:	460e      	mov	r6, r1
 100b3a2:	4690      	mov	r8, r2
 100b3a4:	461f      	mov	r7, r3
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100b3a6:	f7fa fcb7 	bl	1005d18 <mem_acquire>
	if (!tx) {
 100b3aa:	2800      	cmp	r0, #0
 100b3ac:	d042      	beq.n	100b434 <reject_ext_ind_send.isra.0+0x9c>
		return -ENOBUFS;
	}

	pdu_ctrl_tx = (void *)tx->pdu;
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
 100b3ae:	2303      	movs	r3, #3
		sizeof(struct pdu_data_llctrl_reject_ext_ind);
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
 100b3b0:	2111      	movs	r1, #17
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b3b2:	7904      	ldrb	r4, [r0, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
 100b3b4:	7143      	strb	r3, [r0, #5]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b3b6:	ea44 0203 	orr.w	r2, r4, r3
	    conn->tx_head &&
 100b3ba:	f8d5 31b0 	ldr.w	r3, [r5, #432]	; 0x1b0
	pdu_ctrl_tx->llctrl.reject_ext_ind.reject_opcode = reject_opcode;
 100b3be:	f880 8008 	strb.w	r8, [r0, #8]
	pdu_ctrl_tx->llctrl.reject_ext_ind.error_code = error_code;
 100b3c2:	7247      	strb	r7, [r0, #9]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b3c4:	7102      	strb	r2, [r0, #4]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
 100b3c6:	71c1      	strb	r1, [r0, #7]
	if (
 100b3c8:	b11b      	cbz	r3, 100b3d2 <reject_ext_ind_send.isra.0+0x3a>
	    !conn->llcp_enc.pause_tx &&
 100b3ca:	f895 2152 	ldrb.w	r2, [r5, #338]	; 0x152
	    conn->tx_head &&
 100b3ce:	0791      	lsls	r1, r2, #30
 100b3d0:	d510      	bpl.n	100b3f4 <reject_ext_ind_send.isra.0+0x5c>
		if (!conn->tx_ctrl) {
 100b3d2:	f8d5 21b4 	ldr.w	r2, [r5, #436]	; 0x1b4
 100b3d6:	b33a      	cbz	r2, 100b428 <reject_ext_ind_send.isra.0+0x90>
	tx->next = conn->tx_ctrl_last->next;
 100b3d8:	f8d5 31b8 	ldr.w	r3, [r5, #440]	; 0x1b8
 100b3dc:	681a      	ldr	r2, [r3, #0]
 100b3de:	6002      	str	r2, [r0, #0]
	conn->tx_ctrl_last->next = tx;
 100b3e0:	6018      	str	r0, [r3, #0]
	conn->tx_ctrl_last = tx;
 100b3e2:	f8c5 01b8 	str.w	r0, [r5, #440]	; 0x1b8
 100b3e6:	6803      	ldr	r3, [r0, #0]
	if (!tx->next) {
 100b3e8:	b1db      	cbz	r3, 100b422 <reject_ext_ind_send.isra.0+0x8a>

	ctrl_tx_enqueue(conn, tx);

	/* Mark for buffer for release */
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100b3ea:	2303      	movs	r3, #3

	return 0;
 100b3ec:	2000      	movs	r0, #0
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100b3ee:	7033      	strb	r3, [r6, #0]
}
 100b3f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	    !conn->llcp_phy.pause_tx &&
 100b3f4:	f895 21ab 	ldrb.w	r2, [r5, #427]	; 0x1ab
 100b3f8:	07d2      	lsls	r2, r2, #31
 100b3fa:	d4ea      	bmi.n	100b3d2 <reject_ext_ind_send.isra.0+0x3a>
		if (conn->tx_head == conn->tx_data) {
 100b3fc:	f8d5 21bc 	ldr.w	r2, [r5, #444]	; 0x1bc
 100b400:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 100b402:	bf04      	itt	eq
 100b404:	681a      	ldreq	r2, [r3, #0]
 100b406:	f8c5 21bc 	streq.w	r2, [r5, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 100b40a:	f8d5 21b4 	ldr.w	r2, [r5, #436]	; 0x1b4
 100b40e:	2a00      	cmp	r2, #0
 100b410:	d1e2      	bne.n	100b3d8 <reject_ext_ind_send.isra.0+0x40>
			tx->next = conn->tx_head->next;
 100b412:	681a      	ldr	r2, [r3, #0]
 100b414:	6002      	str	r2, [r0, #0]
			conn->tx_head->next = tx;
 100b416:	6018      	str	r0, [r3, #0]
				conn->tx_ctrl = tx;
 100b418:	6803      	ldr	r3, [r0, #0]
				conn->tx_ctrl_last = tx;
 100b41a:	e9c5 006d 	strd	r0, r0, [r5, #436]	; 0x1b4
	if (!tx->next) {
 100b41e:	2b00      	cmp	r3, #0
 100b420:	d1e3      	bne.n	100b3ea <reject_ext_ind_send.isra.0+0x52>
		conn->tx_data_last = tx;
 100b422:	f8c5 01c0 	str.w	r0, [r5, #448]	; 0x1c0
 100b426:	e7e0      	b.n	100b3ea <reject_ext_ind_send.isra.0+0x52>
			tx->next = conn->tx_head;
 100b428:	6003      	str	r3, [r0, #0]
				conn->tx_ctrl = tx;
 100b42a:	e9c5 006c 	strd	r0, r0, [r5, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 100b42e:	f8c5 01b8 	str.w	r0, [r5, #440]	; 0x1b8
 100b432:	e7d9      	b.n	100b3e8 <reject_ext_ind_send.isra.0+0x50>
		return -ENOBUFS;
 100b434:	f06f 0036 	mvn.w	r0, #54	; 0x36
 100b438:	e7da      	b.n	100b3f0 <reject_ext_ind_send.isra.0+0x58>
 100b43a:	bf00      	nop
 100b43c:	21005288 	.word	0x21005288

0100b440 <start_enc_rsp_send>:
{
 100b440:	b570      	push	{r4, r5, r6, lr}
 100b442:	4604      	mov	r4, r0
	if (!pdu_ctrl_tx) {
 100b444:	b179      	cbz	r1, 100b466 <start_enc_rsp_send+0x26>
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
 100b446:	2601      	movs	r6, #1
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_START_ENC_RSP;
 100b448:	2506      	movs	r5, #6
	conn->lll.enc_tx = 1;
 100b44a:	f890 207e 	ldrb.w	r2, [r0, #126]	; 0x7e
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b44e:	780b      	ldrb	r3, [r1, #0]
	conn->lll.enc_tx = 1;
 100b450:	f042 0210 	orr.w	r2, r2, #16
 100b454:	f880 207e 	strb.w	r2, [r0, #126]	; 0x7e
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b458:	f043 0303 	orr.w	r3, r3, #3
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
 100b45c:	704e      	strb	r6, [r1, #1]
	return 0;
 100b45e:	2000      	movs	r0, #0
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b460:	700b      	strb	r3, [r1, #0]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_START_ENC_RSP;
 100b462:	70cd      	strb	r5, [r1, #3]
}
 100b464:	bd70      	pop	{r4, r5, r6, pc}
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100b466:	4826      	ldr	r0, [pc, #152]	; (100b500 <start_enc_rsp_send+0xc0>)
 100b468:	f7fa fc56 	bl	1005d18 <mem_acquire>
		if (!tx) {
 100b46c:	2800      	cmp	r0, #0
 100b46e:	d043      	beq.n	100b4f8 <start_enc_rsp_send+0xb8>
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
 100b470:	2501      	movs	r5, #1
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_START_ENC_RSP;
 100b472:	2106      	movs	r1, #6
	conn->lll.enc_tx = 1;
 100b474:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b478:	7902      	ldrb	r2, [r0, #4]
	conn->lll.enc_tx = 1;
 100b47a:	f043 0310 	orr.w	r3, r3, #16
 100b47e:	f884 307e 	strb.w	r3, [r4, #126]	; 0x7e
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
 100b482:	7145      	strb	r5, [r0, #5]
	    conn->tx_head &&
 100b484:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b488:	f042 0203 	orr.w	r2, r2, #3
 100b48c:	7102      	strb	r2, [r0, #4]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_START_ENC_RSP;
 100b48e:	71c1      	strb	r1, [r0, #7]
	if (
 100b490:	b1e3      	cbz	r3, 100b4cc <start_enc_rsp_send+0x8c>
	    !conn->llcp_enc.pause_tx &&
 100b492:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
	    conn->tx_head &&
 100b496:	0791      	lsls	r1, r2, #30
 100b498:	d418      	bmi.n	100b4cc <start_enc_rsp_send+0x8c>
	    !conn->llcp_phy.pause_tx &&
 100b49a:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
 100b49e:	07d2      	lsls	r2, r2, #31
 100b4a0:	d414      	bmi.n	100b4cc <start_enc_rsp_send+0x8c>
		if (conn->tx_head == conn->tx_data) {
 100b4a2:	f8d4 21bc 	ldr.w	r2, [r4, #444]	; 0x1bc
 100b4a6:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 100b4a8:	bf04      	itt	eq
 100b4aa:	681a      	ldreq	r2, [r3, #0]
 100b4ac:	f8c4 21bc 	streq.w	r2, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 100b4b0:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 100b4b4:	b1ca      	cbz	r2, 100b4ea <start_enc_rsp_send+0xaa>
	tx->next = conn->tx_ctrl_last->next;
 100b4b6:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 100b4ba:	681a      	ldr	r2, [r3, #0]
 100b4bc:	6002      	str	r2, [r0, #0]
	conn->tx_ctrl_last->next = tx;
 100b4be:	6018      	str	r0, [r3, #0]
	conn->tx_ctrl_last = tx;
 100b4c0:	f8c4 01b8 	str.w	r0, [r4, #440]	; 0x1b8
 100b4c4:	6803      	ldr	r3, [r0, #0]
	if (!tx->next) {
 100b4c6:	b163      	cbz	r3, 100b4e2 <start_enc_rsp_send+0xa2>
	return 0;
 100b4c8:	2000      	movs	r0, #0
}
 100b4ca:	bd70      	pop	{r4, r5, r6, pc}
		if (!conn->tx_ctrl) {
 100b4cc:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 100b4d0:	2a00      	cmp	r2, #0
 100b4d2:	d1f0      	bne.n	100b4b6 <start_enc_rsp_send+0x76>
			tx->next = conn->tx_head;
 100b4d4:	6003      	str	r3, [r0, #0]
				conn->tx_ctrl = tx;
 100b4d6:	e9c4 006c 	strd	r0, r0, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 100b4da:	f8c4 01b8 	str.w	r0, [r4, #440]	; 0x1b8
	if (!tx->next) {
 100b4de:	2b00      	cmp	r3, #0
 100b4e0:	d1f2      	bne.n	100b4c8 <start_enc_rsp_send+0x88>
		conn->tx_data_last = tx;
 100b4e2:	f8c4 01c0 	str.w	r0, [r4, #448]	; 0x1c0
	return 0;
 100b4e6:	4618      	mov	r0, r3
}
 100b4e8:	bd70      	pop	{r4, r5, r6, pc}
			tx->next = conn->tx_head->next;
 100b4ea:	681a      	ldr	r2, [r3, #0]
 100b4ec:	6002      	str	r2, [r0, #0]
			conn->tx_head->next = tx;
 100b4ee:	6018      	str	r0, [r3, #0]
				conn->tx_ctrl = tx;
 100b4f0:	6803      	ldr	r3, [r0, #0]
				conn->tx_ctrl_last = tx;
 100b4f2:	e9c4 006d 	strd	r0, r0, [r4, #436]	; 0x1b4
 100b4f6:	e7e6      	b.n	100b4c6 <start_enc_rsp_send+0x86>
			return -ENOBUFS;
 100b4f8:	f06f 0036 	mvn.w	r0, #54	; 0x36
}
 100b4fc:	bd70      	pop	{r4, r5, r6, pc}
 100b4fe:	bf00      	nop
 100b500:	21005288 	.word	0x21005288

0100b504 <ctrl_tx_sec_enqueue>:
{
 100b504:	b538      	push	{r3, r4, r5, lr}
	if (conn->llcp_enc.pause_tx) {
 100b506:	f890 3152 	ldrb.w	r3, [r0, #338]	; 0x152
{
 100b50a:	4604      	mov	r4, r0
	if (conn->llcp_enc.pause_tx) {
 100b50c:	079a      	lsls	r2, r3, #30
{
 100b50e:	460d      	mov	r5, r1
	if (conn->llcp_enc.pause_tx) {
 100b510:	d50b      	bpl.n	100b52a <ctrl_tx_sec_enqueue+0x26>
		if (!conn->tx_ctrl) {
 100b512:	f8d0 31b4 	ldr.w	r3, [r0, #436]	; 0x1b4
 100b516:	2b00      	cmp	r3, #0
 100b518:	d045      	beq.n	100b5a6 <ctrl_tx_sec_enqueue+0xa2>
			tx->next = conn->tx_ctrl_last->next;
 100b51a:	f8d0 31b8 	ldr.w	r3, [r0, #440]	; 0x1b8
 100b51e:	681a      	ldr	r2, [r3, #0]
 100b520:	600a      	str	r2, [r1, #0]
			conn->tx_ctrl_last->next = tx;
 100b522:	6019      	str	r1, [r3, #0]
		if (!tx->next) {
 100b524:	682b      	ldr	r3, [r5, #0]
 100b526:	b363      	cbz	r3, 100b582 <ctrl_tx_sec_enqueue+0x7e>
}
 100b528:	bd38      	pop	{r3, r4, r5, pc}
		if (conn->tx_head) {
 100b52a:	f8d0 21b0 	ldr.w	r2, [r0, #432]	; 0x1b0
 100b52e:	b302      	cbz	r2, 100b572 <ctrl_tx_sec_enqueue+0x6e>
			if ((conn->llcp_req != conn->llcp_ack) &&
 100b530:	f890 10e8 	ldrb.w	r1, [r0, #232]	; 0xe8
 100b534:	f890 30e9 	ldrb.w	r3, [r0, #233]	; 0xe9
 100b538:	4299      	cmp	r1, r3
 100b53a:	d003      	beq.n	100b544 <ctrl_tx_sec_enqueue+0x40>
 100b53c:	f890 30ea 	ldrb.w	r3, [r0, #234]	; 0xea
 100b540:	2b03      	cmp	r3, #3
 100b542:	d038      	beq.n	100b5b6 <ctrl_tx_sec_enqueue+0xb2>
	    !conn->llcp_phy.pause_tx &&
 100b544:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
 100b548:	f013 0301 	ands.w	r3, r3, #1
 100b54c:	d11c      	bne.n	100b588 <ctrl_tx_sec_enqueue+0x84>
		if (conn->tx_head == conn->tx_data) {
 100b54e:	f8d4 11bc 	ldr.w	r1, [r4, #444]	; 0x1bc
 100b552:	428a      	cmp	r2, r1
			conn->tx_data = conn->tx_data->next;
 100b554:	bf04      	itt	eq
 100b556:	6811      	ldreq	r1, [r2, #0]
 100b558:	f8c4 11bc 	streq.w	r1, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 100b55c:	f8d4 11b4 	ldr.w	r1, [r4, #436]	; 0x1b4
 100b560:	2900      	cmp	r1, #0
 100b562:	d043      	beq.n	100b5ec <ctrl_tx_sec_enqueue+0xe8>
			LL_ASSERT(!pause);
 100b564:	b1a3      	cbz	r3, 100b590 <ctrl_tx_sec_enqueue+0x8c>
 100b566:	f240 716a 	movw	r1, #1898	; 0x76a
 100b56a:	482a      	ldr	r0, [pc, #168]	; (100b614 <ctrl_tx_sec_enqueue+0x110>)
 100b56c:	f7f8 f888 	bl	1003680 <bt_ctlr_assert_handle>
	tx->next = conn->tx_ctrl_last->next;
 100b570:	e00e      	b.n	100b590 <ctrl_tx_sec_enqueue+0x8c>
		if (!conn->tx_ctrl) {
 100b572:	f8d0 31b4 	ldr.w	r3, [r0, #436]	; 0x1b4
 100b576:	b95b      	cbnz	r3, 100b590 <ctrl_tx_sec_enqueue+0x8c>
			tx->next = conn->tx_head;
 100b578:	600b      	str	r3, [r1, #0]
				conn->tx_ctrl = tx;
 100b57a:	e9c0 116c 	strd	r1, r1, [r0, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 100b57e:	f8c4 11b8 	str.w	r1, [r4, #440]	; 0x1b8
			conn->tx_data_last = tx;
 100b582:	f8c4 51c0 	str.w	r5, [r4, #448]	; 0x1c0
}
 100b586:	bd38      	pop	{r3, r4, r5, pc}
		if (!conn->tx_ctrl) {
 100b588:	f8d4 31b4 	ldr.w	r3, [r4, #436]	; 0x1b4
 100b58c:	2b00      	cmp	r3, #0
 100b58e:	d038      	beq.n	100b602 <ctrl_tx_sec_enqueue+0xfe>
	tx->next = conn->tx_ctrl_last->next;
 100b590:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 100b594:	681a      	ldr	r2, [r3, #0]
 100b596:	602a      	str	r2, [r5, #0]
	conn->tx_ctrl_last->next = tx;
 100b598:	601d      	str	r5, [r3, #0]
	conn->tx_ctrl_last = tx;
 100b59a:	f8c4 51b8 	str.w	r5, [r4, #440]	; 0x1b8
 100b59e:	682b      	ldr	r3, [r5, #0]
		if (!tx->next) {
 100b5a0:	2b00      	cmp	r3, #0
 100b5a2:	d1c1      	bne.n	100b528 <ctrl_tx_sec_enqueue+0x24>
 100b5a4:	e7ed      	b.n	100b582 <ctrl_tx_sec_enqueue+0x7e>
			tx->next = conn->tx_head;
 100b5a6:	f8d0 31b0 	ldr.w	r3, [r0, #432]	; 0x1b0
 100b5aa:	600b      	str	r3, [r1, #0]
			conn->tx_head = tx;
 100b5ac:	f8c4 11b0 	str.w	r1, [r4, #432]	; 0x1b0
		if (!tx->next) {
 100b5b0:	2b00      	cmp	r3, #0
 100b5b2:	d1b9      	bne.n	100b528 <ctrl_tx_sec_enqueue+0x24>
 100b5b4:	e7e5      	b.n	100b582 <ctrl_tx_sec_enqueue+0x7e>
			    (pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
 100b5b6:	7913      	ldrb	r3, [r2, #4]
			    (conn->llcp_type == LLCP_ENCRYPTION) &&
 100b5b8:	f003 0303 	and.w	r3, r3, #3
 100b5bc:	2b03      	cmp	r3, #3
 100b5be:	d1c1      	bne.n	100b544 <ctrl_tx_sec_enqueue+0x40>
			    ((pdu_data_tx->llctrl.opcode ==
 100b5c0:	79d3      	ldrb	r3, [r2, #7]
			    (pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
 100b5c2:	2b03      	cmp	r3, #3
 100b5c4:	d001      	beq.n	100b5ca <ctrl_tx_sec_enqueue+0xc6>
			      PDU_DATA_LLCTRL_TYPE_ENC_REQ) ||
 100b5c6:	2b0a      	cmp	r3, #10
 100b5c8:	d1bc      	bne.n	100b544 <ctrl_tx_sec_enqueue+0x40>
	    !conn->llcp_phy.pause_tx &&
 100b5ca:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
 100b5ce:	07db      	lsls	r3, r3, #31
 100b5d0:	d51d      	bpl.n	100b60e <ctrl_tx_sec_enqueue+0x10a>
		if (!conn->tx_ctrl) {
 100b5d2:	f8d4 31b4 	ldr.w	r3, [r4, #436]	; 0x1b4
 100b5d6:	b12b      	cbz	r3, 100b5e4 <ctrl_tx_sec_enqueue+0xe0>
			LL_ASSERT(!pause);
 100b5d8:	f240 717c 	movw	r1, #1916	; 0x77c
 100b5dc:	480d      	ldr	r0, [pc, #52]	; (100b614 <ctrl_tx_sec_enqueue+0x110>)
 100b5de:	f7f8 f84f 	bl	1003680 <bt_ctlr_assert_handle>
 100b5e2:	e7d5      	b.n	100b590 <ctrl_tx_sec_enqueue+0x8c>
			tx->next = conn->tx_head;
 100b5e4:	602a      	str	r2, [r5, #0]
			conn->tx_head = tx;
 100b5e6:	f8c4 51b0 	str.w	r5, [r4, #432]	; 0x1b0
}
 100b5ea:	bd38      	pop	{r3, r4, r5, pc}
			tx->next = conn->tx_head->next;
 100b5ec:	6811      	ldr	r1, [r2, #0]
 100b5ee:	6029      	str	r1, [r5, #0]
			conn->tx_head->next = tx;
 100b5f0:	6015      	str	r5, [r2, #0]
			if (!pause) {
 100b5f2:	2b00      	cmp	r3, #0
 100b5f4:	d196      	bne.n	100b524 <ctrl_tx_sec_enqueue+0x20>
				conn->tx_ctrl_last = tx;
 100b5f6:	e9c4 556d 	strd	r5, r5, [r4, #436]	; 0x1b4
 100b5fa:	682b      	ldr	r3, [r5, #0]
		if (!tx->next) {
 100b5fc:	2b00      	cmp	r3, #0
 100b5fe:	d193      	bne.n	100b528 <ctrl_tx_sec_enqueue+0x24>
 100b600:	e7bf      	b.n	100b582 <ctrl_tx_sec_enqueue+0x7e>
			tx->next = conn->tx_head;
 100b602:	602a      	str	r2, [r5, #0]
				conn->tx_ctrl = tx;
 100b604:	e9c4 556c 	strd	r5, r5, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 100b608:	f8c4 51b8 	str.w	r5, [r4, #440]	; 0x1b8
}
 100b60c:	bd38      	pop	{r3, r4, r5, pc}
				pause = true;
 100b60e:	2301      	movs	r3, #1
 100b610:	e79d      	b.n	100b54e <ctrl_tx_sec_enqueue+0x4a>
 100b612:	bf00      	nop
 100b614:	01018934 	.word	0x01018934

0100b618 <feature_rsp_send.isra.0>:
static int feature_rsp_send(struct ll_conn *conn, struct node_rx_pdu *rx,
 100b618:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 100b61a:	4606      	mov	r6, r0
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100b61c:	481d      	ldr	r0, [pc, #116]	; (100b694 <feature_rsp_send.isra.0+0x7c>)
static int feature_rsp_send(struct ll_conn *conn, struct node_rx_pdu *rx,
 100b61e:	460d      	mov	r5, r1
 100b620:	4617      	mov	r7, r2
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100b622:	f7fa fb79 	bl	1005d18 <mem_acquire>
	if (!tx) {
 100b626:	b390      	cbz	r0, 100b68e <feature_rsp_send.isra.0+0x76>
	return feat;
 100b628:	4604      	mov	r4, r0
	       (features[1] << 8) | (features[2] << 16);
 100b62a:	79bb      	ldrb	r3, [r7, #6]
 100b62c:	797a      	ldrb	r2, [r7, #5]
	feat = ~LL_FEAT_BIT_MASK_VALID | features[0] |
 100b62e:	7939      	ldrb	r1, [r7, #4]
	       (features[1] << 8) | (features[2] << 16);
 100b630:	041b      	lsls	r3, r3, #16
 100b632:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 100b636:	4a18      	ldr	r2, [pc, #96]	; (100b698 <feature_rsp_send.isra.0+0x80>)
 100b638:	430b      	orrs	r3, r1
 100b63a:	4313      	orrs	r3, r2
	conn->common.fex_valid = 1U;
 100b63c:	f896 20dc 	ldrb.w	r2, [r6, #220]	; 0xdc
	conn->llcp_feature.features &= feat_get(&req->features[0]);
 100b640:	f8d6 111c 	ldr.w	r1, [r6, #284]	; 0x11c
	conn->common.fex_valid = 1U;
 100b644:	f042 0201 	orr.w	r2, r2, #1
	pdu_tx->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
 100b648:	2009      	movs	r0, #9
	conn->llcp_feature.features &= feat_get(&req->features[0]);
 100b64a:	400b      	ands	r3, r1
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b64c:	7921      	ldrb	r1, [r4, #4]
	conn->common.fex_valid = 1U;
 100b64e:	f886 20dc 	strb.w	r2, [r6, #220]	; 0xdc
	(void)memset(&pdu_tx->llctrl.feature_rsp.features[0], 0x00,
 100b652:	2208      	movs	r2, #8
	conn->llcp_feature.features &= feat_get(&req->features[0]);
 100b654:	f3c3 0310 	ubfx	r3, r3, #0, #17
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b658:	f041 0103 	orr.w	r1, r1, #3
	conn->llcp_feature.features &= feat_get(&req->features[0]);
 100b65c:	f8c6 311c 	str.w	r3, [r6, #284]	; 0x11c
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b660:	7121      	strb	r1, [r4, #4]
	pdu_tx->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
 100b662:	7160      	strb	r0, [r4, #5]
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_RSP;
 100b664:	71e0      	strb	r0, [r4, #7]
	(void)memset(&pdu_tx->llctrl.feature_rsp.features[0], 0x00,
 100b666:	2100      	movs	r1, #0
 100b668:	18a0      	adds	r0, r4, r2
 100b66a:	f00b fa00 	bl	1016a6e <memset>
	sys_put_le24(conn->llcp_feature.features,
 100b66e:	f8d6 311c 	ldr.w	r3, [r6, #284]	; 0x11c
	ctrl_tx_sec_enqueue(conn, tx);
 100b672:	4630      	mov	r0, r6
	dst[1] = val >> 8;
 100b674:	f3c3 2107 	ubfx	r1, r3, #8, #8
	dst[2] = val >> 16;
 100b678:	0c1a      	lsrs	r2, r3, #16
	dst[0] = val;
 100b67a:	7223      	strb	r3, [r4, #8]
	dst[1] = val >> 8;
 100b67c:	7261      	strb	r1, [r4, #9]
	dst[2] = val >> 16;
 100b67e:	72a2      	strb	r2, [r4, #10]
 100b680:	4621      	mov	r1, r4
 100b682:	f7ff ff3f 	bl	100b504 <ctrl_tx_sec_enqueue>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100b686:	2303      	movs	r3, #3
 100b688:	702b      	strb	r3, [r5, #0]
	return 0;
 100b68a:	2000      	movs	r0, #0
}
 100b68c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -ENOBUFS;
 100b68e:	f06f 0036 	mvn.w	r0, #54	; 0x36
}
 100b692:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 100b694:	21005288 	.word	0x21005288
 100b698:	fffe30d0 	.word	0xfffe30d0

0100b69c <ll_conn_acquire>:
	return mem_acquire(&conn_free);
 100b69c:	4801      	ldr	r0, [pc, #4]	; (100b6a4 <ll_conn_acquire+0x8>)
 100b69e:	f7fa bb3b 	b.w	1005d18 <mem_acquire>
 100b6a2:	bf00      	nop
 100b6a4:	21002bcc 	.word	0x21002bcc

0100b6a8 <ll_conn_release>:
	mem_release(conn, &conn_free);
 100b6a8:	4901      	ldr	r1, [pc, #4]	; (100b6b0 <ll_conn_release+0x8>)
 100b6aa:	f7fa bb4f 	b.w	1005d4c <mem_release>
 100b6ae:	bf00      	nop
 100b6b0:	21002bcc 	.word	0x21002bcc

0100b6b4 <ll_conn_handle_get>:
	return mem_index_get(conn, conn_pool, sizeof(struct ll_conn));
 100b6b4:	f44f 72e4 	mov.w	r2, #456	; 0x1c8
 100b6b8:	4901      	ldr	r1, [pc, #4]	; (100b6c0 <ll_conn_handle_get+0xc>)
 100b6ba:	f7fa bb63 	b.w	1005d84 <mem_index_get>
 100b6be:	bf00      	nop
 100b6c0:	21002bd0 	.word	0x21002bd0

0100b6c4 <ll_conn_get>:
{
 100b6c4:	4602      	mov	r2, r0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b6c6:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100b6ca:	4801      	ldr	r0, [pc, #4]	; (100b6d0 <ll_conn_get+0xc>)
 100b6cc:	f7fa bb56 	b.w	1005d7c <mem_get>
 100b6d0:	21002bd0 	.word	0x21002bd0

0100b6d4 <ll_connected_get>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100b6d4:	280f      	cmp	r0, #15
 100b6d6:	d80c      	bhi.n	100b6f2 <ll_connected_get+0x1e>
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b6d8:	4602      	mov	r2, r0
{
 100b6da:	b510      	push	{r4, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b6dc:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100b6e0:	4604      	mov	r4, r0
 100b6e2:	4805      	ldr	r0, [pc, #20]	; (100b6f8 <ll_connected_get+0x24>)
 100b6e4:	f7fa fb4a 	bl	1005d7c <mem_get>
	if (conn->lll.handle != handle) {
 100b6e8:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
 100b6ea:	42a3      	cmp	r3, r4
		return NULL;
 100b6ec:	bf18      	it	ne
 100b6ee:	2000      	movne	r0, #0
}
 100b6f0:	bd10      	pop	{r4, pc}
		return NULL;
 100b6f2:	2000      	movs	r0, #0
}
 100b6f4:	4770      	bx	lr
 100b6f6:	bf00      	nop
 100b6f8:	21002bd0 	.word	0x21002bd0

0100b6fc <ll_tx_mem_acquire>:
	return mem_acquire(&mem_conn_tx.free);
 100b6fc:	4801      	ldr	r0, [pc, #4]	; (100b704 <ll_tx_mem_acquire+0x8>)
 100b6fe:	f7fa bb0b 	b.w	1005d18 <mem_acquire>
 100b702:	bf00      	nop
 100b704:	2100485c 	.word	0x2100485c

0100b708 <ll_tx_mem_release>:
	mem_release(tx, &mem_conn_tx.free);
 100b708:	4901      	ldr	r1, [pc, #4]	; (100b710 <ll_tx_mem_release+0x8>)
 100b70a:	f7fa bb1f 	b.w	1005d4c <mem_release>
 100b70e:	bf00      	nop
 100b710:	2100485c 	.word	0x2100485c

0100b714 <ll_tx_mem_enqueue>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100b714:	280f      	cmp	r0, #15
 100b716:	d852      	bhi.n	100b7be <ll_tx_mem_enqueue+0xaa>
{
 100b718:	b5f0      	push	{r4, r5, r6, r7, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b71a:	4602      	mov	r2, r0
 100b71c:	4604      	mov	r4, r0
 100b71e:	460d      	mov	r5, r1
 100b720:	482a      	ldr	r0, [pc, #168]	; (100b7cc <ll_tx_mem_enqueue+0xb8>)
 100b722:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
{
 100b726:	b089      	sub	sp, #36	; 0x24
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b728:	f7fa fb28 	bl	1005d7c <mem_get>
	if (conn->lll.handle != handle) {
 100b72c:	8d86      	ldrh	r6, [r0, #44]	; 0x2c
 100b72e:	42a6      	cmp	r6, r4
 100b730:	d11c      	bne.n	100b76c <ll_tx_mem_enqueue+0x58>
	idx = MFIFO_ENQUEUE_GET(conn_tx, (void **) &lll_tx);
 100b732:	4927      	ldr	r1, [pc, #156]	; (100b7d0 <ll_tx_mem_enqueue+0xbc>)
 100b734:	78ca      	ldrb	r2, [r1, #3]
	if (last == count) {
 100b736:	784c      	ldrb	r4, [r1, #1]
	last = last + 1;
 100b738:	1c53      	adds	r3, r2, #1
 100b73a:	b2db      	uxtb	r3, r3
		last = 0U;
 100b73c:	429c      	cmp	r4, r3
 100b73e:	bf08      	it	eq
 100b740:	2300      	moveq	r3, #0
 100b742:	788c      	ldrb	r4, [r1, #2]
	if (last == first) {
 100b744:	429c      	cmp	r4, r3
 100b746:	d03d      	beq.n	100b7c4 <ll_tx_mem_enqueue+0xb0>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
 100b748:	460c      	mov	r4, r1
 100b74a:	f814 7b04 	ldrb.w	r7, [r4], #4
 100b74e:	fb02 f207 	mul.w	r2, r2, r7
	if (!lll_tx) {
 100b752:	18a7      	adds	r7, r4, r2
 100b754:	d036      	beq.n	100b7c4 <ll_tx_mem_enqueue+0xb0>
	if (conn->lll.role && conn->lll.latency_event &&
 100b756:	f990 c03d 	ldrsb.w	ip, [r0, #61]	; 0x3d
	lll_tx->handle = handle;
 100b75a:	52a6      	strh	r6, [r4, r2]
	if (conn->lll.role && conn->lll.latency_event &&
 100b75c:	f1bc 0f00 	cmp.w	ip, #0
	lll_tx->node = tx;
 100b760:	607d      	str	r5, [r7, #4]
	*last = idx; /* Commit: Update write index */
 100b762:	70cb      	strb	r3, [r1, #3]
	if (conn->lll.role && conn->lll.latency_event &&
 100b764:	db06      	blt.n	100b774 <ll_tx_mem_enqueue+0x60>
	return 0;
 100b766:	2000      	movs	r0, #0
}
 100b768:	b009      	add	sp, #36	; 0x24
 100b76a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -EINVAL;
 100b76c:	f06f 0015 	mvn.w	r0, #21
}
 100b770:	b009      	add	sp, #36	; 0x24
 100b772:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (conn->lll.role && conn->lll.latency_event &&
 100b774:	8e83      	ldrh	r3, [r0, #52]	; 0x34
 100b776:	2b00      	cmp	r3, #0
 100b778:	d0f5      	beq.n	100b766 <ll_tx_mem_enqueue+0x52>
	    !conn->slave.latency_cancel) {
 100b77a:	f890 30dc 	ldrb.w	r3, [r0, #220]	; 0xdc
	if (conn->lll.role && conn->lll.latency_event &&
 100b77e:	f013 0402 	ands.w	r4, r3, #2
 100b782:	d1f0      	bne.n	100b766 <ll_tx_mem_enqueue+0x52>
			ticker_update(TICKER_INSTANCE_ID_CTLR,
 100b784:	2501      	movs	r5, #1
 100b786:	4913      	ldr	r1, [pc, #76]	; (100b7d4 <ll_tx_mem_enqueue+0xc0>)
		conn->slave.latency_cancel = 1U;
 100b788:	f043 0302 	orr.w	r3, r3, #2
				      (TICKER_ID_CONN_BASE + handle),
 100b78c:	1d72      	adds	r2, r6, #5
		conn->slave.latency_cancel = 1U;
 100b78e:	f880 30dc 	strb.w	r3, [r0, #220]	; 0xdc
			ticker_update(TICKER_INSTANCE_ID_CTLR,
 100b792:	b2d2      	uxtb	r2, r2
 100b794:	4623      	mov	r3, r4
 100b796:	9006      	str	r0, [sp, #24]
 100b798:	9105      	str	r1, [sp, #20]
 100b79a:	4620      	mov	r0, r4
 100b79c:	2103      	movs	r1, #3
 100b79e:	e9cd 4401 	strd	r4, r4, [sp, #4]
 100b7a2:	9404      	str	r4, [sp, #16]
 100b7a4:	9400      	str	r4, [sp, #0]
 100b7a6:	9503      	str	r5, [sp, #12]
 100b7a8:	f7fb fd76 	bl	1007298 <ticker_update>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 100b7ac:	f030 0302 	bics.w	r3, r0, #2
 100b7b0:	d0d9      	beq.n	100b766 <ll_tx_mem_enqueue+0x52>
 100b7b2:	4809      	ldr	r0, [pc, #36]	; (100b7d8 <ll_tx_mem_enqueue+0xc4>)
 100b7b4:	21fd      	movs	r1, #253	; 0xfd
 100b7b6:	f7f7 ff63 	bl	1003680 <bt_ctlr_assert_handle>
	return 0;
 100b7ba:	4620      	mov	r0, r4
 100b7bc:	e7d4      	b.n	100b768 <ll_tx_mem_enqueue+0x54>
		return -EINVAL;
 100b7be:	f06f 0015 	mvn.w	r0, #21
}
 100b7c2:	4770      	bx	lr
		return -ENOBUFS;
 100b7c4:	f06f 0036 	mvn.w	r0, #54	; 0x36
}
 100b7c8:	b009      	add	sp, #36	; 0x24
 100b7ca:	bdf0      	pop	{r4, r5, r6, r7, pc}
 100b7cc:	21002bd0 	.word	0x21002bd0
 100b7d0:	21000398 	.word	0x21000398
 100b7d4:	0100b0c1 	.word	0x0100b0c1
 100b7d8:	01018934 	.word	0x01018934

0100b7dc <ll_conn_update>:
{
 100b7dc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (handle >= CONFIG_BT_MAX_CONN) {
 100b7e0:	280f      	cmp	r0, #15
{
 100b7e2:	f8bd a020 	ldrh.w	sl, [sp, #32]
 100b7e6:	f8bd 9024 	ldrh.w	r9, [sp, #36]	; 0x24
 100b7ea:	f8bd 8028 	ldrh.w	r8, [sp, #40]	; 0x28
	if (handle >= CONFIG_BT_MAX_CONN) {
 100b7ee:	d83f      	bhi.n	100b870 <ll_conn_update+0x94>
 100b7f0:	4604      	mov	r4, r0
 100b7f2:	460d      	mov	r5, r1
 100b7f4:	4617      	mov	r7, r2
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b7f6:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100b7fa:	4602      	mov	r2, r0
 100b7fc:	483a      	ldr	r0, [pc, #232]	; (100b8e8 <ll_conn_update+0x10c>)
 100b7fe:	461e      	mov	r6, r3
 100b800:	f7fa fabc 	bl	1005d7c <mem_get>
	if (conn->lll.handle != handle) {
 100b804:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
 100b806:	42a3      	cmp	r3, r4
 100b808:	d132      	bne.n	100b870 <ll_conn_update+0x94>
	if (!cmd) {
 100b80a:	bb3d      	cbnz	r5, 100b85c <ll_conn_update+0x80>
		if (!conn->llcp_conn_param.disabled &&
 100b80c:	f890 3172 	ldrb.w	r3, [r0, #370]	; 0x172
 100b810:	06d9      	lsls	r1, r3, #27
 100b812:	d530      	bpl.n	100b876 <ll_conn_update+0x9a>
		} else if (conn->lll.role) {
 100b814:	f990 303d 	ldrsb.w	r3, [r0, #61]	; 0x3d
 100b818:	2b00      	cmp	r3, #0
 100b81a:	db62      	blt.n	100b8e2 <ll_conn_update+0x106>
		if (conn->llcp_cu.req != conn->llcp_cu.ack) {
 100b81c:	f890 3104 	ldrb.w	r3, [r0, #260]	; 0x104
 100b820:	f890 2105 	ldrb.w	r2, [r0, #261]	; 0x105
 100b824:	429a      	cmp	r2, r3
 100b826:	d123      	bne.n	100b870 <ll_conn_update+0x94>
		conn->llcp_cu.win_size = 1U;
 100b828:	2401      	movs	r4, #1
		conn->llcp_cu.win_offset_us = 0U;
 100b82a:	2300      	movs	r3, #0
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
 100b82c:	f890 1106 	ldrb.w	r1, [r0, #262]	; 0x106
		conn->llcp_cu.req++;
 100b830:	4422      	add	r2, r4
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
 100b832:	f021 0107 	bic.w	r1, r1, #7
 100b836:	f041 0105 	orr.w	r1, r1, #5
		conn->llcp_cu.req++;
 100b83a:	f880 2104 	strb.w	r2, [r0, #260]	; 0x104
		conn->llcp_cu.win_size = 1U;
 100b83e:	f880 4114 	strb.w	r4, [r0, #276]	; 0x114
		conn->llcp_cu.interval = interval_max;
 100b842:	f8a0 a108 	strh.w	sl, [r0, #264]	; 0x108
		conn->llcp_cu.latency = latency;
 100b846:	f8a0 910a 	strh.w	r9, [r0, #266]	; 0x10a
		conn->llcp_cu.timeout = timeout;
 100b84a:	f8a0 810c 	strh.w	r8, [r0, #268]	; 0x10c
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
 100b84e:	f880 1106 	strb.w	r1, [r0, #262]	; 0x106
		conn->llcp_cu.win_offset_us = 0U;
 100b852:	f8c0 3110 	str.w	r3, [r0, #272]	; 0x110
	return 0;
 100b856:	4618      	mov	r0, r3
}
 100b858:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		cmd--;
 100b85c:	3d01      	subs	r5, #1
		if (cmd) {
 100b85e:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
 100b862:	d010      	beq.n	100b886 <ll_conn_update+0xaa>
			if ((conn->llcp_conn_param.req ==
 100b864:	f890 2170 	ldrb.w	r2, [r0, #368]	; 0x170
 100b868:	f890 3171 	ldrb.w	r3, [r0, #369]	; 0x171
 100b86c:	429a      	cmp	r2, r3
 100b86e:	d125      	bne.n	100b8bc <ll_conn_update+0xe0>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100b870:	200c      	movs	r0, #12
}
 100b872:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		    (!conn->common.fex_valid ||
 100b876:	f890 30dc 	ldrb.w	r3, [r0, #220]	; 0xdc
		if (!conn->llcp_conn_param.disabled &&
 100b87a:	07da      	lsls	r2, r3, #31
 100b87c:	d503      	bpl.n	100b886 <ll_conn_update+0xaa>
		     (conn->llcp_feature.features &
 100b87e:	f8d0 311c 	ldr.w	r3, [r0, #284]	; 0x11c
		    (!conn->common.fex_valid ||
 100b882:	079b      	lsls	r3, r3, #30
 100b884:	d5c6      	bpl.n	100b814 <ll_conn_update+0x38>
			if (conn->llcp_conn_param.req !=
 100b886:	f890 2170 	ldrb.w	r2, [r0, #368]	; 0x170
 100b88a:	f890 3171 	ldrb.w	r3, [r0, #369]	; 0x171
 100b88e:	4293      	cmp	r3, r2
 100b890:	d1ee      	bne.n	100b870 <ll_conn_update+0x94>
			conn->llcp_conn_param.state = cmd;
 100b892:	f8b0 2172 	ldrh.w	r2, [r0, #370]	; 0x172
			conn->llcp_conn_param.req++;
 100b896:	3301      	adds	r3, #1
			conn->llcp_conn_param.state = cmd;
 100b898:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 100b89c:	f042 0208 	orr.w	r2, r2, #8
			conn->llcp_conn_param.req++;
 100b8a0:	f880 3170 	strb.w	r3, [r0, #368]	; 0x170
			conn->llcp_conn_param.interval_min = interval_min;
 100b8a4:	f8a0 6174 	strh.w	r6, [r0, #372]	; 0x174
			conn->llcp_conn_param.interval_max = interval_max;
 100b8a8:	f8a0 a176 	strh.w	sl, [r0, #374]	; 0x176
			conn->llcp_conn_param.latency = latency;
 100b8ac:	f8a0 9178 	strh.w	r9, [r0, #376]	; 0x178
			conn->llcp_conn_param.timeout = timeout;
 100b8b0:	f8a0 817a 	strh.w	r8, [r0, #378]	; 0x17a
			conn->llcp_conn_param.state = cmd;
 100b8b4:	f8a0 2172 	strh.w	r2, [r0, #370]	; 0x172
	return 0;
 100b8b8:	2000      	movs	r0, #0
 100b8ba:	e7da      	b.n	100b872 <ll_conn_update+0x96>
			    (conn->llcp_conn_param.state !=
 100b8bc:	f890 3172 	ldrb.w	r3, [r0, #370]	; 0x172
			     conn->llcp_conn_param.ack) ||
 100b8c0:	f003 0207 	and.w	r2, r3, #7
 100b8c4:	2a03      	cmp	r2, #3
 100b8c6:	d1d3      	bne.n	100b870 <ll_conn_update+0x94>
			conn->llcp_conn_param.state = cmd;
 100b8c8:	f005 0507 	and.w	r5, r5, #7
 100b8cc:	f045 0508 	orr.w	r5, r5, #8
 100b8d0:	f023 030f 	bic.w	r3, r3, #15
 100b8d4:	431d      	orrs	r5, r3
 100b8d6:	f880 5172 	strb.w	r5, [r0, #370]	; 0x172
			conn->llcp_conn_param.status = status;
 100b8da:	f880 7173 	strb.w	r7, [r0, #371]	; 0x173
	return 0;
 100b8de:	2000      	movs	r0, #0
 100b8e0:	e7c7      	b.n	100b872 <ll_conn_update+0x96>
			return BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
 100b8e2:	201a      	movs	r0, #26
 100b8e4:	e7c5      	b.n	100b872 <ll_conn_update+0x96>
 100b8e6:	bf00      	nop
 100b8e8:	21002bd0 	.word	0x21002bd0

0100b8ec <ll_chm_get>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100b8ec:	280f      	cmp	r0, #15
 100b8ee:	d81d      	bhi.n	100b92c <ll_chm_get+0x40>
{
 100b8f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b8f2:	4602      	mov	r2, r0
 100b8f4:	4606      	mov	r6, r0
 100b8f6:	460d      	mov	r5, r1
 100b8f8:	480d      	ldr	r0, [pc, #52]	; (100b930 <ll_chm_get+0x44>)
 100b8fa:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100b8fe:	f7fa fa3d 	bl	1005d7c <mem_get>
	if (conn->lll.handle != handle) {
 100b902:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b904:	4604      	mov	r4, r0
	if (conn->lll.handle != handle) {
 100b906:	42b3      	cmp	r3, r6
 100b908:	d10e      	bne.n	100b928 <ll_chm_get+0x3c>
		conn->chm_updated = 0U;
 100b90a:	2700      	movs	r7, #0
 100b90c:	f100 0638 	add.w	r6, r0, #56	; 0x38
		memcpy(chm, conn->lll.data_chan_map,
 100b910:	2205      	movs	r2, #5
 100b912:	4631      	mov	r1, r6
 100b914:	4628      	mov	r0, r5
		conn->chm_updated = 0U;
 100b916:	f884 71c4 	strb.w	r7, [r4, #452]	; 0x1c4
		memcpy(chm, conn->lll.data_chan_map,
 100b91a:	f00b f87d 	bl	1016a18 <memcpy>
	} while (conn->chm_updated);
 100b91e:	f894 01c4 	ldrb.w	r0, [r4, #452]	; 0x1c4
 100b922:	2800      	cmp	r0, #0
 100b924:	d1f4      	bne.n	100b910 <ll_chm_get+0x24>
}
 100b926:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100b928:	200c      	movs	r0, #12
}
 100b92a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100b92c:	200c      	movs	r0, #12
}
 100b92e:	4770      	bx	lr
 100b930:	21002bd0 	.word	0x21002bd0

0100b934 <ll_terminate_ind_send>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100b934:	280f      	cmp	r0, #15
 100b936:	d817      	bhi.n	100b968 <ll_terminate_ind_send+0x34>
{
 100b938:	b538      	push	{r3, r4, r5, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b93a:	4602      	mov	r2, r0
 100b93c:	4604      	mov	r4, r0
 100b93e:	460d      	mov	r5, r1
 100b940:	480a      	ldr	r0, [pc, #40]	; (100b96c <ll_terminate_ind_send+0x38>)
 100b942:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100b946:	f7fa fa19 	bl	1005d7c <mem_get>
	if (conn->lll.handle != handle) {
 100b94a:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b94c:	4603      	mov	r3, r0
	if (conn->lll.handle != handle) {
 100b94e:	42a2      	cmp	r2, r4
 100b950:	d108      	bne.n	100b964 <ll_terminate_ind_send+0x30>
	conn->llcp_terminate.req++;
 100b952:	f893 2128 	ldrb.w	r2, [r3, #296]	; 0x128
	conn->llcp_terminate.reason_own = reason;
 100b956:	f883 512a 	strb.w	r5, [r3, #298]	; 0x12a
	conn->llcp_terminate.req++;
 100b95a:	3201      	adds	r2, #1
 100b95c:	f883 2128 	strb.w	r2, [r3, #296]	; 0x128
	return 0;
 100b960:	2000      	movs	r0, #0
}
 100b962:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100b964:	200c      	movs	r0, #12
}
 100b966:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100b968:	200c      	movs	r0, #12
}
 100b96a:	4770      	bx	lr
 100b96c:	21002bd0 	.word	0x21002bd0

0100b970 <ll_feature_req_send>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100b970:	280f      	cmp	r0, #15
 100b972:	d818      	bhi.n	100b9a6 <ll_feature_req_send+0x36>
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b974:	4602      	mov	r2, r0
{
 100b976:	b510      	push	{r4, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b978:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100b97c:	4604      	mov	r4, r0
 100b97e:	480b      	ldr	r0, [pc, #44]	; (100b9ac <ll_feature_req_send+0x3c>)
 100b980:	f7fa f9fc 	bl	1005d7c <mem_get>
	if (conn->lll.handle != handle) {
 100b984:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b986:	4603      	mov	r3, r0
	if (conn->lll.handle != handle) {
 100b988:	42a2      	cmp	r2, r4
 100b98a:	d10a      	bne.n	100b9a2 <ll_feature_req_send+0x32>
	if (conn->llcp_feature.req != conn->llcp_feature.ack) {
 100b98c:	f890 1118 	ldrb.w	r1, [r0, #280]	; 0x118
 100b990:	f890 2119 	ldrb.w	r2, [r0, #281]	; 0x119
 100b994:	428a      	cmp	r2, r1
 100b996:	d104      	bne.n	100b9a2 <ll_feature_req_send+0x32>
	conn->llcp_feature.req++;
 100b998:	3201      	adds	r2, #1
 100b99a:	f883 2118 	strb.w	r2, [r3, #280]	; 0x118
	return 0;
 100b99e:	2000      	movs	r0, #0
}
 100b9a0:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100b9a2:	200c      	movs	r0, #12
}
 100b9a4:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100b9a6:	200c      	movs	r0, #12
}
 100b9a8:	4770      	bx	lr
 100b9aa:	bf00      	nop
 100b9ac:	21002bd0 	.word	0x21002bd0

0100b9b0 <ll_version_ind_send>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100b9b0:	280f      	cmp	r0, #15
 100b9b2:	d818      	bhi.n	100b9e6 <ll_version_ind_send+0x36>
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b9b4:	4602      	mov	r2, r0
{
 100b9b6:	b510      	push	{r4, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b9b8:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100b9bc:	4604      	mov	r4, r0
 100b9be:	480b      	ldr	r0, [pc, #44]	; (100b9ec <ll_version_ind_send+0x3c>)
 100b9c0:	f7fa f9dc 	bl	1005d7c <mem_get>
	if (conn->lll.handle != handle) {
 100b9c4:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b9c6:	4603      	mov	r3, r0
	if (conn->lll.handle != handle) {
 100b9c8:	42a2      	cmp	r2, r4
 100b9ca:	d10a      	bne.n	100b9e2 <ll_version_ind_send+0x32>
	if (conn->llcp_version.req != conn->llcp_version.ack) {
 100b9cc:	f890 1120 	ldrb.w	r1, [r0, #288]	; 0x120
 100b9d0:	f890 2121 	ldrb.w	r2, [r0, #289]	; 0x121
 100b9d4:	428a      	cmp	r2, r1
 100b9d6:	d104      	bne.n	100b9e2 <ll_version_ind_send+0x32>
	conn->llcp_version.req++;
 100b9d8:	3201      	adds	r2, #1
 100b9da:	f883 2120 	strb.w	r2, [r3, #288]	; 0x120
	return 0;
 100b9de:	2000      	movs	r0, #0
}
 100b9e0:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100b9e2:	200c      	movs	r0, #12
}
 100b9e4:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100b9e6:	200c      	movs	r0, #12
}
 100b9e8:	4770      	bx	lr
 100b9ea:	bf00      	nop
 100b9ec:	21002bd0 	.word	0x21002bd0

0100b9f0 <ll_length_req_send>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100b9f0:	280f      	cmp	r0, #15
 100b9f2:	d836      	bhi.n	100ba62 <ll_length_req_send+0x72>
{
 100b9f4:	b570      	push	{r4, r5, r6, lr}
 100b9f6:	4604      	mov	r4, r0
 100b9f8:	460e      	mov	r6, r1
 100b9fa:	4615      	mov	r5, r2
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b9fc:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100ba00:	4602      	mov	r2, r0
 100ba02:	4820      	ldr	r0, [pc, #128]	; (100ba84 <ll_length_req_send+0x94>)
 100ba04:	f7fa f9ba 	bl	1005d7c <mem_get>
	if (conn->lll.handle != handle) {
 100ba08:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
 100ba0a:	42a3      	cmp	r3, r4
 100ba0c:	d11f      	bne.n	100ba4e <ll_length_req_send+0x5e>
	if (conn->llcp_length.disabled ||
 100ba0e:	f890 319a 	ldrb.w	r3, [r0, #410]	; 0x19a
 100ba12:	071c      	lsls	r4, r3, #28
 100ba14:	d421      	bmi.n	100ba5a <ll_length_req_send+0x6a>
	    (conn->common.fex_valid &&
 100ba16:	f890 20dc 	ldrb.w	r2, [r0, #220]	; 0xdc
	if (conn->llcp_length.disabled ||
 100ba1a:	07d1      	lsls	r1, r2, #31
 100ba1c:	d419      	bmi.n	100ba52 <ll_length_req_send+0x62>
	if (conn->llcp_length.req != conn->llcp_length.ack) {
 100ba1e:	f890 1198 	ldrb.w	r1, [r0, #408]	; 0x198
 100ba22:	f890 2199 	ldrb.w	r2, [r0, #409]	; 0x199
 100ba26:	428a      	cmp	r2, r1
 100ba28:	d01d      	beq.n	100ba66 <ll_length_req_send+0x76>
		switch (conn->llcp_length.state) {
 100ba2a:	f003 0307 	and.w	r3, r3, #7
 100ba2e:	2b03      	cmp	r3, #3
 100ba30:	d004      	beq.n	100ba3c <ll_length_req_send+0x4c>
 100ba32:	3303      	adds	r3, #3
 100ba34:	f003 0307 	and.w	r3, r3, #7
 100ba38:	2b01      	cmp	r3, #1
 100ba3a:	d810      	bhi.n	100ba5e <ll_length_req_send+0x6e>
			if (!conn->llcp_length.cache.tx_octets) {
 100ba3c:	f8b0 31a4 	ldrh.w	r3, [r0, #420]	; 0x1a4
 100ba40:	b96b      	cbnz	r3, 100ba5e <ll_length_req_send+0x6e>
				conn->llcp_length.cache.tx_octets = tx_octets;
 100ba42:	f8a0 61a4 	strh.w	r6, [r0, #420]	; 0x1a4
				conn->llcp_length.cache.tx_time = tx_time;
 100ba46:	f8a0 51a6 	strh.w	r5, [r0, #422]	; 0x1a6
				return 0;
 100ba4a:	4618      	mov	r0, r3
}
 100ba4c:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100ba4e:	2002      	movs	r0, #2
}
 100ba50:	bd70      	pop	{r4, r5, r6, pc}
	     !(conn->llcp_feature.features & BIT(BT_LE_FEAT_BIT_DLE)))) {
 100ba52:	f8d0 211c 	ldr.w	r2, [r0, #284]	; 0x11c
	    (conn->common.fex_valid &&
 100ba56:	0692      	lsls	r2, r2, #26
 100ba58:	d4e1      	bmi.n	100ba1e <ll_length_req_send+0x2e>
		return BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
 100ba5a:	201a      	movs	r0, #26
}
 100ba5c:	bd70      	pop	{r4, r5, r6, pc}
			return BT_HCI_ERR_CMD_DISALLOWED;
 100ba5e:	200c      	movs	r0, #12
}
 100ba60:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100ba62:	2002      	movs	r0, #2
}
 100ba64:	4770      	bx	lr
	conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
 100ba66:	f890 319a 	ldrb.w	r3, [r0, #410]	; 0x19a
	conn->llcp_length.req++;
 100ba6a:	3201      	adds	r2, #1
	conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
 100ba6c:	f36f 0302 	bfc	r3, #0, #3
	conn->llcp_length.req++;
 100ba70:	f880 2198 	strb.w	r2, [r0, #408]	; 0x198
	conn->llcp_length.tx_octets = tx_octets;
 100ba74:	f8a0 619e 	strh.w	r6, [r0, #414]	; 0x19e
	conn->llcp_length.tx_time = tx_time;
 100ba78:	f8a0 51a2 	strh.w	r5, [r0, #418]	; 0x1a2
	conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
 100ba7c:	f880 319a 	strb.w	r3, [r0, #410]	; 0x19a
	return 0;
 100ba80:	2000      	movs	r0, #0
}
 100ba82:	bd70      	pop	{r4, r5, r6, pc}
 100ba84:	21002bd0 	.word	0x21002bd0

0100ba88 <ll_length_default_get>:
	*max_tx_octets = default_tx_octets;
 100ba88:	4a03      	ldr	r2, [pc, #12]	; (100ba98 <ll_length_default_get+0x10>)
	*max_tx_time = default_tx_time;
 100ba8a:	4b04      	ldr	r3, [pc, #16]	; (100ba9c <ll_length_default_get+0x14>)
	*max_tx_octets = default_tx_octets;
 100ba8c:	8812      	ldrh	r2, [r2, #0]
	*max_tx_time = default_tx_time;
 100ba8e:	881b      	ldrh	r3, [r3, #0]
	*max_tx_octets = default_tx_octets;
 100ba90:	8002      	strh	r2, [r0, #0]
	*max_tx_time = default_tx_time;
 100ba92:	800b      	strh	r3, [r1, #0]
}
 100ba94:	4770      	bx	lr
 100ba96:	bf00      	nop
 100ba98:	2100805a 	.word	0x2100805a
 100ba9c:	2100805c 	.word	0x2100805c

0100baa0 <ll_length_default_set>:
	default_tx_octets = max_tx_octets;
 100baa0:	4a02      	ldr	r2, [pc, #8]	; (100baac <ll_length_default_set+0xc>)
	default_tx_time = max_tx_time;
 100baa2:	4b03      	ldr	r3, [pc, #12]	; (100bab0 <ll_length_default_set+0x10>)
	default_tx_octets = max_tx_octets;
 100baa4:	8010      	strh	r0, [r2, #0]
	default_tx_time = max_tx_time;
 100baa6:	8019      	strh	r1, [r3, #0]
}
 100baa8:	2000      	movs	r0, #0
 100baaa:	4770      	bx	lr
 100baac:	2100805a 	.word	0x2100805a
 100bab0:	2100805c 	.word	0x2100805c

0100bab4 <ll_length_max_get>:
{
 100bab4:	b430      	push	{r4, r5}
	*max_tx_octets = LL_LENGTH_OCTETS_RX_MAX;
 100bab6:	25fb      	movs	r5, #251	; 0xfb
	*max_tx_time = PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_CODED);
 100bab8:	f244 2490 	movw	r4, #17040	; 0x4290
	*max_tx_octets = LL_LENGTH_OCTETS_RX_MAX;
 100babc:	8005      	strh	r5, [r0, #0]
	*max_rx_octets = LL_LENGTH_OCTETS_RX_MAX;
 100babe:	8015      	strh	r5, [r2, #0]
	*max_tx_time = PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_CODED);
 100bac0:	800c      	strh	r4, [r1, #0]
	*max_rx_time = PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_CODED);
 100bac2:	801c      	strh	r4, [r3, #0]
}
 100bac4:	bc30      	pop	{r4, r5}
 100bac6:	4770      	bx	lr

0100bac8 <ll_phy_get>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100bac8:	280f      	cmp	r0, #15
 100baca:	d81b      	bhi.n	100bb04 <ll_phy_get+0x3c>
{
 100bacc:	b570      	push	{r4, r5, r6, lr}
 100bace:	4604      	mov	r4, r0
 100bad0:	460e      	mov	r6, r1
 100bad2:	4615      	mov	r5, r2
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100bad4:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100bad8:	4602      	mov	r2, r0
 100bada:	480b      	ldr	r0, [pc, #44]	; (100bb08 <ll_phy_get+0x40>)
 100badc:	f7fa f94e 	bl	1005d7c <mem_get>
	if (conn->lll.handle != handle) {
 100bae0:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100bae2:	4603      	mov	r3, r0
	if (conn->lll.handle != handle) {
 100bae4:	42a2      	cmp	r2, r4
 100bae6:	d10b      	bne.n	100bb00 <ll_phy_get+0x38>
	*tx = conn->lll.phy_tx;
 100bae8:	f893 2064 	ldrb.w	r2, [r3, #100]	; 0x64
	return 0;
 100baec:	2000      	movs	r0, #0
	*tx = conn->lll.phy_tx;
 100baee:	f3c2 0202 	ubfx	r2, r2, #0, #3
 100baf2:	7032      	strb	r2, [r6, #0]
	*rx = conn->lll.phy_rx;
 100baf4:	f893 3065 	ldrb.w	r3, [r3, #101]	; 0x65
 100baf8:	f3c3 0302 	ubfx	r3, r3, #0, #3
 100bafc:	702b      	strb	r3, [r5, #0]
}
 100bafe:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100bb00:	2002      	movs	r0, #2
}
 100bb02:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100bb04:	2002      	movs	r0, #2
}
 100bb06:	4770      	bx	lr
 100bb08:	21002bd0 	.word	0x21002bd0

0100bb0c <ll_phy_default_set>:
	default_phy_tx = tx;
 100bb0c:	4a02      	ldr	r2, [pc, #8]	; (100bb18 <ll_phy_default_set+0xc>)
	default_phy_rx = rx;
 100bb0e:	4b03      	ldr	r3, [pc, #12]	; (100bb1c <ll_phy_default_set+0x10>)
	default_phy_tx = tx;
 100bb10:	7010      	strb	r0, [r2, #0]
	default_phy_rx = rx;
 100bb12:	7019      	strb	r1, [r3, #0]
}
 100bb14:	2000      	movs	r0, #0
 100bb16:	4770      	bx	lr
 100bb18:	210080c5 	.word	0x210080c5
 100bb1c:	210080c4 	.word	0x210080c4

0100bb20 <ll_phy_req_send>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100bb20:	280f      	cmp	r0, #15
 100bb22:	d84d      	bhi.n	100bbc0 <ll_phy_req_send+0xa0>
{
 100bb24:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100bb28:	4605      	mov	r5, r0
 100bb2a:	4688      	mov	r8, r1
 100bb2c:	4616      	mov	r6, r2
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100bb2e:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100bb32:	4602      	mov	r2, r0
 100bb34:	4823      	ldr	r0, [pc, #140]	; (100bbc4 <ll_phy_req_send+0xa4>)
 100bb36:	461f      	mov	r7, r3
 100bb38:	f7fa f920 	bl	1005d7c <mem_get>
	if (conn->lll.handle != handle) {
 100bb3c:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100bb3e:	4604      	mov	r4, r0
	if (conn->lll.handle != handle) {
 100bb40:	42ab      	cmp	r3, r5
 100bb42:	d12f      	bne.n	100bba4 <ll_phy_req_send+0x84>
	if (conn->llcp_phy.disabled ||
 100bb44:	f890 01ab 	ldrb.w	r0, [r0, #427]	; 0x1ab
 100bb48:	f010 0008 	ands.w	r0, r0, #8
 100bb4c:	d135      	bne.n	100bbba <ll_phy_req_send+0x9a>
	    (conn->common.fex_valid &&
 100bb4e:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
	if (conn->llcp_phy.disabled ||
 100bb52:	07db      	lsls	r3, r3, #31
 100bb54:	d42c      	bmi.n	100bbb0 <ll_phy_req_send+0x90>
	if ((conn->llcp_req != conn->llcp_ack) ||
 100bb56:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
 100bb5a:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
 100bb5e:	429a      	cmp	r2, r3
 100bb60:	d123      	bne.n	100bbaa <ll_phy_req_send+0x8a>
	    (conn->llcp_phy.req != conn->llcp_phy.ack)) {
 100bb62:	f894 31a8 	ldrb.w	r3, [r4, #424]	; 0x1a8
	if ((conn->llcp_req != conn->llcp_ack) ||
 100bb66:	f894 21a9 	ldrb.w	r2, [r4, #425]	; 0x1a9
 100bb6a:	429a      	cmp	r2, r3
 100bb6c:	d11d      	bne.n	100bbaa <ll_phy_req_send+0x8a>
	conn->llcp_phy.state = LLCP_PHY_STATE_REQ;
 100bb6e:	f008 0107 	and.w	r1, r8, #7
 100bb72:	f8b4 51aa 	ldrh.w	r5, [r4, #426]	; 0x1aa
 100bb76:	0089      	lsls	r1, r1, #2
 100bb78:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
 100bb7c:	f007 0307 	and.w	r3, r7, #7
 100bb80:	ea41 1343 	orr.w	r3, r1, r3, lsl #5
 100bb84:	f006 0601 	and.w	r6, r6, #1
 100bb88:	f425 61df 	bic.w	r1, r5, #1784	; 0x6f8
 100bb8c:	ea43 2346 	orr.w	r3, r3, r6, lsl #9
 100bb90:	f021 0107 	bic.w	r1, r1, #7
	conn->llcp_phy.req++;
 100bb94:	3201      	adds	r2, #1
	conn->llcp_phy.state = LLCP_PHY_STATE_REQ;
 100bb96:	430b      	orrs	r3, r1
	conn->llcp_phy.req++;
 100bb98:	f884 21a8 	strb.w	r2, [r4, #424]	; 0x1a8
	conn->llcp_phy.state = LLCP_PHY_STATE_REQ;
 100bb9c:	f8a4 31aa 	strh.w	r3, [r4, #426]	; 0x1aa
}
 100bba0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100bba4:	2002      	movs	r0, #2
}
 100bba6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100bbaa:	200c      	movs	r0, #12
}
 100bbac:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	     !(conn->llcp_feature.features & BIT(BT_LE_FEAT_BIT_PHY_2M)) &&
 100bbb0:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
 100bbb4:	f413 6f10 	tst.w	r3, #2304	; 0x900
 100bbb8:	d1cd      	bne.n	100bb56 <ll_phy_req_send+0x36>
		return BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
 100bbba:	201a      	movs	r0, #26
}
 100bbbc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100bbc0:	2002      	movs	r0, #2
}
 100bbc2:	4770      	bx	lr
 100bbc4:	21002bd0 	.word	0x21002bd0

0100bbc8 <ll_rssi_get>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100bbc8:	280f      	cmp	r0, #15
 100bbca:	d813      	bhi.n	100bbf4 <ll_rssi_get+0x2c>
{
 100bbcc:	b538      	push	{r3, r4, r5, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100bbce:	4602      	mov	r2, r0
 100bbd0:	4604      	mov	r4, r0
 100bbd2:	460d      	mov	r5, r1
 100bbd4:	4808      	ldr	r0, [pc, #32]	; (100bbf8 <ll_rssi_get+0x30>)
 100bbd6:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100bbda:	f7fa f8cf 	bl	1005d7c <mem_get>
	if (conn->lll.handle != handle) {
 100bbde:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100bbe0:	4603      	mov	r3, r0
	if (conn->lll.handle != handle) {
 100bbe2:	42a2      	cmp	r2, r4
 100bbe4:	d104      	bne.n	100bbf0 <ll_rssi_get+0x28>
	*rssi = conn->lll.rssi_latest;
 100bbe6:	f893 30c1 	ldrb.w	r3, [r3, #193]	; 0xc1
	return 0;
 100bbea:	2000      	movs	r0, #0
	*rssi = conn->lll.rssi_latest;
 100bbec:	702b      	strb	r3, [r5, #0]
}
 100bbee:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100bbf0:	200c      	movs	r0, #12
}
 100bbf2:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100bbf4:	200c      	movs	r0, #12
}
 100bbf6:	4770      	bx	lr
 100bbf8:	21002bd0 	.word	0x21002bd0

0100bbfc <ll_apto_get>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100bbfc:	280f      	cmp	r0, #15
 100bbfe:	d81e      	bhi.n	100bc3e <ll_apto_get+0x42>
{
 100bc00:	b538      	push	{r3, r4, r5, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100bc02:	4602      	mov	r2, r0
 100bc04:	4604      	mov	r4, r0
 100bc06:	460d      	mov	r5, r1
 100bc08:	480e      	ldr	r0, [pc, #56]	; (100bc44 <ll_apto_get+0x48>)
 100bc0a:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100bc0e:	f7fa f8b5 	bl	1005d7c <mem_get>
	if (conn->lll.handle != handle) {
 100bc12:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100bc14:	4602      	mov	r2, r0
	if (conn->lll.handle != handle) {
 100bc16:	42a3      	cmp	r3, r4
 100bc18:	d10f      	bne.n	100bc3a <ll_apto_get+0x3e>
	*apto = conn->apto_reload * conn->lll.interval * 125U / 1000;
 100bc1a:	f8b2 10d2 	ldrh.w	r1, [r2, #210]	; 0xd2
 100bc1e:	8dd3      	ldrh	r3, [r2, #46]	; 0x2e
 100bc20:	4a09      	ldr	r2, [pc, #36]	; (100bc48 <ll_apto_get+0x4c>)
 100bc22:	fb03 f301 	mul.w	r3, r3, r1
 100bc26:	ebc3 1143 	rsb	r1, r3, r3, lsl #5
 100bc2a:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 100bc2e:	fba2 2303 	umull	r2, r3, r2, r3
 100bc32:	099b      	lsrs	r3, r3, #6
	return 0;
 100bc34:	2000      	movs	r0, #0
	*apto = conn->apto_reload * conn->lll.interval * 125U / 1000;
 100bc36:	802b      	strh	r3, [r5, #0]
}
 100bc38:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100bc3a:	2002      	movs	r0, #2
}
 100bc3c:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100bc3e:	2002      	movs	r0, #2
}
 100bc40:	4770      	bx	lr
 100bc42:	bf00      	nop
 100bc44:	21002bd0 	.word	0x21002bd0
 100bc48:	10624dd3 	.word	0x10624dd3

0100bc4c <ll_apto_set>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100bc4c:	280f      	cmp	r0, #15
 100bc4e:	d81e      	bhi.n	100bc8e <ll_apto_set+0x42>
{
 100bc50:	b538      	push	{r3, r4, r5, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100bc52:	4602      	mov	r2, r0
 100bc54:	4604      	mov	r4, r0
 100bc56:	460d      	mov	r5, r1
 100bc58:	480e      	ldr	r0, [pc, #56]	; (100bc94 <ll_apto_set+0x48>)
 100bc5a:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100bc5e:	f7fa f88d 	bl	1005d7c <mem_get>
	if (conn->lll.handle != handle) {
 100bc62:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100bc64:	4602      	mov	r2, r0
	if (conn->lll.handle != handle) {
 100bc66:	42a3      	cmp	r3, r4
 100bc68:	d10f      	bne.n	100bc8a <ll_apto_set+0x3e>
	conn->apto_reload = RADIO_CONN_EVENTS(apto * 10U * 1000U,
 100bc6a:	f240 44e2 	movw	r4, #1250	; 0x4e2
 100bc6e:	f242 7310 	movw	r3, #10000	; 0x2710
 100bc72:	8dc1      	ldrh	r1, [r0, #46]	; 0x2e
	return 0;
 100bc74:	2000      	movs	r0, #0
	conn->apto_reload = RADIO_CONN_EVENTS(apto * 10U * 1000U,
 100bc76:	fb04 f401 	mul.w	r4, r4, r1
 100bc7a:	fb03 4305 	mla	r3, r3, r5, r4
 100bc7e:	3b01      	subs	r3, #1
 100bc80:	fbb3 f3f4 	udiv	r3, r3, r4
 100bc84:	f8a2 30d2 	strh.w	r3, [r2, #210]	; 0xd2
}
 100bc88:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100bc8a:	2002      	movs	r0, #2
}
 100bc8c:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100bc8e:	2002      	movs	r0, #2
}
 100bc90:	4770      	bx	lr
 100bc92:	bf00      	nop
 100bc94:	21002bd0 	.word	0x21002bd0

0100bc98 <ull_conn_init>:
	err = init_reset();
 100bc98:	f7ff ba78 	b.w	100b18c <init_reset>

0100bc9c <ull_conn_reset>:
{
 100bc9c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 100bca0:	b085      	sub	sp, #20
 100bca2:	2500      	movs	r5, #0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100bca4:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 100bd68 <ull_conn_reset+0xcc>
	LL_ASSERT(mark == conn);
 100bca8:	4f29      	ldr	r7, [pc, #164]	; (100bd50 <ull_conn_reset+0xb4>)
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
 100bcaa:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 100bd6c <ull_conn_reset+0xd0>
 100bcae:	ae03      	add	r6, sp, #12
 100bcb0:	e00d      	b.n	100bcce <ull_conn_reset+0x32>
	conn->lll.link_tx_free = NULL;
 100bcb2:	2300      	movs	r3, #0
	mark = ull_disable_unmark(conn);
 100bcb4:	4620      	mov	r0, r4
	conn->lll.link_tx_free = NULL;
 100bcb6:	67a3      	str	r3, [r4, #120]	; 0x78
	mark = ull_disable_unmark(conn);
 100bcb8:	f7fe fae8 	bl	100a28c <ull_disable_unmark>
	LL_ASSERT(mark == conn);
 100bcbc:	4284      	cmp	r4, r0
 100bcbe:	d004      	beq.n	100bcca <ull_conn_reset+0x2e>
 100bcc0:	f240 61a4 	movw	r1, #1700	; 0x6a4
 100bcc4:	4638      	mov	r0, r7
 100bcc6:	f7f7 fcdb 	bl	1003680 <bt_ctlr_assert_handle>
	for (handle = 0U; handle < CONFIG_BT_MAX_CONN; handle++) {
 100bcca:	2d10      	cmp	r5, #16
 100bccc:	d02b      	beq.n	100bd26 <ull_conn_reset+0x8a>
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 100bcce:	2302      	movs	r3, #2
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100bcd0:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100bcd4:	b2aa      	uxth	r2, r5
 100bcd6:	4648      	mov	r0, r9
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 100bcd8:	9303      	str	r3, [sp, #12]
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100bcda:	f7fa f84f 	bl	1005d7c <mem_get>
 100bcde:	4604      	mov	r4, r0
	mark = ull_disable_mark(conn);
 100bce0:	f7fe faca 	bl	100a278 <ull_disable_mark>
	LL_ASSERT(mark == conn);
 100bce4:	4284      	cmp	r4, r0
 100bce6:	d004      	beq.n	100bcf2 <ull_conn_reset+0x56>
 100bce8:	f240 6195 	movw	r1, #1685	; 0x695
 100bcec:	4638      	mov	r0, r7
 100bcee:	f7f7 fcc7 	bl	1003680 <bt_ctlr_assert_handle>
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
 100bcf2:	1d6a      	adds	r2, r5, #5
 100bcf4:	4643      	mov	r3, r8
 100bcf6:	2103      	movs	r1, #3
 100bcf8:	b2d2      	uxtb	r2, r2
 100bcfa:	2000      	movs	r0, #0
 100bcfc:	9600      	str	r6, [sp, #0]
 100bcfe:	f7fb fb15 	bl	100732c <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
 100bd02:	4631      	mov	r1, r6
 100bd04:	f7fe faaa 	bl	100a25c <ull_ticker_status_take>
	if (!ret) {
 100bd08:	3501      	adds	r5, #1
 100bd0a:	2800      	cmp	r0, #0
 100bd0c:	d1d1      	bne.n	100bcb2 <ull_conn_reset+0x16>
		ret = ull_disable(&conn->lll);
 100bd0e:	f104 001c 	add.w	r0, r4, #28
 100bd12:	f7fe faed 	bl	100a2f0 <ull_disable>
		LL_ASSERT(!ret);
 100bd16:	2800      	cmp	r0, #0
 100bd18:	d0cb      	beq.n	100bcb2 <ull_conn_reset+0x16>
 100bd1a:	f240 619e 	movw	r1, #1694	; 0x69e
 100bd1e:	4638      	mov	r0, r7
 100bd20:	f7f7 fcae 	bl	1003680 <bt_ctlr_assert_handle>
 100bd24:	e7c5      	b.n	100bcb2 <ull_conn_reset+0x16>
	data_chan_map[0] = 0xFF;
 100bd26:	f04f 30ff 	mov.w	r0, #4294967295
	data_chan_map[4] = 0x1F;
 100bd2a:	211f      	movs	r1, #31
	MFIFO_INIT(conn_tx);
 100bd2c:	2300      	movs	r3, #0
	data_chan_count = 37U;
 100bd2e:	2525      	movs	r5, #37	; 0x25
	data_chan_map[0] = 0xFF;
 100bd30:	4a08      	ldr	r2, [pc, #32]	; (100bd54 <ull_conn_reset+0xb8>)
	data_chan_count = 37U;
 100bd32:	4c09      	ldr	r4, [pc, #36]	; (100bd58 <ull_conn_reset+0xbc>)
	data_chan_map[0] = 0xFF;
 100bd34:	6010      	str	r0, [r2, #0]
	data_chan_map[4] = 0x1F;
 100bd36:	7111      	strb	r1, [r2, #4]
	MFIFO_INIT(conn_tx);
 100bd38:	4808      	ldr	r0, [pc, #32]	; (100bd5c <ull_conn_reset+0xc0>)
	MFIFO_INIT(conn_ack);
 100bd3a:	4909      	ldr	r1, [pc, #36]	; (100bd60 <ull_conn_reset+0xc4>)
	conn_upd_curr = NULL;
 100bd3c:	4a09      	ldr	r2, [pc, #36]	; (100bd64 <ull_conn_reset+0xc8>)
	MFIFO_INIT(conn_tx);
 100bd3e:	8043      	strh	r3, [r0, #2]
	MFIFO_INIT(conn_ack);
 100bd40:	804b      	strh	r3, [r1, #2]
	data_chan_count = 37U;
 100bd42:	7025      	strb	r5, [r4, #0]
	conn_upd_curr = NULL;
 100bd44:	6013      	str	r3, [r2, #0]
	err = init_reset();
 100bd46:	f7ff fa21 	bl	100b18c <init_reset>
}
 100bd4a:	b005      	add	sp, #20
 100bd4c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 100bd50:	01018934 	.word	0x01018934
 100bd54:	21000314 	.word	0x21000314
 100bd58:	21000500 	.word	0x21000500
 100bd5c:	21000398 	.word	0x21000398
 100bd60:	2100031c 	.word	0x2100031c
 100bd64:	21004850 	.word	0x21004850
 100bd68:	21002bd0 	.word	0x21002bd0
 100bd6c:	0100a251 	.word	0x0100a251

0100bd70 <ull_conn_chan_map_cpy>:
{
 100bd70:	b508      	push	{r3, lr}
	memcpy(chan_map, data_chan_map, sizeof(data_chan_map));
 100bd72:	2205      	movs	r2, #5
 100bd74:	4902      	ldr	r1, [pc, #8]	; (100bd80 <ull_conn_chan_map_cpy+0x10>)
 100bd76:	f00a fe4f 	bl	1016a18 <memcpy>
	return data_chan_count;
 100bd7a:	4b02      	ldr	r3, [pc, #8]	; (100bd84 <ull_conn_chan_map_cpy+0x14>)
}
 100bd7c:	7818      	ldrb	r0, [r3, #0]
 100bd7e:	bd08      	pop	{r3, pc}
 100bd80:	21000314 	.word	0x21000314
 100bd84:	21000500 	.word	0x21000500

0100bd88 <ull_conn_chan_map_set>:
{
 100bd88:	b510      	push	{r4, lr}
	memcpy(data_chan_map, chan_map, sizeof(data_chan_map));
 100bd8a:	4c06      	ldr	r4, [pc, #24]	; (100bda4 <ull_conn_chan_map_set+0x1c>)
{
 100bd8c:	4601      	mov	r1, r0
	memcpy(data_chan_map, chan_map, sizeof(data_chan_map));
 100bd8e:	2205      	movs	r2, #5
 100bd90:	4620      	mov	r0, r4
 100bd92:	f00a fe41 	bl	1016a18 <memcpy>
	data_chan_count = util_ones_count_get(data_chan_map,
 100bd96:	4620      	mov	r0, r4
 100bd98:	2105      	movs	r1, #5
 100bd9a:	f7fa f989 	bl	10060b0 <util_ones_count_get>
 100bd9e:	4b02      	ldr	r3, [pc, #8]	; (100bda8 <ull_conn_chan_map_set+0x20>)
 100bda0:	7018      	strb	r0, [r3, #0]
}
 100bda2:	bd10      	pop	{r4, pc}
 100bda4:	21000314 	.word	0x21000314
 100bda8:	21000500 	.word	0x21000500

0100bdac <ull_conn_default_tx_octets_get>:
	return default_tx_octets;
 100bdac:	4b01      	ldr	r3, [pc, #4]	; (100bdb4 <ull_conn_default_tx_octets_get+0x8>)
}
 100bdae:	8818      	ldrh	r0, [r3, #0]
 100bdb0:	4770      	bx	lr
 100bdb2:	bf00      	nop
 100bdb4:	2100805a 	.word	0x2100805a

0100bdb8 <ull_conn_default_tx_time_get>:
	return default_tx_time;
 100bdb8:	4b01      	ldr	r3, [pc, #4]	; (100bdc0 <ull_conn_default_tx_time_get+0x8>)
}
 100bdba:	8818      	ldrh	r0, [r3, #0]
 100bdbc:	4770      	bx	lr
 100bdbe:	bf00      	nop
 100bdc0:	2100805c 	.word	0x2100805c

0100bdc4 <ull_conn_default_phy_tx_get>:
	return default_phy_tx;
 100bdc4:	4b01      	ldr	r3, [pc, #4]	; (100bdcc <ull_conn_default_phy_tx_get+0x8>)
}
 100bdc6:	7818      	ldrb	r0, [r3, #0]
 100bdc8:	4770      	bx	lr
 100bdca:	bf00      	nop
 100bdcc:	210080c5 	.word	0x210080c5

0100bdd0 <ull_conn_default_phy_rx_get>:
	return default_phy_rx;
 100bdd0:	4b01      	ldr	r3, [pc, #4]	; (100bdd8 <ull_conn_default_phy_rx_get+0x8>)
}
 100bdd2:	7818      	ldrb	r0, [r3, #0]
 100bdd4:	4770      	bx	lr
 100bdd6:	bf00      	nop
 100bdd8:	210080c4 	.word	0x210080c4

0100bddc <ull_conn_setup>:
{
 100bddc:	460a      	mov	r2, r1
	lll = *((struct lll_conn **)((u8_t *)ftr->param +
 100bdde:	688b      	ldr	r3, [r1, #8]
{
 100bde0:	b410      	push	{r4}
	lll = *((struct lll_conn **)((u8_t *)ftr->param +
 100bde2:	689b      	ldr	r3, [r3, #8]
	ftr = &(rx->rx_ftr);
 100bde4:	3208      	adds	r2, #8
	switch (lll->role) {
 100bde6:	f893 4021 	ldrb.w	r4, [r3, #33]	; 0x21
 100bdea:	09e4      	lsrs	r4, r4, #7
 100bdec:	d002      	beq.n	100bdf4 <ull_conn_setup+0x18>
}
 100bdee:	bc10      	pop	{r4}
		ull_slave_setup(link, rx, ftr, lll);
 100bdf0:	f7f6 bc72 	b.w	10026d8 <ull_slave_setup>
}
 100bdf4:	bc10      	pop	{r4}
		ull_master_setup(link, rx, ftr, lll);
 100bdf6:	f7f6 bec3 	b.w	1002b80 <ull_master_setup>
 100bdfa:	bf00      	nop

0100bdfc <ull_conn_rx>:
{
 100bdfc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	conn = ll_connected_get((*rx)->hdr.handle);
 100be00:	680b      	ldr	r3, [r1, #0]
{
 100be02:	b085      	sub	sp, #20
	conn = ll_connected_get((*rx)->hdr.handle);
 100be04:	88de      	ldrh	r6, [r3, #6]
	if (handle >= CONFIG_BT_MAX_CONN) {
 100be06:	2e0f      	cmp	r6, #15
 100be08:	d85e      	bhi.n	100bec8 <ull_conn_rx+0xcc>
 100be0a:	460c      	mov	r4, r1
 100be0c:	4607      	mov	r7, r0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100be0e:	4632      	mov	r2, r6
 100be10:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100be14:	48ba      	ldr	r0, [pc, #744]	; (100c100 <ull_conn_rx+0x304>)
 100be16:	f7f9 ffb1 	bl	1005d7c <mem_get>
	if (conn->lll.handle != handle) {
 100be1a:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100be1c:	4605      	mov	r5, r0
	if (conn->lll.handle != handle) {
 100be1e:	42b3      	cmp	r3, r6
 100be20:	d151      	bne.n	100bec6 <ull_conn_rx+0xca>
	pdu_rx = (void *)(*rx)->pdu;
 100be22:	6822      	ldr	r2, [r4, #0]
	switch (pdu_rx->ll_id) {
 100be24:	f892 3020 	ldrb.w	r3, [r2, #32]
	pdu_rx = (void *)(*rx)->pdu;
 100be28:	4616      	mov	r6, r2
	switch (pdu_rx->ll_id) {
 100be2a:	f003 0303 	and.w	r3, r3, #3
 100be2e:	2b03      	cmp	r3, #3
 100be30:	d150      	bne.n	100bed4 <ull_conn_rx+0xd8>

	opcode = pdu_rx->llctrl.opcode;

#if defined(CONFIG_BT_CTLR_LE_ENC)
	/* FIXME: do check in individual case to reduce CPU time */
	if (conn->llcp_enc.pause_rx && ctrl_is_unexpected(conn, opcode)) {
 100be32:	f890 3152 	ldrb.w	r3, [r0, #338]	; 0x152
	opcode = pdu_rx->llctrl.opcode;
 100be36:	f892 9023 	ldrb.w	r9, [r2, #35]	; 0x23
	if (conn->llcp_enc.pause_rx && ctrl_is_unexpected(conn, opcode)) {
 100be3a:	07d8      	lsls	r0, r3, #31
 100be3c:	d55a      	bpl.n	100bef4 <ull_conn_rx+0xf8>
		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)))) ||
 100be3e:	f995 203d 	ldrsb.w	r2, [r5, #61]	; 0x3d
 100be42:	2a00      	cmp	r2, #0
 100be44:	f2c0 80e8 	blt.w	100c018 <ull_conn_rx+0x21c>
	return (!conn->lll.role &&
 100be48:	0759      	lsls	r1, r3, #29
 100be4a:	f140 8688 	bpl.w	100cb5e <ull_conn_rx+0xd62>
		 (conn->llcp_enc.refresh &&
 100be4e:	f1b9 0f02 	cmp.w	r9, #2
 100be52:	f000 8389 	beq.w	100c568 <ull_conn_rx+0x76c>
		  (opcode != PDU_DATA_LLCTRL_TYPE_TERMINATE_IND) &&
 100be56:	f1b9 0f0b 	cmp.w	r9, #11
 100be5a:	f000 868c 	beq.w	100cb76 <ull_conn_rx+0xd7a>
		  (opcode != PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP) &&
 100be5e:	f1b9 0f04 	cmp.w	r9, #4
 100be62:	f000 856a 	beq.w	100c93a <ull_conn_rx+0xb3e>
		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)) ||
 100be66:	f1b9 0f05 	cmp.w	r9, #5
 100be6a:	f000 858a 	beq.w	100c982 <ull_conn_rx+0xb86>
 100be6e:	f1b9 0f06 	cmp.w	r9, #6
 100be72:	f000 808b 	beq.w	100bf8c <ull_conn_rx+0x190>
		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)) ||
 100be76:	f1b9 0f0d 	cmp.w	r9, #13
 100be7a:	f000 839b 	beq.w	100c5b4 <ull_conn_rx+0x7b8>
 100be7e:	f1b9 0f11 	cmp.w	r9, #17
 100be82:	d179      	bne.n	100bf78 <ull_conn_rx+0x17c>

		break;
#endif /* CONFIG_BT_CTLR_CONN_PARAM_REQ */

	case PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND:
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND,
 100be84:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100be88:	2b03      	cmp	r3, #3
 100be8a:	f040 8083 	bne.w	100bf94 <ull_conn_rx+0x198>
	switch (rej_ext_ind->reject_opcode) {
 100be8e:	f896 3024 	ldrb.w	r3, [r6, #36]	; 0x24
 100be92:	3b03      	subs	r3, #3
 100be94:	2b13      	cmp	r3, #19
 100be96:	f200 80ab 	bhi.w	100bff0 <ull_conn_rx+0x1f4>
 100be9a:	e8df f013 	tbh	[pc, r3, lsl #1]
 100be9e:	061c      	.short	0x061c
 100bea0:	00a900a9 	.word	0x00a900a9
 100bea4:	00a900a9 	.word	0x00a900a9
 100bea8:	00a900a9 	.word	0x00a900a9
 100beac:	00a900a9 	.word	0x00a900a9
 100beb0:	00a900a9 	.word	0x00a900a9
 100beb4:	05e800a9 	.word	0x05e800a9
 100beb8:	00a900a9 	.word	0x00a900a9
 100bebc:	00a900a9 	.word	0x00a900a9
 100bec0:	00a9063c 	.word	0x00a9063c
 100bec4:	05b1      	.short	0x05b1
 100bec6:	6823      	ldr	r3, [r4, #0]
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100bec8:	2203      	movs	r2, #3
		return 0;
 100beca:	2000      	movs	r0, #0
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100becc:	711a      	strb	r2, [r3, #4]
}
 100bece:	b005      	add	sp, #20
 100bed0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (pdu_rx->ll_id) {
 100bed4:	2b00      	cmp	r3, #0
 100bed6:	d149      	bne.n	100bf6c <ull_conn_rx+0x170>
		if (conn->llcp_enc.pause_rx) {
 100bed8:	f890 3152 	ldrb.w	r3, [r0, #338]	; 0x152
 100bedc:	07db      	lsls	r3, r3, #31
 100bede:	d503      	bpl.n	100bee8 <ull_conn_rx+0xec>
			conn->llcp_terminate.reason_peer =
 100bee0:	233d      	movs	r3, #61	; 0x3d
 100bee2:	f880 312b 	strb.w	r3, [r0, #299]	; 0x12b
 100bee6:	6822      	ldr	r2, [r4, #0]
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100bee8:	2303      	movs	r3, #3
	return 0;
 100beea:	2000      	movs	r0, #0
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100beec:	7113      	strb	r3, [r2, #4]
}
 100beee:	b005      	add	sp, #20
 100bef0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	pdu_rx = (void *)(*rx)->pdu;
 100bef4:	3220      	adds	r2, #32
	switch (opcode) {
 100bef6:	f1b9 0f19 	cmp.w	r9, #25
 100befa:	d84b      	bhi.n	100bf94 <ull_conn_rx+0x198>
 100befc:	a101      	add	r1, pc, #4	; (adr r1, 100bf04 <ull_conn_rx+0x108>)
 100befe:	f851 f029 	ldr.w	pc, [r1, r9, lsl #2]
 100bf02:	bf00      	nop
 100bf04:	0100c645 	.word	0x0100c645
 100bf08:	0100c725 	.word	0x0100c725
 100bf0c:	0100c569 	.word	0x0100c569
 100bf10:	0100c835 	.word	0x0100c835
 100bf14:	0100c931 	.word	0x0100c931
 100bf18:	0100c979 	.word	0x0100c979
 100bf1c:	0100c9b9 	.word	0x0100c9b9
 100bf20:	0100c793 	.word	0x0100c793
 100bf24:	0100c63b 	.word	0x0100c63b
 100bf28:	0100c2bb 	.word	0x0100c2bb
 100bf2c:	0100c21d 	.word	0x0100c21d
 100bf30:	0100c9d1 	.word	0x0100c9d1
 100bf34:	0100c5db 	.word	0x0100c5db
 100bf38:	0100c5b5 	.word	0x0100c5b5
 100bf3c:	0100c583 	.word	0x0100c583
 100bf40:	0100c531 	.word	0x0100c531
 100bf44:	0100c407 	.word	0x0100c407
 100bf48:	0100be85 	.word	0x0100be85
 100bf4c:	0100c1e9 	.word	0x0100c1e9
 100bf50:	0100c0eb 	.word	0x0100c0eb
 100bf54:	0100c07f 	.word	0x0100c07f
 100bf58:	0100c07f 	.word	0x0100c07f
 100bf5c:	0100c185 	.word	0x0100c185
 100bf60:	0100c109 	.word	0x0100c109
 100bf64:	0100c377 	.word	0x0100c377
 100bf68:	0100c307 	.word	0x0100c307
		if (conn->llcp_enc.pause_rx) {
 100bf6c:	f890 3152 	ldrb.w	r3, [r0, #338]	; 0x152
 100bf70:	07da      	lsls	r2, r3, #31
 100bf72:	d401      	bmi.n	100bf78 <ull_conn_rx+0x17c>
	int nack = 0;
 100bf74:	2000      	movs	r0, #0
 100bf76:	e7aa      	b.n	100bece <ull_conn_rx+0xd2>
		conn->llcp_terminate.reason_peer =
 100bf78:	233d      	movs	r3, #61	; 0x3d
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100bf7a:	2203      	movs	r2, #3
		return 0;
 100bf7c:	2000      	movs	r0, #0
		conn->llcp_terminate.reason_peer =
 100bf7e:	f885 312b 	strb.w	r3, [r5, #299]	; 0x12b
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100bf82:	6823      	ldr	r3, [r4, #0]
 100bf84:	711a      	strb	r2, [r3, #4]
}
 100bf86:	b005      	add	sp, #20
 100bf88:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_START_ENC_RSP,
 100bf8c:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100bf90:	2b01      	cmp	r3, #1
 100bf92:	d05f      	beq.n	100c054 <ull_conn_rx+0x258>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100bf94:	485b      	ldr	r0, [pc, #364]	; (100c104 <ull_conn_rx+0x308>)
 100bf96:	f7f9 febf 	bl	1005d18 <mem_acquire>
	if (!tx) {
 100bf9a:	2800      	cmp	r0, #0
 100bf9c:	f000 869c 	beq.w	100ccd8 <ull_conn_rx+0xedc>
	pdu->len = offsetof(struct pdu_data_llctrl, unknown_rsp) +
 100bfa0:	2302      	movs	r3, #2
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP;
 100bfa2:	2107      	movs	r1, #7
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 100bfa4:	7902      	ldrb	r2, [r0, #4]
	pdu->len = offsetof(struct pdu_data_llctrl, unknown_rsp) +
 100bfa6:	7143      	strb	r3, [r0, #5]
	    conn->tx_head &&
 100bfa8:	f8d5 31b0 	ldr.w	r3, [r5, #432]	; 0x1b0
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 100bfac:	f042 0203 	orr.w	r2, r2, #3
	pdu->llctrl.unknown_rsp.type = type;
 100bfb0:	f880 9008 	strb.w	r9, [r0, #8]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 100bfb4:	7102      	strb	r2, [r0, #4]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP;
 100bfb6:	71c1      	strb	r1, [r0, #7]
	if (
 100bfb8:	b303      	cbz	r3, 100bffc <ull_conn_rx+0x200>
	    !conn->llcp_enc.pause_tx &&
 100bfba:	f895 2152 	ldrb.w	r2, [r5, #338]	; 0x152
	    conn->tx_head &&
 100bfbe:	0794      	lsls	r4, r2, #30
 100bfc0:	d41c      	bmi.n	100bffc <ull_conn_rx+0x200>
	    !conn->llcp_phy.pause_tx &&
 100bfc2:	f895 21ab 	ldrb.w	r2, [r5, #427]	; 0x1ab
 100bfc6:	07d1      	lsls	r1, r2, #31
 100bfc8:	d418      	bmi.n	100bffc <ull_conn_rx+0x200>
		if (conn->tx_head == conn->tx_data) {
 100bfca:	f8d5 21bc 	ldr.w	r2, [r5, #444]	; 0x1bc
 100bfce:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 100bfd0:	bf04      	itt	eq
 100bfd2:	681a      	ldreq	r2, [r3, #0]
 100bfd4:	f8c5 21bc 	streq.w	r2, [r5, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 100bfd8:	f8d5 21b4 	ldr.w	r2, [r5, #436]	; 0x1b4
 100bfdc:	b99a      	cbnz	r2, 100c006 <ull_conn_rx+0x20a>
			tx->next = conn->tx_head->next;
 100bfde:	681a      	ldr	r2, [r3, #0]
 100bfe0:	6002      	str	r2, [r0, #0]
			conn->tx_head->next = tx;
 100bfe2:	6018      	str	r0, [r3, #0]
				conn->tx_ctrl = tx;
 100bfe4:	6803      	ldr	r3, [r0, #0]
				conn->tx_ctrl_last = tx;
 100bfe6:	e9c5 006d 	strd	r0, r0, [r5, #436]	; 0x1b4
	if (!tx->next) {
 100bfea:	2b00      	cmp	r3, #0
 100bfec:	f000 85b3 	beq.w	100cb56 <ull_conn_rx+0xd5a>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100bff0:	2303      	movs	r3, #3
	return 0;
 100bff2:	2000      	movs	r0, #0
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100bff4:	7133      	strb	r3, [r6, #4]
}
 100bff6:	b005      	add	sp, #20
 100bff8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!conn->tx_ctrl) {
 100bffc:	f8d5 21b4 	ldr.w	r2, [r5, #436]	; 0x1b4
 100c000:	2a00      	cmp	r2, #0
 100c002:	f000 85b1 	beq.w	100cb68 <ull_conn_rx+0xd6c>
	tx->next = conn->tx_ctrl_last->next;
 100c006:	f8d5 31b8 	ldr.w	r3, [r5, #440]	; 0x1b8
 100c00a:	681a      	ldr	r2, [r3, #0]
 100c00c:	6002      	str	r2, [r0, #0]
	conn->tx_ctrl_last->next = tx;
 100c00e:	6018      	str	r0, [r3, #0]
	conn->tx_ctrl_last = tx;
 100c010:	f8c5 01b8 	str.w	r0, [r5, #440]	; 0x1b8
 100c014:	6803      	ldr	r3, [r0, #0]
}
 100c016:	e7e8      	b.n	100bfea <ull_conn_rx+0x1ee>
	       (conn->lll.role &&
 100c018:	075a      	lsls	r2, r3, #29
 100c01a:	f140 829d 	bpl.w	100c558 <ull_conn_rx+0x75c>
		 (conn->llcp_enc.refresh &&
 100c01e:	f1b9 0f02 	cmp.w	r9, #2
 100c022:	f000 82a1 	beq.w	100c568 <ull_conn_rx+0x76c>
		  (opcode != PDU_DATA_LLCTRL_TYPE_TERMINATE_IND) &&
 100c026:	f1b9 0f0b 	cmp.w	r9, #11
 100c02a:	f000 864f 	beq.w	100cccc <ull_conn_rx+0xed0>
		  (opcode != PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP) &&
 100c02e:	f1b9 0f03 	cmp.w	r9, #3
 100c032:	f000 8404 	beq.w	100c83e <ull_conn_rx+0xa42>
		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)) ||
 100c036:	f1b9 0f06 	cmp.w	r9, #6
 100c03a:	f47f af1c 	bne.w	100be76 <ull_conn_rx+0x7a>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_START_ENC_RSP,
 100c03e:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c042:	2b01      	cmp	r3, #1
 100c044:	d1a6      	bne.n	100bf94 <ull_conn_rx+0x198>
			nack = start_enc_rsp_send(conn, NULL);
 100c046:	2100      	movs	r1, #0
 100c048:	4628      	mov	r0, r5
 100c04a:	f7ff f9f9 	bl	100b440 <start_enc_rsp_send>
			if (nack) {
 100c04e:	2800      	cmp	r0, #0
 100c050:	f47f af3d 	bne.w	100bece <ull_conn_rx+0xd2>
			conn->llcp_enc.pause_rx = 0U;
 100c054:	f895 3152 	ldrb.w	r3, [r5, #338]	; 0x152
 100c058:	f023 0303 	bic.w	r3, r3, #3
 100c05c:	f885 3152 	strb.w	r3, [r5, #338]	; 0x152
		if (conn->llcp_enc.refresh) {
 100c060:	f895 3152 	ldrb.w	r3, [r5, #338]	; 0x152
 100c064:	0758      	lsls	r0, r3, #29
 100c066:	d506      	bpl.n	100c076 <ull_conn_rx+0x27a>
			(*rx)->hdr.type = NODE_RX_TYPE_ENC_REFRESH;
 100c068:	210b      	movs	r1, #11
 100c06a:	6822      	ldr	r2, [r4, #0]
			conn->llcp_enc.refresh = 0U;
 100c06c:	f36f 0382 	bfc	r3, #2, #1
 100c070:	f885 3152 	strb.w	r3, [r5, #338]	; 0x152
			(*rx)->hdr.type = NODE_RX_TYPE_ENC_REFRESH;
 100c074:	7111      	strb	r1, [r2, #4]
				break;
			}
		}

		/* Procedure complete */
		conn->procedure_expire = 0U;
 100c076:	2000      	movs	r0, #0
 100c078:	f8a5 00cc 	strh.w	r0, [r5, #204]	; 0xcc
		break;
 100c07c:	e727      	b.n	100bece <ull_conn_rx+0xd2>

#if defined(CONFIG_BT_CTLR_DATA_LENGTH)
	case PDU_DATA_LLCTRL_TYPE_LENGTH_RSP:
	case PDU_DATA_LLCTRL_TYPE_LENGTH_REQ:
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_LENGTH_REQ,
 100c07e:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c082:	2b09      	cmp	r3, #9
 100c084:	d186      	bne.n	100bf94 <ull_conn_rx+0x198>
	if (pdu_rx->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_LENGTH_REQ) {
 100c086:	f1b9 0f14 	cmp.w	r9, #20
 100c08a:	f000 8629 	beq.w	100cce0 <ull_conn_rx+0xee4>
	eff_rx_octets = conn->lll.max_rx_octets;
 100c08e:	f8b5 205e 	ldrh.w	r2, [r5, #94]	; 0x5e
	    ((conn->llcp_length.req == conn->llcp_length.ack) && tx) ||
 100c092:	f895 1198 	ldrb.w	r1, [r5, #408]	; 0x198
	if (/* Local idle, and Peer request then complete the Peer procedure
 100c096:	f895 3199 	ldrb.w	r3, [r5, #409]	; 0x199
	eff_rx_octets = conn->lll.max_rx_octets;
 100c09a:	9201      	str	r2, [sp, #4]
	eff_tx_octets = conn->lll.max_tx_octets;
 100c09c:	f8b5 205c 	ldrh.w	r2, [r5, #92]	; 0x5c
	if (/* Local idle, and Peer request then complete the Peer procedure
 100c0a0:	428b      	cmp	r3, r1
	eff_rx_time = conn->lll.max_rx_time;
 100c0a2:	f8b5 e062 	ldrh.w	lr, [r5, #98]	; 0x62
	eff_tx_time = conn->lll.max_tx_time;
 100c0a6:	f8b5 8060 	ldrh.w	r8, [r5, #96]	; 0x60
	    ((conn->llcp_length.req == conn->llcp_length.ack) && tx) ||
 100c0aa:	9100      	str	r1, [sp, #0]
	eff_tx_octets = conn->lll.max_tx_octets;
 100c0ac:	9202      	str	r2, [sp, #8]
	if (/* Local idle, and Peer request then complete the Peer procedure
 100c0ae:	f001 8151 	beq.w	100d354 <ull_conn_rx+0x1558>
	struct node_tx *tx = NULL;
 100c0b2:	2100      	movs	r1, #0
	     ((((conn->llcp_length.state == LLCP_LENGTH_STATE_REQ) ||
 100c0b4:	f895 319a 	ldrb.w	r3, [r5, #410]	; 0x19a
	       tx) ||
 100c0b8:	f003 0307 	and.w	r3, r3, #7
 100c0bc:	2b02      	cmp	r3, #2
 100c0be:	f000 8627 	beq.w	100cd10 <ull_conn_rx+0xf14>
 100c0c2:	f896 9023 	ldrb.w	r9, [r6, #35]	; 0x23
		if (pdu_rx->llctrl.opcode != PDU_DATA_LLCTRL_TYPE_LENGTH_RSP) {
 100c0c6:	f1b9 0f15 	cmp.w	r9, #21
 100c0ca:	f43f af53 	beq.w	100bf74 <ull_conn_rx+0x178>
			mem_release(tx, &mem_conn_tx_ctrl.free);
 100c0ce:	4608      	mov	r0, r1
 100c0d0:	490c      	ldr	r1, [pc, #48]	; (100c104 <ull_conn_rx+0x308>)
 100c0d2:	f7f9 fe3b 	bl	1005d4c <mem_release>
			if (conn->llcp_length.state ==
 100c0d6:	f895 319a 	ldrb.w	r3, [r5, #410]	; 0x19a
 100c0da:	f003 0307 	and.w	r3, r3, #7
 100c0de:	2b04      	cmp	r3, #4
 100c0e0:	f47f af48 	bne.w	100bf74 <ull_conn_rx+0x178>
				return -EBUSY;
 100c0e4:	f06f 000f 	mvn.w	r0, #15
 100c0e8:	e6f1      	b.n	100bece <ull_conn_rx+0xd2>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PING_RSP, pdu_rx->len)) {
 100c0ea:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c0ee:	2b01      	cmp	r3, #1
 100c0f0:	f47f af50 	bne.w	100bf94 <ull_conn_rx+0x198>
		conn->procedure_expire = 0U;
 100c0f4:	2000      	movs	r0, #0
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c0f6:	2303      	movs	r3, #3
		conn->procedure_expire = 0U;
 100c0f8:	f8a5 00cc 	strh.w	r0, [r5, #204]	; 0xcc
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c0fc:	7133      	strb	r3, [r6, #4]
		break;
 100c0fe:	e6e6      	b.n	100bece <ull_conn_rx+0xd2>
 100c100:	21002bd0 	.word	0x21002bd0
 100c104:	21005288 	.word	0x21005288
			nack = phy_rsp_send(conn, *rx, pdu_rx);
		}
		break;

	case PDU_DATA_LLCTRL_TYPE_PHY_RSP:
		if (conn->lll.role ||
 100c108:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c10c:	2b00      	cmp	r3, #0
 100c10e:	f6ff af41 	blt.w	100bf94 <ull_conn_rx+0x198>
 100c112:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c116:	2b03      	cmp	r3, #3
 100c118:	f47f af3c 	bne.w	100bf94 <ull_conn_rx+0x198>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PHY_RSP, pdu_rx->len)) {
			goto ull_conn_rx_unknown_rsp_send;
		}

		if (!conn->lll.role &&
 100c11c:	f895 21a9 	ldrb.w	r2, [r5, #425]	; 0x1a9
 100c120:	f895 31a8 	ldrb.w	r3, [r5, #424]	; 0x1a8
 100c124:	429a      	cmp	r2, r3
 100c126:	f43f af63 	beq.w	100bff0 <ull_conn_rx+0x1f4>
		    (conn->llcp_phy.ack != conn->llcp_phy.req) &&
		    (conn->llcp_phy.state == LLCP_PHY_STATE_RSP_WAIT)) {
 100c12a:	f895 11aa 	ldrb.w	r1, [r5, #426]	; 0x1aa
		    (conn->llcp_phy.ack != conn->llcp_phy.req) &&
 100c12e:	f001 0303 	and.w	r3, r1, #3
 100c132:	2b02      	cmp	r3, #2
 100c134:	f47f af5c 	bne.w	100bff0 <ull_conn_rx+0x1f4>
			struct pdu_data_llctrl_phy_rsp *p =
				&pdu_rx->llctrl.phy_rsp;

			conn->llcp_phy.state = LLCP_PHY_STATE_UPD;

			conn->llcp_phy.tx &= p->rx_phys;
 100c138:	f896 3025 	ldrb.w	r3, [r6, #37]	; 0x25
 100c13c:	f3c1 0282 	ubfx	r2, r1, #2, #3
 100c140:	4013      	ands	r3, r2
			conn->llcp_phy.rx &= p->tx_phys;
 100c142:	f896 2024 	ldrb.w	r2, [r6, #36]	; 0x24
			conn->llcp_phy.state = LLCP_PHY_STATE_UPD;
 100c146:	009b      	lsls	r3, r3, #2
 100c148:	f043 0303 	orr.w	r3, r3, #3
			conn->llcp_phy.rx &= p->tx_phys;
 100c14c:	ea02 1251 	and.w	r2, r2, r1, lsr #5
			conn->llcp_phy.state = LLCP_PHY_STATE_UPD;
 100c150:	ea43 1342 	orr.w	r3, r3, r2, lsl #5

			if (!conn->llcp_phy.tx || !conn->llcp_phy.rx) {
 100c154:	f013 0f1c 	tst.w	r3, #28
			conn->llcp_phy.state = LLCP_PHY_STATE_UPD;
 100c158:	f885 31aa 	strb.w	r3, [r5, #426]	; 0x1aa
			if (!conn->llcp_phy.tx || !conn->llcp_phy.rx) {
 100c15c:	d002      	beq.n	100c164 <ull_conn_rx+0x368>
 100c15e:	f013 0fe0 	tst.w	r3, #224	; 0xe0
 100c162:	d105      	bne.n	100c170 <ull_conn_rx+0x374>
				conn->llcp_phy.tx = 0;
 100c164:	f895 31aa 	ldrb.w	r3, [r5, #426]	; 0x1aa
 100c168:	f003 0303 	and.w	r3, r3, #3
 100c16c:	f885 31aa 	strb.w	r3, [r5, #426]	; 0x1aa

			/* pause data packet tx */
			conn->llcp_phy.pause_tx = 1U;

			/* Procedure timeout is stopped */
			conn->procedure_expire = 0U;
 100c170:	2200      	movs	r2, #0
			conn->llcp_phy.pause_tx = 1U;
 100c172:	f895 31ab 	ldrb.w	r3, [r5, #427]	; 0x1ab
			conn->procedure_expire = 0U;
 100c176:	f8a5 20cc 	strh.w	r2, [r5, #204]	; 0xcc
			conn->llcp_phy.pause_tx = 1U;
 100c17a:	f043 0301 	orr.w	r3, r3, #1
 100c17e:	f885 31ab 	strb.w	r3, [r5, #427]	; 0x1ab
		}

		/* Mark for buffer for release */
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c182:	e735      	b.n	100bff0 <ull_conn_rx+0x1f4>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PHY_REQ, pdu_rx->len)) {
 100c184:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c188:	2b03      	cmp	r3, #3
 100c18a:	f47f af03 	bne.w	100bf94 <ull_conn_rx+0x198>
		if (!conn->lll.role) {
 100c18e:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c192:	2b00      	cmp	r3, #0
 100c194:	f2c0 850c 	blt.w	100cbb0 <ull_conn_rx+0xdb4>
			if ((conn->llcp_phy.ack !=
 100c198:	f895 21a9 	ldrb.w	r2, [r5, #425]	; 0x1a9
			     conn->llcp_phy.req) &&
 100c19c:	f895 11a8 	ldrb.w	r1, [r5, #424]	; 0x1a8
			if ((conn->llcp_phy.ack !=
 100c1a0:	428a      	cmp	r2, r1
 100c1a2:	d007      	beq.n	100c1b4 <ull_conn_rx+0x3b8>
			      LLCP_PHY_STATE_RSP_WAIT) ||
 100c1a4:	f895 31aa 	ldrb.w	r3, [r5, #426]	; 0x1aa
 100c1a8:	f003 0303 	and.w	r3, r3, #3
			     conn->llcp_phy.req) &&
 100c1ac:	3b01      	subs	r3, #1
 100c1ae:	2b02      	cmp	r3, #2
 100c1b0:	f241 803d 	bls.w	100d22e <ull_conn_rx+0x1432>
			} else if (((((conn->llcp_req - conn->llcp_ack) &
 100c1b4:	f895 30e8 	ldrb.w	r3, [r5, #232]	; 0xe8
 100c1b8:	f895 00e9 	ldrb.w	r0, [r5, #233]	; 0xe9
 100c1bc:	1a1b      	subs	r3, r3, r0
 100c1be:	f003 0303 	and.w	r3, r3, #3
 100c1c2:	2b02      	cmp	r3, #2
 100c1c4:	f000 8770 	beq.w	100d0a8 <ull_conn_rx+0x12ac>
				     LLCP_ENCRYPTION)) ||
 100c1c8:	f895 0170 	ldrb.w	r0, [r5, #368]	; 0x170
 100c1cc:	f895 3171 	ldrb.w	r3, [r5, #369]	; 0x171
 100c1d0:	4298      	cmp	r0, r3
 100c1d2:	f000 87e4 	beq.w	100d19e <ull_conn_rx+0x13a2>
				nack = reject_ext_ind_send(conn, *rx,
 100c1d6:	4628      	mov	r0, r5
 100c1d8:	232a      	movs	r3, #42	; 0x2a
 100c1da:	1d31      	adds	r1, r6, #4
 100c1dc:	2216      	movs	r2, #22
}
 100c1de:	b005      	add	sp, #20
 100c1e0:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
				nack = reject_ext_ind_send(conn, *rx,
 100c1e4:	f7ff b8d8 	b.w	100b398 <reject_ext_ind_send.isra.0>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PING_REQ, pdu_rx->len)) {
 100c1e8:	f896 4021 	ldrb.w	r4, [r6, #33]	; 0x21
 100c1ec:	2c01      	cmp	r4, #1
 100c1ee:	f47f aed1 	bne.w	100bf94 <ull_conn_rx+0x198>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100c1f2:	48ec      	ldr	r0, [pc, #944]	; (100c5a4 <ull_conn_rx+0x7a8>)
 100c1f4:	f7f9 fd90 	bl	1005d18 <mem_acquire>
	if (!tx) {
 100c1f8:	4601      	mov	r1, r0
 100c1fa:	2800      	cmp	r0, #0
 100c1fc:	f000 856c 	beq.w	100ccd8 <ull_conn_rx+0xedc>
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_RSP;
 100c200:	2213      	movs	r2, #19
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100c202:	7903      	ldrb	r3, [r0, #4]
	pdu_tx->len = offsetof(struct pdu_data_llctrl, ping_rsp) +
 100c204:	7144      	strb	r4, [r0, #5]
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100c206:	f043 0303 	orr.w	r3, r3, #3
	ctrl_tx_sec_enqueue(conn, tx);
 100c20a:	4628      	mov	r0, r5
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100c20c:	710b      	strb	r3, [r1, #4]
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_RSP;
 100c20e:	71ca      	strb	r2, [r1, #7]
	ctrl_tx_sec_enqueue(conn, tx);
 100c210:	f7ff f978 	bl	100b504 <ctrl_tx_sec_enqueue>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c214:	2303      	movs	r3, #3
	return 0;
 100c216:	2000      	movs	r0, #0
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c218:	7133      	strb	r3, [r6, #4]
	return 0;
 100c21a:	e658      	b.n	100bece <ull_conn_rx+0xd2>
		if (!conn->lll.role ||
 100c21c:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c220:	2b00      	cmp	r3, #0
 100c222:	f6bf aeb7 	bge.w	100bf94 <ull_conn_rx+0x198>
 100c226:	f896 4021 	ldrb.w	r4, [r6, #33]	; 0x21
 100c22a:	2c01      	cmp	r4, #1
 100c22c:	f47f aeb2 	bne.w	100bf94 <ull_conn_rx+0x198>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100c230:	48dc      	ldr	r0, [pc, #880]	; (100c5a4 <ull_conn_rx+0x7a8>)
 100c232:	f7f9 fd71 	bl	1005d18 <mem_acquire>
		if (!tx) {
 100c236:	4603      	mov	r3, r0
 100c238:	2800      	cmp	r0, #0
 100c23a:	f000 854d 	beq.w	100ccd8 <ull_conn_rx+0xedc>
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP;
 100c23e:	200b      	movs	r0, #11
	conn->llcp_enc.pause_rx = 1U;
 100c240:	f895 2152 	ldrb.w	r2, [r5, #338]	; 0x152
	conn->lll.enc_rx = 0;
 100c244:	f895 107e 	ldrb.w	r1, [r5, #126]	; 0x7e
	conn->llcp_enc.pause_rx = 1U;
 100c248:	f022 0205 	bic.w	r2, r2, #5
	conn->lll.enc_rx = 0;
 100c24c:	f36f 01c3 	bfc	r1, #3, #1
 100c250:	f885 107e 	strb.w	r1, [r5, #126]	; 0x7e
	conn->llcp_enc.pause_rx = 1U;
 100c254:	f042 0205 	orr.w	r2, r2, #5
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100c258:	7919      	ldrb	r1, [r3, #4]
	conn->llcp_enc.pause_rx = 1U;
 100c25a:	f885 2152 	strb.w	r2, [r5, #338]	; 0x152
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
 100c25e:	715c      	strb	r4, [r3, #5]
	    conn->tx_head &&
 100c260:	f8d5 21b0 	ldr.w	r2, [r5, #432]	; 0x1b0
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100c264:	f041 0103 	orr.w	r1, r1, #3
 100c268:	7119      	strb	r1, [r3, #4]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP;
 100c26a:	71d8      	strb	r0, [r3, #7]
	if (
 100c26c:	2a00      	cmp	r2, #0
 100c26e:	f000 84f3 	beq.w	100cc58 <ull_conn_rx+0xe5c>
	    !conn->llcp_enc.pause_tx &&
 100c272:	f895 1152 	ldrb.w	r1, [r5, #338]	; 0x152
	    conn->tx_head &&
 100c276:	0788      	lsls	r0, r1, #30
 100c278:	f100 84ee 	bmi.w	100cc58 <ull_conn_rx+0xe5c>
	    !conn->llcp_phy.pause_tx &&
 100c27c:	f895 11ab 	ldrb.w	r1, [r5, #427]	; 0x1ab
 100c280:	07c9      	lsls	r1, r1, #31
 100c282:	f100 84e9 	bmi.w	100cc58 <ull_conn_rx+0xe5c>
		if (conn->tx_head == conn->tx_data) {
 100c286:	f8d5 11bc 	ldr.w	r1, [r5, #444]	; 0x1bc
 100c28a:	428a      	cmp	r2, r1
			conn->tx_data = conn->tx_data->next;
 100c28c:	bf04      	itt	eq
 100c28e:	6811      	ldreq	r1, [r2, #0]
 100c290:	f8c5 11bc 	streq.w	r1, [r5, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 100c294:	f8d5 11b4 	ldr.w	r1, [r5, #436]	; 0x1b4
 100c298:	2900      	cmp	r1, #0
 100c29a:	f001 8083 	beq.w	100d3a4 <ull_conn_rx+0x15a8>
	tx->next = conn->tx_ctrl_last->next;
 100c29e:	f8d5 21b8 	ldr.w	r2, [r5, #440]	; 0x1b8
 100c2a2:	6811      	ldr	r1, [r2, #0]
 100c2a4:	6019      	str	r1, [r3, #0]
	conn->tx_ctrl_last->next = tx;
 100c2a6:	6013      	str	r3, [r2, #0]
	conn->tx_ctrl_last = tx;
 100c2a8:	f8c5 31b8 	str.w	r3, [r5, #440]	; 0x1b8
	if (!tx->next) {
 100c2ac:	681a      	ldr	r2, [r3, #0]
 100c2ae:	2a00      	cmp	r2, #0
 100c2b0:	f47f ae9e 	bne.w	100bff0 <ull_conn_rx+0x1f4>
		conn->tx_data_last = tx;
 100c2b4:	f8c5 31c0 	str.w	r3, [r5, #448]	; 0x1c0
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c2b8:	e69a      	b.n	100bff0 <ull_conn_rx+0x1f4>
		if ((!IS_ENABLED(CONFIG_BT_CTLR_SLAVE_FEAT_REQ) &&
 100c2ba:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c2be:	2b09      	cmp	r3, #9
 100c2c0:	f47f ae68 	bne.w	100bf94 <ull_conn_rx+0x198>
	conn->procedure_expire = 0U;
 100c2c4:	2000      	movs	r0, #0
	       (features[1] << 8) | (features[2] << 16);
 100c2c6:	f896 3026 	ldrb.w	r3, [r6, #38]	; 0x26
 100c2ca:	f896 2025 	ldrb.w	r2, [r6, #37]	; 0x25
	feat = ~LL_FEAT_BIT_MASK_VALID | features[0] |
 100c2ce:	f896 1024 	ldrb.w	r1, [r6, #36]	; 0x24
	       (features[1] << 8) | (features[2] << 16);
 100c2d2:	041b      	lsls	r3, r3, #16
 100c2d4:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 100c2d8:	4ab3      	ldr	r2, [pc, #716]	; (100c5a8 <ull_conn_rx+0x7ac>)
 100c2da:	430b      	orrs	r3, r1
	conn->llcp_feature.features &= feat_get(&rsp->features[0]);
 100c2dc:	f8d5 111c 	ldr.w	r1, [r5, #284]	; 0x11c
	       (features[1] << 8) | (features[2] << 16);
 100c2e0:	4313      	orrs	r3, r2
	conn->common.fex_valid = 1U;
 100c2e2:	f895 20dc 	ldrb.w	r2, [r5, #220]	; 0xdc
	conn->llcp_feature.features &= feat_get(&rsp->features[0]);
 100c2e6:	400b      	ands	r3, r1
	conn->llcp_feature.ack = conn->llcp_feature.req;
 100c2e8:	f895 1118 	ldrb.w	r1, [r5, #280]	; 0x118
	conn->llcp_feature.features &= feat_get(&rsp->features[0]);
 100c2ec:	f3c3 0310 	ubfx	r3, r3, #0, #17
	conn->common.fex_valid = 1U;
 100c2f0:	f042 0201 	orr.w	r2, r2, #1
	conn->llcp_feature.features &= feat_get(&rsp->features[0]);
 100c2f4:	f8c5 311c 	str.w	r3, [r5, #284]	; 0x11c
	conn->common.fex_valid = 1U;
 100c2f8:	f885 20dc 	strb.w	r2, [r5, #220]	; 0xdc
	conn->procedure_expire = 0U;
 100c2fc:	f8a5 00cc 	strh.w	r0, [r5, #204]	; 0xcc
	conn->llcp_feature.ack = conn->llcp_feature.req;
 100c300:	f885 1119 	strb.w	r1, [r5, #281]	; 0x119
}
 100c304:	e5e3      	b.n	100bece <ull_conn_rx+0xd2>
	break;
#endif /* CONFIG_BT_CTLR_PHY */

#if defined(CONFIG_BT_CTLR_MIN_USED_CHAN)
	case PDU_DATA_LLCTRL_TYPE_MIN_USED_CHAN_IND:
		if (conn->lll.role ||
 100c306:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c30a:	2b00      	cmp	r3, #0
 100c30c:	f6ff ae42 	blt.w	100bf94 <ull_conn_rx+0x198>
 100c310:	f896 7021 	ldrb.w	r7, [r6, #33]	; 0x21
 100c314:	2f03      	cmp	r7, #3
 100c316:	f47f ae3d 	bne.w	100bf94 <ull_conn_rx+0x198>
		if (!conn->lll.role) {
			struct pdu_data_llctrl_min_used_chans_ind *p =
				&pdu_rx->llctrl.min_used_chans_ind;

#if defined(CONFIG_BT_CTLR_PHY)
			if (!(p->phys & (conn->lll.phy_tx |
 100c31a:	f895 1064 	ldrb.w	r1, [r5, #100]	; 0x64
					 conn->lll.phy_rx))) {
 100c31e:	f895 3065 	ldrb.w	r3, [r5, #101]	; 0x65
			if (!(p->phys & (conn->lll.phy_tx |
 100c322:	f896 2024 	ldrb.w	r2, [r6, #36]	; 0x24
 100c326:	430b      	orrs	r3, r1
 100c328:	f003 0307 	and.w	r3, r3, #7
 100c32c:	4213      	tst	r3, r2
 100c32e:	f43f ae21 	beq.w	100bf74 <ull_conn_rx+0x178>
			if (!(p->phys & 0x01)) {
#endif /* !CONFIG_BT_CTLR_PHY */
				break;
			}

			if (((conn->llcp_req - conn->llcp_ack) & 0x03) ==
 100c332:	f895 30e8 	ldrb.w	r3, [r5, #232]	; 0xe8
 100c336:	f895 20e9 	ldrb.w	r2, [r5, #233]	; 0xe9
 100c33a:	1a9b      	subs	r3, r3, r2
 100c33c:	f003 0303 	and.w	r3, r3, #3
 100c340:	2b02      	cmp	r3, #2
 100c342:	f43f ae17 	beq.w	100bf74 <ull_conn_rx+0x178>
			    0x02) {
				break;
			}

			memcpy(&conn->llcp.chan_map.chm[0], data_chan_map,
 100c346:	2205      	movs	r2, #5
 100c348:	4998      	ldr	r1, [pc, #608]	; (100c5ac <ull_conn_rx+0x7b0>)
 100c34a:	f105 00ed 	add.w	r0, r5, #237	; 0xed
 100c34e:	f00a fb63 	bl	1016a18 <memcpy>
			       sizeof(conn->llcp.chan_map.chm));
			/* conn->llcp.chan_map.instant     = 0; */
			conn->llcp.chan_map.initiate = 1U;

			conn->llcp_type = LLCP_CHAN_MAP;
 100c352:	2202      	movs	r2, #2
			conn->llcp_ack -= 2U;
 100c354:	f895 30e9 	ldrb.w	r3, [r5, #233]	; 0xe9
			conn->llcp_type = LLCP_CHAN_MAP;
 100c358:	f885 20ea 	strb.w	r2, [r5, #234]	; 0xea
			conn->llcp_ack -= 2U;
 100c35c:	3b02      	subs	r3, #2
 100c35e:	f885 30e9 	strb.w	r3, [r5, #233]	; 0xe9
			conn->llcp.chan_map.initiate = 1U;
 100c362:	f895 30ec 	ldrb.w	r3, [r5, #236]	; 0xec
		}

		/* Mark for buffer for release */
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c366:	6822      	ldr	r2, [r4, #0]
			conn->llcp.chan_map.initiate = 1U;
 100c368:	f043 0301 	orr.w	r3, r3, #1
 100c36c:	f885 30ec 	strb.w	r3, [r5, #236]	; 0xec
	int nack = 0;
 100c370:	2000      	movs	r0, #0
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c372:	7117      	strb	r7, [r2, #4]

		break;
 100c374:	e5ab      	b.n	100bece <ull_conn_rx+0xd2>
		if (!conn->lll.role ||
 100c376:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c37a:	2b00      	cmp	r3, #0
 100c37c:	f6bf ae0a 	bge.w	100bf94 <ull_conn_rx+0x198>
 100c380:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c384:	2b05      	cmp	r3, #5
 100c386:	f47f ae05 	bne.w	100bf94 <ull_conn_rx+0x198>
	if (!((ind->m_to_s_phy | ind->s_to_m_phy) & 0x07)) {
 100c38a:	f896 0024 	ldrb.w	r0, [r6, #36]	; 0x24
 100c38e:	f896 3025 	ldrb.w	r3, [r6, #37]	; 0x25
 100c392:	ea40 0203 	orr.w	r2, r0, r3
 100c396:	f012 0207 	ands.w	r2, r2, #7
 100c39a:	f040 8692 	bne.w	100d0c2 <ull_conn_rx+0x12c6>
		if ((conn->llcp_phy.ack == conn->llcp_phy.req) ||
 100c39e:	f895 71a8 	ldrb.w	r7, [r5, #424]	; 0x1a8
 100c3a2:	f895 31a9 	ldrb.w	r3, [r5, #425]	; 0x1a9
 100c3a6:	42bb      	cmp	r3, r7
 100c3a8:	f43f ae22 	beq.w	100bff0 <ull_conn_rx+0x1f4>
		    (conn->llcp_phy.state != LLCP_PHY_STATE_RSP_WAIT)) {
 100c3ac:	f895 31aa 	ldrb.w	r3, [r5, #426]	; 0x1aa
		if ((conn->llcp_phy.ack == conn->llcp_phy.req) ||
 100c3b0:	f003 0303 	and.w	r3, r3, #3
 100c3b4:	2b02      	cmp	r3, #2
 100c3b6:	f47f ae1b 	bne.w	100bff0 <ull_conn_rx+0x1f4>
		conn->lll.phy_tx_time = conn->lll.phy_tx;
 100c3ba:	f895 1064 	ldrb.w	r1, [r5, #100]	; 0x64
		conn->llcp_phy.pause_tx = 0U;
 100c3be:	f895 31ab 	ldrb.w	r3, [r5, #427]	; 0x1ab
		conn->lll.phy_tx_time = conn->lll.phy_tx;
 100c3c2:	4608      	mov	r0, r1
		conn->llcp_phy.pause_tx = 0U;
 100c3c4:	f362 0300 	bfi	r3, r2, #0, #1
		conn->lll.phy_tx_time = conn->lll.phy_tx;
 100c3c8:	f361 1006 	bfi	r0, r1, #4, #3
		conn->llcp_phy.pause_tx = 0U;
 100c3cc:	f885 31ab 	strb.w	r3, [r5, #427]	; 0x1ab
		if (!conn->llcp_phy.cmd) {
 100c3d0:	f013 0304 	ands.w	r3, r3, #4
		conn->llcp_phy.ack = conn->llcp_phy.req;
 100c3d4:	f885 71a9 	strb.w	r7, [r5, #425]	; 0x1a9
		conn->procedure_expire = 0U;
 100c3d8:	f8a5 20cc 	strh.w	r2, [r5, #204]	; 0xcc
		conn->lll.phy_tx_time = conn->lll.phy_tx;
 100c3dc:	f885 0064 	strb.w	r0, [r5, #100]	; 0x64
 100c3e0:	f3c1 0102 	ubfx	r1, r1, #0, #3
		if (!conn->llcp_phy.cmd) {
 100c3e4:	f000 8667 	beq.w	100d0b6 <ull_conn_rx+0x12ba>
		(*rx)->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
 100c3e8:	270e      	movs	r7, #14
 100c3ea:	6823      	ldr	r3, [r4, #0]
	int nack = 0;
 100c3ec:	4610      	mov	r0, r2
		(*rx)->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
 100c3ee:	711f      	strb	r7, [r3, #4]
		p->status = 0U;
 100c3f0:	f886 2020 	strb.w	r2, [r6, #32]
		p->tx = conn->lll.phy_tx;
 100c3f4:	f886 1021 	strb.w	r1, [r6, #33]	; 0x21
		p->rx = conn->lll.phy_rx;
 100c3f8:	f895 3065 	ldrb.w	r3, [r5, #101]	; 0x65
 100c3fc:	f3c3 0302 	ubfx	r3, r3, #0, #3
 100c400:	f886 3022 	strb.w	r3, [r6, #34]	; 0x22
		if (err) {
 100c404:	e563      	b.n	100bece <ull_conn_rx+0xd2>
		if (conn->lll.role ||
 100c406:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c40a:	2b00      	cmp	r3, #0
 100c40c:	f6ff adc2 	blt.w	100bf94 <ull_conn_rx+0x198>
 100c410:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c414:	2b18      	cmp	r3, #24
 100c416:	f47f adbd 	bne.w	100bf94 <ull_conn_rx+0x198>
		if (!conn->lll.role &&
 100c41a:	f895 2170 	ldrb.w	r2, [r5, #368]	; 0x170
 100c41e:	f895 3171 	ldrb.w	r3, [r5, #369]	; 0x171
 100c422:	429a      	cmp	r2, r3
 100c424:	f43f ade4 	beq.w	100bff0 <ull_conn_rx+0x1f4>
		    (conn->llcp_conn_param.state ==
 100c428:	f895 3172 	ldrb.w	r3, [r5, #370]	; 0x172
		     conn->llcp_conn_param.ack) &&
 100c42c:	f003 0307 	and.w	r3, r3, #7
 100c430:	2b04      	cmp	r3, #4
 100c432:	f47f addd 	bne.w	100bff0 <ull_conn_rx+0x1f4>
			u16_t interval_min = sys_le16_to_cpu(cpr->interval_min);
 100c436:	f8b6 e024 	ldrh.w	lr, [r6, #36]	; 0x24
 100c43a:	fa1f f28e 	uxth.w	r2, lr
			if ((interval_min < 6) ||
 100c43e:	2a05      	cmp	r2, #5
 100c440:	f240 8701 	bls.w	100d246 <ull_conn_rx+0x144a>
			u16_t interval_max = sys_le16_to_cpu(cpr->interval_max);
 100c444:	f8b6 c026 	ldrh.w	ip, [r6, #38]	; 0x26
 100c448:	fa1f f38c 	uxth.w	r3, ip
			if ((interval_min < 6) ||
 100c44c:	f5b3 6f48 	cmp.w	r3, #3200	; 0xc80
 100c450:	f200 86f9 	bhi.w	100d246 <ull_conn_rx+0x144a>
			    (interval_max > 3200) ||
 100c454:	429a      	cmp	r2, r3
 100c456:	f200 86f6 	bhi.w	100d246 <ull_conn_rx+0x144a>
			u16_t latency = sys_le16_to_cpu(cpr->latency);
 100c45a:	8d37      	ldrh	r7, [r6, #40]	; 0x28
 100c45c:	b2ba      	uxth	r2, r7
			    (interval_min > interval_max) ||
 100c45e:	f5b2 7ffa 	cmp.w	r2, #500	; 0x1f4
 100c462:	f080 86f0 	bcs.w	100d246 <ull_conn_rx+0x144a>
			    (latency > 499) ||
 100c466:	f640 4976 	movw	r9, #3190	; 0xc76
			u16_t timeout = sys_le16_to_cpu(cpr->timeout);
 100c46a:	8d70      	ldrh	r0, [r6, #42]	; 0x2a
 100c46c:	fa1f f880 	uxth.w	r8, r0
			    (latency > 499) ||
 100c470:	f1a8 010a 	sub.w	r1, r8, #10
 100c474:	b289      	uxth	r1, r1
 100c476:	4549      	cmp	r1, r9
 100c478:	f200 86e5 	bhi.w	100d246 <ull_conn_rx+0x144a>
			     ((latency + 1) * interval_max)) ||
 100c47c:	fb02 3203 	mla	r2, r2, r3, r3
			    (timeout < 10) || (timeout > 3200) ||
 100c480:	ebb2 0f88 	cmp.w	r2, r8, lsl #2
 100c484:	f080 86df 	bcs.w	100d246 <ull_conn_rx+0x144a>
			     ((latency + 1) * interval_max)) ||
 100c488:	f896 102c 	ldrb.w	r1, [r6, #44]	; 0x2c
 100c48c:	428b      	cmp	r3, r1
 100c48e:	f0c0 86da 	bcc.w	100d246 <ull_conn_rx+0x144a>
			conn->procedure_expire = 0U;
 100c492:	2300      	movs	r3, #0
			conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP;
 100c494:	f04f 0801 	mov.w	r8, #1
			conn->llcp_conn_param.preferred_periodicity =
 100c498:	f885 117c 	strb.w	r1, [r5, #380]	; 0x17c
			conn->llcp_conn_param.interval_min = interval_min;
 100c49c:	f8a5 e174 	strh.w	lr, [r5, #372]	; 0x174
			conn->llcp_conn_param.interval_max = interval_max;
 100c4a0:	f8a5 c176 	strh.w	ip, [r5, #374]	; 0x176
			conn->llcp_conn_param.latency =	latency;
 100c4a4:	f8a5 7178 	strh.w	r7, [r5, #376]	; 0x178
			conn->llcp_conn_param.timeout =	timeout;
 100c4a8:	f8a5 017a 	strh.w	r0, [r5, #378]	; 0x17a
			conn->procedure_expire = 0U;
 100c4ac:	f8a5 30cc 	strh.w	r3, [r5, #204]	; 0xcc
				sys_le16_to_cpu(cpr->reference_conn_event_count);
 100c4b0:	f896 102e 	ldrb.w	r1, [r6, #46]	; 0x2e
 100c4b4:	f896 302d 	ldrb.w	r3, [r6, #45]	; 0x2d
			conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP;
 100c4b8:	f895 2172 	ldrb.w	r2, [r5, #370]	; 0x172
				sys_le16_to_cpu(cpr->reference_conn_event_count);
 100c4bc:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
			conn->llcp_conn_param.reference_conn_event_count =
 100c4c0:	f8a5 317e 	strh.w	r3, [r5, #382]	; 0x17e
				sys_le16_to_cpu(cpr->offset0);
 100c4c4:	f896 1030 	ldrb.w	r1, [r6, #48]	; 0x30
 100c4c8:	f896 302f 	ldrb.w	r3, [r6, #47]	; 0x2f
			conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP;
 100c4cc:	f368 0202 	bfi	r2, r8, #0, #3
				sys_le16_to_cpu(cpr->offset0);
 100c4d0:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
			conn->llcp_conn_param.offset0 =
 100c4d4:	f8a5 3180 	strh.w	r3, [r5, #384]	; 0x180
				sys_le16_to_cpu(cpr->offset1);
 100c4d8:	f896 1032 	ldrb.w	r1, [r6, #50]	; 0x32
 100c4dc:	f896 3031 	ldrb.w	r3, [r6, #49]	; 0x31
 100c4e0:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
			conn->llcp_conn_param.offset1 =
 100c4e4:	f8a5 3182 	strh.w	r3, [r5, #386]	; 0x182
				sys_le16_to_cpu(cpr->offset2);
 100c4e8:	f896 1034 	ldrb.w	r1, [r6, #52]	; 0x34
 100c4ec:	f896 3033 	ldrb.w	r3, [r6, #51]	; 0x33
 100c4f0:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
			conn->llcp_conn_param.offset2 =
 100c4f4:	f8a5 3184 	strh.w	r3, [r5, #388]	; 0x184
				sys_le16_to_cpu(cpr->offset3);
 100c4f8:	f896 1036 	ldrb.w	r1, [r6, #54]	; 0x36
 100c4fc:	f896 3035 	ldrb.w	r3, [r6, #53]	; 0x35
 100c500:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
			conn->llcp_conn_param.offset3 =
 100c504:	f8a5 3186 	strh.w	r3, [r5, #390]	; 0x186
				sys_le16_to_cpu(cpr->offset4);
 100c508:	f896 1038 	ldrb.w	r1, [r6, #56]	; 0x38
 100c50c:	f896 3037 	ldrb.w	r3, [r6, #55]	; 0x37
 100c510:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
			conn->llcp_conn_param.offset4 =
 100c514:	f8a5 3188 	strh.w	r3, [r5, #392]	; 0x188
				sys_le16_to_cpu(cpr->offset5);
 100c518:	f896 3039 	ldrb.w	r3, [r6, #57]	; 0x39
 100c51c:	f896 103a 	ldrb.w	r1, [r6, #58]	; 0x3a
 100c520:	6826      	ldr	r6, [r4, #0]
 100c522:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
			conn->llcp_conn_param.offset5 =
 100c526:	f8a5 318a 	strh.w	r3, [r5, #394]	; 0x18a
			conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP;
 100c52a:	f885 2172 	strb.w	r2, [r5, #370]	; 0x172
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c52e:	e55f      	b.n	100bff0 <ull_conn_rx+0x1f4>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ,
 100c530:	f896 2021 	ldrb.w	r2, [r6, #33]	; 0x21
 100c534:	2a18      	cmp	r2, #24
 100c536:	f47f ad2d 	bne.w	100bf94 <ull_conn_rx+0x198>
		if (conn_upd_curr && (conn_upd_curr != conn)) {
 100c53a:	4f1d      	ldr	r7, [pc, #116]	; (100c5b0 <ull_conn_rx+0x7b4>)
 100c53c:	f8d7 9000 	ldr.w	r9, [r7]
 100c540:	f1b9 0f00 	cmp.w	r9, #0
 100c544:	f000 8394 	beq.w	100cc70 <ull_conn_rx+0xe74>
 100c548:	454d      	cmp	r5, r9
 100c54a:	f000 8391 	beq.w	100cc70 <ull_conn_rx+0xe74>
			nack = reject_ext_ind_send(conn, *rx,
 100c54e:	4628      	mov	r0, r5
 100c550:	2320      	movs	r3, #32
 100c552:	220f      	movs	r2, #15
 100c554:	1d31      	adds	r1, r6, #4
 100c556:	e642      	b.n	100c1de <ull_conn_rx+0x3e2>
		((!conn->llcp_enc.refresh &&
 100c558:	f1b9 0f07 	cmp.w	r9, #7
 100c55c:	f000 8119 	beq.w	100c792 <ull_conn_rx+0x996>
		  (opcode != PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP) &&
 100c560:	f1b9 0f02 	cmp.w	r9, #2
 100c564:	f47f ad67 	bne.w	100c036 <ull_conn_rx+0x23a>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_TERMINATE_IND,
 100c568:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c56c:	2b02      	cmp	r3, #2
 100c56e:	f47f ad11 	bne.w	100bf94 <ull_conn_rx+0x198>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c572:	2303      	movs	r3, #3
		terminate_ind_recv(conn, *rx, pdu_rx);
 100c574:	f896 2024 	ldrb.w	r2, [r6, #36]	; 0x24
	int nack = 0;
 100c578:	2000      	movs	r0, #0
	conn->llcp_terminate.reason_peer = pdu->llctrl.terminate_ind.error_code;
 100c57a:	f885 212b 	strb.w	r2, [r5, #299]	; 0x12b
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c57e:	7133      	strb	r3, [r6, #4]
}
 100c580:	e4a5      	b.n	100bece <ull_conn_rx+0xd2>
		if (conn->lll.role ||
 100c582:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c586:	2b00      	cmp	r3, #0
 100c588:	f6ff ad04 	blt.w	100bf94 <ull_conn_rx+0x198>
 100c58c:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c590:	2b09      	cmp	r3, #9
 100c592:	f47f acff 	bne.w	100bf94 <ull_conn_rx+0x198>
		nack = feature_rsp_send(conn, *rx, pdu_rx);
 100c596:	4628      	mov	r0, r5
 100c598:	1d31      	adds	r1, r6, #4
}
 100c59a:	b005      	add	sp, #20
 100c59c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		nack = feature_rsp_send(conn, *rx, pdu_rx);
 100c5a0:	f7ff b83a 	b.w	100b618 <feature_rsp_send.isra.0>
 100c5a4:	21005288 	.word	0x21005288
 100c5a8:	fffe30d0 	.word	0xfffe30d0
 100c5ac:	21000314 	.word	0x21000314
 100c5b0:	21004850 	.word	0x21004850
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_REJECT_IND, pdu_rx->len)) {
 100c5b4:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c5b8:	2b02      	cmp	r3, #2
 100c5ba:	f47f aceb 	bne.w	100bf94 <ull_conn_rx+0x198>
		conn->procedure_expire = 0U;
 100c5be:	2000      	movs	r0, #0
		conn->llcp_enc.pause_rx = 0U;
 100c5c0:	f895 3152 	ldrb.w	r3, [r5, #338]	; 0x152
		conn->llcp_ack = conn->llcp_req;
 100c5c4:	f895 20e8 	ldrb.w	r2, [r5, #232]	; 0xe8
		conn->llcp_enc.pause_rx = 0U;
 100c5c8:	f023 0303 	bic.w	r3, r3, #3
 100c5cc:	f885 3152 	strb.w	r3, [r5, #338]	; 0x152
		conn->procedure_expire = 0U;
 100c5d0:	f8a5 00cc 	strh.w	r0, [r5, #204]	; 0xcc
		conn->llcp_ack = conn->llcp_req;
 100c5d4:	f885 20e9 	strb.w	r2, [r5, #233]	; 0xe9
		break;
 100c5d8:	e479      	b.n	100bece <ull_conn_rx+0xd2>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_VERSION_IND,
 100c5da:	f896 4021 	ldrb.w	r4, [r6, #33]	; 0x21
 100c5de:	2c06      	cmp	r4, #6
 100c5e0:	f47f acd8 	bne.w	100bf94 <ull_conn_rx+0x198>
	if (!conn->llcp_version.tx) {
 100c5e4:	f895 3122 	ldrb.w	r3, [r5, #290]	; 0x122
 100c5e8:	07d9      	lsls	r1, r3, #31
 100c5ea:	f140 8498 	bpl.w	100cf1e <ull_conn_rx+0x1122>
	} else if (!conn->llcp_version.rx) {
 100c5ee:	f013 0302 	ands.w	r3, r3, #2
 100c5f2:	f47f acfd 	bne.w	100bff0 <ull_conn_rx+0x1f4>
		conn->llcp_version.ack = conn->llcp_version.req;
 100c5f6:	f895 2120 	ldrb.w	r2, [r5, #288]	; 0x120
		conn->procedure_expire = 0U;
 100c5fa:	f8a5 30cc 	strh.w	r3, [r5, #204]	; 0xcc
		conn->llcp_version.ack = conn->llcp_version.req;
 100c5fe:	f885 2121 	strb.w	r2, [r5, #289]	; 0x121
	conn->llcp_version.version_number = v->version_number;
 100c602:	f896 2024 	ldrb.w	r2, [r6, #36]	; 0x24
	conn->llcp_version.rx = 1U;
 100c606:	f895 3122 	ldrb.w	r3, [r5, #290]	; 0x122
	conn->llcp_version.version_number = v->version_number;
 100c60a:	f885 2123 	strb.w	r2, [r5, #291]	; 0x123
	conn->llcp_version.company_id = sys_le16_to_cpu(v->company_id);
 100c60e:	f896 1026 	ldrb.w	r1, [r6, #38]	; 0x26
 100c612:	f896 2025 	ldrb.w	r2, [r6, #37]	; 0x25
	conn->llcp_version.rx = 1U;
 100c616:	f043 0302 	orr.w	r3, r3, #2
	conn->llcp_version.company_id = sys_le16_to_cpu(v->company_id);
 100c61a:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 100c61e:	f8a5 2124 	strh.w	r2, [r5, #292]	; 0x124
		sys_le16_to_cpu(v->sub_version_number);
 100c622:	f896 2027 	ldrb.w	r2, [r6, #39]	; 0x27
 100c626:	f896 1028 	ldrb.w	r1, [r6, #40]	; 0x28
	return 0;
 100c62a:	2000      	movs	r0, #0
		sys_le16_to_cpu(v->sub_version_number);
 100c62c:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	conn->llcp_version.sub_version_number =
 100c630:	f8a5 2126 	strh.w	r2, [r5, #294]	; 0x126
	conn->llcp_version.rx = 1U;
 100c634:	f885 3122 	strb.w	r3, [r5, #290]	; 0x122
	return 0;
 100c638:	e449      	b.n	100bece <ull_conn_rx+0xd2>
		if (!conn->lll.role ||
 100c63a:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c63e:	2b00      	cmp	r3, #0
 100c640:	dba4      	blt.n	100c58c <ull_conn_rx+0x790>
 100c642:	e4a7      	b.n	100bf94 <ull_conn_rx+0x198>
		if (!conn->lll.role ||
 100c644:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c648:	2b00      	cmp	r3, #0
 100c64a:	f6bf aca3 	bge.w	100bf94 <ull_conn_rx+0x198>
 100c64e:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c652:	2b0c      	cmp	r3, #12
 100c654:	f47f ac9e 	bne.w	100bf94 <ull_conn_rx+0x198>
	instant = sys_le16_to_cpu(pdu->llctrl.conn_update_ind.instant);
 100c658:	f8b6 002d 	ldrh.w	r0, [r6, #45]	; 0x2d
	if (((instant - conn->lll.event_counter) & 0xFFFF) > 0x7FFF) {
 100c65c:	8eeb      	ldrh	r3, [r5, #54]	; 0x36
 100c65e:	1ac3      	subs	r3, r0, r3
 100c660:	041b      	lsls	r3, r3, #16
 100c662:	f100 85e9 	bmi.w	100d238 <ull_conn_rx+0x143c>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
 100c666:	f895 30e8 	ldrb.w	r3, [r5, #232]	; 0xe8
 100c66a:	f895 20e9 	ldrb.w	r2, [r5, #233]	; 0xe9
 100c66e:	1a9b      	subs	r3, r3, r2
 100c670:	f003 0303 	and.w	r3, r3, #3
 100c674:	2b02      	cmp	r3, #2
 100c676:	f000 8615 	beq.w	100d2a4 <ull_conn_rx+0x14a8>
	if (!conn_upd_curr) {
 100c67a:	4bde      	ldr	r3, [pc, #888]	; (100c9f4 <ull_conn_rx+0xbf8>)
 100c67c:	681a      	ldr	r2, [r3, #0]
 100c67e:	2a00      	cmp	r2, #0
 100c680:	f000 8656 	beq.w	100d330 <ull_conn_rx+0x1534>
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.win_offset) * 1250;
 100c684:	f240 43e2 	movw	r3, #1250	; 0x4e2
	*rx = NULL;
 100c688:	f04f 0c00 	mov.w	ip, #0
	conn->llcp_cu.win_size = pdu->llctrl.conn_update_ind.win_size;
 100c68c:	f896 2024 	ldrb.w	r2, [r6, #36]	; 0x24
 100c690:	f885 2114 	strb.w	r2, [r5, #276]	; 0x114
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.win_offset) * 1250;
 100c694:	f8b6 2025 	ldrh.w	r2, [r6, #37]	; 0x25
 100c698:	fb03 f302 	mul.w	r3, r3, r2
	conn->llcp_cu.win_offset_us =
 100c69c:	f8c5 3110 	str.w	r3, [r5, #272]	; 0x110
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.interval);
 100c6a0:	f896 2028 	ldrb.w	r2, [r6, #40]	; 0x28
 100c6a4:	f896 3027 	ldrb.w	r3, [r6, #39]	; 0x27
 100c6a8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	conn->llcp_cu.interval =
 100c6ac:	f8a5 3108 	strh.w	r3, [r5, #264]	; 0x108
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.latency);
 100c6b0:	f896 202a 	ldrb.w	r2, [r6, #42]	; 0x2a
 100c6b4:	f896 3029 	ldrb.w	r3, [r6, #41]	; 0x29
 100c6b8:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	conn->llcp_cu.latency =
 100c6bc:	f8a5 310a 	strh.w	r3, [r5, #266]	; 0x10a
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.timeout);
 100c6c0:	f896 202c 	ldrb.w	r2, [r6, #44]	; 0x2c
 100c6c4:	f896 102b 	ldrb.w	r1, [r6, #43]	; 0x2b
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
 100c6c8:	f895 3106 	ldrb.w	r3, [r5, #262]	; 0x106
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.timeout);
 100c6cc:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
	conn->llcp_cu.ack--;
 100c6d0:	f895 2105 	ldrb.w	r2, [r5, #261]	; 0x105
	conn->llcp_cu.timeout =
 100c6d4:	f8a5 110c 	strh.w	r1, [r5, #268]	; 0x10c
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
 100c6d8:	f023 0307 	bic.w	r3, r3, #7
	link->mem = conn->llcp_rx;
 100c6dc:	f8d5 1100 	ldr.w	r1, [r5, #256]	; 0x100
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
 100c6e0:	f043 0304 	orr.w	r3, r3, #4
	conn->llcp_cu.ack--;
 100c6e4:	3a01      	subs	r2, #1
 100c6e6:	f885 2105 	strb.w	r2, [r5, #261]	; 0x105
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
 100c6ea:	f885 3106 	strb.w	r3, [r5, #262]	; 0x106
	conn->llcp.conn_upd.instant = instant;
 100c6ee:	f8a5 00ec 	strh.w	r0, [r5, #236]	; 0xec
	link->mem = conn->llcp_rx;
 100c6f2:	6079      	str	r1, [r7, #4]
	(*rx)->hdr.link = link;
 100c6f4:	6823      	ldr	r3, [r4, #0]
 100c6f6:	601f      	str	r7, [r3, #0]
	conn->llcp_rx = *rx;
 100c6f8:	6823      	ldr	r3, [r4, #0]
 100c6fa:	f8c5 3100 	str.w	r3, [r5, #256]	; 0x100
	*rx = NULL;
 100c6fe:	f8c4 c000 	str.w	ip, [r4]
	if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
 100c702:	f895 2170 	ldrb.w	r2, [r5, #368]	; 0x170
 100c706:	f895 3171 	ldrb.w	r3, [r5, #369]	; 0x171
 100c70a:	4293      	cmp	r3, r2
 100c70c:	f43f acb3 	beq.w	100c076 <ull_conn_rx+0x27a>
	    (conn->llcp_conn_param.state == LLCP_CPR_STATE_RSP_WAIT)) {
 100c710:	f895 3172 	ldrb.w	r3, [r5, #370]	; 0x172
	if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
 100c714:	f003 0307 	and.w	r3, r3, #7
 100c718:	2b04      	cmp	r3, #4
 100c71a:	f47f acac 	bne.w	100c076 <ull_conn_rx+0x27a>
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
 100c71e:	f885 2171 	strb.w	r2, [r5, #369]	; 0x171
		if (err) {
 100c722:	e4a8      	b.n	100c076 <ull_conn_rx+0x27a>
		if (!conn->lll.role ||
 100c724:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c728:	2b00      	cmp	r3, #0
 100c72a:	f6bf ac33 	bge.w	100bf94 <ull_conn_rx+0x198>
 100c72e:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c732:	2b08      	cmp	r3, #8
 100c734:	f47f ac2e 	bne.w	100bf94 <ull_conn_rx+0x198>
	instant = sys_le16_to_cpu(pdu->llctrl.chan_map_ind.instant);
 100c738:	f8b6 4029 	ldrh.w	r4, [r6, #41]	; 0x29
	if (((instant - conn->lll.event_counter) & 0xffff) > 0x7fff) {
 100c73c:	8eeb      	ldrh	r3, [r5, #54]	; 0x36
 100c73e:	1ae3      	subs	r3, r4, r3
 100c740:	0419      	lsls	r1, r3, #16
 100c742:	f100 8579 	bmi.w	100d238 <ull_conn_rx+0x143c>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
 100c746:	f895 30e8 	ldrb.w	r3, [r5, #232]	; 0xe8
 100c74a:	f895 20e9 	ldrb.w	r2, [r5, #233]	; 0xe9
 100c74e:	1a9b      	subs	r3, r3, r2
 100c750:	f003 0303 	and.w	r3, r3, #3
 100c754:	2b02      	cmp	r3, #2
 100c756:	f000 85a5 	beq.w	100d2a4 <ull_conn_rx+0x14a8>
	memcpy(&conn->llcp.chan_map.chm[0], &pdu->llctrl.chan_map_ind.chm[0],
 100c75a:	2205      	movs	r2, #5
 100c75c:	f106 0124 	add.w	r1, r6, #36	; 0x24
 100c760:	f105 00ed 	add.w	r0, r5, #237	; 0xed
 100c764:	f00a f958 	bl	1016a18 <memcpy>
	conn->llcp_type = LLCP_CHAN_MAP;
 100c768:	2002      	movs	r0, #2
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c76a:	2103      	movs	r1, #3
	conn->llcp.chan_map.initiate = 0U;
 100c76c:	f895 20ec 	ldrb.w	r2, [r5, #236]	; 0xec
	conn->llcp_ack -= 2U;
 100c770:	f895 30e9 	ldrb.w	r3, [r5, #233]	; 0xe9
	conn->llcp.chan_map.initiate = 0U;
 100c774:	f36f 0200 	bfc	r2, #0, #1
	conn->llcp_ack -= 2U;
 100c778:	3b02      	subs	r3, #2
	conn->llcp_type = LLCP_CHAN_MAP;
 100c77a:	f885 00ea 	strb.w	r0, [r5, #234]	; 0xea
	conn->llcp.chan_map.instant = instant;
 100c77e:	f8a5 40f2 	strh.w	r4, [r5, #242]	; 0xf2
	conn->llcp.chan_map.initiate = 0U;
 100c782:	f885 20ec 	strb.w	r2, [r5, #236]	; 0xec
	conn->llcp_ack -= 2U;
 100c786:	f885 30e9 	strb.w	r3, [r5, #233]	; 0xe9
	int nack = 0;
 100c78a:	2000      	movs	r0, #0
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c78c:	7131      	strb	r1, [r6, #4]
		if (err) {
 100c78e:	f7ff bb9e 	b.w	100bece <ull_conn_rx+0xd2>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP,
 100c792:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c796:	2b02      	cmp	r3, #2
 100c798:	f47f abfc 	bne.w	100bf94 <ull_conn_rx+0x198>
		} else if (conn->llcp_conn_param.ack !=
 100c79c:	f895 2171 	ldrb.w	r2, [r5, #369]	; 0x171
 100c7a0:	f895 3170 	ldrb.w	r3, [r5, #368]	; 0x170
 100c7a4:	429a      	cmp	r2, r3
 100c7a6:	f000 8355 	beq.w	100ce54 <ull_conn_rx+0x1058>
			conn->llcp_conn_param.disabled = 1U;
 100c7aa:	f895 2172 	ldrb.w	r2, [r5, #370]	; 0x172
			if (!conn->lll.role) {
 100c7ae:	f995 103d 	ldrsb.w	r1, [r5, #61]	; 0x3d
			conn->llcp_conn_param.disabled = 1U;
 100c7b2:	f042 0210 	orr.w	r2, r2, #16
			if (!conn->lll.role) {
 100c7b6:	2900      	cmp	r1, #0
			conn->llcp_conn_param.disabled = 1U;
 100c7b8:	f885 2172 	strb.w	r2, [r5, #370]	; 0x172
			if (!conn->lll.role) {
 100c7bc:	f2c0 8378 	blt.w	100ceb0 <ull_conn_rx+0x10b4>
				LL_ASSERT(conn->llcp_cu.req ==
 100c7c0:	f895 2104 	ldrb.w	r2, [r5, #260]	; 0x104
 100c7c4:	f895 3105 	ldrb.w	r3, [r5, #261]	; 0x105
 100c7c8:	429a      	cmp	r2, r3
 100c7ca:	d006      	beq.n	100c7da <ull_conn_rx+0x9de>
 100c7cc:	f241 61d4 	movw	r1, #5844	; 0x16d4
 100c7d0:	4889      	ldr	r0, [pc, #548]	; (100c9f8 <ull_conn_rx+0xbfc>)
 100c7d2:	f7f6 ff55 	bl	1003680 <bt_ctlr_assert_handle>
 100c7d6:	f895 3105 	ldrb.w	r3, [r5, #261]	; 0x105
				conn->llcp_conn_param.state =
 100c7da:	2705      	movs	r7, #5
				conn->llcp_cu.win_size = 1U;
 100c7dc:	2101      	movs	r1, #1
				conn->llcp_cu.win_offset_us = 0U;
 100c7de:	2000      	movs	r0, #0
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c7e0:	2603      	movs	r6, #3
				conn->llcp_conn_param.state =
 100c7e2:	f895 2172 	ldrb.w	r2, [r5, #370]	; 0x172
				conn->llcp_cu.ack--;
 100c7e6:	3b01      	subs	r3, #1
				conn->llcp_conn_param.state =
 100c7e8:	f367 0202 	bfi	r2, r7, #0, #3
				conn->llcp_cu.ack--;
 100c7ec:	f885 3105 	strb.w	r3, [r5, #261]	; 0x105
				conn->llcp_cu.win_size = 1U;
 100c7f0:	f885 1114 	strb.w	r1, [r5, #276]	; 0x114
				conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
 100c7f4:	f3c2 03c0 	ubfx	r3, r2, #3, #1
				conn->llcp_cu.state = LLCP_CUI_STATE_USE;
 100c7f8:	f895 1106 	ldrb.w	r1, [r5, #262]	; 0x106
 100c7fc:	009b      	lsls	r3, r3, #2
 100c7fe:	f021 0107 	bic.w	r1, r1, #7
 100c802:	f043 0301 	orr.w	r3, r3, #1
 100c806:	430b      	orrs	r3, r1
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c808:	6824      	ldr	r4, [r4, #0]
				conn->llcp_cu.interval =
 100c80a:	f8b5 1176 	ldrh.w	r1, [r5, #374]	; 0x176
				conn->llcp_conn_param.state =
 100c80e:	f885 2172 	strb.w	r2, [r5, #370]	; 0x172
				conn->llcp_cu.state = LLCP_CUI_STATE_USE;
 100c812:	f885 3106 	strb.w	r3, [r5, #262]	; 0x106
				conn->llcp_cu.latency =
 100c816:	f8b5 2178 	ldrh.w	r2, [r5, #376]	; 0x178
				conn->llcp_cu.timeout =
 100c81a:	f8b5 317a 	ldrh.w	r3, [r5, #378]	; 0x17a
				conn->llcp_cu.win_offset_us = 0U;
 100c81e:	f8c5 0110 	str.w	r0, [r5, #272]	; 0x110
				conn->llcp_cu.interval =
 100c822:	f8a5 1108 	strh.w	r1, [r5, #264]	; 0x108
				conn->llcp_cu.latency =
 100c826:	f8a5 210a 	strh.w	r2, [r5, #266]	; 0x10a
				conn->llcp_cu.timeout =
 100c82a:	f8a5 310c 	strh.w	r3, [r5, #268]	; 0x10c
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c82e:	7126      	strb	r6, [r4, #4]
				break;
 100c830:	f7ff bb4d 	b.w	100bece <ull_conn_rx+0xd2>
		if (!conn->lll.role ||
 100c834:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c838:	2b00      	cmp	r3, #0
 100c83a:	f6bf abab 	bge.w	100bf94 <ull_conn_rx+0x198>
 100c83e:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c842:	2b17      	cmp	r3, #23
 100c844:	f47f aba6 	bne.w	100bf94 <ull_conn_rx+0x198>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100c848:	486c      	ldr	r0, [pc, #432]	; (100c9fc <ull_conn_rx+0xc00>)
 100c84a:	f7f9 fa65 	bl	1005d18 <mem_acquire>
	if (!tx) {
 100c84e:	4604      	mov	r4, r0
 100c850:	2800      	cmp	r0, #0
 100c852:	f000 8241 	beq.w	100ccd8 <ull_conn_rx+0xedc>
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp) +
 100c856:	220d      	movs	r2, #13
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_RSP;
 100c858:	f04f 0804 	mov.w	r8, #4
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100c85c:	7903      	ldrb	r3, [r0, #4]
	lll_trng_isr_get(pdu_ctrl_tx->llctrl.enc_rsp.skds,
 100c85e:	f100 0708 	add.w	r7, r0, #8
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100c862:	f043 0303 	orr.w	r3, r3, #3
 100c866:	7103      	strb	r3, [r0, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp) +
 100c868:	7142      	strb	r2, [r0, #5]
	lll_trng_isr_get(pdu_ctrl_tx->llctrl.enc_rsp.skds,
 100c86a:	210c      	movs	r1, #12
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_RSP;
 100c86c:	f880 8007 	strb.w	r8, [r0, #7]
	lll_trng_isr_get(pdu_ctrl_tx->llctrl.enc_rsp.skds,
 100c870:	4638      	mov	r0, r7
 100c872:	f003 fb3b 	bl	100feec <lll_trng_isr_get>
	memcpy(&conn->llcp.encryption.skd[8],
 100c876:	4639      	mov	r1, r7
 100c878:	2208      	movs	r2, #8
 100c87a:	f105 00f6 	add.w	r0, r5, #246	; 0xf6
 100c87e:	f00a f8cb 	bl	1016a18 <memcpy>
	memcpy(&conn->lll.ccm_rx.iv[4],
 100c882:	4642      	mov	r2, r8
 100c884:	f104 0110 	add.w	r1, r4, #16
 100c888:	f105 009c 	add.w	r0, r5, #156	; 0x9c
 100c88c:	f00a f8c4 	bl	1016a18 <memcpy>
	    conn->tx_head &&
 100c890:	f8d5 31b0 	ldr.w	r3, [r5, #432]	; 0x1b0
	if (
 100c894:	2b00      	cmp	r3, #0
 100c896:	f000 82ee 	beq.w	100ce76 <ull_conn_rx+0x107a>
	    !conn->llcp_enc.pause_tx &&
 100c89a:	f895 2152 	ldrb.w	r2, [r5, #338]	; 0x152
	    conn->tx_head &&
 100c89e:	0792      	lsls	r2, r2, #30
 100c8a0:	f100 82e9 	bmi.w	100ce76 <ull_conn_rx+0x107a>
	    !conn->llcp_phy.pause_tx &&
 100c8a4:	f895 21ab 	ldrb.w	r2, [r5, #427]	; 0x1ab
 100c8a8:	07d7      	lsls	r7, r2, #31
 100c8aa:	f100 82e4 	bmi.w	100ce76 <ull_conn_rx+0x107a>
		if (conn->tx_head == conn->tx_data) {
 100c8ae:	f8d5 21bc 	ldr.w	r2, [r5, #444]	; 0x1bc
 100c8b2:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 100c8b4:	bf04      	itt	eq
 100c8b6:	681a      	ldreq	r2, [r3, #0]
 100c8b8:	f8c5 21bc 	streq.w	r2, [r5, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 100c8bc:	f8d5 21b4 	ldr.w	r2, [r5, #436]	; 0x1b4
 100c8c0:	2a00      	cmp	r2, #0
 100c8c2:	f000 8553 	beq.w	100d36c <ull_conn_rx+0x1570>
	tx->next = conn->tx_ctrl_last->next;
 100c8c6:	f8d5 31b8 	ldr.w	r3, [r5, #440]	; 0x1b8
 100c8ca:	681a      	ldr	r2, [r3, #0]
 100c8cc:	6022      	str	r2, [r4, #0]
	conn->tx_ctrl_last->next = tx;
 100c8ce:	601c      	str	r4, [r3, #0]
	conn->tx_ctrl_last = tx;
 100c8d0:	f8c5 41b8 	str.w	r4, [r5, #440]	; 0x1b8
	if (!tx->next) {
 100c8d4:	6823      	ldr	r3, [r4, #0]
 100c8d6:	2b00      	cmp	r3, #0
 100c8d8:	f000 8516 	beq.w	100d308 <ull_conn_rx+0x150c>
		conn->llcp.encryption.state = LLCP_ENC_STATE_LTK_WAIT;
 100c8dc:	2002      	movs	r0, #2
		conn->llcp_type = LLCP_ENCRYPTION;
 100c8de:	2103      	movs	r1, #3
		conn->llcp.encryption.state = LLCP_ENC_STATE_LTK_WAIT;
 100c8e0:	f895 20ec 	ldrb.w	r2, [r5, #236]	; 0xec
		conn->llcp_ack -= 2U;
 100c8e4:	f895 30e9 	ldrb.w	r3, [r5, #233]	; 0xe9
		conn->llcp.encryption.state = LLCP_ENC_STATE_LTK_WAIT;
 100c8e8:	f360 0201 	bfi	r2, r0, #0, #2
		conn->llcp_ack -= 2U;
 100c8ec:	3b02      	subs	r3, #2
 100c8ee:	f885 30e9 	strb.w	r3, [r5, #233]	; 0xe9
		conn->llcp.encryption.state = LLCP_ENC_STATE_LTK_WAIT;
 100c8f2:	f885 20ec 	strb.w	r2, [r5, #236]	; 0xec
		conn->llcp_type = LLCP_ENCRYPTION;
 100c8f6:	f885 10ea 	strb.w	r1, [r5, #234]	; 0xea
		memcpy(&conn->llcp.encryption.skd[0],
 100c8fa:	2208      	movs	r2, #8
 100c8fc:	f106 012e 	add.w	r1, r6, #46	; 0x2e
 100c900:	f105 00ee 	add.w	r0, r5, #238	; 0xee
 100c904:	f00a f888 	bl	1016a18 <memcpy>
		memcpy(&conn->lll.ccm_rx.iv[0],
 100c908:	2204      	movs	r2, #4
 100c90a:	f106 0136 	add.w	r1, r6, #54	; 0x36
 100c90e:	f105 0098 	add.w	r0, r5, #152	; 0x98
 100c912:	f00a f881 	bl	1016a18 <memcpy>
		conn->llcp_enc.pause_rx = 1U;
 100c916:	f895 3152 	ldrb.w	r3, [r5, #338]	; 0x152
		conn->procedure_expire = conn->procedure_reload;
 100c91a:	f8b5 20ca 	ldrh.w	r2, [r5, #202]	; 0xca
		conn->llcp_enc.pause_rx = 1U;
 100c91e:	f043 0301 	orr.w	r3, r3, #1
		nack = enc_rsp_send(conn);
 100c922:	2000      	movs	r0, #0
		conn->llcp_enc.pause_rx = 1U;
 100c924:	f885 3152 	strb.w	r3, [r5, #338]	; 0x152
		conn->procedure_expire = conn->procedure_reload;
 100c928:	f8a5 20cc 	strh.w	r2, [r5, #204]	; 0xcc
		break;
 100c92c:	f7ff bacf 	b.w	100bece <ull_conn_rx+0xd2>
		if (conn->lll.role ||
 100c930:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c934:	2b00      	cmp	r3, #0
 100c936:	f6ff ab2d 	blt.w	100bf94 <ull_conn_rx+0x198>
 100c93a:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c93e:	2b0d      	cmp	r3, #13
 100c940:	f47f ab28 	bne.w	100bf94 <ull_conn_rx+0x198>
		memcpy(&conn->llcp.encryption.skd[8],
 100c944:	2208      	movs	r2, #8
 100c946:	f106 0124 	add.w	r1, r6, #36	; 0x24
 100c94a:	f105 00f6 	add.w	r0, r5, #246	; 0xf6
 100c94e:	f00a f863 	bl	1016a18 <memcpy>
		memcpy(&conn->lll.ccm_rx.iv[4],
 100c952:	2204      	movs	r2, #4
 100c954:	f106 012c 	add.w	r1, r6, #44	; 0x2c
 100c958:	f105 009c 	add.w	r0, r5, #156	; 0x9c
 100c95c:	f00a f85c 	bl	1016a18 <memcpy>
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c960:	2103      	movs	r1, #3
		conn->llcp_enc.pause_rx = 1U;
 100c962:	f895 3152 	ldrb.w	r3, [r5, #338]	; 0x152
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c966:	6822      	ldr	r2, [r4, #0]
		conn->llcp_enc.pause_rx = 1U;
 100c968:	f043 0301 	orr.w	r3, r3, #1
 100c96c:	f885 3152 	strb.w	r3, [r5, #338]	; 0x152
	int nack = 0;
 100c970:	2000      	movs	r0, #0
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c972:	7111      	strb	r1, [r2, #4]
		break;
 100c974:	f7ff baab 	b.w	100bece <ull_conn_rx+0xd2>
		if (conn->lll.role || (conn->llcp_req == conn->llcp_ack) ||
 100c978:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c97c:	2b00      	cmp	r3, #0
 100c97e:	f6ff ab09 	blt.w	100bf94 <ull_conn_rx+0x198>
 100c982:	f895 20e8 	ldrb.w	r2, [r5, #232]	; 0xe8
 100c986:	f895 30e9 	ldrb.w	r3, [r5, #233]	; 0xe9
 100c98a:	429a      	cmp	r2, r3
 100c98c:	f43f ab02 	beq.w	100bf94 <ull_conn_rx+0x198>
 100c990:	f895 30ea 	ldrb.w	r3, [r5, #234]	; 0xea
 100c994:	2b03      	cmp	r3, #3
 100c996:	f47f aafd 	bne.w	100bf94 <ull_conn_rx+0x198>
		    (conn->llcp_type != LLCP_ENCRYPTION) ||
 100c99a:	f896 2021 	ldrb.w	r2, [r6, #33]	; 0x21
 100c99e:	2a01      	cmp	r2, #1
 100c9a0:	f47f aaf8 	bne.w	100bf94 <ull_conn_rx+0x198>
		conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
 100c9a4:	f895 20ec 	ldrb.w	r2, [r5, #236]	; 0xec
	int nack = 0;
 100c9a8:	2000      	movs	r0, #0
		conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
 100c9aa:	f36f 0201 	bfc	r2, #0, #2
 100c9ae:	f885 20ec 	strb.w	r2, [r5, #236]	; 0xec
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c9b2:	7133      	strb	r3, [r6, #4]
		break;
 100c9b4:	f7ff ba8b 	b.w	100bece <ull_conn_rx+0xd2>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_START_ENC_RSP,
 100c9b8:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c9bc:	2b01      	cmp	r3, #1
 100c9be:	f47f aae9 	bne.w	100bf94 <ull_conn_rx+0x198>
		if (conn->lll.role) {
 100c9c2:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c9c6:	2b00      	cmp	r3, #0
 100c9c8:	f6ff ab3d 	blt.w	100c046 <ull_conn_rx+0x24a>
 100c9cc:	f7ff bb42 	b.w	100c054 <ull_conn_rx+0x258>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP,
 100c9d0:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c9d4:	2b01      	cmp	r3, #1
 100c9d6:	f47f aadd 	bne.w	100bf94 <ull_conn_rx+0x198>
	} else if (!conn->lll.role) {
 100c9da:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c9de:	2b00      	cmp	r3, #0
 100c9e0:	f280 80ce 	bge.w	100cb80 <ull_conn_rx+0xd84>
		conn->lll.enc_tx = 0;
 100c9e4:	f895 307e 	ldrb.w	r3, [r5, #126]	; 0x7e
 100c9e8:	f36f 1304 	bfc	r3, #4, #1
 100c9ec:	f885 307e 	strb.w	r3, [r5, #126]	; 0x7e
		goto pause_enc_rsp_send_exit;
 100c9f0:	f7ff bafe 	b.w	100bff0 <ull_conn_rx+0x1f4>
 100c9f4:	21004850 	.word	0x21004850
 100c9f8:	01018934 	.word	0x01018934
 100c9fc:	21005288 	.word	0x21005288
		if (conn->llcp_phy.ack != conn->llcp_phy.req) {
 100ca00:	f895 01a8 	ldrb.w	r0, [r5, #424]	; 0x1a8
 100ca04:	f895 31a9 	ldrb.w	r3, [r5, #425]	; 0x1a9
 100ca08:	4283      	cmp	r3, r0
 100ca0a:	f43f aaf1 	beq.w	100bff0 <ull_conn_rx+0x1f4>
	if (rej_ext_ind->error_code != BT_HCI_ERR_LL_PROC_COLLISION) {
 100ca0e:	f896 2025 	ldrb.w	r2, [r6, #37]	; 0x25
 100ca12:	2a23      	cmp	r2, #35	; 0x23
 100ca14:	d013      	beq.n	100ca3e <ull_conn_rx+0xc42>
		conn->lll.phy_tx_time = conn->lll.phy_tx;
 100ca16:	f895 3064 	ldrb.w	r3, [r5, #100]	; 0x64
		conn->procedure_expire = 0U;
 100ca1a:	2400      	movs	r4, #0
		conn->lll.phy_tx_time = conn->lll.phy_tx;
 100ca1c:	4619      	mov	r1, r3
 100ca1e:	f3c3 0302 	ubfx	r3, r3, #0, #3
 100ca22:	f363 1106 	bfi	r1, r3, #4, #3
		conn->llcp_phy.pause_tx = 0U;
 100ca26:	f895 31ab 	ldrb.w	r3, [r5, #427]	; 0x1ab
		conn->llcp_phy.ack = conn->llcp_phy.req;
 100ca2a:	f885 01a9 	strb.w	r0, [r5, #425]	; 0x1a9
		conn->llcp_phy.pause_tx = 0U;
 100ca2e:	f36f 0300 	bfc	r3, #0, #1
		conn->lll.phy_tx_time = conn->lll.phy_tx;
 100ca32:	f885 1064 	strb.w	r1, [r5, #100]	; 0x64
		conn->llcp_phy.pause_tx = 0U;
 100ca36:	f885 31ab 	strb.w	r3, [r5, #427]	; 0x1ab
		conn->procedure_expire = 0U;
 100ca3a:	f8a5 40cc 	strh.w	r4, [r5, #204]	; 0xcc
	if (!conn->llcp_phy.cmd) {
 100ca3e:	f895 31ab 	ldrb.w	r3, [r5, #427]	; 0x1ab
 100ca42:	075c      	lsls	r4, r3, #29
 100ca44:	f57f aad4 	bpl.w	100bff0 <ull_conn_rx+0x1f4>
	rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
 100ca48:	230e      	movs	r3, #14
	p->status = rej_ext_ind->error_code;
 100ca4a:	f886 2020 	strb.w	r2, [r6, #32]
	rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
 100ca4e:	7133      	strb	r3, [r6, #4]
	p->tx = conn->lll.phy_tx;
 100ca50:	f895 3064 	ldrb.w	r3, [r5, #100]	; 0x64
	int nack = 0;
 100ca54:	2000      	movs	r0, #0
	p->tx = conn->lll.phy_tx;
 100ca56:	f3c3 0302 	ubfx	r3, r3, #0, #3
 100ca5a:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
	p->rx = conn->lll.phy_rx;
 100ca5e:	f895 3065 	ldrb.w	r3, [r5, #101]	; 0x65
 100ca62:	f3c3 0302 	ubfx	r3, r3, #0, #3
 100ca66:	f886 3022 	strb.w	r3, [r6, #34]	; 0x22
	if (err) {
 100ca6a:	f7ff ba30 	b.w	100bece <ull_conn_rx+0xd2>
		if (conn->llcp_conn_param.ack != conn->llcp_conn_param.req) {
 100ca6e:	f895 2171 	ldrb.w	r2, [r5, #369]	; 0x171
 100ca72:	f895 3170 	ldrb.w	r3, [r5, #368]	; 0x170
 100ca76:	429a      	cmp	r2, r3
 100ca78:	f43f aaba 	beq.w	100bff0 <ull_conn_rx+0x1f4>
	if (!lll->role && (rej_ext_ind->error_code ==
 100ca7c:	f995 203d 	ldrsb.w	r2, [r5, #61]	; 0x3d
 100ca80:	2a00      	cmp	r2, #0
 100ca82:	f896 2025 	ldrb.w	r2, [r6, #37]	; 0x25
 100ca86:	f2c0 8494 	blt.w	100d3b2 <ull_conn_rx+0x15b6>
 100ca8a:	2a1a      	cmp	r2, #26
 100ca8c:	f000 854e 	beq.w	100d52c <ull_conn_rx+0x1730>
	if (conn->llcp_conn_param.state == LLCP_CPR_STATE_RSP_WAIT) {
 100ca90:	f895 2172 	ldrb.w	r2, [r5, #370]	; 0x172
 100ca94:	f002 0107 	and.w	r1, r2, #7
 100ca98:	2904      	cmp	r1, #4
 100ca9a:	f000 846e 	beq.w	100d37a <ull_conn_rx+0x157e>
	if (!conn->llcp_conn_param.cmd) {
 100ca9e:	0710      	lsls	r0, r2, #28
 100caa0:	f57f aaa6 	bpl.w	100bff0 <ull_conn_rx+0x1f4>
	rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
 100caa4:	210a      	movs	r1, #10
		      lll->interval * 125U / 1000;
 100caa6:	237d      	movs	r3, #125	; 0x7d
 100caa8:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
	cu->status = rej_ext_ind->error_code;
 100caac:	f896 2025 	ldrb.w	r2, [r6, #37]	; 0x25
	rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
 100cab0:	7131      	strb	r1, [r6, #4]
	cu->status = rej_ext_ind->error_code;
 100cab2:	f886 2020 	strb.w	r2, [r6, #32]
	cu->interval = lll->interval;
 100cab6:	8de9      	ldrh	r1, [r5, #46]	; 0x2e
	cu->timeout = conn->supervision_reload *
 100cab8:	f8b5 20c6 	ldrh.w	r2, [r5, #198]	; 0xc6
	cu->latency = lll->latency;
 100cabc:	8e28      	ldrh	r0, [r5, #48]	; 0x30
	cu->timeout = conn->supervision_reload *
 100cabe:	fb01 f202 	mul.w	r2, r1, r2
		      lll->interval * 125U / 1000;
 100cac2:	fb03 f302 	mul.w	r3, r3, r2
 100cac6:	fbb3 f3f4 	udiv	r3, r3, r4
	cu->latency = lll->latency;
 100caca:	84b0      	strh	r0, [r6, #36]	; 0x24
	cu->interval = lll->interval;
 100cacc:	8471      	strh	r1, [r6, #34]	; 0x22
	int nack = 0;
 100cace:	2000      	movs	r0, #0
	cu->timeout = conn->supervision_reload *
 100cad0:	84f3      	strh	r3, [r6, #38]	; 0x26
	if (err) {
 100cad2:	f7ff b9fc 	b.w	100bece <ull_conn_rx+0xd2>
		if ((conn->llcp_ack != conn->llcp_req) &&
 100cad6:	f895 20e8 	ldrb.w	r2, [r5, #232]	; 0xe8
 100cada:	f895 30e9 	ldrb.w	r3, [r5, #233]	; 0xe9
 100cade:	4293      	cmp	r3, r2
 100cae0:	f43f aa86 	beq.w	100bff0 <ull_conn_rx+0x1f4>
 100cae4:	f895 30ea 	ldrb.w	r3, [r5, #234]	; 0xea
 100cae8:	2b03      	cmp	r3, #3
 100caea:	f47f aa81 	bne.w	100bff0 <ull_conn_rx+0x1f4>
	conn->procedure_expire = 0U;
 100caee:	2000      	movs	r0, #0
	pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_IND;
 100caf0:	210d      	movs	r1, #13
	conn->llcp_enc.pause_rx = 0U;
 100caf2:	f895 3152 	ldrb.w	r3, [r5, #338]	; 0x152
	conn->llcp_ack = conn->llcp_req;
 100caf6:	f885 20e9 	strb.w	r2, [r5, #233]	; 0xe9
	conn->llcp_enc.pause_rx = 0U;
 100cafa:	f023 0303 	bic.w	r3, r3, #3
 100cafe:	f885 3152 	strb.w	r3, [r5, #338]	; 0x152
	conn->procedure_expire = 0U;
 100cb02:	f8a5 00cc 	strh.w	r0, [r5, #204]	; 0xcc
	pdu_rx->llctrl.reject_ind.error_code = rej_ext_ind->error_code;
 100cb06:	f896 3025 	ldrb.w	r3, [r6, #37]	; 0x25
	pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_IND;
 100cb0a:	f886 1023 	strb.w	r1, [r6, #35]	; 0x23
	pdu_rx->llctrl.reject_ind.error_code = rej_ext_ind->error_code;
 100cb0e:	f886 3024 	strb.w	r3, [r6, #36]	; 0x24
 100cb12:	f7ff b9dc 	b.w	100bece <ull_conn_rx+0xd2>
		if (conn->llcp_length.ack != conn->llcp_length.req) {
 100cb16:	f895 3198 	ldrb.w	r3, [r5, #408]	; 0x198
 100cb1a:	f895 2199 	ldrb.w	r2, [r5, #409]	; 0x199
 100cb1e:	429a      	cmp	r2, r3
 100cb20:	f43f aa66 	beq.w	100bff0 <ull_conn_rx+0x1f4>
	pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
 100cb24:	2109      	movs	r1, #9
	conn->procedure_expire = 0U;
 100cb26:	2000      	movs	r0, #0
	pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 100cb28:	2215      	movs	r2, #21
	conn->llcp_length.ack = conn->llcp_length.req;
 100cb2a:	f885 3199 	strb.w	r3, [r5, #409]	; 0x199
	conn->procedure_expire = 0U;
 100cb2e:	f8a5 00cc 	strh.w	r0, [r5, #204]	; 0xcc
	pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
 100cb32:	f886 1021 	strb.w	r1, [r6, #33]	; 0x21
	lr->max_rx_octets = sys_cpu_to_le16(conn->lll.max_rx_octets);
 100cb36:	f8b5 305e 	ldrh.w	r3, [r5, #94]	; 0x5e
	lr->max_tx_octets = sys_cpu_to_le16(conn->lll.max_tx_octets);
 100cb3a:	f8b5 405c 	ldrh.w	r4, [r5, #92]	; 0x5c
	lr->max_rx_time = sys_cpu_to_le16(conn->lll.max_rx_time);
 100cb3e:	f8b5 1062 	ldrh.w	r1, [r5, #98]	; 0x62
	lr->max_rx_octets = sys_cpu_to_le16(conn->lll.max_rx_octets);
 100cb42:	84b3      	strh	r3, [r6, #36]	; 0x24
	lr->max_tx_time = sys_cpu_to_le16(conn->lll.max_tx_time);
 100cb44:	f8b5 3060 	ldrh.w	r3, [r5, #96]	; 0x60
	lr->max_tx_octets = sys_cpu_to_le16(conn->lll.max_tx_octets);
 100cb48:	8534      	strh	r4, [r6, #40]	; 0x28
	lr->max_rx_time = sys_cpu_to_le16(conn->lll.max_rx_time);
 100cb4a:	84f1      	strh	r1, [r6, #38]	; 0x26
	lr->max_tx_time = sys_cpu_to_le16(conn->lll.max_tx_time);
 100cb4c:	8573      	strh	r3, [r6, #42]	; 0x2a
	pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 100cb4e:	f886 2023 	strb.w	r2, [r6, #35]	; 0x23
	if (err) {
 100cb52:	f7ff b9bc 	b.w	100bece <ull_conn_rx+0xd2>
		conn->tx_data_last = tx;
 100cb56:	f8c5 01c0 	str.w	r0, [r5, #448]	; 0x1c0
 100cb5a:	f7ff ba49 	b.w	100bff0 <ull_conn_rx+0x1f4>
		((!conn->llcp_enc.refresh &&
 100cb5e:	f1b9 0f02 	cmp.w	r9, #2
 100cb62:	f47f a980 	bne.w	100be66 <ull_conn_rx+0x6a>
 100cb66:	e4ff      	b.n	100c568 <ull_conn_rx+0x76c>
			tx->next = conn->tx_head;
 100cb68:	6003      	str	r3, [r0, #0]
				conn->tx_ctrl = tx;
 100cb6a:	e9c5 006c 	strd	r0, r0, [r5, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 100cb6e:	f8c5 01b8 	str.w	r0, [r5, #440]	; 0x1b8
 100cb72:	f7ff ba3a 	b.w	100bfea <ull_conn_rx+0x1ee>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP,
 100cb76:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100cb7a:	2b01      	cmp	r3, #1
 100cb7c:	f47f aa0a 	bne.w	100bf94 <ull_conn_rx+0x198>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100cb80:	48e2      	ldr	r0, [pc, #904]	; (100cf0c <ull_conn_rx+0x1110>)
 100cb82:	f7f9 f8c9 	bl	1005d18 <mem_acquire>
		if (!tx) {
 100cb86:	4603      	mov	r3, r0
 100cb88:	2800      	cmp	r0, #0
 100cb8a:	f000 80a5 	beq.w	100ccd8 <ull_conn_rx+0xedc>
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
 100cb8e:	2401      	movs	r4, #1
	conn->llcp_enc.pause_rx = 1U;
 100cb90:	f895 1152 	ldrb.w	r1, [r5, #338]	; 0x152
	conn->lll.enc_rx = 0;
 100cb94:	f895 207e 	ldrb.w	r2, [r5, #126]	; 0x7e
	conn->llcp_enc.pause_rx = 1U;
 100cb98:	4321      	orrs	r1, r4
	conn->lll.enc_rx = 0;
 100cb9a:	f022 0218 	bic.w	r2, r2, #24
	conn->llcp_enc.pause_rx = 1U;
 100cb9e:	f885 1152 	strb.w	r1, [r5, #338]	; 0x152
	conn->lll.enc_rx = 0;
 100cba2:	f885 207e 	strb.w	r2, [r5, #126]	; 0x7e
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP;
 100cba6:	200b      	movs	r0, #11
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100cba8:	7919      	ldrb	r1, [r3, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
 100cbaa:	715c      	strb	r4, [r3, #5]
 100cbac:	f7ff bb58 	b.w	100c260 <ull_conn_rx+0x464>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100cbb0:	48d6      	ldr	r0, [pc, #856]	; (100cf0c <ull_conn_rx+0x1110>)
 100cbb2:	f7f9 f8b1 	bl	1005d18 <mem_acquire>
	if (!tx) {
 100cbb6:	4603      	mov	r3, r0
 100cbb8:	2800      	cmp	r0, #0
 100cbba:	f000 808d 	beq.w	100ccd8 <ull_conn_rx+0xedc>
	conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
 100cbbe:	2002      	movs	r0, #2
 100cbc0:	f895 21aa 	ldrb.w	r2, [r5, #426]	; 0x1aa
	if (conn->llcp_phy.ack ==
 100cbc4:	f895 11a9 	ldrb.w	r1, [r5, #425]	; 0x1a9
	conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
 100cbc8:	f360 0201 	bfi	r2, r0, #0, #2
	if (conn->llcp_phy.ack ==
 100cbcc:	f895 01a8 	ldrb.w	r0, [r5, #424]	; 0x1a8
	conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
 100cbd0:	f885 21aa 	strb.w	r2, [r5, #426]	; 0x1aa
	if (conn->llcp_phy.ack ==
 100cbd4:	4288      	cmp	r0, r1
 100cbd6:	d118      	bne.n	100cc0a <ull_conn_rx+0xe0e>
			conn->phy_pref_rx;
 100cbd8:	f895 41ac 	ldrb.w	r4, [r5, #428]	; 0x1ac
		conn->llcp_phy.tx =
 100cbdc:	f8b5 11aa 	ldrh.w	r1, [r5, #426]	; 0x1aa
 100cbe0:	f004 0207 	and.w	r2, r4, #7
 100cbe4:	0092      	lsls	r2, r2, #2
 100cbe6:	f3c4 1402 	ubfx	r4, r4, #4, #3
 100cbea:	f421 619f 	bic.w	r1, r1, #1272	; 0x4f8
 100cbee:	f021 0104 	bic.w	r1, r1, #4
 100cbf2:	ea42 1244 	orr.w	r2, r2, r4, lsl #5
 100cbf6:	430a      	orrs	r2, r1
		conn->procedure_expire =
 100cbf8:	f8b5 10ca 	ldrh.w	r1, [r5, #202]	; 0xca
		conn->llcp_phy.ack--;
 100cbfc:	3801      	subs	r0, #1
 100cbfe:	f885 01a9 	strb.w	r0, [r5, #425]	; 0x1a9
		conn->llcp_phy.tx =
 100cc02:	f8a5 21aa 	strh.w	r2, [r5, #426]	; 0x1aa
		conn->procedure_expire =
 100cc06:	f8a5 10cc 	strh.w	r1, [r5, #204]	; 0xcc
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, phy_rsp) +
 100cc0a:	2703      	movs	r7, #3
	conn->llcp_phy.rx &= p->tx_phys;
 100cc0c:	f895 11aa 	ldrb.w	r1, [r5, #426]	; 0x1aa
	conn->llcp_phy.tx &= p->rx_phys;
 100cc10:	f896 2025 	ldrb.w	r2, [r6, #37]	; 0x25
 100cc14:	f3c1 0482 	ubfx	r4, r1, #2, #3
 100cc18:	4022      	ands	r2, r4
	conn->llcp_phy.rx &= p->tx_phys;
 100cc1a:	f896 4024 	ldrb.w	r4, [r6, #36]	; 0x24
	conn->llcp_phy.tx &= p->rx_phys;
 100cc1e:	0092      	lsls	r2, r2, #2
	conn->llcp_phy.rx &= p->tx_phys;
 100cc20:	ea04 1451 	and.w	r4, r4, r1, lsr #5
	conn->llcp_phy.tx &= p->rx_phys;
 100cc24:	ea42 1244 	orr.w	r2, r2, r4, lsl #5
 100cc28:	4039      	ands	r1, r7
 100cc2a:	430a      	orrs	r2, r1
 100cc2c:	f885 21aa 	strb.w	r2, [r5, #426]	; 0x1aa
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, phy_rsp) +
 100cc30:	715f      	strb	r7, [r3, #5]
	pdu_ctrl_tx->llctrl.phy_rsp.tx_phys = conn->phy_pref_tx;
 100cc32:	f895 21ac 	ldrb.w	r2, [r5, #428]	; 0x1ac
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_RSP;
 100cc36:	2017      	movs	r0, #23
	pdu_ctrl_tx->llctrl.phy_rsp.rx_phys = conn->phy_pref_rx;
 100cc38:	4614      	mov	r4, r2
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100cc3a:	7919      	ldrb	r1, [r3, #4]
	pdu_ctrl_tx->llctrl.phy_rsp.tx_phys = conn->phy_pref_tx;
 100cc3c:	f3c2 0202 	ubfx	r2, r2, #0, #3
 100cc40:	721a      	strb	r2, [r3, #8]
	    conn->tx_head &&
 100cc42:	f8d5 21b0 	ldr.w	r2, [r5, #432]	; 0x1b0
	pdu_ctrl_tx->llctrl.phy_rsp.rx_phys = conn->phy_pref_rx;
 100cc46:	f3c4 1402 	ubfx	r4, r4, #4, #3
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100cc4a:	4339      	orrs	r1, r7
	pdu_ctrl_tx->llctrl.phy_rsp.rx_phys = conn->phy_pref_rx;
 100cc4c:	725c      	strb	r4, [r3, #9]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100cc4e:	7119      	strb	r1, [r3, #4]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_RSP;
 100cc50:	71d8      	strb	r0, [r3, #7]
	if (
 100cc52:	2a00      	cmp	r2, #0
 100cc54:	f47f ab0d 	bne.w	100c272 <ull_conn_rx+0x476>
		if (!conn->tx_ctrl) {
 100cc58:	f8d5 11b4 	ldr.w	r1, [r5, #436]	; 0x1b4
 100cc5c:	2900      	cmp	r1, #0
 100cc5e:	f47f ab1e 	bne.w	100c29e <ull_conn_rx+0x4a2>
			tx->next = conn->tx_head;
 100cc62:	601a      	str	r2, [r3, #0]
				conn->tx_ctrl = tx;
 100cc64:	e9c5 336c 	strd	r3, r3, [r5, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 100cc68:	f8c5 31b8 	str.w	r3, [r5, #440]	; 0x1b8
 100cc6c:	f7ff bb1e 	b.w	100c2ac <ull_conn_rx+0x4b0>
		if (!conn->lll.role) {
 100cc70:	f995 203d 	ldrsb.w	r2, [r5, #61]	; 0x3d
 100cc74:	2a00      	cmp	r2, #0
 100cc76:	f2c0 8109 	blt.w	100ce8c <ull_conn_rx+0x1090>
					conn->llcp_conn_param.ack) &&
 100cc7a:	f895 2171 	ldrb.w	r2, [r5, #369]	; 0x171
 100cc7e:	4611      	mov	r1, r2
 100cc80:	9200      	str	r2, [sp, #0]
			if ((conn->llcp_conn_param.req !=
 100cc82:	f895 2170 	ldrb.w	r2, [r5, #368]	; 0x170
 100cc86:	428a      	cmp	r2, r1
 100cc88:	d009      	beq.n	100cc9e <ull_conn_rx+0xea2>
			    ((conn->llcp_conn_param.state ==
 100cc8a:	f895 2172 	ldrb.w	r2, [r5, #370]	; 0x172
					conn->llcp_conn_param.ack) &&
 100cc8e:	f012 0207 	ands.w	r2, r2, #7
 100cc92:	f000 8201 	beq.w	100d098 <ull_conn_rx+0x129c>
			      LLCP_CPR_STATE_REQ) ||
 100cc96:	3a04      	subs	r2, #4
 100cc98:	2a01      	cmp	r2, #1
 100cc9a:	f240 81fd 	bls.w	100d098 <ull_conn_rx+0x129c>
			} else if (((((conn->llcp_req - conn->llcp_ack) &
 100cc9e:	f895 20e8 	ldrb.w	r2, [r5, #232]	; 0xe8
 100cca2:	f895 10e9 	ldrb.w	r1, [r5, #233]	; 0xe9
 100cca6:	1a52      	subs	r2, r2, r1
 100cca8:	f002 0203 	and.w	r2, r2, #3
 100ccac:	2a02      	cmp	r2, #2
 100ccae:	f000 8354 	beq.w	100d35a <ull_conn_rx+0x155e>
				    (conn->llcp_type != LLCP_ENCRYPTION)) ||
 100ccb2:	f895 11a8 	ldrb.w	r1, [r5, #424]	; 0x1a8
 100ccb6:	f895 21a9 	ldrb.w	r2, [r5, #425]	; 0x1a9
 100ccba:	4291      	cmp	r1, r2
 100ccbc:	f000 8395 	beq.w	100d3ea <ull_conn_rx+0x15ee>
				nack = reject_ext_ind_send(conn, *rx,
 100ccc0:	4628      	mov	r0, r5
 100ccc2:	232a      	movs	r3, #42	; 0x2a
 100ccc4:	220f      	movs	r2, #15
 100ccc6:	1d31      	adds	r1, r6, #4
 100ccc8:	f7ff ba89 	b.w	100c1de <ull_conn_rx+0x3e2>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP,
 100cccc:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100ccd0:	2b01      	cmp	r3, #1
 100ccd2:	f47f a95f 	bne.w	100bf94 <ull_conn_rx+0x198>
 100ccd6:	e685      	b.n	100c9e4 <ull_conn_rx+0xbe8>
		return -ENOBUFS;
 100ccd8:	f06f 0036 	mvn.w	r0, #54	; 0x36
 100ccdc:	f7ff b8f7 	b.w	100bece <ull_conn_rx+0xd2>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100cce0:	488a      	ldr	r0, [pc, #552]	; (100cf0c <ull_conn_rx+0x1110>)
 100cce2:	f7f9 f819 	bl	1005d18 <mem_acquire>
		if (!tx) {
 100cce6:	4601      	mov	r1, r0
 100cce8:	2800      	cmp	r0, #0
 100ccea:	d0f5      	beq.n	100ccd8 <ull_conn_rx+0xedc>
	eff_rx_octets = conn->lll.max_rx_octets;
 100ccec:	f8b5 205e 	ldrh.w	r2, [r5, #94]	; 0x5e
	    ((conn->llcp_length.req == conn->llcp_length.ack) && tx) ||
 100ccf0:	f895 0198 	ldrb.w	r0, [r5, #408]	; 0x198
 100ccf4:	f895 3199 	ldrb.w	r3, [r5, #409]	; 0x199
	eff_rx_octets = conn->lll.max_rx_octets;
 100ccf8:	9201      	str	r2, [sp, #4]
	eff_tx_octets = conn->lll.max_tx_octets;
 100ccfa:	f8b5 205c 	ldrh.w	r2, [r5, #92]	; 0x5c
	if (/* Local idle, and Peer request then complete the Peer procedure
 100ccfe:	4298      	cmp	r0, r3
	eff_rx_time = conn->lll.max_rx_time;
 100cd00:	f8b5 e062 	ldrh.w	lr, [r5, #98]	; 0x62
	eff_tx_time = conn->lll.max_tx_time;
 100cd04:	f8b5 8060 	ldrh.w	r8, [r5, #96]	; 0x60
	    ((conn->llcp_length.req == conn->llcp_length.ack) && tx) ||
 100cd08:	9000      	str	r0, [sp, #0]
	eff_tx_octets = conn->lll.max_tx_octets;
 100cd0a:	9202      	str	r2, [sp, #8]
	if (/* Local idle, and Peer request then complete the Peer procedure
 100cd0c:	f040 8465 	bne.w	100d5da <ull_conn_rx+0x17de>
		max_rx_octets = sys_le16_to_cpu(lr->max_rx_octets);
 100cd10:	8cb3      	ldrh	r3, [r6, #36]	; 0x24
		if (max_rx_octets >= PDU_DC_PAYLOAD_SIZE_MIN) {
 100cd12:	2b1a      	cmp	r3, #26
 100cd14:	f240 81be 	bls.w	100d094 <ull_conn_rx+0x1298>
			eff_tx_octets = MIN(max_rx_octets,
 100cd18:	f8b5 00d6 	ldrh.w	r0, [r5, #214]	; 0xd6
 100cd1c:	4298      	cmp	r0, r3
 100cd1e:	bf28      	it	cs
 100cd20:	4618      	movcs	r0, r3
		max_tx_octets = sys_le16_to_cpu(lr->max_tx_octets);
 100cd22:	f8b6 c028 	ldrh.w	ip, [r6, #40]	; 0x28
		if (max_tx_octets >= PDU_DC_PAYLOAD_SIZE_MIN) {
 100cd26:	f1bc 0f1a 	cmp.w	ip, #26
 100cd2a:	f240 81b0 	bls.w	100d08e <ull_conn_rx+0x1292>
			eff_rx_octets = MIN(max_tx_octets,
 100cd2e:	f1bc 0ffb 	cmp.w	ip, #251	; 0xfb
 100cd32:	bf28      	it	cs
 100cd34:	f04f 0cfb 	movcs.w	ip, #251	; 0xfb
	if (!conn->common.fex_valid ||
 100cd38:	f895 30dc 	ldrb.w	r3, [r5, #220]	; 0xdc
 100cd3c:	07db      	lsls	r3, r3, #31
 100cd3e:	f140 80eb 	bpl.w	100cf18 <ull_conn_rx+0x111c>
	feature_coded_phy = (conn->llcp_feature.features &
 100cd42:	f8d5 311c 	ldr.w	r3, [r5, #284]	; 0x11c
	if (!conn->common.fex_valid ||
 100cd46:	051a      	lsls	r2, r3, #20
 100cd48:	f140 82e2 	bpl.w	100d310 <ull_conn_rx+0x1514>
		tx_time = MIN(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_CODED),
 100cd4c:	f244 2a90 	movw	sl, #17040	; 0x4290
 100cd50:	f8b5 30d8 	ldrh.w	r3, [r5, #216]	; 0xd8
		rx_time = MAX(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_CODED),
 100cd54:	46d1      	mov	r9, sl
		tx_time = MIN(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_CODED),
 100cd56:	4553      	cmp	r3, sl
 100cd58:	bf28      	it	cs
 100cd5a:	4653      	movcs	r3, sl
		tx_time = MAX(PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M), tx_time);
 100cd5c:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
 100cd60:	bf38      	it	cc
 100cd62:	f44f 73a4 	movcc.w	r3, #328	; 0x148
		lr_rx_time = sys_le16_to_cpu(lr->max_rx_time);
 100cd66:	f8b6 b026 	ldrh.w	fp, [r6, #38]	; 0x26
		lr_tx_time = sys_le16_to_cpu(lr->max_tx_time);
 100cd6a:	8d72      	ldrh	r2, [r6, #42]	; 0x2a
		if (lr_rx_time >= PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M)) {
 100cd6c:	f5bb 7fa4 	cmp.w	fp, #328	; 0x148
		lr_tx_time = sys_le16_to_cpu(lr->max_tx_time);
 100cd70:	9203      	str	r2, [sp, #12]
		if (lr_rx_time >= PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M)) {
 100cd72:	f0c0 818a 	bcc.w	100d08a <ull_conn_rx+0x128e>
			eff_tx_time = MAX(eff_tx_time,
 100cd76:	f895 a064 	ldrb.w	sl, [r5, #100]	; 0x64
			eff_tx_time = MIN(lr_rx_time, max_tx_time);
 100cd7a:	459b      	cmp	fp, r3
 100cd7c:	bf28      	it	cs
 100cd7e:	469b      	movcs	fp, r3
			eff_tx_time = MAX(eff_tx_time,
 100cd80:	f01a 0f04 	tst.w	sl, #4
 100cd84:	f00a 0307 	and.w	r3, sl, #7
 100cd88:	f040 82ed 	bne.w	100d366 <ull_conn_rx+0x156a>
 100cd8c:	f103 0a28 	add.w	sl, r3, #40	; 0x28
 100cd90:	ea4f 0aca 	mov.w	sl, sl, lsl #3
 100cd94:	105b      	asrs	r3, r3, #1
 100cd96:	fa2a f303 	lsr.w	r3, sl, r3
 100cd9a:	455b      	cmp	r3, fp
 100cd9c:	bf38      	it	cc
 100cd9e:	465b      	movcc	r3, fp
 100cda0:	b29b      	uxth	r3, r3
		if (lr_tx_time >= PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M)) {
 100cda2:	9a03      	ldr	r2, [sp, #12]
 100cda4:	f5b2 7fa4 	cmp.w	r2, #328	; 0x148
 100cda8:	f0c0 817c 	bcc.w	100d0a4 <ull_conn_rx+0x12a8>
			eff_rx_time = MIN(lr_tx_time, max_rx_time);
 100cdac:	454a      	cmp	r2, r9
 100cdae:	bf28      	it	cs
 100cdb0:	464a      	movcs	r2, r9
			eff_rx_time = MAX(eff_rx_time,
 100cdb2:	f895 a065 	ldrb.w	sl, [r5, #101]	; 0x65
			eff_rx_time = MIN(lr_tx_time, max_rx_time);
 100cdb6:	4693      	mov	fp, r2
			eff_rx_time = MAX(eff_rx_time,
 100cdb8:	f01a 0f04 	tst.w	sl, #4
 100cdbc:	f00a 0907 	and.w	r9, sl, #7
 100cdc0:	f040 82b9 	bne.w	100d336 <ull_conn_rx+0x153a>
 100cdc4:	f109 0a28 	add.w	sl, r9, #40	; 0x28
 100cdc8:	ea4f 0aca 	mov.w	sl, sl, lsl #3
 100cdcc:	ea4f 0969 	mov.w	r9, r9, asr #1
 100cdd0:	fa2a f909 	lsr.w	r9, sl, r9
 100cdd4:	45d9      	cmp	r9, fp
 100cdd6:	bf38      	it	cc
 100cdd8:	46d9      	movcc	r9, fp
 100cdda:	fa1f f989 	uxth.w	r9, r9
		if (eff_rx_octets != conn->lll.max_rx_octets) {
 100cdde:	9a01      	ldr	r2, [sp, #4]
 100cde0:	4594      	cmp	ip, r2
 100cde2:	f000 8236 	beq.w	100d252 <ull_conn_rx+0x1456>
			conn->llcp_length.ack = conn->llcp_length.req - 1;
 100cde6:	9a00      	ldr	r2, [sp, #0]
			conn->llcp_length.rx_octets = eff_rx_octets;
 100cde8:	f8a5 c19c 	strh.w	ip, [r5, #412]	; 0x19c
			conn->llcp_length.ack = conn->llcp_length.req - 1;
 100cdec:	3a01      	subs	r2, #1
 100cdee:	f885 2199 	strb.w	r2, [r5, #409]	; 0x199
			conn->llcp_length.tx_octets = eff_tx_octets;
 100cdf2:	f8a5 019e 	strh.w	r0, [r5, #414]	; 0x19e
			conn->llcp_length.rx_time = eff_rx_time;
 100cdf6:	f8a5 91a0 	strh.w	r9, [r5, #416]	; 0x1a0
			conn->llcp_length.tx_time = eff_tx_time;
 100cdfa:	f8a5 31a2 	strh.w	r3, [r5, #418]	; 0x1a2
			if (tx) {
 100cdfe:	2900      	cmp	r1, #0
 100ce00:	f000 829c 	beq.w	100d33c <ull_conn_rx+0x1540>
				conn->llcp_length.state =
 100ce04:	2605      	movs	r6, #5
 100ce06:	f895 219a 	ldrb.w	r2, [r5, #410]	; 0x19a
 100ce0a:	f366 0202 	bfi	r2, r6, #0, #3
 100ce0e:	f885 219a 	strb.w	r2, [r5, #410]	; 0x19a
			*rx = NULL;
 100ce12:	2600      	movs	r6, #0
			link->mem = conn->llcp_rx;
 100ce14:	f8d5 2100 	ldr.w	r2, [r5, #256]	; 0x100
 100ce18:	607a      	str	r2, [r7, #4]
			(*rx)->hdr.link = link;
 100ce1a:	6822      	ldr	r2, [r4, #0]
 100ce1c:	6017      	str	r7, [r2, #0]
			conn->llcp_rx = *rx;
 100ce1e:	6822      	ldr	r2, [r4, #0]
 100ce20:	f8c5 2100 	str.w	r2, [r5, #256]	; 0x100
			*rx = NULL;
 100ce24:	6026      	str	r6, [r4, #0]
	if (tx) {
 100ce26:	2900      	cmp	r1, #0
 100ce28:	f43f a8a4 	beq.w	100bf74 <ull_conn_rx+0x178>
	pdu_tx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
 100ce2c:	2609      	movs	r6, #9
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 100ce2e:	2415      	movs	r4, #21
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100ce30:	790a      	ldrb	r2, [r1, #4]
	pdu_tx->llctrl.length_rsp.max_tx_octets =
 100ce32:	8188      	strh	r0, [r1, #12]
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100ce34:	f042 0203 	orr.w	r2, r2, #3
	ctrl_tx_sec_enqueue(conn, tx);
 100ce38:	4628      	mov	r0, r5
	pdu_tx->llctrl.length_rsp.max_rx_octets =
 100ce3a:	f8a1 c008 	strh.w	ip, [r1, #8]
	pdu_tx->llctrl.length_rsp.max_rx_time = sys_cpu_to_le16(eff_rx_time);
 100ce3e:	f8a1 900a 	strh.w	r9, [r1, #10]
	pdu_tx->llctrl.length_rsp.max_tx_time = sys_cpu_to_le16(eff_tx_time);
 100ce42:	81cb      	strh	r3, [r1, #14]
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100ce44:	710a      	strb	r2, [r1, #4]
	pdu_tx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
 100ce46:	714e      	strb	r6, [r1, #5]
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 100ce48:	71cc      	strb	r4, [r1, #7]
	ctrl_tx_sec_enqueue(conn, tx);
 100ce4a:	f7fe fb5b 	bl	100b504 <ctrl_tx_sec_enqueue>
	return 0;
 100ce4e:	2000      	movs	r0, #0
}
 100ce50:	f7ff b83d 	b.w	100bece <ull_conn_rx+0xd2>
		} else if (conn->llcp_length.req != conn->llcp_length.ack) {
 100ce54:	f895 2198 	ldrb.w	r2, [r5, #408]	; 0x198
 100ce58:	f895 3199 	ldrb.w	r3, [r5, #409]	; 0x199
 100ce5c:	4293      	cmp	r3, r2
 100ce5e:	f000 8227 	beq.w	100d2b0 <ull_conn_rx+0x14b4>
			conn->llcp_length.disabled = 1U;
 100ce62:	f895 319a 	ldrb.w	r3, [r5, #410]	; 0x19a
			conn->llcp_length.ack = conn->llcp_length.req;
 100ce66:	f885 2199 	strb.w	r2, [r5, #409]	; 0x199
			conn->llcp_length.disabled = 1U;
 100ce6a:	f043 0308 	orr.w	r3, r3, #8
 100ce6e:	f885 319a 	strb.w	r3, [r5, #410]	; 0x19a
			conn->llcp_length.ack = conn->llcp_length.req;
 100ce72:	f7ff b900 	b.w	100c076 <ull_conn_rx+0x27a>
		if (!conn->tx_ctrl) {
 100ce76:	f8d5 21b4 	ldr.w	r2, [r5, #436]	; 0x1b4
 100ce7a:	2a00      	cmp	r2, #0
 100ce7c:	f47f ad23 	bne.w	100c8c6 <ull_conn_rx+0xaca>
			tx->next = conn->tx_head;
 100ce80:	6023      	str	r3, [r4, #0]
				conn->tx_ctrl = tx;
 100ce82:	e9c5 446c 	strd	r4, r4, [r5, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 100ce86:	f8c5 41b8 	str.w	r4, [r5, #440]	; 0x1b8
 100ce8a:	e523      	b.n	100c8d4 <ull_conn_rx+0xad8>
			    conn->llcp_conn_param.ack) ||
 100ce8c:	f895 1171 	ldrb.w	r1, [r5, #369]	; 0x171
		} else if ((conn->llcp_conn_param.req ==
 100ce90:	f895 3170 	ldrb.w	r3, [r5, #368]	; 0x170
 100ce94:	428b      	cmp	r3, r1
 100ce96:	d06c      	beq.n	100cf72 <ull_conn_rx+0x1176>
			    conn->llcp_conn_param.ack) ||
 100ce98:	f895 3172 	ldrb.w	r3, [r5, #370]	; 0x172
 100ce9c:	079b      	lsls	r3, r3, #30
 100ce9e:	d068      	beq.n	100cf72 <ull_conn_rx+0x1176>
			LL_ASSERT(0);
 100cea0:	481b      	ldr	r0, [pc, #108]	; (100cf10 <ull_conn_rx+0x1114>)
 100cea2:	f241 6154 	movw	r1, #5716	; 0x1654
 100cea6:	f7f6 fbeb 	bl	1003680 <bt_ctlr_assert_handle>
	int nack = 0;
 100ceaa:	2000      	movs	r0, #0
 100ceac:	f7ff b80f 	b.w	100bece <ull_conn_rx+0xd2>
			LL_ASSERT(conn_upd_curr == conn);
 100ceb0:	4f18      	ldr	r7, [pc, #96]	; (100cf14 <ull_conn_rx+0x1118>)
 100ceb2:	683a      	ldr	r2, [r7, #0]
 100ceb4:	4295      	cmp	r5, r2
 100ceb6:	d006      	beq.n	100cec6 <ull_conn_rx+0x10ca>
 100ceb8:	f241 61ec 	movw	r1, #5868	; 0x16ec
 100cebc:	4814      	ldr	r0, [pc, #80]	; (100cf10 <ull_conn_rx+0x1114>)
 100cebe:	f7f6 fbdf 	bl	1003680 <bt_ctlr_assert_handle>
 100cec2:	f895 3170 	ldrb.w	r3, [r5, #368]	; 0x170
			conn_upd_curr = NULL;
 100cec6:	2200      	movs	r2, #0
			conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
 100cec8:	f885 3171 	strb.w	r3, [r5, #369]	; 0x171
			if (!conn->llcp_conn_param.cmd) {
 100cecc:	f895 3172 	ldrb.w	r3, [r5, #370]	; 0x172
			conn_upd_curr = NULL;
 100ced0:	603a      	str	r2, [r7, #0]
			if (!conn->llcp_conn_param.cmd) {
 100ced2:	f013 0308 	ands.w	r3, r3, #8
 100ced6:	f000 80ee 	beq.w	100d0b6 <ull_conn_rx+0x12ba>
			cu->status = BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
 100ceda:	221a      	movs	r2, #26
			(*rx)->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
 100cedc:	270a      	movs	r7, #10
				      lll->interval * 125U / 1000;
 100cede:	237d      	movs	r3, #125	; 0x7d
 100cee0:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
			(*rx)->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
 100cee4:	6820      	ldr	r0, [r4, #0]
 100cee6:	7107      	strb	r7, [r0, #4]
			cu->status = BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
 100cee8:	f886 2020 	strb.w	r2, [r6, #32]
			cu->interval = lll->interval;
 100ceec:	8dea      	ldrh	r2, [r5, #46]	; 0x2e
			cu->timeout = conn->supervision_reload *
 100ceee:	f8b5 00c6 	ldrh.w	r0, [r5, #198]	; 0xc6
			cu->interval = lll->interval;
 100cef2:	8472      	strh	r2, [r6, #34]	; 0x22
			cu->timeout = conn->supervision_reload *
 100cef4:	fb02 f200 	mul.w	r2, r2, r0
				      lll->interval * 125U / 1000;
 100cef8:	fb03 f302 	mul.w	r3, r3, r2
 100cefc:	fbb3 f3f1 	udiv	r3, r3, r1
			cu->latency = lll->latency;
 100cf00:	8e2a      	ldrh	r2, [r5, #48]	; 0x30
			cu->timeout = conn->supervision_reload *
 100cf02:	84f3      	strh	r3, [r6, #38]	; 0x26
			cu->latency = lll->latency;
 100cf04:	84b2      	strh	r2, [r6, #36]	; 0x24
			cu->timeout = conn->supervision_reload *
 100cf06:	f7ff b8b6 	b.w	100c076 <ull_conn_rx+0x27a>
 100cf0a:	bf00      	nop
 100cf0c:	21005288 	.word	0x21005288
 100cf10:	01018934 	.word	0x01018934
 100cf14:	21004850 	.word	0x21004850
		tx_time = MAX(MIN(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_1M),
 100cf18:	f640 0a48 	movw	sl, #2120	; 0x848
 100cf1c:	e718      	b.n	100cd50 <ull_conn_rx+0xf54>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100cf1e:	48e3      	ldr	r0, [pc, #908]	; (100d2ac <ull_conn_rx+0x14b0>)
 100cf20:	f7f8 fefa 	bl	1005d18 <mem_acquire>
		if (!tx) {
 100cf24:	4601      	mov	r1, r0
 100cf26:	2800      	cmp	r0, #0
 100cf28:	f43f aed6 	beq.w	100ccd8 <ull_conn_rx+0xedc>
		v->sub_version_number =
 100cf2c:	f04f 32ff 	mov.w	r2, #4294967295
		pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
 100cf30:	f04f 0e0c 	mov.w	lr, #12
		v->version_number = LL_VERSION_NUMBER;
 100cf34:	f04f 0c0b 	mov.w	ip, #11
		v->company_id =	sys_cpu_to_le16(ll_settings_company_id());
 100cf38:	2005      	movs	r0, #5
 100cf3a:	f06f 070e 	mvn.w	r7, #14
		conn->llcp_version.tx = 1U;
 100cf3e:	f895 3122 	ldrb.w	r3, [r5, #290]	; 0x122
 100cf42:	f043 0301 	orr.w	r3, r3, #1
 100cf46:	f885 3122 	strb.w	r3, [r5, #290]	; 0x122
		pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100cf4a:	790b      	ldrb	r3, [r1, #4]
		v->company_id =	sys_cpu_to_le16(ll_settings_company_id());
 100cf4c:	7288      	strb	r0, [r1, #10]
		pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100cf4e:	f043 0303 	orr.w	r3, r3, #3
 100cf52:	710b      	strb	r3, [r1, #4]
		ctrl_tx_sec_enqueue(conn, tx);
 100cf54:	4628      	mov	r0, r5
		pdu_tx->len =
 100cf56:	714c      	strb	r4, [r1, #5]
		pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
 100cf58:	f881 e007 	strb.w	lr, [r1, #7]
		v->version_number = LL_VERSION_NUMBER;
 100cf5c:	f881 c008 	strb.w	ip, [r1, #8]
		v->company_id =	sys_cpu_to_le16(ll_settings_company_id());
 100cf60:	724f      	strb	r7, [r1, #9]
		v->sub_version_number =
 100cf62:	72ca      	strb	r2, [r1, #11]
 100cf64:	730a      	strb	r2, [r1, #12]
		ctrl_tx_sec_enqueue(conn, tx);
 100cf66:	f7fe facd 	bl	100b504 <ctrl_tx_sec_enqueue>
		rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100cf6a:	2303      	movs	r3, #3
 100cf6c:	7133      	strb	r3, [r6, #4]
 100cf6e:	f7ff bb48 	b.w	100c602 <ull_conn_rx+0x806>
			u16_t interval_min = sys_le16_to_cpu(cpr->interval_min);
 100cf72:	f8b6 a024 	ldrh.w	sl, [r6, #36]	; 0x24
 100cf76:	fa1f f38a 	uxth.w	r3, sl
			if ((interval_min < 6) ||
 100cf7a:	2b05      	cmp	r3, #5
 100cf7c:	d97f      	bls.n	100d07e <ull_conn_rx+0x1282>
			u16_t interval_max = sys_le16_to_cpu(cpr->interval_max);
 100cf7e:	8cf2      	ldrh	r2, [r6, #38]	; 0x26
 100cf80:	f8ad 2000 	strh.w	r2, [sp]
 100cf84:	b292      	uxth	r2, r2
			if ((interval_min < 6) ||
 100cf86:	f5b2 6f48 	cmp.w	r2, #3200	; 0xc80
 100cf8a:	d878      	bhi.n	100d07e <ull_conn_rx+0x1282>
			    (interval_max > 3200) ||
 100cf8c:	4293      	cmp	r3, r2
 100cf8e:	d876      	bhi.n	100d07e <ull_conn_rx+0x1282>
			u16_t latency = sys_le16_to_cpu(cpr->latency);
 100cf90:	f8b6 8028 	ldrh.w	r8, [r6, #40]	; 0x28
 100cf94:	fa1f f088 	uxth.w	r0, r8
			    (interval_min > interval_max) ||
 100cf98:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
 100cf9c:	d26f      	bcs.n	100d07e <ull_conn_rx+0x1282>
			    (latency > 499) ||
 100cf9e:	f640 4b76 	movw	fp, #3190	; 0xc76
			u16_t timeout = sys_le16_to_cpu(cpr->timeout);
 100cfa2:	f8b6 e02a 	ldrh.w	lr, [r6, #42]	; 0x2a
 100cfa6:	fa1f f38e 	uxth.w	r3, lr
			    (latency > 499) ||
 100cfaa:	f1a3 0c0a 	sub.w	ip, r3, #10
 100cfae:	fa1f fc8c 	uxth.w	ip, ip
 100cfb2:	45dc      	cmp	ip, fp
 100cfb4:	d863      	bhi.n	100d07e <ull_conn_rx+0x1282>
			     ((latency + 1) * interval_max)) ||
 100cfb6:	fb00 2c02 	mla	ip, r0, r2, r2
			    (timeout < 10) || (timeout > 3200) ||
 100cfba:	ebbc 0f83 	cmp.w	ip, r3, lsl #2
 100cfbe:	d25e      	bcs.n	100d07e <ull_conn_rx+0x1282>
			     ((latency + 1) * interval_max)) ||
 100cfc0:	f896 b02c 	ldrb.w	fp, [r6, #44]	; 0x2c
 100cfc4:	455a      	cmp	r2, fp
 100cfc6:	d35a      	bcc.n	100d07e <ull_conn_rx+0x1282>
			conn->llcp_conn_param.interval_min = interval_min;
 100cfc8:	f8a5 a174 	strh.w	sl, [r5, #372]	; 0x174
			conn->llcp_conn_param.interval_max = interval_max;
 100cfcc:	f8bd a000 	ldrh.w	sl, [sp]
			conn->llcp_conn_param.timeout =	timeout;
 100cfd0:	f8a5 e17a 	strh.w	lr, [r5, #378]	; 0x17a
			conn->llcp_conn_param.interval_max = interval_max;
 100cfd4:	f8a5 a176 	strh.w	sl, [r5, #374]	; 0x176
			conn->llcp_conn_param.latency =	latency;
 100cfd8:	f8a5 8178 	strh.w	r8, [r5, #376]	; 0x178
			conn->llcp_conn_param.preferred_periodicity =
 100cfdc:	f885 b17c 	strb.w	fp, [r5, #380]	; 0x17c
				sys_le16_to_cpu(cpr->reference_conn_event_count);
 100cfe0:	f896 802e 	ldrb.w	r8, [r6, #46]	; 0x2e
 100cfe4:	f896 c02d 	ldrb.w	ip, [r6, #45]	; 0x2d
			     lll->interval) ||
 100cfe8:	f8b5 e02e 	ldrh.w	lr, [r5, #46]	; 0x2e
				sys_le16_to_cpu(cpr->reference_conn_event_count);
 100cfec:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
			conn->llcp_conn_param.reference_conn_event_count =
 100cff0:	f8a5 c17e 	strh.w	ip, [r5, #382]	; 0x17e
				sys_le16_to_cpu(cpr->offset0);
 100cff4:	f896 8030 	ldrb.w	r8, [r6, #48]	; 0x30
 100cff8:	f896 c02f 	ldrb.w	ip, [r6, #47]	; 0x2f
			if ((conn->llcp_conn_param.interval_max !=
 100cffc:	4572      	cmp	r2, lr
				sys_le16_to_cpu(cpr->offset0);
 100cffe:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
			conn->llcp_conn_param.offset0 =
 100d002:	f8a5 c180 	strh.w	ip, [r5, #384]	; 0x180
				sys_le16_to_cpu(cpr->offset1);
 100d006:	f896 8032 	ldrb.w	r8, [r6, #50]	; 0x32
 100d00a:	f896 c031 	ldrb.w	ip, [r6, #49]	; 0x31
 100d00e:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
			conn->llcp_conn_param.offset1 =
 100d012:	f8a5 c182 	strh.w	ip, [r5, #386]	; 0x182
				sys_le16_to_cpu(cpr->offset2);
 100d016:	f896 8034 	ldrb.w	r8, [r6, #52]	; 0x34
 100d01a:	f896 c033 	ldrb.w	ip, [r6, #51]	; 0x33
 100d01e:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
			conn->llcp_conn_param.offset2 =
 100d022:	f8a5 c184 	strh.w	ip, [r5, #388]	; 0x184
				sys_le16_to_cpu(cpr->offset3);
 100d026:	f896 8036 	ldrb.w	r8, [r6, #54]	; 0x36
 100d02a:	f896 c035 	ldrb.w	ip, [r6, #53]	; 0x35
 100d02e:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
			conn->llcp_conn_param.offset3 =
 100d032:	f8a5 c186 	strh.w	ip, [r5, #390]	; 0x186
				sys_le16_to_cpu(cpr->offset4);
 100d036:	f896 c037 	ldrb.w	ip, [r6, #55]	; 0x37
 100d03a:	f896 8038 	ldrb.w	r8, [r6, #56]	; 0x38
 100d03e:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
			conn->llcp_conn_param.offset4 =
 100d042:	f8a5 c188 	strh.w	ip, [r5, #392]	; 0x188
				sys_le16_to_cpu(cpr->offset5);
 100d046:	f896 c039 	ldrb.w	ip, [r6, #57]	; 0x39
 100d04a:	f896 603a 	ldrb.w	r6, [r6, #58]	; 0x3a
 100d04e:	ea4c 2606 	orr.w	r6, ip, r6, lsl #8
			conn->llcp_conn_param.offset5 =
 100d052:	f8a5 618a 	strh.w	r6, [r5, #394]	; 0x18a
			if ((conn->llcp_conn_param.interval_max !=
 100d056:	f000 829f 	beq.w	100d598 <ull_conn_rx+0x179c>
				conn->llcp_conn_param.state =
 100d05a:	2203      	movs	r2, #3
 100d05c:	f895 3172 	ldrb.w	r3, [r5, #370]	; 0x172
 100d060:	f362 0302 	bfi	r3, r2, #0, #3
 100d064:	f885 3172 	strb.w	r3, [r5, #370]	; 0x172
			conn->llcp_conn_param.ack--;
 100d068:	3901      	subs	r1, #1
 100d06a:	f885 1171 	strb.w	r1, [r5, #369]	; 0x171
			if (!conn_upd_curr) {
 100d06e:	f1b9 0f00 	cmp.w	r9, #0
 100d072:	f47e af7f 	bne.w	100bf74 <ull_conn_rx+0x178>
	int nack = 0;
 100d076:	4648      	mov	r0, r9
				conn_upd_curr = conn;
 100d078:	603d      	str	r5, [r7, #0]
 100d07a:	f7fe bf28 	b.w	100bece <ull_conn_rx+0xd2>
				nack = reject_ext_ind_send(conn, *rx,
 100d07e:	4628      	mov	r0, r5
 100d080:	231e      	movs	r3, #30
 100d082:	220f      	movs	r2, #15
 100d084:	1d31      	adds	r1, r6, #4
 100d086:	f7ff b8aa 	b.w	100c1de <ull_conn_rx+0x3e2>
 100d08a:	4643      	mov	r3, r8
 100d08c:	e689      	b.n	100cda2 <ull_conn_rx+0xfa6>
 100d08e:	f8dd c004 	ldr.w	ip, [sp, #4]
 100d092:	e651      	b.n	100cd38 <ull_conn_rx+0xf3c>
 100d094:	9802      	ldr	r0, [sp, #8]
 100d096:	e644      	b.n	100cd22 <ull_conn_rx+0xf26>
				nack = reject_ext_ind_send(conn, *rx,
 100d098:	4628      	mov	r0, r5
 100d09a:	2323      	movs	r3, #35	; 0x23
 100d09c:	220f      	movs	r2, #15
 100d09e:	1d31      	adds	r1, r6, #4
 100d0a0:	f7ff b89d 	b.w	100c1de <ull_conn_rx+0x3e2>
 100d0a4:	46f1      	mov	r9, lr
 100d0a6:	e69a      	b.n	100cdde <ull_conn_rx+0xfe2>
				      0x03) == 0x02) &&
 100d0a8:	f895 30ea 	ldrb.w	r3, [r5, #234]	; 0xea
 100d0ac:	2b03      	cmp	r3, #3
 100d0ae:	f47f a892 	bne.w	100c1d6 <ull_conn_rx+0x3da>
 100d0b2:	f7ff b889 	b.w	100c1c8 <ull_conn_rx+0x3cc>
			(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d0b6:	2103      	movs	r1, #3
 100d0b8:	6822      	ldr	r2, [r4, #0]
	int nack = 0;
 100d0ba:	4618      	mov	r0, r3
			(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d0bc:	7111      	strb	r1, [r2, #4]
		if (err) {
 100d0be:	f7fe bf06 	b.w	100bece <ull_conn_rx+0xd2>
	instant = sys_le16_to_cpu(ind->instant);
 100d0c2:	8cf1      	ldrh	r1, [r6, #38]	; 0x26
	if (((instant - conn->lll.event_counter) & 0xffff) > 0x7fff) {
 100d0c4:	8eea      	ldrh	r2, [r5, #54]	; 0x36
 100d0c6:	1a8a      	subs	r2, r1, r2
 100d0c8:	0412      	lsls	r2, r2, #16
 100d0ca:	f100 80b5 	bmi.w	100d238 <ull_conn_rx+0x143c>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
 100d0ce:	f895 20e8 	ldrb.w	r2, [r5, #232]	; 0xe8
 100d0d2:	f895 c0e9 	ldrb.w	ip, [r5, #233]	; 0xe9
 100d0d6:	eba2 020c 	sub.w	r2, r2, ip
 100d0da:	f002 0203 	and.w	r2, r2, #3
 100d0de:	2a02      	cmp	r2, #2
 100d0e0:	f000 80e0 	beq.w	100d2a4 <ull_conn_rx+0x14a8>
	if ((conn->llcp_phy.ack != conn->llcp_phy.req) &&
 100d0e4:	f895 61a8 	ldrb.w	r6, [r5, #424]	; 0x1a8
 100d0e8:	f895 21a9 	ldrb.w	r2, [r5, #425]	; 0x1a9
 100d0ec:	42b2      	cmp	r2, r6
 100d0ee:	d019      	beq.n	100d124 <ull_conn_rx+0x1328>
	    (conn->llcp_phy.state == LLCP_PHY_STATE_RSP_WAIT)) {
 100d0f0:	f895 21aa 	ldrb.w	r2, [r5, #426]	; 0x1aa
	if ((conn->llcp_phy.ack != conn->llcp_phy.req) &&
 100d0f4:	f002 0203 	and.w	r2, r2, #3
 100d0f8:	2a02      	cmp	r2, #2
 100d0fa:	d113      	bne.n	100d124 <ull_conn_rx+0x1328>
		conn->procedure_expire = 0U;
 100d0fc:	f04f 0c00 	mov.w	ip, #0
		conn->llcp_phy.pause_tx = 0U;
 100d100:	f895 21ab 	ldrb.w	r2, [r5, #427]	; 0x1ab
		conn->llcp_phy.ack = conn->llcp_phy.req;
 100d104:	f885 61a9 	strb.w	r6, [r5, #425]	; 0x1a9
		conn->llcp_phy.pause_tx = 0U;
 100d108:	f36f 0200 	bfc	r2, #0, #1
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
 100d10c:	f895 60ec 	ldrb.w	r6, [r5, #236]	; 0xec
		conn->llcp_phy.pause_tx = 0U;
 100d110:	f885 21ab 	strb.w	r2, [r5, #427]	; 0x1ab
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
 100d114:	f3c2 0280 	ubfx	r2, r2, #2, #1
 100d118:	f362 0641 	bfi	r6, r2, #1, #1
 100d11c:	f885 60ec 	strb.w	r6, [r5, #236]	; 0xec
		conn->procedure_expire = 0U;
 100d120:	f8a5 c0cc 	strh.w	ip, [r5, #204]	; 0xcc
	*rx = NULL;
 100d124:	2600      	movs	r6, #0
	conn->llcp.phy_upd_ind.initiate = 0U;
 100d126:	f895 20ec 	ldrb.w	r2, [r5, #236]	; 0xec
 100d12a:	009b      	lsls	r3, r3, #2
 100d12c:	f003 031c 	and.w	r3, r3, #28
	conn->llcp.phy_upd_ind.instant = instant;
 100d130:	f8a5 10ee 	strh.w	r1, [r5, #238]	; 0xee
	conn->llcp.phy_upd_ind.initiate = 0U;
 100d134:	ea43 1340 	orr.w	r3, r3, r0, lsl #5
	link->mem = conn->llcp_rx;
 100d138:	f8d5 1100 	ldr.w	r1, [r5, #256]	; 0x100
	conn->llcp.phy_upd_ind.initiate = 0U;
 100d13c:	f002 0202 	and.w	r2, r2, #2
 100d140:	4313      	orrs	r3, r2
 100d142:	f885 30ec 	strb.w	r3, [r5, #236]	; 0xec
	link->mem = conn->llcp_rx;
 100d146:	6079      	str	r1, [r7, #4]
	(*rx)->hdr.link = link;
 100d148:	6823      	ldr	r3, [r4, #0]
 100d14a:	601f      	str	r7, [r3, #0]
	conn->llcp_rx = *rx;
 100d14c:	6823      	ldr	r3, [r4, #0]
 100d14e:	f8c5 3100 	str.w	r3, [r5, #256]	; 0x100
	*rx = NULL;
 100d152:	6026      	str	r6, [r4, #0]
	struct node_rx_pdu *rx_dle = ll_pdu_rx_alloc();
 100d154:	f7fd f840 	bl	100a1d8 <ll_pdu_rx_alloc>
	LL_ASSERT(rx_dle);
 100d158:	4604      	mov	r4, r0
 100d15a:	2800      	cmp	r0, #0
 100d15c:	f000 813f 	beq.w	100d3de <ull_conn_rx+0x15e2>
	conn->llcp_type = LLCP_PHY_UPD;
 100d160:	2106      	movs	r1, #6
	rx_dle->hdr.link->mem = conn->llcp_rx;
 100d162:	6823      	ldr	r3, [r4, #0]
 100d164:	f8d5 2100 	ldr.w	r2, [r5, #256]	; 0x100
 100d168:	605a      	str	r2, [r3, #4]
	conn->llcp_ack -= 2U;
 100d16a:	f895 20e9 	ldrb.w	r2, [r5, #233]	; 0xe9
	if (conn->llcp.phy_upd_ind.tx) {
 100d16e:	f895 30ec 	ldrb.w	r3, [r5, #236]	; 0xec
	conn->llcp_ack -= 2U;
 100d172:	3a02      	subs	r2, #2
	if (conn->llcp.phy_upd_ind.tx) {
 100d174:	f013 0f1c 	tst.w	r3, #28
	conn->llcp_rx = rx_dle;
 100d178:	f8c5 4100 	str.w	r4, [r5, #256]	; 0x100
	conn->llcp_ack -= 2U;
 100d17c:	f885 20e9 	strb.w	r2, [r5, #233]	; 0xe9
	conn->llcp_type = LLCP_PHY_UPD;
 100d180:	f885 10ea 	strb.w	r1, [r5, #234]	; 0xea
	if (conn->llcp.phy_upd_ind.tx) {
 100d184:	f43e aef6 	beq.w	100bf74 <ull_conn_rx+0x178>
		conn->lll.phy_tx_time = conn->llcp.phy_upd_ind.tx;
 100d188:	f895 2064 	ldrb.w	r2, [r5, #100]	; 0x64
 100d18c:	f3c3 0382 	ubfx	r3, r3, #2, #3
 100d190:	f363 1206 	bfi	r2, r3, #4, #3
	int nack = 0;
 100d194:	2000      	movs	r0, #0
		conn->lll.phy_tx_time = conn->llcp.phy_upd_ind.tx;
 100d196:	f885 2064 	strb.w	r2, [r5, #100]	; 0x64
		if (err) {
 100d19a:	f7fe be98 	b.w	100bece <ull_conn_rx+0xd2>
				conn->llcp_phy.state =
 100d19e:	f895 31aa 	ldrb.w	r3, [r5, #426]	; 0x1aa
				if (conn->llcp_phy.ack ==
 100d1a2:	428a      	cmp	r2, r1
				conn->llcp_phy.state =
 100d1a4:	f043 0303 	orr.w	r3, r3, #3
 100d1a8:	f885 31aa 	strb.w	r3, [r5, #426]	; 0x1aa
				if (conn->llcp_phy.ack ==
 100d1ac:	d114      	bne.n	100d1d8 <ull_conn_rx+0x13dc>
						conn->phy_pref_rx;
 100d1ae:	f895 01ac 	ldrb.w	r0, [r5, #428]	; 0x1ac
					conn->llcp_phy.tx =
 100d1b2:	f8b5 11aa 	ldrh.w	r1, [r5, #426]	; 0x1aa
 100d1b6:	f000 0307 	and.w	r3, r0, #7
 100d1ba:	009b      	lsls	r3, r3, #2
 100d1bc:	f3c0 1002 	ubfx	r0, r0, #4, #3
 100d1c0:	f421 619f 	bic.w	r1, r1, #1272	; 0x4f8
 100d1c4:	ea43 1340 	orr.w	r3, r3, r0, lsl #5
 100d1c8:	f021 0104 	bic.w	r1, r1, #4
					conn->llcp_phy.ack--;
 100d1cc:	3a01      	subs	r2, #1
					conn->llcp_phy.tx =
 100d1ce:	430b      	orrs	r3, r1
					conn->llcp_phy.ack--;
 100d1d0:	f885 21a9 	strb.w	r2, [r5, #425]	; 0x1a9
					conn->llcp_phy.tx =
 100d1d4:	f8a5 31aa 	strh.w	r3, [r5, #426]	; 0x1aa
				conn->llcp_phy.rx &= p->tx_phys;
 100d1d8:	f895 21aa 	ldrb.w	r2, [r5, #426]	; 0x1aa
				conn->llcp_phy.tx &= p->rx_phys;
 100d1dc:	f896 3025 	ldrb.w	r3, [r6, #37]	; 0x25
				conn->llcp_phy.rx &= p->tx_phys;
 100d1e0:	f896 1024 	ldrb.w	r1, [r6, #36]	; 0x24
				conn->llcp_phy.tx &= p->rx_phys;
 100d1e4:	f3c2 0082 	ubfx	r0, r2, #2, #3
 100d1e8:	4003      	ands	r3, r0
				conn->llcp_phy.rx &= p->tx_phys;
 100d1ea:	ea01 1152 	and.w	r1, r1, r2, lsr #5
				conn->llcp_phy.tx &= p->rx_phys;
 100d1ee:	009b      	lsls	r3, r3, #2
 100d1f0:	ea43 1341 	orr.w	r3, r3, r1, lsl #5
 100d1f4:	f002 0203 	and.w	r2, r2, #3
 100d1f8:	4313      	orrs	r3, r2
				if (!conn->llcp_phy.tx || !conn->llcp_phy.rx) {
 100d1fa:	f013 0f1c 	tst.w	r3, #28
				conn->llcp_phy.tx &= p->rx_phys;
 100d1fe:	f885 31aa 	strb.w	r3, [r5, #426]	; 0x1aa
				if (!conn->llcp_phy.tx || !conn->llcp_phy.rx) {
 100d202:	d002      	beq.n	100d20a <ull_conn_rx+0x140e>
 100d204:	f013 0fe0 	tst.w	r3, #224	; 0xe0
 100d208:	d105      	bne.n	100d216 <ull_conn_rx+0x141a>
					conn->llcp_phy.tx = 0;
 100d20a:	f895 31aa 	ldrb.w	r3, [r5, #426]	; 0x1aa
 100d20e:	f003 0303 	and.w	r3, r3, #3
 100d212:	f885 31aa 	strb.w	r3, [r5, #426]	; 0x1aa
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d216:	2203      	movs	r2, #3
				conn->llcp_phy.pause_tx = 1U;
 100d218:	f895 31ab 	ldrb.w	r3, [r5, #427]	; 0x1ab
	int nack = 0;
 100d21c:	2000      	movs	r0, #0
				conn->llcp_phy.pause_tx = 1U;
 100d21e:	f043 0301 	orr.w	r3, r3, #1
 100d222:	f885 31ab 	strb.w	r3, [r5, #427]	; 0x1ab
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d226:	6823      	ldr	r3, [r4, #0]
 100d228:	711a      	strb	r2, [r3, #4]
 100d22a:	f7fe be50 	b.w	100bece <ull_conn_rx+0xd2>
				nack = reject_ext_ind_send(conn, *rx,
 100d22e:	4628      	mov	r0, r5
 100d230:	2323      	movs	r3, #35	; 0x23
 100d232:	1d31      	adds	r1, r6, #4
 100d234:	f7fe bfd2 	b.w	100c1dc <ull_conn_rx+0x3e0>
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d238:	2203      	movs	r2, #3
		return BT_HCI_ERR_INSTANT_PASSED;
 100d23a:	2328      	movs	r3, #40	; 0x28
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d23c:	7132      	strb	r2, [r6, #4]
			conn->llcp_terminate.reason_peer = err;
 100d23e:	f885 312b 	strb.w	r3, [r5, #299]	; 0x12b
 100d242:	f7fe be97 	b.w	100bf74 <ull_conn_rx+0x178>
				nack = reject_ext_ind_send(conn, *rx,
 100d246:	4628      	mov	r0, r5
 100d248:	231e      	movs	r3, #30
 100d24a:	2210      	movs	r2, #16
 100d24c:	1d31      	adds	r1, r6, #4
 100d24e:	f7fe bfc6 	b.w	100c1de <ull_conn_rx+0x3e2>
			conn->procedure_expire = 0U;
 100d252:	2700      	movs	r7, #0
			conn->llcp_length.ack = conn->llcp_length.req;
 100d254:	9a00      	ldr	r2, [sp, #0]
			conn->procedure_expire = 0U;
 100d256:	f8a5 70cc 	strh.w	r7, [r5, #204]	; 0xcc
			conn->llcp_length.ack = conn->llcp_length.req;
 100d25a:	f885 2199 	strb.w	r2, [r5, #409]	; 0x199
			if (eff_tx_octets == conn->lll.max_tx_octets &&
 100d25e:	9a02      	ldr	r2, [sp, #8]
 100d260:	4290      	cmp	r0, r2
 100d262:	f000 8159 	beq.w	100d518 <ull_conn_rx+0x171c>
			conn->lll.max_rx_time = eff_rx_time;
 100d266:	f8a5 9062 	strh.w	r9, [r5, #98]	; 0x62
			if (tx) {
 100d26a:	2900      	cmp	r1, #0
 100d26c:	f000 814f 	beq.w	100d50e <ull_conn_rx+0x1712>
				conn->llcp_length.state =
 100d270:	2703      	movs	r7, #3
 100d272:	f895 419a 	ldrb.w	r4, [r5, #410]	; 0x19a
					(conn->llcp_length.req - 1);
 100d276:	9a00      	ldr	r2, [sp, #0]
				conn->llcp_length.state =
 100d278:	f367 0402 	bfi	r4, r7, #0, #3
					(conn->llcp_length.req - 1);
 100d27c:	3a01      	subs	r2, #1
				conn->llcp_length.ack =
 100d27e:	f885 2199 	strb.w	r2, [r5, #409]	; 0x199
				conn->llcp_length.rx_octets = eff_rx_octets;
 100d282:	f8a5 c19c 	strh.w	ip, [r5, #412]	; 0x19c
				conn->llcp_length.tx_octets = eff_tx_octets;
 100d286:	f8a5 019e 	strh.w	r0, [r5, #414]	; 0x19e
				conn->llcp_length.rx_time = eff_rx_time;
 100d28a:	f8a5 91a0 	strh.w	r9, [r5, #416]	; 0x1a0
				conn->llcp_length.tx_time = eff_tx_time;
 100d28e:	f8a5 31a2 	strh.w	r3, [r5, #418]	; 0x1a2
				conn->llcp_length.state =
 100d292:	f885 419a 	strb.w	r4, [r5, #410]	; 0x19a
			lr->max_rx_octets = sys_cpu_to_le16(eff_rx_octets);
 100d296:	f8a6 c024 	strh.w	ip, [r6, #36]	; 0x24
			lr->max_tx_octets = sys_cpu_to_le16(eff_tx_octets);
 100d29a:	8530      	strh	r0, [r6, #40]	; 0x28
			lr->max_rx_time = sys_cpu_to_le16(eff_rx_time);
 100d29c:	f8a6 9026 	strh.w	r9, [r6, #38]	; 0x26
			lr->max_tx_time = sys_cpu_to_le16(eff_tx_time);
 100d2a0:	8573      	strh	r3, [r6, #42]	; 0x2a
 100d2a2:	e5c0      	b.n	100ce26 <ull_conn_rx+0x102a>
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d2a4:	2203      	movs	r2, #3
		return BT_HCI_ERR_DIFF_TRANS_COLLISION;
 100d2a6:	232a      	movs	r3, #42	; 0x2a
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d2a8:	7132      	strb	r2, [r6, #4]
		if (err) {
 100d2aa:	e7c8      	b.n	100d23e <ull_conn_rx+0x1442>
 100d2ac:	21005288 	.word	0x21005288
		} else if (conn->llcp_phy.req !=
 100d2b0:	f895 01a8 	ldrb.w	r0, [r5, #424]	; 0x1a8
 100d2b4:	f895 31a9 	ldrb.w	r3, [r5, #425]	; 0x1a9
 100d2b8:	4283      	cmp	r3, r0
 100d2ba:	f000 8088 	beq.w	100d3ce <ull_conn_rx+0x15d2>
			lll->phy_tx_time = lll->phy_tx;
 100d2be:	f895 2064 	ldrb.w	r2, [r5, #100]	; 0x64
			conn->llcp_phy.pause_tx = 0U;
 100d2c2:	f895 31ab 	ldrb.w	r3, [r5, #427]	; 0x1ab
			lll->phy_tx_time = lll->phy_tx;
 100d2c6:	4611      	mov	r1, r2
			conn->llcp_phy.pause_tx = 0U;
 100d2c8:	f023 0309 	bic.w	r3, r3, #9
			lll->phy_tx_time = lll->phy_tx;
 100d2cc:	f362 1106 	bfi	r1, r2, #4, #3
			conn->llcp_phy.pause_tx = 0U;
 100d2d0:	f043 0308 	orr.w	r3, r3, #8
			lll->phy_tx_time = lll->phy_tx;
 100d2d4:	f885 1064 	strb.w	r1, [r5, #100]	; 0x64
			if (conn->llcp_phy.cmd) {
 100d2d8:	0759      	lsls	r1, r3, #29
			conn->llcp_phy.ack = conn->llcp_phy.req;
 100d2da:	f885 01a9 	strb.w	r0, [r5, #425]	; 0x1a9
			lll->phy_tx_time = lll->phy_tx;
 100d2de:	f3c2 0202 	ubfx	r2, r2, #0, #3
			conn->llcp_phy.pause_tx = 0U;
 100d2e2:	f885 31ab 	strb.w	r3, [r5, #427]	; 0x1ab
			if (conn->llcp_phy.cmd) {
 100d2e6:	d56d      	bpl.n	100d3c4 <ull_conn_rx+0x15c8>
				p->status = 0U;
 100d2e8:	2300      	movs	r3, #0
				(*rx)->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
 100d2ea:	200e      	movs	r0, #14
 100d2ec:	6821      	ldr	r1, [r4, #0]
 100d2ee:	7108      	strb	r0, [r1, #4]
				p->tx = lll->phy_tx;
 100d2f0:	f886 2021 	strb.w	r2, [r6, #33]	; 0x21
				p->status = 0U;
 100d2f4:	f886 3020 	strb.w	r3, [r6, #32]
				p->rx = lll->phy_rx;
 100d2f8:	f895 3065 	ldrb.w	r3, [r5, #101]	; 0x65
 100d2fc:	f3c3 0302 	ubfx	r3, r3, #0, #3
 100d300:	f886 3022 	strb.w	r3, [r6, #34]	; 0x22
 100d304:	f7fe beb7 	b.w	100c076 <ull_conn_rx+0x27a>
		conn->tx_data_last = tx;
 100d308:	f8c5 41c0 	str.w	r4, [r5, #448]	; 0x1c0
		if (nack) {
 100d30c:	f7ff bae6 	b.w	100c8dc <ull_conn_rx+0xae0>
	    (!feature_coded_phy && !feature_phy_2m)) {
 100d310:	05db      	lsls	r3, r3, #23
 100d312:	f57f ae01 	bpl.w	100cf18 <ull_conn_rx+0x111c>
		rx_time = MAX(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_2M),
 100d316:	f44f 6985 	mov.w	r9, #1064	; 0x428
		tx_time = MAX(PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M),
 100d31a:	f8b5 30d8 	ldrh.w	r3, [r5, #216]	; 0xd8
 100d31e:	454b      	cmp	r3, r9
 100d320:	bf28      	it	cs
 100d322:	464b      	movcs	r3, r9
 100d324:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
 100d328:	bf38      	it	cc
 100d32a:	f44f 73a4 	movcc.w	r3, #328	; 0x148
 100d32e:	e51a      	b.n	100cd66 <ull_conn_rx+0xf6a>
		conn_upd_curr = conn;
 100d330:	601d      	str	r5, [r3, #0]
 100d332:	f7ff b9a7 	b.w	100c684 <ull_conn_rx+0x888>
			eff_rx_time = MAX(eff_rx_time,
 100d336:	f44f 6929 	mov.w	r9, #2704	; 0xa90
 100d33a:	e54b      	b.n	100cdd4 <ull_conn_rx+0xfd8>
				conn->llcp_length.state =
 100d33c:	2604      	movs	r6, #4
 100d33e:	f895 219a 	ldrb.w	r2, [r5, #410]	; 0x19a
				conn->lll.max_tx_octets = eff_tx_octets;
 100d342:	f8a5 005c 	strh.w	r0, [r5, #92]	; 0x5c
				conn->llcp_length.state =
 100d346:	f366 0202 	bfi	r2, r6, #0, #3
				conn->lll.max_tx_time = eff_tx_time;
 100d34a:	f8a5 3060 	strh.w	r3, [r5, #96]	; 0x60
				conn->llcp_length.state =
 100d34e:	f885 219a 	strb.w	r2, [r5, #410]	; 0x19a
 100d352:	e55e      	b.n	100ce12 <ull_conn_rx+0x1016>
	struct node_tx *tx = NULL;
 100d354:	2100      	movs	r1, #0
 100d356:	f7fe beb6 	b.w	100c0c6 <ull_conn_rx+0x2ca>
				      0x03) == 0x02) &&
 100d35a:	f895 20ea 	ldrb.w	r2, [r5, #234]	; 0xea
 100d35e:	2a03      	cmp	r2, #3
 100d360:	f47f acae 	bne.w	100ccc0 <ull_conn_rx+0xec4>
 100d364:	e4a5      	b.n	100ccb2 <ull_conn_rx+0xeb6>
			eff_tx_time = MAX(eff_tx_time,
 100d366:	f44f 6329 	mov.w	r3, #2704	; 0xa90
 100d36a:	e516      	b.n	100cd9a <ull_conn_rx+0xf9e>
			tx->next = conn->tx_head->next;
 100d36c:	681a      	ldr	r2, [r3, #0]
 100d36e:	6022      	str	r2, [r4, #0]
			conn->tx_head->next = tx;
 100d370:	601c      	str	r4, [r3, #0]
				conn->tx_ctrl_last = tx;
 100d372:	e9c5 446d 	strd	r4, r4, [r5, #436]	; 0x1b4
 100d376:	f7ff baad 	b.w	100c8d4 <ull_conn_rx+0xad8>
		LL_ASSERT(conn_upd_curr == conn);
 100d37a:	4fb0      	ldr	r7, [pc, #704]	; (100d63c <ull_conn_rx+0x1840>)
 100d37c:	6839      	ldr	r1, [r7, #0]
 100d37e:	428d      	cmp	r5, r1
 100d380:	d008      	beq.n	100d394 <ull_conn_rx+0x1598>
 100d382:	f241 019b 	movw	r1, #4251	; 0x109b
 100d386:	48ae      	ldr	r0, [pc, #696]	; (100d640 <ull_conn_rx+0x1844>)
 100d388:	f7f6 f97a 	bl	1003680 <bt_ctlr_assert_handle>
 100d38c:	f895 3170 	ldrb.w	r3, [r5, #368]	; 0x170
 100d390:	f895 2172 	ldrb.w	r2, [r5, #370]	; 0x172
		conn_upd_curr = NULL;
 100d394:	2100      	movs	r1, #0
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
 100d396:	f885 3171 	strb.w	r3, [r5, #369]	; 0x171
		conn_upd_curr = NULL;
 100d39a:	6039      	str	r1, [r7, #0]
		conn->procedure_expire = 0U;
 100d39c:	f8a5 10cc 	strh.w	r1, [r5, #204]	; 0xcc
 100d3a0:	f7ff bb7d 	b.w	100ca9e <ull_conn_rx+0xca2>
			tx->next = conn->tx_head->next;
 100d3a4:	6811      	ldr	r1, [r2, #0]
 100d3a6:	6019      	str	r1, [r3, #0]
			conn->tx_head->next = tx;
 100d3a8:	6013      	str	r3, [r2, #0]
				conn->tx_ctrl_last = tx;
 100d3aa:	e9c5 336d 	strd	r3, r3, [r5, #436]	; 0x1b4
 100d3ae:	f7fe bf7d 	b.w	100c2ac <ull_conn_rx+0x4b0>
	else if (rej_ext_ind->error_code != BT_HCI_ERR_LL_PROC_COLLISION) {
 100d3b2:	2a23      	cmp	r2, #35	; 0x23
 100d3b4:	f43f ab6c 	beq.w	100ca90 <ull_conn_rx+0xc94>
			conn->slave.ticks_to_offset =
 100d3b8:	f8d5 2194 	ldr.w	r2, [r5, #404]	; 0x194
 100d3bc:	f8c5 20e4 	str.w	r2, [r5, #228]	; 0xe4
 100d3c0:	f7ff bb66 	b.w	100ca90 <ull_conn_rx+0xc94>
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d3c4:	2203      	movs	r2, #3
 100d3c6:	6823      	ldr	r3, [r4, #0]
 100d3c8:	711a      	strb	r2, [r3, #4]
 100d3ca:	f7fe be54 	b.w	100c076 <ull_conn_rx+0x27a>
			switch (llctrl->unknown_rsp.type) {
 100d3ce:	f896 3024 	ldrb.w	r3, [r6, #36]	; 0x24
 100d3d2:	2b12      	cmp	r3, #18
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d3d4:	bf04      	itt	eq
 100d3d6:	2303      	moveq	r3, #3
 100d3d8:	7133      	strbeq	r3, [r6, #4]
				break;
 100d3da:	f7fe be4c 	b.w	100c076 <ull_conn_rx+0x27a>
	LL_ASSERT(rx_dle);
 100d3de:	f241 3113 	movw	r1, #4883	; 0x1313
 100d3e2:	4897      	ldr	r0, [pc, #604]	; (100d640 <ull_conn_rx+0x1844>)
 100d3e4:	f7f6 f94c 	bl	1003680 <bt_ctlr_assert_handle>
 100d3e8:	e6ba      	b.n	100d160 <ull_conn_rx+0x1364>
				u16_t interval_min =
 100d3ea:	8cb2      	ldrh	r2, [r6, #36]	; 0x24
 100d3ec:	f8ad 2004 	strh.w	r2, [sp, #4]
 100d3f0:	b292      	uxth	r2, r2
				if ((interval_min < 6) ||
 100d3f2:	2a05      	cmp	r2, #5
 100d3f4:	f67f ae43 	bls.w	100d07e <ull_conn_rx+0x1282>
				u16_t interval_max =
 100d3f8:	f8b6 8026 	ldrh.w	r8, [r6, #38]	; 0x26
 100d3fc:	fa1f f188 	uxth.w	r1, r8
				if ((interval_min < 6) ||
 100d400:	f5b1 6f48 	cmp.w	r1, #3200	; 0xc80
 100d404:	f63f ae3b 	bhi.w	100d07e <ull_conn_rx+0x1282>
				    (interval_max > 3200) ||
 100d408:	428a      	cmp	r2, r1
 100d40a:	f63f ae38 	bhi.w	100d07e <ull_conn_rx+0x1282>
				u16_t latency =
 100d40e:	f8b6 e028 	ldrh.w	lr, [r6, #40]	; 0x28
 100d412:	fa1f f08e 	uxth.w	r0, lr
				    (interval_min > interval_max) ||
 100d416:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
 100d41a:	f4bf ae30 	bcs.w	100d07e <ull_conn_rx+0x1282>
				    (latency > 499) ||
 100d41e:	f640 4a76 	movw	sl, #3190	; 0xc76
				u16_t timeout =
 100d422:	f8b6 b02a 	ldrh.w	fp, [r6, #42]	; 0x2a
 100d426:	fa1f f28b 	uxth.w	r2, fp
				    (latency > 499) ||
 100d42a:	f1a2 0c0a 	sub.w	ip, r2, #10
 100d42e:	fa1f fc8c 	uxth.w	ip, ip
 100d432:	45d4      	cmp	ip, sl
 100d434:	f63f ae23 	bhi.w	100d07e <ull_conn_rx+0x1282>
				     ((latency + 1) * interval_max)) ||
 100d438:	fb00 1c01 	mla	ip, r0, r1, r1
				    (timeout > 3200) ||
 100d43c:	ebbc 0f82 	cmp.w	ip, r2, lsl #2
 100d440:	f4bf ae1d 	bcs.w	100d07e <ull_conn_rx+0x1282>
				     ((latency + 1) * interval_max)) ||
 100d444:	f896 a02c 	ldrb.w	sl, [r6, #44]	; 0x2c
 100d448:	4551      	cmp	r1, sl
					cpr->preferred_periodicity;
 100d44a:	46d4      	mov	ip, sl
				     ((latency + 1) * interval_max)) ||
 100d44c:	f4ff ae17 	bcc.w	100d07e <ull_conn_rx+0x1282>
				conn->llcp_conn_param.interval_min =
 100d450:	f8bd a004 	ldrh.w	sl, [sp, #4]
				conn->llcp_conn_param.latency =	latency;
 100d454:	f8a5 e178 	strh.w	lr, [r5, #376]	; 0x178
				conn->llcp_conn_param.interval_min =
 100d458:	f8a5 a174 	strh.w	sl, [r5, #372]	; 0x174
				conn->llcp_conn_param.interval_max =
 100d45c:	f8a5 8176 	strh.w	r8, [r5, #374]	; 0x176
				conn->llcp_conn_param.timeout =	timeout;
 100d460:	f8a5 b17a 	strh.w	fp, [r5, #378]	; 0x17a
				conn->llcp_conn_param.preferred_periodicity =
 100d464:	f885 c17c 	strb.w	ip, [r5, #380]	; 0x17c
					sys_le16_to_cpu(cpr->reference_conn_event_count);
 100d468:	f896 802e 	ldrb.w	r8, [r6, #46]	; 0x2e
 100d46c:	f896 c02d 	ldrb.w	ip, [r6, #45]	; 0x2d
				     lll->interval) ||
 100d470:	f8b5 e02e 	ldrh.w	lr, [r5, #46]	; 0x2e
					sys_le16_to_cpu(cpr->reference_conn_event_count);
 100d474:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
				conn->llcp_conn_param.reference_conn_event_count =
 100d478:	f8a5 c17e 	strh.w	ip, [r5, #382]	; 0x17e
					sys_le16_to_cpu(cpr->offset0);
 100d47c:	f896 8030 	ldrb.w	r8, [r6, #48]	; 0x30
 100d480:	f896 c02f 	ldrb.w	ip, [r6, #47]	; 0x2f
				if ((conn->llcp_conn_param.interval_max !=
 100d484:	4571      	cmp	r1, lr
					sys_le16_to_cpu(cpr->offset0);
 100d486:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
				conn->llcp_conn_param.offset0 =
 100d48a:	f8a5 c180 	strh.w	ip, [r5, #384]	; 0x180
					sys_le16_to_cpu(cpr->offset1);
 100d48e:	f896 8032 	ldrb.w	r8, [r6, #50]	; 0x32
 100d492:	f896 c031 	ldrb.w	ip, [r6, #49]	; 0x31
 100d496:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
				conn->llcp_conn_param.offset1 =
 100d49a:	f8a5 c182 	strh.w	ip, [r5, #386]	; 0x182
					sys_le16_to_cpu(cpr->offset2);
 100d49e:	f896 8034 	ldrb.w	r8, [r6, #52]	; 0x34
 100d4a2:	f896 c033 	ldrb.w	ip, [r6, #51]	; 0x33
 100d4a6:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
				conn->llcp_conn_param.offset2 =
 100d4aa:	f8a5 c184 	strh.w	ip, [r5, #388]	; 0x184
					sys_le16_to_cpu(cpr->offset3);
 100d4ae:	f896 8036 	ldrb.w	r8, [r6, #54]	; 0x36
 100d4b2:	f896 c035 	ldrb.w	ip, [r6, #53]	; 0x35
 100d4b6:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
				conn->llcp_conn_param.offset3 =
 100d4ba:	f8a5 c186 	strh.w	ip, [r5, #390]	; 0x186
					sys_le16_to_cpu(cpr->offset4);
 100d4be:	f896 c037 	ldrb.w	ip, [r6, #55]	; 0x37
 100d4c2:	f896 8038 	ldrb.w	r8, [r6, #56]	; 0x38
 100d4c6:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
				conn->llcp_conn_param.offset4 =
 100d4ca:	f8a5 c188 	strh.w	ip, [r5, #392]	; 0x188
					sys_le16_to_cpu(cpr->offset5);
 100d4ce:	f896 c039 	ldrb.w	ip, [r6, #57]	; 0x39
 100d4d2:	f896 603a 	ldrb.w	r6, [r6, #58]	; 0x3a
 100d4d6:	ea4c 2606 	orr.w	r6, ip, r6, lsl #8
				conn->llcp_conn_param.offset5 =
 100d4da:	f8a5 618a 	strh.w	r6, [r5, #394]	; 0x18a
				if ((conn->llcp_conn_param.interval_max !=
 100d4de:	f000 808c 	beq.w	100d5fa <ull_conn_rx+0x17fe>
					if (conn->llcp_enc.pause_tx) {
 100d4e2:	079a      	lsls	r2, r3, #30
 100d4e4:	f140 8081 	bpl.w	100d5ea <ull_conn_rx+0x17ee>
						conn->llcp_conn_param.state =
 100d4e8:	2002      	movs	r0, #2
						(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d4ea:	2103      	movs	r1, #3
						conn->llcp_conn_param.state =
 100d4ec:	f895 3172 	ldrb.w	r3, [r5, #370]	; 0x172
						(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d4f0:	6822      	ldr	r2, [r4, #0]
						conn->llcp_conn_param.state =
 100d4f2:	f360 0302 	bfi	r3, r0, #0, #3
 100d4f6:	f885 3172 	strb.w	r3, [r5, #370]	; 0x172
						(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d4fa:	7111      	strb	r1, [r2, #4]
				conn->llcp_conn_param.ack--;
 100d4fc:	9b00      	ldr	r3, [sp, #0]
 100d4fe:	3b01      	subs	r3, #1
 100d500:	f885 3171 	strb.w	r3, [r5, #369]	; 0x171
				if (!conn_upd_curr) {
 100d504:	f1b9 0f00 	cmp.w	r9, #0
 100d508:	f47e ad34 	bne.w	100bf74 <ull_conn_rx+0x178>
 100d50c:	e5b3      	b.n	100d076 <ull_conn_rx+0x127a>
				conn->lll.max_tx_octets = eff_tx_octets;
 100d50e:	f8a5 005c 	strh.w	r0, [r5, #92]	; 0x5c
				conn->lll.max_tx_time = eff_tx_time;
 100d512:	f8a5 3060 	strh.w	r3, [r5, #96]	; 0x60
 100d516:	e6be      	b.n	100d296 <ull_conn_rx+0x149a>
			if (eff_tx_octets == conn->lll.max_tx_octets &&
 100d518:	4543      	cmp	r3, r8
 100d51a:	f47f aea4 	bne.w	100d266 <ull_conn_rx+0x146a>
			    eff_rx_time == conn->lll.max_rx_time &&
 100d51e:	45f1      	cmp	r9, lr
 100d520:	f47f aea1 	bne.w	100d266 <ull_conn_rx+0x146a>
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d524:	2603      	movs	r6, #3
 100d526:	6822      	ldr	r2, [r4, #0]
 100d528:	7116      	strb	r6, [r2, #4]
				goto send_length_resp;
 100d52a:	e47c      	b.n	100ce26 <ull_conn_rx+0x102a>
		LL_ASSERT(conn->llcp_cu.req == conn->llcp_cu.ack);
 100d52c:	f895 2104 	ldrb.w	r2, [r5, #260]	; 0x104
 100d530:	f895 3105 	ldrb.w	r3, [r5, #261]	; 0x105
 100d534:	429a      	cmp	r2, r3
 100d536:	d006      	beq.n	100d546 <ull_conn_rx+0x174a>
 100d538:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100d53c:	4840      	ldr	r0, [pc, #256]	; (100d640 <ull_conn_rx+0x1844>)
 100d53e:	f7f6 f89f 	bl	1003680 <bt_ctlr_assert_handle>
 100d542:	f895 3105 	ldrb.w	r3, [r5, #261]	; 0x105
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
 100d546:	2105      	movs	r1, #5
		conn->llcp_cu.win_size = 1U;
 100d548:	2401      	movs	r4, #1
		conn->llcp_cu.win_offset_us = 0U;
 100d54a:	2000      	movs	r0, #0
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
 100d54c:	f895 2172 	ldrb.w	r2, [r5, #370]	; 0x172
		conn->llcp_cu.ack--;
 100d550:	1e5f      	subs	r7, r3, #1
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
 100d552:	f361 0202 	bfi	r2, r1, #0, #3
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
 100d556:	f3c2 03c0 	ubfx	r3, r2, #3, #1
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
 100d55a:	f895 1106 	ldrb.w	r1, [r5, #262]	; 0x106
 100d55e:	009b      	lsls	r3, r3, #2
 100d560:	f021 0107 	bic.w	r1, r1, #7
 100d564:	4323      	orrs	r3, r4
 100d566:	430b      	orrs	r3, r1
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
 100d568:	f885 2172 	strb.w	r2, [r5, #370]	; 0x172
		conn->llcp_cu.interval = conn->llcp_conn_param.interval_max;
 100d56c:	f8b5 1176 	ldrh.w	r1, [r5, #374]	; 0x176
		conn->llcp_cu.latency = conn->llcp_conn_param.latency;
 100d570:	f8b5 2178 	ldrh.w	r2, [r5, #376]	; 0x178
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
 100d574:	f885 3106 	strb.w	r3, [r5, #262]	; 0x106
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
 100d578:	f8b5 317a 	ldrh.w	r3, [r5, #378]	; 0x17a
		conn->llcp_cu.ack--;
 100d57c:	f885 7105 	strb.w	r7, [r5, #261]	; 0x105
		conn->llcp_cu.win_size = 1U;
 100d580:	f885 4114 	strb.w	r4, [r5, #276]	; 0x114
		conn->llcp_cu.win_offset_us = 0U;
 100d584:	f8c5 0110 	str.w	r0, [r5, #272]	; 0x110
		conn->llcp_cu.interval = conn->llcp_conn_param.interval_max;
 100d588:	f8a5 1108 	strh.w	r1, [r5, #264]	; 0x108
		conn->llcp_cu.latency = conn->llcp_conn_param.latency;
 100d58c:	f8a5 210a 	strh.w	r2, [r5, #266]	; 0x10a
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
 100d590:	f8a5 310c 	strh.w	r3, [r5, #268]	; 0x10c
	if (err) {
 100d594:	f7fe bd2c 	b.w	100bff0 <ull_conn_rx+0x1f4>
			     lll->interval) ||
 100d598:	8e2e      	ldrh	r6, [r5, #48]	; 0x30
 100d59a:	4286      	cmp	r6, r0
 100d59c:	f47f ad5d 	bne.w	100d05a <ull_conn_rx+0x125e>
			    (RADIO_CONN_EVENTS(conn->llcp_conn_param.timeout *
 100d5a0:	f240 40e2 	movw	r0, #1250	; 0x4e2
 100d5a4:	f242 7610 	movw	r6, #10000	; 0x2710
 100d5a8:	fb00 f202 	mul.w	r2, r0, r2
 100d5ac:	fb06 2303 	mla	r3, r6, r3, r2
 100d5b0:	3b01      	subs	r3, #1
 100d5b2:	fbb3 f3f2 	udiv	r3, r3, r2
			    (conn->llcp_conn_param.latency != lll->latency) ||
 100d5b6:	f8b5 20c6 	ldrh.w	r2, [r5, #198]	; 0xc6
 100d5ba:	b29b      	uxth	r3, r3
 100d5bc:	429a      	cmp	r2, r3
 100d5be:	f47f ad4c 	bne.w	100d05a <ull_conn_rx+0x125e>
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d5c2:	2203      	movs	r2, #3
				conn->llcp_conn_param.state =
 100d5c4:	f8b5 3172 	ldrh.w	r3, [r5, #370]	; 0x172
 100d5c8:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 100d5cc:	f043 0301 	orr.w	r3, r3, #1
 100d5d0:	f8a5 3172 	strh.w	r3, [r5, #370]	; 0x172
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d5d4:	6823      	ldr	r3, [r4, #0]
 100d5d6:	711a      	strb	r2, [r3, #4]
 100d5d8:	e546      	b.n	100d068 <ull_conn_rx+0x126c>
	     ((((conn->llcp_length.state == LLCP_LENGTH_STATE_REQ) ||
 100d5da:	f895 319a 	ldrb.w	r3, [r5, #410]	; 0x19a
	    ((conn->llcp_length.req != conn->llcp_length.ack) &&
 100d5de:	f013 0f06 	tst.w	r3, #6
 100d5e2:	f43f ab95 	beq.w	100cd10 <ull_conn_rx+0xf14>
 100d5e6:	f7fe bd67 	b.w	100c0b8 <ull_conn_rx+0x2bc>
						conn->llcp_conn_param.state =
 100d5ea:	2203      	movs	r2, #3
 100d5ec:	f895 3172 	ldrb.w	r3, [r5, #370]	; 0x172
 100d5f0:	f362 0302 	bfi	r3, r2, #0, #3
 100d5f4:	f885 3172 	strb.w	r3, [r5, #370]	; 0x172
 100d5f8:	e780      	b.n	100d4fc <ull_conn_rx+0x1700>
				     lll->interval) ||
 100d5fa:	8e29      	ldrh	r1, [r5, #48]	; 0x30
 100d5fc:	4281      	cmp	r1, r0
 100d5fe:	f47f af70 	bne.w	100d4e2 <ull_conn_rx+0x16e6>
				    (RADIO_CONN_EVENTS(conn->llcp_conn_param.timeout *
 100d602:	f240 41e2 	movw	r1, #1250	; 0x4e2
 100d606:	f242 7010 	movw	r0, #10000	; 0x2710
 100d60a:	fb01 f10e 	mul.w	r1, r1, lr
 100d60e:	fb00 1202 	mla	r2, r0, r2, r1
 100d612:	3a01      	subs	r2, #1
 100d614:	fbb2 f2f1 	udiv	r2, r2, r1
				     lll->latency) ||
 100d618:	f8b5 10c6 	ldrh.w	r1, [r5, #198]	; 0xc6
 100d61c:	b292      	uxth	r2, r2
 100d61e:	4291      	cmp	r1, r2
 100d620:	f47f af5f 	bne.w	100d4e2 <ull_conn_rx+0x16e6>
					(*rx)->hdr.type =
 100d624:	2203      	movs	r2, #3
					conn->llcp_conn_param.state =
 100d626:	f8b5 3172 	ldrh.w	r3, [r5, #370]	; 0x172
 100d62a:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 100d62e:	f043 0301 	orr.w	r3, r3, #1
 100d632:	f8a5 3172 	strh.w	r3, [r5, #370]	; 0x172
					(*rx)->hdr.type =
 100d636:	6823      	ldr	r3, [r4, #0]
 100d638:	711a      	strb	r2, [r3, #4]
 100d63a:	e75f      	b.n	100d4fc <ull_conn_rx+0x1700>
 100d63c:	21004850 	.word	0x21004850
 100d640:	01018934 	.word	0x01018934

0100d644 <ull_conn_tx_demux>:
{
 100d644:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 100d648:	4c3d      	ldr	r4, [pc, #244]	; (100d740 <ull_conn_tx_demux+0xfc>)
 100d64a:	4605      	mov	r5, r0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100d64c:	4f3d      	ldr	r7, [pc, #244]	; (100d744 <ull_conn_tx_demux+0x100>)
 100d64e:	78e1      	ldrb	r1, [r4, #3]
	return (void *)(fifo + first * size);
 100d650:	1d26      	adds	r6, r4, #4
 100d652:	e02e      	b.n	100d6b2 <ull_conn_tx_demux+0x6e>
 100d654:	4642      	mov	r2, r8
 100d656:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100d65a:	4638      	mov	r0, r7
 100d65c:	f7f8 fb8e 	bl	1005d7c <mem_get>
	if (conn->lll.handle != handle) {
 100d660:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100d662:	4603      	mov	r3, r0
	if (conn->lll.handle != handle) {
 100d664:	4590      	cmp	r8, r2
 100d666:	d132      	bne.n	100d6ce <ull_conn_tx_demux+0x8a>
			struct node_tx *tx = lll_tx->node;
 100d668:	f8d9 1004 	ldr.w	r1, [r9, #4]
	if ((p->ll_id == PDU_DATA_LLID_DATA_START) && !p->len) {
 100d66c:	790a      	ldrb	r2, [r1, #4]
 100d66e:	7948      	ldrb	r0, [r1, #5]
 100d670:	f002 0203 	and.w	r2, r2, #3
 100d674:	2a02      	cmp	r2, #2
 100d676:	d035      	beq.n	100d6e4 <ull_conn_tx_demux+0xa0>
	} else if (p->len && conn->start_empty) {
 100d678:	2800      	cmp	r0, #0
 100d67a:	d134      	bne.n	100d6e6 <ull_conn_tx_demux+0xa2>
			tx->next = NULL;
 100d67c:	2000      	movs	r0, #0
			if (!conn->tx_data) {
 100d67e:	f8d3 21bc 	ldr.w	r2, [r3, #444]	; 0x1bc
			tx->next = NULL;
 100d682:	6008      	str	r0, [r1, #0]
			if (!conn->tx_data) {
 100d684:	2a00      	cmp	r2, #0
 100d686:	d045      	beq.n	100d714 <ull_conn_tx_demux+0xd0>
			if (conn->tx_data_last) {
 100d688:	f8d3 21c0 	ldr.w	r2, [r3, #448]	; 0x1c0
 100d68c:	b102      	cbz	r2, 100d690 <ull_conn_tx_demux+0x4c>
				conn->tx_data_last->next = tx;
 100d68e:	6011      	str	r1, [r2, #0]
			conn->tx_data_last = tx;
 100d690:	f8c3 11c0 	str.w	r1, [r3, #448]	; 0x1c0
		MFIFO_DEQUEUE(conn_tx);
 100d694:	78e1      	ldrb	r1, [r4, #3]
	u8_t _first = *first; /* Copy read-index */
 100d696:	78a3      	ldrb	r3, [r4, #2]
 100d698:	7862      	ldrb	r2, [r4, #1]
	if (_first == last) {
 100d69a:	4299      	cmp	r1, r3
 100d69c:	d005      	beq.n	100d6aa <ull_conn_tx_demux+0x66>
	_first += 1U;
 100d69e:	3301      	adds	r3, #1
 100d6a0:	b2db      	uxtb	r3, r3
		_first = 0U;
 100d6a2:	429a      	cmp	r2, r3
 100d6a4:	bf08      	it	eq
 100d6a6:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
 100d6a8:	70a3      	strb	r3, [r4, #2]
	} while (--count);
 100d6aa:	3d01      	subs	r5, #1
 100d6ac:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
 100d6b0:	d039      	beq.n	100d726 <ull_conn_tx_demux+0xe2>
		lll_tx = MFIFO_DEQUEUE_GET(conn_tx);
 100d6b2:	78a2      	ldrb	r2, [r4, #2]
 100d6b4:	7823      	ldrb	r3, [r4, #0]
	if (first == last) {
 100d6b6:	428a      	cmp	r2, r1
 100d6b8:	d035      	beq.n	100d726 <ull_conn_tx_demux+0xe2>
	return (void *)(fifo + first * size);
 100d6ba:	fb03 f302 	mul.w	r3, r3, r2
		if (!lll_tx) {
 100d6be:	eb16 0903 	adds.w	r9, r6, r3
 100d6c2:	d030      	beq.n	100d726 <ull_conn_tx_demux+0xe2>
		conn = ll_connected_get(lll_tx->handle);
 100d6c4:	f836 8003 	ldrh.w	r8, [r6, r3]
	if (handle >= CONFIG_BT_MAX_CONN) {
 100d6c8:	f1b8 0f0f 	cmp.w	r8, #15
 100d6cc:	d9c2      	bls.n	100d654 <ull_conn_tx_demux+0x10>
			struct node_tx *tx = lll_tx->node;
 100d6ce:	f8d9 1004 	ldr.w	r1, [r9, #4]
			ll_tx_ack_put(0xFFFF, tx);
 100d6d2:	f64f 70ff 	movw	r0, #65535	; 0xffff
			p->ll_id = PDU_DATA_LLID_RESV;
 100d6d6:	790b      	ldrb	r3, [r1, #4]
 100d6d8:	f36f 0301 	bfc	r3, #0, #2
 100d6dc:	710b      	strb	r3, [r1, #4]
			ll_tx_ack_put(0xFFFF, tx);
 100d6de:	f7fc fd93 	bl	100a208 <ll_tx_ack_put>
 100d6e2:	e7d7      	b.n	100d694 <ull_conn_tx_demux+0x50>
	if ((p->ll_id == PDU_DATA_LLID_DATA_START) && !p->len) {
 100d6e4:	b308      	cbz	r0, 100d72a <ull_conn_tx_demux+0xe6>
	} else if (p->len && conn->start_empty) {
 100d6e6:	f993 01ac 	ldrsb.w	r0, [r3, #428]	; 0x1ac
 100d6ea:	2800      	cmp	r0, #0
 100d6ec:	dac6      	bge.n	100d67c <ull_conn_tx_demux+0x38>
		conn->start_empty = 0U;
 100d6ee:	f893 01ac 	ldrb.w	r0, [r3, #428]	; 0x1ac
		if (p->ll_id == PDU_DATA_LLID_DATA_CONTINUE) {
 100d6f2:	2a01      	cmp	r2, #1
		conn->start_empty = 0U;
 100d6f4:	f36f 10c7 	bfc	r0, #7, #1
 100d6f8:	f883 01ac 	strb.w	r0, [r3, #428]	; 0x1ac
		if (p->ll_id == PDU_DATA_LLID_DATA_CONTINUE) {
 100d6fc:	d1be      	bne.n	100d67c <ull_conn_tx_demux+0x38>
			p->ll_id = PDU_DATA_LLID_DATA_START;
 100d6fe:	2002      	movs	r0, #2
 100d700:	790a      	ldrb	r2, [r1, #4]
 100d702:	f360 0201 	bfi	r2, r0, #0, #2
			tx->next = NULL;
 100d706:	2000      	movs	r0, #0
			p->ll_id = PDU_DATA_LLID_DATA_START;
 100d708:	710a      	strb	r2, [r1, #4]
			if (!conn->tx_data) {
 100d70a:	f8d3 21bc 	ldr.w	r2, [r3, #444]	; 0x1bc
			tx->next = NULL;
 100d70e:	6008      	str	r0, [r1, #0]
			if (!conn->tx_data) {
 100d710:	2a00      	cmp	r2, #0
 100d712:	d1b9      	bne.n	100d688 <ull_conn_tx_demux+0x44>
				if (!conn->tx_head) {
 100d714:	f8d3 21b0 	ldr.w	r2, [r3, #432]	; 0x1b0
				conn->tx_data = tx;
 100d718:	f8c3 11bc 	str.w	r1, [r3, #444]	; 0x1bc
				if (!conn->tx_head) {
 100d71c:	2a00      	cmp	r2, #0
 100d71e:	d1b3      	bne.n	100d688 <ull_conn_tx_demux+0x44>
					conn->tx_head = tx;
 100d720:	f8c3 11b0 	str.w	r1, [r3, #432]	; 0x1b0
			if (conn->tx_data_last) {
 100d724:	e7b4      	b.n	100d690 <ull_conn_tx_demux+0x4c>
}
 100d726:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		conn->start_empty = 1U;
 100d72a:	f893 21ac 	ldrb.w	r2, [r3, #428]	; 0x1ac
		ll_tx_ack_put(conn->lll.handle, tx);
 100d72e:	4640      	mov	r0, r8
		conn->start_empty = 1U;
 100d730:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 100d734:	f883 21ac 	strb.w	r2, [r3, #428]	; 0x1ac
		ll_tx_ack_put(conn->lll.handle, tx);
 100d738:	f7fc fd66 	bl	100a208 <ll_tx_ack_put>
		return -EINVAL;
 100d73c:	e7aa      	b.n	100d694 <ull_conn_tx_demux+0x50>
 100d73e:	bf00      	nop
 100d740:	21000398 	.word	0x21000398
 100d744:	21002bd0 	.word	0x21002bd0

0100d748 <conn_cleanup>:
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
 100d748:	2309      	movs	r3, #9
{
 100d74a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	rx->hdr.handle = conn->lll.handle;
 100d74e:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
	rx = conn->llcp_rx;
 100d750:	f8d0 4100 	ldr.w	r4, [r0, #256]	; 0x100
{
 100d754:	4606      	mov	r6, r0
 100d756:	b082      	sub	sp, #8
	*((u8_t *)rx->pdu) = reason;
 100d758:	f880 114c 	strb.w	r1, [r0, #332]	; 0x14c
	rx->hdr.handle = conn->lll.handle;
 100d75c:	f8a0 2132 	strh.w	r2, [r0, #306]	; 0x132
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
 100d760:	f880 3130 	strb.w	r3, [r0, #304]	; 0x130
	struct lll_conn *lll = &conn->lll;
 100d764:	f100 0a1c 	add.w	sl, r0, #28
	while (rx) {
 100d768:	b144      	cbz	r4, 100d77c <conn_cleanup+0x34>
		hdr->type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d76a:	2503      	movs	r5, #3
		hdr = &rx->hdr;
 100d76c:	4621      	mov	r1, r4
		rx = hdr->link->mem;
 100d76e:	6820      	ldr	r0, [r4, #0]
 100d770:	6844      	ldr	r4, [r0, #4]
		hdr->type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d772:	710d      	strb	r5, [r1, #4]
		ll_rx_put(hdr->link, hdr);
 100d774:	f7fc fd02 	bl	100a17c <ll_rx_put>
	while (rx) {
 100d778:	2c00      	cmp	r4, #0
 100d77a:	d1f7      	bne.n	100d76c <conn_cleanup+0x24>
	while (conn->tx_head) {
 100d77c:	f8d6 11b0 	ldr.w	r1, [r6, #432]	; 0x1b0
 100d780:	b331      	cbz	r1, 100d7d0 <conn_cleanup+0x88>
		link = mem_acquire(&mem_link_tx.free);
 100d782:	f8df 808c 	ldr.w	r8, [pc, #140]	; 100d810 <conn_cleanup+0xc8>
		LL_ASSERT(link);
 100d786:	f8df 9084 	ldr.w	r9, [pc, #132]	; 100d80c <conn_cleanup+0xc4>
 100d78a:	f106 076c 	add.w	r7, r6, #108	; 0x6c
 100d78e:	e007      	b.n	100d7a0 <conn_cleanup+0x58>
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
 100d790:	4629      	mov	r1, r5
 100d792:	4620      	mov	r0, r4
 100d794:	463a      	mov	r2, r7
 100d796:	f7f8 fb23 	bl	1005de0 <memq_enqueue>
	while (conn->tx_head) {
 100d79a:	f8d6 11b0 	ldr.w	r1, [r6, #432]	; 0x1b0
 100d79e:	b1b9      	cbz	r1, 100d7d0 <conn_cleanup+0x88>
		tx = tx_ull_dequeue(conn, conn->tx_head);
 100d7a0:	4630      	mov	r0, r6
 100d7a2:	f7fd fc17 	bl	100afd4 <tx_ull_dequeue>
 100d7a6:	4605      	mov	r5, r0
		link = mem_acquire(&mem_link_tx.free);
 100d7a8:	4640      	mov	r0, r8
 100d7aa:	f7f8 fab5 	bl	1005d18 <mem_acquire>
		LL_ASSERT(link);
 100d7ae:	4604      	mov	r4, r0
 100d7b0:	2800      	cmp	r0, #0
 100d7b2:	d1ed      	bne.n	100d790 <conn_cleanup+0x48>
 100d7b4:	f240 61e3 	movw	r1, #1763	; 0x6e3
 100d7b8:	4648      	mov	r0, r9
 100d7ba:	f7f5 ff61 	bl	1003680 <bt_ctlr_assert_handle>
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
 100d7be:	4629      	mov	r1, r5
 100d7c0:	4620      	mov	r0, r4
 100d7c2:	463a      	mov	r2, r7
 100d7c4:	f7f8 fb0c 	bl	1005de0 <memq_enqueue>
	while (conn->tx_head) {
 100d7c8:	f8d6 11b0 	ldr.w	r1, [r6, #432]	; 0x1b0
 100d7cc:	2900      	cmp	r1, #0
 100d7ce:	d1e7      	bne.n	100d7a0 <conn_cleanup+0x58>
				    TICKER_ID_CONN_BASE + lll->handle,
 100d7d0:	f896 202c 	ldrb.w	r2, [r6, #44]	; 0x2c
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 100d7d4:	4b0c      	ldr	r3, [pc, #48]	; (100d808 <conn_cleanup+0xc0>)
				    TICKER_ID_CONN_BASE + lll->handle,
 100d7d6:	3205      	adds	r2, #5
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 100d7d8:	2101      	movs	r1, #1
 100d7da:	2000      	movs	r0, #0
 100d7dc:	f8cd a000 	str.w	sl, [sp]
 100d7e0:	b2d2      	uxtb	r2, r2
 100d7e2:	f7f9 fda3 	bl	100732c <ticker_stop>
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 100d7e6:	f030 0302 	bics.w	r3, r0, #2
 100d7ea:	d004      	beq.n	100d7f6 <conn_cleanup+0xae>
 100d7ec:	f44f 61da 	mov.w	r1, #1744	; 0x6d0
 100d7f0:	4806      	ldr	r0, [pc, #24]	; (100d80c <conn_cleanup+0xc4>)
 100d7f2:	f7f5 ff45 	bl	1003680 <bt_ctlr_assert_handle>
	lll->handle = 0xFFFF;
 100d7f6:	f64f 73ff 	movw	r3, #65535	; 0xffff
	ull_conn_tx_demux(UINT8_MAX);
 100d7fa:	20ff      	movs	r0, #255	; 0xff
	lll->handle = 0xFFFF;
 100d7fc:	85b3      	strh	r3, [r6, #44]	; 0x2c
}
 100d7fe:	b002      	add	sp, #8
 100d800:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	ull_conn_tx_demux(UINT8_MAX);
 100d804:	f7ff bf1e 	b.w	100d644 <ull_conn_tx_demux>
 100d808:	0100b2d1 	.word	0x0100b2d1
 100d80c:	01018934 	.word	0x01018934
 100d810:	2100530c 	.word	0x2100530c

0100d814 <ull_conn_done>:
	if (lll->handle == 0xFFFF) {
 100d814:	f64f 73ff 	movw	r3, #65535	; 0xffff
{
 100d818:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct lll_conn *lll = (void *)HDR_ULL2LLL(done->param);
 100d81c:	6a06      	ldr	r6, [r0, #32]
{
 100d81e:	b08a      	sub	sp, #40	; 0x28
	if (lll->handle == 0xFFFF) {
 100d820:	8bb2      	ldrh	r2, [r6, #28]
 100d822:	429a      	cmp	r2, r3
 100d824:	d054      	beq.n	100d8d0 <ull_conn_done+0xbc>
	switch (done->extra.mic_state) {
 100d826:	f890 302b 	ldrb.w	r3, [r0, #43]	; 0x2b
 100d82a:	4605      	mov	r5, r0
 100d82c:	2b01      	cmp	r3, #1
	struct ll_conn *conn = (void *)HDR_LLL2EVT(lll);
 100d82e:	68f4      	ldr	r4, [r6, #12]
	switch (done->extra.mic_state) {
 100d830:	f000 8138 	beq.w	100daa4 <ull_conn_done+0x290>
 100d834:	2b02      	cmp	r3, #2
 100d836:	d045      	beq.n	100d8c4 <ull_conn_done+0xb0>
 100d838:	2b00      	cmp	r3, #0
 100d83a:	f000 8114 	beq.w	100da66 <ull_conn_done+0x252>
	reason_peer = conn->llcp_terminate.reason_peer;
 100d83e:	f894 112b 	ldrb.w	r1, [r4, #299]	; 0x12b
	if (reason_peer && (
 100d842:	2900      	cmp	r1, #0
 100d844:	f040 80b5 	bne.w	100d9b2 <ull_conn_done+0x19e>
	latency_event = lll->latency_event;
 100d848:	8cb7      	ldrh	r7, [r6, #36]	; 0x24
	if (done->extra.trx_cnt) {
 100d84a:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
	elapsed_event = latency_event + 1;
 100d84c:	f107 0801 	add.w	r8, r7, #1
	ticks_drift_minus = 0U;
 100d850:	e9cd 1108 	strd	r1, r1, [sp, #32]
	elapsed_event = latency_event + 1;
 100d854:	fa1f f888 	uxth.w	r8, r8
	if (done->extra.trx_cnt) {
 100d858:	2b00      	cmp	r3, #0
 100d85a:	d03c      	beq.n	100d8d6 <ull_conn_done+0xc2>
		} else if (lll->role) {
 100d85c:	f996 302d 	ldrsb.w	r3, [r6, #45]	; 0x2d
 100d860:	2b00      	cmp	r3, #0
 100d862:	f2c0 812f 	blt.w	100dac4 <ull_conn_done+0x2b0>
		conn->connect_expire = 0U;
 100d866:	2200      	movs	r2, #0
	if (done->extra.crc_valid) {
 100d868:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
		conn->connect_expire = 0U;
 100d86c:	f8a4 20c4 	strh.w	r2, [r4, #196]	; 0xc4
	if (done->extra.crc_valid) {
 100d870:	bbb3      	cbnz	r3, 100d8e0 <ull_conn_done+0xcc>
		if (!conn->supervision_expire) {
 100d872:	f8b4 30c8 	ldrh.w	r3, [r4, #200]	; 0xc8
 100d876:	b933      	cbnz	r3, 100d886 <ull_conn_done+0x72>
			conn->supervision_expire = conn->supervision_reload;
 100d878:	f8b4 30c6 	ldrh.w	r3, [r4, #198]	; 0xc6
 100d87c:	f8a4 30c8 	strh.w	r3, [r4, #200]	; 0xc8
	if (conn->supervision_expire) {
 100d880:	2b00      	cmp	r3, #0
 100d882:	f000 8157 	beq.w	100db34 <ull_conn_done+0x320>
		if (conn->supervision_expire > elapsed_event) {
 100d886:	4543      	cmp	r3, r8
 100d888:	f240 8127 	bls.w	100dada <ull_conn_done+0x2c6>
			lll->latency_event = 0;
 100d88c:	2500      	movs	r5, #0
			conn->supervision_expire -= elapsed_event;
 100d88e:	eba3 0308 	sub.w	r3, r3, r8
 100d892:	b29b      	uxth	r3, r3
			if (conn->supervision_expire <= 6U) {
 100d894:	2b06      	cmp	r3, #6
			conn->supervision_expire -= elapsed_event;
 100d896:	f8a4 30c8 	strh.w	r3, [r4, #200]	; 0xc8
			lll->latency_event = 0;
 100d89a:	84b5      	strh	r5, [r6, #36]	; 0x24
			if (conn->supervision_expire <= 6U) {
 100d89c:	f240 8108 	bls.w	100dab0 <ull_conn_done+0x29c>
			else if (lll->role) {
 100d8a0:	f996 302d 	ldrsb.w	r3, [r6, #45]	; 0x2d
 100d8a4:	42ab      	cmp	r3, r5
 100d8a6:	da1e      	bge.n	100d8e6 <ull_conn_done+0xd2>
				if (latency_event) {
 100d8a8:	2f00      	cmp	r7, #0
 100d8aa:	f040 8101 	bne.w	100dab0 <ull_conn_done+0x29c>
					force = conn->slave.force & 0x01;
 100d8ae:	f8d4 50e0 	ldr.w	r5, [r4, #224]	; 0xe0
					conn->slave.force >>= 1;
 100d8b2:	086b      	lsrs	r3, r5, #1
					if (force) {
 100d8b4:	f015 0501 	ands.w	r5, r5, #1
						conn->slave.force |= BIT(31);
 100d8b8:	bf18      	it	ne
 100d8ba:	f043 4300 	orrne.w	r3, r3, #2147483648	; 0x80000000
 100d8be:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
 100d8c2:	e010      	b.n	100d8e6 <ull_conn_done+0xd2>
		conn->llcp_terminate.reason_peer =
 100d8c4:	213d      	movs	r1, #61	; 0x3d
 100d8c6:	f884 112b 	strb.w	r1, [r4, #299]	; 0x12b
		conn_cleanup(conn, reason_peer);
 100d8ca:	4620      	mov	r0, r4
 100d8cc:	f7ff ff3c 	bl	100d748 <conn_cleanup>
}
 100d8d0:	b00a      	add	sp, #40	; 0x28
 100d8d2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (done->extra.crc_valid) {
 100d8d6:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
 100d8da:	2b00      	cmp	r3, #0
 100d8dc:	f000 8084 	beq.w	100d9e8 <ull_conn_done+0x1d4>
		conn->supervision_expire = 0U;
 100d8e0:	2500      	movs	r5, #0
 100d8e2:	f8a4 50c8 	strh.w	r5, [r4, #200]	; 0xc8
	if (conn->procedure_expire != 0U) {
 100d8e6:	f8b4 30cc 	ldrh.w	r3, [r4, #204]	; 0xcc
 100d8ea:	b133      	cbz	r3, 100d8fa <ull_conn_done+0xe6>
		if (conn->procedure_expire > elapsed_event) {
 100d8ec:	4543      	cmp	r3, r8
 100d8ee:	f240 80f9 	bls.w	100dae4 <ull_conn_done+0x2d0>
			conn->procedure_expire -= elapsed_event;
 100d8f2:	eba3 0308 	sub.w	r3, r3, r8
 100d8f6:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	if (conn->apto_expire != 0U) {
 100d8fa:	f8b4 30d4 	ldrh.w	r3, [r4, #212]	; 0xd4
 100d8fe:	b133      	cbz	r3, 100d90e <ull_conn_done+0xfa>
		if (conn->apto_expire > elapsed_event) {
 100d900:	4543      	cmp	r3, r8
 100d902:	f240 809e 	bls.w	100da42 <ull_conn_done+0x22e>
			conn->apto_expire -= elapsed_event;
 100d906:	eba3 0308 	sub.w	r3, r3, r8
 100d90a:	f8a4 30d4 	strh.w	r3, [r4, #212]	; 0xd4
	if (conn->appto_expire != 0U) {
 100d90e:	f8b4 30d0 	ldrh.w	r3, [r4, #208]	; 0xd0
 100d912:	b1a3      	cbz	r3, 100d93e <ull_conn_done+0x12a>
		if (conn->appto_expire > elapsed_event) {
 100d914:	4543      	cmp	r3, r8
 100d916:	d87a      	bhi.n	100da0e <ull_conn_done+0x1fa>
			conn->appto_expire = 0U;
 100d918:	2200      	movs	r2, #0
			if ((conn->procedure_expire == 0U) &&
 100d91a:	f8b4 30cc 	ldrh.w	r3, [r4, #204]	; 0xcc
			conn->appto_expire = 0U;
 100d91e:	f8a4 20d0 	strh.w	r2, [r4, #208]	; 0xd0
			if ((conn->procedure_expire == 0U) &&
 100d922:	b963      	cbnz	r3, 100d93e <ull_conn_done+0x12a>
			    (conn->llcp_req == conn->llcp_ack)) {
 100d924:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 100d928:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
			if ((conn->procedure_expire == 0U) &&
 100d92c:	4293      	cmp	r3, r2
 100d92e:	d10a      	bne.n	100d946 <ull_conn_done+0x132>
				conn->llcp_type = LLCP_PING;
 100d930:	2205      	movs	r2, #5
				conn->llcp_ack -= 2U;
 100d932:	3b02      	subs	r3, #2
 100d934:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
				conn->llcp_type = LLCP_PING;
 100d938:	f884 20ea 	strb.w	r2, [r4, #234]	; 0xea
	if (((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
 100d93c:	e008      	b.n	100d950 <ull_conn_done+0x13c>
 100d93e:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 100d942:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
 100d946:	1a9b      	subs	r3, r3, r2
 100d948:	f003 0303 	and.w	r3, r3, #3
 100d94c:	2b02      	cmp	r3, #2
 100d94e:	d06b      	beq.n	100da28 <ull_conn_done+0x214>
	      (conn->llcp_type == LLCP_CHAN_MAP))) ||
 100d950:	f894 2104 	ldrb.w	r2, [r4, #260]	; 0x104
 100d954:	f894 3105 	ldrb.w	r3, [r4, #261]	; 0x105
 100d958:	429a      	cmp	r2, r3
 100d95a:	f000 80ab 	beq.w	100dab4 <ull_conn_done+0x2a0>
		lll->latency_event = 0;
 100d95e:	2300      	movs	r3, #0
 100d960:	461a      	mov	r2, r3
 100d962:	84b3      	strh	r3, [r6, #36]	; 0x24
	if ((ticks_drift_plus != 0U) || (ticks_drift_minus != 0U) ||
 100d964:	9b09      	ldr	r3, [sp, #36]	; 0x24
	if ((force) || (latency_event != lll->latency_event)) {
 100d966:	b90d      	cbnz	r5, 100d96c <ull_conn_done+0x158>
 100d968:	42ba      	cmp	r2, r7
 100d96a:	d063      	beq.n	100da34 <ull_conn_done+0x220>
		lazy = lll->latency_event + 1;
 100d96c:	3201      	adds	r2, #1
 100d96e:	9c08      	ldr	r4, [sp, #32]
 100d970:	b291      	uxth	r1, r2
	if ((ticks_drift_plus != 0U) || (ticks_drift_minus != 0U) ||
 100d972:	b90b      	cbnz	r3, 100d978 <ull_conn_done+0x164>
 100d974:	2c00      	cmp	r4, #0
 100d976:	d046      	beq.n	100da06 <ull_conn_done+0x1f2>
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
 100d978:	2000      	movs	r0, #0
		u8_t ticker_id = TICKER_ID_CONN_BASE + lll->handle;
 100d97a:	7f32      	ldrb	r2, [r6, #28]
		struct ll_conn *conn = lll->hdr.parent;
 100d97c:	68f6      	ldr	r6, [r6, #12]
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
 100d97e:	9504      	str	r5, [sp, #16]
 100d980:	4d6d      	ldr	r5, [pc, #436]	; (100db38 <ull_conn_done+0x324>)
		u8_t ticker_id = TICKER_ID_CONN_BASE + lll->handle;
 100d982:	3205      	adds	r2, #5
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
 100d984:	9103      	str	r1, [sp, #12]
 100d986:	e9cd 0001 	strd	r0, r0, [sp, #4]
 100d98a:	2101      	movs	r1, #1
 100d98c:	b2d2      	uxtb	r2, r2
 100d98e:	9606      	str	r6, [sp, #24]
 100d990:	9400      	str	r4, [sp, #0]
 100d992:	9505      	str	r5, [sp, #20]
 100d994:	f7f9 fc80 	bl	1007298 <ticker_update>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 100d998:	f030 0302 	bics.w	r3, r0, #2
 100d99c:	d098      	beq.n	100d8d0 <ull_conn_done+0xbc>
 100d99e:	f7fc fc83 	bl	100a2a8 <ull_disable_mark_get>
 100d9a2:	4286      	cmp	r6, r0
 100d9a4:	d094      	beq.n	100d8d0 <ull_conn_done+0xbc>
 100d9a6:	f240 41e7 	movw	r1, #1255	; 0x4e7
 100d9aa:	4864      	ldr	r0, [pc, #400]	; (100db3c <ull_conn_done+0x328>)
 100d9ac:	f7f5 fe68 	bl	1003680 <bt_ctlr_assert_handle>
			  ((void *)conn == ull_disable_mark_get()));
 100d9b0:	e78e      	b.n	100d8d0 <ull_conn_done+0xbc>
	if (reason_peer && (
 100d9b2:	f996 302d 	ldrsb.w	r3, [r6, #45]	; 0x2d
 100d9b6:	2b00      	cmp	r3, #0
 100d9b8:	db87      	blt.n	100d8ca <ull_conn_done+0xb6>
			    lll->role ||
 100d9ba:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
 100d9be:	f013 0202 	ands.w	r2, r3, #2
 100d9c2:	d182      	bne.n	100d8ca <ull_conn_done+0xb6>
			    conn->master.terminate_ack ||
 100d9c4:	293d      	cmp	r1, #61	; 0x3d
 100d9c6:	d080      	beq.n	100d8ca <ull_conn_done+0xb6>
	latency_event = lll->latency_event;
 100d9c8:	8cb7      	ldrh	r7, [r6, #36]	; 0x24
	if (done->extra.trx_cnt) {
 100d9ca:	8d29      	ldrh	r1, [r5, #40]	; 0x28
	elapsed_event = latency_event + 1;
 100d9cc:	f107 0801 	add.w	r8, r7, #1
	ticks_drift_minus = 0U;
 100d9d0:	e9cd 2208 	strd	r2, r2, [sp, #32]
	elapsed_event = latency_event + 1;
 100d9d4:	fa1f f888 	uxth.w	r8, r8
	if (done->extra.trx_cnt) {
 100d9d8:	2900      	cmp	r1, #0
 100d9da:	f43f af7c 	beq.w	100d8d6 <ull_conn_done+0xc2>
			conn->master.terminate_ack = 1;
 100d9de:	f043 0302 	orr.w	r3, r3, #2
 100d9e2:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
 100d9e6:	e73e      	b.n	100d866 <ull_conn_done+0x52>
	else if (conn->connect_expire) {
 100d9e8:	f8b4 30c4 	ldrh.w	r3, [r4, #196]	; 0xc4
 100d9ec:	2b00      	cmp	r3, #0
 100d9ee:	f43f af40 	beq.w	100d872 <ull_conn_done+0x5e>
		if (conn->connect_expire > elapsed_event) {
 100d9f2:	4543      	cmp	r3, r8
 100d9f4:	f240 8084 	bls.w	100db00 <ull_conn_done+0x2ec>
			conn->connect_expire -= elapsed_event;
 100d9f8:	eba3 0308 	sub.w	r3, r3, r8
 100d9fc:	f8a4 30c4 	strh.w	r3, [r4, #196]	; 0xc4
 100da00:	f8b4 30c8 	ldrh.w	r3, [r4, #200]	; 0xc8
 100da04:	e73c      	b.n	100d880 <ull_conn_done+0x6c>
	if ((ticks_drift_plus != 0U) || (ticks_drift_minus != 0U) ||
 100da06:	2900      	cmp	r1, #0
 100da08:	d075      	beq.n	100daf6 <ull_conn_done+0x2e2>
 100da0a:	4623      	mov	r3, r4
 100da0c:	e7b4      	b.n	100d978 <ull_conn_done+0x164>
			conn->appto_expire -= elapsed_event;
 100da0e:	eba3 0808 	sub.w	r8, r3, r8
 100da12:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
	if (((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
 100da16:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
			conn->appto_expire -= elapsed_event;
 100da1a:	f8a4 80d0 	strh.w	r8, [r4, #208]	; 0xd0
	if (((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
 100da1e:	1a9b      	subs	r3, r3, r2
 100da20:	f003 0303 	and.w	r3, r3, #3
 100da24:	2b02      	cmp	r3, #2
 100da26:	d193      	bne.n	100d950 <ull_conn_done+0x13c>
 100da28:	f894 30ea 	ldrb.w	r3, [r4, #234]	; 0xea
 100da2c:	3b01      	subs	r3, #1
 100da2e:	2b01      	cmp	r3, #1
 100da30:	d88e      	bhi.n	100d950 <ull_conn_done+0x13c>
 100da32:	e794      	b.n	100d95e <ull_conn_done+0x14a>
	if ((ticks_drift_plus != 0U) || (ticks_drift_minus != 0U) ||
 100da34:	9c08      	ldr	r4, [sp, #32]
 100da36:	b913      	cbnz	r3, 100da3e <ull_conn_done+0x22a>
 100da38:	2c00      	cmp	r4, #0
 100da3a:	f43f af49 	beq.w	100d8d0 <ull_conn_done+0xbc>
	lazy = 0U;
 100da3e:	4629      	mov	r1, r5
 100da40:	e79a      	b.n	100d978 <ull_conn_done+0x164>
			rx = ll_pdu_rx_alloc();
 100da42:	f7fc fbc9 	bl	100a1d8 <ll_pdu_rx_alloc>
			if (rx) {
 100da46:	4601      	mov	r1, r0
 100da48:	2800      	cmp	r0, #0
 100da4a:	d050      	beq.n	100daee <ull_conn_done+0x2da>
				rx->type = NODE_RX_TYPE_APTO;
 100da4c:	220c      	movs	r2, #12
				conn->apto_expire = 0U;
 100da4e:	2000      	movs	r0, #0
				rx->handle = lll->handle;
 100da50:	8bb3      	ldrh	r3, [r6, #28]
				conn->apto_expire = 0U;
 100da52:	f8a4 00d4 	strh.w	r0, [r4, #212]	; 0xd4
				ll_rx_put(rx->link, rx);
 100da56:	6808      	ldr	r0, [r1, #0]
				rx->type = NODE_RX_TYPE_APTO;
 100da58:	710a      	strb	r2, [r1, #4]
				rx->handle = lll->handle;
 100da5a:	80cb      	strh	r3, [r1, #6]
				ll_rx_put(rx->link, rx);
 100da5c:	f7fc fb8e 	bl	100a17c <ll_rx_put>
				ll_rx_sched();
 100da60:	f7fc fb96 	bl	100a190 <ll_rx_sched>
 100da64:	e753      	b.n	100d90e <ull_conn_done+0xfa>
		if (lll->enc_rx || conn->llcp_enc.pause_rx) {
 100da66:	f896 306e 	ldrb.w	r3, [r6, #110]	; 0x6e
 100da6a:	0719      	lsls	r1, r3, #28
 100da6c:	d404      	bmi.n	100da78 <ull_conn_done+0x264>
 100da6e:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
 100da72:	07da      	lsls	r2, r3, #31
 100da74:	f57f aee3 	bpl.w	100d83e <ull_conn_done+0x2a>
					    (lll->latency + 6)) ?
 100da78:	8c33      	ldrh	r3, [r6, #32]
			appto_reload_new = (conn->apto_reload >
 100da7a:	f8b4 20d2 	ldrh.w	r2, [r4, #210]	; 0xd2
					    (lll->latency + 6)) ?
 100da7e:	1d99      	adds	r1, r3, #6
			appto_reload_new = (conn->apto_reload >
 100da80:	428a      	cmp	r2, r1
 100da82:	bfd2      	itee	le
 100da84:	4613      	movle	r3, r2
					   (conn->apto_reload -
 100da86:	1ad3      	subgt	r3, r2, r3
 100da88:	3b06      	subgt	r3, #6
			if (conn->appto_reload != appto_reload_new) {
 100da8a:	f8b4 10ce 	ldrh.w	r1, [r4, #206]	; 0xce
			appto_reload_new = (conn->apto_reload >
 100da8e:	bfc8      	it	gt
 100da90:	b29b      	uxthgt	r3, r3
			if (conn->appto_reload != appto_reload_new) {
 100da92:	4299      	cmp	r1, r3
 100da94:	d010      	beq.n	100dab8 <ull_conn_done+0x2a4>
				conn->appto_reload = appto_reload_new;
 100da96:	f8a4 30ce 	strh.w	r3, [r4, #206]	; 0xce
				conn->appto_expire = conn->appto_reload;
 100da9a:	f8a4 30d0 	strh.w	r3, [r4, #208]	; 0xd0
				conn->apto_expire = conn->apto_reload;
 100da9e:	f8a4 20d4 	strh.w	r2, [r4, #212]	; 0xd4
 100daa2:	e6cc      	b.n	100d83e <ull_conn_done+0x2a>
		conn->appto_expire = conn->apto_expire = 0U;
 100daa4:	2300      	movs	r3, #0
 100daa6:	f8a4 30d4 	strh.w	r3, [r4, #212]	; 0xd4
 100daaa:	f8a4 30d0 	strh.w	r3, [r4, #208]	; 0xd0
		break;
 100daae:	e6c6      	b.n	100d83e <ull_conn_done+0x2a>
					force = 1U;
 100dab0:	2501      	movs	r5, #1
 100dab2:	e718      	b.n	100d8e6 <ull_conn_done+0xd2>
 100dab4:	8cb2      	ldrh	r2, [r6, #36]	; 0x24
 100dab6:	e755      	b.n	100d964 <ull_conn_done+0x150>
			if (conn->apto_expire == 0U) {
 100dab8:	f8b4 10d4 	ldrh.w	r1, [r4, #212]	; 0xd4
 100dabc:	2900      	cmp	r1, #0
 100dabe:	f47f aebe 	bne.w	100d83e <ull_conn_done+0x2a>
 100dac2:	e7ea      	b.n	100da9a <ull_conn_done+0x286>
			ull_slave_done(done, &ticks_drift_plus,
 100dac4:	4628      	mov	r0, r5
 100dac6:	aa08      	add	r2, sp, #32
 100dac8:	a909      	add	r1, sp, #36	; 0x24
 100daca:	f7f5 f811 	bl	1002af0 <ull_slave_done>
			if (!conn->tx_head) {
 100dace:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
 100dad2:	b1d3      	cbz	r3, 100db0a <ull_conn_done+0x2f6>
				lll->latency_event = 0;
 100dad4:	2300      	movs	r3, #0
 100dad6:	84b3      	strh	r3, [r6, #36]	; 0x24
 100dad8:	e6c5      	b.n	100d866 <ull_conn_done+0x52>
			conn_cleanup(conn, BT_HCI_ERR_CONN_TIMEOUT);
 100dada:	4620      	mov	r0, r4
 100dadc:	2108      	movs	r1, #8
 100dade:	f7ff fe33 	bl	100d748 <conn_cleanup>
			return;
 100dae2:	e6f5      	b.n	100d8d0 <ull_conn_done+0xbc>
			conn_cleanup(conn, BT_HCI_ERR_LL_RESP_TIMEOUT);
 100dae4:	4620      	mov	r0, r4
 100dae6:	2122      	movs	r1, #34	; 0x22
 100dae8:	f7ff fe2e 	bl	100d748 <conn_cleanup>
			return;
 100daec:	e6f0      	b.n	100d8d0 <ull_conn_done+0xbc>
				conn->apto_expire = 1U;
 100daee:	2301      	movs	r3, #1
 100daf0:	f8a4 30d4 	strh.w	r3, [r4, #212]	; 0xd4
 100daf4:	e70b      	b.n	100d90e <ull_conn_done+0xfa>
	    (lazy != 0U) || (force != 0U)) {
 100daf6:	2d00      	cmp	r5, #0
 100daf8:	f43f aeea 	beq.w	100d8d0 <ull_conn_done+0xbc>
 100dafc:	460b      	mov	r3, r1
 100dafe:	e73b      	b.n	100d978 <ull_conn_done+0x164>
			conn_cleanup(conn, BT_HCI_ERR_CONN_FAIL_TO_ESTAB);
 100db00:	4620      	mov	r0, r4
 100db02:	213e      	movs	r1, #62	; 0x3e
 100db04:	f7ff fe20 	bl	100d748 <conn_cleanup>
			return;
 100db08:	e6e2      	b.n	100d8d0 <ull_conn_done+0xbc>
				ull_conn_tx_demux(UINT8_MAX);
 100db0a:	20ff      	movs	r0, #255	; 0xff
 100db0c:	f7ff fd9a 	bl	100d644 <ull_conn_tx_demux>
			if (conn->tx_head || memq_peek(lll->memq_tx.head,
 100db10:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
 100db14:	2a00      	cmp	r2, #0
 100db16:	d1dd      	bne.n	100dad4 <ull_conn_done+0x2c0>
 100db18:	e9d6 0116 	ldrd	r0, r1, [r6, #88]	; 0x58
 100db1c:	f7f8 f968 	bl	1005df0 <memq_peek>
 100db20:	2800      	cmp	r0, #0
 100db22:	d1d7      	bne.n	100dad4 <ull_conn_done+0x2c0>
			} else if (lll->slave.latency_enabled) {
 100db24:	f896 3030 	ldrb.w	r3, [r6, #48]	; 0x30
 100db28:	07db      	lsls	r3, r3, #31
 100db2a:	f57f ae9c 	bpl.w	100d866 <ull_conn_done+0x52>
				lll->latency_event = lll->latency;
 100db2e:	8c33      	ldrh	r3, [r6, #32]
 100db30:	84b3      	strh	r3, [r6, #36]	; 0x24
 100db32:	e698      	b.n	100d866 <ull_conn_done+0x52>
	force = 0U;
 100db34:	461d      	mov	r5, r3
 100db36:	e6d6      	b.n	100d8e6 <ull_conn_done+0xd2>
 100db38:	0100b36d 	.word	0x0100b36d
 100db3c:	01018934 	.word	0x01018934

0100db40 <ull_conn_tx_lll_enqueue>:
	while (conn->tx_head &&
 100db40:	f8d0 31b0 	ldr.w	r3, [r0, #432]	; 0x1b0
 100db44:	2b00      	cmp	r3, #0
 100db46:	f000 80de 	beq.w	100dd06 <ull_conn_tx_lll_enqueue+0x1c6>
 100db4a:	3901      	subs	r1, #1
{
 100db4c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 100db50:	4604      	mov	r4, r0
			conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
 100db52:	f04f 0a01 	mov.w	sl, #1
		link = mem_acquire(&mem_link_tx.free);
 100db56:	f8df 81b0 	ldr.w	r8, [pc, #432]	; 100dd08 <ull_conn_tx_lll_enqueue+0x1c8>
		LL_ASSERT(link);
 100db5a:	f8df 91b0 	ldr.w	r9, [pc, #432]	; 100dd0c <ull_conn_tx_lll_enqueue+0x1cc>
 100db5e:	b2cd      	uxtb	r5, r1
 100db60:	e012      	b.n	100db88 <ull_conn_tx_lll_enqueue+0x48>
		link = mem_acquire(&mem_link_tx.free);
 100db62:	4640      	mov	r0, r8
 100db64:	f7f8 f8d8 	bl	1005d18 <mem_acquire>
		LL_ASSERT(link);
 100db68:	4607      	mov	r7, r0
 100db6a:	2800      	cmp	r0, #0
 100db6c:	d066      	beq.n	100dc3c <ull_conn_tx_lll_enqueue+0xfc>
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
 100db6e:	4631      	mov	r1, r6
 100db70:	4638      	mov	r0, r7
 100db72:	f104 026c 	add.w	r2, r4, #108	; 0x6c
 100db76:	f7f8 f933 	bl	1005de0 <memq_enqueue>
	while (conn->tx_head &&
 100db7a:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
 100db7e:	3d01      	subs	r5, #1
 100db80:	b2ed      	uxtb	r5, r5
 100db82:	2b00      	cmp	r3, #0
 100db84:	f000 8081 	beq.w	100dc8a <ull_conn_tx_lll_enqueue+0x14a>
		 !conn->llcp_phy.pause_tx &&
 100db88:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
	while (conn->tx_head &&
 100db8c:	07d1      	lsls	r1, r2, #31
 100db8e:	d403      	bmi.n	100db98 <ull_conn_tx_lll_enqueue+0x58>
		 !conn->llcp_enc.pause_tx &&
 100db90:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
		 !conn->llcp_phy.pause_tx &&
 100db94:	0792      	lsls	r2, r2, #30
 100db96:	d55e      	bpl.n	100dc56 <ull_conn_tx_lll_enqueue+0x116>
		(!pause_tx && (conn->tx_head == conn->tx_ctrl))) && count--) {
 100db98:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 100db9c:	4293      	cmp	r3, r2
 100db9e:	d174      	bne.n	100dc8a <ull_conn_tx_lll_enqueue+0x14a>
 100dba0:	2dff      	cmp	r5, #255	; 0xff
 100dba2:	d072      	beq.n	100dc8a <ull_conn_tx_lll_enqueue+0x14a>
		tx = tx_ull_dequeue(conn, conn->tx_head);
 100dba4:	4620      	mov	r0, r4
 100dba6:	f8d4 11b0 	ldr.w	r1, [r4, #432]	; 0x1b0
 100dbaa:	f7fd fa13 	bl	100afd4 <tx_ull_dequeue>
		if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
 100dbae:	7903      	ldrb	r3, [r0, #4]
		tx = tx_ull_dequeue(conn, conn->tx_head);
 100dbb0:	4606      	mov	r6, r0
		if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
 100dbb2:	f003 0303 	and.w	r3, r3, #3
 100dbb6:	2b03      	cmp	r3, #3
 100dbb8:	d1d3      	bne.n	100db62 <ull_conn_tx_lll_enqueue+0x22>
	switch (pdu_tx->llctrl.opcode) {
 100dbba:	79c3      	ldrb	r3, [r0, #7]
 100dbbc:	3b03      	subs	r3, #3
 100dbbe:	2b14      	cmp	r3, #20
 100dbc0:	d8cf      	bhi.n	100db62 <ull_conn_tx_lll_enqueue+0x22>
 100dbc2:	a201      	add	r2, pc, #4	; (adr r2, 100dbc8 <ull_conn_tx_lll_enqueue+0x88>)
 100dbc4:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 100dbc8:	0100dc25 	.word	0x0100dc25
 100dbcc:	0100dc25 	.word	0x0100dc25
 100dbd0:	0100db63 	.word	0x0100db63
 100dbd4:	0100db63 	.word	0x0100db63
 100dbd8:	0100db63 	.word	0x0100db63
 100dbdc:	0100db63 	.word	0x0100db63
 100dbe0:	0100db63 	.word	0x0100db63
 100dbe4:	0100dc25 	.word	0x0100dc25
 100dbe8:	0100dc1d 	.word	0x0100dc1d
 100dbec:	0100db63 	.word	0x0100db63
 100dbf0:	0100db63 	.word	0x0100db63
 100dbf4:	0100db63 	.word	0x0100db63
 100dbf8:	0100db63 	.word	0x0100db63
 100dbfc:	0100db63 	.word	0x0100db63
 100dc00:	0100db63 	.word	0x0100db63
 100dc04:	0100db63 	.word	0x0100db63
 100dc08:	0100db63 	.word	0x0100db63
 100dc0c:	0100db63 	.word	0x0100db63
 100dc10:	0100db63 	.word	0x0100db63
 100dc14:	0100dc49 	.word	0x0100dc49
 100dc18:	0100dc49 	.word	0x0100dc49
		if (!conn->lll.role) {
 100dc1c:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
 100dc20:	2b00      	cmp	r3, #0
 100dc22:	da9e      	bge.n	100db62 <ull_conn_tx_lll_enqueue+0x22>
		conn->llcp_enc.pause_tx = 1U;
 100dc24:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
		link = mem_acquire(&mem_link_tx.free);
 100dc28:	4640      	mov	r0, r8
		conn->llcp_enc.pause_tx = 1U;
 100dc2a:	f043 0302 	orr.w	r3, r3, #2
 100dc2e:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
		link = mem_acquire(&mem_link_tx.free);
 100dc32:	f7f8 f871 	bl	1005d18 <mem_acquire>
		LL_ASSERT(link);
 100dc36:	4607      	mov	r7, r0
 100dc38:	2800      	cmp	r0, #0
 100dc3a:	d198      	bne.n	100db6e <ull_conn_tx_lll_enqueue+0x2e>
 100dc3c:	f240 5163 	movw	r1, #1379	; 0x563
 100dc40:	4648      	mov	r0, r9
 100dc42:	f7f5 fd1d 	bl	1003680 <bt_ctlr_assert_handle>
 100dc46:	e792      	b.n	100db6e <ull_conn_tx_lll_enqueue+0x2e>
		conn->llcp_phy.pause_tx = 1U;
 100dc48:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
 100dc4c:	f043 0301 	orr.w	r3, r3, #1
 100dc50:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
		break;
 100dc54:	e785      	b.n	100db62 <ull_conn_tx_lll_enqueue+0x22>
	if ((pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
 100dc56:	791a      	ldrb	r2, [r3, #4]
 100dc58:	f002 0203 	and.w	r2, r2, #3
 100dc5c:	2a03      	cmp	r2, #3
 100dc5e:	d19f      	bne.n	100dba0 <ull_conn_tx_lll_enqueue+0x60>
	    ((pdu_data_tx->llctrl.opcode ==
 100dc60:	79da      	ldrb	r2, [r3, #7]
	if ((pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
 100dc62:	2a03      	cmp	r2, #3
 100dc64:	d001      	beq.n	100dc6a <ull_conn_tx_lll_enqueue+0x12a>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) ||
 100dc66:	2a0a      	cmp	r2, #10
 100dc68:	d19a      	bne.n	100dba0 <ull_conn_tx_lll_enqueue+0x60>
		if (((conn->llcp_req != conn->llcp_ack) &&
 100dc6a:	f894 10e9 	ldrb.w	r1, [r4, #233]	; 0xe9
 100dc6e:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
 100dc72:	428a      	cmp	r2, r1
 100dc74:	d00b      	beq.n	100dc8e <ull_conn_tx_lll_enqueue+0x14e>
 100dc76:	f894 20ea 	ldrb.w	r2, [r4, #234]	; 0xea
 100dc7a:	2a03      	cmp	r2, #3
 100dc7c:	d090      	beq.n	100dba0 <ull_conn_tx_lll_enqueue+0x60>
			if ((tx->next != NULL) &&
 100dc7e:	681a      	ldr	r2, [r3, #0]
 100dc80:	b11a      	cbz	r2, 100dc8a <ull_conn_tx_lll_enqueue+0x14a>
 100dc82:	f8d4 11b4 	ldr.w	r1, [r4, #436]	; 0x1b4
 100dc86:	428a      	cmp	r2, r1
 100dc88:	d02c      	beq.n	100dce4 <ull_conn_tx_lll_enqueue+0x1a4>
}
 100dc8a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		    ((conn->llcp_req == conn->llcp_ack) &&
 100dc8e:	f894 0119 	ldrb.w	r0, [r4, #281]	; 0x119
 100dc92:	f894 1118 	ldrb.w	r1, [r4, #280]	; 0x118
 100dc96:	4288      	cmp	r0, r1
 100dc98:	d1f1      	bne.n	100dc7e <ull_conn_tx_lll_enqueue+0x13e>
		     ((conn->llcp_feature.ack != conn->llcp_feature.req) ||
 100dc9a:	f894 0121 	ldrb.w	r0, [r4, #289]	; 0x121
 100dc9e:	f894 1120 	ldrb.w	r1, [r4, #288]	; 0x120
 100dca2:	4288      	cmp	r0, r1
 100dca4:	d1eb      	bne.n	100dc7e <ull_conn_tx_lll_enqueue+0x13e>
		      (conn->llcp_version.ack != conn->llcp_version.req) ||
 100dca6:	f894 0171 	ldrb.w	r0, [r4, #369]	; 0x171
 100dcaa:	f894 1170 	ldrb.w	r1, [r4, #368]	; 0x170
 100dcae:	4288      	cmp	r0, r1
 100dcb0:	d1e5      	bne.n	100dc7e <ull_conn_tx_lll_enqueue+0x13e>
		       conn->llcp_conn_param.req) ||
 100dcb2:	f894 0199 	ldrb.w	r0, [r4, #409]	; 0x199
 100dcb6:	f894 1198 	ldrb.w	r1, [r4, #408]	; 0x198
 100dcba:	4288      	cmp	r0, r1
 100dcbc:	d1df      	bne.n	100dc7e <ull_conn_tx_lll_enqueue+0x13e>
		      (conn->llcp_phy.ack != conn->llcp_phy.req) ||
 100dcbe:	f894 01a9 	ldrb.w	r0, [r4, #425]	; 0x1a9
 100dcc2:	f894 11a8 	ldrb.w	r1, [r4, #424]	; 0x1a8
 100dcc6:	4288      	cmp	r0, r1
 100dcc8:	d1d9      	bne.n	100dc7e <ull_conn_tx_lll_enqueue+0x13e>
			conn->llcp_type = LLCP_ENCRYPTION;
 100dcca:	2103      	movs	r1, #3
			conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
 100dccc:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
			conn->llcp_ack -= 2U;
 100dcd0:	3a02      	subs	r2, #2
			conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
 100dcd2:	f36a 0301 	bfi	r3, sl, #0, #2
			conn->llcp_ack -= 2U;
 100dcd6:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
			conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
 100dcda:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
			conn->llcp_type = LLCP_ENCRYPTION;
 100dcde:	f884 10ea 	strb.w	r1, [r4, #234]	; 0xea
			conn->llcp_ack -= 2U;
 100dce2:	e75d      	b.n	100dba0 <ull_conn_tx_lll_enqueue+0x60>
				tx->next = conn->tx_ctrl_last->next;
 100dce4:	f8d4 11b8 	ldr.w	r1, [r4, #440]	; 0x1b8
				conn->tx_head = tx->next;
 100dce8:	f8c4 21b0 	str.w	r2, [r4, #432]	; 0x1b0
				if (!conn->tx_data_last) {
 100dcec:	f8d4 01c0 	ldr.w	r0, [r4, #448]	; 0x1c0
				tx->next = conn->tx_ctrl_last->next;
 100dcf0:	680a      	ldr	r2, [r1, #0]
 100dcf2:	601a      	str	r2, [r3, #0]
				conn->tx_ctrl_last->next = tx;
 100dcf4:	600b      	str	r3, [r1, #0]
				conn->tx_data = tx;
 100dcf6:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
				if (!conn->tx_data_last) {
 100dcfa:	2800      	cmp	r0, #0
 100dcfc:	f47f af50 	bne.w	100dba0 <ull_conn_tx_lll_enqueue+0x60>
					conn->tx_data_last = tx;
 100dd00:	f8c4 31c0 	str.w	r3, [r4, #448]	; 0x1c0
 100dd04:	e74c      	b.n	100dba0 <ull_conn_tx_lll_enqueue+0x60>
 100dd06:	4770      	bx	lr
 100dd08:	2100530c 	.word	0x2100530c
 100dd0c:	01018934 	.word	0x01018934

0100dd10 <ull_conn_link_tx_release>:
	mem_release(link, &mem_link_tx.free);
 100dd10:	4901      	ldr	r1, [pc, #4]	; (100dd18 <ull_conn_link_tx_release+0x8>)
 100dd12:	f7f8 b81b 	b.w	1005d4c <mem_release>
 100dd16:	bf00      	nop
 100dd18:	2100530c 	.word	0x2100530c

0100dd1c <ull_conn_ack_last_idx_get>:
	return mfifo_conn_ack.l;
 100dd1c:	4b01      	ldr	r3, [pc, #4]	; (100dd24 <ull_conn_ack_last_idx_get+0x8>)
}
 100dd1e:	78d8      	ldrb	r0, [r3, #3]
 100dd20:	4770      	bx	lr
 100dd22:	bf00      	nop
 100dd24:	2100031c 	.word	0x2100031c

0100dd28 <ull_conn_ack_peek>:
{
 100dd28:	b470      	push	{r4, r5, r6}
	lll_tx = MFIFO_DEQUEUE_GET(conn_ack);
 100dd2a:	4b0b      	ldr	r3, [pc, #44]	; (100dd58 <ull_conn_ack_peek+0x30>)
{
 100dd2c:	4605      	mov	r5, r0
	lll_tx = MFIFO_DEQUEUE_GET(conn_ack);
 100dd2e:	78de      	ldrb	r6, [r3, #3]
 100dd30:	7898      	ldrb	r0, [r3, #2]
 100dd32:	781c      	ldrb	r4, [r3, #0]
	if (first == last) {
 100dd34:	42b0      	cmp	r0, r6
 100dd36:	d00c      	beq.n	100dd52 <ull_conn_ack_peek+0x2a>
	return (void *)(fifo + first * size);
 100dd38:	fb04 f400 	mul.w	r4, r4, r0
 100dd3c:	3304      	adds	r3, #4
	if (!lll_tx) {
 100dd3e:	1918      	adds	r0, r3, r4
 100dd40:	d005      	beq.n	100dd4e <ull_conn_ack_peek+0x26>
	*ack_last = mfifo_conn_ack.l;
 100dd42:	702e      	strb	r6, [r5, #0]
	*handle = lll_tx->handle;
 100dd44:	5b1c      	ldrh	r4, [r3, r4]
	*tx = lll_tx->node;
 100dd46:	6843      	ldr	r3, [r0, #4]
	*handle = lll_tx->handle;
 100dd48:	800c      	strh	r4, [r1, #0]
	*tx = lll_tx->node;
 100dd4a:	6013      	str	r3, [r2, #0]
	return (*tx)->link;
 100dd4c:	6818      	ldr	r0, [r3, #0]
}
 100dd4e:	bc70      	pop	{r4, r5, r6}
 100dd50:	4770      	bx	lr
		return NULL;
 100dd52:	2000      	movs	r0, #0
 100dd54:	e7fb      	b.n	100dd4e <ull_conn_ack_peek+0x26>
 100dd56:	bf00      	nop
 100dd58:	2100031c 	.word	0x2100031c

0100dd5c <ull_conn_ack_by_last_peek>:
{
 100dd5c:	b430      	push	{r4, r5}
	lll_tx = mfifo_dequeue_get(mfifo_conn_ack.m, mfifo_conn_ack.s,
 100dd5e:	4b09      	ldr	r3, [pc, #36]	; (100dd84 <ull_conn_ack_by_last_peek+0x28>)
 100dd60:	789d      	ldrb	r5, [r3, #2]
 100dd62:	781c      	ldrb	r4, [r3, #0]
	if (first == last) {
 100dd64:	4285      	cmp	r5, r0
 100dd66:	d00b      	beq.n	100dd80 <ull_conn_ack_by_last_peek+0x24>
	return (void *)(fifo + first * size);
 100dd68:	fb04 f405 	mul.w	r4, r4, r5
 100dd6c:	3304      	adds	r3, #4
	if (!lll_tx) {
 100dd6e:	1918      	adds	r0, r3, r4
 100dd70:	d004      	beq.n	100dd7c <ull_conn_ack_by_last_peek+0x20>
	*handle = lll_tx->handle;
 100dd72:	5b1c      	ldrh	r4, [r3, r4]
	*tx = lll_tx->node;
 100dd74:	6843      	ldr	r3, [r0, #4]
	*handle = lll_tx->handle;
 100dd76:	800c      	strh	r4, [r1, #0]
	*tx = lll_tx->node;
 100dd78:	6013      	str	r3, [r2, #0]
	return (*tx)->link;
 100dd7a:	6818      	ldr	r0, [r3, #0]
}
 100dd7c:	bc30      	pop	{r4, r5}
 100dd7e:	4770      	bx	lr
		return NULL;
 100dd80:	2000      	movs	r0, #0
 100dd82:	e7fb      	b.n	100dd7c <ull_conn_ack_by_last_peek+0x20>
 100dd84:	2100031c 	.word	0x2100031c

0100dd88 <ull_conn_ack_dequeue>:
{
 100dd88:	b410      	push	{r4}
	return MFIFO_DEQUEUE(conn_ack);
 100dd8a:	4b0a      	ldr	r3, [pc, #40]	; (100ddb4 <ull_conn_ack_dequeue+0x2c>)
	u8_t _first = *first; /* Copy read-index */
 100dd8c:	7899      	ldrb	r1, [r3, #2]
	if (_first == last) {
 100dd8e:	78da      	ldrb	r2, [r3, #3]
 100dd90:	7818      	ldrb	r0, [r3, #0]
 100dd92:	428a      	cmp	r2, r1
 100dd94:	785c      	ldrb	r4, [r3, #1]
 100dd96:	d00a      	beq.n	100ddae <ull_conn_ack_dequeue+0x26>
	_first += 1U;
 100dd98:	1c4a      	adds	r2, r1, #1
 100dd9a:	b2d2      	uxtb	r2, r2
		_first = 0U;
 100dd9c:	4294      	cmp	r4, r2
 100dd9e:	bf08      	it	eq
 100dda0:	2200      	moveq	r2, #0
	mem = *((void **)(fifo + _first * size));
 100dda2:	fb00 3101 	mla	r1, r0, r1, r3
 100dda6:	6848      	ldr	r0, [r1, #4]
	*first = _first; /* Write back read-index */
 100dda8:	709a      	strb	r2, [r3, #2]
}
 100ddaa:	bc10      	pop	{r4}
 100ddac:	4770      	bx	lr
		return NULL;
 100ddae:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(conn_ack);
 100ddb0:	e7fb      	b.n	100ddaa <ull_conn_ack_dequeue+0x22>
 100ddb2:	bf00      	nop
 100ddb4:	2100031c 	.word	0x2100031c

0100ddb8 <ull_conn_lll_ack_enqueue>:
{
 100ddb8:	b570      	push	{r4, r5, r6, lr}
	idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
 100ddba:	4c0f      	ldr	r4, [pc, #60]	; (100ddf8 <ull_conn_lll_ack_enqueue+0x40>)
 100ddbc:	78e2      	ldrb	r2, [r4, #3]
	if (last == count) {
 100ddbe:	7865      	ldrb	r5, [r4, #1]
	last = last + 1;
 100ddc0:	1c53      	adds	r3, r2, #1
 100ddc2:	b2db      	uxtb	r3, r3
		last = 0U;
 100ddc4:	429d      	cmp	r5, r3
 100ddc6:	bf08      	it	eq
 100ddc8:	2300      	moveq	r3, #0
 100ddca:	78a5      	ldrb	r5, [r4, #2]
	if (last == first) {
 100ddcc:	429d      	cmp	r5, r3
 100ddce:	d00a      	beq.n	100dde6 <ull_conn_lll_ack_enqueue+0x2e>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
 100ddd0:	4625      	mov	r5, r4
 100ddd2:	f815 6b04 	ldrb.w	r6, [r5], #4
 100ddd6:	fb02 f206 	mul.w	r2, r2, r6
	LL_ASSERT(lll_tx);
 100ddda:	18ae      	adds	r6, r5, r2
 100dddc:	d003      	beq.n	100dde6 <ull_conn_lll_ack_enqueue+0x2e>
	lll_tx->handle = handle;
 100ddde:	52a8      	strh	r0, [r5, r2]
	lll_tx->node = tx;
 100dde0:	6071      	str	r1, [r6, #4]
	*last = idx; /* Commit: Update write index */
 100dde2:	70e3      	strb	r3, [r4, #3]
}
 100dde4:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(lll_tx);
 100dde6:	f240 51a1 	movw	r1, #1441	; 0x5a1
 100ddea:	4804      	ldr	r0, [pc, #16]	; (100ddfc <ull_conn_lll_ack_enqueue+0x44>)
 100ddec:	f7f5 fc48 	bl	1003680 <bt_ctlr_assert_handle>
	lll_tx->handle = handle;
 100ddf0:	2300      	movs	r3, #0
 100ddf2:	801b      	strh	r3, [r3, #0]
 100ddf4:	deff      	udf	#255	; 0xff
 100ddf6:	bf00      	nop
 100ddf8:	2100031c 	.word	0x2100031c
 100ddfc:	01018934 	.word	0x01018934

0100de00 <ull_conn_tx_ack>:
{
 100de00:	b5f0      	push	{r4, r5, r6, r7, lr}
	LL_ASSERT(pdu_tx->len);
 100de02:	7953      	ldrb	r3, [r2, #5]
{
 100de04:	4614      	mov	r4, r2
 100de06:	4605      	mov	r5, r0
 100de08:	460f      	mov	r7, r1
 100de0a:	b083      	sub	sp, #12
	LL_ASSERT(pdu_tx->len);
 100de0c:	b35b      	cbz	r3, 100de66 <ull_conn_tx_ack+0x66>
	if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
 100de0e:	7923      	ldrb	r3, [r4, #4]
 100de10:	f003 0203 	and.w	r2, r3, #3
 100de14:	2a03      	cmp	r2, #3
 100de16:	d016      	beq.n	100de46 <ull_conn_tx_ack+0x46>
	} else if (handle != 0xFFFF) {
 100de18:	f64f 72ff 	movw	r2, #65535	; 0xffff
 100de1c:	4295      	cmp	r5, r2
 100de1e:	d10a      	bne.n	100de36 <ull_conn_tx_ack+0x36>
	struct ll_conn *conn = NULL;
 100de20:	2600      	movs	r6, #0
		pdu_tx->ll_id = PDU_DATA_LLID_RESV;
 100de22:	f36f 0301 	bfc	r3, #0, #2
 100de26:	7123      	strb	r3, [r4, #4]
	ll_tx_ack_put(handle, tx);
 100de28:	4621      	mov	r1, r4
 100de2a:	4628      	mov	r0, r5
 100de2c:	f7fc f9ec 	bl	100a208 <ll_tx_ack_put>
}
 100de30:	4630      	mov	r0, r6
 100de32:	b003      	add	sp, #12
 100de34:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100de36:	462a      	mov	r2, r5
 100de38:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100de3c:	48b9      	ldr	r0, [pc, #740]	; (100e124 <ull_conn_tx_ack+0x324>)
 100de3e:	f7f7 ff9d 	bl	1005d7c <mem_get>
 100de42:	4606      	mov	r6, r0
 100de44:	e7f0      	b.n	100de28 <ull_conn_tx_ack+0x28>
		if (handle != 0xFFFF) {
 100de46:	f64f 73ff 	movw	r3, #65535	; 0xffff
 100de4a:	429d      	cmp	r5, r3
 100de4c:	d111      	bne.n	100de72 <ull_conn_tx_ack+0x72>
	struct ll_conn *conn = NULL;
 100de4e:	2600      	movs	r6, #0
		if (link->next == (void *)tx) {
 100de50:	6838      	ldr	r0, [r7, #0]
 100de52:	4284      	cmp	r4, r0
 100de54:	d07d      	beq.n	100df52 <ull_conn_tx_ack+0x152>
			LL_ASSERT(!link->next);
 100de56:	2800      	cmp	r0, #0
 100de58:	d0e6      	beq.n	100de28 <ull_conn_tx_ack+0x28>
 100de5a:	f240 51c3 	movw	r1, #1475	; 0x5c3
 100de5e:	48b2      	ldr	r0, [pc, #712]	; (100e128 <ull_conn_tx_ack+0x328>)
 100de60:	f7f5 fc0e 	bl	1003680 <bt_ctlr_assert_handle>
 100de64:	e7e0      	b.n	100de28 <ull_conn_tx_ack+0x28>
	LL_ASSERT(pdu_tx->len);
 100de66:	f44f 61b6 	mov.w	r1, #1456	; 0x5b0
 100de6a:	48af      	ldr	r0, [pc, #700]	; (100e128 <ull_conn_tx_ack+0x328>)
 100de6c:	f7f5 fc08 	bl	1003680 <bt_ctlr_assert_handle>
 100de70:	e7cd      	b.n	100de0e <ull_conn_tx_ack+0xe>
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100de72:	462a      	mov	r2, r5
 100de74:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100de78:	48aa      	ldr	r0, [pc, #680]	; (100e124 <ull_conn_tx_ack+0x324>)
 100de7a:	f7f7 ff7f 	bl	1005d7c <mem_get>
 100de7e:	79e3      	ldrb	r3, [r4, #7]
 100de80:	4606      	mov	r6, r0
	switch (pdu_tx->llctrl.opcode) {
 100de82:	3b02      	subs	r3, #2
 100de84:	2b16      	cmp	r3, #22
 100de86:	d868      	bhi.n	100df5a <ull_conn_tx_ack+0x15a>
 100de88:	e8df f013 	tbh	[pc, r3, lsl #1]
 100de8c:	00d400f0 	.word	0x00d400f0
 100de90:	00670095 	.word	0x00670095
 100de94:	00670067 	.word	0x00670067
 100de98:	00670067 	.word	0x00670067
 100de9c:	001700c3 	.word	0x001700c3
 100dea0:	00a00067 	.word	0x00a00067
 100dea4:	00670067 	.word	0x00670067
 100dea8:	009c0067 	.word	0x009c0067
 100deac:	00670067 	.word	0x00670067
 100deb0:	00f700aa 	.word	0x00f700aa
 100deb4:	0074006d 	.word	0x0074006d
 100deb8:	00b2      	.short	0x00b2
		if (!conn->lll.role) {
 100deba:	f990 303d 	ldrsb.w	r3, [r0, #61]	; 0x3d
 100debe:	2b00      	cmp	r3, #0
 100dec0:	db79      	blt.n	100dfb6 <ull_conn_tx_ack+0x1b6>
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
 100dec2:	2203      	movs	r2, #3
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100dec4:	7923      	ldrb	r3, [r4, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_req) +
 100dec6:	2117      	movs	r1, #23
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100dec8:	4313      	orrs	r3, r2
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
 100deca:	71e2      	strb	r2, [r4, #7]
	memcpy(&pdu_ctrl_tx->llctrl.enc_req.rand[0], &conn->llcp_enc.rand[0],
 100decc:	2208      	movs	r2, #8
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_req) +
 100dece:	7161      	strb	r1, [r4, #5]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100ded0:	7123      	strb	r3, [r4, #4]
	memcpy(&pdu_ctrl_tx->llctrl.enc_req.rand[0], &conn->llcp_enc.rand[0],
 100ded2:	f200 1155 	addw	r1, r0, #341	; 0x155
 100ded6:	18a0      	adds	r0, r4, r2
 100ded8:	f008 fd9e 	bl	1016a18 <memcpy>
	pdu_ctrl_tx->llctrl.enc_req.ediv[0] = conn->llcp_enc.ediv[0];
 100dedc:	f896 3153 	ldrb.w	r3, [r6, #339]	; 0x153
	lll_trng_isr_get(pdu_ctrl_tx->llctrl.enc_req.skdm,
 100dee0:	210c      	movs	r1, #12
	pdu_ctrl_tx->llctrl.enc_req.ediv[0] = conn->llcp_enc.ediv[0];
 100dee2:	7423      	strb	r3, [r4, #16]
	pdu_ctrl_tx->llctrl.enc_req.ediv[1] = conn->llcp_enc.ediv[1];
 100dee4:	f896 3154 	ldrb.w	r3, [r6, #340]	; 0x154
	lll_trng_isr_get(pdu_ctrl_tx->llctrl.enc_req.skdm,
 100dee8:	f104 0012 	add.w	r0, r4, #18
	pdu_ctrl_tx->llctrl.enc_req.ediv[1] = conn->llcp_enc.ediv[1];
 100deec:	7463      	strb	r3, [r4, #17]
	lll_trng_isr_get(pdu_ctrl_tx->llctrl.enc_req.skdm,
 100deee:	f001 fffd 	bl	100feec <lll_trng_isr_get>
	    conn->tx_head &&
 100def2:	f8d6 31b0 	ldr.w	r3, [r6, #432]	; 0x1b0
	if (
 100def6:	2b00      	cmp	r3, #0
 100def8:	f000 80e6 	beq.w	100e0c8 <ull_conn_tx_ack+0x2c8>
	    !conn->llcp_enc.pause_tx &&
 100defc:	f896 2152 	ldrb.w	r2, [r6, #338]	; 0x152
	    conn->tx_head &&
 100df00:	0791      	lsls	r1, r2, #30
 100df02:	f100 80e1 	bmi.w	100e0c8 <ull_conn_tx_ack+0x2c8>
	    !conn->llcp_phy.pause_tx &&
 100df06:	f896 21ab 	ldrb.w	r2, [r6, #427]	; 0x1ab
 100df0a:	07d2      	lsls	r2, r2, #31
 100df0c:	f100 80dc 	bmi.w	100e0c8 <ull_conn_tx_ack+0x2c8>
		if (conn->tx_head == conn->tx_data) {
 100df10:	f8d6 21bc 	ldr.w	r2, [r6, #444]	; 0x1bc
 100df14:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 100df16:	bf04      	itt	eq
 100df18:	681a      	ldreq	r2, [r3, #0]
 100df1a:	f8c6 21bc 	streq.w	r2, [r6, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 100df1e:	f8d6 21b4 	ldr.w	r2, [r6, #436]	; 0x1b4
 100df22:	2a00      	cmp	r2, #0
 100df24:	f000 80f6 	beq.w	100e114 <ull_conn_tx_ack+0x314>
	tx->next = conn->tx_ctrl_last->next;
 100df28:	f8d6 31b8 	ldr.w	r3, [r6, #440]	; 0x1b8
 100df2c:	681a      	ldr	r2, [r3, #0]
 100df2e:	6022      	str	r2, [r4, #0]
	conn->tx_ctrl_last->next = tx;
 100df30:	601c      	str	r4, [r3, #0]
	conn->tx_ctrl_last = tx;
 100df32:	f8c6 41b8 	str.w	r4, [r6, #440]	; 0x1b8
 100df36:	6823      	ldr	r3, [r4, #0]
	if (!tx->next) {
 100df38:	2b00      	cmp	r3, #0
 100df3a:	f000 80d0 	beq.w	100e0de <ull_conn_tx_ack+0x2de>
		if (link->next == (void *)tx) {
 100df3e:	683b      	ldr	r3, [r7, #0]
 100df40:	2b00      	cmp	r3, #0
 100df42:	f47f af75 	bne.w	100de30 <ull_conn_tx_ack+0x30>
			LL_ASSERT(link->next);
 100df46:	4878      	ldr	r0, [pc, #480]	; (100e128 <ull_conn_tx_ack+0x328>)
 100df48:	f240 51bc 	movw	r1, #1468	; 0x5bc
 100df4c:	f7f5 fb98 	bl	1003680 <bt_ctlr_assert_handle>
 100df50:	2000      	movs	r0, #0
			mem_release(tx, &mem_conn_tx_ctrl.free);
 100df52:	4976      	ldr	r1, [pc, #472]	; (100e12c <ull_conn_tx_ack+0x32c>)
 100df54:	f7f7 fefa 	bl	1005d4c <mem_release>
			return conn;
 100df58:	e76a      	b.n	100de30 <ull_conn_tx_ack+0x30>
		if (link->next == (void *)tx) {
 100df5a:	6838      	ldr	r0, [r7, #0]
 100df5c:	42a0      	cmp	r0, r4
 100df5e:	f47f af7a 	bne.w	100de56 <ull_conn_tx_ack+0x56>
 100df62:	4620      	mov	r0, r4
 100df64:	e7f5      	b.n	100df52 <ull_conn_tx_ack+0x152>
		conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
 100df66:	2202      	movs	r2, #2
 100df68:	f890 31aa 	ldrb.w	r3, [r0, #426]	; 0x1aa
 100df6c:	f362 0301 	bfi	r3, r2, #0, #2
 100df70:	f880 31aa 	strb.w	r3, [r0, #426]	; 0x1aa
		if (conn->lll.role) {
 100df74:	f996 303d 	ldrsb.w	r3, [r6, #61]	; 0x3d
 100df78:	2b00      	cmp	r3, #0
 100df7a:	da15      	bge.n	100dfa8 <ull_conn_tx_ack+0x1a8>
			phys = conn->llcp_phy.tx | lll->phy_tx;
 100df7c:	f896 3064 	ldrb.w	r3, [r6, #100]	; 0x64
 100df80:	f896 01aa 	ldrb.w	r0, [r6, #426]	; 0x1aa
			lll->phy_tx_time = phy_tx_time[phys];
 100df84:	461a      	mov	r2, r3
			u8_t phy_tx_time[8] = {BIT(0), BIT(0), BIT(1), BIT(0),
 100df86:	496a      	ldr	r1, [pc, #424]	; (100e130 <ull_conn_tx_ack+0x330>)
 100df88:	f10d 0c08 	add.w	ip, sp, #8
			phys = conn->llcp_phy.tx | lll->phy_tx;
 100df8c:	ea43 0390 	orr.w	r3, r3, r0, lsr #2
			u8_t phy_tx_time[8] = {BIT(0), BIT(0), BIT(1), BIT(0),
 100df90:	c903      	ldmia	r1, {r0, r1}
 100df92:	e90c 0003 	stmdb	ip, {r0, r1}
			lll->phy_tx_time = phy_tx_time[phys];
 100df96:	f003 0307 	and.w	r3, r3, #7
 100df9a:	4463      	add	r3, ip
 100df9c:	f813 3c08 	ldrb.w	r3, [r3, #-8]
 100dfa0:	f363 1206 	bfi	r2, r3, #4, #3
 100dfa4:	f886 2064 	strb.w	r2, [r6, #100]	; 0x64
		conn->llcp_phy.pause_tx = 0U;
 100dfa8:	f896 31ab 	ldrb.w	r3, [r6, #427]	; 0x1ab
 100dfac:	f36f 0300 	bfc	r3, #0, #1
 100dfb0:	f886 31ab 	strb.w	r3, [r6, #427]	; 0x1ab
		break;
 100dfb4:	e74c      	b.n	100de50 <ull_conn_tx_ack+0x50>
			conn->llcp_enc.pause_tx = 1U;
 100dfb6:	f896 3152 	ldrb.w	r3, [r6, #338]	; 0x152
 100dfba:	f043 0302 	orr.w	r3, r3, #2
 100dfbe:	f886 3152 	strb.w	r3, [r6, #338]	; 0x152
 100dfc2:	e745      	b.n	100de50 <ull_conn_tx_ack+0x50>
		if (pdu_tx->llctrl.reject_ext_ind.reject_opcode !=
 100dfc4:	7a23      	ldrb	r3, [r4, #8]
 100dfc6:	2b03      	cmp	r3, #3
 100dfc8:	f47f af42 	bne.w	100de50 <ull_conn_tx_ack+0x50>
		conn->procedure_expire = 0U;
 100dfcc:	2200      	movs	r2, #0
		conn->llcp_enc.pause_rx = 0U;
 100dfce:	f896 3152 	ldrb.w	r3, [r6, #338]	; 0x152
		conn->procedure_expire = 0U;
 100dfd2:	f8a6 20cc 	strh.w	r2, [r6, #204]	; 0xcc
		conn->llcp_enc.pause_rx = 0U;
 100dfd6:	f023 0303 	bic.w	r3, r3, #3
 100dfda:	f886 3152 	strb.w	r3, [r6, #338]	; 0x152
		break;
 100dfde:	e737      	b.n	100de50 <ull_conn_tx_ack+0x50>
		conn->llcp_length.state = LLCP_LENGTH_STATE_RSP_WAIT;
 100dfe0:	2202      	movs	r2, #2
 100dfe2:	f890 319a 	ldrb.w	r3, [r0, #410]	; 0x19a
 100dfe6:	f362 0302 	bfi	r3, r2, #0, #3
 100dfea:	f880 319a 	strb.w	r3, [r0, #410]	; 0x19a
		break;
 100dfee:	e72f      	b.n	100de50 <ull_conn_tx_ack+0x50>
		conn->lll.phy_tx_time = conn->llcp.phy_upd_ind.tx;
 100dff0:	f890 30ec 	ldrb.w	r3, [r0, #236]	; 0xec
 100dff4:	f890 1064 	ldrb.w	r1, [r0, #100]	; 0x64
		conn->llcp_phy.pause_tx = 0U;
 100dff8:	f890 21ab 	ldrb.w	r2, [r0, #427]	; 0x1ab
		conn->lll.phy_tx_time = conn->llcp.phy_upd_ind.tx;
 100dffc:	f3c3 0382 	ubfx	r3, r3, #2, #3
 100e000:	f363 1106 	bfi	r1, r3, #4, #3
		conn->llcp_phy.pause_tx = 0U;
 100e004:	f36f 0200 	bfc	r2, #0, #1
		conn->lll.phy_tx_time = conn->llcp.phy_upd_ind.tx;
 100e008:	f880 1064 	strb.w	r1, [r0, #100]	; 0x64
		conn->llcp_phy.pause_tx = 0U;
 100e00c:	f880 21ab 	strb.w	r2, [r0, #427]	; 0x1ab
		break;
 100e010:	e71e      	b.n	100de50 <ull_conn_tx_ack+0x50>
		conn->llcp_enc.pause_tx = 1U;
 100e012:	f890 3152 	ldrb.w	r3, [r0, #338]	; 0x152
		conn->procedure_expire = conn->procedure_reload;
 100e016:	f8b0 20ca 	ldrh.w	r2, [r0, #202]	; 0xca
		conn->llcp_enc.pause_tx = 1U;
 100e01a:	f023 0306 	bic.w	r3, r3, #6
 100e01e:	f043 0306 	orr.w	r3, r3, #6
 100e022:	f880 3152 	strb.w	r3, [r0, #338]	; 0x152
		conn->llcp_enc.ack = conn->llcp_enc.req;
 100e026:	f890 3150 	ldrb.w	r3, [r0, #336]	; 0x150
		conn->procedure_expire = conn->procedure_reload;
 100e02a:	f8a0 20cc 	strh.w	r2, [r0, #204]	; 0xcc
		conn->llcp_enc.ack = conn->llcp_enc.req;
 100e02e:	f880 3151 	strb.w	r3, [r0, #337]	; 0x151
		break;
 100e032:	e70d      	b.n	100de50 <ull_conn_tx_ack+0x50>
		memcpy(&conn->llcp.encryption.skd[0],
 100e034:	2208      	movs	r2, #8
 100e036:	f104 0112 	add.w	r1, r4, #18
 100e03a:	30ee      	adds	r0, #238	; 0xee
 100e03c:	f008 fcec 	bl	1016a18 <memcpy>
		memcpy(&conn->lll.ccm_rx.iv[0],
 100e040:	2204      	movs	r2, #4
 100e042:	f104 011a 	add.w	r1, r4, #26
 100e046:	f106 0098 	add.w	r0, r6, #152	; 0x98
 100e04a:	f008 fce5 	bl	1016a18 <memcpy>
		conn->llcp_enc.pause_tx = 1U;
 100e04e:	f896 3152 	ldrb.w	r3, [r6, #338]	; 0x152
		conn->procedure_expire = conn->procedure_reload;
 100e052:	f8b6 10ca 	ldrh.w	r1, [r6, #202]	; 0xca
		conn->llcp_enc.ack = conn->llcp_enc.req;
 100e056:	f896 2150 	ldrb.w	r2, [r6, #336]	; 0x150
		conn->llcp_enc.pause_tx = 1U;
 100e05a:	f043 0302 	orr.w	r3, r3, #2
 100e05e:	f886 3152 	strb.w	r3, [r6, #338]	; 0x152
		conn->procedure_expire = conn->procedure_reload;
 100e062:	f8a6 10cc 	strh.w	r1, [r6, #204]	; 0xcc
		conn->llcp_enc.ack = conn->llcp_enc.req;
 100e066:	f886 2151 	strb.w	r2, [r6, #337]	; 0x151
		break;
 100e06a:	e6f1      	b.n	100de50 <ull_conn_tx_ack+0x50>
		u8_t reason = (pdu_tx->llctrl.terminate_ind.error_code ==
 100e06c:	7a21      	ldrb	r1, [r4, #8]
 100e06e:	2913      	cmp	r1, #19
		conn_cleanup(conn, reason);
 100e070:	bf08      	it	eq
 100e072:	2116      	moveq	r1, #22
 100e074:	f7ff fb68 	bl	100d748 <conn_cleanup>
	break;
 100e078:	e6ea      	b.n	100de50 <ull_conn_tx_ack+0x50>
		if (conn->llcp_length.req != conn->llcp_length.ack) {
 100e07a:	f890 1198 	ldrb.w	r1, [r0, #408]	; 0x198
 100e07e:	f890 3199 	ldrb.w	r3, [r0, #409]	; 0x199
 100e082:	428b      	cmp	r3, r1
 100e084:	f43f aee4 	beq.w	100de50 <ull_conn_tx_ack+0x50>
			switch (conn->llcp_length.state) {
 100e088:	f890 219a 	ldrb.w	r2, [r0, #410]	; 0x19a
 100e08c:	f002 0307 	and.w	r3, r2, #7
 100e090:	2b03      	cmp	r3, #3
 100e092:	d005      	beq.n	100e0a0 <ull_conn_tx_ack+0x2a0>
 100e094:	3303      	adds	r3, #3
 100e096:	f003 0307 	and.w	r3, r3, #7
 100e09a:	2b01      	cmp	r3, #1
 100e09c:	f63f af5d 	bhi.w	100df5a <ull_conn_tx_ack+0x15a>
				conn->lll.max_tx_octets =
 100e0a0:	f8b6 319e 	ldrh.w	r3, [r6, #414]	; 0x19e
				conn->lll.max_tx_time =
 100e0a4:	f8b6 01a2 	ldrh.w	r0, [r6, #418]	; 0x1a2
				conn->lll.max_tx_octets =
 100e0a8:	f8a6 305c 	strh.w	r3, [r6, #92]	; 0x5c
				if (conn->llcp_length.state ==
 100e0ac:	f002 0307 	and.w	r3, r2, #7
 100e0b0:	2b05      	cmp	r3, #5
				conn->lll.max_tx_time =
 100e0b2:	f8a6 0060 	strh.w	r0, [r6, #96]	; 0x60
				if (conn->llcp_length.state ==
 100e0b6:	d027      	beq.n	100e108 <ull_conn_tx_ack+0x308>
				if (!conn->llcp_length.cache.tx_octets) {
 100e0b8:	f8b6 31a4 	ldrh.w	r3, [r6, #420]	; 0x1a4
 100e0bc:	b9b3      	cbnz	r3, 100e0ec <ull_conn_tx_ack+0x2ec>
					conn->llcp_length.ack =
 100e0be:	f886 1199 	strb.w	r1, [r6, #409]	; 0x199
					conn->procedure_expire = 0U;
 100e0c2:	f8a6 30cc 	strh.w	r3, [r6, #204]	; 0xcc
					break;
 100e0c6:	e6c3      	b.n	100de50 <ull_conn_tx_ack+0x50>
		if (!conn->tx_ctrl) {
 100e0c8:	f8d6 21b4 	ldr.w	r2, [r6, #436]	; 0x1b4
 100e0cc:	2a00      	cmp	r2, #0
 100e0ce:	f47f af2b 	bne.w	100df28 <ull_conn_tx_ack+0x128>
			tx->next = conn->tx_head;
 100e0d2:	6023      	str	r3, [r4, #0]
				conn->tx_ctrl = tx;
 100e0d4:	e9c6 446c 	strd	r4, r4, [r6, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 100e0d8:	f8c6 41b8 	str.w	r4, [r6, #440]	; 0x1b8
 100e0dc:	e72c      	b.n	100df38 <ull_conn_tx_ack+0x138>
		if (link->next == (void *)tx) {
 100e0de:	683b      	ldr	r3, [r7, #0]
		conn->tx_data_last = tx;
 100e0e0:	f8c6 41c0 	str.w	r4, [r6, #448]	; 0x1c0
		if (link->next == (void *)tx) {
 100e0e4:	2b00      	cmp	r3, #0
 100e0e6:	f47f aea3 	bne.w	100de30 <ull_conn_tx_ack+0x30>
 100e0ea:	e72c      	b.n	100df46 <ull_conn_tx_ack+0x146>
				conn->llcp_length.cache.tx_octets = 0;
 100e0ec:	2100      	movs	r1, #0
				conn->llcp_length.tx_octets =
 100e0ee:	f8a6 319e 	strh.w	r3, [r6, #414]	; 0x19e
				conn->llcp_length.tx_time =
 100e0f2:	f8b6 31a6 	ldrh.w	r3, [r6, #422]	; 0x1a6
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
 100e0f6:	f361 0202 	bfi	r2, r1, #0, #3
 100e0fa:	f886 219a 	strb.w	r2, [r6, #410]	; 0x19a
				conn->llcp_length.cache.tx_octets = 0;
 100e0fe:	f8a6 11a4 	strh.w	r1, [r6, #420]	; 0x1a4
				conn->llcp_length.tx_time =
 100e102:	f8a6 31a2 	strh.w	r3, [r6, #418]	; 0x1a2
				break;
 100e106:	e6a3      	b.n	100de50 <ull_conn_tx_ack+0x50>
					conn->llcp_length.state =
 100e108:	2304      	movs	r3, #4
 100e10a:	f363 0202 	bfi	r2, r3, #0, #3
 100e10e:	f886 219a 	strb.w	r2, [r6, #410]	; 0x19a
					break;
 100e112:	e69d      	b.n	100de50 <ull_conn_tx_ack+0x50>
			tx->next = conn->tx_head->next;
 100e114:	681a      	ldr	r2, [r3, #0]
 100e116:	6022      	str	r2, [r4, #0]
			conn->tx_head->next = tx;
 100e118:	601c      	str	r4, [r3, #0]
				conn->tx_ctrl = tx;
 100e11a:	6823      	ldr	r3, [r4, #0]
				conn->tx_ctrl_last = tx;
 100e11c:	e9c6 446d 	strd	r4, r4, [r6, #436]	; 0x1b4
 100e120:	e70a      	b.n	100df38 <ull_conn_tx_ack+0x138>
 100e122:	bf00      	nop
 100e124:	21002bd0 	.word	0x21002bd0
 100e128:	01018934 	.word	0x01018934
 100e12c:	21005288 	.word	0x21005288
 100e130:	01018974 	.word	0x01018974

0100e134 <ull_conn_llcp_req>:
	if (conn_hdr->llcp_req != conn_hdr->llcp_ack) {
 100e134:	f890 30e9 	ldrb.w	r3, [r0, #233]	; 0xe9
 100e138:	f890 20e8 	ldrb.w	r2, [r0, #232]	; 0xe8
 100e13c:	4293      	cmp	r3, r2
	conn_hdr->llcp_req++;
 100e13e:	bf03      	ittte	eq
 100e140:	3301      	addeq	r3, #1
 100e142:	f880 30e8 	strbeq.w	r3, [r0, #232]	; 0xe8
	return 0;
 100e146:	2000      	moveq	r0, #0
		return BT_HCI_ERR_CMD_DISALLOWED;
 100e148:	200c      	movne	r0, #12
}
 100e14a:	4770      	bx	lr

0100e14c <ull_conn_lll_max_tx_octets_get>:
	switch (lll->phy_tx_time) {
 100e14c:	f890 2048 	ldrb.w	r2, [r0, #72]	; 0x48
 100e150:	f3c2 1302 	ubfx	r3, r2, #4, #3
 100e154:	2b02      	cmp	r3, #2
 100e156:	d012      	beq.n	100e17e <ull_conn_lll_max_tx_octets_get+0x32>
 100e158:	2b04      	cmp	r3, #4
		max_tx_octets = (lll->max_tx_time >> 3) - 10;
 100e15a:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
	switch (lll->phy_tx_time) {
 100e15e:	d014      	beq.n	100e18a <ull_conn_lll_max_tx_octets_get+0x3e>
		max_tx_octets = (lll->max_tx_time >> 3) - 10;
 100e160:	08db      	lsrs	r3, r3, #3
 100e162:	3b0a      	subs	r3, #10
 100e164:	b29b      	uxth	r3, r3
	if (lll->enc_tx) {
 100e166:	f890 2062 	ldrb.w	r2, [r0, #98]	; 0x62
	return max_tx_octets;
 100e16a:	f8b0 0040 	ldrh.w	r0, [r0, #64]	; 0x40
	if (lll->enc_tx) {
 100e16e:	06d2      	lsls	r2, r2, #27
		max_tx_octets -= 4U;
 100e170:	bf44      	itt	mi
 100e172:	3b04      	submi	r3, #4
 100e174:	b29b      	uxthmi	r3, r3
}
 100e176:	4298      	cmp	r0, r3
 100e178:	bf28      	it	cs
 100e17a:	4618      	movcs	r0, r3
 100e17c:	4770      	bx	lr
		max_tx_octets = (lll->max_tx_time >> 2) - 11;
 100e17e:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 100e182:	089b      	lsrs	r3, r3, #2
 100e184:	3b0b      	subs	r3, #11
 100e186:	b29b      	uxth	r3, r3
		break;
 100e188:	e7ed      	b.n	100e166 <ull_conn_lll_max_tx_octets_get+0x1a>
		if (lll->phy_flags & 0x01) {
 100e18a:	0711      	lsls	r1, r2, #28
			max_tx_octets = ((lll->max_tx_time - 592) >>
 100e18c:	bf4b      	itete	mi
 100e18e:	f5a3 7314 	submi.w	r3, r3, #592	; 0x250
			max_tx_octets = ((lll->max_tx_time - 430) >>
 100e192:	f5a3 73d7 	subpl.w	r3, r3, #430	; 0x1ae
			max_tx_octets = ((lll->max_tx_time - 592) >>
 100e196:	119b      	asrmi	r3, r3, #6
			max_tx_octets = ((lll->max_tx_time - 430) >>
 100e198:	111b      	asrpl	r3, r3, #4
					  4) - 2;
 100e19a:	3b02      	subs	r3, #2
			max_tx_octets = ((lll->max_tx_time - 430) >>
 100e19c:	b29b      	uxth	r3, r3
 100e19e:	e7e2      	b.n	100e166 <ull_conn_lll_max_tx_octets_get+0x1a>

0100e1a0 <ticker_op_cb>:

static void ticker_op_cb(u32_t status, void *param)
{
	ARG_UNUSED(param);

	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 100e1a0:	b900      	cbnz	r0, 100e1a4 <ticker_op_cb+0x4>
}
 100e1a2:	4770      	bx	lr
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 100e1a4:	f44f 71e2 	mov.w	r1, #452	; 0x1c4
 100e1a8:	4801      	ldr	r0, [pc, #4]	; (100e1b0 <ticker_op_cb+0x10>)
 100e1aa:	f7f5 ba69 	b.w	1003680 <bt_ctlr_assert_handle>
 100e1ae:	bf00      	nop
 100e1b0:	01018994 	.word	0x01018994

0100e1b4 <ull_slave_ticker_cb>:
{
 100e1b4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100e1b8:	4605      	mov	r5, r0
 100e1ba:	4688      	mov	r8, r1
		ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
 100e1bc:	4601      	mov	r1, r0
 100e1be:	4618      	mov	r0, r3
{
 100e1c0:	461c      	mov	r4, r3
 100e1c2:	4617      	mov	r7, r2
		ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
 100e1c4:	f7f2 fd0c 	bl	1000be0 <ull_conn_llcp>
		if (ret) {
 100e1c8:	bb48      	cbnz	r0, 100e21e <ull_slave_ticker_cb+0x6a>
 100e1ca:	7c23      	ldrb	r3, [r4, #16]
 100e1cc:	3301      	adds	r3, #1
 100e1ce:	b2db      	uxtb	r3, r3
 100e1d0:	7423      	strb	r3, [r4, #16]
	LL_ASSERT(ref);
 100e1d2:	b1f3      	cbz	r3, 100e212 <ull_slave_ticker_cb+0x5e>
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100e1d4:	2200      	movs	r2, #0
	p.ticks_at_expire = ticks_at_expire;
 100e1d6:	4e13      	ldr	r6, [pc, #76]	; (100e224 <ull_slave_ticker_cb+0x70>)
	mfy.param = &p;
 100e1d8:	4b13      	ldr	r3, [pc, #76]	; (100e228 <ull_slave_ticker_cb+0x74>)
	p.param = &conn->lll;
 100e1da:	f104 0c1c 	add.w	ip, r4, #28
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100e1de:	4611      	mov	r1, r2
 100e1e0:	2001      	movs	r0, #1
	p.remainder = remainder;
 100e1e2:	e9c6 5800 	strd	r5, r8, [r6]
	mfy.param = &p;
 100e1e6:	609e      	str	r6, [r3, #8]
	p.lazy = lazy;
 100e1e8:	8137      	strh	r7, [r6, #8]
	p.param = &conn->lll;
 100e1ea:	f8c6 c00c 	str.w	ip, [r6, #12]
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100e1ee:	f7f7 fe6b 	bl	1005ec8 <mayfly_enqueue>
	LL_ASSERT(!err);
 100e1f2:	b940      	cbnz	r0, 100e206 <ull_slave_ticker_cb+0x52>
	ull_conn_tx_demux(UINT8_MAX);
 100e1f4:	20ff      	movs	r0, #255	; 0xff
 100e1f6:	f7ff fa25 	bl	100d644 <ull_conn_tx_demux>
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
 100e1fa:	4620      	mov	r0, r4
}
 100e1fc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
 100e200:	21ff      	movs	r1, #255	; 0xff
 100e202:	f7ff bc9d 	b.w	100db40 <ull_conn_tx_lll_enqueue>
	LL_ASSERT(!err);
 100e206:	f44f 71c0 	mov.w	r1, #384	; 0x180
 100e20a:	4808      	ldr	r0, [pc, #32]	; (100e22c <ull_slave_ticker_cb+0x78>)
 100e20c:	f7f5 fa38 	bl	1003680 <bt_ctlr_assert_handle>
 100e210:	e7f0      	b.n	100e1f4 <ull_slave_ticker_cb+0x40>
	LL_ASSERT(ref);
 100e212:	f44f 71ba 	mov.w	r1, #372	; 0x174
 100e216:	4805      	ldr	r0, [pc, #20]	; (100e22c <ull_slave_ticker_cb+0x78>)
 100e218:	f7f5 fa32 	bl	1003680 <bt_ctlr_assert_handle>
 100e21c:	e7da      	b.n	100e1d4 <ull_slave_ticker_cb+0x20>
}
 100e21e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 100e222:	bf00      	nop
 100e224:	21005398 	.word	0x21005398
 100e228:	21000424 	.word	0x21000424
 100e22c:	01018994 	.word	0x01018994

0100e230 <ticker_op_stop_adv_cb>:
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
 100e230:	2801      	cmp	r0, #1
 100e232:	d000      	beq.n	100e236 <ticker_op_stop_adv_cb+0x6>
 100e234:	4770      	bx	lr
{
 100e236:	b510      	push	{r4, lr}
 100e238:	460c      	mov	r4, r1
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
 100e23a:	f7fc f835 	bl	100a2a8 <ull_disable_mark_get>
 100e23e:	4284      	cmp	r4, r0
 100e240:	d006      	beq.n	100e250 <ticker_op_stop_adv_cb+0x20>
}
 100e242:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
 100e246:	f44f 71de 	mov.w	r1, #444	; 0x1bc
 100e24a:	4802      	ldr	r0, [pc, #8]	; (100e254 <ticker_op_stop_adv_cb+0x24>)
 100e24c:	f7f5 ba18 	b.w	1003680 <bt_ctlr_assert_handle>
}
 100e250:	bd10      	pop	{r4, pc}
 100e252:	bf00      	nop
 100e254:	01018994 	.word	0x01018994

0100e258 <ll_start_enc_req_send>:
{
 100e258:	b570      	push	{r4, r5, r6, lr}
 100e25a:	460e      	mov	r6, r1
 100e25c:	4615      	mov	r5, r2
	conn = ll_connected_get(handle);
 100e25e:	f7fd fa39 	bl	100b6d4 <ll_connected_get>
	if (!conn) {
 100e262:	2800      	cmp	r0, #0
 100e264:	d040      	beq.n	100e2e8 <ll_start_enc_req_send+0x90>
	if (error_code) {
 100e266:	4604      	mov	r4, r0
 100e268:	b95e      	cbnz	r6, 100e282 <ll_start_enc_req_send+0x2a>
		if ((conn->llcp_req == conn->llcp_ack) ||
 100e26a:	f890 20e8 	ldrb.w	r2, [r0, #232]	; 0xe8
 100e26e:	f890 30e9 	ldrb.w	r3, [r0, #233]	; 0xe9
 100e272:	429a      	cmp	r2, r3
 100e274:	d003      	beq.n	100e27e <ll_start_enc_req_send+0x26>
 100e276:	f890 30ea 	ldrb.w	r3, [r0, #234]	; 0xea
 100e27a:	2b03      	cmp	r3, #3
 100e27c:	d026      	beq.n	100e2cc <ll_start_enc_req_send+0x74>
				return BT_HCI_ERR_CMD_DISALLOWED;
 100e27e:	200c      	movs	r0, #12
}
 100e280:	bd70      	pop	{r4, r5, r6, pc}
		if (conn->llcp_enc.refresh == 0U) {
 100e282:	f890 0152 	ldrb.w	r0, [r0, #338]	; 0x152
 100e286:	f010 0004 	ands.w	r0, r0, #4
 100e28a:	d112      	bne.n	100e2b2 <ll_start_enc_req_send+0x5a>
			if ((conn->llcp_req == conn->llcp_ack) ||
 100e28c:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
 100e290:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
 100e294:	429a      	cmp	r2, r3
 100e296:	d0f2      	beq.n	100e27e <ll_start_enc_req_send+0x26>
 100e298:	f894 30ea 	ldrb.w	r3, [r4, #234]	; 0xea
 100e29c:	2b03      	cmp	r3, #3
 100e29e:	d1ee      	bne.n	100e27e <ll_start_enc_req_send+0x26>
			conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
 100e2a0:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
			conn->llcp.encryption.error_code = error_code;
 100e2a4:	f884 60ed 	strb.w	r6, [r4, #237]	; 0xed
			conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
 100e2a8:	f360 0301 	bfi	r3, r0, #0, #2
 100e2ac:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
}
 100e2b0:	bd70      	pop	{r4, r5, r6, pc}
			    conn->llcp_terminate.req) {
 100e2b2:	f894 2128 	ldrb.w	r2, [r4, #296]	; 0x128
			if (conn->llcp_terminate.ack !=
 100e2b6:	f894 3129 	ldrb.w	r3, [r4, #297]	; 0x129
 100e2ba:	4293      	cmp	r3, r2
 100e2bc:	d1df      	bne.n	100e27e <ll_start_enc_req_send+0x26>
			conn->llcp_terminate.req++;
 100e2be:	3301      	adds	r3, #1
 100e2c0:	f884 3128 	strb.w	r3, [r4, #296]	; 0x128
			conn->llcp_terminate.reason_own = error_code;
 100e2c4:	f884 612a 	strb.w	r6, [r4, #298]	; 0x12a
	return 0;
 100e2c8:	2000      	movs	r0, #0
}
 100e2ca:	bd70      	pop	{r4, r5, r6, pc}
		memcpy(&conn->llcp_enc.ltk[0], ltk,
 100e2cc:	4629      	mov	r1, r5
 100e2ce:	2210      	movs	r2, #16
 100e2d0:	f200 105d 	addw	r0, r0, #349	; 0x15d
 100e2d4:	f008 fba0 	bl	1016a18 <memcpy>
		conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
 100e2d8:	f8b4 30ec 	ldrh.w	r3, [r4, #236]	; 0xec
	return 0;
 100e2dc:	4630      	mov	r0, r6
		conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
 100e2de:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
 100e2e2:	f8a4 30ec 	strh.w	r3, [r4, #236]	; 0xec
}
 100e2e6:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100e2e8:	2002      	movs	r0, #2
}
 100e2ea:	bd70      	pop	{r4, r5, r6, pc}

0100e2ec <ticker_op_stop_scan_cb>:
}

static void ticker_op_stop_scan_cb(u32_t status, void *params)
{
	/* TODO: */
}
 100e2ec:	4770      	bx	lr
 100e2ee:	bf00      	nop

0100e2f0 <ticker_op_cb>:

static void ticker_op_cb(u32_t status, void *params)
{
	ARG_UNUSED(params);

	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 100e2f0:	b900      	cbnz	r0, 100e2f4 <ticker_op_cb+0x4>
}
 100e2f2:	4770      	bx	lr
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 100e2f4:	f240 21b2 	movw	r1, #690	; 0x2b2
 100e2f8:	4801      	ldr	r0, [pc, #4]	; (100e300 <ticker_op_cb+0x10>)
 100e2fa:	f7f5 b9c1 	b.w	1003680 <bt_ctlr_assert_handle>
 100e2fe:	bf00      	nop
 100e300:	010189ec 	.word	0x010189ec

0100e304 <ull_master_ticker_cb>:
{
 100e304:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100e308:	4605      	mov	r5, r0
 100e30a:	4688      	mov	r8, r1
		ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
 100e30c:	4601      	mov	r1, r0
 100e30e:	4618      	mov	r0, r3
{
 100e310:	461c      	mov	r4, r3
 100e312:	4617      	mov	r7, r2
		ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
 100e314:	f7f2 fc64 	bl	1000be0 <ull_conn_llcp>
		if (ret) {
 100e318:	bb80      	cbnz	r0, 100e37c <ull_master_ticker_cb+0x78>
 100e31a:	7c23      	ldrb	r3, [r4, #16]
 100e31c:	3301      	adds	r3, #1
 100e31e:	b2db      	uxtb	r3, r3
 100e320:	7423      	strb	r3, [r4, #16]
	LL_ASSERT(ref);
 100e322:	b32b      	cbz	r3, 100e370 <ull_master_ticker_cb+0x6c>
	ull_conn_tx_demux(1);
 100e324:	2001      	movs	r0, #1
 100e326:	f7ff f98d 	bl	100d644 <ull_conn_tx_demux>
	ull_conn_tx_lll_enqueue(conn, 1);
 100e32a:	2101      	movs	r1, #1
 100e32c:	4620      	mov	r0, r4
 100e32e:	f7ff fc07 	bl	100db40 <ull_conn_tx_lll_enqueue>
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100e332:	2200      	movs	r2, #0
	p.ticks_at_expire = ticks_at_expire;
 100e334:	4e12      	ldr	r6, [pc, #72]	; (100e380 <ull_master_ticker_cb+0x7c>)
	mfy.param = &p;
 100e336:	4b13      	ldr	r3, [pc, #76]	; (100e384 <ull_master_ticker_cb+0x80>)
	p.param = &conn->lll;
 100e338:	f104 0c1c 	add.w	ip, r4, #28
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100e33c:	4611      	mov	r1, r2
 100e33e:	2001      	movs	r0, #1
	p.remainder = remainder;
 100e340:	e9c6 5800 	strd	r5, r8, [r6]
	mfy.param = &p;
 100e344:	609e      	str	r6, [r3, #8]
	p.lazy = lazy;
 100e346:	8137      	strh	r7, [r6, #8]
	p.param = &conn->lll;
 100e348:	f8c6 c00c 	str.w	ip, [r6, #12]
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100e34c:	f7f7 fdbc 	bl	1005ec8 <mayfly_enqueue>
	LL_ASSERT(!err);
 100e350:	b940      	cbnz	r0, 100e364 <ull_master_ticker_cb+0x60>
	ull_conn_tx_demux(UINT8_MAX);
 100e352:	20ff      	movs	r0, #255	; 0xff
 100e354:	f7ff f976 	bl	100d644 <ull_conn_tx_demux>
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
 100e358:	4620      	mov	r0, r4
}
 100e35a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
 100e35e:	21ff      	movs	r1, #255	; 0xff
 100e360:	f7ff bbee 	b.w	100db40 <ull_conn_tx_lll_enqueue>
	LL_ASSERT(!err);
 100e364:	f240 219e 	movw	r1, #670	; 0x29e
 100e368:	4807      	ldr	r0, [pc, #28]	; (100e388 <ull_master_ticker_cb+0x84>)
 100e36a:	f7f5 f989 	bl	1003680 <bt_ctlr_assert_handle>
 100e36e:	e7f0      	b.n	100e352 <ull_master_ticker_cb+0x4e>
	LL_ASSERT(ref);
 100e370:	f44f 7123 	mov.w	r1, #652	; 0x28c
 100e374:	4804      	ldr	r0, [pc, #16]	; (100e388 <ull_master_ticker_cb+0x84>)
 100e376:	f7f5 f983 	bl	1003680 <bt_ctlr_assert_handle>
 100e37a:	e7d3      	b.n	100e324 <ull_master_ticker_cb+0x20>
}
 100e37c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 100e380:	210053b0 	.word	0x210053b0
 100e384:	21000434 	.word	0x21000434
 100e388:	010189ec 	.word	0x010189ec

0100e38c <ll_create_connection>:
{
 100e38c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100e390:	b08d      	sub	sp, #52	; 0x34
 100e392:	9306      	str	r3, [sp, #24]
 100e394:	f89d 305c 	ldrb.w	r3, [sp, #92]	; 0x5c
 100e398:	4605      	mov	r5, r0
 100e39a:	9302      	str	r3, [sp, #8]
 100e39c:	f8bd 3060 	ldrh.w	r3, [sp, #96]	; 0x60
	scan = ull_scan_is_disabled_get(0);
 100e3a0:	2000      	movs	r0, #0
{
 100e3a2:	9304      	str	r3, [sp, #16]
 100e3a4:	f8bd 3064 	ldrh.w	r3, [sp, #100]	; 0x64
 100e3a8:	460e      	mov	r6, r1
 100e3aa:	9307      	str	r3, [sp, #28]
 100e3ac:	f8bd 3068 	ldrh.w	r3, [sp, #104]	; 0x68
 100e3b0:	9203      	str	r2, [sp, #12]
 100e3b2:	9305      	str	r3, [sp, #20]
	scan = ull_scan_is_disabled_get(0);
 100e3b4:	f7fc fdd8 	bl	100af68 <ull_scan_is_disabled_get>
	if (!scan) {
 100e3b8:	b128      	cbz	r0, 100e3c6 <ll_create_connection+0x3a>
	if (lll->conn) {
 100e3ba:	f8d0 8024 	ldr.w	r8, [r0, #36]	; 0x24
 100e3be:	4607      	mov	r7, r0
 100e3c0:	f1b8 0f00 	cmp.w	r8, #0
 100e3c4:	d003      	beq.n	100e3ce <ll_create_connection+0x42>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100e3c6:	200c      	movs	r0, #12
}
 100e3c8:	b00d      	add	sp, #52	; 0x34
 100e3ca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	link = ll_rx_link_alloc();
 100e3ce:	f7fb febd 	bl	100a14c <ll_rx_link_alloc>
	if (!link) {
 100e3d2:	9008      	str	r0, [sp, #32]
 100e3d4:	2800      	cmp	r0, #0
 100e3d6:	f000 8230 	beq.w	100e83a <ll_create_connection+0x4ae>
	conn = ll_conn_acquire();
 100e3da:	f7fd f95f 	bl	100b69c <ll_conn_acquire>
	if (!conn) {
 100e3de:	4604      	mov	r4, r0
 100e3e0:	2800      	cmp	r0, #0
 100e3e2:	f000 8276 	beq.w	100e8d2 <ll_create_connection+0x546>
	ull_scan_params_set(lll, 0, scan_interval, scan_window, filter_policy);
 100e3e6:	9b03      	ldr	r3, [sp, #12]
 100e3e8:	4641      	mov	r1, r8
 100e3ea:	462a      	mov	r2, r5
 100e3ec:	9300      	str	r3, [sp, #0]
 100e3ee:	f107 001c 	add.w	r0, r7, #28
 100e3f2:	4633      	mov	r3, r6
 100e3f4:	f7f2 fb18 	bl	1000a28 <ull_scan_params_set>
	lll->adv_addr_type = peer_addr_type;
 100e3f8:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 100e3fc:	9906      	ldr	r1, [sp, #24]
	memcpy(lll->adv_addr, peer_addr, BDADDR_SIZE);
 100e3fe:	2206      	movs	r2, #6
	lll->adv_addr_type = peer_addr_type;
 100e400:	f361 1345 	bfi	r3, r1, #5, #1
 100e404:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
	memcpy(lll->adv_addr, peer_addr, BDADDR_SIZE);
 100e408:	9916      	ldr	r1, [sp, #88]	; 0x58
 100e40a:	f107 003b 	add.w	r0, r7, #59	; 0x3b
 100e40e:	f008 fb03 	bl	1016a18 <memcpy>
	lll_trng_get(access_addr, 4);
	aa = sys_get_le32(access_addr);

	bit_idx = 31U;
	transitions = 0U;
	consecutive_cnt = 1U;
 100e412:	f04f 0901 	mov.w	r9, #1
	lll->conn_ticks_slot = 0; /* TODO: */
 100e416:	f8c7 8028 	str.w	r8, [r7, #40]	; 0x28
	retry = 3U;
 100e41a:	f04f 0803 	mov.w	r8, #3
	conn_lll = &conn->lll;
 100e41e:	f104 031c 	add.w	r3, r4, #28
 100e422:	9309      	str	r3, [sp, #36]	; 0x24
	lll->conn_timeout = timeout;
 100e424:	9b05      	ldr	r3, [sp, #20]
 100e426:	863b      	strh	r3, [r7, #48]	; 0x30
	lll_trng_get(access_addr, 4);
 100e428:	2104      	movs	r1, #4
 100e42a:	a80a      	add	r0, sp, #40	; 0x28
 100e42c:	f001 fd52 	bl	100fed4 <lll_trng_get>
#if defined(CONFIG_BT_CTLR_PHY_CODED)
	ones_count_lsb8 = 0U;
 100e430:	f04f 0c00 	mov.w	ip, #0
	return ((u16_t)src[1] << 8) | src[0];
 100e434:	f89d 502b 	ldrb.w	r5, [sp, #43]	; 0x2b
 100e438:	f89d 202a 	ldrb.w	r2, [sp, #42]	; 0x2a
 100e43c:	f89d 1029 	ldrb.w	r1, [sp, #41]	; 0x29
	return ((u32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
 100e440:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
	return ((u16_t)src[1] << 8) | src[0];
 100e444:	f89d 5028 	ldrb.w	r5, [sp, #40]	; 0x28
	retry--;
 100e448:	f108 38ff 	add.w	r8, r8, #4294967295
	return ((u32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
 100e44c:	ea45 2501 	orr.w	r5, r5, r1, lsl #8
 100e450:	ea45 4502 	orr.w	r5, r5, r2, lsl #16
	transitions_lsb16 = 0U;
#endif /* CONFIG_BT_CTLR_PHY_CODED */
	consecutive_bit = (aa >> bit_idx) & 0x01;
 100e454:	231e      	movs	r3, #30
	transitions_lsb16 = 0U;
 100e456:	4660      	mov	r0, ip
	transitions = 0U;
 100e458:	4666      	mov	r6, ip
	consecutive_cnt = 1U;
 100e45a:	f04f 0e01 	mov.w	lr, #1
	retry--;
 100e45e:	fa5f f888 	uxtb.w	r8, r8
	consecutive_bit = (aa >> bit_idx) & 0x01;
 100e462:	0bd2      	lsrs	r2, r2, #15
	while (bit_idx--) {
 100e464:	e01d      	b.n	100e4a2 <ll_create_connection+0x116>
		if (bit == consecutive_bit) {
			consecutive_cnt++;
		} else {
			consecutive_cnt = 1U;
			consecutive_bit = bit;
			transitions++;
 100e466:	f106 0a01 	add.w	sl, r6, #1

#if defined(CONFIG_BT_CTLR_PHY_CODED)
			if (bit_idx < 15) {
 100e46a:	2b0e      	cmp	r3, #14
			transitions++;
 100e46c:	fa5f fa8a 	uxtb.w	sl, sl
			if (bit_idx < 15) {
 100e470:	b2da      	uxtb	r2, r3
 100e472:	f240 81c4 	bls.w	100e7fe <ll_create_connection+0x472>

		/* It shall have no more than six consecutive zeros or ones. */
		/* It shall have a minimum of two transitions in the most
		 * significant six bits.
		 */
		if ((consecutive_cnt > 6) ||
 100e476:	2900      	cmp	r1, #0
 100e478:	f000 81ab 	beq.w	100e7d2 <ll_create_connection+0x446>
 100e47c:	460a      	mov	r2, r1
 100e47e:	4683      	mov	fp, r0
					  ((bit_idx < 5) &&
					   (ones_count_lsb8 < 2)) ||
					  ((bit_idx < 4) &&
					   (ones_count_lsb8 < 3)))) ||
#endif /* CONFIG_BT_CTLR_PHY_CODED */
		    ((consecutive_cnt < 6) &&
 100e480:	2b1c      	cmp	r3, #28
 100e482:	f240 824a 	bls.w	100e91a <ll_create_connection+0x58e>
		     (((bit_idx < 29) && (transitions < 1)) ||
 100e486:	2b1b      	cmp	r3, #27
 100e488:	f240 825c 	bls.w	100e944 <ll_create_connection+0x5b8>

		/* It shall have no more than 24 transitions
		 * It shall have no more than eleven transitions in the least
		 * significant 16 bits.
		 */
		if ((transitions > 24) ||
 100e48c:	f1ba 0f19 	cmp.w	sl, #25
 100e490:	d032      	beq.n	100e4f8 <ll_create_connection+0x16c>
					   (ones_count_lsb8 < 3)))) ||
 100e492:	468e      	mov	lr, r1
 100e494:	4656      	mov	r6, sl
#if defined(CONFIG_BT_CTLR_PHY_CODED)
		    (transitions_lsb16 > 11) ||
 100e496:	f1bb 0f0c 	cmp.w	fp, #12
					   (ones_count_lsb8 < 3)))) ||
 100e49a:	4658      	mov	r0, fp
		    (transitions_lsb16 > 11) ||
 100e49c:	d02c      	beq.n	100e4f8 <ll_create_connection+0x16c>
	while (bit_idx--) {
 100e49e:	3b01      	subs	r3, #1
 100e4a0:	d332      	bcc.n	100e508 <ll_create_connection+0x17c>
		bit = (aa >> bit_idx) & 0x01;
 100e4a2:	fa25 f103 	lsr.w	r1, r5, r3
 100e4a6:	f001 0101 	and.w	r1, r1, #1
		if (bit == consecutive_bit) {
 100e4aa:	4291      	cmp	r1, r2
 100e4ac:	d1db      	bne.n	100e466 <ll_create_connection+0xda>
			consecutive_cnt++;
 100e4ae:	f10e 0101 	add.w	r1, lr, #1
		if ((bit_idx < 8) && consecutive_bit) {
 100e4b2:	2b07      	cmp	r3, #7
			consecutive_cnt++;
 100e4b4:	b2c9      	uxtb	r1, r1
		if ((bit_idx < 8) && consecutive_bit) {
 100e4b6:	f240 824a 	bls.w	100e94e <ll_create_connection+0x5c2>
		if ((consecutive_cnt > 6) ||
 100e4ba:	2906      	cmp	r1, #6
 100e4bc:	f240 8180 	bls.w	100e7c0 <ll_create_connection+0x434>
			if (consecutive_bit) {
 100e4c0:	2a00      	cmp	r2, #0
 100e4c2:	f000 8167 	beq.w	100e794 <ll_create_connection+0x408>
				aa &= ~BIT(bit_idx);
 100e4c6:	fa09 f203 	lsl.w	r2, r9, r3
 100e4ca:	ea25 0502 	bic.w	r5, r5, r2
 100e4ce:	46b2      	mov	sl, r6
 100e4d0:	4683      	mov	fp, r0
				consecutive_bit = 0U;
 100e4d2:	2200      	movs	r2, #0
				transitions++;
 100e4d4:	f10a 0a01 	add.w	sl, sl, #1
			if (bit_idx < 15) {
 100e4d8:	2b0e      	cmp	r3, #14
				consecutive_cnt = 1U;
 100e4da:	bf88      	it	hi
 100e4dc:	2101      	movhi	r1, #1
				transitions++;
 100e4de:	fa5f fa8a 	uxtb.w	sl, sl
			if (bit_idx < 15) {
 100e4e2:	d8d3      	bhi.n	100e48c <ll_create_connection+0x100>
				if (transitions_lsb16 !=
 100e4e4:	4558      	cmp	r0, fp
 100e4e6:	f000 8262 	beq.w	100e9ae <ll_create_connection+0x622>
		if ((transitions > 24) ||
 100e4ea:	f1ba 0f19 	cmp.w	sl, #25
 100e4ee:	d003      	beq.n	100e4f8 <ll_create_connection+0x16c>
 100e4f0:	4656      	mov	r6, sl
				consecutive_cnt = 1U;
 100e4f2:	f04f 0e01 	mov.w	lr, #1
 100e4f6:	e7d2      	b.n	100e49e <ll_create_connection+0x112>
#endif /* CONFIG_BT_CTLR_PHY_CODED */
		    0) {
			if (consecutive_bit) {
				aa &= ~(BIT(bit_idx + 1) - 1);
 100e4f8:	3301      	adds	r3, #1
 100e4fa:	fa09 f303 	lsl.w	r3, r9, r3
			if (consecutive_bit) {
 100e4fe:	2a00      	cmp	r2, #0
 100e500:	f000 8188 	beq.w	100e814 <ll_create_connection+0x488>
				aa &= ~(BIT(bit_idx + 1) - 1);
 100e504:	425b      	negs	r3, r3
 100e506:	401d      	ands	r5, r3

	/* It shall not be the advertising channel packets Access Address.
	 * It shall not be a sequence that differs from the advertising channel
	 * packets Access Address by only one bit.
	 */
	adv_aa_check = aa ^ PDU_AC_ACCESS_ADDR;
 100e508:	4bd4      	ldr	r3, [pc, #848]	; (100e85c <ll_create_connection+0x4d0>)
	if (util_ones_count_get((u8_t *)&adv_aa_check,
 100e50a:	2104      	movs	r1, #4
	adv_aa_check = aa ^ PDU_AC_ACCESS_ADDR;
 100e50c:	406b      	eors	r3, r5
	if (util_ones_count_get((u8_t *)&adv_aa_check,
 100e50e:	a80b      	add	r0, sp, #44	; 0x2c
	adv_aa_check = aa ^ PDU_AC_ACCESS_ADDR;
 100e510:	930b      	str	r3, [sp, #44]	; 0x2c
	if (util_ones_count_get((u8_t *)&adv_aa_check,
 100e512:	f7f7 fdcd 	bl	10060b0 <util_ones_count_get>
 100e516:	2801      	cmp	r0, #1
 100e518:	d907      	bls.n	100e52a <ll_create_connection+0x19e>
				sizeof(adv_aa_check)) <= 1) {
		goto again;
	}

	/* It shall not have all four octets equal. */
	if (!((aa & 0xFFFF) ^ (aa >> 16)) &&
 100e51a:	b2ab      	uxth	r3, r5
 100e51c:	ebb3 4f15 	cmp.w	r3, r5, lsr #16
 100e520:	d10d      	bne.n	100e53e <ll_create_connection+0x1b2>
	    !((aa & 0xFF) ^ (aa >> 24))) {
 100e522:	b2eb      	uxtb	r3, r5
	if (!((aa & 0xFFFF) ^ (aa >> 16)) &&
 100e524:	ebb3 6f15 	cmp.w	r3, r5, lsr #24
 100e528:	d109      	bne.n	100e53e <ll_create_connection+0x1b2>
	LL_ASSERT(retry);
 100e52a:	f1b8 0f00 	cmp.w	r8, #0
 100e52e:	f47f af7b 	bne.w	100e428 <ll_create_connection+0x9c>
 100e532:	f240 21d5 	movw	r1, #725	; 0x2d5
 100e536:	48ca      	ldr	r0, [pc, #808]	; (100e860 <ll_create_connection+0x4d4>)
 100e538:	f7f5 f8a2 	bl	1003680 <bt_ctlr_assert_handle>
 100e53c:	e774      	b.n	100e428 <ll_create_connection+0x9c>
	memcpy(conn_lll->access_addr, &access_addr,
 100e53e:	2204      	movs	r2, #4
 100e540:	a90a      	add	r1, sp, #40	; 0x28
 100e542:	f104 0024 	add.w	r0, r4, #36	; 0x24
	dst[0] = val;
 100e546:	950a      	str	r5, [sp, #40]	; 0x28
 100e548:	f008 fa66 	bl	1016a18 <memcpy>
	lll_trng_get(&conn_lll->crc_init[0], 3);
 100e54c:	2103      	movs	r1, #3
 100e54e:	f104 0028 	add.w	r0, r4, #40	; 0x28
 100e552:	f001 fcbf 	bl	100fed4 <lll_trng_get>
	conn_lll->handle = 0xFFFF;
 100e556:	f64f 73ff 	movw	r3, #65535	; 0xffff
	conn_lll->interval = interval;
 100e55a:	9a04      	ldr	r2, [sp, #16]
	if (!conn_lll->link_tx_free) {
 100e55c:	6fa0      	ldr	r0, [r4, #120]	; 0x78
	conn_lll->interval = interval;
 100e55e:	85e2      	strh	r2, [r4, #46]	; 0x2e
	conn_lll->latency = latency;
 100e560:	9a07      	ldr	r2, [sp, #28]
	conn_lll->handle = 0xFFFF;
 100e562:	85a3      	strh	r3, [r4, #44]	; 0x2c
	conn_lll->latency = latency;
 100e564:	8622      	strh	r2, [r4, #48]	; 0x30
	if (!conn_lll->link_tx_free) {
 100e566:	2800      	cmp	r0, #0
 100e568:	f000 8163 	beq.w	100e832 <ll_create_connection+0x4a6>
	memq_init(conn_lll->link_tx_free, &conn_lll->memq_tx.head,
 100e56c:	f104 026c 	add.w	r2, r4, #108	; 0x6c
 100e570:	f104 0168 	add.w	r1, r4, #104	; 0x68
 100e574:	f7f7 fc26 	bl	1005dc4 <memq_init>
	conn_lll->link_tx_free = NULL;
 100e578:	2500      	movs	r5, #0
	conn_lll->max_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
 100e57a:	f04f 111b 	mov.w	r1, #1769499	; 0x1b001b
	conn_lll->rssi_latest = 0x7F;
 100e57e:	227f      	movs	r2, #127	; 0x7f
	conn_lll->phy_tx = BIT(0);
 100e580:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
	conn_lll->sn = 0;
 100e584:	f894 007e 	ldrb.w	r0, [r4, #126]	; 0x7e
	conn_lll->phy_tx = BIT(0);
 100e588:	f423 63ef 	bic.w	r3, r3, #1912	; 0x778
 100e58c:	f023 0307 	bic.w	r3, r3, #7
 100e590:	f443 7388 	orr.w	r3, r3, #272	; 0x110
 100e594:	f043 0301 	orr.w	r3, r3, #1
 100e598:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
	conn_lll->max_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M);
 100e59c:	4bb1      	ldr	r3, [pc, #708]	; (100e864 <ll_create_connection+0x4d8>)
	conn_lll->sn = 0;
 100e59e:	f020 0007 	bic.w	r0, r0, #7
 100e5a2:	f884 007e 	strb.w	r0, [r4, #126]	; 0x7e
	conn_lll->max_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
 100e5a6:	65e1      	str	r1, [r4, #92]	; 0x5c
	conn_lll->rssi_latest = 0x7F;
 100e5a8:	f884 20c1 	strb.w	r2, [r4, #193]	; 0xc1
	conn_lll->max_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M);
 100e5ac:	6623      	str	r3, [r4, #96]	; 0x60
	conn_lll->link_tx_free = NULL;
 100e5ae:	67a5      	str	r5, [r4, #120]	; 0x78
	conn_lll->packet_tx_head_len = 0;
 100e5b0:	f8a4 507c 	strh.w	r5, [r4, #124]	; 0x7c
	conn_lll->latency_prepare = 0;
 100e5b4:	8665      	strh	r5, [r4, #50]	; 0x32
	conn_lll->latency_event = 0;
 100e5b6:	6365      	str	r5, [r4, #52]	; 0x34
		ull_conn_chan_map_cpy(conn_lll->data_chan_map);
 100e5b8:	f104 0038 	add.w	r0, r4, #56	; 0x38
 100e5bc:	f7fd fbd8 	bl	100bd70 <ull_conn_chan_map_cpy>
 100e5c0:	4602      	mov	r2, r0
	conn_lll->data_chan_count =
 100e5c2:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
	lll_trng_get(&hop, sizeof(u8_t));
 100e5c6:	2101      	movs	r1, #1
	conn_lll->data_chan_count =
 100e5c8:	f362 0305 	bfi	r3, r2, #0, #6
 100e5cc:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
	lll_trng_get(&hop, sizeof(u8_t));
 100e5d0:	a80b      	add	r0, sp, #44	; 0x2c
 100e5d2:	f001 fc7f 	bl	100fed4 <lll_trng_get>
	conn_interval_us = (u32_t)interval * 1250U;
 100e5d6:	f240 40e2 	movw	r0, #1250	; 0x4e2
	conn->supervision_reload = RADIO_CONN_EVENTS(timeout * 10000U,
 100e5da:	f242 7210 	movw	r2, #10000	; 0x2710
	conn_interval_us = (u32_t)interval * 1250U;
 100e5de:	9904      	ldr	r1, [sp, #16]
	conn->connect_expire = 6U;
 100e5e0:	f04f 0e06 	mov.w	lr, #6
	conn_interval_us = (u32_t)interval * 1250U;
 100e5e4:	fb00 f101 	mul.w	r1, r0, r1
	conn->supervision_reload = RADIO_CONN_EVENTS(timeout * 10000U,
 100e5e8:	9805      	ldr	r0, [sp, #20]
 100e5ea:	1e4b      	subs	r3, r1, #1
 100e5ec:	fb02 3300 	mla	r3, r2, r0, r3
	conn->apto_reload = RADIO_CONN_EVENTS((30000000), conn_interval_us);
 100e5f0:	4a9d      	ldr	r2, [pc, #628]	; (100e868 <ll_create_connection+0x4dc>)
	conn->procedure_reload = RADIO_CONN_EVENTS(40000000,
 100e5f2:	489e      	ldr	r0, [pc, #632]	; (100e86c <ll_create_connection+0x4e0>)
	conn->apto_reload = RADIO_CONN_EVENTS((30000000), conn_interval_us);
 100e5f4:	440a      	add	r2, r1
	conn->supervision_reload = RADIO_CONN_EVENTS(timeout * 10000U,
 100e5f6:	fbb3 f3f1 	udiv	r3, r3, r1
	conn->apto_reload = RADIO_CONN_EVENTS((30000000), conn_interval_us);
 100e5fa:	fbb2 f2f1 	udiv	r2, r2, r1
	conn->procedure_reload = RADIO_CONN_EVENTS(40000000,
 100e5fe:	4408      	add	r0, r1
 100e600:	fbb0 f0f1 	udiv	r0, r0, r1
	conn_lll->data_chan_hop = 5 + (hop % 12);
 100e604:	4e9a      	ldr	r6, [pc, #616]	; (100e870 <ll_create_connection+0x4e4>)
 100e606:	f89d 102c 	ldrb.w	r1, [sp, #44]	; 0x2c
	conn->supervision_reload = RADIO_CONN_EVENTS(timeout * 10000U,
 100e60a:	f8a4 30c6 	strh.w	r3, [r4, #198]	; 0xc6
	conn_lll->data_chan_hop = 5 + (hop % 12);
 100e60e:	fba6 c601 	umull	ip, r6, r6, r1
 100e612:	08f6      	lsrs	r6, r6, #3
 100e614:	eb06 0646 	add.w	r6, r6, r6, lsl #1
 100e618:	eba1 0186 	sub.w	r1, r1, r6, lsl #2
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
 100e61c:	8e26      	ldrh	r6, [r4, #48]	; 0x30
	conn_lll->data_chan_sel = 0;
 100e61e:	f894 c03d 	ldrb.w	ip, [r4, #61]	; 0x3d
	conn_lll->data_chan_hop = 5 + (hop % 12);
 100e622:	3105      	adds	r1, #5
 100e624:	f884 103e 	strb.w	r1, [r4, #62]	; 0x3e
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
 100e628:	eb06 030e 	add.w	r3, r6, lr
	conn->apto_reload = RADIO_CONN_EVENTS((30000000), conn_interval_us);
 100e62c:	b291      	uxth	r1, r2
	conn_lll->data_chan_sel = 0;
 100e62e:	f00c 0c3f 	and.w	ip, ip, #63	; 0x3f
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
 100e632:	4299      	cmp	r1, r3
	conn_lll->data_chan_use = 0;
 100e634:	f884 503f 	strb.w	r5, [r4, #63]	; 0x3f
	conn->supervision_expire = 0U;
 100e638:	f8a4 50c8 	strh.w	r5, [r4, #200]	; 0xc8
	conn->procedure_expire = 0U;
 100e63c:	f8a4 50cc 	strh.w	r5, [r4, #204]	; 0xcc
	conn->apto_expire = 0U;
 100e640:	f8a4 50d4 	strh.w	r5, [r4, #212]	; 0xd4
	conn->appto_expire = 0U;
 100e644:	f8a4 50d0 	strh.w	r5, [r4, #208]	; 0xd0
	conn->apto_reload = RADIO_CONN_EVENTS((30000000), conn_interval_us);
 100e648:	f8a4 10d2 	strh.w	r1, [r4, #210]	; 0xd2
	conn->procedure_reload = RADIO_CONN_EVENTS(40000000,
 100e64c:	f8a4 00ca 	strh.w	r0, [r4, #202]	; 0xca
	conn_lll->data_chan_sel = 0;
 100e650:	f884 c03d 	strb.w	ip, [r4, #61]	; 0x3d
	conn->connect_expire = 6U;
 100e654:	f8a4 e0c4 	strh.w	lr, [r4, #196]	; 0xc4
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
 100e658:	dd02      	ble.n	100e660 <ll_create_connection+0x2d4>
			     (conn->apto_reload - (conn_lll->latency + 6)) :
 100e65a:	1b89      	subs	r1, r1, r6
 100e65c:	3906      	subs	r1, #6
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
 100e65e:	b289      	uxth	r1, r1
	conn->llcp_req = conn->llcp_ack = conn->llcp_type = 0U;
 100e660:	2500      	movs	r5, #0
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
 100e662:	f8a4 10ce 	strh.w	r1, [r4, #206]	; 0xce
	conn->llcp_terminate.node_rx.hdr.link = link;
 100e666:	9908      	ldr	r1, [sp, #32]
	conn->llcp_conn_param.disabled = 0U;
 100e668:	f894 2172 	ldrb.w	r2, [r4, #370]	; 0x172
	conn->llcp_length.disabled = 0U;
 100e66c:	f894 319a 	ldrb.w	r3, [r4, #410]	; 0x19a
	conn->llcp_terminate.node_rx.hdr.link = link;
 100e670:	f8c4 112c 	str.w	r1, [r4, #300]	; 0x12c
	conn->llcp_version.tx = conn->llcp_version.rx = 0U;
 100e674:	f894 1122 	ldrb.w	r1, [r4, #290]	; 0x122
	conn->llcp_conn_param.disabled = 0U;
 100e678:	f365 1204 	bfi	r2, r5, #4, #1
	conn->llcp_length.disabled = 0U;
 100e67c:	f365 03c3 	bfi	r3, r5, #3, #1
	conn->common.fex_valid = 0U;
 100e680:	f894 00dc 	ldrb.w	r0, [r4, #220]	; 0xdc
	conn->llcp_conn_param.disabled = 0U;
 100e684:	f884 2172 	strb.w	r2, [r4, #370]	; 0x172
	conn->llcp_length.disabled = 0U;
 100e688:	f884 319a 	strb.w	r3, [r4, #410]	; 0x19a
	conn_lll->enc_rx = conn_lll->enc_tx = 0U;
 100e68c:	f894 207e 	ldrb.w	r2, [r4, #126]	; 0x7e
	conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
 100e690:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
	conn->llcp_version.tx = conn->llcp_version.rx = 0U;
 100e694:	f021 0103 	bic.w	r1, r1, #3
 100e698:	f884 1122 	strb.w	r1, [r4, #290]	; 0x122
	conn->llcp_feature.features = LL_FEAT;
 100e69c:	4975      	ldr	r1, [pc, #468]	; (100e874 <ll_create_connection+0x4e8>)
	conn_lll->enc_rx = conn_lll->enc_tx = 0U;
 100e69e:	f022 0218 	bic.w	r2, r2, #24
	conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
 100e6a2:	f023 0307 	bic.w	r3, r3, #7
	conn->common.fex_valid = 0U;
 100e6a6:	f020 0003 	bic.w	r0, r0, #3
	conn->llcp_feature.features = LL_FEAT;
 100e6aa:	f8c4 111c 	str.w	r1, [r4, #284]	; 0x11c
	conn_lll->enc_rx = conn_lll->enc_tx = 0U;
 100e6ae:	f884 207e 	strb.w	r2, [r4, #126]	; 0x7e
	conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
 100e6b2:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
	conn->llcp_req = conn->llcp_ack = conn->llcp_type = 0U;
 100e6b6:	f8a4 50e8 	strh.w	r5, [r4, #232]	; 0xe8
 100e6ba:	f884 50ea 	strb.w	r5, [r4, #234]	; 0xea
	conn->llcp_rx = NULL;
 100e6be:	f8c4 5100 	str.w	r5, [r4, #256]	; 0x100
	conn->llcp_cu.req = conn->llcp_cu.ack = 0;
 100e6c2:	f8a4 5104 	strh.w	r5, [r4, #260]	; 0x104
	conn->llcp_feature.req = conn->llcp_feature.ack = 0;
 100e6c6:	f8a4 5118 	strh.w	r5, [r4, #280]	; 0x118
	conn->llcp_version.req = conn->llcp_version.ack = 0;
 100e6ca:	f8a4 5120 	strh.w	r5, [r4, #288]	; 0x120
	conn->llcp_terminate.reason_peer = 0U;
 100e6ce:	f884 512b 	strb.w	r5, [r4, #299]	; 0x12b
	conn->llcp_enc.req = conn->llcp_enc.ack = 0U;
 100e6d2:	f8a4 5150 	strh.w	r5, [r4, #336]	; 0x150
	conn->llcp_conn_param.req = 0U;
 100e6d6:	f8a4 5170 	strh.w	r5, [r4, #368]	; 0x170
	conn->llcp_length.req = conn->llcp_length.ack = 0U;
 100e6da:	f8a4 5198 	strh.w	r5, [r4, #408]	; 0x198
	conn->llcp_length.cache.tx_octets = 0U;
 100e6de:	f8a4 51a4 	strh.w	r5, [r4, #420]	; 0x1a4
	conn->common.fex_valid = 0U;
 100e6e2:	f884 00dc 	strb.w	r0, [r4, #220]	; 0xdc
	conn->default_tx_octets = ull_conn_default_tx_octets_get();
 100e6e6:	f7fd fb61 	bl	100bdac <ull_conn_default_tx_octets_get>
 100e6ea:	f8a4 00d6 	strh.w	r0, [r4, #214]	; 0xd6
	conn->default_tx_time = ull_conn_default_tx_time_get();
 100e6ee:	f7fd fb63 	bl	100bdb8 <ull_conn_default_tx_time_get>
	conn->llcp_phy.req = conn->llcp_phy.ack = 0U;
 100e6f2:	f8d4 21a8 	ldr.w	r2, [r4, #424]	; 0x1a8
 100e6f6:	4b60      	ldr	r3, [pc, #384]	; (100e878 <ll_create_connection+0x4ec>)
	conn->default_tx_time = ull_conn_default_tx_time_get();
 100e6f8:	f8a4 00d8 	strh.w	r0, [r4, #216]	; 0xd8
	conn->llcp_phy.req = conn->llcp_phy.ack = 0U;
 100e6fc:	4013      	ands	r3, r2
 100e6fe:	f8c4 31a8 	str.w	r3, [r4, #424]	; 0x1a8
	conn->phy_pref_tx = ull_conn_default_phy_tx_get();
 100e702:	f7fd fb5f 	bl	100bdc4 <ull_conn_default_phy_tx_get>
 100e706:	f894 31ac 	ldrb.w	r3, [r4, #428]	; 0x1ac
 100e70a:	f360 0302 	bfi	r3, r0, #0, #3
 100e70e:	f884 31ac 	strb.w	r3, [r4, #428]	; 0x1ac
	conn->phy_pref_rx = ull_conn_default_phy_rx_get();
 100e712:	f7fd fb5d 	bl	100bdd0 <ull_conn_default_phy_rx_get>
	conn->phy_pref_flags = 0U;
 100e716:	f894 31ac 	ldrb.w	r3, [r4, #428]	; 0x1ac
 100e71a:	0100      	lsls	r0, r0, #4
 100e71c:	f023 0378 	bic.w	r3, r3, #120	; 0x78
 100e720:	f000 0070 	and.w	r0, r0, #112	; 0x70
 100e724:	4318      	orrs	r0, r3
	lll->conn = conn_lll;
 100e726:	9b09      	ldr	r3, [sp, #36]	; 0x24
	conn->phy_pref_flags = 0U;
 100e728:	f884 01ac 	strb.w	r0, [r4, #428]	; 0x1ac
	conn->tx_data = conn->tx_data_last = 0;
 100e72c:	e9c4 556f 	strd	r5, r5, [r4, #444]	; 0x1bc
	conn->tx_head = conn->tx_ctrl = conn->tx_ctrl_last =
 100e730:	e9c4 556d 	strd	r5, r5, [r4, #436]	; 0x1b4
 100e734:	f8c4 51b0 	str.w	r5, [r4, #432]	; 0x1b0
	lll->conn = conn_lll;
 100e738:	627b      	str	r3, [r7, #36]	; 0x24
	hdr->is_stop = 0U;
 100e73a:	f894 3020 	ldrb.w	r3, [r4, #32]
	hdr->disabled_cb = hdr->disabled_param = NULL;
 100e73e:	61a5      	str	r5, [r4, #24]
 100e740:	f365 0300 	bfi	r3, r5, #0, #1
 100e744:	f884 3020 	strb.w	r3, [r4, #32]
 100e748:	6165      	str	r5, [r4, #20]
	hdr->parent = parent;
 100e74a:	61e4      	str	r4, [r4, #28]
	ull_filter_scan_update(filter_policy);
 100e74c:	9c03      	ldr	r4, [sp, #12]
 100e74e:	4620      	mov	r0, r4
 100e750:	f000 fc1c 	bl	100ef8c <ull_filter_scan_update>
	lll->rl_idx = FILTER_IDX_NONE;
 100e754:	22ff      	movs	r2, #255	; 0xff
	lll->rpa_gen = 0;
 100e756:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
	lll->rl_idx = FILTER_IDX_NONE;
 100e75a:	f887 2034 	strb.w	r2, [r7, #52]	; 0x34
	lll->rpa_gen = 0;
 100e75e:	f365 0300 	bfi	r3, r5, #0, #1
 100e762:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
	if (!filter_policy && ull_filter_lll_rl_enabled()) {
 100e766:	2c00      	cmp	r4, #0
 100e768:	d057      	beq.n	100e81a <ll_create_connection+0x48e>
	if (own_addr_type == BT_ADDR_LE_PUBLIC_ID ||
 100e76a:	9b02      	ldr	r3, [sp, #8]
 100e76c:	3b02      	subs	r3, #2
 100e76e:	2b01      	cmp	r3, #1
 100e770:	d965      	bls.n	100e83e <ll_create_connection+0x4b2>
	scan->own_addr_type = own_addr_type;
 100e772:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 100e776:	9a02      	ldr	r2, [sp, #8]
 100e778:	f362 0342 	bfi	r3, r2, #1, #2
 100e77c:	f887 3048 	strb.w	r3, [r7, #72]	; 0x48
	err = lll_clock_wait();
 100e780:	f001 fce8 	bl	1010154 <lll_clock_wait>
	if (err) {
 100e784:	2800      	cmp	r0, #0
 100e786:	d179      	bne.n	100e87c <ll_create_connection+0x4f0>
	return ull_scan_enable(scan);
 100e788:	4638      	mov	r0, r7
 100e78a:	f7f2 f975 	bl	1000a78 <ull_scan_enable>
}
 100e78e:	b00d      	add	sp, #52	; 0x34
 100e790:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				aa |= BIT(bit_idx);
 100e794:	fa09 f203 	lsl.w	r2, r9, r3
 100e798:	4315      	orrs	r5, r2
 100e79a:	4683      	mov	fp, r0
 100e79c:	46b2      	mov	sl, r6
				consecutive_bit = 1U;
 100e79e:	2201      	movs	r2, #1
			if (transitions != transitions_prev) {
 100e7a0:	4556      	cmp	r6, sl
 100e7a2:	f43f ae97 	beq.w	100e4d4 <ll_create_connection+0x148>
			if (bit_idx < 15) {
 100e7a6:	2b0e      	cmp	r3, #14
 100e7a8:	f63f ae75 	bhi.w	100e496 <ll_create_connection+0x10a>
				if (transitions_lsb16 !=
 100e7ac:	4558      	cmp	r0, fp
 100e7ae:	f47f ae76 	bne.w	100e49e <ll_create_connection+0x112>
 100e7b2:	46b2      	mov	sl, r6
					transitions_lsb16++;
 100e7b4:	f10b 0b01 	add.w	fp, fp, #1
 100e7b8:	4671      	mov	r1, lr
 100e7ba:	fa5f fb8b 	uxtb.w	fp, fp
 100e7be:	e665      	b.n	100e48c <ll_create_connection+0x100>
		if ((consecutive_cnt > 6) ||
 100e7c0:	2a00      	cmp	r2, #0
 100e7c2:	f040 80d2 	bne.w	100e96a <ll_create_connection+0x5de>
 100e7c6:	46b2      	mov	sl, r6
 100e7c8:	4683      	mov	fp, r0
					   (ones_count_lsb8 < 3)))) ||
 100e7ca:	2906      	cmp	r1, #6
 100e7cc:	d120      	bne.n	100e810 <ll_create_connection+0x484>
 100e7ce:	2200      	movs	r2, #0
 100e7d0:	e65c      	b.n	100e48c <ll_create_connection+0x100>
		if ((consecutive_cnt > 6) ||
 100e7d2:	4683      	mov	fp, r0
			consecutive_cnt = 1U;
 100e7d4:	2101      	movs	r1, #1
		    (!consecutive_bit && (((bit_idx < 6) &&
 100e7d6:	2b05      	cmp	r3, #5
 100e7d8:	d8f7      	bhi.n	100e7ca <ll_create_connection+0x43e>
 100e7da:	f1bc 0f00 	cmp.w	ip, #0
 100e7de:	d00a      	beq.n	100e7f6 <ll_create_connection+0x46a>
					   (ones_count_lsb8 < 1)) ||
 100e7e0:	2a04      	cmp	r2, #4
 100e7e2:	d8f2      	bhi.n	100e7ca <ll_create_connection+0x43e>
					  ((bit_idx < 5) &&
 100e7e4:	f1bc 0f01 	cmp.w	ip, #1
 100e7e8:	d905      	bls.n	100e7f6 <ll_create_connection+0x46a>
					   (ones_count_lsb8 < 2)) ||
 100e7ea:	2a03      	cmp	r2, #3
 100e7ec:	d8ed      	bhi.n	100e7ca <ll_create_connection+0x43e>
					  ((bit_idx < 4) &&
 100e7ee:	f1bc 0f02 	cmp.w	ip, #2
 100e7f2:	f200 80c5 	bhi.w	100e980 <ll_create_connection+0x5f4>
				aa |= BIT(bit_idx);
 100e7f6:	fa09 f203 	lsl.w	r2, r9, r3
 100e7fa:	4315      	orrs	r5, r2
				if (bit_idx < 8) {
 100e7fc:	e09c      	b.n	100e938 <ll_create_connection+0x5ac>
				transitions_lsb16++;
 100e7fe:	f100 0b01 	add.w	fp, r0, #1
		if ((bit_idx < 8) && consecutive_bit) {
 100e802:	2a07      	cmp	r2, #7
				transitions_lsb16++;
 100e804:	fa5f fb8b 	uxtb.w	fp, fp
		if ((bit_idx < 8) && consecutive_bit) {
 100e808:	d97e      	bls.n	100e908 <ll_create_connection+0x57c>
		if ((consecutive_cnt > 6) ||
 100e80a:	2900      	cmp	r1, #0
 100e80c:	d166      	bne.n	100e8dc <ll_create_connection+0x550>
			consecutive_cnt = 1U;
 100e80e:	2101      	movs	r1, #1
 100e810:	2200      	movs	r2, #0
 100e812:	e635      	b.n	100e480 <ll_create_connection+0xf4>
				aa |= (BIT(bit_idx + 1) - 1);
 100e814:	3b01      	subs	r3, #1
 100e816:	431d      	orrs	r5, r3
 100e818:	e676      	b.n	100e508 <ll_create_connection+0x17c>
	if (!filter_policy && ull_filter_lll_rl_enabled()) {
 100e81a:	f001 f9c1 	bl	100fba0 <ull_filter_lll_rl_enabled>
 100e81e:	2800      	cmp	r0, #0
 100e820:	d0a3      	beq.n	100e76a <ll_create_connection+0x3de>
		lll->rl_idx = ull_filter_rl_find(peer_addr_type, peer_addr,
 100e822:	9a03      	ldr	r2, [sp, #12]
 100e824:	9806      	ldr	r0, [sp, #24]
 100e826:	9916      	ldr	r1, [sp, #88]	; 0x58
 100e828:	f000 fd7a 	bl	100f320 <ull_filter_rl_find>
 100e82c:	f887 0034 	strb.w	r0, [r7, #52]	; 0x34
 100e830:	e79b      	b.n	100e76a <ll_create_connection+0x3de>
		conn_lll->link_tx_free = &conn_lll->link_tx;
 100e832:	f104 0070 	add.w	r0, r4, #112	; 0x70
 100e836:	67a0      	str	r0, [r4, #120]	; 0x78
 100e838:	e698      	b.n	100e56c <ll_create_connection+0x1e0>
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
 100e83a:	2007      	movs	r0, #7
 100e83c:	e5c4      	b.n	100e3c8 <ll_create_connection+0x3c>
		ull_filter_rpa_update(false);
 100e83e:	2000      	movs	r0, #0
 100e840:	f000 fc48 	bl	100f0d4 <ull_filter_rpa_update>
		lll->rpa_gen = 1;
 100e844:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
		own_addr_type &= 0x1;
 100e848:	9a02      	ldr	r2, [sp, #8]
		lll->rpa_gen = 1;
 100e84a:	f043 0301 	orr.w	r3, r3, #1
		own_addr_type &= 0x1;
 100e84e:	f002 0201 	and.w	r2, r2, #1
 100e852:	9202      	str	r2, [sp, #8]
		lll->rpa_gen = 1;
 100e854:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 100e858:	e78b      	b.n	100e772 <ll_create_connection+0x3e6>
 100e85a:	bf00      	nop
 100e85c:	8e89bed6 	.word	0x8e89bed6
 100e860:	010189ec 	.word	0x010189ec
 100e864:	01480148 	.word	0x01480148
 100e868:	01c9c37f 	.word	0x01c9c37f
 100e86c:	026259ff 	.word	0x026259ff
 100e870:	aaaaaaab 	.word	0xaaaaaaab
 100e874:	000149ff 	.word	0x000149ff
 100e878:	f6ff0000 	.word	0xf6ff0000
	sys_put_le32(aa, access_addr);
}

static inline void conn_release(struct ll_scan_set *scan)
{
	struct lll_conn *lll = scan->lll.conn;
 100e87c:	6a7c      	ldr	r4, [r7, #36]	; 0x24
	struct node_rx_pdu *cc;
	struct ll_conn *conn;
	memq_link_t *link;

	LL_ASSERT(!lll->link_tx_free);
 100e87e:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 100e880:	b123      	cbz	r3, 100e88c <ll_create_connection+0x500>
 100e882:	f44f 7159 	mov.w	r1, #868	; 0x364
 100e886:	484b      	ldr	r0, [pc, #300]	; (100e9b4 <ll_create_connection+0x628>)
 100e888:	f7f4 fefa 	bl	1003680 <bt_ctlr_assert_handle>
	link = memq_deinit(&lll->memq_tx.head, &lll->memq_tx.tail);
 100e88c:	f104 0150 	add.w	r1, r4, #80	; 0x50
 100e890:	f104 004c 	add.w	r0, r4, #76	; 0x4c
 100e894:	f7f7 fa9a 	bl	1005dcc <memq_deinit>
	LL_ASSERT(link);
 100e898:	4605      	mov	r5, r0
 100e89a:	b1a0      	cbz	r0, 100e8c6 <ll_create_connection+0x53a>
	lll->link_tx_free = link;

	conn = (void *)HDR_LLL2EVT(lll);
 100e89c:	6826      	ldr	r6, [r4, #0]
	lll->link_tx_free = link;
 100e89e:	65e5      	str	r5, [r4, #92]	; 0x5c

	cc = (void *)&conn->llcp_terminate.node_rx;
	link = cc->hdr.link;
 100e8a0:	f8d6 412c 	ldr.w	r4, [r6, #300]	; 0x12c
	LL_ASSERT(link);
 100e8a4:	b14c      	cbz	r4, 100e8ba <ll_create_connection+0x52e>

	ll_rx_link_release(link);
 100e8a6:	4620      	mov	r0, r4
 100e8a8:	f7fb fc56 	bl	100a158 <ll_rx_link_release>

	ll_conn_release(conn);
 100e8ac:	4630      	mov	r0, r6
 100e8ae:	f7fc fefb 	bl	100b6a8 <ll_conn_release>
	scan->lll.conn = NULL;
 100e8b2:	2300      	movs	r3, #0
		return BT_HCI_ERR_HW_FAILURE;
 100e8b4:	2003      	movs	r0, #3
	scan->lll.conn = NULL;
 100e8b6:	627b      	str	r3, [r7, #36]	; 0x24
}
 100e8b8:	e586      	b.n	100e3c8 <ll_create_connection+0x3c>
	LL_ASSERT(link);
 100e8ba:	f240 316d 	movw	r1, #877	; 0x36d
 100e8be:	483d      	ldr	r0, [pc, #244]	; (100e9b4 <ll_create_connection+0x628>)
 100e8c0:	f7f4 fede 	bl	1003680 <bt_ctlr_assert_handle>
 100e8c4:	e7ef      	b.n	100e8a6 <ll_create_connection+0x51a>
	LL_ASSERT(link);
 100e8c6:	f240 3166 	movw	r1, #870	; 0x366
 100e8ca:	483a      	ldr	r0, [pc, #232]	; (100e9b4 <ll_create_connection+0x628>)
 100e8cc:	f7f4 fed8 	bl	1003680 <bt_ctlr_assert_handle>
 100e8d0:	e7e4      	b.n	100e89c <ll_create_connection+0x510>
		ll_rx_link_release(link);
 100e8d2:	9808      	ldr	r0, [sp, #32]
 100e8d4:	f7fb fc40 	bl	100a158 <ll_rx_link_release>
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
 100e8d8:	2007      	movs	r0, #7
 100e8da:	e575      	b.n	100e3c8 <ll_create_connection+0x3c>
		      ((bit_idx < 28) && (transitions < 2))))) {
 100e8dc:	f1ba 0f01 	cmp.w	sl, #1
 100e8e0:	d003      	beq.n	100e8ea <ll_create_connection+0x55e>
 100e8e2:	460a      	mov	r2, r1
 100e8e4:	e5d2      	b.n	100e48c <ll_create_connection+0x100>
		     (((bit_idx < 29) && (transitions < 1)) ||
 100e8e6:	4683      	mov	fp, r0
 100e8e8:	46b2      	mov	sl, r6
				aa &= ~BIT(bit_idx);
 100e8ea:	fa09 f203 	lsl.w	r2, r9, r3
				if (bit_idx < 8) {
 100e8ee:	2b07      	cmp	r3, #7
				aa &= ~BIT(bit_idx);
 100e8f0:	ea25 0502 	bic.w	r5, r5, r2
				consecutive_bit = 0U;
 100e8f4:	bf88      	it	hi
 100e8f6:	2200      	movhi	r2, #0
				if (bit_idx < 8) {
 100e8f8:	f63f af52 	bhi.w	100e7a0 <ll_create_connection+0x414>
					ones_count_lsb8--;
 100e8fc:	f10c 3cff 	add.w	ip, ip, #4294967295
				consecutive_bit = 0U;
 100e900:	2200      	movs	r2, #0
					ones_count_lsb8--;
 100e902:	fa5f fc8c 	uxtb.w	ip, ip
 100e906:	e74b      	b.n	100e7a0 <ll_create_connection+0x414>
		if ((bit_idx < 8) && consecutive_bit) {
 100e908:	2900      	cmp	r1, #0
 100e90a:	f43f af63 	beq.w	100e7d4 <ll_create_connection+0x448>
			ones_count_lsb8++;
 100e90e:	f10c 0c01 	add.w	ip, ip, #1
 100e912:	460a      	mov	r2, r1
 100e914:	fa5f fc8c 	uxtb.w	ip, ip
		if ((consecutive_cnt > 6) ||
 100e918:	e5b5      	b.n	100e486 <ll_create_connection+0xfa>
		     (((bit_idx < 29) && (transitions < 1)) ||
 100e91a:	f1ba 0f00 	cmp.w	sl, #0
 100e91e:	f47f adb2 	bne.w	100e486 <ll_create_connection+0xfa>
			if (consecutive_bit) {
 100e922:	2a00      	cmp	r2, #0
 100e924:	d1e1      	bne.n	100e8ea <ll_create_connection+0x55e>
				aa |= BIT(bit_idx);
 100e926:	fa09 f203 	lsl.w	r2, r9, r3
				if (bit_idx < 8) {
 100e92a:	2b07      	cmp	r3, #7
				aa |= BIT(bit_idx);
 100e92c:	ea45 0502 	orr.w	r5, r5, r2
				consecutive_bit = 1U;
 100e930:	bf88      	it	hi
 100e932:	2201      	movhi	r2, #1
				if (bit_idx < 8) {
 100e934:	f63f af34 	bhi.w	100e7a0 <ll_create_connection+0x414>
					ones_count_lsb8++;
 100e938:	f10c 0c01 	add.w	ip, ip, #1
				consecutive_bit = 1U;
 100e93c:	2201      	movs	r2, #1
					ones_count_lsb8++;
 100e93e:	fa5f fc8c 	uxtb.w	ip, ip
 100e942:	e72d      	b.n	100e7a0 <ll_create_connection+0x414>
		      ((bit_idx < 28) && (transitions < 2))))) {
 100e944:	f1ba 0f01 	cmp.w	sl, #1
 100e948:	f63f ada0 	bhi.w	100e48c <ll_create_connection+0x100>
 100e94c:	e7e9      	b.n	100e922 <ll_create_connection+0x596>
		if ((bit_idx < 8) && consecutive_bit) {
 100e94e:	b1fa      	cbz	r2, 100e990 <ll_create_connection+0x604>
			ones_count_lsb8++;
 100e950:	f10c 0c01 	add.w	ip, ip, #1
		if ((consecutive_cnt > 6) ||
 100e954:	2906      	cmp	r1, #6
			ones_count_lsb8++;
 100e956:	fa5f fc8c 	uxtb.w	ip, ip
		if ((consecutive_cnt > 6) ||
 100e95a:	d90b      	bls.n	100e974 <ll_create_connection+0x5e8>
				aa &= ~BIT(bit_idx);
 100e95c:	fa09 f203 	lsl.w	r2, r9, r3
 100e960:	46b2      	mov	sl, r6
 100e962:	4683      	mov	fp, r0
 100e964:	ea25 0502 	bic.w	r5, r5, r2
				if (bit_idx < 8) {
 100e968:	e7c8      	b.n	100e8fc <ll_create_connection+0x570>
					   (ones_count_lsb8 < 3)))) ||
 100e96a:	2906      	cmp	r1, #6
 100e96c:	d116      	bne.n	100e99c <ll_create_connection+0x610>
 100e96e:	4683      	mov	fp, r0
 100e970:	46b2      	mov	sl, r6
 100e972:	e58e      	b.n	100e492 <ll_create_connection+0x106>
 100e974:	d0fb      	beq.n	100e96e <ll_create_connection+0x5e2>
		     (((bit_idx < 29) && (transitions < 1)) ||
 100e976:	2e00      	cmp	r6, #0
 100e978:	d0b5      	beq.n	100e8e6 <ll_create_connection+0x55a>
 100e97a:	46b2      	mov	sl, r6
 100e97c:	4683      	mov	fp, r0
 100e97e:	e582      	b.n	100e486 <ll_create_connection+0xfa>
					   (ones_count_lsb8 < 3)))) ||
 100e980:	2906      	cmp	r1, #6
 100e982:	f43f af24 	beq.w	100e7ce <ll_create_connection+0x442>
		     (((bit_idx < 29) && (transitions < 1)) ||
 100e986:	f1ba 0f00 	cmp.w	sl, #0
 100e98a:	d0cc      	beq.n	100e926 <ll_create_connection+0x59a>
 100e98c:	2200      	movs	r2, #0
 100e98e:	e57a      	b.n	100e486 <ll_create_connection+0xfa>
		if ((consecutive_cnt > 6) ||
 100e990:	2906      	cmp	r1, #6
 100e992:	d806      	bhi.n	100e9a2 <ll_create_connection+0x616>
 100e994:	4683      	mov	fp, r0
 100e996:	46b2      	mov	sl, r6
 100e998:	b2da      	uxtb	r2, r3
 100e99a:	e71c      	b.n	100e7d6 <ll_create_connection+0x44a>
					   (ones_count_lsb8 < 3)))) ||
 100e99c:	46b2      	mov	sl, r6
 100e99e:	4683      	mov	fp, r0
 100e9a0:	e56e      	b.n	100e480 <ll_create_connection+0xf4>
				aa |= BIT(bit_idx);
 100e9a2:	fa09 f203 	lsl.w	r2, r9, r3
 100e9a6:	4683      	mov	fp, r0
 100e9a8:	46b2      	mov	sl, r6
 100e9aa:	4315      	orrs	r5, r2
				if (bit_idx < 8) {
 100e9ac:	e7c4      	b.n	100e938 <ll_create_connection+0x5ac>
				consecutive_cnt = 1U;
 100e9ae:	f04f 0e01 	mov.w	lr, #1
 100e9b2:	e6ff      	b.n	100e7b4 <ll_create_connection+0x428>
 100e9b4:	010189ec 	.word	0x010189ec

0100e9b8 <ll_connect_disable>:
{
 100e9b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100e9bc:	4607      	mov	r7, r0
 100e9be:	b082      	sub	sp, #8
	scan = ull_scan_is_enabled_get(0);
 100e9c0:	2000      	movs	r0, #0
 100e9c2:	f7fc fac3 	bl	100af4c <ull_scan_is_enabled_get>
	if (!scan) {
 100e9c6:	b320      	cbz	r0, 100ea12 <ll_connect_disable+0x5a>
	conn_lll = scan->lll.conn;
 100e9c8:	6a46      	ldr	r6, [r0, #36]	; 0x24
	if (!conn_lll) {
 100e9ca:	4604      	mov	r4, r0
 100e9cc:	b30e      	cbz	r6, 100ea12 <ll_connect_disable+0x5a>
	status = ull_scan_disable(0, scan);
 100e9ce:	4601      	mov	r1, r0
 100e9d0:	2000      	movs	r0, #0
 100e9d2:	f7fc f9e9 	bl	100ada8 <ull_scan_disable>
	if (!status) {
 100e9d6:	4605      	mov	r5, r0
 100e9d8:	b9b8      	cbnz	r0, 100ea0a <ll_connect_disable+0x52>
		struct ll_conn *conn = (void *)HDR_LLL2EVT(conn_lll);
 100e9da:	6836      	ldr	r6, [r6, #0]
		link = cc->hdr.link;
 100e9dc:	f8d6 312c 	ldr.w	r3, [r6, #300]	; 0x12c
		cc = (void *)&conn->llcp_terminate.node_rx;
 100e9e0:	f506 7896 	add.w	r8, r6, #300	; 0x12c
		LL_ASSERT(link);
 100e9e4:	b1d3      	cbz	r3, 100ea1c <ll_connect_disable+0x64>
		ll_rx_link_release(link);
 100e9e6:	4618      	mov	r0, r3
 100e9e8:	f7fb fbb6 	bl	100a158 <ll_rx_link_release>
		cc->hdr.type = NODE_RX_TYPE_CONNECTION;
 100e9ec:	2108      	movs	r1, #8
		cc->hdr.handle = 0xffff;
 100e9ee:	f64f 72ff 	movw	r2, #65535	; 0xffff
		*((u8_t *)cc->pdu) = BT_HCI_ERR_UNKNOWN_CONN_ID;
 100e9f2:	2302      	movs	r3, #2
		ftr->param = &scan->lll;
 100e9f4:	341c      	adds	r4, #28
 100e9f6:	f8c6 4134 	str.w	r4, [r6, #308]	; 0x134
		cc->hdr.type = NODE_RX_TYPE_CONNECTION;
 100e9fa:	f886 1130 	strb.w	r1, [r6, #304]	; 0x130
		cc->hdr.handle = 0xffff;
 100e9fe:	f8a6 2132 	strh.w	r2, [r6, #306]	; 0x132
		*((u8_t *)cc->pdu) = BT_HCI_ERR_UNKNOWN_CONN_ID;
 100ea02:	f886 314c 	strb.w	r3, [r6, #332]	; 0x14c
		*rx = cc;
 100ea06:	f8c7 8000 	str.w	r8, [r7]
}
 100ea0a:	4628      	mov	r0, r5
 100ea0c:	b002      	add	sp, #8
 100ea0e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100ea12:	250c      	movs	r5, #12
}
 100ea14:	4628      	mov	r0, r5
 100ea16:	b002      	add	sp, #8
 100ea18:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		LL_ASSERT(link);
 100ea1c:	f240 1139 	movw	r1, #313	; 0x139
 100ea20:	4802      	ldr	r0, [pc, #8]	; (100ea2c <ll_connect_disable+0x74>)
 100ea22:	9301      	str	r3, [sp, #4]
 100ea24:	f7f4 fe2c 	bl	1003680 <bt_ctlr_assert_handle>
 100ea28:	9b01      	ldr	r3, [sp, #4]
 100ea2a:	e7dc      	b.n	100e9e6 <ll_connect_disable+0x2e>
 100ea2c:	010189ec 	.word	0x010189ec

0100ea30 <ll_chm_update>:
{
 100ea30:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100ea34:	4607      	mov	r7, r0
	while (handle--) {
 100ea36:	250f      	movs	r5, #15
		conn->llcp_type = LLCP_CHAN_MAP;
 100ea38:	f04f 0802 	mov.w	r8, #2
	ull_conn_chan_map_set(chm);
 100ea3c:	f7fd f9a4 	bl	100bd88 <ull_conn_chan_map_set>
	while (handle--) {
 100ea40:	f64f 76ff 	movw	r6, #65535	; 0xffff
		conn = ll_connected_get(handle);
 100ea44:	4628      	mov	r0, r5
 100ea46:	f7fc fe45 	bl	100b6d4 <ll_connected_get>
		if (!conn || conn->lll.role) {
 100ea4a:	4604      	mov	r4, r0
 100ea4c:	b1c8      	cbz	r0, 100ea82 <ll_chm_update+0x52>
 100ea4e:	f990 303d 	ldrsb.w	r3, [r0, #61]	; 0x3d
 100ea52:	2b00      	cmp	r3, #0
 100ea54:	db15      	blt.n	100ea82 <ll_chm_update+0x52>
		ret = ull_conn_llcp_req(conn);
 100ea56:	f7ff fb6d 	bl	100e134 <ull_conn_llcp_req>
		if (ret) {
 100ea5a:	b9b8      	cbnz	r0, 100ea8c <ll_chm_update+0x5c>
		memcpy(conn->llcp.chan_map.chm, chm,
 100ea5c:	2205      	movs	r2, #5
 100ea5e:	4639      	mov	r1, r7
 100ea60:	f104 00ed 	add.w	r0, r4, #237	; 0xed
 100ea64:	f007 ffd8 	bl	1016a18 <memcpy>
		conn->llcp.chan_map.initiate = 1U;
 100ea68:	f894 20ec 	ldrb.w	r2, [r4, #236]	; 0xec
		conn->llcp_req++;
 100ea6c:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
		conn->llcp.chan_map.initiate = 1U;
 100ea70:	f042 0201 	orr.w	r2, r2, #1
		conn->llcp_req++;
 100ea74:	3301      	adds	r3, #1
		conn->llcp_type = LLCP_CHAN_MAP;
 100ea76:	f884 80ea 	strb.w	r8, [r4, #234]	; 0xea
		conn->llcp.chan_map.initiate = 1U;
 100ea7a:	f884 20ec 	strb.w	r2, [r4, #236]	; 0xec
		conn->llcp_req++;
 100ea7e:	f884 30e8 	strb.w	r3, [r4, #232]	; 0xe8
	while (handle--) {
 100ea82:	3d01      	subs	r5, #1
 100ea84:	b2ad      	uxth	r5, r5
 100ea86:	42b5      	cmp	r5, r6
 100ea88:	d1dc      	bne.n	100ea44 <ll_chm_update+0x14>
	return 0;
 100ea8a:	2000      	movs	r0, #0
}
 100ea8c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0100ea90 <ll_enc_req_send>:
{
 100ea90:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 100ea94:	4688      	mov	r8, r1
 100ea96:	4616      	mov	r6, r2
 100ea98:	4699      	mov	r9, r3
 100ea9a:	4607      	mov	r7, r0
	conn = ll_connected_get(handle);
 100ea9c:	f7fc fe1a 	bl	100b6d4 <ll_connected_get>
	if (!conn) {
 100eaa0:	2800      	cmp	r0, #0
 100eaa2:	d062      	beq.n	100eb6a <ll_enc_req_send+0xda>
	if ((conn->llcp_enc.req != conn->llcp_enc.ack) ||
 100eaa4:	f890 2150 	ldrb.w	r2, [r0, #336]	; 0x150
 100eaa8:	f890 3151 	ldrb.w	r3, [r0, #337]	; 0x151
 100eaac:	4604      	mov	r4, r0
 100eaae:	429a      	cmp	r2, r3
 100eab0:	d13d      	bne.n	100eb2e <ll_enc_req_send+0x9e>
 100eab2:	f890 20e8 	ldrb.w	r2, [r0, #232]	; 0xe8
 100eab6:	f890 30e9 	ldrb.w	r3, [r0, #233]	; 0xe9
 100eaba:	429a      	cmp	r2, r3
 100eabc:	d003      	beq.n	100eac6 <ll_enc_req_send+0x36>
	    ((conn->llcp_req != conn->llcp_ack) &&
 100eabe:	f890 30ea 	ldrb.w	r3, [r0, #234]	; 0xea
 100eac2:	2b03      	cmp	r3, #3
 100eac4:	d033      	beq.n	100eb2e <ll_enc_req_send+0x9e>
	tx = ll_tx_mem_acquire();
 100eac6:	f7fc fe19 	bl	100b6fc <ll_tx_mem_acquire>
	if (tx) {
 100eaca:	4605      	mov	r5, r0
 100eacc:	b378      	cbz	r0, 100eb2e <ll_enc_req_send+0x9e>
		memcpy(&conn->llcp_enc.ltk[0], ltk, sizeof(conn->llcp_enc.ltk));
 100eace:	4649      	mov	r1, r9
 100ead0:	2210      	movs	r2, #16
 100ead2:	f204 105d 	addw	r0, r4, #349	; 0x15d
 100ead6:	f007 ff9f 	bl	1016a18 <memcpy>
		if (!conn->lll.enc_rx && !conn->lll.enc_tx) {
 100eada:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
 100eade:	f013 0318 	ands.w	r3, r3, #24
 100eae2:	d027      	beq.n	100eb34 <ll_enc_req_send+0xa4>
		} else if (conn->lll.enc_rx && conn->lll.enc_tx) {
 100eae4:	2b18      	cmp	r3, #24
 100eae6:	d11f      	bne.n	100eb28 <ll_enc_req_send+0x98>
			memcpy(&conn->llcp_enc.rand[0], rand,
 100eae8:	4641      	mov	r1, r8
 100eaea:	2208      	movs	r2, #8
 100eaec:	f204 1055 	addw	r0, r4, #341	; 0x155
 100eaf0:	f007 ff92 	bl	1016a18 <memcpy>
			pdu_data_tx->len = offsetof(struct pdu_data_llctrl,
 100eaf4:	2101      	movs	r1, #1
			pdu_data_tx->llctrl.opcode =
 100eaf6:	220a      	movs	r2, #10
			conn->llcp_enc.ediv[0] = ediv[0];
 100eaf8:	7833      	ldrb	r3, [r6, #0]
 100eafa:	f884 3153 	strb.w	r3, [r4, #339]	; 0x153
			conn->llcp_enc.ediv[1] = ediv[1];
 100eafe:	7873      	ldrb	r3, [r6, #1]
 100eb00:	f884 3154 	strb.w	r3, [r4, #340]	; 0x154
			pdu_data_tx->ll_id = PDU_DATA_LLID_CTRL;
 100eb04:	792b      	ldrb	r3, [r5, #4]
			pdu_data_tx->len = offsetof(struct pdu_data_llctrl,
 100eb06:	7169      	strb	r1, [r5, #5]
			pdu_data_tx->ll_id = PDU_DATA_LLID_CTRL;
 100eb08:	f043 0303 	orr.w	r3, r3, #3
 100eb0c:	712b      	strb	r3, [r5, #4]
			pdu_data_tx->llctrl.opcode =
 100eb0e:	71ea      	strb	r2, [r5, #7]
		if (ll_tx_mem_enqueue(handle, tx)) {
 100eb10:	4638      	mov	r0, r7
 100eb12:	4629      	mov	r1, r5
 100eb14:	f7fc fdfe 	bl	100b714 <ll_tx_mem_enqueue>
 100eb18:	b930      	cbnz	r0, 100eb28 <ll_enc_req_send+0x98>
		conn->llcp_enc.req++;
 100eb1a:	f894 3150 	ldrb.w	r3, [r4, #336]	; 0x150
 100eb1e:	3301      	adds	r3, #1
 100eb20:	f884 3150 	strb.w	r3, [r4, #336]	; 0x150
}
 100eb24:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			ll_tx_mem_release(tx);
 100eb28:	4628      	mov	r0, r5
 100eb2a:	f7fc fded 	bl	100b708 <ll_tx_mem_release>
			return BT_HCI_ERR_CMD_DISALLOWED;
 100eb2e:	200c      	movs	r0, #12
}
 100eb30:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			pdu_data_tx->llctrl.opcode =
 100eb34:	2203      	movs	r2, #3
			pdu_data_tx->ll_id = PDU_DATA_LLID_CTRL;
 100eb36:	792b      	ldrb	r3, [r5, #4]
			pdu_data_tx->llctrl.opcode =
 100eb38:	71ea      	strb	r2, [r5, #7]
			pdu_data_tx->ll_id = PDU_DATA_LLID_CTRL;
 100eb3a:	4313      	orrs	r3, r2
			pdu_data_tx->len =
 100eb3c:	2017      	movs	r0, #23
			memcpy(enc_req->rand, rand, sizeof(enc_req->rand));
 100eb3e:	2208      	movs	r2, #8
 100eb40:	4641      	mov	r1, r8
			pdu_data_tx->ll_id = PDU_DATA_LLID_CTRL;
 100eb42:	712b      	strb	r3, [r5, #4]
			pdu_data_tx->len =
 100eb44:	7168      	strb	r0, [r5, #5]
			memcpy(enc_req->rand, rand, sizeof(enc_req->rand));
 100eb46:	18a8      	adds	r0, r5, r2
 100eb48:	f007 ff66 	bl	1016a18 <memcpy>
			enc_req->ediv[0] = ediv[0];
 100eb4c:	7833      	ldrb	r3, [r6, #0]
			lll_trng_get(enc_req->skdm, sizeof(enc_req->skdm));
 100eb4e:	2108      	movs	r1, #8
			enc_req->ediv[0] = ediv[0];
 100eb50:	742b      	strb	r3, [r5, #16]
			enc_req->ediv[1] = ediv[1];
 100eb52:	7873      	ldrb	r3, [r6, #1]
			lll_trng_get(enc_req->skdm, sizeof(enc_req->skdm));
 100eb54:	f105 0012 	add.w	r0, r5, #18
			enc_req->ediv[1] = ediv[1];
 100eb58:	746b      	strb	r3, [r5, #17]
			lll_trng_get(enc_req->skdm, sizeof(enc_req->skdm));
 100eb5a:	f001 f9bb 	bl	100fed4 <lll_trng_get>
			lll_trng_get(enc_req->ivm, sizeof(enc_req->ivm));
 100eb5e:	2104      	movs	r1, #4
 100eb60:	f105 001a 	add.w	r0, r5, #26
 100eb64:	f001 f9b6 	bl	100fed4 <lll_trng_get>
 100eb68:	e7d2      	b.n	100eb10 <ll_enc_req_send+0x80>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100eb6a:	2002      	movs	r0, #2
}
 100eb6c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0100eb70 <ull_sched_after_mstr_slot_get>:

void ull_sched_after_mstr_slot_get(u8_t user_id, u32_t ticks_slot_abs,
				   u32_t *ticks_anchor, u32_t *us_offset)
{
	/* TODO: */
}
 100eb70:	4770      	bx	lr
 100eb72:	bf00      	nop

0100eb74 <ull_sched_mfy_after_mstr_offset_get>:
void ull_sched_mfy_after_mstr_offset_get(void *param)
{
	struct ll_scan_set *scan = param;

	/* TODO: */
	scan->lll.conn_win_offset_us = 0;
 100eb74:	2300      	movs	r3, #0
 100eb76:	62c3      	str	r3, [r0, #44]	; 0x2c
}
 100eb78:	4770      	bx	lr
 100eb7a:	bf00      	nop

0100eb7c <ull_sched_mfy_free_win_offset_calc>:

void ull_sched_mfy_free_win_offset_calc(void *param)
{
	/* TODO: */
}
 100eb7c:	4770      	bx	lr
 100eb7e:	bf00      	nop

0100eb80 <ull_sched_mfy_win_offset_use>:
 100eb80:	4770      	bx	lr
 100eb82:	bf00      	nop

0100eb84 <ull_sched_mfy_win_offset_select>:
 100eb84:	4770      	bx	lr
 100eb86:	bf00      	nop

0100eb88 <wl_find>:
		wl[i].taken = 0U;
	}
}

static u8_t wl_find(u8_t addr_type, u8_t *addr, u8_t *free)
{
 100eb88:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 100eb8c:	4688      	mov	r8, r1
	int i;

	if (free) {
 100eb8e:	4615      	mov	r5, r2
 100eb90:	b10a      	cbz	r2, 100eb96 <wl_find+0xe>
		*free = FILTER_IDX_NONE;
 100eb92:	23ff      	movs	r3, #255	; 0xff
 100eb94:	7013      	strb	r3, [r2, #0]
 100eb96:	4e17      	ldr	r6, [pc, #92]	; (100ebf4 <wl_find+0x6c>)
{
 100eb98:	2400      	movs	r4, #0
	}

	for (i = 0; i < WL_SIZE; i++) {
		if (LIST_MATCH(wl, i, addr_type, addr)) {
 100eb9a:	f000 0701 	and.w	r7, r0, #1
 100eb9e:	f106 0902 	add.w	r9, r6, #2
 100eba2:	e004      	b.n	100ebae <wl_find+0x26>
 100eba4:	42ba      	cmp	r2, r7
 100eba6:	d014      	beq.n	100ebd2 <wl_find+0x4a>
	for (i = 0; i < WL_SIZE; i++) {
 100eba8:	3401      	adds	r4, #1
 100ebaa:	2c08      	cmp	r4, #8
 100ebac:	d00e      	beq.n	100ebcc <wl_find+0x44>
		if (LIST_MATCH(wl, i, addr_type, addr)) {
 100ebae:	f816 3034 	ldrb.w	r3, [r6, r4, lsl #3]
 100ebb2:	07d9      	lsls	r1, r3, #31
 100ebb4:	f3c3 0240 	ubfx	r2, r3, #1, #1
 100ebb8:	d4f4      	bmi.n	100eba4 <wl_find+0x1c>
			return i;
		} else if (free && !wl[i].taken && (*free == FILTER_IDX_NONE)) {
 100ebba:	2d00      	cmp	r5, #0
 100ebbc:	d0f4      	beq.n	100eba8 <wl_find+0x20>
 100ebbe:	782b      	ldrb	r3, [r5, #0]
 100ebc0:	2bff      	cmp	r3, #255	; 0xff
			*free = i;
 100ebc2:	bf08      	it	eq
 100ebc4:	702c      	strbeq	r4, [r5, #0]
	for (i = 0; i < WL_SIZE; i++) {
 100ebc6:	3401      	adds	r4, #1
 100ebc8:	2c08      	cmp	r4, #8
 100ebca:	d1f0      	bne.n	100ebae <wl_find+0x26>
		}
	}

	return FILTER_IDX_NONE;
 100ebcc:	20ff      	movs	r0, #255	; 0xff
}
 100ebce:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (LIST_MATCH(wl, i, addr_type, addr)) {
 100ebd2:	2206      	movs	r2, #6
 100ebd4:	4641      	mov	r1, r8
 100ebd6:	eb09 00c4 	add.w	r0, r9, r4, lsl #3
 100ebda:	f007 ff0d 	bl	10169f8 <memcmp>
 100ebde:	b130      	cbz	r0, 100ebee <wl_find+0x66>
		} else if (free && !wl[i].taken && (*free == FILTER_IDX_NONE)) {
 100ebe0:	2d00      	cmp	r5, #0
 100ebe2:	d0e1      	beq.n	100eba8 <wl_find+0x20>
 100ebe4:	f816 3034 	ldrb.w	r3, [r6, r4, lsl #3]
 100ebe8:	07db      	lsls	r3, r3, #31
 100ebea:	d4dd      	bmi.n	100eba8 <wl_find+0x20>
 100ebec:	e7e7      	b.n	100ebbe <wl_find+0x36>
			return i;
 100ebee:	b2e0      	uxtb	r0, r4
 100ebf0:	e7ed      	b.n	100ebce <wl_find+0x46>
 100ebf2:	bf00      	nop
 100ebf4:	21005610 	.word	0x21005610

0100ebf8 <wl_update>:

	return BT_HCI_ERR_UNKNOWN_CONN_ID;
}

static void wl_update(void)
{
 100ebf8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 100ebfc:	2400      	movs	r4, #0
 100ebfe:	4d1c      	ldr	r5, [pc, #112]	; (100ec70 <wl_update+0x78>)
 100ec00:	f8df a074 	ldr.w	sl, [pc, #116]	; 100ec78 <wl_update+0x80>
			continue;
		}

		j = wl[i].rl_idx;

		if (!rl_enable || j >= ARRAY_SIZE(rl) || !rl[j].pirk ||
 100ec04:	4f1b      	ldr	r7, [pc, #108]	; (100ec74 <wl_update+0x7c>)
 100ec06:	f8df 8074 	ldr.w	r8, [pc, #116]	; 100ec7c <wl_update+0x84>
#endif /* !CONFIG_BT_CTLR_PRIVACY */

static void filter_insert(struct lll_filter *filter, int index, u8_t addr_type,
			   u8_t *bdaddr)
{
	filter->enable_bitmask |= BIT(index);
 100ec0a:	1eae      	subs	r6, r5, #2
 100ec0c:	f1aa 0902 	sub.w	r9, sl, #2
		if (!wl[i].taken) {
 100ec10:	f819 3034 	ldrb.w	r3, [r9, r4, lsl #3]
 100ec14:	07d9      	lsls	r1, r3, #31
 100ec16:	d522      	bpl.n	100ec5e <wl_update+0x66>
		if (!rl_enable || j >= ARRAY_SIZE(rl) || !rl[j].pirk ||
 100ec18:	783b      	ldrb	r3, [r7, #0]
 100ec1a:	b15b      	cbz	r3, 100ec34 <wl_update+0x3c>
		j = wl[i].rl_idx;
 100ec1c:	f81a 3c01 	ldrb.w	r3, [sl, #-1]
		if (!rl_enable || j >= ARRAY_SIZE(rl) || !rl[j].pirk ||
 100ec20:	2b07      	cmp	r3, #7
 100ec22:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 100ec26:	d805      	bhi.n	100ec34 <wl_update+0x3c>
 100ec28:	f818 3032 	ldrb.w	r3, [r8, r2, lsl #3]
 100ec2c:	075a      	lsls	r2, r3, #29
 100ec2e:	d501      	bpl.n	100ec34 <wl_update+0x3c>
 100ec30:	06db      	lsls	r3, r3, #27
 100ec32:	d514      	bpl.n	100ec5e <wl_update+0x66>
	filter->enable_bitmask |= BIT(index);
 100ec34:	2101      	movs	r1, #1
			filter_insert(&wl_filter, i, wl[i].id_addr_type,
 100ec36:	f819 3034 	ldrb.w	r3, [r9, r4, lsl #3]
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
 100ec3a:	7872      	ldrb	r2, [r6, #1]
	filter->enable_bitmask |= BIT(index);
 100ec3c:	f896 c000 	ldrb.w	ip, [r6]
			filter_insert(&wl_filter, i, wl[i].id_addr_type,
 100ec40:	f3c3 0340 	ubfx	r3, r3, #1, #1
	filter->enable_bitmask |= BIT(index);
 100ec44:	40a1      	lsls	r1, r4
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
 100ec46:	40a3      	lsls	r3, r4
 100ec48:	4313      	orrs	r3, r2
	filter->enable_bitmask |= BIT(index);
 100ec4a:	ea4c 0c01 	orr.w	ip, ip, r1
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
 100ec4e:	2206      	movs	r2, #6
 100ec50:	4651      	mov	r1, sl
 100ec52:	4628      	mov	r0, r5
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
 100ec54:	7073      	strb	r3, [r6, #1]
	filter->enable_bitmask |= BIT(index);
 100ec56:	f886 c000 	strb.w	ip, [r6]
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
 100ec5a:	f007 fedd 	bl	1016a18 <memcpy>
	for (i = 0U; i < WL_SIZE; i++) {
 100ec5e:	3401      	adds	r4, #1
 100ec60:	2c08      	cmp	r4, #8
 100ec62:	f105 0506 	add.w	r5, r5, #6
 100ec66:	f10a 0a08 	add.w	sl, sl, #8
 100ec6a:	d1d1      	bne.n	100ec10 <wl_update+0x18>
}
 100ec6c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 100ec70:	21005652 	.word	0x21005652
 100ec74:	210080c7 	.word	0x210080c7
 100ec78:	21005612 	.word	0x21005612
 100ec7c:	21005478 	.word	0x21005478

0100ec80 <rl_update>:
{
 100ec80:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100ec84:	f8df 8060 	ldr.w	r8, [pc, #96]	; 100ece8 <rl_update+0x68>
	filter->enable_bitmask |= BIT(index);
 100ec88:	4d16      	ldr	r5, [pc, #88]	; (100ece4 <rl_update+0x64>)
{
 100ec8a:	2400      	movs	r4, #0
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
 100ec8c:	f108 0701 	add.w	r7, r8, #1
 100ec90:	1cae      	adds	r6, r5, #2
 100ec92:	e002      	b.n	100ec9a <rl_update+0x1a>
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
 100ec94:	3401      	adds	r4, #1
 100ec96:	2c08      	cmp	r4, #8
 100ec98:	d021      	beq.n	100ecde <rl_update+0x5e>
		if (rl[i].taken) {
 100ec9a:	eb04 0184 	add.w	r1, r4, r4, lsl #2
 100ec9e:	f818 3031 	ldrb.w	r3, [r8, r1, lsl #3]
 100eca2:	00c9      	lsls	r1, r1, #3
 100eca4:	07da      	lsls	r2, r3, #31
 100eca6:	d5f5      	bpl.n	100ec94 <rl_update+0x14>
	filter->enable_bitmask |= BIT(index);
 100eca8:	f04f 0e01 	mov.w	lr, #1
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
 100ecac:	786a      	ldrb	r2, [r5, #1]
	filter->enable_bitmask |= BIT(index);
 100ecae:	f895 c000 	ldrb.w	ip, [r5]
			filter_insert(&rl_filter, i, rl[i].id_addr_type,
 100ecb2:	f3c3 1380 	ubfx	r3, r3, #6, #1
	filter->enable_bitmask |= BIT(index);
 100ecb6:	fa0e fe04 	lsl.w	lr, lr, r4
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
 100ecba:	40a3      	lsls	r3, r4
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
 100ecbc:	eb04 0044 	add.w	r0, r4, r4, lsl #1
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
 100ecc0:	4313      	orrs	r3, r2
	filter->enable_bitmask |= BIT(index);
 100ecc2:	ea4c 0c0e 	orr.w	ip, ip, lr
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
 100ecc6:	2206      	movs	r2, #6
 100ecc8:	4439      	add	r1, r7
 100ecca:	eb06 0040 	add.w	r0, r6, r0, lsl #1
 100ecce:	3401      	adds	r4, #1
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
 100ecd0:	706b      	strb	r3, [r5, #1]
	filter->enable_bitmask |= BIT(index);
 100ecd2:	f885 c000 	strb.w	ip, [r5]
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
 100ecd6:	f007 fe9f 	bl	1016a18 <memcpy>
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
 100ecda:	2c08      	cmp	r4, #8
 100ecdc:	d1dd      	bne.n	100ec9a <rl_update+0x1a>
}
 100ecde:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 100ece2:	bf00      	nop
 100ece4:	210055b8 	.word	0x210055b8
 100ece8:	21005478 	.word	0x21005478

0100ecec <rl_access_check.part.0>:
static int rl_access_check(bool check_ar)
 100ecec:	b508      	push	{r3, lr}
		(IS_ENABLED(CONFIG_BT_OBSERVER) && ull_scan_is_enabled(0)))
 100ecee:	2000      	movs	r0, #0
 100ecf0:	f7fc f948 	bl	100af84 <ull_scan_is_enabled>
}
 100ecf4:	fab0 f080 	clz	r0, r0
 100ecf8:	0940      	lsrs	r0, r0, #5
 100ecfa:	bd08      	pop	{r3, pc}

0100ecfc <ll_wl_size_get>:
}
 100ecfc:	2008      	movs	r0, #8
 100ecfe:	4770      	bx	lr

0100ed00 <ll_wl_clear>:
{
 100ed00:	b510      	push	{r4, lr}
	if (ull_adv_filter_pol_get(0)) {
 100ed02:	2000      	movs	r0, #0
 100ed04:	f7fb fffc 	bl	100ad00 <ull_adv_filter_pol_get>
 100ed08:	bb08      	cbnz	r0, 100ed4e <ll_wl_clear+0x4e>
	if (ull_scan_filter_pol_get(0) & 0x1) {
 100ed0a:	f7fc f953 	bl	100afb4 <ull_scan_filter_pol_get>
 100ed0e:	f010 0001 	ands.w	r0, r0, #1
 100ed12:	d11c      	bne.n	100ed4e <ll_wl_clear+0x4e>
 100ed14:	4a0f      	ldr	r2, [pc, #60]	; (100ed54 <ll_wl_clear+0x54>)
			rl[j].wl = 0U;
 100ed16:	4c10      	ldr	r4, [pc, #64]	; (100ed58 <ll_wl_clear+0x58>)
		u8_t j = wl[i].rl_idx;
 100ed18:	eb02 03c0 	add.w	r3, r2, r0, lsl #3
 100ed1c:	785b      	ldrb	r3, [r3, #1]
		if (j < ARRAY_SIZE(rl)) {
 100ed1e:	2b07      	cmp	r3, #7
 100ed20:	d807      	bhi.n	100ed32 <ll_wl_clear+0x32>
			rl[j].wl = 0U;
 100ed22:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 100ed26:	f814 1033 	ldrb.w	r1, [r4, r3, lsl #3]
 100ed2a:	f36f 1145 	bfc	r1, #5, #1
 100ed2e:	f804 1033 	strb.w	r1, [r4, r3, lsl #3]
		wl[i].taken = 0U;
 100ed32:	f812 3030 	ldrb.w	r3, [r2, r0, lsl #3]
 100ed36:	f36f 0300 	bfc	r3, #0, #1
 100ed3a:	f802 3030 	strb.w	r3, [r2, r0, lsl #3]
	for (int i = 0; i < WL_SIZE; i++) {
 100ed3e:	3001      	adds	r0, #1
 100ed40:	2808      	cmp	r0, #8
 100ed42:	d1e9      	bne.n	100ed18 <ll_wl_clear+0x18>
	wl_anon = 0U;
 100ed44:	2300      	movs	r3, #0
 100ed46:	4a05      	ldr	r2, [pc, #20]	; (100ed5c <ll_wl_clear+0x5c>)
	return 0;
 100ed48:	4618      	mov	r0, r3
	wl_anon = 0U;
 100ed4a:	7013      	strb	r3, [r2, #0]
}
 100ed4c:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100ed4e:	200c      	movs	r0, #12
}
 100ed50:	bd10      	pop	{r4, pc}
 100ed52:	bf00      	nop
 100ed54:	21005610 	.word	0x21005610
 100ed58:	21005478 	.word	0x21005478
 100ed5c:	210080c8 	.word	0x210080c8

0100ed60 <ll_wl_remove>:
{
 100ed60:	b538      	push	{r3, r4, r5, lr}
 100ed62:	4604      	mov	r4, r0
	if (ull_adv_filter_pol_get(0)) {
 100ed64:	2000      	movs	r0, #0
 100ed66:	f7fb ffcb 	bl	100ad00 <ull_adv_filter_pol_get>
 100ed6a:	b980      	cbnz	r0, 100ed8e <ll_wl_remove+0x2e>
	if (ull_scan_filter_pol_get(0) & 0x1) {
 100ed6c:	f7fc f922 	bl	100afb4 <ull_scan_filter_pol_get>
 100ed70:	f010 0501 	ands.w	r5, r0, #1
 100ed74:	d10b      	bne.n	100ed8e <ll_wl_remove+0x2e>
	if (addr->type == ADDR_TYPE_ANON) {
 100ed76:	7820      	ldrb	r0, [r4, #0]
 100ed78:	28ff      	cmp	r0, #255	; 0xff
 100ed7a:	d00a      	beq.n	100ed92 <ll_wl_remove+0x32>
	u8_t i = wl_find(id_addr->type, id_addr->a.val, NULL);
 100ed7c:	462a      	mov	r2, r5
 100ed7e:	1c61      	adds	r1, r4, #1
 100ed80:	f7ff ff02 	bl	100eb88 <wl_find>
	if (i < ARRAY_SIZE(wl)) {
 100ed84:	2807      	cmp	r0, #7
	u8_t i = wl_find(id_addr->type, id_addr->a.val, NULL);
 100ed86:	4603      	mov	r3, r0
	if (i < ARRAY_SIZE(wl)) {
 100ed88:	d907      	bls.n	100ed9a <ll_wl_remove+0x3a>
 100ed8a:	2002      	movs	r0, #2
}
 100ed8c:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100ed8e:	200c      	movs	r0, #12
}
 100ed90:	bd38      	pop	{r3, r4, r5, pc}
		wl_anon = 0U;
 100ed92:	4b0d      	ldr	r3, [pc, #52]	; (100edc8 <ll_wl_remove+0x68>)
		return 0;
 100ed94:	4628      	mov	r0, r5
		wl_anon = 0U;
 100ed96:	701d      	strb	r5, [r3, #0]
}
 100ed98:	bd38      	pop	{r3, r4, r5, pc}
		u8_t j = wl[i].rl_idx;
 100ed9a:	490c      	ldr	r1, [pc, #48]	; (100edcc <ll_wl_remove+0x6c>)
 100ed9c:	eb01 02c0 	add.w	r2, r1, r0, lsl #3
 100eda0:	7852      	ldrb	r2, [r2, #1]
		if (j < ARRAY_SIZE(rl)) {
 100eda2:	2a07      	cmp	r2, #7
 100eda4:	d808      	bhi.n	100edb8 <ll_wl_remove+0x58>
			rl[j].wl = 0U;
 100eda6:	480a      	ldr	r0, [pc, #40]	; (100edd0 <ll_wl_remove+0x70>)
 100eda8:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 100edac:	f810 4032 	ldrb.w	r4, [r0, r2, lsl #3]
 100edb0:	f365 1445 	bfi	r4, r5, #5, #1
 100edb4:	f800 4032 	strb.w	r4, [r0, r2, lsl #3]
		wl[i].taken = 0U;
 100edb8:	f811 2033 	ldrb.w	r2, [r1, r3, lsl #3]
		return 0;
 100edbc:	2000      	movs	r0, #0
		wl[i].taken = 0U;
 100edbe:	f36f 0200 	bfc	r2, #0, #1
 100edc2:	f801 2033 	strb.w	r2, [r1, r3, lsl #3]
}
 100edc6:	bd38      	pop	{r3, r4, r5, pc}
 100edc8:	210080c8 	.word	0x210080c8
 100edcc:	21005610 	.word	0x21005610
 100edd0:	21005478 	.word	0x21005478

0100edd4 <ll_rl_id_addr_get>:
	LL_ASSERT(rl_idx < CONFIG_BT_CTLR_RL_SIZE);
 100edd4:	2807      	cmp	r0, #7
{
 100edd6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100edda:	4604      	mov	r4, r0
 100eddc:	460f      	mov	r7, r1
 100edde:	4690      	mov	r8, r2
	LL_ASSERT(rl_idx < CONFIG_BT_CTLR_RL_SIZE);
 100ede0:	d816      	bhi.n	100ee10 <ll_rl_id_addr_get+0x3c>
	LL_ASSERT(rl[rl_idx].taken);
 100ede2:	4d10      	ldr	r5, [pc, #64]	; (100ee24 <ll_rl_id_addr_get+0x50>)
 100ede4:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 100ede8:	f815 3033 	ldrb.w	r3, [r5, r3, lsl #3]
 100edec:	00a6      	lsls	r6, r4, #2
 100edee:	07db      	lsls	r3, r3, #31
 100edf0:	d513      	bpl.n	100ee1a <ll_rl_id_addr_get+0x46>
	*id_addr_type = rl[rl_idx].id_addr_type;
 100edf2:	4434      	add	r4, r6
 100edf4:	f815 3034 	ldrb.w	r3, [r5, r4, lsl #3]
	memcpy(id_addr, rl[rl_idx].id_addr.val, BDADDR_SIZE);
 100edf8:	eb05 05c4 	add.w	r5, r5, r4, lsl #3
	*id_addr_type = rl[rl_idx].id_addr_type;
 100edfc:	f3c3 1380 	ubfx	r3, r3, #6, #1
 100ee00:	703b      	strb	r3, [r7, #0]
	memcpy(id_addr, rl[rl_idx].id_addr.val, BDADDR_SIZE);
 100ee02:	4640      	mov	r0, r8
 100ee04:	1c69      	adds	r1, r5, #1
 100ee06:	2206      	movs	r2, #6
}
 100ee08:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	memcpy(id_addr, rl[rl_idx].id_addr.val, BDADDR_SIZE);
 100ee0c:	f007 be04 	b.w	1016a18 <memcpy>
	LL_ASSERT(rl_idx < CONFIG_BT_CTLR_RL_SIZE);
 100ee10:	21e7      	movs	r1, #231	; 0xe7
 100ee12:	4805      	ldr	r0, [pc, #20]	; (100ee28 <ll_rl_id_addr_get+0x54>)
 100ee14:	f7f4 fc34 	bl	1003680 <bt_ctlr_assert_handle>
 100ee18:	e7e3      	b.n	100ede2 <ll_rl_id_addr_get+0xe>
	LL_ASSERT(rl[rl_idx].taken);
 100ee1a:	21e8      	movs	r1, #232	; 0xe8
 100ee1c:	4802      	ldr	r0, [pc, #8]	; (100ee28 <ll_rl_id_addr_get+0x54>)
 100ee1e:	f7f4 fc2f 	bl	1003680 <bt_ctlr_assert_handle>
 100ee22:	e7e6      	b.n	100edf2 <ll_rl_id_addr_get+0x1e>
 100ee24:	21005478 	.word	0x21005478
 100ee28:	01018a44 	.word	0x01018a44

0100ee2c <ll_rl_size_get>:
 100ee2c:	2008      	movs	r0, #8
 100ee2e:	4770      	bx	lr

0100ee30 <ll_rl_clear>:
{
 100ee30:	b570      	push	{r4, r5, r6, lr}
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
 100ee32:	2000      	movs	r0, #0
 100ee34:	f7fb ff58 	bl	100ace8 <ull_adv_is_enabled>
		? 0 : 1;
 100ee38:	b108      	cbz	r0, 100ee3e <ll_rl_clear+0xe>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100ee3a:	200c      	movs	r0, #12
}
 100ee3c:	bd70      	pop	{r4, r5, r6, pc}
 100ee3e:	4604      	mov	r4, r0
 100ee40:	f7ff ff54 	bl	100ecec <rl_access_check.part.0>
	if (!rl_access_check(false)) {
 100ee44:	2800      	cmp	r0, #0
 100ee46:	d0f8      	beq.n	100ee3a <ll_rl_clear+0xa>
		rl[i].taken = 0U;
 100ee48:	4b19      	ldr	r3, [pc, #100]	; (100eeb0 <ll_rl_clear+0x80>)
	peer_irk_count = 0U;
 100ee4a:	4e1a      	ldr	r6, [pc, #104]	; (100eeb4 <ll_rl_clear+0x84>)
		rl[i].taken = 0U;
 100ee4c:	7819      	ldrb	r1, [r3, #0]
 100ee4e:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
 100ee52:	f364 0100 	bfi	r1, r4, #0, #1
 100ee56:	f364 0200 	bfi	r2, r4, #0, #1
 100ee5a:	f893 5050 	ldrb.w	r5, [r3, #80]	; 0x50
 100ee5e:	7019      	strb	r1, [r3, #0]
 100ee60:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
 100ee64:	f893 1078 	ldrb.w	r1, [r3, #120]	; 0x78
 100ee68:	f893 20a0 	ldrb.w	r2, [r3, #160]	; 0xa0
 100ee6c:	f364 0500 	bfi	r5, r4, #0, #1
 100ee70:	f364 0100 	bfi	r1, r4, #0, #1
 100ee74:	f364 0200 	bfi	r2, r4, #0, #1
 100ee78:	f883 5050 	strb.w	r5, [r3, #80]	; 0x50
 100ee7c:	f883 1078 	strb.w	r1, [r3, #120]	; 0x78
 100ee80:	f893 50c8 	ldrb.w	r5, [r3, #200]	; 0xc8
 100ee84:	f893 10f0 	ldrb.w	r1, [r3, #240]	; 0xf0
 100ee88:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0
 100ee8c:	f893 2118 	ldrb.w	r2, [r3, #280]	; 0x118
 100ee90:	f364 0500 	bfi	r5, r4, #0, #1
 100ee94:	f364 0100 	bfi	r1, r4, #0, #1
 100ee98:	f364 0200 	bfi	r2, r4, #0, #1
	return 0;
 100ee9c:	4620      	mov	r0, r4
		rl[i].taken = 0U;
 100ee9e:	f883 50c8 	strb.w	r5, [r3, #200]	; 0xc8
 100eea2:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
 100eea6:	f883 2118 	strb.w	r2, [r3, #280]	; 0x118
	peer_irk_count = 0U;
 100eeaa:	7034      	strb	r4, [r6, #0]
}
 100eeac:	bd70      	pop	{r4, r5, r6, pc}
 100eeae:	bf00      	nop
 100eeb0:	21005478 	.word	0x21005478
 100eeb4:	210080c6 	.word	0x210080c6

0100eeb8 <ll_rl_enable>:
{
 100eeb8:	b538      	push	{r3, r4, r5, lr}
 100eeba:	4605      	mov	r5, r0
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
 100eebc:	2000      	movs	r0, #0
 100eebe:	f7fb ff13 	bl	100ace8 <ull_adv_is_enabled>
		? 0 : 1;
 100eec2:	b108      	cbz	r0, 100eec8 <ll_rl_enable+0x10>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100eec4:	200c      	movs	r0, #12
}
 100eec6:	bd38      	pop	{r3, r4, r5, pc}
 100eec8:	4604      	mov	r4, r0
 100eeca:	f7ff ff0f 	bl	100ecec <rl_access_check.part.0>
	if (!rl_access_check(false)) {
 100eece:	2800      	cmp	r0, #0
 100eed0:	d0f8      	beq.n	100eec4 <ll_rl_enable+0xc>
	switch (enable) {
 100eed2:	b13d      	cbz	r5, 100eee4 <ll_rl_enable+0x2c>
 100eed4:	2d01      	cmp	r5, #1
 100eed6:	d001      	beq.n	100eedc <ll_rl_enable+0x24>
 100eed8:	2012      	movs	r0, #18
}
 100eeda:	bd38      	pop	{r3, r4, r5, pc}
		rl_enable = 1U;
 100eedc:	4b03      	ldr	r3, [pc, #12]	; (100eeec <ll_rl_enable+0x34>)
	return 0;
 100eede:	4620      	mov	r0, r4
		rl_enable = 1U;
 100eee0:	701d      	strb	r5, [r3, #0]
}
 100eee2:	bd38      	pop	{r3, r4, r5, pc}
		rl_enable = 0U;
 100eee4:	4b01      	ldr	r3, [pc, #4]	; (100eeec <ll_rl_enable+0x34>)
	return 0;
 100eee6:	4628      	mov	r0, r5
		rl_enable = 0U;
 100eee8:	701d      	strb	r5, [r3, #0]
}
 100eeea:	bd38      	pop	{r3, r4, r5, pc}
 100eeec:	210080c7 	.word	0x210080c7

0100eef0 <ll_rl_timeout_set>:
	rpa_timeout_ms = timeout * 1000U;
 100eef0:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 100eef4:	fb03 f300 	mul.w	r3, r3, r0
 100eef8:	4a01      	ldr	r2, [pc, #4]	; (100ef00 <ll_rl_timeout_set+0x10>)
 100eefa:	6013      	str	r3, [r2, #0]
}
 100eefc:	4770      	bx	lr
 100eefe:	bf00      	nop
 100ef00:	210055ec 	.word	0x210055ec

0100ef04 <ull_filter_adv_scan_state_cb>:
	if (bm) {
 100ef04:	b1b0      	cbz	r0, 100ef34 <ull_filter_adv_scan_state_cb+0x30>
{
 100ef06:	b570      	push	{r4, r5, r6, lr}
		} else {
			return t * (to_hz / from_hz);
		}
	} else {
		if (result32) {
			return (u32_t)((t * to_hz + off) / from_hz);
 100ef08:	f240 30e7 	movw	r0, #999	; 0x3e7
 100ef0c:	f44f 4400 	mov.w	r4, #32768	; 0x8000
 100ef10:	2100      	movs	r1, #0
	k_delayed_work_submit(&rpa_work, K_MSEC(rpa_timeout_ms));
 100ef12:	4d0a      	ldr	r5, [pc, #40]	; (100ef3c <ull_filter_adv_scan_state_cb+0x38>)
 100ef14:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 100ef18:	682d      	ldr	r5, [r5, #0]
 100ef1a:	2300      	movs	r3, #0
 100ef1c:	fbe4 0105 	umlal	r0, r1, r4, r5
 100ef20:	f7f1 f8ca 	bl	10000b8 <__aeabi_uldivmod>
}
 100ef24:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 100ef28:	4602      	mov	r2, r0
 * @retval -EADDRINUSE Work item is pending on a different workqueue.
 */
static inline int k_delayed_work_submit(struct k_delayed_work *work,
					k_timeout_t delay)
{
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
 100ef2a:	2300      	movs	r3, #0
 100ef2c:	4904      	ldr	r1, [pc, #16]	; (100ef40 <ull_filter_adv_scan_state_cb+0x3c>)
 100ef2e:	4805      	ldr	r0, [pc, #20]	; (100ef44 <ull_filter_adv_scan_state_cb+0x40>)
 100ef30:	f005 bd7c 	b.w	1014a2c <k_delayed_work_submit_to_queue>
	k_delayed_work_cancel(&rpa_work);
 100ef34:	4802      	ldr	r0, [pc, #8]	; (100ef40 <ull_filter_adv_scan_state_cb+0x3c>)
 100ef36:	f008 bef3 	b.w	1017d20 <k_delayed_work_cancel>
 100ef3a:	bf00      	nop
 100ef3c:	210055ec 	.word	0x210055ec
 100ef40:	210055f0 	.word	0x210055f0
 100ef44:	21007fc8 	.word	0x21007fc8

0100ef48 <ull_filter_adv_update>:
{
 100ef48:	b508      	push	{r3, lr}
}

static void filter_clear(struct lll_filter *filter)
{
	filter->enable_bitmask = 0;
 100ef4a:	2300      	movs	r3, #0
 100ef4c:	4a0c      	ldr	r2, [pc, #48]	; (100ef80 <ull_filter_adv_update+0x38>)
 100ef4e:	8013      	strh	r3, [r2, #0]
	if (adv_fp &&
 100ef50:	b970      	cbnz	r0, 100ef70 <ull_filter_adv_update+0x28>
	filter->enable_bitmask = 0;
 100ef52:	2000      	movs	r0, #0
	if (rl_enable &&
 100ef54:	4b0b      	ldr	r3, [pc, #44]	; (100ef84 <ull_filter_adv_update+0x3c>)
	filter->enable_bitmask = 0;
 100ef56:	4a0c      	ldr	r2, [pc, #48]	; (100ef88 <ull_filter_adv_update+0x40>)
	if (rl_enable &&
 100ef58:	781b      	ldrb	r3, [r3, #0]
	filter->enable_bitmask = 0;
 100ef5a:	8010      	strh	r0, [r2, #0]
	if (rl_enable &&
 100ef5c:	b903      	cbnz	r3, 100ef60 <ull_filter_adv_update+0x18>
}
 100ef5e:	bd08      	pop	{r3, pc}
	    (!IS_ENABLED(CONFIG_BT_OBSERVER) || !ull_scan_is_enabled(0))) {
 100ef60:	f7fc f810 	bl	100af84 <ull_scan_is_enabled>
	if (rl_enable &&
 100ef64:	2800      	cmp	r0, #0
 100ef66:	d1fa      	bne.n	100ef5e <ull_filter_adv_update+0x16>
}
 100ef68:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		rl_update();
 100ef6c:	f7ff be88 	b.w	100ec80 <rl_update>
	     !(ull_scan_filter_pol_get(0) & 0x1))) {
 100ef70:	4618      	mov	r0, r3
 100ef72:	f7fc f81f 	bl	100afb4 <ull_scan_filter_pol_get>
	if (adv_fp &&
 100ef76:	07c3      	lsls	r3, r0, #31
 100ef78:	d4eb      	bmi.n	100ef52 <ull_filter_adv_update+0xa>
		wl_update();
 100ef7a:	f7ff fe3d 	bl	100ebf8 <wl_update>
 100ef7e:	e7e8      	b.n	100ef52 <ull_filter_adv_update+0xa>
 100ef80:	21005650 	.word	0x21005650
 100ef84:	210080c7 	.word	0x210080c7
 100ef88:	210055b8 	.word	0x210055b8

0100ef8c <ull_filter_scan_update>:
{
 100ef8c:	b508      	push	{r3, lr}
	filter->enable_bitmask = 0;
 100ef8e:	2300      	movs	r3, #0
 100ef90:	4a0d      	ldr	r2, [pc, #52]	; (100efc8 <ull_filter_scan_update+0x3c>)
 100ef92:	8013      	strh	r3, [r2, #0]
	if ((scan_fp & 0x1) &&
 100ef94:	07c2      	lsls	r2, r0, #31
 100ef96:	d40e      	bmi.n	100efb6 <ull_filter_scan_update+0x2a>
	filter->enable_bitmask = 0;
 100ef98:	2000      	movs	r0, #0
	if (rl_enable &&
 100ef9a:	4b0c      	ldr	r3, [pc, #48]	; (100efcc <ull_filter_scan_update+0x40>)
	filter->enable_bitmask = 0;
 100ef9c:	4a0c      	ldr	r2, [pc, #48]	; (100efd0 <ull_filter_scan_update+0x44>)
	if (rl_enable &&
 100ef9e:	781b      	ldrb	r3, [r3, #0]
	filter->enable_bitmask = 0;
 100efa0:	8010      	strh	r0, [r2, #0]
	if (rl_enable &&
 100efa2:	b903      	cbnz	r3, 100efa6 <ull_filter_scan_update+0x1a>
}
 100efa4:	bd08      	pop	{r3, pc}
	    (!IS_ENABLED(CONFIG_BT_BROADCASTER) || !ull_adv_is_enabled(0))) {
 100efa6:	f7fb fe9f 	bl	100ace8 <ull_adv_is_enabled>
	if (rl_enable &&
 100efaa:	2800      	cmp	r0, #0
 100efac:	d1fa      	bne.n	100efa4 <ull_filter_scan_update+0x18>
}
 100efae:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		rl_update();
 100efb2:	f7ff be65 	b.w	100ec80 <rl_update>
	     !ull_adv_filter_pol_get(0))) {
 100efb6:	4618      	mov	r0, r3
 100efb8:	f7fb fea2 	bl	100ad00 <ull_adv_filter_pol_get>
	if ((scan_fp & 0x1) &&
 100efbc:	2800      	cmp	r0, #0
 100efbe:	d1eb      	bne.n	100ef98 <ull_filter_scan_update+0xc>
		wl_update();
 100efc0:	f7ff fe1a 	bl	100ebf8 <wl_update>
 100efc4:	e7e8      	b.n	100ef98 <ull_filter_scan_update+0xc>
 100efc6:	bf00      	nop
 100efc8:	21005650 	.word	0x21005650
 100efcc:	210080c7 	.word	0x210080c7
 100efd0:	210055b8 	.word	0x210055b8

0100efd4 <ull_filter_adv_pdu_update>:
{
 100efd4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	u8_t idx = adv->lll.rl_idx;
 100efd8:	f890 602a 	ldrb.w	r6, [r0, #42]	; 0x2a
{
 100efdc:	4607      	mov	r7, r0
	if (idx < ARRAY_SIZE(rl) && rl[idx].lirk) {
 100efde:	2e07      	cmp	r6, #7
{
 100efe0:	460c      	mov	r4, r1
				  &pdu->scan_rsp.addr[0] :
 100efe2:	f101 0502 	add.w	r5, r1, #2
	if (idx < ARRAY_SIZE(rl) && rl[idx].lirk) {
 100efe6:	d848      	bhi.n	100f07a <ull_filter_adv_pdu_update+0xa6>
 100efe8:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 100f0d0 <ull_filter_adv_pdu_update+0xfc>
 100efec:	eb06 0386 	add.w	r3, r6, r6, lsl #2
 100eff0:	f819 3033 	ldrb.w	r3, [r9, r3, lsl #3]
 100eff4:	ea4f 0886 	mov.w	r8, r6, lsl #2
 100eff8:	0719      	lsls	r1, r3, #28
 100effa:	d52a      	bpl.n	100f052 <ull_filter_adv_pdu_update+0x7e>
		LL_ASSERT(rl[idx].rpas_ready);
 100effc:	079a      	lsls	r2, r3, #30
 100effe:	d55e      	bpl.n	100f0be <ull_filter_adv_pdu_update+0xea>
		pdu->tx_addr = 1;
 100f000:	7822      	ldrb	r2, [r4, #0]
		memcpy(adva, rl[idx].local_rpa->val, BDADDR_SIZE);
 100f002:	eb08 0306 	add.w	r3, r8, r6
 100f006:	eb09 03c3 	add.w	r3, r9, r3, lsl #3
		pdu->tx_addr = 1;
 100f00a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
		memcpy(adva, rl[idx].local_rpa->val, BDADDR_SIZE);
 100f00e:	6a59      	ldr	r1, [r3, #36]	; 0x24
		pdu->tx_addr = 1;
 100f010:	7022      	strb	r2, [r4, #0]
		memcpy(adva, rl[idx].local_rpa->val, BDADDR_SIZE);
 100f012:	4628      	mov	r0, r5
 100f014:	2206      	movs	r2, #6
 100f016:	f007 fcff 	bl	1016a18 <memcpy>
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
 100f01a:	7823      	ldrb	r3, [r4, #0]
 100f01c:	f003 030f 	and.w	r3, r3, #15
 100f020:	2b01      	cmp	r3, #1
 100f022:	d128      	bne.n	100f076 <ull_filter_adv_pdu_update+0xa2>
		if (idx < ARRAY_SIZE(rl) && rl[idx].pirk) {
 100f024:	4446      	add	r6, r8
 100f026:	f819 3036 	ldrb.w	r3, [r9, r6, lsl #3]
 100f02a:	00f6      	lsls	r6, r6, #3
 100f02c:	075b      	lsls	r3, r3, #29
 100f02e:	d438      	bmi.n	100f0a2 <ull_filter_adv_pdu_update+0xce>
			pdu->rx_addr = adv->id_addr_type;
 100f030:	4620      	mov	r0, r4
 100f032:	f897 30da 	ldrb.w	r3, [r7, #218]	; 0xda
 100f036:	7822      	ldrb	r2, [r4, #0]
 100f038:	f3c3 0380 	ubfx	r3, r3, #2, #1
 100f03c:	f363 12c7 	bfi	r2, r3, #7, #1
 100f040:	f800 2b08 	strb.w	r2, [r0], #8
			memcpy(&pdu->direct_ind.tgt_addr[0],
 100f044:	f107 01db 	add.w	r1, r7, #219	; 0xdb
 100f048:	2206      	movs	r2, #6
}
 100f04a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			memcpy(&pdu->direct_ind.tgt_addr[0],
 100f04e:	f007 bce3 	b.w	1016a18 <memcpy>
		pdu->tx_addr = adv->own_addr_type & 0x1;
 100f052:	f890 00da 	ldrb.w	r0, [r0, #218]	; 0xda
 100f056:	7823      	ldrb	r3, [r4, #0]
 100f058:	f000 0003 	and.w	r0, r0, #3
 100f05c:	f360 1386 	bfi	r3, r0, #6, #1
 100f060:	7023      	strb	r3, [r4, #0]
		ll_addr_get(adv->own_addr_type & 0x1, adva);
 100f062:	4629      	mov	r1, r5
 100f064:	f000 0001 	and.w	r0, r0, #1
 100f068:	f7f8 f9a0 	bl	10073ac <ll_addr_get>
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
 100f06c:	7823      	ldrb	r3, [r4, #0]
 100f06e:	f003 030f 	and.w	r3, r3, #15
 100f072:	2b01      	cmp	r3, #1
 100f074:	d0d6      	beq.n	100f024 <ull_filter_adv_pdu_update+0x50>
}
 100f076:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		pdu->tx_addr = adv->own_addr_type & 0x1;
 100f07a:	f890 00da 	ldrb.w	r0, [r0, #218]	; 0xda
 100f07e:	780b      	ldrb	r3, [r1, #0]
 100f080:	f000 0003 	and.w	r0, r0, #3
 100f084:	f360 1386 	bfi	r3, r0, #6, #1
 100f088:	7023      	strb	r3, [r4, #0]
		ll_addr_get(adv->own_addr_type & 0x1, adva);
 100f08a:	4629      	mov	r1, r5
 100f08c:	f000 0001 	and.w	r0, r0, #1
 100f090:	f7f8 f98c 	bl	10073ac <ll_addr_get>
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
 100f094:	7823      	ldrb	r3, [r4, #0]
 100f096:	f003 030f 	and.w	r3, r3, #15
 100f09a:	2b01      	cmp	r3, #1
 100f09c:	d0c8      	beq.n	100f030 <ull_filter_adv_pdu_update+0x5c>
}
 100f09e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			pdu->rx_addr = 1;
 100f0a2:	4620      	mov	r0, r4
 100f0a4:	7823      	ldrb	r3, [r4, #0]
			       rl[idx].peer_rpa.val, BDADDR_SIZE);
 100f0a6:	361e      	adds	r6, #30
			pdu->rx_addr = 1;
 100f0a8:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 100f0ac:	f800 3b08 	strb.w	r3, [r0], #8
			memcpy(&pdu->direct_ind.tgt_addr[0],
 100f0b0:	eb09 0106 	add.w	r1, r9, r6
 100f0b4:	2206      	movs	r2, #6
}
 100f0b6:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			memcpy(&pdu->direct_ind.tgt_addr[0],
 100f0ba:	f007 bcad 	b.w	1016a18 <memcpy>
		LL_ASSERT(rl[idx].rpas_ready);
 100f0be:	f240 214a 	movw	r1, #586	; 0x24a
 100f0c2:	4802      	ldr	r0, [pc, #8]	; (100f0cc <ull_filter_adv_pdu_update+0xf8>)
 100f0c4:	f7f4 fadc 	bl	1003680 <bt_ctlr_assert_handle>
 100f0c8:	e79a      	b.n	100f000 <ull_filter_adv_pdu_update+0x2c>
 100f0ca:	bf00      	nop
 100f0cc:	01018a44 	.word	0x01018a44
 100f0d0:	21005478 	.word	0x21005478

0100f0d4 <ull_filter_rpa_update>:
{
 100f0d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100f0d8:	4682      	mov	sl, r0
 100f0da:	b087      	sub	sp, #28
	return z_impl_k_uptime_ticks();
 100f0dc:	f008 fe79 	bl	1017dd2 <z_impl_k_uptime_ticks>
		} else {
			return (t * to_hz + off) / from_hz;
 100f0e0:	0142      	lsls	r2, r0, #5
 100f0e2:	014b      	lsls	r3, r1, #5
 100f0e4:	ebb2 0800 	subs.w	r8, r2, r0
 100f0e8:	ea43 63d0 	orr.w	r3, r3, r0, lsr #27
 100f0ec:	eb63 0301 	sbc.w	r3, r3, r1
 100f0f0:	009b      	lsls	r3, r3, #2
 100f0f2:	ea4f 0288 	mov.w	r2, r8, lsl #2
 100f0f6:	ea43 7398 	orr.w	r3, r3, r8, lsr #30
 100f0fa:	eb12 0800 	adds.w	r8, r2, r0
 100f0fe:	eb43 0101 	adc.w	r1, r3, r1
 100f102:	00c9      	lsls	r1, r1, #3
 100f104:	ea41 7158 	orr.w	r1, r1, r8, lsr #29
 100f108:	ea4f 03c8 	mov.w	r3, r8, lsl #3
 100f10c:	ea4f 38d3 	mov.w	r8, r3, lsr #15
 100f110:	0bc8      	lsrs	r0, r1, #15
 100f112:	ea48 4841 	orr.w	r8, r8, r1, lsl #17
 100f116:	9001      	str	r0, [sp, #4]
	bool all = timeout || (rpa_last_ms == -1) ||
 100f118:	f1ba 0f00 	cmp.w	sl, #0
 100f11c:	d117      	bne.n	100f14e <ull_filter_rpa_update+0x7a>
 100f11e:	4b6a      	ldr	r3, [pc, #424]	; (100f2c8 <ull_filter_rpa_update+0x1f4>)
 100f120:	e9d3 6700 	ldrd	r6, r7, [r3]
 100f124:	1c79      	adds	r1, r7, #1
 100f126:	bf08      	it	eq
 100f128:	f1b6 3fff 	cmpeq.w	r6, #4294967295
 100f12c:	d00f      	beq.n	100f14e <ull_filter_rpa_update+0x7a>
		   (now - rpa_last_ms >= rpa_timeout_ms);
 100f12e:	2300      	movs	r3, #0
 100f130:	4966      	ldr	r1, [pc, #408]	; (100f2cc <ull_filter_rpa_update+0x1f8>)
 100f132:	ebb8 0406 	subs.w	r4, r8, r6
 100f136:	680a      	ldr	r2, [r1, #0]
 100f138:	eb60 0507 	sbc.w	r5, r0, r7
	bool all = timeout || (rpa_last_ms == -1) ||
 100f13c:	4294      	cmp	r4, r2
 100f13e:	eb75 0303 	sbcs.w	r3, r5, r3
 100f142:	bfac      	ite	ge
 100f144:	f04f 0901 	movge.w	r9, #1
 100f148:	f04f 0900 	movlt.w	r9, #0
 100f14c:	e001      	b.n	100f152 <ull_filter_rpa_update+0x7e>
 100f14e:	f04f 0901 	mov.w	r9, #1
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
 100f152:	4e5f      	ldr	r6, [pc, #380]	; (100f2d0 <ull_filter_rpa_update+0x1fc>)
	bool all = timeout || (rpa_last_ms == -1) ||
 100f154:	2400      	movs	r4, #0
 100f156:	4633      	mov	r3, r6
 100f158:	f1a6 0724 	sub.w	r7, r6, #36	; 0x24
 100f15c:	464e      	mov	r6, r9
 100f15e:	4699      	mov	r9, r3
				LL_ASSERT(!err);
 100f160:	f8df b178 	ldr.w	fp, [pc, #376]	; 100f2dc <ull_filter_rpa_update+0x208>
		if ((rl[i].taken) && (all || !rl[i].rpas_ready)) {
 100f164:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 100f168:	f817 3033 	ldrb.w	r3, [r7, r3, lsl #3]
 100f16c:	00a5      	lsls	r5, r4, #2
 100f16e:	07da      	lsls	r2, r3, #31
 100f170:	d513      	bpl.n	100f19a <ull_filter_rpa_update+0xc6>
 100f172:	b90e      	cbnz	r6, 100f178 <ull_filter_rpa_update+0xa4>
 100f174:	0798      	lsls	r0, r3, #30
 100f176:	d410      	bmi.n	100f19a <ull_filter_rpa_update+0xc6>
			if (rl[i].pirk) {
 100f178:	192b      	adds	r3, r5, r4
 100f17a:	f817 3033 	ldrb.w	r3, [r7, r3, lsl #3]
 100f17e:	0759      	lsls	r1, r3, #29
 100f180:	d434      	bmi.n	100f1ec <ull_filter_rpa_update+0x118>
			if (rl[i].lirk) {
 100f182:	192b      	adds	r3, r5, r4
 100f184:	f817 3033 	ldrb.w	r3, [r7, r3, lsl #3]
 100f188:	071a      	lsls	r2, r3, #28
 100f18a:	d417      	bmi.n	100f1bc <ull_filter_rpa_update+0xe8>
			rl[i].rpas_ready = 1U;
 100f18c:	4425      	add	r5, r4
 100f18e:	f817 3035 	ldrb.w	r3, [r7, r5, lsl #3]
 100f192:	f043 0302 	orr.w	r3, r3, #2
 100f196:	f807 3035 	strb.w	r3, [r7, r5, lsl #3]
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
 100f19a:	3401      	adds	r4, #1
 100f19c:	2c08      	cmp	r4, #8
 100f19e:	f109 0928 	add.w	r9, r9, #40	; 0x28
 100f1a2:	d1df      	bne.n	100f164 <ull_filter_rpa_update+0x90>
	if (all) {
 100f1a4:	b126      	cbz	r6, 100f1b0 <ull_filter_rpa_update+0xdc>
		rpa_last_ms = now;
 100f1a6:	4b48      	ldr	r3, [pc, #288]	; (100f2c8 <ull_filter_rpa_update+0x1f4>)
 100f1a8:	9a01      	ldr	r2, [sp, #4]
 100f1aa:	f8c3 8000 	str.w	r8, [r3]
 100f1ae:	605a      	str	r2, [r3, #4]
	if (timeout) {
 100f1b0:	f1ba 0f00 	cmp.w	sl, #0
 100f1b4:	d137      	bne.n	100f226 <ull_filter_rpa_update+0x152>
}
 100f1b6:	b007      	add	sp, #28
 100f1b8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				err = bt_rpa_create(rl[i].local_irk, &rpa);
 100f1bc:	a902      	add	r1, sp, #8
 100f1be:	f1a9 001d 	sub.w	r0, r9, #29
 100f1c2:	f007 fcaa 	bl	1016b1a <bt_rpa_create>
				LL_ASSERT(!err);
 100f1c6:	2800      	cmp	r0, #0
 100f1c8:	d16c      	bne.n	100f2a4 <ull_filter_rpa_update+0x1d0>
				rl[i].local_rpa = &rpa;
 100f1ca:	4a42      	ldr	r2, [pc, #264]	; (100f2d4 <ull_filter_rpa_update+0x200>)
 100f1cc:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 100f1d0:	eb02 0343 	add.w	r3, r2, r3, lsl #1
	memcpy(dst, src, sizeof(*dst));
 100f1d4:	a902      	add	r1, sp, #8
 100f1d6:	4618      	mov	r0, r3
 100f1d8:	2206      	movs	r2, #6
 100f1da:	f8c9 1000 	str.w	r1, [r9]
 100f1de:	9300      	str	r3, [sp, #0]
 100f1e0:	f007 fc1a 	bl	1016a18 <memcpy>
				rl[i].local_rpa = &local_rpas[i];
 100f1e4:	9b00      	ldr	r3, [sp, #0]
 100f1e6:	f8c9 3000 	str.w	r3, [r9]
 100f1ea:	e7cf      	b.n	100f18c <ull_filter_rpa_update+0xb8>

	__ASSERT(((psrc < pdst && (psrc + length) <= pdst) ||
		  (psrc > pdst && (pdst + length) <= psrc)),
		 "Source and destination buffers must not overlap");

	psrc += length - 1;
 100f1ec:	f819 2c0d 	ldrb.w	r2, [r9, #-13]
 100f1f0:	4939      	ldr	r1, [pc, #228]	; (100f2d8 <ull_filter_rpa_update+0x204>)
 100f1f2:	f10d 0307 	add.w	r3, sp, #7
 100f1f6:	eb01 1202 	add.w	r2, r1, r2, lsl #4
 100f1fa:	320f      	adds	r2, #15

	for (; length > 0; length--) {
 100f1fc:	f10d 0017 	add.w	r0, sp, #23
		*pdst++ = *psrc--;
 100f200:	f812 1901 	ldrb.w	r1, [r2], #-1
 100f204:	f803 1f01 	strb.w	r1, [r3, #1]!
	for (; length > 0; length--) {
 100f208:	4283      	cmp	r3, r0
 100f20a:	d1f9      	bne.n	100f200 <ull_filter_rpa_update+0x12c>
				err = bt_rpa_create(irk, &rl[i].peer_rpa);
 100f20c:	f1a9 0106 	sub.w	r1, r9, #6
 100f210:	a802      	add	r0, sp, #8
 100f212:	f007 fc82 	bl	1016b1a <bt_rpa_create>
				LL_ASSERT(!err);
 100f216:	2800      	cmp	r0, #0
 100f218:	d0b3      	beq.n	100f182 <ull_filter_rpa_update+0xae>
 100f21a:	f44f 7105 	mov.w	r1, #532	; 0x214
 100f21e:	4658      	mov	r0, fp
 100f220:	f7f4 fa2e 	bl	1003680 <bt_ctlr_assert_handle>
 100f224:	e7ad      	b.n	100f182 <ull_filter_rpa_update+0xae>
		adv = ull_adv_is_enabled_get(0);
 100f226:	2000      	movs	r0, #0
 100f228:	f7fb fd50 	bl	100accc <ull_adv_is_enabled_get>
		if (adv) {
 100f22c:	4604      	mov	r4, r0
 100f22e:	2800      	cmp	r0, #0
 100f230:	d0c1      	beq.n	100f1b6 <ull_filter_rpa_update+0xe2>
	if (adv->own_addr_type != BT_ADDR_LE_PUBLIC_ID &&
 100f232:	f890 30da 	ldrb.w	r3, [r0, #218]	; 0xda
 100f236:	079b      	lsls	r3, r3, #30
 100f238:	d5bd      	bpl.n	100f1b6 <ull_filter_rpa_update+0xe2>
	if (adv->lll.rl_idx >= ARRAY_SIZE(rl)) {
 100f23a:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
 100f23e:	2b07      	cmp	r3, #7
 100f240:	d8b9      	bhi.n	100f1b6 <ull_filter_rpa_update+0xe2>
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 100f242:	f890 502c 	ldrb.w	r5, [r0, #44]	; 0x2c
	if (pdu->first == pdu->last) {
 100f246:	f890 002b 	ldrb.w	r0, [r0, #43]	; 0x2b
 100f24a:	eb05 0385 	add.w	r3, r5, r5, lsl #2
 100f24e:	ebc5 03c3 	rsb	r3, r5, r3, lsl #3
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 100f252:	f103 0211 	add.w	r2, r3, #17
 100f256:	f104 011c 	add.w	r1, r4, #28
	if (pdu->first == pdu->last) {
 100f25a:	42a8      	cmp	r0, r5
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 100f25c:	eb01 0602 	add.w	r6, r1, r2
	if (pdu->first == pdu->last) {
 100f260:	d026      	beq.n	100f2b0 <ull_filter_rpa_update+0x1dc>
 100f262:	3302      	adds	r3, #2
		pdu->chan_sel = prev->chan_sel;
 100f264:	5c8a      	ldrb	r2, [r1, r2]
	return (void *)pdu->pdu[last];
 100f266:	f104 012b 	add.w	r1, r4, #43	; 0x2b
	pdu->type = prev->type;
 100f26a:	5cc8      	ldrb	r0, [r1, r3]
		pdu->chan_sel = prev->chan_sel;
 100f26c:	f3c2 1740 	ubfx	r7, r2, #5, #1
	pdu->type = prev->type;
 100f270:	f3c2 0203 	ubfx	r2, r2, #0, #4
 100f274:	ea42 1247 	orr.w	r2, r2, r7, lsl #5
 100f278:	f020 003f 	bic.w	r0, r0, #63	; 0x3f
 100f27c:	18cf      	adds	r7, r1, r3
 100f27e:	4302      	orrs	r2, r0
 100f280:	54ca      	strb	r2, [r1, r3]
	ull_filter_adv_pdu_update(adv, pdu);
 100f282:	4620      	mov	r0, r4
 100f284:	4639      	mov	r1, r7
 100f286:	f7ff fea5 	bl	100efd4 <ull_filter_adv_pdu_update>
	       prev->len - BDADDR_SIZE);
 100f28a:	7872      	ldrb	r2, [r6, #1]
	memcpy(&pdu->adv_ind.data[0], &prev->adv_ind.data[0],
 100f28c:	f107 0008 	add.w	r0, r7, #8
 100f290:	3a06      	subs	r2, #6
 100f292:	f106 0108 	add.w	r1, r6, #8
 100f296:	f007 fbbf 	bl	1016a18 <memcpy>
	pdu->len = prev->len;
 100f29a:	7873      	ldrb	r3, [r6, #1]
 100f29c:	707b      	strb	r3, [r7, #1]
	pdu->last = idx;
 100f29e:	f884 502c 	strb.w	r5, [r4, #44]	; 0x2c
}
 100f2a2:	e788      	b.n	100f1b6 <ull_filter_rpa_update+0xe2>
				LL_ASSERT(!err);
 100f2a4:	f240 2121 	movw	r1, #545	; 0x221
 100f2a8:	4658      	mov	r0, fp
 100f2aa:	f7f4 f9e9 	bl	1003680 <bt_ctlr_assert_handle>
 100f2ae:	e78c      	b.n	100f1ca <ull_filter_rpa_update+0xf6>
		last = pdu->last + 1;
 100f2b0:	3501      	adds	r5, #1
 100f2b2:	b2ed      	uxtb	r5, r5
		if (last == DOUBLE_BUFFER_SIZE) {
 100f2b4:	2d02      	cmp	r5, #2
 100f2b6:	d004      	beq.n	100f2c2 <ull_filter_rpa_update+0x1ee>
 100f2b8:	eb05 0385 	add.w	r3, r5, r5, lsl #2
 100f2bc:	ebc5 03c3 	rsb	r3, r5, r3, lsl #3
 100f2c0:	e7cf      	b.n	100f262 <ull_filter_rpa_update+0x18e>
 100f2c2:	462b      	mov	r3, r5
			last = 0U;
 100f2c4:	2500      	movs	r5, #0
 100f2c6:	e7cd      	b.n	100f264 <ull_filter_rpa_update+0x190>
 100f2c8:	21000720 	.word	0x21000720
 100f2cc:	210055ec 	.word	0x210055ec
 100f2d0:	2100549c 	.word	0x2100549c
 100f2d4:	210053c0 	.word	0x210053c0
 100f2d8:	210053f8 	.word	0x210053f8
 100f2dc:	01018a44 	.word	0x01018a44

0100f2e0 <rpa_timeout>:
{
 100f2e0:	b570      	push	{r4, r5, r6, lr}
	ull_filter_rpa_update(true);
 100f2e2:	2001      	movs	r0, #1
 100f2e4:	f7ff fef6 	bl	100f0d4 <ull_filter_rpa_update>
			return (u32_t)((t * to_hz + off) / from_hz);
 100f2e8:	f44f 4400 	mov.w	r4, #32768	; 0x8000
 100f2ec:	f240 30e7 	movw	r0, #999	; 0x3e7
 100f2f0:	2100      	movs	r1, #0
	k_delayed_work_submit(&rpa_work, K_MSEC(rpa_timeout_ms));
 100f2f2:	4d08      	ldr	r5, [pc, #32]	; (100f314 <rpa_timeout+0x34>)
 100f2f4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 100f2f8:	682d      	ldr	r5, [r5, #0]
 100f2fa:	2300      	movs	r3, #0
 100f2fc:	fbe4 0105 	umlal	r0, r1, r4, r5
 100f300:	f7f0 feda 	bl	10000b8 <__aeabi_uldivmod>
}
 100f304:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 100f308:	4602      	mov	r2, r0
 100f30a:	2300      	movs	r3, #0
 100f30c:	4902      	ldr	r1, [pc, #8]	; (100f318 <rpa_timeout+0x38>)
 100f30e:	4803      	ldr	r0, [pc, #12]	; (100f31c <rpa_timeout+0x3c>)
 100f310:	f005 bb8c 	b.w	1014a2c <k_delayed_work_submit_to_queue>
 100f314:	210055ec 	.word	0x210055ec
 100f318:	210055f0 	.word	0x210055f0
 100f31c:	21007fc8 	.word	0x21007fc8

0100f320 <ull_filter_rl_find>:
{
 100f320:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100f324:	468b      	mov	fp, r1
	if (free) {
 100f326:	4616      	mov	r6, r2
 100f328:	b10a      	cbz	r2, 100f32e <ull_filter_rl_find+0xe>
		*free = FILTER_IDX_NONE;
 100f32a:	23ff      	movs	r3, #255	; 0xff
 100f32c:	7013      	strb	r3, [r2, #0]
 100f32e:	f8df 8064 	ldr.w	r8, [pc, #100]	; 100f394 <ull_filter_rl_find+0x74>
{
 100f332:	2400      	movs	r4, #0
		if (LIST_MATCH(rl, i, id_addr_type, id_addr)) {
 100f334:	f000 0901 	and.w	r9, r0, #1
 100f338:	f108 0a01 	add.w	sl, r8, #1
 100f33c:	e004      	b.n	100f348 <ull_filter_rl_find+0x28>
 100f33e:	454a      	cmp	r2, r9
 100f340:	d019      	beq.n	100f376 <ull_filter_rl_find+0x56>
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
 100f342:	3401      	adds	r4, #1
 100f344:	2c08      	cmp	r4, #8
 100f346:	d012      	beq.n	100f36e <ull_filter_rl_find+0x4e>
		if (LIST_MATCH(rl, i, id_addr_type, id_addr)) {
 100f348:	eb04 0584 	add.w	r5, r4, r4, lsl #2
 100f34c:	f818 3035 	ldrb.w	r3, [r8, r5, lsl #3]
 100f350:	00e8      	lsls	r0, r5, #3
 100f352:	07d9      	lsls	r1, r3, #31
 100f354:	f3c3 1280 	ubfx	r2, r3, #6, #1
 100f358:	b2e7      	uxtb	r7, r4
 100f35a:	d4f0      	bmi.n	100f33e <ull_filter_rl_find+0x1e>
		} else if (free && !rl[i].taken && (*free == FILTER_IDX_NONE)) {
 100f35c:	2e00      	cmp	r6, #0
 100f35e:	d0f0      	beq.n	100f342 <ull_filter_rl_find+0x22>
 100f360:	7833      	ldrb	r3, [r6, #0]
 100f362:	3401      	adds	r4, #1
 100f364:	2bff      	cmp	r3, #255	; 0xff
			*free = i;
 100f366:	bf08      	it	eq
 100f368:	7037      	strbeq	r7, [r6, #0]
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
 100f36a:	2c08      	cmp	r4, #8
 100f36c:	d1ec      	bne.n	100f348 <ull_filter_rl_find+0x28>
	return FILTER_IDX_NONE;
 100f36e:	27ff      	movs	r7, #255	; 0xff
}
 100f370:	4638      	mov	r0, r7
 100f372:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (LIST_MATCH(rl, i, id_addr_type, id_addr)) {
 100f376:	2206      	movs	r2, #6
 100f378:	4659      	mov	r1, fp
 100f37a:	4450      	add	r0, sl
 100f37c:	f007 fb3c 	bl	10169f8 <memcmp>
 100f380:	2800      	cmp	r0, #0
 100f382:	d0f5      	beq.n	100f370 <ull_filter_rl_find+0x50>
		} else if (free && !rl[i].taken && (*free == FILTER_IDX_NONE)) {
 100f384:	2e00      	cmp	r6, #0
 100f386:	d0dc      	beq.n	100f342 <ull_filter_rl_find+0x22>
 100f388:	f818 3035 	ldrb.w	r3, [r8, r5, lsl #3]
 100f38c:	07db      	lsls	r3, r3, #31
 100f38e:	d4d8      	bmi.n	100f342 <ull_filter_rl_find+0x22>
 100f390:	e7e6      	b.n	100f360 <ull_filter_rl_find+0x40>
 100f392:	bf00      	nop
 100f394:	21005478 	.word	0x21005478

0100f398 <ll_wl_add>:
{
 100f398:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 100f39c:	4605      	mov	r5, r0
 100f39e:	b083      	sub	sp, #12
	if (ull_adv_filter_pol_get(0)) {
 100f3a0:	2000      	movs	r0, #0
 100f3a2:	f7fb fcad 	bl	100ad00 <ull_adv_filter_pol_get>
 100f3a6:	2800      	cmp	r0, #0
 100f3a8:	d142      	bne.n	100f430 <ll_wl_add+0x98>
	if (ull_scan_filter_pol_get(0) & 0x1) {
 100f3aa:	f7fb fe03 	bl	100afb4 <ull_scan_filter_pol_get>
 100f3ae:	f010 0401 	ands.w	r4, r0, #1
 100f3b2:	d13d      	bne.n	100f430 <ll_wl_add+0x98>
	if (addr->type == ADDR_TYPE_ANON) {
 100f3b4:	7828      	ldrb	r0, [r5, #0]
 100f3b6:	28ff      	cmp	r0, #255	; 0xff
 100f3b8:	d03e      	beq.n	100f438 <ll_wl_add+0xa0>
	i = wl_find(id_addr->type, id_addr->a.val, &j);
 100f3ba:	f105 0801 	add.w	r8, r5, #1
 100f3be:	4641      	mov	r1, r8
 100f3c0:	f10d 0207 	add.w	r2, sp, #7
 100f3c4:	f7ff fbe0 	bl	100eb88 <wl_find>
	if (i < ARRAY_SIZE(wl)) {
 100f3c8:	2807      	cmp	r0, #7
 100f3ca:	d93e      	bls.n	100f44a <ll_wl_add+0xb2>
	} else if (j >= ARRAY_SIZE(wl)) {
 100f3cc:	f89d 6007 	ldrb.w	r6, [sp, #7]
 100f3d0:	2e07      	cmp	r6, #7
 100f3d2:	d838      	bhi.n	100f446 <ll_wl_add+0xae>
	wl[i].id_addr_type = id_addr->type & 0x1;
 100f3d4:	4f21      	ldr	r7, [pc, #132]	; (100f45c <ll_wl_add+0xc4>)
 100f3d6:	782a      	ldrb	r2, [r5, #0]
 100f3d8:	f817 3036 	ldrb.w	r3, [r7, r6, lsl #3]
	bt_addr_copy(&wl[i].id_addr, &id_addr->a);
 100f3dc:	ea4f 09c6 	mov.w	r9, r6, lsl #3
 100f3e0:	f109 0002 	add.w	r0, r9, #2
	wl[i].id_addr_type = id_addr->type & 0x1;
 100f3e4:	f362 0341 	bfi	r3, r2, #1, #1
 100f3e8:	4641      	mov	r1, r8
 100f3ea:	2206      	movs	r2, #6
 100f3ec:	4438      	add	r0, r7
 100f3ee:	f807 3036 	strb.w	r3, [r7, r6, lsl #3]
 100f3f2:	f007 fb11 	bl	1016a18 <memcpy>
	j = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
 100f3f6:	4622      	mov	r2, r4
 100f3f8:	4641      	mov	r1, r8
 100f3fa:	7828      	ldrb	r0, [r5, #0]
 100f3fc:	f7ff ff90 	bl	100f320 <ull_filter_rl_find>
	if (j < ARRAY_SIZE(rl)) {
 100f400:	2807      	cmp	r0, #7
 100f402:	d826      	bhi.n	100f452 <ll_wl_add+0xba>
		rl[j].wl = 1U;
 100f404:	4a16      	ldr	r2, [pc, #88]	; (100f460 <ll_wl_add+0xc8>)
 100f406:	eb00 0180 	add.w	r1, r0, r0, lsl #2
 100f40a:	f812 3031 	ldrb.w	r3, [r2, r1, lsl #3]
		wl[i].rl_idx = j;
 100f40e:	44b9      	add	r9, r7
		rl[j].wl = 1U;
 100f410:	f043 0320 	orr.w	r3, r3, #32
		wl[i].rl_idx = j;
 100f414:	f889 0001 	strb.w	r0, [r9, #1]
		rl[j].wl = 1U;
 100f418:	f802 3031 	strb.w	r3, [r2, r1, lsl #3]
	return 0;
 100f41c:	2000      	movs	r0, #0
	wl[i].taken = 1U;
 100f41e:	f817 3036 	ldrb.w	r3, [r7, r6, lsl #3]
 100f422:	f043 0301 	orr.w	r3, r3, #1
 100f426:	f807 3036 	strb.w	r3, [r7, r6, lsl #3]
}
 100f42a:	b003      	add	sp, #12
 100f42c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100f430:	200c      	movs	r0, #12
}
 100f432:	b003      	add	sp, #12
 100f434:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		wl_anon = 1U;
 100f438:	2201      	movs	r2, #1
		return 0;
 100f43a:	4620      	mov	r0, r4
		wl_anon = 1U;
 100f43c:	4b09      	ldr	r3, [pc, #36]	; (100f464 <ll_wl_add+0xcc>)
 100f43e:	701a      	strb	r2, [r3, #0]
}
 100f440:	b003      	add	sp, #12
 100f442:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 100f446:	2007      	movs	r0, #7
	return wl_add(addr);
 100f448:	e7f3      	b.n	100f432 <ll_wl_add+0x9a>
 100f44a:	4620      	mov	r0, r4
}
 100f44c:	b003      	add	sp, #12
 100f44e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		wl[i].rl_idx = FILTER_IDX_NONE;
 100f452:	23ff      	movs	r3, #255	; 0xff
 100f454:	44b9      	add	r9, r7
 100f456:	f889 3001 	strb.w	r3, [r9, #1]
 100f45a:	e7df      	b.n	100f41c <ll_wl_add+0x84>
 100f45c:	21005610 	.word	0x21005610
 100f460:	21005478 	.word	0x21005478
 100f464:	210080c8 	.word	0x210080c8

0100f468 <ll_rl_add>:
{
 100f468:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100f46c:	4607      	mov	r7, r0
 100f46e:	b083      	sub	sp, #12
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
 100f470:	2000      	movs	r0, #0
{
 100f472:	460d      	mov	r5, r1
 100f474:	4614      	mov	r4, r2
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
 100f476:	f7fb fc37 	bl	100ace8 <ull_adv_is_enabled>
		? 0 : 1;
 100f47a:	b118      	cbz	r0, 100f484 <ll_rl_add+0x1c>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100f47c:	200c      	movs	r0, #12
}
 100f47e:	b003      	add	sp, #12
 100f480:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 100f484:	f7ff fc32 	bl	100ecec <rl_access_check.part.0>
	if (!rl_access_check(false)) {
 100f488:	2800      	cmp	r0, #0
 100f48a:	d0f7      	beq.n	100f47c <ll_rl_add+0x14>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, &j);
 100f48c:	46b9      	mov	r9, r7
 100f48e:	f819 0b01 	ldrb.w	r0, [r9], #1
 100f492:	f10d 0207 	add.w	r2, sp, #7
 100f496:	4649      	mov	r1, r9
 100f498:	f7ff ff42 	bl	100f320 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
 100f49c:	2807      	cmp	r0, #7
 100f49e:	d97e      	bls.n	100f59e <ll_rl_add+0x136>
	} else if (j >= ARRAY_SIZE(rl)) {
 100f4a0:	f89d b007 	ldrb.w	fp, [sp, #7]
 100f4a4:	f1bb 0f07 	cmp.w	fp, #7
 100f4a8:	d872      	bhi.n	100f590 <ll_rl_add+0x128>
	bt_addr_copy(&rl[i].id_addr, &id_addr->a);
 100f4aa:	eb0b 088b 	add.w	r8, fp, fp, lsl #2
 100f4ae:	4e44      	ldr	r6, [pc, #272]	; (100f5c0 <ll_rl_add+0x158>)
 100f4b0:	ea4f 08c8 	mov.w	r8, r8, lsl #3
 100f4b4:	f108 0001 	add.w	r0, r8, #1
 100f4b8:	2206      	movs	r2, #6
 100f4ba:	4649      	mov	r1, r9
 100f4bc:	4430      	add	r0, r6
 100f4be:	f007 faab 	bl	1016a18 <memcpy>
	rl[i].id_addr_type = id_addr->type & 0x1;
 100f4c2:	783a      	ldrb	r2, [r7, #0]
 100f4c4:	f816 3008 	ldrb.w	r3, [r6, r8]
	rl[i].pirk = mem_nz((u8_t *)pirk, IRK_SIZE);
 100f4c8:	2110      	movs	r1, #16
	rl[i].id_addr_type = id_addr->type & 0x1;
 100f4ca:	f362 1386 	bfi	r3, r2, #6, #1
	rl[i].pirk = mem_nz((u8_t *)pirk, IRK_SIZE);
 100f4ce:	4628      	mov	r0, r5
	rl[i].id_addr_type = id_addr->type & 0x1;
 100f4d0:	f806 3008 	strb.w	r3, [r6, r8]
	rl[i].pirk = mem_nz((u8_t *)pirk, IRK_SIZE);
 100f4d4:	f7f6 fc6a 	bl	1005dac <mem_nz>
 100f4d8:	f816 3008 	ldrb.w	r3, [r6, r8]
	rl[i].lirk = mem_nz((u8_t *)lirk, IRK_SIZE);
 100f4dc:	2110      	movs	r1, #16
	rl[i].pirk = mem_nz((u8_t *)pirk, IRK_SIZE);
 100f4de:	f360 0382 	bfi	r3, r0, #2, #1
	rl[i].lirk = mem_nz((u8_t *)lirk, IRK_SIZE);
 100f4e2:	4620      	mov	r0, r4
	rl[i].pirk = mem_nz((u8_t *)pirk, IRK_SIZE);
 100f4e4:	f806 3008 	strb.w	r3, [r6, r8]
	rl[i].lirk = mem_nz((u8_t *)lirk, IRK_SIZE);
 100f4e8:	f7f6 fc60 	bl	1005dac <mem_nz>
 100f4ec:	f816 3008 	ldrb.w	r3, [r6, r8]
 100f4f0:	f000 0001 	and.w	r0, r0, #1
 100f4f4:	f360 03c3 	bfi	r3, r0, #3, #1
 100f4f8:	f806 3008 	strb.w	r3, [r6, r8]
	if (rl[i].pirk) {
 100f4fc:	075b      	lsls	r3, r3, #29
	rl[i].id_addr_type = id_addr->type & 0x1;
 100f4fe:	eb06 0108 	add.w	r1, r6, r8
 100f502:	ea4f 0a8b 	mov.w	sl, fp, lsl #2
	if (rl[i].pirk) {
 100f506:	d518      	bpl.n	100f53a <ll_rl_add+0xd2>
		rl[i].pirk_idx = peer_irk_count;
 100f508:	f8df c0c0 	ldr.w	ip, [pc, #192]	; 100f5cc <ll_rl_add+0x164>
 100f50c:	4a2d      	ldr	r2, [pc, #180]	; (100f5c4 <ll_rl_add+0x15c>)
 100f50e:	f89c 3000 	ldrb.w	r3, [ip]
		peer_irk_rl_ids[peer_irk_count] = i;
 100f512:	f8df e0bc 	ldr.w	lr, [pc, #188]	; 100f5d0 <ll_rl_add+0x168>
 100f516:	eb02 1203 	add.w	r2, r2, r3, lsl #4
		rl[i].pirk_idx = peer_irk_count;
 100f51a:	75cb      	strb	r3, [r1, #23]
		sys_memcpy_swap(peer_irks[peer_irk_count++], pirk, IRK_SIZE);
 100f51c:	1c59      	adds	r1, r3, #1
 100f51e:	f88c 1000 	strb.w	r1, [ip]
		peer_irk_rl_ids[peer_irk_count] = i;
 100f522:	f80e b003 	strb.w	fp, [lr, r3]
	psrc += length - 1;
 100f526:	3a01      	subs	r2, #1
 100f528:	f105 030f 	add.w	r3, r5, #15
	for (; length > 0; length--) {
 100f52c:	1e69      	subs	r1, r5, #1
		*pdst++ = *psrc--;
 100f52e:	f813 5901 	ldrb.w	r5, [r3], #-1
	for (; length > 0; length--) {
 100f532:	428b      	cmp	r3, r1
		*pdst++ = *psrc--;
 100f534:	f802 5f01 	strb.w	r5, [r2, #1]!
	for (; length > 0; length--) {
 100f538:	d1f9      	bne.n	100f52e <ll_rl_add+0xc6>
	if (rl[i].lirk) {
 100f53a:	bb90      	cbnz	r0, 100f5a2 <ll_rl_add+0x13a>
	memset(rl[i].curr_rpa.val, 0x00, sizeof(rl[i].curr_rpa));
 100f53c:	f108 0018 	add.w	r0, r8, #24
 100f540:	2206      	movs	r2, #6
 100f542:	2100      	movs	r1, #0
 100f544:	eb0a 040b 	add.w	r4, sl, fp
 100f548:	4430      	add	r0, r6
 100f54a:	f007 fa90 	bl	1016a6e <memset>
	rl[i].rpas_ready = 0U;
 100f54e:	f816 3034 	ldrb.w	r3, [r6, r4, lsl #3]
 100f552:	00e4      	lsls	r4, r4, #3
 100f554:	f023 0312 	bic.w	r3, r3, #18
 100f558:	5533      	strb	r3, [r6, r4]
	j = wl_find(id_addr->type, id_addr->a.val, NULL);
 100f55a:	4649      	mov	r1, r9
 100f55c:	2200      	movs	r2, #0
 100f55e:	7838      	ldrb	r0, [r7, #0]
 100f560:	f7ff fb12 	bl	100eb88 <wl_find>
	if (j < ARRAY_SIZE(wl)) {
 100f564:	2807      	cmp	r0, #7
 100f566:	d815      	bhi.n	100f594 <ll_rl_add+0x12c>
		rl[i].wl = 1U;
 100f568:	5d33      	ldrb	r3, [r6, r4]
		wl[j].rl_idx = i;
 100f56a:	4a17      	ldr	r2, [pc, #92]	; (100f5c8 <ll_rl_add+0x160>)
		rl[i].wl = 1U;
 100f56c:	f043 0320 	orr.w	r3, r3, #32
		wl[j].rl_idx = i;
 100f570:	eb02 00c0 	add.w	r0, r2, r0, lsl #3
 100f574:	f880 b001 	strb.w	fp, [r0, #1]
		rl[i].wl = 1U;
 100f578:	5533      	strb	r3, [r6, r4]
	return 0;
 100f57a:	2000      	movs	r0, #0
	rl[i].taken = 1U;
 100f57c:	44da      	add	sl, fp
 100f57e:	f816 303a 	ldrb.w	r3, [r6, sl, lsl #3]
 100f582:	f043 0301 	orr.w	r3, r3, #1
 100f586:	f806 303a 	strb.w	r3, [r6, sl, lsl #3]
}
 100f58a:	b003      	add	sp, #12
 100f58c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
 100f590:	2007      	movs	r0, #7
 100f592:	e774      	b.n	100f47e <ll_rl_add+0x16>
		rl[i].wl = 0U;
 100f594:	5d33      	ldrb	r3, [r6, r4]
 100f596:	f36f 1345 	bfc	r3, #5, #1
 100f59a:	5533      	strb	r3, [r6, r4]
 100f59c:	e7ed      	b.n	100f57a <ll_rl_add+0x112>
		return BT_HCI_ERR_INVALID_PARAM;
 100f59e:	2012      	movs	r0, #18
 100f5a0:	e76d      	b.n	100f47e <ll_rl_add+0x16>
		memcpy(rl[i].local_irk, lirk, IRK_SIZE);
 100f5a2:	f108 0007 	add.w	r0, r8, #7
 100f5a6:	2210      	movs	r2, #16
 100f5a8:	4621      	mov	r1, r4
 100f5aa:	4430      	add	r0, r6
 100f5ac:	f007 fa34 	bl	1016a18 <memcpy>
		rl[i].local_rpa = NULL;
 100f5b0:	2200      	movs	r2, #0
 100f5b2:	eb0a 030b 	add.w	r3, sl, fp
 100f5b6:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 100f5ba:	625a      	str	r2, [r3, #36]	; 0x24
 100f5bc:	e7be      	b.n	100f53c <ll_rl_add+0xd4>
 100f5be:	bf00      	nop
 100f5c0:	21005478 	.word	0x21005478
 100f5c4:	210053f8 	.word	0x210053f8
 100f5c8:	21005610 	.word	0x21005610
 100f5cc:	210080c6 	.word	0x210080c6
 100f5d0:	210053f0 	.word	0x210053f0

0100f5d4 <ll_rl_remove>:
{
 100f5d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100f5d8:	4605      	mov	r5, r0
 100f5da:	b083      	sub	sp, #12
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
 100f5dc:	2000      	movs	r0, #0
 100f5de:	f7fb fb83 	bl	100ace8 <ull_adv_is_enabled>
		? 0 : 1;
 100f5e2:	b118      	cbz	r0, 100f5ec <ll_rl_remove+0x18>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100f5e4:	200c      	movs	r0, #12
}
 100f5e6:	b003      	add	sp, #12
 100f5e8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 100f5ec:	4604      	mov	r4, r0
 100f5ee:	f7ff fb7d 	bl	100ecec <rl_access_check.part.0>
	if (!rl_access_check(false)) {
 100f5f2:	2800      	cmp	r0, #0
 100f5f4:	d0f6      	beq.n	100f5e4 <ll_rl_remove+0x10>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
 100f5f6:	462f      	mov	r7, r5
 100f5f8:	f817 0b01 	ldrb.w	r0, [r7], #1
 100f5fc:	4622      	mov	r2, r4
 100f5fe:	4639      	mov	r1, r7
 100f600:	f7ff fe8e 	bl	100f320 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
 100f604:	2807      	cmp	r0, #7
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
 100f606:	4606      	mov	r6, r0
	if (i < ARRAY_SIZE(rl)) {
 100f608:	d903      	bls.n	100f612 <ll_rl_remove+0x3e>
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100f60a:	2002      	movs	r0, #2
}
 100f60c:	b003      	add	sp, #12
 100f60e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (rl[i].pirk) {
 100f612:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 100f6d0 <ll_rl_remove+0xfc>
 100f616:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 100f61a:	f818 2033 	ldrb.w	r2, [r8, r3, lsl #3]
 100f61e:	ea4f 0980 	mov.w	r9, r0, lsl #2
 100f622:	0752      	lsls	r2, r2, #29
 100f624:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
 100f628:	d52e      	bpl.n	100f688 <ll_rl_remove+0xb4>
			u8_t pi = rl[i].pirk_idx, pj = peer_irk_count - 1;
 100f62a:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 100f6d4 <ll_rl_remove+0x100>
 100f62e:	f89a 2000 	ldrb.w	r2, [sl]
 100f632:	3a01      	subs	r2, #1
			if (pj && pi != pj) {
 100f634:	f012 0bff 	ands.w	fp, r2, #255	; 0xff
 100f638:	d023      	beq.n	100f682 <ll_rl_remove+0xae>
			u8_t pi = rl[i].pirk_idx, pj = peer_irk_count - 1;
 100f63a:	7ddb      	ldrb	r3, [r3, #23]
			if (pj && pi != pj) {
 100f63c:	455b      	cmp	r3, fp
 100f63e:	d021      	beq.n	100f684 <ll_rl_remove+0xb0>
				memcpy(peer_irks[pi], peer_irks[pj], IRK_SIZE);
 100f640:	4820      	ldr	r0, [pc, #128]	; (100f6c4 <ll_rl_remove+0xf0>)
 100f642:	2210      	movs	r2, #16
 100f644:	eb00 110b 	add.w	r1, r0, fp, lsl #4
 100f648:	eb00 1003 	add.w	r0, r0, r3, lsl #4
 100f64c:	9301      	str	r3, [sp, #4]
 100f64e:	f007 f9e3 	bl	1016a18 <memcpy>
 100f652:	9b01      	ldr	r3, [sp, #4]
					if (rl[k].taken && rl[k].pirk &&
 100f654:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 100f658:	f818 1032 	ldrb.w	r1, [r8, r2, lsl #3]
 100f65c:	b2e0      	uxtb	r0, r4
 100f65e:	f011 0f01 	tst.w	r1, #1
 100f662:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
 100f666:	f104 0401 	add.w	r4, r4, #1
 100f66a:	d004      	beq.n	100f676 <ll_rl_remove+0xa2>
 100f66c:	0749      	lsls	r1, r1, #29
 100f66e:	d502      	bpl.n	100f676 <ll_rl_remove+0xa2>
 100f670:	7dd1      	ldrb	r1, [r2, #23]
 100f672:	4559      	cmp	r1, fp
 100f674:	d01f      	beq.n	100f6b6 <ll_rl_remove+0xe2>
				for (k = 0U;
 100f676:	2c08      	cmp	r4, #8
 100f678:	d1ec      	bne.n	100f654 <ll_rl_remove+0x80>
 100f67a:	f89a 2000 	ldrb.w	r2, [sl]
 100f67e:	3a01      	subs	r2, #1
 100f680:	e000      	b.n	100f684 <ll_rl_remove+0xb0>
 100f682:	465a      	mov	r2, fp
			peer_irk_count--;
 100f684:	f88a 2000 	strb.w	r2, [sl]
		j = wl_find(id_addr->type, id_addr->a.val, NULL);
 100f688:	4639      	mov	r1, r7
 100f68a:	2200      	movs	r2, #0
 100f68c:	7828      	ldrb	r0, [r5, #0]
 100f68e:	f7ff fa7b 	bl	100eb88 <wl_find>
		if (j < ARRAY_SIZE(wl)) {
 100f692:	2807      	cmp	r0, #7
 100f694:	d804      	bhi.n	100f6a0 <ll_rl_remove+0xcc>
			wl[j].rl_idx = FILTER_IDX_NONE;
 100f696:	22ff      	movs	r2, #255	; 0xff
 100f698:	4b0b      	ldr	r3, [pc, #44]	; (100f6c8 <ll_rl_remove+0xf4>)
 100f69a:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 100f69e:	7042      	strb	r2, [r0, #1]
		return 0;
 100f6a0:	2000      	movs	r0, #0
		rl[i].taken = 0U;
 100f6a2:	444e      	add	r6, r9
 100f6a4:	f818 3036 	ldrb.w	r3, [r8, r6, lsl #3]
 100f6a8:	f36f 0300 	bfc	r3, #0, #1
 100f6ac:	f808 3036 	strb.w	r3, [r8, r6, lsl #3]
}
 100f6b0:	b003      	add	sp, #12
 100f6b2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						peer_irk_rl_ids[pi] = k;
 100f6b6:	4905      	ldr	r1, [pc, #20]	; (100f6cc <ll_rl_remove+0xf8>)
						rl[k].pirk_idx = pi;
 100f6b8:	75d3      	strb	r3, [r2, #23]
						peer_irk_rl_ids[pi] = k;
 100f6ba:	f89a 2000 	ldrb.w	r2, [sl]
 100f6be:	54c8      	strb	r0, [r1, r3]
						break;
 100f6c0:	3a01      	subs	r2, #1
 100f6c2:	e7df      	b.n	100f684 <ll_rl_remove+0xb0>
 100f6c4:	210053f8 	.word	0x210053f8
 100f6c8:	21005610 	.word	0x21005610
 100f6cc:	210053f0 	.word	0x210053f0
 100f6d0:	21005478 	.word	0x21005478
 100f6d4:	210080c6 	.word	0x210080c6

0100f6d8 <ll_rl_crpa_set>:
{
 100f6d8:	b538      	push	{r3, r4, r5, lr}
 100f6da:	461c      	mov	r4, r3
	if ((crpa[5] & 0xc0) == 0x40) {
 100f6dc:	795b      	ldrb	r3, [r3, #5]
 100f6de:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 100f6e2:	2b40      	cmp	r3, #64	; 0x40
 100f6e4:	d000      	beq.n	100f6e8 <ll_rl_crpa_set+0x10>
}
 100f6e6:	bd38      	pop	{r3, r4, r5, pc}
		if (id_addr) {
 100f6e8:	b119      	cbz	r1, 100f6f2 <ll_rl_crpa_set+0x1a>
			rl_idx = ull_filter_rl_find(id_addr_type, id_addr, NULL);
 100f6ea:	2200      	movs	r2, #0
 100f6ec:	f7ff fe18 	bl	100f320 <ull_filter_rl_find>
 100f6f0:	4602      	mov	r2, r0
		if (rl_idx < ARRAY_SIZE(rl) && rl[rl_idx].taken) {
 100f6f2:	2a07      	cmp	r2, #7
 100f6f4:	d8f7      	bhi.n	100f6e6 <ll_rl_crpa_set+0xe>
 100f6f6:	4808      	ldr	r0, [pc, #32]	; (100f718 <ll_rl_crpa_set+0x40>)
 100f6f8:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 100f6fc:	f810 3032 	ldrb.w	r3, [r0, r2, lsl #3]
 100f700:	00d2      	lsls	r2, r2, #3
 100f702:	07db      	lsls	r3, r3, #31
 100f704:	d5ef      	bpl.n	100f6e6 <ll_rl_crpa_set+0xe>
			memcpy(rl[rl_idx].curr_rpa.val, crpa,
 100f706:	3218      	adds	r2, #24
 100f708:	4621      	mov	r1, r4
}
 100f70a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			memcpy(rl[rl_idx].curr_rpa.val, crpa,
 100f70e:	4410      	add	r0, r2
 100f710:	2206      	movs	r2, #6
 100f712:	f007 b981 	b.w	1016a18 <memcpy>
 100f716:	bf00      	nop
 100f718:	21005478 	.word	0x21005478

0100f71c <ll_rl_crpa_get>:
{
 100f71c:	b538      	push	{r3, r4, r5, lr}
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
 100f71e:	4603      	mov	r3, r0
 100f720:	f813 0b01 	ldrb.w	r0, [r3], #1
{
 100f724:	460c      	mov	r4, r1
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
 100f726:	2200      	movs	r2, #0
 100f728:	4619      	mov	r1, r3
 100f72a:	f7ff fdf9 	bl	100f320 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl) &&
 100f72e:	2807      	cmp	r0, #7
 100f730:	d901      	bls.n	100f736 <ll_rl_crpa_get+0x1a>
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100f732:	2002      	movs	r0, #2
}
 100f734:	bd38      	pop	{r3, r4, r5, pc}
	    mem_nz(rl[i].curr_rpa.val, sizeof(rl[i].curr_rpa.val))) {
 100f736:	4d0a      	ldr	r5, [pc, #40]	; (100f760 <ll_rl_crpa_get+0x44>)
 100f738:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 100f73c:	eb05 00c0 	add.w	r0, r5, r0, lsl #3
 100f740:	f100 0518 	add.w	r5, r0, #24
 100f744:	4628      	mov	r0, r5
 100f746:	2106      	movs	r1, #6
 100f748:	f7f6 fb30 	bl	1005dac <mem_nz>
	if (i < ARRAY_SIZE(rl) &&
 100f74c:	2800      	cmp	r0, #0
 100f74e:	d0f0      	beq.n	100f732 <ll_rl_crpa_get+0x16>
 100f750:	4629      	mov	r1, r5
 100f752:	4620      	mov	r0, r4
 100f754:	2206      	movs	r2, #6
 100f756:	f007 f95f 	bl	1016a18 <memcpy>
		return 0;
 100f75a:	2000      	movs	r0, #0
}
 100f75c:	bd38      	pop	{r3, r4, r5, pc}
 100f75e:	bf00      	nop
 100f760:	21005478 	.word	0x21005478

0100f764 <ll_rl_lrpa_get>:
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
 100f764:	4603      	mov	r3, r0
{
 100f766:	b510      	push	{r4, lr}
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
 100f768:	f813 0b01 	ldrb.w	r0, [r3], #1
{
 100f76c:	460c      	mov	r4, r1
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
 100f76e:	2200      	movs	r2, #0
 100f770:	4619      	mov	r1, r3
 100f772:	f7ff fdd5 	bl	100f320 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
 100f776:	2807      	cmp	r0, #7
 100f778:	d901      	bls.n	100f77e <ll_rl_lrpa_get+0x1a>
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100f77a:	2002      	movs	r0, #2
}
 100f77c:	bd10      	pop	{r4, pc}
		bt_addr_copy(lrpa, rl[i].local_rpa);
 100f77e:	4b06      	ldr	r3, [pc, #24]	; (100f798 <ll_rl_lrpa_get+0x34>)
 100f780:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 100f784:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 100f788:	2206      	movs	r2, #6
 100f78a:	4620      	mov	r0, r4
 100f78c:	6a59      	ldr	r1, [r3, #36]	; 0x24
 100f78e:	f007 f943 	bl	1016a18 <memcpy>
		return 0;
 100f792:	2000      	movs	r0, #0
}
 100f794:	bd10      	pop	{r4, pc}
 100f796:	bf00      	nop
 100f798:	21005478 	.word	0x21005478

0100f79c <ll_priv_mode_set>:
{
 100f79c:	b570      	push	{r4, r5, r6, lr}
 100f79e:	4605      	mov	r5, r0
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
 100f7a0:	2000      	movs	r0, #0
{
 100f7a2:	460e      	mov	r6, r1
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
 100f7a4:	f7fb faa0 	bl	100ace8 <ull_adv_is_enabled>
		? 0 : 1;
 100f7a8:	b108      	cbz	r0, 100f7ae <ll_priv_mode_set+0x12>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100f7aa:	200c      	movs	r0, #12
}
 100f7ac:	bd70      	pop	{r4, r5, r6, pc}
 100f7ae:	4604      	mov	r4, r0
 100f7b0:	f7ff fa9c 	bl	100ecec <rl_access_check.part.0>
	if (!rl_access_check(false)) {
 100f7b4:	2800      	cmp	r0, #0
 100f7b6:	d0f8      	beq.n	100f7aa <ll_priv_mode_set+0xe>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
 100f7b8:	4629      	mov	r1, r5
 100f7ba:	4622      	mov	r2, r4
 100f7bc:	f811 0b01 	ldrb.w	r0, [r1], #1
 100f7c0:	f7ff fdae 	bl	100f320 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
 100f7c4:	2807      	cmp	r0, #7
 100f7c6:	d81a      	bhi.n	100f7fe <ll_priv_mode_set+0x62>
		switch (mode) {
 100f7c8:	b176      	cbz	r6, 100f7e8 <ll_priv_mode_set+0x4c>
 100f7ca:	2e01      	cmp	r6, #1
 100f7cc:	d10a      	bne.n	100f7e4 <ll_priv_mode_set+0x48>
			rl[i].dev = 1U;
 100f7ce:	490d      	ldr	r1, [pc, #52]	; (100f804 <ll_priv_mode_set+0x68>)
 100f7d0:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 100f7d4:	f811 2033 	ldrb.w	r2, [r1, r3, lsl #3]
	return 0;
 100f7d8:	4620      	mov	r0, r4
			rl[i].dev = 1U;
 100f7da:	f042 0210 	orr.w	r2, r2, #16
 100f7de:	f801 2033 	strb.w	r2, [r1, r3, lsl #3]
}
 100f7e2:	bd70      	pop	{r4, r5, r6, pc}
		switch (mode) {
 100f7e4:	2012      	movs	r0, #18
}
 100f7e6:	bd70      	pop	{r4, r5, r6, pc}
			rl[i].dev = 0U;
 100f7e8:	4a06      	ldr	r2, [pc, #24]	; (100f804 <ll_priv_mode_set+0x68>)
 100f7ea:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 100f7ee:	f812 1033 	ldrb.w	r1, [r2, r3, lsl #3]
	return 0;
 100f7f2:	4630      	mov	r0, r6
			rl[i].dev = 0U;
 100f7f4:	f366 1104 	bfi	r1, r6, #4, #1
 100f7f8:	f802 1033 	strb.w	r1, [r2, r3, lsl #3]
}
 100f7fc:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100f7fe:	2002      	movs	r0, #2
}
 100f800:	bd70      	pop	{r4, r5, r6, pc}
 100f802:	bf00      	nop
 100f804:	21005478 	.word	0x21005478

0100f808 <ull_filter_reset>:
	wl_anon = 0U;
 100f808:	2200      	movs	r2, #0
	for (int i = 0; i < WL_SIZE; i++) {
 100f80a:	4613      	mov	r3, r2
{
 100f80c:	b4f0      	push	{r4, r5, r6, r7}
	wl_anon = 0U;
 100f80e:	4d30      	ldr	r5, [pc, #192]	; (100f8d0 <ull_filter_reset+0xc8>)
 100f810:	4c30      	ldr	r4, [pc, #192]	; (100f8d4 <ull_filter_reset+0xcc>)
 100f812:	4931      	ldr	r1, [pc, #196]	; (100f8d8 <ull_filter_reset+0xd0>)
 100f814:	702a      	strb	r2, [r5, #0]
		u8_t j = wl[i].rl_idx;
 100f816:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
 100f81a:	7852      	ldrb	r2, [r2, #1]
		if (j < ARRAY_SIZE(rl)) {
 100f81c:	2a07      	cmp	r2, #7
 100f81e:	d807      	bhi.n	100f830 <ull_filter_reset+0x28>
			rl[j].wl = 0U;
 100f820:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 100f824:	f811 5032 	ldrb.w	r5, [r1, r2, lsl #3]
 100f828:	f36f 1545 	bfc	r5, #5, #1
 100f82c:	f801 5032 	strb.w	r5, [r1, r2, lsl #3]
		wl[i].taken = 0U;
 100f830:	f814 2033 	ldrb.w	r2, [r4, r3, lsl #3]
 100f834:	f36f 0200 	bfc	r2, #0, #1
 100f838:	f804 2033 	strb.w	r2, [r4, r3, lsl #3]
	for (int i = 0; i < WL_SIZE; i++) {
 100f83c:	3301      	adds	r3, #1
 100f83e:	2b08      	cmp	r3, #8
 100f840:	d1e9      	bne.n	100f816 <ull_filter_reset+0xe>
	rl_enable = 0U;
 100f842:	2300      	movs	r3, #0
	rpa_last_ms = -1;
 100f844:	f04f 36ff 	mov.w	r6, #4294967295
 100f848:	f04f 37ff 	mov.w	r7, #4294967295
	rl_enable = 0U;
 100f84c:	4a23      	ldr	r2, [pc, #140]	; (100f8dc <ull_filter_reset+0xd4>)
		rl[i].taken = 0U;
 100f84e:	780c      	ldrb	r4, [r1, #0]
	rl_enable = 0U;
 100f850:	7013      	strb	r3, [r2, #0]
	peer_irk_count = 0U;
 100f852:	4a23      	ldr	r2, [pc, #140]	; (100f8e0 <ull_filter_reset+0xd8>)
		rl[i].taken = 0U;
 100f854:	f363 0400 	bfi	r4, r3, #0, #1
	peer_irk_count = 0U;
 100f858:	7013      	strb	r3, [r2, #0]
		rl[i].taken = 0U;
 100f85a:	f891 2028 	ldrb.w	r2, [r1, #40]	; 0x28
 100f85e:	700c      	strb	r4, [r1, #0]
 100f860:	f363 0200 	bfi	r2, r3, #0, #1
 100f864:	f891 4050 	ldrb.w	r4, [r1, #80]	; 0x50
 100f868:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
 100f86c:	f891 2078 	ldrb.w	r2, [r1, #120]	; 0x78
 100f870:	f363 0400 	bfi	r4, r3, #0, #1
 100f874:	f363 0200 	bfi	r2, r3, #0, #1
 100f878:	f881 4050 	strb.w	r4, [r1, #80]	; 0x50
 100f87c:	f881 2078 	strb.w	r2, [r1, #120]	; 0x78
 100f880:	f891 40a0 	ldrb.w	r4, [r1, #160]	; 0xa0
 100f884:	f891 20c8 	ldrb.w	r2, [r1, #200]	; 0xc8
 100f888:	f363 0400 	bfi	r4, r3, #0, #1
 100f88c:	f363 0200 	bfi	r2, r3, #0, #1
 100f890:	f881 40a0 	strb.w	r4, [r1, #160]	; 0xa0
 100f894:	f881 20c8 	strb.w	r2, [r1, #200]	; 0xc8
 100f898:	f891 40f0 	ldrb.w	r4, [r1, #240]	; 0xf0
 100f89c:	f891 2118 	ldrb.w	r2, [r1, #280]	; 0x118
 100f8a0:	f363 0400 	bfi	r4, r3, #0, #1
 100f8a4:	f363 0200 	bfi	r2, r3, #0, #1
 100f8a8:	f881 40f0 	strb.w	r4, [r1, #240]	; 0xf0
	rpa_timeout_ms = DEFAULT_RPA_TIMEOUT_MS;
 100f8ac:	4b0d      	ldr	r3, [pc, #52]	; (100f8e4 <ull_filter_reset+0xdc>)
	rpa_last_ms = -1;
 100f8ae:	4c0e      	ldr	r4, [pc, #56]	; (100f8e8 <ull_filter_reset+0xe0>)
		rl[i].taken = 0U;
 100f8b0:	f881 2118 	strb.w	r2, [r1, #280]	; 0x118
	rpa_timeout_ms = DEFAULT_RPA_TIMEOUT_MS;
 100f8b4:	4a0d      	ldr	r2, [pc, #52]	; (100f8ec <ull_filter_reset+0xe4>)
	rpa_last_ms = -1;
 100f8b6:	e9c4 6700 	strd	r6, r7, [r4]
	rpa_timeout_ms = DEFAULT_RPA_TIMEOUT_MS;
 100f8ba:	601a      	str	r2, [r3, #0]
	if (init) {
 100f8bc:	b120      	cbz	r0, 100f8c8 <ull_filter_reset+0xc0>
}
 100f8be:	bcf0      	pop	{r4, r5, r6, r7}
		k_delayed_work_init(&rpa_work, rpa_timeout);
 100f8c0:	490b      	ldr	r1, [pc, #44]	; (100f8f0 <ull_filter_reset+0xe8>)
 100f8c2:	480c      	ldr	r0, [pc, #48]	; (100f8f4 <ull_filter_reset+0xec>)
 100f8c4:	f008 ba24 	b.w	1017d10 <k_delayed_work_init>
		k_delayed_work_cancel(&rpa_work);
 100f8c8:	480a      	ldr	r0, [pc, #40]	; (100f8f4 <ull_filter_reset+0xec>)
}
 100f8ca:	bcf0      	pop	{r4, r5, r6, r7}
		k_delayed_work_cancel(&rpa_work);
 100f8cc:	f008 ba28 	b.w	1017d20 <k_delayed_work_cancel>
 100f8d0:	210080c8 	.word	0x210080c8
 100f8d4:	21005610 	.word	0x21005610
 100f8d8:	21005478 	.word	0x21005478
 100f8dc:	210080c7 	.word	0x210080c7
 100f8e0:	210080c6 	.word	0x210080c6
 100f8e4:	210055ec 	.word	0x210055ec
 100f8e8:	21000720 	.word	0x21000720
 100f8ec:	000dbba0 	.word	0x000dbba0
 100f8f0:	0100f2e1 	.word	0x0100f2e1
 100f8f4:	210055f0 	.word	0x210055f0

0100f8f8 <ull_filter_lll_lrpa_used>:
	return rl_idx < ARRAY_SIZE(rl) && rl[rl_idx].lirk;
 100f8f8:	2807      	cmp	r0, #7
 100f8fa:	d807      	bhi.n	100f90c <ull_filter_lll_lrpa_used+0x14>
 100f8fc:	4b04      	ldr	r3, [pc, #16]	; (100f910 <ull_filter_lll_lrpa_used+0x18>)
 100f8fe:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 100f902:	f813 0030 	ldrb.w	r0, [r3, r0, lsl #3]
 100f906:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 100f90a:	4770      	bx	lr
 100f90c:	2000      	movs	r0, #0
}
 100f90e:	4770      	bx	lr
 100f910:	21005478 	.word	0x21005478

0100f914 <ull_filter_lll_lrpa_get>:
	if ((rl_idx >= ARRAY_SIZE(rl)) || !rl[rl_idx].lirk ||
 100f914:	2807      	cmp	r0, #7
 100f916:	d80c      	bhi.n	100f932 <ull_filter_lll_lrpa_get+0x1e>
 100f918:	4907      	ldr	r1, [pc, #28]	; (100f938 <ull_filter_lll_lrpa_get+0x24>)
 100f91a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 100f91e:	f811 3030 	ldrb.w	r3, [r1, r0, lsl #3]
 100f922:	00c0      	lsls	r0, r0, #3
 100f924:	071a      	lsls	r2, r3, #28
 100f926:	d504      	bpl.n	100f932 <ull_filter_lll_lrpa_get+0x1e>
 100f928:	079b      	lsls	r3, r3, #30
 100f92a:	d502      	bpl.n	100f932 <ull_filter_lll_lrpa_get+0x1e>
	return rl[rl_idx].local_rpa;
 100f92c:	4408      	add	r0, r1
 100f92e:	6a40      	ldr	r0, [r0, #36]	; 0x24
 100f930:	4770      	bx	lr
		return NULL;
 100f932:	2000      	movs	r0, #0
 100f934:	4770      	bx	lr
 100f936:	bf00      	nop
 100f938:	21005478 	.word	0x21005478

0100f93c <ull_filter_lll_irks_get>:
{
 100f93c:	4603      	mov	r3, r0
	*count = peer_irk_count;
 100f93e:	4a02      	ldr	r2, [pc, #8]	; (100f948 <ull_filter_lll_irks_get+0xc>)
}
 100f940:	4802      	ldr	r0, [pc, #8]	; (100f94c <ull_filter_lll_irks_get+0x10>)
	*count = peer_irk_count;
 100f942:	7812      	ldrb	r2, [r2, #0]
 100f944:	701a      	strb	r2, [r3, #0]
}
 100f946:	4770      	bx	lr
 100f948:	210080c6 	.word	0x210080c6
 100f94c:	210053f8 	.word	0x210053f8

0100f950 <ull_filter_lll_rl_idx>:
{
 100f950:	b538      	push	{r3, r4, r5, lr}
 100f952:	460c      	mov	r4, r1
	if (whitelist) {
 100f954:	b150      	cbz	r0, 100f96c <ull_filter_lll_rl_idx+0x1c>
		LL_ASSERT(devmatch_id < ARRAY_SIZE(wl));
 100f956:	2907      	cmp	r1, #7
 100f958:	d81a      	bhi.n	100f990 <ull_filter_lll_rl_idx+0x40>
		LL_ASSERT(wl[devmatch_id].taken);
 100f95a:	4d1a      	ldr	r5, [pc, #104]	; (100f9c4 <ull_filter_lll_rl_idx+0x74>)
 100f95c:	f815 3034 	ldrb.w	r3, [r5, r4, lsl #3]
 100f960:	07da      	lsls	r2, r3, #31
 100f962:	d51f      	bpl.n	100f9a4 <ull_filter_lll_rl_idx+0x54>
		i = wl[devmatch_id].rl_idx;
 100f964:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
 100f968:	7860      	ldrb	r0, [r4, #1]
}
 100f96a:	bd38      	pop	{r3, r4, r5, pc}
		LL_ASSERT(devmatch_id < ARRAY_SIZE(rl));
 100f96c:	2907      	cmp	r1, #7
 100f96e:	d822      	bhi.n	100f9b6 <ull_filter_lll_rl_idx+0x66>
		LL_ASSERT(rl[i].taken);
 100f970:	4b15      	ldr	r3, [pc, #84]	; (100f9c8 <ull_filter_lll_rl_idx+0x78>)
 100f972:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 100f976:	f813 3032 	ldrb.w	r3, [r3, r2, lsl #3]
 100f97a:	07db      	lsls	r3, r3, #31
 100f97c:	d501      	bpl.n	100f982 <ull_filter_lll_rl_idx+0x32>
 100f97e:	4620      	mov	r0, r4
}
 100f980:	bd38      	pop	{r3, r4, r5, pc}
		LL_ASSERT(rl[i].taken);
 100f982:	f240 21b2 	movw	r1, #690	; 0x2b2
 100f986:	4811      	ldr	r0, [pc, #68]	; (100f9cc <ull_filter_lll_rl_idx+0x7c>)
 100f988:	f7f3 fe7a 	bl	1003680 <bt_ctlr_assert_handle>
 100f98c:	4620      	mov	r0, r4
}
 100f98e:	bd38      	pop	{r3, r4, r5, pc}
		LL_ASSERT(wl[devmatch_id].taken);
 100f990:	4d0c      	ldr	r5, [pc, #48]	; (100f9c4 <ull_filter_lll_rl_idx+0x74>)
		LL_ASSERT(devmatch_id < ARRAY_SIZE(wl));
 100f992:	f44f 712b 	mov.w	r1, #684	; 0x2ac
 100f996:	480d      	ldr	r0, [pc, #52]	; (100f9cc <ull_filter_lll_rl_idx+0x7c>)
 100f998:	f7f3 fe72 	bl	1003680 <bt_ctlr_assert_handle>
		LL_ASSERT(wl[devmatch_id].taken);
 100f99c:	f815 3034 	ldrb.w	r3, [r5, r4, lsl #3]
 100f9a0:	07da      	lsls	r2, r3, #31
 100f9a2:	d4df      	bmi.n	100f964 <ull_filter_lll_rl_idx+0x14>
 100f9a4:	4809      	ldr	r0, [pc, #36]	; (100f9cc <ull_filter_lll_rl_idx+0x7c>)
 100f9a6:	f240 21ad 	movw	r1, #685	; 0x2ad
		i = wl[devmatch_id].rl_idx;
 100f9aa:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
		LL_ASSERT(wl[devmatch_id].taken);
 100f9ae:	f7f3 fe67 	bl	1003680 <bt_ctlr_assert_handle>
		i = wl[devmatch_id].rl_idx;
 100f9b2:	7860      	ldrb	r0, [r4, #1]
 100f9b4:	e7d9      	b.n	100f96a <ull_filter_lll_rl_idx+0x1a>
		LL_ASSERT(devmatch_id < ARRAY_SIZE(rl));
 100f9b6:	f44f 712c 	mov.w	r1, #688	; 0x2b0
 100f9ba:	4804      	ldr	r0, [pc, #16]	; (100f9cc <ull_filter_lll_rl_idx+0x7c>)
 100f9bc:	f7f3 fe60 	bl	1003680 <bt_ctlr_assert_handle>
 100f9c0:	e7d6      	b.n	100f970 <ull_filter_lll_rl_idx+0x20>
 100f9c2:	bf00      	nop
 100f9c4:	21005610 	.word	0x21005610
 100f9c8:	21005478 	.word	0x21005478
 100f9cc:	01018a44 	.word	0x01018a44

0100f9d0 <ull_filter_lll_rl_irk_idx>:
{
 100f9d0:	b510      	push	{r4, lr}
	LL_ASSERT(irkmatch_id < peer_irk_count);
 100f9d2:	4b14      	ldr	r3, [pc, #80]	; (100fa24 <ull_filter_lll_rl_irk_idx+0x54>)
{
 100f9d4:	4604      	mov	r4, r0
	LL_ASSERT(irkmatch_id < peer_irk_count);
 100f9d6:	781b      	ldrb	r3, [r3, #0]
 100f9d8:	4283      	cmp	r3, r0
 100f9da:	d90c      	bls.n	100f9f6 <ull_filter_lll_rl_irk_idx+0x26>
	i = peer_irk_rl_ids[irkmatch_id];
 100f9dc:	4b12      	ldr	r3, [pc, #72]	; (100fa28 <ull_filter_lll_rl_irk_idx+0x58>)
 100f9de:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(i < CONFIG_BT_CTLR_RL_SIZE);
 100f9e0:	2c07      	cmp	r4, #7
 100f9e2:	d811      	bhi.n	100fa08 <ull_filter_lll_rl_irk_idx+0x38>
	LL_ASSERT(rl[i].taken);
 100f9e4:	4b11      	ldr	r3, [pc, #68]	; (100fa2c <ull_filter_lll_rl_irk_idx+0x5c>)
 100f9e6:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 100f9ea:	f813 3032 	ldrb.w	r3, [r3, r2, lsl #3]
 100f9ee:	07db      	lsls	r3, r3, #31
 100f9f0:	d510      	bpl.n	100fa14 <ull_filter_lll_rl_irk_idx+0x44>
}
 100f9f2:	4620      	mov	r0, r4
 100f9f4:	bd10      	pop	{r4, pc}
	LL_ASSERT(irkmatch_id < peer_irk_count);
 100f9f6:	f44f 712f 	mov.w	r1, #700	; 0x2bc
 100f9fa:	480d      	ldr	r0, [pc, #52]	; (100fa30 <ull_filter_lll_rl_irk_idx+0x60>)
 100f9fc:	f7f3 fe40 	bl	1003680 <bt_ctlr_assert_handle>
	i = peer_irk_rl_ids[irkmatch_id];
 100fa00:	4b09      	ldr	r3, [pc, #36]	; (100fa28 <ull_filter_lll_rl_irk_idx+0x58>)
 100fa02:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(i < CONFIG_BT_CTLR_RL_SIZE);
 100fa04:	2c07      	cmp	r4, #7
 100fa06:	d9ed      	bls.n	100f9e4 <ull_filter_lll_rl_irk_idx+0x14>
 100fa08:	f240 21be 	movw	r1, #702	; 0x2be
 100fa0c:	4808      	ldr	r0, [pc, #32]	; (100fa30 <ull_filter_lll_rl_irk_idx+0x60>)
 100fa0e:	f7f3 fe37 	bl	1003680 <bt_ctlr_assert_handle>
 100fa12:	e7e7      	b.n	100f9e4 <ull_filter_lll_rl_irk_idx+0x14>
	LL_ASSERT(rl[i].taken);
 100fa14:	f240 21bf 	movw	r1, #703	; 0x2bf
 100fa18:	4805      	ldr	r0, [pc, #20]	; (100fa30 <ull_filter_lll_rl_irk_idx+0x60>)
 100fa1a:	f7f3 fe31 	bl	1003680 <bt_ctlr_assert_handle>
}
 100fa1e:	4620      	mov	r0, r4
 100fa20:	bd10      	pop	{r4, pc}
 100fa22:	bf00      	nop
 100fa24:	210080c6 	.word	0x210080c6
 100fa28:	210053f0 	.word	0x210053f0
 100fa2c:	21005478 	.word	0x21005478
 100fa30:	01018a44 	.word	0x01018a44

0100fa34 <ull_filter_lll_irk_whitelisted>:
	if (rl_idx >= ARRAY_SIZE(rl)) {
 100fa34:	2807      	cmp	r0, #7
 100fa36:	d81b      	bhi.n	100fa70 <ull_filter_lll_irk_whitelisted+0x3c>
{
 100fa38:	b570      	push	{r4, r5, r6, lr}
	LL_ASSERT(rl[rl_idx].taken);
 100fa3a:	4e0e      	ldr	r6, [pc, #56]	; (100fa74 <ull_filter_lll_irk_whitelisted+0x40>)
 100fa3c:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 100fa40:	f816 3033 	ldrb.w	r3, [r6, r3, lsl #3]
 100fa44:	4604      	mov	r4, r0
 100fa46:	07db      	lsls	r3, r3, #31
 100fa48:	ea4f 0580 	mov.w	r5, r0, lsl #2
 100fa4c:	d505      	bpl.n	100fa5a <ull_filter_lll_irk_whitelisted+0x26>
	return rl[rl_idx].wl;
 100fa4e:	442c      	add	r4, r5
 100fa50:	f816 0034 	ldrb.w	r0, [r6, r4, lsl #3]
 100fa54:	f3c0 1040 	ubfx	r0, r0, #5, #1
}
 100fa58:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(rl[rl_idx].taken);
 100fa5a:	f240 21ca 	movw	r1, #714	; 0x2ca
 100fa5e:	4806      	ldr	r0, [pc, #24]	; (100fa78 <ull_filter_lll_irk_whitelisted+0x44>)
	return rl[rl_idx].wl;
 100fa60:	442c      	add	r4, r5
	LL_ASSERT(rl[rl_idx].taken);
 100fa62:	f7f3 fe0d 	bl	1003680 <bt_ctlr_assert_handle>
	return rl[rl_idx].wl;
 100fa66:	f816 0034 	ldrb.w	r0, [r6, r4, lsl #3]
 100fa6a:	f3c0 1040 	ubfx	r0, r0, #5, #1
}
 100fa6e:	bd70      	pop	{r4, r5, r6, pc}
		return false;
 100fa70:	2000      	movs	r0, #0
}
 100fa72:	4770      	bx	lr
 100fa74:	21005478 	.word	0x21005478
 100fa78:	01018a44 	.word	0x01018a44

0100fa7c <ull_filter_lll_get>:
		return &wl_filter;
 100fa7c:	4a03      	ldr	r2, [pc, #12]	; (100fa8c <ull_filter_lll_get+0x10>)
 100fa7e:	4b04      	ldr	r3, [pc, #16]	; (100fa90 <ull_filter_lll_get+0x14>)
}
 100fa80:	2800      	cmp	r0, #0
 100fa82:	bf0c      	ite	eq
 100fa84:	4610      	moveq	r0, r2
 100fa86:	4618      	movne	r0, r3
 100fa88:	4770      	bx	lr
 100fa8a:	bf00      	nop
 100fa8c:	210055b8 	.word	0x210055b8
 100fa90:	21005650 	.word	0x21005650

0100fa94 <ull_filter_lll_rl_idx_allowed>:
	if (!rl_enable || rl_idx >= ARRAY_SIZE(rl) || irkmatch_ok) {
 100fa94:	4b10      	ldr	r3, [pc, #64]	; (100fad8 <ull_filter_lll_rl_idx_allowed+0x44>)
 100fa96:	781b      	ldrb	r3, [r3, #0]
 100fa98:	b19b      	cbz	r3, 100fac2 <ull_filter_lll_rl_idx_allowed+0x2e>
 100fa9a:	2907      	cmp	r1, #7
{
 100fa9c:	b570      	push	{r4, r5, r6, lr}
 100fa9e:	460c      	mov	r4, r1
	if (!rl_enable || rl_idx >= ARRAY_SIZE(rl) || irkmatch_ok) {
 100faa0:	d80d      	bhi.n	100fabe <ull_filter_lll_rl_idx_allowed+0x2a>
 100faa2:	b960      	cbnz	r0, 100fabe <ull_filter_lll_rl_idx_allowed+0x2a>
	LL_ASSERT(rl[rl_idx].taken);
 100faa4:	4e0d      	ldr	r6, [pc, #52]	; (100fadc <ull_filter_lll_rl_idx_allowed+0x48>)
 100faa6:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 100faaa:	f816 3033 	ldrb.w	r3, [r6, r3, lsl #3]
 100faae:	008d      	lsls	r5, r1, #2
 100fab0:	07da      	lsls	r2, r3, #31
 100fab2:	d50b      	bpl.n	100facc <ull_filter_lll_rl_idx_allowed+0x38>
	return !rl[rl_idx].pirk || rl[rl_idx].dev;
 100fab4:	442c      	add	r4, r5
 100fab6:	f816 0034 	ldrb.w	r0, [r6, r4, lsl #3]
 100faba:	0743      	lsls	r3, r0, #29
 100fabc:	d403      	bmi.n	100fac6 <ull_filter_lll_rl_idx_allowed+0x32>
		return true;
 100fabe:	2001      	movs	r0, #1
}
 100fac0:	bd70      	pop	{r4, r5, r6, pc}
		return true;
 100fac2:	2001      	movs	r0, #1
}
 100fac4:	4770      	bx	lr
	return !rl[rl_idx].pirk || rl[rl_idx].dev;
 100fac6:	f3c0 1000 	ubfx	r0, r0, #4, #1
}
 100faca:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(rl[rl_idx].taken);
 100facc:	f240 21f2 	movw	r1, #754	; 0x2f2
 100fad0:	4803      	ldr	r0, [pc, #12]	; (100fae0 <ull_filter_lll_rl_idx_allowed+0x4c>)
 100fad2:	f7f3 fdd5 	bl	1003680 <bt_ctlr_assert_handle>
 100fad6:	e7ed      	b.n	100fab4 <ull_filter_lll_rl_idx_allowed+0x20>
 100fad8:	210080c7 	.word	0x210080c7
 100fadc:	21005478 	.word	0x21005478
 100fae0:	01018a44 	.word	0x01018a44

0100fae4 <ull_filter_lll_rl_addr_allowed>:
	if (!rl_enable || *rl_idx != FILTER_IDX_NONE) {
 100fae4:	4b1c      	ldr	r3, [pc, #112]	; (100fb58 <ull_filter_lll_rl_addr_allowed+0x74>)
 100fae6:	781b      	ldrb	r3, [r3, #0]
 100fae8:	b1fb      	cbz	r3, 100fb2a <ull_filter_lll_rl_addr_allowed+0x46>
 100faea:	7813      	ldrb	r3, [r2, #0]
 100faec:	2bff      	cmp	r3, #255	; 0xff
 100faee:	d11c      	bne.n	100fb2a <ull_filter_lll_rl_addr_allowed+0x46>
{
 100faf0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (!rl_enable || *rl_idx != FILTER_IDX_NONE) {
 100faf4:	2300      	movs	r3, #0
 100faf6:	4606      	mov	r6, r0
 100faf8:	4d18      	ldr	r5, [pc, #96]	; (100fb5c <ull_filter_lll_rl_addr_allowed+0x78>)
 100fafa:	1faf      	subs	r7, r5, #6
		if (rl[i].taken && (rl[i].id_addr_type == id_addr_type)) {
 100fafc:	eb03 0483 	add.w	r4, r3, r3, lsl #2
 100fb00:	f817 4034 	ldrb.w	r4, [r7, r4, lsl #3]
 100fb04:	fa5f fe83 	uxtb.w	lr, r3
 100fb08:	f014 0001 	ands.w	r0, r4, #1
 100fb0c:	ea4f 0c83 	mov.w	ip, r3, lsl #2
 100fb10:	d003      	beq.n	100fb1a <ull_filter_lll_rl_addr_allowed+0x36>
 100fb12:	f3c4 1480 	ubfx	r4, r4, #6, #1
 100fb16:	42b4      	cmp	r4, r6
 100fb18:	d009      	beq.n	100fb2e <ull_filter_lll_rl_addr_allowed+0x4a>
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
 100fb1a:	3301      	adds	r3, #1
 100fb1c:	2b08      	cmp	r3, #8
 100fb1e:	f105 0528 	add.w	r5, r5, #40	; 0x28
 100fb22:	d1eb      	bne.n	100fafc <ull_filter_lll_rl_addr_allowed+0x18>
		return true;
 100fb24:	2001      	movs	r0, #1
}
 100fb26:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return true;
 100fb2a:	2001      	movs	r0, #1
}
 100fb2c:	4770      	bx	lr
			for (j = 0U; j < BDADDR_SIZE; j++) {
 100fb2e:	1fac      	subs	r4, r5, #6
 100fb30:	f101 38ff 	add.w	r8, r1, #4294967295
				if (addr[j] != id_addr[j]) {
 100fb34:	f814 af01 	ldrb.w	sl, [r4, #1]!
 100fb38:	f818 9f01 	ldrb.w	r9, [r8, #1]!
 100fb3c:	45ca      	cmp	sl, r9
 100fb3e:	d1ec      	bne.n	100fb1a <ull_filter_lll_rl_addr_allowed+0x36>
			for (j = 0U; j < BDADDR_SIZE; j++) {
 100fb40:	42ac      	cmp	r4, r5
 100fb42:	d1f7      	bne.n	100fb34 <ull_filter_lll_rl_addr_allowed+0x50>
				*rl_idx = i;
 100fb44:	f882 e000 	strb.w	lr, [r2]
				return !rl[i].pirk || rl[i].dev;
 100fb48:	4463      	add	r3, ip
 100fb4a:	f817 3033 	ldrb.w	r3, [r7, r3, lsl #3]
 100fb4e:	075a      	lsls	r2, r3, #29
 100fb50:	d5e9      	bpl.n	100fb26 <ull_filter_lll_rl_addr_allowed+0x42>
 100fb52:	f3c3 1000 	ubfx	r0, r3, #4, #1
 100fb56:	e7e6      	b.n	100fb26 <ull_filter_lll_rl_addr_allowed+0x42>
 100fb58:	210080c7 	.word	0x210080c7
 100fb5c:	2100547e 	.word	0x2100547e

0100fb60 <ull_filter_lll_rl_addr_resolve>:
{
 100fb60:	b430      	push	{r4, r5}
	if (!rl_enable || rl_idx >= ARRAY_SIZE(rl) || !rl[rl_idx].lirk) {
 100fb62:	4b0d      	ldr	r3, [pc, #52]	; (100fb98 <ull_filter_lll_rl_addr_resolve+0x38>)
 100fb64:	781c      	ldrb	r4, [r3, #0]
 100fb66:	b17c      	cbz	r4, 100fb88 <ull_filter_lll_rl_addr_resolve+0x28>
 100fb68:	2a07      	cmp	r2, #7
 100fb6a:	d80d      	bhi.n	100fb88 <ull_filter_lll_rl_addr_resolve+0x28>
 100fb6c:	4c0b      	ldr	r4, [pc, #44]	; (100fb9c <ull_filter_lll_rl_addr_resolve+0x3c>)
 100fb6e:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 100fb72:	f814 5032 	ldrb.w	r5, [r4, r2, lsl #3]
 100fb76:	00d2      	lsls	r2, r2, #3
 100fb78:	072b      	lsls	r3, r5, #28
 100fb7a:	d505      	bpl.n	100fb88 <ull_filter_lll_rl_addr_resolve+0x28>
	if ((id_addr_type != 0U) && ((id_addr[5] & 0xc0) == 0x40)) {
 100fb7c:	b120      	cbz	r0, 100fb88 <ull_filter_lll_rl_addr_resolve+0x28>
 100fb7e:	794b      	ldrb	r3, [r1, #5]
 100fb80:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 100fb84:	2b40      	cmp	r3, #64	; 0x40
 100fb86:	d002      	beq.n	100fb8e <ull_filter_lll_rl_addr_resolve+0x2e>
}
 100fb88:	bc30      	pop	{r4, r5}
 100fb8a:	2000      	movs	r0, #0
 100fb8c:	4770      	bx	lr
		return bt_rpa_irk_matches(rl[rl_idx].local_irk,
 100fb8e:	3207      	adds	r2, #7
 100fb90:	18a0      	adds	r0, r4, r2
}
 100fb92:	bc30      	pop	{r4, r5}
		return bt_rpa_irk_matches(rl[rl_idx].local_irk,
 100fb94:	f006 bfae 	b.w	1016af4 <bt_rpa_irk_matches>
 100fb98:	210080c7 	.word	0x210080c7
 100fb9c:	21005478 	.word	0x21005478

0100fba0 <ull_filter_lll_rl_enabled>:
	return rl_enable;
 100fba0:	4b02      	ldr	r3, [pc, #8]	; (100fbac <ull_filter_lll_rl_enabled+0xc>)
 100fba2:	7818      	ldrb	r0, [r3, #0]
}
 100fba4:	3800      	subs	r0, #0
 100fba6:	bf18      	it	ne
 100fba8:	2001      	movne	r0, #1
 100fbaa:	4770      	bx	lr
 100fbac:	210080c7 	.word	0x210080c7

0100fbb0 <radio_nrf5_isr>:
#if (CONFIG_BT_CTLR_LLL_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
static void ticker_op_job_disable(u32_t status, void *op_context);
#endif
#endif /* CONFIG_BT_CTLR_LOW_LAT */

ISR_DIRECT_DECLARE(radio_nrf5_isr)
 100fbb0:	4668      	mov	r0, sp
 100fbb2:	f020 0107 	bic.w	r1, r0, #7
 100fbb6:	468d      	mov	sp, r1
 100fbb8:	b501      	push	{r0, lr}
{
	DEBUG_RADIO_ISR(1);

	isr_radio();
 100fbba:	f002 f8c9 	bl	1011d50 <isr_radio>

	ISR_DIRECT_PM();
 100fbbe:	f7f5 f96d 	bl	1004e9c <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING
	sys_trace_isr_exit();
#endif
	if (maybe_swap) {
		z_arm_int_exit();
 100fbc2:	f7f5 fc4f 	bl	1005464 <z_arm_exc_exit>
ISR_DIRECT_DECLARE(radio_nrf5_isr)
 100fbc6:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
 100fbca:	4685      	mov	sp, r0
 100fbcc:	4770      	bx	lr
 100fbce:	bf00      	nop

0100fbd0 <rtc0_nrf5_isr>:
	DEBUG_RADIO_ISR(0);
	return 1;
}

static void rtc0_nrf5_isr(void *arg)
{
 100fbd0:	b508      	push	{r3, lr}
	DEBUG_TICKER_ISR(1);

	/* On compare0 run ticker worker instance0 */
	if (NRF_RTC0->EVENTS_COMPARE[0]) {
 100fbd2:	4b09      	ldr	r3, [pc, #36]	; (100fbf8 <rtc0_nrf5_isr+0x28>)
 100fbd4:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
 100fbd8:	b93a      	cbnz	r2, 100fbea <rtc0_nrf5_isr+0x1a>
		NRF_RTC0->EVENTS_COMPARE[0] = 0;

		ticker_trigger(0);
	}

	mayfly_run(TICKER_USER_ID_ULL_HIGH);
 100fbda:	2001      	movs	r0, #1
 100fbdc:	f7f6 f9ca 	bl	1005f74 <mayfly_run>
	(CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	mayfly_run(TICKER_USER_ID_ULL_LOW);
#endif

	DEBUG_TICKER_ISR(0);
}
 100fbe0:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	mayfly_run(TICKER_USER_ID_ULL_LOW);
 100fbe4:	2002      	movs	r0, #2
 100fbe6:	f7f6 b9c5 	b.w	1005f74 <mayfly_run>
		NRF_RTC0->EVENTS_COMPARE[0] = 0;
 100fbea:	2000      	movs	r0, #0
 100fbec:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140
		ticker_trigger(0);
 100fbf0:	f7f7 fad6 	bl	10071a0 <ticker_trigger>
 100fbf4:	e7f1      	b.n	100fbda <rtc0_nrf5_isr+0xa>
 100fbf6:	bf00      	nop
 100fbf8:	41011000 	.word	0x41011000

0100fbfc <swi_lll_nrf5_isr>:

static void swi_lll_nrf5_isr(void *arg)
{
	DEBUG_RADIO_ISR(1);

	mayfly_run(TICKER_USER_ID_LLL);
 100fbfc:	2000      	movs	r0, #0
 100fbfe:	f7f6 b9b9 	b.w	1005f74 <mayfly_run>
 100fc02:	bf00      	nop

0100fc04 <ticker_start_op_cb>:
	/* NOTE: this callback is present only for addition of debug messages
	 * when needed, else can be dispensed with.
	 */
	ARG_UNUSED(param);

	LL_ASSERT((status == TICKER_STATUS_SUCCESS) ||
 100fc04:	2801      	cmp	r0, #1
 100fc06:	d800      	bhi.n	100fc0a <ticker_start_op_cb+0x6>
		  (status == TICKER_STATUS_FAILURE));
}
 100fc08:	4770      	bx	lr
	LL_ASSERT((status == TICKER_STATUS_SUCCESS) ||
 100fc0a:	f240 2107 	movw	r1, #519	; 0x207
 100fc0e:	4801      	ldr	r0, [pc, #4]	; (100fc14 <ticker_start_op_cb+0x10>)
 100fc10:	f7f3 bd36 	b.w	1003680 <bt_ctlr_assert_handle>
 100fc14:	01018a9c 	.word	0x01018a9c

0100fc18 <preempt_ticker_start.isra.0>:
	preempt_to = MAX(evt->ticks_active_to_start,
			 evt->ticks_xtal_to_start) -
			 evt->ticks_preempt_to_start;

	/* Setup pre empt timeout */
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 100fc18:	2200      	movs	r2, #0
static void preempt_ticker_start(struct lll_prepare_param *prepare_param)
 100fc1a:	b530      	push	{r4, r5, lr}
 100fc1c:	b08b      	sub	sp, #44	; 0x2c
	evt = HDR_LLL2EVT(prepare_param->param);
 100fc1e:	680b      	ldr	r3, [r1, #0]
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 100fc20:	4d12      	ldr	r5, [pc, #72]	; (100fc6c <preempt_ticker_start.isra.0+0x54>)
 100fc22:	e9cd 2203 	strd	r2, r2, [sp, #12]
 100fc26:	e9cd 2201 	strd	r2, r2, [sp, #4]
 100fc2a:	4c11      	ldr	r4, [pc, #68]	; (100fc70 <preempt_ticker_start.isra.0+0x58>)
 100fc2c:	9208      	str	r2, [sp, #32]
 100fc2e:	9206      	str	r2, [sp, #24]
 100fc30:	9507      	str	r5, [sp, #28]
 100fc32:	9405      	str	r4, [sp, #20]
	preempt_to = MAX(evt->ticks_active_to_start,
 100fc34:	6899      	ldr	r1, [r3, #8]
 100fc36:	e9d3 5400 	ldrd	r5, r4, [r3]
 100fc3a:	42a5      	cmp	r5, r4
 100fc3c:	bf2c      	ite	cs
 100fc3e:	ebc1 0105 	rsbcs	r1, r1, r5
 100fc42:	ebc1 0104 	rsbcc	r1, r1, r4
static void preempt_ticker_start(struct lll_prepare_param *prepare_param)
 100fc46:	4603      	mov	r3, r0
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 100fc48:	9100      	str	r1, [sp, #0]
 100fc4a:	4610      	mov	r0, r2
 100fc4c:	4611      	mov	r1, r2
 100fc4e:	f7f7 fb07 	bl	1007260 <ticker_start>
			   TICKER_NULL_REMAINDER,
			   TICKER_NULL_LAZY,
			   TICKER_NULL_SLOT,
			   preempt_ticker_cb, NULL,
			   ticker_start_op_cb, NULL);
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 100fc52:	2802      	cmp	r0, #2
 100fc54:	d801      	bhi.n	100fc5a <preempt_ticker_start.isra.0+0x42>
		  (ret == TICKER_STATUS_FAILURE) ||
		  (ret == TICKER_STATUS_BUSY));
}
 100fc56:	b00b      	add	sp, #44	; 0x2c
 100fc58:	bd30      	pop	{r4, r5, pc}
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 100fc5a:	f240 2125 	movw	r1, #549	; 0x225
 100fc5e:	4805      	ldr	r0, [pc, #20]	; (100fc74 <preempt_ticker_start.isra.0+0x5c>)
}
 100fc60:	b00b      	add	sp, #44	; 0x2c
 100fc62:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 100fc66:	f7f3 bd0b 	b.w	1003680 <bt_ctlr_assert_handle>
 100fc6a:	bf00      	nop
 100fc6c:	0100fc05 	.word	0x0100fc05
 100fc70:	0100fe49 	.word	0x0100fe49
 100fc74:	01018a9c 	.word	0x01018a9c

0100fc78 <preempt>:
			     0, &mfy);
	LL_ASSERT(!ret);
}

static void preempt(void *param)
{
 100fc78:	b5f0      	push	{r4, r5, r6, r7, lr}
 100fc7a:	b08b      	sub	sp, #44	; 0x2c
	struct lll_event *next = ull_prepare_dequeue_get();
 100fc7c:	f7fa fbf0 	bl	100a460 <ull_prepare_dequeue_get>
	lll_prepare_cb_t resume_cb;
	u8_t idx = UINT8_MAX;
 100fc80:	23ff      	movs	r3, #255	; 0xff
	int resume_prio;
	int ret;

	if (!event.curr.abort_cb || !event.curr.param) {
 100fc82:	4e3f      	ldr	r6, [pc, #252]	; (100fd80 <preempt+0x108>)
	u8_t idx = UINT8_MAX;
 100fc84:	f88d 300e 	strb.w	r3, [sp, #14]
	if (!event.curr.abort_cb || !event.curr.param) {
 100fc88:	68b3      	ldr	r3, [r6, #8]
 100fc8a:	b173      	cbz	r3, 100fcaa <preempt+0x32>
 100fc8c:	6833      	ldr	r3, [r6, #0]
 100fc8e:	b92b      	cbnz	r3, 100fc9c <preempt+0x24>
 100fc90:	e00b      	b.n	100fcaa <preempt+0x32>
	next = ull_prepare_dequeue_iter(&idx);
	if (!next) {
		return;
	}

	while (next && (next->is_aborted || next->is_resume)) {
 100fc92:	f890 0020 	ldrb.w	r0, [r0, #32]
 100fc96:	f010 0503 	ands.w	r5, r0, #3
 100fc9a:	d008      	beq.n	100fcae <preempt+0x36>
		next = ull_prepare_dequeue_iter(&idx);
 100fc9c:	f10d 000e 	add.w	r0, sp, #14
 100fca0:	f7fa fbec 	bl	100a47c <ull_prepare_dequeue_iter>
	while (next && (next->is_aborted || next->is_resume)) {
 100fca4:	4604      	mov	r4, r0
 100fca6:	2800      	cmp	r0, #0
 100fca8:	d1f3      	bne.n	100fc92 <preempt+0x1a>
			return;
		}
	} while (next->is_aborted || next->is_resume);

	preempt_ticker_start(&next->prepare_param);
}
 100fcaa:	b00b      	add	sp, #44	; 0x2c
 100fcac:	bdf0      	pop	{r4, r5, r6, r7, pc}
	ret = event.curr.is_abort_cb(next->prepare_param.param, next->prio,
 100fcae:	ab05      	add	r3, sp, #20
 100fcb0:	69e1      	ldr	r1, [r4, #28]
 100fcb2:	68e0      	ldr	r0, [r4, #12]
 100fcb4:	6877      	ldr	r7, [r6, #4]
 100fcb6:	9300      	str	r3, [sp, #0]
 100fcb8:	6832      	ldr	r2, [r6, #0]
 100fcba:	ab04      	add	r3, sp, #16
 100fcbc:	47b8      	blx	r7
	if (!ret) {
 100fcbe:	4607      	mov	r7, r0
 100fcc0:	2800      	cmp	r0, #0
 100fcc2:	d052      	beq.n	100fd6a <preempt+0xf2>
	event.curr.abort_cb(NULL, event.curr.param);
 100fcc4:	4628      	mov	r0, r5
 100fcc6:	68b3      	ldr	r3, [r6, #8]
 100fcc8:	6831      	ldr	r1, [r6, #0]
 100fcca:	4798      	blx	r3
	if (ret == -EAGAIN) {
 100fccc:	f117 0f0b 	cmn.w	r7, #11
 100fcd0:	d012      	beq.n	100fcf8 <preempt+0x80>
		LL_ASSERT(ret == -ECANCELED);
 100fcd2:	3748      	adds	r7, #72	; 0x48
 100fcd4:	d009      	beq.n	100fcea <preempt+0x72>
 100fcd6:	f240 216f 	movw	r1, #623	; 0x26f
 100fcda:	482a      	ldr	r0, [pc, #168]	; (100fd84 <preempt+0x10c>)
 100fcdc:	f7f3 fcd0 	bl	1003680 <bt_ctlr_assert_handle>
 100fce0:	e003      	b.n	100fcea <preempt+0x72>
	} while (next->is_aborted || next->is_resume);
 100fce2:	f890 3020 	ldrb.w	r3, [r0, #32]
 100fce6:	079b      	lsls	r3, r3, #30
 100fce8:	d039      	beq.n	100fd5e <preempt+0xe6>
		next = ull_prepare_dequeue_iter(&idx);
 100fcea:	f10d 000e 	add.w	r0, sp, #14
 100fcee:	f7fa fbc5 	bl	100a47c <ull_prepare_dequeue_iter>
		if (!next) {
 100fcf2:	2800      	cmp	r0, #0
 100fcf4:	d1f5      	bne.n	100fce2 <preempt+0x6a>
 100fcf6:	e7d8      	b.n	100fcaa <preempt+0x32>
		u8_t iter_idx = UINT8_MAX;
 100fcf8:	23ff      	movs	r3, #255	; 0xff
		iter = ull_prepare_dequeue_iter(&iter_idx);
 100fcfa:	f10d 000f 	add.w	r0, sp, #15
		u8_t iter_idx = UINT8_MAX;
 100fcfe:	f88d 300f 	strb.w	r3, [sp, #15]
		iter = ull_prepare_dequeue_iter(&iter_idx);
 100fd02:	f7fa fbbb 	bl	100a47c <ull_prepare_dequeue_iter>
		while (iter) {
 100fd06:	bb08      	cbnz	r0, 100fd4c <preempt+0xd4>
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
 100fd08:	2201      	movs	r2, #1
	event.curr.param = NULL;
 100fd0a:	2100      	movs	r1, #0
		ret = resume_enqueue(resume_cb, resume_prio);
 100fd0c:	9b05      	ldr	r3, [sp, #20]
	prepare_param.param = event.curr.param;
 100fd0e:	6834      	ldr	r4, [r6, #0]
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
 100fd10:	e9cd 3200 	strd	r3, r2, [sp]
	event.curr.param = NULL;
 100fd14:	6031      	str	r1, [r6, #0]
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
 100fd16:	9b04      	ldr	r3, [sp, #16]
 100fd18:	aa06      	add	r2, sp, #24
 100fd1a:	e9d6 0101 	ldrd	r0, r1, [r6, #4]
	prepare_param.param = event.curr.param;
 100fd1e:	9409      	str	r4, [sp, #36]	; 0x24
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
 100fd20:	f7fa fb66 	bl	100a3f0 <ull_prepare_enqueue>
		LL_ASSERT(!ret);
 100fd24:	2800      	cmp	r0, #0
 100fd26:	d0e0      	beq.n	100fcea <preempt+0x72>
 100fd28:	f240 216d 	movw	r1, #621	; 0x26d
 100fd2c:	4815      	ldr	r0, [pc, #84]	; (100fd84 <preempt+0x10c>)
 100fd2e:	f7f3 fca7 	bl	1003680 <bt_ctlr_assert_handle>
 100fd32:	e7da      	b.n	100fcea <preempt+0x72>
				iter->is_aborted = 1;
 100fd34:	f043 0302 	orr.w	r3, r3, #2
 100fd38:	f880 3020 	strb.w	r3, [r0, #32]
				iter->abort_cb(&iter->prepare_param,
 100fd3c:	6983      	ldr	r3, [r0, #24]
 100fd3e:	4798      	blx	r3
			iter = ull_prepare_dequeue_iter(&iter_idx);
 100fd40:	f10d 000f 	add.w	r0, sp, #15
 100fd44:	f7fa fb9a 	bl	100a47c <ull_prepare_dequeue_iter>
		while (iter) {
 100fd48:	2800      	cmp	r0, #0
 100fd4a:	d0dd      	beq.n	100fd08 <preempt+0x90>
			if (!iter->is_aborted &&
 100fd4c:	f890 3020 	ldrb.w	r3, [r0, #32]
 100fd50:	079a      	lsls	r2, r3, #30
 100fd52:	d4f5      	bmi.n	100fd40 <preempt+0xc8>
			    event.curr.param == iter->prepare_param.param) {
 100fd54:	68c2      	ldr	r2, [r0, #12]
			if (!iter->is_aborted &&
 100fd56:	6831      	ldr	r1, [r6, #0]
 100fd58:	4291      	cmp	r1, r2
 100fd5a:	d1f1      	bne.n	100fd40 <preempt+0xc8>
 100fd5c:	e7ea      	b.n	100fd34 <preempt+0xbc>
	preempt_ticker_start(&next->prepare_param);
 100fd5e:	68c1      	ldr	r1, [r0, #12]
 100fd60:	6800      	ldr	r0, [r0, #0]
 100fd62:	f7ff ff59 	bl	100fc18 <preempt_ticker_start.isra.0>
}
 100fd66:	b00b      	add	sp, #44	; 0x2c
 100fd68:	bdf0      	pop	{r4, r5, r6, r7, pc}
		next->is_aborted = 1;
 100fd6a:	f894 3020 	ldrb.w	r3, [r4, #32]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
 100fd6e:	4620      	mov	r0, r4
		next->is_aborted = 1;
 100fd70:	f043 0302 	orr.w	r3, r3, #2
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
 100fd74:	69a2      	ldr	r2, [r4, #24]
 100fd76:	68e1      	ldr	r1, [r4, #12]
		next->is_aborted = 1;
 100fd78:	f884 3020 	strb.w	r3, [r4, #32]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
 100fd7c:	4790      	blx	r2
		goto preempt_next;
 100fd7e:	e7b4      	b.n	100fcea <preempt+0x72>
 100fd80:	21005688 	.word	0x21005688
 100fd84:	01018a9c 	.word	0x01018a9c

0100fd88 <prepare>:
	u8_t idx = UINT8_MAX;
 100fd88:	f04f 0cff 	mov.w	ip, #255	; 0xff
{
 100fd8c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 100fd90:	b085      	sub	sp, #20
 100fd92:	4604      	mov	r4, r0
	p = ull_prepare_dequeue_iter(&idx);
 100fd94:	f10d 000f 	add.w	r0, sp, #15
{
 100fd98:	460d      	mov	r5, r1
 100fd9a:	4616      	mov	r6, r2
 100fd9c:	461f      	mov	r7, r3
 100fd9e:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 100fda2:	f89d 9034 	ldrb.w	r9, [sp, #52]	; 0x34
	u8_t idx = UINT8_MAX;
 100fda6:	f88d c00f 	strb.w	ip, [sp, #15]
	p = ull_prepare_dequeue_iter(&idx);
 100fdaa:	f7fa fb67 	bl	100a47c <ull_prepare_dequeue_iter>
	while (p && (p->is_aborted || p->is_resume)) {
 100fdae:	b928      	cbnz	r0, 100fdbc <prepare+0x34>
 100fdb0:	e01d      	b.n	100fdee <prepare+0x66>
		p = ull_prepare_dequeue_iter(&idx);
 100fdb2:	f10d 000f 	add.w	r0, sp, #15
 100fdb6:	f7fa fb61 	bl	100a47c <ull_prepare_dequeue_iter>
	while (p && (p->is_aborted || p->is_resume)) {
 100fdba:	b1c0      	cbz	r0, 100fdee <prepare+0x66>
 100fdbc:	f890 3020 	ldrb.w	r3, [r0, #32]
 100fdc0:	079b      	lsls	r3, r3, #30
 100fdc2:	d1f6      	bne.n	100fdb2 <prepare+0x2a>
	if (event.curr.abort_cb || (p && is_resume)) {
 100fdc4:	4b1e      	ldr	r3, [pc, #120]	; (100fe40 <prepare+0xb8>)
 100fdc6:	689a      	ldr	r2, [r3, #8]
 100fdc8:	b9a2      	cbnz	r2, 100fdf4 <prepare+0x6c>
 100fdca:	f1b9 0f00 	cmp.w	r9, #0
 100fdce:	d02d      	beq.n	100fe2c <prepare+0xa4>
		ret = ull_prepare_enqueue(is_abort_cb, abort_cb, prepare_param,
 100fdd0:	2201      	movs	r2, #1
 100fdd2:	4633      	mov	r3, r6
 100fdd4:	9201      	str	r2, [sp, #4]
 100fdd6:	4629      	mov	r1, r5
 100fdd8:	4620      	mov	r0, r4
 100fdda:	4642      	mov	r2, r8
 100fddc:	9700      	str	r7, [sp, #0]
 100fdde:	f7fa fb07 	bl	100a3f0 <ull_prepare_enqueue>
		LL_ASSERT(!ret);
 100fde2:	b9d0      	cbnz	r0, 100fe1a <prepare+0x92>
		return -EINPROGRESS;
 100fde4:	f06f 0043 	mvn.w	r0, #67	; 0x43
}
 100fde8:	b005      	add	sp, #20
 100fdea:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (event.curr.abort_cb || (p && is_resume)) {
 100fdee:	4b14      	ldr	r3, [pc, #80]	; (100fe40 <prepare+0xb8>)
 100fdf0:	689a      	ldr	r2, [r3, #8]
 100fdf2:	b1da      	cbz	r2, 100fe2c <prepare+0xa4>
		ret = ull_prepare_enqueue(is_abort_cb, abort_cb, prepare_param,
 100fdf4:	4633      	mov	r3, r6
 100fdf6:	4629      	mov	r1, r5
 100fdf8:	4620      	mov	r0, r4
 100fdfa:	4642      	mov	r2, r8
 100fdfc:	e9cd 7900 	strd	r7, r9, [sp]
 100fe00:	f7fa faf6 	bl	100a3f0 <ull_prepare_enqueue>
		LL_ASSERT(!ret);
 100fe04:	b948      	cbnz	r0, 100fe1a <prepare+0x92>
		if (is_resume) {
 100fe06:	f1b9 0f00 	cmp.w	r9, #0
 100fe0a:	d1eb      	bne.n	100fde4 <prepare+0x5c>
		preempt_ticker_start(prepare_param);
 100fe0c:	f8d8 100c 	ldr.w	r1, [r8, #12]
 100fe10:	f8d8 0000 	ldr.w	r0, [r8]
 100fe14:	f7ff ff00 	bl	100fc18 <preempt_ticker_start.isra.0>
 100fe18:	e7e4      	b.n	100fde4 <prepare+0x5c>
		LL_ASSERT(!ret);
 100fe1a:	f240 11bb 	movw	r1, #443	; 0x1bb
 100fe1e:	4809      	ldr	r0, [pc, #36]	; (100fe44 <prepare+0xbc>)
 100fe20:	f7f3 fc2e 	bl	1003680 <bt_ctlr_assert_handle>
		if (is_resume) {
 100fe24:	f1b9 0f00 	cmp.w	r9, #0
 100fe28:	d1dc      	bne.n	100fde4 <prepare+0x5c>
 100fe2a:	e7ef      	b.n	100fe0c <prepare+0x84>
	event.curr.param = prepare_param->param;
 100fe2c:	f8d8 200c 	ldr.w	r2, [r8, #12]
	err = prepare_cb(prepare_param);
 100fe30:	4640      	mov	r0, r8
	event.curr.abort_cb = abort_cb;
 100fe32:	e9c3 4501 	strd	r4, r5, [r3, #4]
	event.curr.param = prepare_param->param;
 100fe36:	601a      	str	r2, [r3, #0]
	err = prepare_cb(prepare_param);
 100fe38:	47b0      	blx	r6
}
 100fe3a:	b005      	add	sp, #20
 100fe3c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 100fe40:	21005688 	.word	0x21005688
 100fe44:	01018a9c 	.word	0x01018a9c

0100fe48 <preempt_ticker_cb>:
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100fe48:	2200      	movs	r2, #0
{
 100fe4a:	b508      	push	{r3, lr}
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100fe4c:	4611      	mov	r1, r2
 100fe4e:	2001      	movs	r0, #1
 100fe50:	4b05      	ldr	r3, [pc, #20]	; (100fe68 <preempt_ticker_cb+0x20>)
 100fe52:	f7f6 f839 	bl	1005ec8 <mayfly_enqueue>
	LL_ASSERT(!ret);
 100fe56:	b900      	cbnz	r0, 100fe5a <preempt_ticker_cb+0x12>
}
 100fe58:	bd08      	pop	{r3, pc}
	LL_ASSERT(!ret);
 100fe5a:	f240 2133 	movw	r1, #563	; 0x233
}
 100fe5e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	LL_ASSERT(!ret);
 100fe62:	4802      	ldr	r0, [pc, #8]	; (100fe6c <preempt_ticker_cb+0x24>)
 100fe64:	f7f3 bc0c 	b.w	1003680 <bt_ctlr_assert_handle>
 100fe68:	21000444 	.word	0x21000444
 100fe6c:	01018a9c 	.word	0x01018a9c

0100fe70 <lll_init>:
{
 100fe70:	b510      	push	{r4, lr}
 100fe72:	4815      	ldr	r0, [pc, #84]	; (100fec8 <lll_init+0x58>)
 100fe74:	f003 ff4a 	bl	1013d0c <z_impl_device_get_binding>
	dev_entropy = device_get_binding(DT_LABEL(DT_NODELABEL(rng)));
 100fe78:	4b14      	ldr	r3, [pc, #80]	; (100fecc <lll_init+0x5c>)
 100fe7a:	6018      	str	r0, [r3, #0]
	if (!dev_entropy) {
 100fe7c:	b300      	cbz	r0, 100fec0 <lll_init+0x50>
	event.curr.abort_cb = NULL;
 100fe7e:	2200      	movs	r2, #0
 100fe80:	4b13      	ldr	r3, [pc, #76]	; (100fed0 <lll_init+0x60>)
 100fe82:	609a      	str	r2, [r3, #8]
	err = lll_clock_init();
 100fe84:	f000 f952 	bl	101012c <lll_clock_init>
	if (err) {
 100fe88:	4604      	mov	r4, r0
 100fe8a:	b9b8      	cbnz	r0, 100febc <lll_init+0x4c>
	IRQ_DIRECT_CONNECT(RADIO_IRQn, CONFIG_BT_CTLR_LLL_PRIO,
 100fe8c:	4602      	mov	r2, r0
 100fe8e:	4601      	mov	r1, r0
 100fe90:	2008      	movs	r0, #8
 100fe92:	f7f4 ffed 	bl	1004e70 <z_arm_irq_priority_set>
	IRQ_CONNECT(RTC0_IRQn, CONFIG_BT_CTLR_ULL_HIGH_PRIO,
 100fe96:	4622      	mov	r2, r4
 100fe98:	4621      	mov	r1, r4
 100fe9a:	2011      	movs	r0, #17
 100fe9c:	f7f4 ffe8 	bl	1004e70 <z_arm_irq_priority_set>
	IRQ_CONNECT(HAL_SWI_RADIO_IRQ, CONFIG_BT_CTLR_LLL_PRIO,
 100fea0:	4622      	mov	r2, r4
 100fea2:	4621      	mov	r1, r4
 100fea4:	2014      	movs	r0, #20
 100fea6:	f7f4 ffe3 	bl	1004e70 <z_arm_irq_priority_set>
	irq_enable(RADIO_IRQn);
 100feaa:	2008      	movs	r0, #8
 100feac:	f7f4 ffae 	bl	1004e0c <arch_irq_enable>
	irq_enable(RTC0_IRQn);
 100feb0:	2011      	movs	r0, #17
 100feb2:	f7f4 ffab 	bl	1004e0c <arch_irq_enable>
	irq_enable(HAL_SWI_RADIO_IRQ);
 100feb6:	2014      	movs	r0, #20
 100feb8:	f7f4 ffa8 	bl	1004e0c <arch_irq_enable>
}
 100febc:	4620      	mov	r0, r4
 100febe:	bd10      	pop	{r4, pc}
		return -ENODEV;
 100fec0:	f06f 0412 	mvn.w	r4, #18
 100fec4:	e7fa      	b.n	100febc <lll_init+0x4c>
 100fec6:	bf00      	nop
 100fec8:	01018ae4 	.word	0x01018ae4
 100fecc:	21005684 	.word	0x21005684
 100fed0:	21005688 	.word	0x21005688

0100fed4 <lll_trng_get>:
	return entropy_get_entropy(dev_entropy, buf, len);
 100fed4:	4a04      	ldr	r2, [pc, #16]	; (100fee8 <lll_trng_get+0x14>)
{
 100fed6:	4603      	mov	r3, r0
 100fed8:	b410      	push	{r4}
	return entropy_get_entropy(dev_entropy, buf, len);
 100feda:	6810      	ldr	r0, [r2, #0]
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->driver_api;

	__ASSERT(api->get_entropy != NULL,
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
 100fedc:	6884      	ldr	r4, [r0, #8]
 100fede:	b28a      	uxth	r2, r1
 100fee0:	4619      	mov	r1, r3
 100fee2:	6823      	ldr	r3, [r4, #0]
}
 100fee4:	bc10      	pop	{r4}
 100fee6:	4718      	bx	r3
 100fee8:	21005684 	.word	0x21005684

0100feec <lll_trng_isr_get>:
	return entropy_get_entropy_isr(dev_entropy, buf, len, 0);
 100feec:	4b08      	ldr	r3, [pc, #32]	; (100ff10 <lll_trng_isr_get+0x24>)
{
 100feee:	460a      	mov	r2, r1
 100fef0:	4601      	mov	r1, r0
	return entropy_get_entropy_isr(dev_entropy, buf, len, 0);
 100fef2:	6818      	ldr	r0, [r3, #0]
{
 100fef4:	b410      	push	{r4}
					  u32_t flags)
{
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->driver_api;

	if (unlikely(!api->get_entropy_isr)) {
 100fef6:	6883      	ldr	r3, [r0, #8]
 100fef8:	685c      	ldr	r4, [r3, #4]
 100fefa:	b124      	cbz	r4, 100ff06 <lll_trng_isr_get+0x1a>
		return -ENOTSUP;
	}

	return api->get_entropy_isr(dev, buffer, length, flags);
 100fefc:	46a4      	mov	ip, r4
 100fefe:	2300      	movs	r3, #0
}
 100ff00:	bc10      	pop	{r4}
 100ff02:	b292      	uxth	r2, r2
 100ff04:	4760      	bx	ip
 100ff06:	f06f 0022 	mvn.w	r0, #34	; 0x22
 100ff0a:	bc10      	pop	{r4}
 100ff0c:	4770      	bx	lr
 100ff0e:	bf00      	nop
 100ff10:	21005684 	.word	0x21005684

0100ff14 <lll_rng_isr_get>:
 100ff14:	f7ff bfea 	b.w	100feec <lll_trng_isr_get>

0100ff18 <lll_reset>:
}
 100ff18:	2000      	movs	r0, #0
 100ff1a:	4770      	bx	lr

0100ff1c <lll_prepare>:
{
 100ff1c:	b530      	push	{r4, r5, lr}
	return prepare(is_abort_cb, abort_cb, prepare_cb, prio, prepare_param,
 100ff1e:	2500      	movs	r5, #0
{
 100ff20:	b083      	sub	sp, #12
 100ff22:	9c06      	ldr	r4, [sp, #24]
	return prepare(is_abort_cb, abort_cb, prepare_cb, prio, prepare_param,
 100ff24:	e9cd 4500 	strd	r4, r5, [sp]
 100ff28:	f7ff ff2e 	bl	100fd88 <prepare>
}
 100ff2c:	b003      	add	sp, #12
 100ff2e:	bd30      	pop	{r4, r5, pc}

0100ff30 <lll_resume>:
{
 100ff30:	b500      	push	{lr}
		      next->prio, &next->prepare_param, next->is_resume);
 100ff32:	f890 3020 	ldrb.w	r3, [r0, #32]
{
 100ff36:	b083      	sub	sp, #12
	ret = prepare(next->is_abort_cb, next->abort_cb, next->prepare_cb,
 100ff38:	f003 0301 	and.w	r3, r3, #1
 100ff3c:	9000      	str	r0, [sp, #0]
 100ff3e:	9301      	str	r3, [sp, #4]
 100ff40:	69c3      	ldr	r3, [r0, #28]
 100ff42:	6902      	ldr	r2, [r0, #16]
 100ff44:	e9d0 0105 	ldrd	r0, r1, [r0, #20]
 100ff48:	f7ff ff1e 	bl	100fd88 <prepare>
	LL_ASSERT(!ret || ret == -EINPROGRESS);
 100ff4c:	b108      	cbz	r0, 100ff52 <lll_resume+0x22>
 100ff4e:	3044      	adds	r0, #68	; 0x44
 100ff50:	d102      	bne.n	100ff58 <lll_resume+0x28>
}
 100ff52:	b003      	add	sp, #12
 100ff54:	f85d fb04 	ldr.w	pc, [sp], #4
	LL_ASSERT(!ret || ret == -EINPROGRESS);
 100ff58:	21e1      	movs	r1, #225	; 0xe1
 100ff5a:	4803      	ldr	r0, [pc, #12]	; (100ff68 <lll_resume+0x38>)
}
 100ff5c:	b003      	add	sp, #12
 100ff5e:	f85d eb04 	ldr.w	lr, [sp], #4
	LL_ASSERT(!ret || ret == -EINPROGRESS);
 100ff62:	f7f3 bb8d 	b.w	1003680 <bt_ctlr_assert_handle>
 100ff66:	bf00      	nop
 100ff68:	01018a9c 	.word	0x01018a9c

0100ff6c <lll_disable>:
{
 100ff6c:	b510      	push	{r4, lr}
	if (!param || (param == event.curr.param)) {
 100ff6e:	4604      	mov	r4, r0
{
 100ff70:	b082      	sub	sp, #8
	if (!param || (param == event.curr.param)) {
 100ff72:	2800      	cmp	r0, #0
 100ff74:	d033      	beq.n	100ffde <lll_disable+0x72>
 100ff76:	4b21      	ldr	r3, [pc, #132]	; (100fffc <lll_disable+0x90>)
 100ff78:	681a      	ldr	r2, [r3, #0]
 100ff7a:	4282      	cmp	r2, r0
 100ff7c:	d029      	beq.n	100ffd2 <lll_disable+0x66>
		u8_t idx = UINT8_MAX;
 100ff7e:	23ff      	movs	r3, #255	; 0xff
		next = ull_prepare_dequeue_iter(&idx);
 100ff80:	f10d 0007 	add.w	r0, sp, #7
		u8_t idx = UINT8_MAX;
 100ff84:	f88d 3007 	strb.w	r3, [sp, #7]
		next = ull_prepare_dequeue_iter(&idx);
 100ff88:	f7fa fa78 	bl	100a47c <ull_prepare_dequeue_iter>
		while (next) {
 100ff8c:	b940      	cbnz	r0, 100ffa0 <lll_disable+0x34>
 100ff8e:	e01c      	b.n	100ffca <lll_disable+0x5e>
			    (!param || (param == next->prepare_param.param))) {
 100ff90:	68c3      	ldr	r3, [r0, #12]
 100ff92:	42a3      	cmp	r3, r4
 100ff94:	d01b      	beq.n	100ffce <lll_disable+0x62>
			next = ull_prepare_dequeue_iter(&idx);
 100ff96:	f10d 0007 	add.w	r0, sp, #7
 100ff9a:	f7fa fa6f 	bl	100a47c <ull_prepare_dequeue_iter>
		while (next) {
 100ff9e:	b1a0      	cbz	r0, 100ffca <lll_disable+0x5e>
			if (!next->is_aborted &&
 100ffa0:	f890 3020 	ldrb.w	r3, [r0, #32]
 100ffa4:	079b      	lsls	r3, r3, #30
 100ffa6:	d4f6      	bmi.n	100ff96 <lll_disable+0x2a>
 100ffa8:	2c00      	cmp	r4, #0
 100ffaa:	d1f1      	bne.n	100ff90 <lll_disable+0x24>
 100ffac:	68c1      	ldr	r1, [r0, #12]
				next->is_aborted = 1;
 100ffae:	f890 3020 	ldrb.w	r3, [r0, #32]
 100ffb2:	f043 0302 	orr.w	r3, r3, #2
 100ffb6:	f880 3020 	strb.w	r3, [r0, #32]
				next->abort_cb(&next->prepare_param,
 100ffba:	6983      	ldr	r3, [r0, #24]
 100ffbc:	4798      	blx	r3
			next = ull_prepare_dequeue_iter(&idx);
 100ffbe:	f10d 0007 	add.w	r0, sp, #7
 100ffc2:	f7fa fa5b 	bl	100a47c <ull_prepare_dequeue_iter>
		while (next) {
 100ffc6:	2800      	cmp	r0, #0
 100ffc8:	d1ea      	bne.n	100ffa0 <lll_disable+0x34>
}
 100ffca:	b002      	add	sp, #8
 100ffcc:	bd10      	pop	{r4, pc}
 100ffce:	4621      	mov	r1, r4
 100ffd0:	e7ed      	b.n	100ffae <lll_disable+0x42>
		if (event.curr.abort_cb && event.curr.param) {
 100ffd2:	689b      	ldr	r3, [r3, #8]
 100ffd4:	b16b      	cbz	r3, 100fff2 <lll_disable+0x86>
 100ffd6:	4621      	mov	r1, r4
			event.curr.abort_cb(NULL, event.curr.param);
 100ffd8:	2000      	movs	r0, #0
 100ffda:	4798      	blx	r3
 100ffdc:	e7cf      	b.n	100ff7e <lll_disable+0x12>
		if (event.curr.abort_cb && event.curr.param) {
 100ffde:	4a07      	ldr	r2, [pc, #28]	; (100fffc <lll_disable+0x90>)
 100ffe0:	6893      	ldr	r3, [r2, #8]
 100ffe2:	2b00      	cmp	r3, #0
 100ffe4:	d0cb      	beq.n	100ff7e <lll_disable+0x12>
 100ffe6:	6811      	ldr	r1, [r2, #0]
 100ffe8:	2900      	cmp	r1, #0
 100ffea:	d0c8      	beq.n	100ff7e <lll_disable+0x12>
			event.curr.abort_cb(NULL, event.curr.param);
 100ffec:	2000      	movs	r0, #0
 100ffee:	4798      	blx	r3
 100fff0:	e7c5      	b.n	100ff7e <lll_disable+0x12>
			LL_ASSERT(!param);
 100fff2:	21eb      	movs	r1, #235	; 0xeb
 100fff4:	4802      	ldr	r0, [pc, #8]	; (1010000 <lll_disable+0x94>)
 100fff6:	f7f3 fb43 	bl	1003680 <bt_ctlr_assert_handle>
 100fffa:	e7c0      	b.n	100ff7e <lll_disable+0x12>
 100fffc:	21005688 	.word	0x21005688
 1010000:	01018a9c 	.word	0x01018a9c

01010004 <lll_prepare_done>:
}
 1010004:	2000      	movs	r0, #0
 1010006:	4770      	bx	lr

01010008 <lll_done>:
{
 1010008:	b510      	push	{r4, lr}
 101000a:	4604      	mov	r4, r0
	struct lll_event *next = ull_prepare_dequeue_get();
 101000c:	f7fa fa28 	bl	100a460 <ull_prepare_dequeue_get>
	LL_ASSERT(!param || next);
 1010010:	b13c      	cbz	r4, 1010022 <lll_done+0x1a>
 1010012:	b1e0      	cbz	r0, 101004e <lll_done+0x46>
		ull = HDR_ULL(((struct lll_hdr *)param)->parent);
 1010014:	6820      	ldr	r0, [r4, #0]
 1010016:	3010      	adds	r0, #16
	evdone = ull_event_done(ull);
 1010018:	f7fa fa5e 	bl	100a4d8 <ull_event_done>
	LL_ASSERT(evdone);
 101001c:	b180      	cbz	r0, 1010040 <lll_done+0x38>
}
 101001e:	2000      	movs	r0, #0
 1010020:	bd10      	pop	{r4, pc}
		LL_ASSERT(event.curr.abort_cb);
 1010022:	4c11      	ldr	r4, [pc, #68]	; (1010068 <lll_done+0x60>)
 1010024:	68a3      	ldr	r3, [r4, #8]
 1010026:	b1c3      	cbz	r3, 101005a <lll_done+0x52>
		event.curr.abort_cb = NULL;
 1010028:	2300      	movs	r3, #0
		param = event.curr.param;
 101002a:	6820      	ldr	r0, [r4, #0]
		event.curr.abort_cb = NULL;
 101002c:	60a3      	str	r3, [r4, #8]
		event.curr.param = NULL;
 101002e:	6023      	str	r3, [r4, #0]
		if (param) {
 1010030:	2800      	cmp	r0, #0
 1010032:	d0f1      	beq.n	1010018 <lll_done+0x10>
			ull = HDR_ULL(((struct lll_hdr *)param)->parent);
 1010034:	6800      	ldr	r0, [r0, #0]
 1010036:	3010      	adds	r0, #16
	evdone = ull_event_done(ull);
 1010038:	f7fa fa4e 	bl	100a4d8 <ull_event_done>
	LL_ASSERT(evdone);
 101003c:	2800      	cmp	r0, #0
 101003e:	d1ee      	bne.n	101001e <lll_done+0x16>
 1010040:	f240 1137 	movw	r1, #311	; 0x137
 1010044:	4809      	ldr	r0, [pc, #36]	; (101006c <lll_done+0x64>)
 1010046:	f7f3 fb1b 	bl	1003680 <bt_ctlr_assert_handle>
}
 101004a:	2000      	movs	r0, #0
 101004c:	bd10      	pop	{r4, pc}
	LL_ASSERT(!param || next);
 101004e:	f44f 718d 	mov.w	r1, #282	; 0x11a
 1010052:	4806      	ldr	r0, [pc, #24]	; (101006c <lll_done+0x64>)
 1010054:	f7f3 fb14 	bl	1003680 <bt_ctlr_assert_handle>
 1010058:	e7dc      	b.n	1010014 <lll_done+0xc>
		LL_ASSERT(event.curr.abort_cb);
 101005a:	f240 111f 	movw	r1, #287	; 0x11f
 101005e:	4803      	ldr	r0, [pc, #12]	; (101006c <lll_done+0x64>)
 1010060:	f7f3 fb0e 	bl	1003680 <bt_ctlr_assert_handle>
 1010064:	e7e0      	b.n	1010028 <lll_done+0x20>
 1010066:	bf00      	nop
 1010068:	21005688 	.word	0x21005688
 101006c:	01018a9c 	.word	0x01018a9c

01010070 <lll_is_done>:
	return !event.curr.abort_cb;
 1010070:	4b02      	ldr	r3, [pc, #8]	; (101007c <lll_is_done+0xc>)
 1010072:	6898      	ldr	r0, [r3, #8]
}
 1010074:	fab0 f080 	clz	r0, r0
 1010078:	0940      	lsrs	r0, r0, #5
 101007a:	4770      	bx	lr
 101007c:	21005688 	.word	0x21005688

01010080 <lll_evt_offset_get>:
	} else if (evt->ticks_xtal_to_start & XON_BITMASK) {
 1010080:	6803      	ldr	r3, [r0, #0]
 1010082:	2b00      	cmp	r3, #0
		return MAX(evt->ticks_active_to_start,
 1010084:	bfac      	ite	ge
 1010086:	6840      	ldrge	r0, [r0, #4]
		return MAX(evt->ticks_active_to_start,
 1010088:	e9d0 0301 	ldrdlt	r0, r3, [r0, #4]
		return MAX(evt->ticks_active_to_start,
 101008c:	4298      	cmp	r0, r3
 101008e:	bf38      	it	cc
 1010090:	4618      	movcc	r0, r3
}
 1010092:	4770      	bx	lr

01010094 <lll_preempt_calc>:
{
 1010094:	b510      	push	{r4, lr}
 1010096:	4614      	mov	r4, r2
	u32_t ticks_now = ticker_ticks_now_get();
 1010098:	f7f7 f982 	bl	10073a0 <ticker_ticks_now_get>
	diff = ticker_ticks_diff_get(ticks_now, ticks_at_event);
 101009c:	4621      	mov	r1, r4
 101009e:	f7f7 f981 	bl	10073a4 <ticker_ticks_diff_get>
	diff += HAL_TICKER_CNTR_CMP_OFFSET_MIN;
 10100a2:	3003      	adds	r0, #3
	if (!(diff & BIT(HAL_TICKER_CNTR_MSBIT)) &&
 10100a4:	0203      	lsls	r3, r0, #8
 10100a6:	d404      	bmi.n	10100b2 <lll_preempt_calc+0x1e>
 10100a8:	2809      	cmp	r0, #9
 10100aa:	bf94      	ite	ls
 10100ac:	2000      	movls	r0, #0
 10100ae:	2001      	movhi	r0, #1
}
 10100b0:	bd10      	pop	{r4, pc}
	return 0;
 10100b2:	2000      	movs	r0, #0
}
 10100b4:	bd10      	pop	{r4, pc}
 10100b6:	bf00      	nop

010100b8 <lll_chan_set>:
	switch (chan) {
 10100b8:	2826      	cmp	r0, #38	; 0x26
{
 10100ba:	b510      	push	{r4, lr}
 10100bc:	4604      	mov	r4, r0
	switch (chan) {
 10100be:	d01c      	beq.n	10100fa <lll_chan_set+0x42>
 10100c0:	2827      	cmp	r0, #39	; 0x27
 10100c2:	d012      	beq.n	10100ea <lll_chan_set+0x32>
 10100c4:	2825      	cmp	r0, #37	; 0x25
 10100c6:	d008      	beq.n	10100da <lll_chan_set+0x22>
		if (chan < 11) {
 10100c8:	280a      	cmp	r0, #10
 10100ca:	d91e      	bls.n	101010a <lll_chan_set+0x52>
		} else if (chan < 40) {
 10100cc:	2827      	cmp	r0, #39	; 0x27
 10100ce:	d821      	bhi.n	1010114 <lll_chan_set+0x5c>
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
 10100d0:	3003      	adds	r0, #3
 10100d2:	0040      	lsls	r0, r0, #1
 10100d4:	f001 feae 	bl	1011e34 <radio_freq_chan_set>
 10100d8:	e002      	b.n	10100e0 <lll_chan_set+0x28>
		radio_freq_chan_set(2);
 10100da:	2002      	movs	r0, #2
 10100dc:	f001 feaa 	bl	1011e34 <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
 10100e0:	4620      	mov	r0, r4
}
 10100e2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_whiten_iv_set(chan);
 10100e6:	f001 beab 	b.w	1011e40 <radio_whiten_iv_set>
		radio_freq_chan_set(80);
 10100ea:	2050      	movs	r0, #80	; 0x50
 10100ec:	f001 fea2 	bl	1011e34 <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
 10100f0:	4620      	mov	r0, r4
}
 10100f2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_whiten_iv_set(chan);
 10100f6:	f001 bea3 	b.w	1011e40 <radio_whiten_iv_set>
		radio_freq_chan_set(26);
 10100fa:	201a      	movs	r0, #26
 10100fc:	f001 fe9a 	bl	1011e34 <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
 1010100:	4620      	mov	r0, r4
}
 1010102:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_whiten_iv_set(chan);
 1010106:	f001 be9b 	b.w	1011e40 <radio_whiten_iv_set>
			radio_freq_chan_set(4 + (chan * 2U));
 101010a:	3002      	adds	r0, #2
 101010c:	0040      	lsls	r0, r0, #1
 101010e:	f001 fe91 	bl	1011e34 <radio_freq_chan_set>
 1010112:	e7e5      	b.n	10100e0 <lll_chan_set+0x28>
			LL_ASSERT(0);
 1010114:	f240 117b 	movw	r1, #379	; 0x17b
 1010118:	4801      	ldr	r0, [pc, #4]	; (1010120 <lll_chan_set+0x68>)
 101011a:	f7f3 fab1 	bl	1003680 <bt_ctlr_assert_handle>
 101011e:	e7df      	b.n	10100e0 <lll_chan_set+0x28>
 1010120:	01018a9c 	.word	0x01018a9c

01010124 <clock_ready>:
	return err;
}

static void clock_ready(struct device *dev, clock_control_subsys_t subsys,
			void *user_data)
{
 1010124:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
 1010126:	f004 bb3f 	b.w	10147a8 <z_impl_k_sem_give>
 101012a:	bf00      	nop

0101012c <lll_clock_init>:
{
 101012c:	b510      	push	{r4, lr}
 101012e:	4807      	ldr	r0, [pc, #28]	; (101014c <lll_clock_init+0x20>)
 1010130:	f003 fdec 	bl	1013d0c <z_impl_device_get_binding>
	dev = device_get_binding(DT_LABEL(DT_INST(0, nordic_nrf_clock)));
 1010134:	4a06      	ldr	r2, [pc, #24]	; (1010150 <lll_clock_init+0x24>)
 1010136:	6010      	str	r0, [r2, #0]
	if (!dev) {
 1010138:	b128      	cbz	r0, 1010146 <lll_clock_init+0x1a>
}
 101013a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 101013e:	6883      	ldr	r3, [r0, #8]
 1010140:	2101      	movs	r1, #1
 1010142:	681b      	ldr	r3, [r3, #0]
 1010144:	4718      	bx	r3
 1010146:	f06f 0012 	mvn.w	r0, #18
 101014a:	bd10      	pop	{r4, pc}
 101014c:	01018af4 	.word	0x01018af4
 1010150:	2100569c 	.word	0x2100569c

01010154 <lll_clock_wait>:
	if (done) {
 1010154:	4b12      	ldr	r3, [pc, #72]	; (10101a0 <lll_clock_wait+0x4c>)
 1010156:	7819      	ldrb	r1, [r3, #0]
 1010158:	b109      	cbz	r1, 101015e <lll_clock_wait+0xa>
		return 0;
 101015a:	2000      	movs	r0, #0
}
 101015c:	4770      	bx	lr
{
 101015e:	b530      	push	{r4, r5, lr}
	done = true;
 1010160:	2401      	movs	r4, #1
{
 1010162:	b08b      	sub	sp, #44	; 0x2c
	struct clock_control_async_data async_data = {
 1010164:	4a0f      	ldr	r2, [pc, #60]	; (10101a4 <lll_clock_wait+0x50>)
 1010166:	ad04      	add	r5, sp, #16
 1010168:	e9cd 2502 	strd	r2, r5, [sp, #8]
 101016c:	9101      	str	r1, [sp, #4]
	done = true;
 101016e:	701c      	strb	r4, [r3, #0]
	return z_impl_k_sem_init(sem, initial_count, limit);
 1010170:	4622      	mov	r2, r4
 1010172:	4628      	mov	r0, r5
 1010174:	f007 fd53 	bl	1017c1e <z_impl_k_sem_init>
	err = clock_control_async_on(dev, CLOCK_CONTROL_NRF_SUBSYS_LF,
 1010178:	4b0b      	ldr	r3, [pc, #44]	; (10101a8 <lll_clock_wait+0x54>)
 101017a:	6818      	ldr	r0, [r3, #0]
					 struct clock_control_async_data *data)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	if (!api->async_on) {
 101017c:	6883      	ldr	r3, [r0, #8]
 101017e:	689b      	ldr	r3, [r3, #8]
 1010180:	b15b      	cbz	r3, 101019a <lll_clock_wait+0x46>
		return -ENOTSUP;
	}

	return api->async_on(dev, sys, data);
 1010182:	4621      	mov	r1, r4
 1010184:	aa01      	add	r2, sp, #4
 1010186:	4798      	blx	r3
	if (err) {
 1010188:	b928      	cbnz	r0, 1010196 <lll_clock_wait+0x42>
	return z_impl_k_sem_take(sem, timeout);
 101018a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 101018e:	2300      	movs	r3, #0
 1010190:	4628      	mov	r0, r5
 1010192:	f004 fb2f 	bl	10147f4 <z_impl_k_sem_take>
}
 1010196:	b00b      	add	sp, #44	; 0x2c
 1010198:	bd30      	pop	{r4, r5, pc}
		return -ENOTSUP;
 101019a:	f06f 0022 	mvn.w	r0, #34	; 0x22
 101019e:	e7fa      	b.n	1010196 <lll_clock_wait+0x42>
 10101a0:	210080c9 	.word	0x210080c9
 10101a4:	01010125 	.word	0x01010125
 10101a8:	2100569c 	.word	0x2100569c

010101ac <lll_hfclock_on>:
	err = clock_control_on(dev, CLOCK_CONTROL_NRF_SUBSYS_HF);
 10101ac:	4b02      	ldr	r3, [pc, #8]	; (10101b8 <lll_hfclock_on+0xc>)
	return api->on(dev, sys);
 10101ae:	2100      	movs	r1, #0
 10101b0:	6818      	ldr	r0, [r3, #0]
 10101b2:	6883      	ldr	r3, [r0, #8]
 10101b4:	681b      	ldr	r3, [r3, #0]
 10101b6:	4718      	bx	r3
 10101b8:	2100569c 	.word	0x2100569c

010101bc <lll_hfclock_off>:
	err = clock_control_off(dev, CLOCK_CONTROL_NRF_SUBSYS_HF);
 10101bc:	4b02      	ldr	r3, [pc, #8]	; (10101c8 <lll_hfclock_off+0xc>)
	return api->off(dev, sys);
 10101be:	2100      	movs	r1, #0
 10101c0:	6818      	ldr	r0, [r3, #0]
 10101c2:	6883      	ldr	r3, [r0, #8]
 10101c4:	685b      	ldr	r3, [r3, #4]
 10101c6:	4718      	bx	r3
 10101c8:	2100569c 	.word	0x2100569c

010101cc <isr_race>:
}

static void isr_race(void *param)
{
	/* NOTE: lll_disable could have a race with ... */
	radio_status_reset();
 10101cc:	f001 bee4 	b.w	1011f98 <radio_status_reset>

010101d0 <isr_cleanup>:
{
 10101d0:	4601      	mov	r1, r0
 10101d2:	b508      	push	{r3, lr}
	radio_isr_set(isr_race, param);
 10101d4:	480f      	ldr	r0, [pc, #60]	; (1010214 <isr_cleanup+0x44>)
 10101d6:	f001 fdcb 	bl	1011d70 <radio_isr_set>
	if (!radio_is_idle()) {
 10101da:	f001 fefd 	bl	1011fd8 <radio_is_idle>
 10101de:	b1a8      	cbz	r0, 101020c <isr_cleanup+0x3c>
	radio_tmr_stop();
 10101e0:	f002 f87c 	bl	10122dc <radio_tmr_stop>
	err = lll_hfclock_off();
 10101e4:	f7ff ffea 	bl	10101bc <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
 10101e8:	b108      	cbz	r0, 10101ee <isr_cleanup+0x1e>
 10101ea:	3010      	adds	r0, #16
 10101ec:	d104      	bne.n	10101f8 <isr_cleanup+0x28>
}
 10101ee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
 10101f2:	2000      	movs	r0, #0
 10101f4:	f7ff bf08 	b.w	1010008 <lll_done>
	LL_ASSERT(!err || err == -EBUSY);
 10101f8:	4807      	ldr	r0, [pc, #28]	; (1010218 <isr_cleanup+0x48>)
 10101fa:	f240 2149 	movw	r1, #585	; 0x249
 10101fe:	f7f3 fa3f 	bl	1003680 <bt_ctlr_assert_handle>
}
 1010202:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
 1010206:	2000      	movs	r0, #0
 1010208:	f7ff befe 	b.w	1010008 <lll_done>
		radio_disable();
 101020c:	f001 feae 	bl	1011f6c <radio_disable>
 1010210:	e7e6      	b.n	10101e0 <isr_cleanup+0x10>
 1010212:	bf00      	nop
 1010214:	010101cd 	.word	0x010101cd
 1010218:	01018b10 	.word	0x01018b10

0101021c <isr_abort>:
{
 101021c:	b510      	push	{r4, lr}
 101021e:	4604      	mov	r4, r0
	radio_status_reset();
 1010220:	f001 feba 	bl	1011f98 <radio_status_reset>
	radio_tmr_status_reset();
 1010224:	f001 ff90 	bl	1012148 <radio_tmr_status_reset>
	radio_filter_status_reset();
 1010228:	f001 ff76 	bl	1012118 <radio_filter_status_reset>
	radio_ar_status_reset();
 101022c:	f002 f9ca 	bl	10125c4 <radio_ar_status_reset>
	radio_rssi_status_reset();
 1010230:	f001 ff3a 	bl	10120a8 <radio_rssi_status_reset>
	radio_filter_disable();
 1010234:	f001 ff66 	bl	1012104 <radio_filter_disable>
	isr_cleanup(param);
 1010238:	4620      	mov	r0, r4
}
 101023a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
 101023e:	f7ff bfc7 	b.w	10101d0 <isr_cleanup>
 1010242:	bf00      	nop

01010244 <isr_tx>:
{
 1010244:	b530      	push	{r4, r5, lr}
 1010246:	b083      	sub	sp, #12
 1010248:	4604      	mov	r4, r0
	radio_status_reset();
 101024a:	f001 fea5 	bl	1011f98 <radio_status_reset>
	radio_tmr_status_reset();
 101024e:	f001 ff7b 	bl	1012148 <radio_tmr_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
 1010252:	2096      	movs	r0, #150	; 0x96
 1010254:	f001 ff88 	bl	1012168 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
 1010258:	2300      	movs	r3, #0
 101025a:	461a      	mov	r2, r3
 101025c:	4619      	mov	r1, r3
 101025e:	4618      	mov	r0, r3
 1010260:	f001 fef0 	bl	1012044 <radio_switch_complete_and_tx>
	radio_pkt_rx_set(radio_pkt_scratch_get());
 1010264:	f001 fedc 	bl	1012020 <radio_pkt_scratch_get>
 1010268:	f001 fe4c 	bl	1011f04 <radio_pkt_rx_set>
	LL_ASSERT(!radio_is_ready());
 101026c:	f001 fea0 	bl	1011fb0 <radio_is_ready>
 1010270:	b9e8      	cbnz	r0, 10102ae <isr_tx+0x6a>
	radio_isr_set(isr_rx, param);
 1010272:	4621      	mov	r1, r4
 1010274:	4819      	ldr	r0, [pc, #100]	; (10102dc <isr_tx+0x98>)
 1010276:	f001 fd7b 	bl	1011d70 <radio_isr_set>
	if (ull_filter_lll_rl_enabled()) {
 101027a:	f7ff fc91 	bl	100fba0 <ull_filter_lll_rl_enabled>
 101027e:	bb18      	cbnz	r0, 10102c8 <isr_tx+0x84>
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
 1010280:	f002 f8b2 	bl	10123e8 <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(0, 0);
 1010284:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
 1010286:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(0, 0);
 1010288:	4608      	mov	r0, r1
 101028a:	f001 fe55 	bl	1011f38 <radio_rx_chain_delay_get>
	hcto -= radio_tx_chain_delay_get(0, 0);
 101028e:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(0, 0);
 1010290:	4605      	mov	r5, r0
	hcto -= radio_tx_chain_delay_get(0, 0);
 1010292:	4608      	mov	r0, r1
 1010294:	f001 fe4c 	bl	1011f30 <radio_tx_chain_delay_get>
 1010298:	442c      	add	r4, r5
 101029a:	34c3      	adds	r4, #195	; 0xc3
	radio_tmr_hcto_configure(hcto);
 101029c:	1a20      	subs	r0, r4, r0
 101029e:	f002 f831 	bl	1012304 <radio_tmr_hcto_configure>
	radio_tmr_end_capture();
 10102a2:	f002 f885 	bl	10123b0 <radio_tmr_end_capture>
		radio_rssi_measure();
 10102a6:	f001 feef 	bl	1012088 <radio_rssi_measure>
}
 10102aa:	b003      	add	sp, #12
 10102ac:	bd30      	pop	{r4, r5, pc}
	LL_ASSERT(!radio_is_ready());
 10102ae:	f240 1157 	movw	r1, #343	; 0x157
 10102b2:	480b      	ldr	r0, [pc, #44]	; (10102e0 <isr_tx+0x9c>)
 10102b4:	f7f3 f9e4 	bl	1003680 <bt_ctlr_assert_handle>
	radio_isr_set(isr_rx, param);
 10102b8:	4621      	mov	r1, r4
 10102ba:	4808      	ldr	r0, [pc, #32]	; (10102dc <isr_tx+0x98>)
 10102bc:	f001 fd58 	bl	1011d70 <radio_isr_set>
	if (ull_filter_lll_rl_enabled()) {
 10102c0:	f7ff fc6e 	bl	100fba0 <ull_filter_lll_rl_enabled>
 10102c4:	2800      	cmp	r0, #0
 10102c6:	d0db      	beq.n	1010280 <isr_tx+0x3c>
		u8_t count, *irks = ull_filter_lll_irks_get(&count);
 10102c8:	f10d 0007 	add.w	r0, sp, #7
 10102cc:	f7ff fb36 	bl	100f93c <ull_filter_lll_irks_get>
 10102d0:	4601      	mov	r1, r0
		radio_ar_configure(count, irks);
 10102d2:	f89d 0007 	ldrb.w	r0, [sp, #7]
 10102d6:	f002 f937 	bl	1012548 <radio_ar_configure>
 10102da:	e7d1      	b.n	1010280 <isr_tx+0x3c>
 10102dc:	01010621 	.word	0x01010621
 10102e0:	01018b10 	.word	0x01018b10

010102e4 <chan_prepare>:
}

static void chan_prepare(struct lll_adv *lll)
{
 10102e4:	b538      	push	{r3, r4, r5, lr}
static inline struct pdu_adv *lll_adv_pdu_latest_get(struct lll_adv_pdu *pdu,
						     u8_t *is_modified)
{
	u8_t first;

	first = pdu->first;
 10102e6:	7bc3      	ldrb	r3, [r0, #15]
	if (first != pdu->last) {
 10102e8:	7c05      	ldrb	r5, [r0, #16]
 10102ea:	4604      	mov	r4, r0
 10102ec:	429d      	cmp	r5, r3
 10102ee:	d052      	beq.n	1010396 <chan_prepare+0xb2>
		first += 1U;
 10102f0:	3301      	adds	r3, #1
 10102f2:	b2db      	uxtb	r3, r3
		if (first == DOUBLE_BUFFER_SIZE) {
 10102f4:	2b02      	cmp	r3, #2
 10102f6:	d04b      	beq.n	1010390 <chan_prepare+0xac>
 10102f8:	eb03 0583 	add.w	r5, r3, r3, lsl #2
 10102fc:	ebc3 05c5 	rsb	r5, r3, r5, lsl #3
 1010300:	1ca9      	adds	r1, r5, #2
			first = 0U;
		}
		pdu->first = first;
 1010302:	4625      	mov	r5, r4
 1010304:	f805 3f0f 	strb.w	r3, [r5, #15]!
	first = pdu->first;
 1010308:	f894 305f 	ldrb.w	r3, [r4, #95]	; 0x5f
	if (first != pdu->last) {
 101030c:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
		*is_modified = 1U;
	}

	return (void *)pdu->pdu[first];
 1010310:	440d      	add	r5, r1
	if (first != pdu->last) {
 1010312:	429a      	cmp	r2, r3
 1010314:	d062      	beq.n	10103dc <chan_prepare+0xf8>
		first += 1U;
 1010316:	3301      	adds	r3, #1
 1010318:	b2db      	uxtb	r3, r3
		if (first == DOUBLE_BUFFER_SIZE) {
 101031a:	2b02      	cmp	r3, #2
 101031c:	d04c      	beq.n	10103b8 <chan_prepare+0xd4>
 101031e:	eb03 0083 	add.w	r0, r3, r3, lsl #2
 1010322:	ebc3 00c0 	rsb	r0, r3, r0, lsl #3
 1010326:	1c82      	adds	r2, r0, #2
		pdu->first = first;
 1010328:	4620      	mov	r0, r4
 101032a:	f800 3f5f 	strb.w	r3, [r0, #95]!
	return (void *)pdu->pdu[first];
 101032e:	4410      	add	r0, r2
#if defined(CONFIG_BT_CTLR_PRIVACY)
	if (upd) {
		/* Copy the address from the adv packet we will send into the
		 * scan response.
		 */
		memcpy(&scan_pdu->scan_rsp.addr[0],
 1010330:	2206      	movs	r2, #6
 1010332:	3002      	adds	r0, #2
 1010334:	1ca9      	adds	r1, r5, #2
 1010336:	f006 fb6f 	bl	1016a18 <memcpy>
#else
	ARG_UNUSED(scan_pdu);
	ARG_UNUSED(upd);
#endif /* !CONFIG_BT_CTLR_PRIVACY */

	radio_pkt_tx_set(pdu);
 101033a:	4628      	mov	r0, r5
 101033c:	f001 fde8 	bl	1011f10 <radio_pkt_tx_set>

	if ((pdu->type != PDU_ADV_TYPE_NONCONN_IND) &&
 1010340:	782b      	ldrb	r3, [r5, #0]
	    (!IS_ENABLED(CONFIG_BT_CTLR_ADV_EXT) ||
	     (pdu->type != PDU_ADV_TYPE_EXT_IND))) {
		radio_isr_set(isr_tx, lll);
 1010342:	4621      	mov	r1, r4
	if ((pdu->type != PDU_ADV_TYPE_NONCONN_IND) &&
 1010344:	f003 030f 	and.w	r3, r3, #15
 1010348:	2b02      	cmp	r3, #2
 101034a:	d038      	beq.n	10103be <chan_prepare+0xda>
		radio_isr_set(isr_tx, lll);
 101034c:	4827      	ldr	r0, [pc, #156]	; (10103ec <chan_prepare+0x108>)
 101034e:	f001 fd0f 	bl	1011d70 <radio_isr_set>
		radio_tmr_tifs_set(EVENT_IFS_US);
 1010352:	2096      	movs	r0, #150	; 0x96
 1010354:	f001 ff08 	bl	1012168 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
 1010358:	2000      	movs	r0, #0
 101035a:	f001 fe65 	bl	1012028 <radio_switch_complete_and_rx>
	} else {
		radio_isr_set(isr_done, lll);
		radio_switch_complete_and_disable();
	}

	chan = find_lsb_set(lll->chan_map_curr);
 101035e:	7b23      	ldrb	r3, [r4, #12]
 1010360:	f3c3 1302 	ubfx	r3, r3, #4, #3
 1010364:	fa93 f0a3 	rbit	r0, r3
 1010368:	2b00      	cmp	r3, #0
 101036a:	fab0 f080 	clz	r0, r0
 101036e:	bf08      	it	eq
 1010370:	f04f 30ff 	moveq.w	r0, #4294967295
	LL_ASSERT(chan);
 1010374:	1c45      	adds	r5, r0, #1
 1010376:	d028      	beq.n	10103ca <chan_prepare+0xe6>

	lll->chan_map_curr &= (lll->chan_map_curr - 1);
 1010378:	7b22      	ldrb	r2, [r4, #12]
 101037a:	1e59      	subs	r1, r3, #1
 101037c:	400b      	ands	r3, r1
 101037e:	f363 1206 	bfi	r2, r3, #4, #3

	lll_chan_set(36 + chan);
 1010382:	f105 0024 	add.w	r0, r5, #36	; 0x24
	lll->chan_map_curr &= (lll->chan_map_curr - 1);
 1010386:	7322      	strb	r2, [r4, #12]
}
 1010388:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	lll_chan_set(36 + chan);
 101038c:	f7ff be94 	b.w	10100b8 <lll_chan_set>
 1010390:	4619      	mov	r1, r3
			first = 0U;
 1010392:	2300      	movs	r3, #0
 1010394:	e7b5      	b.n	1010302 <chan_prepare+0x1e>
	return (void *)pdu->pdu[first];
 1010396:	eb05 0385 	add.w	r3, r5, r5, lsl #2
 101039a:	ebc5 05c3 	rsb	r5, r5, r3, lsl #3
	if (first != pdu->last) {
 101039e:	f890 2060 	ldrb.w	r2, [r0, #96]	; 0x60
	first = pdu->first;
 10103a2:	f890 305f 	ldrb.w	r3, [r0, #95]	; 0x5f
	return (void *)pdu->pdu[first];
 10103a6:	4405      	add	r5, r0
	if (first != pdu->last) {
 10103a8:	429a      	cmp	r2, r3
	return (void *)pdu->pdu[first];
 10103aa:	f105 0511 	add.w	r5, r5, #17
	if (first != pdu->last) {
 10103ae:	d0c4      	beq.n	101033a <chan_prepare+0x56>
		first += 1U;
 10103b0:	3301      	adds	r3, #1
 10103b2:	b2db      	uxtb	r3, r3
		if (first == DOUBLE_BUFFER_SIZE) {
 10103b4:	2b02      	cmp	r3, #2
 10103b6:	d1b2      	bne.n	101031e <chan_prepare+0x3a>
 10103b8:	461a      	mov	r2, r3
			first = 0U;
 10103ba:	2300      	movs	r3, #0
 10103bc:	e7b4      	b.n	1010328 <chan_prepare+0x44>
		radio_isr_set(isr_done, lll);
 10103be:	480c      	ldr	r0, [pc, #48]	; (10103f0 <chan_prepare+0x10c>)
 10103c0:	f001 fcd6 	bl	1011d70 <radio_isr_set>
		radio_switch_complete_and_disable();
 10103c4:	f001 fe4a 	bl	101205c <radio_switch_complete_and_disable>
 10103c8:	e7c9      	b.n	101035e <chan_prepare+0x7a>
	LL_ASSERT(chan);
 10103ca:	f240 2179 	movw	r1, #633	; 0x279
 10103ce:	4809      	ldr	r0, [pc, #36]	; (10103f4 <chan_prepare+0x110>)
 10103d0:	f7f3 f956 	bl	1003680 <bt_ctlr_assert_handle>
 10103d4:	7b23      	ldrb	r3, [r4, #12]
 10103d6:	f3c3 1302 	ubfx	r3, r3, #4, #3
 10103da:	e7cd      	b.n	1010378 <chan_prepare+0x94>
	return (void *)pdu->pdu[first];
 10103dc:	eb02 0082 	add.w	r0, r2, r2, lsl #2
 10103e0:	ebc2 00c0 	rsb	r0, r2, r0, lsl #3
 10103e4:	4420      	add	r0, r4
 10103e6:	3061      	adds	r0, #97	; 0x61
	if (upd) {
 10103e8:	e7a2      	b.n	1010330 <chan_prepare+0x4c>
 10103ea:	bf00      	nop
 10103ec:	01010245 	.word	0x01010245
 10103f0:	010105c9 	.word	0x010105c9
 10103f4:	01018b10 	.word	0x01018b10

010103f8 <prepare_cb>:
{
 10103f8:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct lll_adv *lll = prepare_param->param;
 10103fa:	68c5      	ldr	r5, [r0, #12]
	u32_t aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
 10103fc:	4b3c      	ldr	r3, [pc, #240]	; (10104f0 <prepare_cb+0xf8>)

static inline int lll_is_stop(void *lll)
{
	struct lll_hdr *hdr = lll;

	return !!hdr->is_stop;
 10103fe:	792c      	ldrb	r4, [r5, #4]
{
 1010400:	b083      	sub	sp, #12
	if (lll_is_stop(lll)) {
 1010402:	f014 0401 	ands.w	r4, r4, #1
	u32_t aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
 1010406:	9301      	str	r3, [sp, #4]
	if (lll_is_stop(lll)) {
 1010408:	d154      	bne.n	10104b4 <prepare_cb+0xbc>
	radio_reset();
 101040a:	4606      	mov	r6, r0
 101040c:	f001 fcd0 	bl	1011db0 <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
 1010410:	4620      	mov	r0, r4
 1010412:	f001 fd09 	bl	1011e28 <radio_tx_power_set>
	radio_phy_set(0, 0);
 1010416:	4621      	mov	r1, r4
 1010418:	4620      	mov	r0, r4
 101041a:	f001 fced 	bl	1011df8 <radio_phy_set>
	radio_pkt_configure(8, PDU_AC_PAYLOAD_SIZE_MAX, 0);
 101041e:	4622      	mov	r2, r4
 1010420:	2125      	movs	r1, #37	; 0x25
 1010422:	2008      	movs	r0, #8
 1010424:	f001 fd38 	bl	1011e98 <radio_pkt_configure>
	radio_aa_set((u8_t *)&aa);
 1010428:	a801      	add	r0, sp, #4
 101042a:	f001 fd1b 	bl	1011e64 <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
 101042e:	f240 605b 	movw	r0, #1627	; 0x65b
 1010432:	4930      	ldr	r1, [pc, #192]	; (10104f4 <prepare_cb+0xfc>)
 1010434:	f001 fdda 	bl	1011fec <radio_crc_configure>
	lll->chan_map_curr = lll->chan_map;
 1010438:	7b2b      	ldrb	r3, [r5, #12]
	chan_prepare(lll);
 101043a:	4628      	mov	r0, r5
	lll->chan_map_curr = lll->chan_map;
 101043c:	461a      	mov	r2, r3
 101043e:	f3c3 0342 	ubfx	r3, r3, #1, #3
 1010442:	f363 1206 	bfi	r2, r3, #4, #3
 1010446:	732a      	strb	r2, [r5, #12]
	chan_prepare(lll);
 1010448:	f7ff ff4c 	bl	10102e4 <chan_prepare>
	if (ull_filter_lll_rl_enabled()) {
 101044c:	f7ff fba8 	bl	100fba0 <ull_filter_lll_rl_enabled>
 1010450:	bb18      	cbnz	r0, 101049a <prepare_cb+0xa2>
	if (IS_ENABLED(CONFIG_BT_CTLR_FILTER) && lll->filter_policy) {
 1010452:	7b6b      	ldrb	r3, [r5, #13]
 1010454:	079b      	lsls	r3, r3, #30
 1010456:	d148      	bne.n	10104ea <prepare_cb+0xf2>
	evt = HDR_LLL2EVT(lll);
 1010458:	682f      	ldr	r7, [r5, #0]
	ticks_at_event = prepare_param->ticks_at_expire;
 101045a:	6834      	ldr	r4, [r6, #0]
	ticks_at_event += lll_evt_offset_get(evt);
 101045c:	4638      	mov	r0, r7
 101045e:	f7ff fe0f 	bl	1010080 <lll_evt_offset_get>
 1010462:	4404      	add	r4, r0
	remainder_us = radio_tmr_start(1, ticks_at_start, remainder);
 1010464:	6872      	ldr	r2, [r6, #4]
 1010466:	f104 0109 	add.w	r1, r4, #9
 101046a:	2001      	movs	r0, #1
 101046c:	f001 fe88 	bl	1012180 <radio_tmr_start>
	radio_tmr_end_capture();
 1010470:	f001 ff9e 	bl	10123b0 <radio_tmr_end_capture>
				   ull_adv_lll_handle_get(lll)),
 1010474:	4628      	mov	r0, r5
 1010476:	f7fa fc1b 	bl	100acb0 <ull_adv_lll_handle_get>
	if (lll_preempt_calc(evt, (TICKER_ID_ADV_BASE +
 101047a:	1c81      	adds	r1, r0, #2
 101047c:	4622      	mov	r2, r4
 101047e:	4638      	mov	r0, r7
 1010480:	b2c9      	uxtb	r1, r1
 1010482:	f7ff fe07 	bl	1010094 <lll_preempt_calc>
 1010486:	b320      	cbz	r0, 10104d2 <prepare_cb+0xda>
		radio_isr_set(isr_abort, lll);
 1010488:	4629      	mov	r1, r5
 101048a:	481b      	ldr	r0, [pc, #108]	; (10104f8 <prepare_cb+0x100>)
 101048c:	f001 fc70 	bl	1011d70 <radio_isr_set>
		radio_disable();
 1010490:	f001 fd6c 	bl	1011f6c <radio_disable>
}
 1010494:	2000      	movs	r0, #0
 1010496:	b003      	add	sp, #12
 1010498:	bdf0      	pop	{r4, r5, r6, r7, pc}
			ull_filter_lll_get(!!(lll->filter_policy));
 101049a:	7b68      	ldrb	r0, [r5, #13]
 101049c:	f010 0003 	ands.w	r0, r0, #3
 10104a0:	bf18      	it	ne
 10104a2:	2001      	movne	r0, #1
		struct lll_filter *wl = ull_filter_lll_get(true);
 10104a4:	f7ff faea 	bl	100fa7c <ull_filter_lll_get>
		radio_filter_configure(wl->enable_bitmask,
 10104a8:	7841      	ldrb	r1, [r0, #1]
 10104aa:	1c82      	adds	r2, r0, #2
 10104ac:	7800      	ldrb	r0, [r0, #0]
 10104ae:	f001 fe0d 	bl	10120cc <radio_filter_configure>
 10104b2:	e7d1      	b.n	1010458 <prepare_cb+0x60>
		err = lll_hfclock_off();
 10104b4:	f7ff fe82 	bl	10101bc <lll_hfclock_off>
		LL_ASSERT(!err || err == -EBUSY);
 10104b8:	b128      	cbz	r0, 10104c6 <prepare_cb+0xce>
 10104ba:	3010      	adds	r0, #16
 10104bc:	d003      	beq.n	10104c6 <prepare_cb+0xce>
 10104be:	218b      	movs	r1, #139	; 0x8b
 10104c0:	480e      	ldr	r0, [pc, #56]	; (10104fc <prepare_cb+0x104>)
 10104c2:	f7f3 f8dd 	bl	1003680 <bt_ctlr_assert_handle>
		lll_done(NULL);
 10104c6:	2000      	movs	r0, #0
 10104c8:	f7ff fd9e 	bl	1010008 <lll_done>
}
 10104cc:	2000      	movs	r0, #0
 10104ce:	b003      	add	sp, #12
 10104d0:	bdf0      	pop	{r4, r5, r6, r7, pc}
		ret = lll_prepare_done(lll);
 10104d2:	4628      	mov	r0, r5
 10104d4:	f7ff fd96 	bl	1010004 <lll_prepare_done>
		LL_ASSERT(!ret);
 10104d8:	2800      	cmp	r0, #0
 10104da:	d0db      	beq.n	1010494 <prepare_cb+0x9c>
 10104dc:	21e9      	movs	r1, #233	; 0xe9
 10104de:	4807      	ldr	r0, [pc, #28]	; (10104fc <prepare_cb+0x104>)
 10104e0:	f7f3 f8ce 	bl	1003680 <bt_ctlr_assert_handle>
}
 10104e4:	2000      	movs	r0, #0
 10104e6:	b003      	add	sp, #12
 10104e8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		struct lll_filter *wl = ull_filter_lll_get(true);
 10104ea:	2001      	movs	r0, #1
 10104ec:	e7da      	b.n	10104a4 <prepare_cb+0xac>
 10104ee:	bf00      	nop
 10104f0:	8e89bed6 	.word	0x8e89bed6
 10104f4:	00555555 	.word	0x00555555
 10104f8:	0101021d 	.word	0x0101021d
 10104fc:	01018b10 	.word	0x01018b10

01010500 <resume_prepare_cb>:
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
 1010500:	68c3      	ldr	r3, [r0, #12]
{
 1010502:	b570      	push	{r4, r5, r6, lr}
 1010504:	4604      	mov	r4, r0
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
 1010506:	681e      	ldr	r6, [r3, #0]
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
 1010508:	f7f6 ff4a 	bl	10073a0 <ticker_ticks_now_get>
 101050c:	4605      	mov	r5, r0
 101050e:	4630      	mov	r0, r6
 1010510:	f7ff fdb6 	bl	1010080 <lll_evt_offset_get>
	p->remainder = 0;
 1010514:	2300      	movs	r3, #0
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
 1010516:	1a2d      	subs	r5, r5, r0
	p->remainder = 0;
 1010518:	e9c4 5300 	strd	r5, r3, [r4]
	return prepare_cb(p);
 101051c:	4620      	mov	r0, r4
	p->lazy = 0;
 101051e:	8123      	strh	r3, [r4, #8]
}
 1010520:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return prepare_cb(p);
 1010524:	f7ff bf68 	b.w	10103f8 <prepare_cb>

01010528 <is_abort_cb>:
	if (next != curr) {
 1010528:	4282      	cmp	r2, r0
{
 101052a:	b508      	push	{r3, lr}
	if (next != curr) {
 101052c:	d017      	beq.n	101055e <is_abort_cb+0x36>
		} else if (lll->is_hdcd) {
 101052e:	7b12      	ldrb	r2, [r2, #12]
 1010530:	07d2      	lsls	r2, r2, #31
 1010532:	d402      	bmi.n	101053a <is_abort_cb+0x12>
			return -ECANCELED;
 1010534:	f06f 0047 	mvn.w	r0, #71	; 0x47
}
 1010538:	bd08      	pop	{r3, pc}
			*resume_prio = 0; /* TODO: */
 101053a:	2200      	movs	r2, #0
			*resume_cb = resume_prepare_cb;
 101053c:	4911      	ldr	r1, [pc, #68]	; (1010584 <is_abort_cb+0x5c>)
 101053e:	6019      	str	r1, [r3, #0]
			*resume_prio = 0; /* TODO: */
 1010540:	9b02      	ldr	r3, [sp, #8]
 1010542:	601a      	str	r2, [r3, #0]
			err = lll_hfclock_on();
 1010544:	f7ff fe32 	bl	10101ac <lll_hfclock_on>
			LL_ASSERT(!err || err == -EINPROGRESS);
 1010548:	b1c0      	cbz	r0, 101057c <is_abort_cb+0x54>
 101054a:	3044      	adds	r0, #68	; 0x44
 101054c:	d016      	beq.n	101057c <is_abort_cb+0x54>
 101054e:	f240 1113 	movw	r1, #275	; 0x113
 1010552:	480d      	ldr	r0, [pc, #52]	; (1010588 <is_abort_cb+0x60>)
 1010554:	f7f3 f894 	bl	1003680 <bt_ctlr_assert_handle>
 1010558:	f06f 000a 	mvn.w	r0, #10
}
 101055c:	bd08      	pop	{r3, pc}
	return lll_adv_pdu_latest_get(&lll->scan_rsp, is_modified);
}

static inline struct pdu_adv *lll_adv_data_curr_get(struct lll_adv *lll)
{
	return (void *)lll->adv_data.pdu[lll->adv_data.first];
 101055e:	7bd3      	ldrb	r3, [r2, #15]
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
 1010560:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 1010564:	ebc3 03c1 	rsb	r3, r3, r1, lsl #3
 1010568:	441a      	add	r2, r3
 101056a:	7c53      	ldrb	r3, [r2, #17]
 101056c:	f003 030f 	and.w	r3, r3, #15
 1010570:	2b01      	cmp	r3, #1
		return 0;
 1010572:	bf14      	ite	ne
 1010574:	f06f 0047 	mvnne.w	r0, #71	; 0x47
 1010578:	2000      	moveq	r0, #0
}
 101057a:	bd08      	pop	{r3, pc}
 101057c:	f06f 000a 	mvn.w	r0, #10
 1010580:	bd08      	pop	{r3, pc}
 1010582:	bf00      	nop
 1010584:	01010501 	.word	0x01010501
 1010588:	01018b10 	.word	0x01018b10

0101058c <abort_cb>:
{
 101058c:	b510      	push	{r4, lr}
	if (!prepare_param) {
 101058e:	b178      	cbz	r0, 10105b0 <abort_cb+0x24>
	err = lll_hfclock_off();
 1010590:	460c      	mov	r4, r1
 1010592:	f7ff fe13 	bl	10101bc <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
 1010596:	b130      	cbz	r0, 10105a6 <abort_cb+0x1a>
 1010598:	3010      	adds	r0, #16
 101059a:	d004      	beq.n	10105a6 <abort_cb+0x1a>
 101059c:	f240 1139 	movw	r1, #313	; 0x139
 10105a0:	4807      	ldr	r0, [pc, #28]	; (10105c0 <abort_cb+0x34>)
 10105a2:	f7f3 f86d 	bl	1003680 <bt_ctlr_assert_handle>
	lll_done(param);
 10105a6:	4620      	mov	r0, r4
}
 10105a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
 10105ac:	f7ff bd2c 	b.w	1010008 <lll_done>
		radio_isr_set(isr_abort, param);
 10105b0:	4804      	ldr	r0, [pc, #16]	; (10105c4 <abort_cb+0x38>)
 10105b2:	f001 fbdd 	bl	1011d70 <radio_isr_set>
}
 10105b6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_disable();
 10105ba:	f001 bcd7 	b.w	1011f6c <radio_disable>
 10105be:	bf00      	nop
 10105c0:	01018b10 	.word	0x01018b10
 10105c4:	0101021d 	.word	0x0101021d

010105c8 <isr_done>:
{
 10105c8:	b510      	push	{r4, lr}
 10105ca:	4604      	mov	r4, r0
	radio_status_reset();
 10105cc:	f001 fce4 	bl	1011f98 <radio_status_reset>
	radio_tmr_status_reset();
 10105d0:	f001 fdba 	bl	1012148 <radio_tmr_status_reset>
	radio_filter_status_reset();
 10105d4:	f001 fda0 	bl	1012118 <radio_filter_status_reset>
	radio_ar_status_reset();
 10105d8:	f001 fff4 	bl	10125c4 <radio_ar_status_reset>
	radio_rssi_status_reset();
 10105dc:	f001 fd64 	bl	10120a8 <radio_rssi_status_reset>
	if (!IS_ENABLED(CONFIG_BT_CTLR_LOW_LAT) && lll->is_hdcd &&
 10105e0:	7b23      	ldrb	r3, [r4, #12]
 10105e2:	f003 0271 	and.w	r2, r3, #113	; 0x71
 10105e6:	2a01      	cmp	r2, #1
 10105e8:	d106      	bne.n	10105f8 <isr_done+0x30>
		lll->chan_map_curr = lll->chan_map;
 10105ea:	461a      	mov	r2, r3
 10105ec:	f3c3 0342 	ubfx	r3, r3, #1, #3
 10105f0:	f363 1206 	bfi	r2, r3, #4, #3
 10105f4:	7322      	strb	r2, [r4, #12]
 10105f6:	b2d3      	uxtb	r3, r2
	if (lll->chan_map_curr) {
 10105f8:	f013 0f70 	tst.w	r3, #112	; 0x70
 10105fc:	d106      	bne.n	101060c <isr_done+0x44>
	radio_filter_disable();
 10105fe:	f001 fd81 	bl	1012104 <radio_filter_disable>
	isr_cleanup(param);
 1010602:	4620      	mov	r0, r4
}
 1010604:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
 1010608:	f7ff bde2 	b.w	10101d0 <isr_cleanup>
		chan_prepare(lll);
 101060c:	4620      	mov	r0, r4
 101060e:	f7ff fe69 	bl	10102e4 <chan_prepare>
		radio_tx_enable();
 1010612:	f001 fca5 	bl	1011f60 <radio_tx_enable>
}
 1010616:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_tmr_end_capture();
 101061a:	f001 bec9 	b.w	10123b0 <radio_tmr_end_capture>
 101061e:	bf00      	nop

01010620 <isr_rx>:
{
 1010620:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1010624:	b085      	sub	sp, #20
 1010626:	4604      	mov	r4, r0
	trx_done = radio_is_done();
 1010628:	f001 fccc 	bl	1011fc4 <radio_is_done>
	if (trx_done) {
 101062c:	f010 0fff 	tst.w	r0, #255	; 0xff
 1010630:	d112      	bne.n	1010658 <isr_rx+0x38>
	radio_status_reset();
 1010632:	f001 fcb1 	bl	1011f98 <radio_status_reset>
	radio_tmr_status_reset();
 1010636:	f001 fd87 	bl	1012148 <radio_tmr_status_reset>
	radio_filter_status_reset();
 101063a:	f001 fd6d 	bl	1012118 <radio_filter_status_reset>
	radio_ar_status_reset();
 101063e:	f001 ffc1 	bl	10125c4 <radio_ar_status_reset>
	radio_rssi_status_reset();
 1010642:	f001 fd31 	bl	10120a8 <radio_rssi_status_reset>
	radio_isr_set(isr_done, param);
 1010646:	4621      	mov	r1, r4
 1010648:	48c9      	ldr	r0, [pc, #804]	; (1010970 <isr_rx+0x350>)
 101064a:	f001 fb91 	bl	1011d70 <radio_isr_set>
	radio_disable();
 101064e:	f001 fc8d 	bl	1011f6c <radio_disable>
}
 1010652:	b005      	add	sp, #20
 1010654:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		crc_ok = radio_crc_is_valid();
 1010658:	f001 fcd4 	bl	1012004 <radio_crc_is_valid>
 101065c:	4605      	mov	r5, r0
		devmatch_ok = radio_filter_has_match();
 101065e:	f001 fd63 	bl	1012128 <radio_filter_has_match>
 1010662:	4607      	mov	r7, r0
		devmatch_id = radio_filter_match_get();
 1010664:	f001 fd6a 	bl	101213c <radio_filter_match_get>
		irkmatch_ok = radio_ar_has_match();
 1010668:	f001 ffb8 	bl	10125dc <radio_ar_has_match>
 101066c:	4606      	mov	r6, r0
		irkmatch_id = radio_ar_match_get();
 101066e:	f001 ffa3 	bl	10125b8 <radio_ar_match_get>
 1010672:	4680      	mov	r8, r0
		rssi_ready = radio_rssi_is_ready();
 1010674:	f001 fd20 	bl	10120b8 <radio_rssi_is_ready>
 1010678:	4681      	mov	r9, r0
	radio_status_reset();
 101067a:	f001 fc8d 	bl	1011f98 <radio_status_reset>
	radio_tmr_status_reset();
 101067e:	f001 fd63 	bl	1012148 <radio_tmr_status_reset>
	radio_filter_status_reset();
 1010682:	f001 fd49 	bl	1012118 <radio_filter_status_reset>
	radio_ar_status_reset();
 1010686:	f001 ff9d 	bl	10125c4 <radio_ar_status_reset>
	radio_rssi_status_reset();
 101068a:	f001 fd0d 	bl	10120a8 <radio_rssi_status_reset>
	if (crc_ok) {
 101068e:	f015 0fff 	tst.w	r5, #255	; 0xff
 1010692:	d0d8      	beq.n	1010646 <isr_rx+0x26>
{
	struct pdu_adv *pdu_rx, *pdu_adv;

#if defined(CONFIG_BT_CTLR_PRIVACY)
	/* An IRK match implies address resolution enabled */
	u8_t rl_idx = irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
 1010694:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
 1010698:	f040 808f 	bne.w	10107ba <isr_rx+0x19a>
 101069c:	20ff      	movs	r0, #255	; 0xff
 101069e:	f88d 000f 	strb.w	r0, [sp, #15]
				    FILTER_IDX_NONE;
#else
	u8_t rl_idx = FILTER_IDX_NONE;
#endif /* CONFIG_BT_CTLR_PRIVACY */

	pdu_rx = (void *)radio_pkt_scratch_get();
 10106a2:	f001 fcbd 	bl	1012020 <radio_pkt_scratch_get>
 10106a6:	7be3      	ldrb	r3, [r4, #15]
 10106a8:	4680      	mov	r8, r0
 10106aa:	eb03 0583 	add.w	r5, r3, r3, lsl #2
	pdu_adv = lll_adv_data_curr_get(lll);

	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
 10106ae:	7800      	ldrb	r0, [r0, #0]
 10106b0:	ebc3 03c5 	rsb	r3, r3, r5, lsl #3
 10106b4:	f103 0511 	add.w	r5, r3, #17
 10106b8:	f000 030f 	and.w	r3, r0, #15
 10106bc:	2b03      	cmp	r3, #3
		devmatch_ok = radio_filter_has_match();
 10106be:	b2ff      	uxtb	r7, r7
 10106c0:	eb04 0a05 	add.w	sl, r4, r5
	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
 10106c4:	f000 808d 	beq.w	10107e2 <isr_rx+0x1c2>
					 CONFIG_BT_CTLR_GPIO_PA_OFFSET);
#endif /* CONFIG_BT_CTLR_GPIO_PA_PIN */
		return 0;

#if defined(CONFIG_BT_PERIPHERAL)
	} else if ((pdu_rx->type == PDU_ADV_TYPE_CONNECT_IND) &&
 10106c8:	2b05      	cmp	r3, #5
 10106ca:	d1bc      	bne.n	1010646 <isr_rx+0x26>
 10106cc:	f898 3001 	ldrb.w	r3, [r8, #1]
 10106d0:	2b22      	cmp	r3, #34	; 0x22
 10106d2:	d1b8      	bne.n	1010646 <isr_rx+0x26>
static inline bool isr_rx_ci_check(struct lll_adv *lll, struct pdu_adv *adv,
				   struct pdu_adv *ci, u8_t devmatch_ok,
				   u8_t *rl_idx)
{
	/* LL 4.3.2: filter policy shall be ignored for directed adv */
	if (adv->type == PDU_ADV_TYPE_DIRECT_IND) {
 10106d4:	5d63      	ldrb	r3, [r4, r5]
 10106d6:	f003 030f 	and.w	r3, r3, #15
 10106da:	2b01      	cmp	r3, #1
 10106dc:	f000 80c8 	beq.w	1010870 <isr_rx+0x250>
		       isr_rx_ci_adva_check(adv, ci) &&
		       isr_rx_ci_tgta_check(lll, adv, ci, *rl_idx);
	}

#if defined(CONFIG_BT_CTLR_PRIVACY)
	return ((((lll->filter_policy & 0x02) == 0) &&
 10106e0:	7b63      	ldrb	r3, [r4, #13]
		 ull_filter_lll_rl_addr_allowed(ci->tx_addr,
						ci->connect_ind.init_addr,
						rl_idx)) ||
		(((lll->filter_policy & 0x02) != 0) &&
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
 10106e2:	0799      	lsls	r1, r3, #30
 10106e4:	d56e      	bpl.n	10107c4 <isr_rx+0x1a4>
		(((lll->filter_policy & 0x02) != 0) &&
 10106e6:	2f00      	cmp	r7, #0
 10106e8:	f000 80ba 	beq.w	1010860 <isr_rx+0x240>
}

static inline bool isr_rx_ci_adva_check(struct pdu_adv *adv,
					struct pdu_adv *ci)
{
	return (adv->tx_addr == ci->rx_addr) &&
 10106ec:	5d63      	ldrb	r3, [r4, r5]
 10106ee:	f898 1000 	ldrb.w	r1, [r8]
 10106f2:	f3c3 1280 	ubfx	r2, r3, #6, #1
 10106f6:	ebb2 1fd1 	cmp.w	r2, r1, lsr #7
 10106fa:	d1a4      	bne.n	1010646 <isr_rx+0x26>
 10106fc:	f003 030f 	and.w	r3, r3, #15
 1010700:	2b01      	cmp	r3, #1
		(((adv->type == PDU_ADV_TYPE_DIRECT_IND) &&
		 !memcmp(adv->direct_ind.adv_addr, ci->connect_ind.adv_addr,
 1010702:	f10a 0a02 	add.w	sl, sl, #2
 1010706:	f108 0508 	add.w	r5, r8, #8
	return (adv->tx_addr == ci->rx_addr) &&
 101070a:	f000 80df 	beq.w	10108cc <isr_rx+0x2ac>
			 BDADDR_SIZE)) ||
		 (!memcmp(adv->adv_ind.addr, ci->connect_ind.adv_addr,
 101070e:	4629      	mov	r1, r5
 1010710:	4650      	mov	r0, sl
 1010712:	2206      	movs	r2, #6
 1010714:	f006 f970 	bl	10169f8 <memcmp>
			 BDADDR_SIZE)) ||
 1010718:	fab0 f080 	clz	r0, r0
 101071c:	0940      	lsrs	r0, r0, #5
		   (pdu_rx->len == sizeof(struct pdu_adv_connect_ind)) &&
 101071e:	2800      	cmp	r0, #0
 1010720:	d091      	beq.n	1010646 <isr_rx+0x26>
				   &rl_idx) &&
 1010722:	68a3      	ldr	r3, [r4, #8]
 1010724:	2b00      	cmp	r3, #0
 1010726:	d08e      	beq.n	1010646 <isr_rx+0x26>
			rx = ull_pdu_rx_alloc_peek(4);
 1010728:	2004      	movs	r0, #4
 101072a:	f7f9 fe13 	bl	100a354 <ull_pdu_rx_alloc_peek>
		if (!rx) {
 101072e:	2800      	cmp	r0, #0
 1010730:	d089      	beq.n	1010646 <isr_rx+0x26>
		radio_isr_set(isr_abort, lll);
 1010732:	4621      	mov	r1, r4
 1010734:	488f      	ldr	r0, [pc, #572]	; (1010974 <isr_rx+0x354>)
 1010736:	f001 fb1b 	bl	1011d70 <radio_isr_set>
		radio_disable();
 101073a:	f001 fc17 	bl	1011f6c <radio_disable>
		LL_ASSERT(!radio_is_ready());
 101073e:	f001 fc37 	bl	1011fb0 <radio_is_ready>
 1010742:	2800      	cmp	r0, #0
 1010744:	f040 8086 	bne.w	1010854 <isr_rx+0x234>
		if (rssi_ready) {
 1010748:	f019 0fff 	tst.w	r9, #255	; 0xff
 101074c:	d17c      	bne.n	1010848 <isr_rx+0x228>
	int ret = !!hdr->is_stop;
 101074e:	7923      	ldrb	r3, [r4, #4]
	hdr->is_stop = 1U;
 1010750:	f043 0201 	orr.w	r2, r3, #1
		LL_ASSERT(!ret);
 1010754:	07db      	lsls	r3, r3, #31
 1010756:	7122      	strb	r2, [r4, #4]
 1010758:	d470      	bmi.n	101083c <isr_rx+0x21c>
		rx = ull_pdu_rx_alloc();
 101075a:	f7f9 fe19 	bl	100a390 <ull_pdu_rx_alloc>
		rx->hdr.handle = 0xffff;
 101075e:	f64f 73ff 	movw	r3, #65535	; 0xffff
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
 1010762:	2208      	movs	r2, #8
		rx = ull_pdu_rx_alloc();
 1010764:	4605      	mov	r5, r0
		rx->hdr.handle = 0xffff;
 1010766:	80c3      	strh	r3, [r0, #6]
		memcpy(rx->pdu, pdu_rx, (offsetof(struct pdu_adv, connect_ind) +
 1010768:	4641      	mov	r1, r8
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
 101076a:	7102      	strb	r2, [r0, #4]
		memcpy(rx->pdu, pdu_rx, (offsetof(struct pdu_adv, connect_ind) +
 101076c:	2224      	movs	r2, #36	; 0x24
 101076e:	3020      	adds	r0, #32
 1010770:	f006 f952 	bl	1016a18 <memcpy>
		ftr->param = lll;
 1010774:	60ac      	str	r4, [r5, #8]
		ftr->ticks_anchor = radio_tmr_start_get();
 1010776:	f001 fdab 	bl	10122d0 <radio_tmr_start_get>
 101077a:	6128      	str	r0, [r5, #16]
		ftr->us_radio_end = radio_tmr_end_get() -
 101077c:	f001 fe2e 	bl	10123dc <radio_tmr_end_get>
				    radio_tx_chain_delay_get(0, 0);
 1010780:	2100      	movs	r1, #0
		ftr->us_radio_end = radio_tmr_end_get() -
 1010782:	4604      	mov	r4, r0
				    radio_tx_chain_delay_get(0, 0);
 1010784:	4608      	mov	r0, r1
 1010786:	f001 fbd3 	bl	1011f30 <radio_tx_chain_delay_get>
		ftr->us_radio_rdy = radio_rx_ready_delay_get(0, 0);
 101078a:	2100      	movs	r1, #0
		ftr->us_radio_end = radio_tmr_end_get() -
 101078c:	1a24      	subs	r4, r4, r0
 101078e:	616c      	str	r4, [r5, #20]
		ftr->us_radio_rdy = radio_rx_ready_delay_get(0, 0);
 1010790:	4608      	mov	r0, r1
 1010792:	f001 fbcf 	bl	1011f34 <radio_rx_ready_delay_get>
 1010796:	61a8      	str	r0, [r5, #24]
		ftr->rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
 1010798:	2e00      	cmp	r6, #0
 101079a:	d04d      	beq.n	1010838 <isr_rx+0x218>
 101079c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 10107a0:	77ab      	strb	r3, [r5, #30]
			ftr->extra = ull_pdu_rx_alloc();
 10107a2:	f7f9 fdf5 	bl	100a390 <ull_pdu_rx_alloc>
		ull_rx_put(rx->hdr.link, rx);
 10107a6:	4629      	mov	r1, r5
			ftr->extra = ull_pdu_rx_alloc();
 10107a8:	60e8      	str	r0, [r5, #12]
		ull_rx_put(rx->hdr.link, rx);
 10107aa:	6828      	ldr	r0, [r5, #0]
 10107ac:	f7f9 fe08 	bl	100a3c0 <ull_rx_put>
		ull_rx_sched();
 10107b0:	f7f9 fe16 	bl	100a3e0 <ull_rx_sched>
}
 10107b4:	b005      	add	sp, #20
 10107b6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	u8_t rl_idx = irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
 10107ba:	fa5f f088 	uxtb.w	r0, r8
 10107be:	f7ff f907 	bl	100f9d0 <ull_filter_lll_rl_irk_idx>
 10107c2:	e76c      	b.n	101069e <isr_rx+0x7e>
		 ull_filter_lll_rl_addr_allowed(ci->tx_addr,
 10107c4:	f3c0 1080 	ubfx	r0, r0, #6, #1
 10107c8:	f10d 020f 	add.w	r2, sp, #15
 10107cc:	f108 0102 	add.w	r1, r8, #2
 10107d0:	f7ff f988 	bl	100fae4 <ull_filter_lll_rl_addr_allowed>
	return ((((lll->filter_policy & 0x02) == 0) &&
 10107d4:	2800      	cmp	r0, #0
 10107d6:	d189      	bne.n	10106ec <isr_rx+0xcc>
		(((lll->filter_policy & 0x02) != 0) &&
 10107d8:	7b63      	ldrb	r3, [r4, #13]
						rl_idx)) ||
 10107da:	079a      	lsls	r2, r3, #30
 10107dc:	f57f af33 	bpl.w	1010646 <isr_rx+0x26>
 10107e0:	e781      	b.n	10106e6 <isr_rx+0xc6>
	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
 10107e2:	f898 3001 	ldrb.w	r3, [r8, #1]
 10107e6:	2b0c      	cmp	r3, #12
 10107e8:	f47f af2d 	bne.w	1010646 <isr_rx+0x26>
	    (pdu_adv->type != PDU_ADV_TYPE_DIRECT_IND) &&
 10107ec:	5d63      	ldrb	r3, [r4, r5]
	    (pdu_rx->len == sizeof(struct pdu_adv_scan_req)) &&
 10107ee:	f003 030f 	and.w	r3, r3, #15
 10107f2:	2b01      	cmp	r3, #1
 10107f4:	f43f af27 	beq.w	1010646 <isr_rx+0x26>
	return ((((lll->filter_policy & 0x01) == 0) &&
 10107f8:	7b63      	ldrb	r3, [r4, #13]
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
 10107fa:	07db      	lsls	r3, r3, #31
 10107fc:	d50c      	bpl.n	1010818 <isr_rx+0x1f8>
		(((lll->filter_policy & 0x01) != 0) &&
 10107fe:	2f00      	cmp	r7, #0
 1010800:	d06d      	beq.n	10108de <isr_rx+0x2be>
	return (adv->tx_addr == sr->rx_addr) &&
 1010802:	5d63      	ldrb	r3, [r4, r5]
 1010804:	f898 0000 	ldrb.w	r0, [r8]
 1010808:	f3c3 1380 	ubfx	r3, r3, #6, #1
 101080c:	ebb3 1fd0 	cmp.w	r3, r0, lsr #7
 1010810:	d06c      	beq.n	10108ec <isr_rx+0x2cc>
 1010812:	f000 030f 	and.w	r3, r0, #15
 1010816:	e757      	b.n	10106c8 <isr_rx+0xa8>
		 ull_filter_lll_rl_addr_allowed(sr->tx_addr,
 1010818:	f3c0 1080 	ubfx	r0, r0, #6, #1
 101081c:	f10d 020f 	add.w	r2, sp, #15
 1010820:	f108 0102 	add.w	r1, r8, #2
 1010824:	f7ff f95e 	bl	100fae4 <ull_filter_lll_rl_addr_allowed>
	return ((((lll->filter_policy & 0x01) == 0) &&
 1010828:	2800      	cmp	r0, #0
 101082a:	d1ea      	bne.n	1010802 <isr_rx+0x1e2>
		(((lll->filter_policy & 0x01) != 0) &&
 101082c:	7b63      	ldrb	r3, [r4, #13]
						rl_idx)) ||
 101082e:	07d8      	lsls	r0, r3, #31
 1010830:	d4e5      	bmi.n	10107fe <isr_rx+0x1de>
 1010832:	f898 0000 	ldrb.w	r0, [r8]
 1010836:	e7ec      	b.n	1010812 <isr_rx+0x1f2>
		ftr->rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
 1010838:	23ff      	movs	r3, #255	; 0xff
 101083a:	e7b1      	b.n	10107a0 <isr_rx+0x180>
		LL_ASSERT(!ret);
 101083c:	f240 21e5 	movw	r1, #741	; 0x2e5
 1010840:	484d      	ldr	r0, [pc, #308]	; (1010978 <isr_rx+0x358>)
 1010842:	f7f2 ff1d 	bl	1003680 <bt_ctlr_assert_handle>
 1010846:	e788      	b.n	101075a <isr_rx+0x13a>
			lll->conn->rssi_latest =  radio_rssi_get();
 1010848:	f001 fc28 	bl	101209c <radio_rssi_get>
 101084c:	68a3      	ldr	r3, [r4, #8]
 101084e:	f883 00a5 	strb.w	r0, [r3, #165]	; 0xa5
 1010852:	e77c      	b.n	101074e <isr_rx+0x12e>
		LL_ASSERT(!radio_is_ready());
 1010854:	f240 21d7 	movw	r1, #727	; 0x2d7
 1010858:	4847      	ldr	r0, [pc, #284]	; (1010978 <isr_rx+0x358>)
 101085a:	f7f2 ff11 	bl	1003680 <bt_ctlr_assert_handle>
 101085e:	e773      	b.n	1010748 <isr_rx+0x128>
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
 1010860:	f89d 000f 	ldrb.w	r0, [sp, #15]
 1010864:	f7ff f8e6 	bl	100fa34 <ull_filter_lll_irk_whitelisted>
 1010868:	2800      	cmp	r0, #0
 101086a:	f47f af3f 	bne.w	10106ec <isr_rx+0xcc>
 101086e:	e6ea      	b.n	1010646 <isr_rx+0x26>
						      ci->connect_ind.init_addr,
 1010870:	f108 0702 	add.w	r7, r8, #2
		return ull_filter_lll_rl_addr_allowed(ci->tx_addr,
 1010874:	4639      	mov	r1, r7
 1010876:	f3c0 1080 	ubfx	r0, r0, #6, #1
 101087a:	f10d 020f 	add.w	r2, sp, #15
 101087e:	f7ff f931 	bl	100fae4 <ull_filter_lll_rl_addr_allowed>
		       isr_rx_ci_adva_check(adv, ci) &&
 1010882:	2800      	cmp	r0, #0
 1010884:	f43f aedf 	beq.w	1010646 <isr_rx+0x26>
	return (adv->tx_addr == ci->rx_addr) &&
 1010888:	5d63      	ldrb	r3, [r4, r5]
 101088a:	f898 1000 	ldrb.w	r1, [r8]
 101088e:	f3c3 1280 	ubfx	r2, r3, #6, #1
 1010892:	ebb2 1fd1 	cmp.w	r2, r1, lsr #7
 1010896:	f47f aed6 	bne.w	1010646 <isr_rx+0x26>
 101089a:	f003 030f 	and.w	r3, r3, #15
 101089e:	2b01      	cmp	r3, #1
		 !memcmp(adv->direct_ind.adv_addr, ci->connect_ind.adv_addr,
 10108a0:	f108 0108 	add.w	r1, r8, #8
 10108a4:	f10a 0b02 	add.w	fp, sl, #2
	return (adv->tx_addr == ci->rx_addr) &&
 10108a8:	d04f      	beq.n	101094a <isr_rx+0x32a>
		 (!memcmp(adv->adv_ind.addr, ci->connect_ind.adv_addr,
 10108aa:	4658      	mov	r0, fp
 10108ac:	2206      	movs	r2, #6
 10108ae:	f006 f8a3 	bl	10169f8 <memcmp>
			 BDADDR_SIZE)) ||
 10108b2:	2800      	cmp	r0, #0
 10108b4:	f47f aec7 	bne.w	1010646 <isr_rx+0x26>
		       isr_rx_ci_tgta_check(lll, adv, ci, *rl_idx);
 10108b8:	f89d 300f 	ldrb.w	r3, [sp, #15]
	if (rl_idx != FILTER_IDX_NONE) {
 10108bc:	2bff      	cmp	r3, #255	; 0xff
 10108be:	d03a      	beq.n	1010936 <isr_rx+0x316>
		return rl_idx == lll->rl_idx;
 10108c0:	7ba0      	ldrb	r0, [r4, #14]
 10108c2:	1ac0      	subs	r0, r0, r3
 10108c4:	fab0 f080 	clz	r0, r0
 10108c8:	0940      	lsrs	r0, r0, #5
 10108ca:	e728      	b.n	101071e <isr_rx+0xfe>
		 !memcmp(adv->direct_ind.adv_addr, ci->connect_ind.adv_addr,
 10108cc:	4650      	mov	r0, sl
 10108ce:	4629      	mov	r1, r5
 10108d0:	2206      	movs	r2, #6
 10108d2:	f006 f891 	bl	10169f8 <memcmp>
		(((adv->type == PDU_ADV_TYPE_DIRECT_IND) &&
 10108d6:	2800      	cmp	r0, #0
 10108d8:	f43f af23 	beq.w	1010722 <isr_rx+0x102>
 10108dc:	e717      	b.n	101070e <isr_rx+0xee>
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
 10108de:	f89d 000f 	ldrb.w	r0, [sp, #15]
 10108e2:	f7ff f8a7 	bl	100fa34 <ull_filter_lll_irk_whitelisted>
 10108e6:	2800      	cmp	r0, #0
 10108e8:	d18b      	bne.n	1010802 <isr_rx+0x1e2>
 10108ea:	e7a2      	b.n	1010832 <isr_rx+0x212>
		!memcmp(adv->adv_ind.addr, sr->scan_req.adv_addr, BDADDR_SIZE);
 10108ec:	2206      	movs	r2, #6
 10108ee:	f108 0108 	add.w	r1, r8, #8
 10108f2:	f10a 0002 	add.w	r0, sl, #2
 10108f6:	f006 f87f 	bl	10169f8 <memcmp>
	return (adv->tx_addr == sr->rx_addr) &&
 10108fa:	2800      	cmp	r0, #0
 10108fc:	d199      	bne.n	1010832 <isr_rx+0x212>
		radio_isr_set(isr_done, lll);
 10108fe:	4621      	mov	r1, r4
 1010900:	481b      	ldr	r0, [pc, #108]	; (1010970 <isr_rx+0x350>)
 1010902:	f001 fa35 	bl	1011d70 <radio_isr_set>
		radio_switch_complete_and_disable();
 1010906:	f001 fba9 	bl	101205c <radio_switch_complete_and_disable>
}

static inline struct pdu_adv *lll_adv_scan_rsp_curr_get(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.first];
 101090a:	f894 305f 	ldrb.w	r3, [r4, #95]	; 0x5f
 101090e:	eb03 0083 	add.w	r0, r3, r3, lsl #2
 1010912:	ebc3 03c0 	rsb	r3, r3, r0, lsl #3
 1010916:	f103 0061 	add.w	r0, r3, #97	; 0x61
		radio_pkt_tx_set(lll_adv_scan_rsp_curr_get(lll));
 101091a:	4420      	add	r0, r4
 101091c:	f001 faf8 	bl	1011f10 <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
 1010920:	f001 fb46 	bl	1011fb0 <radio_is_ready>
 1010924:	2800      	cmp	r0, #0
 1010926:	f43f ae94 	beq.w	1010652 <isr_rx+0x32>
 101092a:	f240 219b 	movw	r1, #667	; 0x29b
 101092e:	4812      	ldr	r0, [pc, #72]	; (1010978 <isr_rx+0x358>)
 1010930:	f7f2 fea6 	bl	1003680 <bt_ctlr_assert_handle>
		if (!err) {
 1010934:	e68d      	b.n	1010652 <isr_rx+0x32>
	return (adv->rx_addr == ci->tx_addr) &&
 1010936:	f898 3000 	ldrb.w	r3, [r8]
 101093a:	5d62      	ldrb	r2, [r4, r5]
 101093c:	f3c3 1380 	ubfx	r3, r3, #6, #1
 1010940:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
 1010944:	d00a      	beq.n	101095c <isr_rx+0x33c>
 1010946:	2000      	movs	r0, #0
		       isr_rx_ci_adva_check(adv, ci) &&
 1010948:	e6e9      	b.n	101071e <isr_rx+0xfe>
		 !memcmp(adv->direct_ind.adv_addr, ci->connect_ind.adv_addr,
 101094a:	4658      	mov	r0, fp
 101094c:	2206      	movs	r2, #6
 101094e:	9101      	str	r1, [sp, #4]
 1010950:	f006 f852 	bl	10169f8 <memcmp>
		(((adv->type == PDU_ADV_TYPE_DIRECT_IND) &&
 1010954:	2800      	cmp	r0, #0
 1010956:	d0af      	beq.n	10108b8 <isr_rx+0x298>
 1010958:	9901      	ldr	r1, [sp, #4]
 101095a:	e7a6      	b.n	10108aa <isr_rx+0x28a>
	       !memcmp(adv->direct_ind.tgt_addr, ci->connect_ind.init_addr,
 101095c:	4639      	mov	r1, r7
 101095e:	2206      	movs	r2, #6
 1010960:	f10a 0008 	add.w	r0, sl, #8
 1010964:	f006 f848 	bl	10169f8 <memcmp>
	return (adv->rx_addr == ci->tx_addr) &&
 1010968:	fab0 f080 	clz	r0, r0
 101096c:	0940      	lsrs	r0, r0, #5
 101096e:	e6d6      	b.n	101071e <isr_rx+0xfe>
 1010970:	010105c9 	.word	0x010105c9
 1010974:	0101021d 	.word	0x0101021d
 1010978:	01018b10 	.word	0x01018b10

0101097c <lll_adv_init>:
}
 101097c:	2000      	movs	r0, #0
 101097e:	4770      	bx	lr

01010980 <lll_adv_reset>:
 1010980:	2000      	movs	r0, #0
 1010982:	4770      	bx	lr

01010984 <lll_adv_prepare>:
{
 1010984:	b510      	push	{r4, lr}
 1010986:	b082      	sub	sp, #8
 1010988:	4604      	mov	r4, r0
	err = lll_hfclock_on();
 101098a:	f7ff fc0f 	bl	10101ac <lll_hfclock_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
 101098e:	b108      	cbz	r0, 1010994 <lll_adv_prepare+0x10>
 1010990:	3044      	adds	r0, #68	; 0x44
 1010992:	d112      	bne.n	10109ba <lll_adv_prepare+0x36>
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, p);
 1010994:	2300      	movs	r3, #0
 1010996:	4a0b      	ldr	r2, [pc, #44]	; (10109c4 <lll_adv_prepare+0x40>)
 1010998:	490b      	ldr	r1, [pc, #44]	; (10109c8 <lll_adv_prepare+0x44>)
 101099a:	480c      	ldr	r0, [pc, #48]	; (10109cc <lll_adv_prepare+0x48>)
 101099c:	9400      	str	r4, [sp, #0]
 101099e:	f7ff fabd 	bl	100ff1c <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
 10109a2:	b108      	cbz	r0, 10109a8 <lll_adv_prepare+0x24>
 10109a4:	3044      	adds	r0, #68	; 0x44
 10109a6:	d101      	bne.n	10109ac <lll_adv_prepare+0x28>
}
 10109a8:	b002      	add	sp, #8
 10109aa:	bd10      	pop	{r4, pc}
	LL_ASSERT(!err || err == -EINPROGRESS);
 10109ac:	2171      	movs	r1, #113	; 0x71
 10109ae:	4808      	ldr	r0, [pc, #32]	; (10109d0 <lll_adv_prepare+0x4c>)
}
 10109b0:	b002      	add	sp, #8
 10109b2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LL_ASSERT(!err || err == -EINPROGRESS);
 10109b6:	f7f2 be63 	b.w	1003680 <bt_ctlr_assert_handle>
	LL_ASSERT(!err || err == -EINPROGRESS);
 10109ba:	216e      	movs	r1, #110	; 0x6e
 10109bc:	4804      	ldr	r0, [pc, #16]	; (10109d0 <lll_adv_prepare+0x4c>)
 10109be:	f7f2 fe5f 	bl	1003680 <bt_ctlr_assert_handle>
 10109c2:	e7e7      	b.n	1010994 <lll_adv_prepare+0x10>
 10109c4:	010103f9 	.word	0x010103f9
 10109c8:	0101058d 	.word	0x0101058d
 10109cc:	01010529 	.word	0x01010529
 10109d0:	01018b10 	.word	0x01018b10

010109d4 <ticker_stop_cb>:
{
 10109d4:	b508      	push	{r3, lr}
	radio_isr_set(isr_cleanup, param);
 10109d6:	4619      	mov	r1, r3
 10109d8:	4803      	ldr	r0, [pc, #12]	; (10109e8 <ticker_stop_cb+0x14>)
 10109da:	f001 f9c9 	bl	1011d70 <radio_isr_set>
}
 10109de:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_disable();
 10109e2:	f001 bac3 	b.w	1011f6c <radio_disable>
 10109e6:	bf00      	nop
 10109e8:	01010ddd 	.word	0x01010ddd

010109ec <prepare_cb>:
{
 10109ec:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct lll_scan *lll = prepare_param->param;
 10109ee:	68c5      	ldr	r5, [r0, #12]
	u32_t aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
 10109f0:	4b61      	ldr	r3, [pc, #388]	; (1010b78 <prepare_cb+0x18c>)
	return !!hdr->is_stop;
 10109f2:	792c      	ldrb	r4, [r5, #4]
{
 10109f4:	b08d      	sub	sp, #52	; 0x34
	if (lll_is_stop(lll)) {
 10109f6:	f014 0401 	ands.w	r4, r4, #1
	u32_t aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
 10109fa:	930b      	str	r3, [sp, #44]	; 0x2c
	if (lll_is_stop(lll)) {
 10109fc:	d176      	bne.n	1010aec <prepare_cb+0x100>
	radio_reset();
 10109fe:	4606      	mov	r6, r0
 1010a00:	f001 f9d6 	bl	1011db0 <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
 1010a04:	4620      	mov	r0, r4
 1010a06:	f001 fa0f 	bl	1011e28 <radio_tx_power_set>
	radio_phy_set(0, 0);
 1010a0a:	4621      	mov	r1, r4
 1010a0c:	4620      	mov	r0, r4
 1010a0e:	f001 f9f3 	bl	1011df8 <radio_phy_set>
	radio_pkt_configure(8, PDU_AC_PAYLOAD_SIZE_MAX, 0);
 1010a12:	4622      	mov	r2, r4
 1010a14:	2125      	movs	r1, #37	; 0x25
 1010a16:	2008      	movs	r0, #8
 1010a18:	f001 fa3e 	bl	1011e98 <radio_pkt_configure>
	node_rx = ull_pdu_rx_alloc_peek(1);
 1010a1c:	2001      	movs	r0, #1
 1010a1e:	f7f9 fc99 	bl	100a354 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
 1010a22:	4604      	mov	r4, r0
 1010a24:	2800      	cmp	r0, #0
 1010a26:	f000 80a2 	beq.w	1010b6e <prepare_cb+0x182>
	radio_pkt_rx_set(node_rx->pdu);
 1010a2a:	f104 0020 	add.w	r0, r4, #32
 1010a2e:	f001 fa69 	bl	1011f04 <radio_pkt_rx_set>
	radio_aa_set((u8_t *)&aa);
 1010a32:	a80b      	add	r0, sp, #44	; 0x2c
 1010a34:	f001 fa16 	bl	1011e64 <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
 1010a38:	4950      	ldr	r1, [pc, #320]	; (1010b7c <prepare_cb+0x190>)
 1010a3a:	f240 605b 	movw	r0, #1627	; 0x65b
 1010a3e:	f001 fad5 	bl	1011fec <radio_crc_configure>
	lll_chan_set(37 + lll->chan);
 1010a42:	7da8      	ldrb	r0, [r5, #22]
 1010a44:	f3c0 0041 	ubfx	r0, r0, #1, #2
 1010a48:	3025      	adds	r0, #37	; 0x25
 1010a4a:	f7ff fb35 	bl	10100b8 <lll_chan_set>
	radio_isr_set(isr_rx, lll);
 1010a4e:	4629      	mov	r1, r5
 1010a50:	484b      	ldr	r0, [pc, #300]	; (1010b80 <prepare_cb+0x194>)
 1010a52:	f001 f98d 	bl	1011d70 <radio_isr_set>
	radio_tmr_tifs_set(EVENT_IFS_US);
 1010a56:	2096      	movs	r0, #150	; 0x96
 1010a58:	f001 fb86 	bl	1012168 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
 1010a5c:	2300      	movs	r3, #0
 1010a5e:	461a      	mov	r2, r3
 1010a60:	4619      	mov	r1, r3
 1010a62:	4618      	mov	r0, r3
 1010a64:	f001 faee 	bl	1012044 <radio_switch_complete_and_tx>
	if (ull_filter_lll_rl_enabled()) {
 1010a68:	f7ff f89a 	bl	100fba0 <ull_filter_lll_rl_enabled>
 1010a6c:	bb40      	cbnz	r0, 1010ac0 <prepare_cb+0xd4>
	if (IS_ENABLED(CONFIG_BT_CTLR_FILTER) && lll->filter_policy) {
 1010a6e:	7dab      	ldrb	r3, [r5, #22]
 1010a70:	f013 0f18 	tst.w	r3, #24
 1010a74:	d172      	bne.n	1010b5c <prepare_cb+0x170>
	evt = HDR_LLL2EVT(lll);
 1010a76:	682f      	ldr	r7, [r5, #0]
	ticks_at_event = prepare_param->ticks_at_expire;
 1010a78:	6834      	ldr	r4, [r6, #0]
	ticks_at_event += lll_evt_offset_get(evt);
 1010a7a:	4638      	mov	r0, r7
 1010a7c:	f7ff fb00 	bl	1010080 <lll_evt_offset_get>
 1010a80:	4404      	add	r4, r0
	remainder_us = radio_tmr_start(0, ticks_at_start, remainder);
 1010a82:	6872      	ldr	r2, [r6, #4]
 1010a84:	f104 0109 	add.w	r1, r4, #9
 1010a88:	2000      	movs	r0, #0
 1010a8a:	f001 fb79 	bl	1012180 <radio_tmr_start>
	radio_tmr_end_capture();
 1010a8e:	f001 fc8f 	bl	10123b0 <radio_tmr_end_capture>
	radio_rssi_measure();
 1010a92:	f001 faf9 	bl	1012088 <radio_rssi_measure>
				   ull_scan_lll_handle_get(lll)),
 1010a96:	4628      	mov	r0, r5
 1010a98:	f7fa fa4a 	bl	100af30 <ull_scan_lll_handle_get>
	if (lll_preempt_calc(evt, (TICKER_ID_SCAN_BASE +
 1010a9c:	1d01      	adds	r1, r0, #4
 1010a9e:	b2c9      	uxtb	r1, r1
 1010aa0:	4638      	mov	r0, r7
 1010aa2:	4622      	mov	r2, r4
 1010aa4:	f7ff faf6 	bl	1010094 <lll_preempt_calc>
 1010aa8:	4601      	mov	r1, r0
 1010aaa:	bb70      	cbnz	r0, 1010b0a <prepare_cb+0x11e>
		if (lll->ticks_window) {
 1010aac:	6aab      	ldr	r3, [r5, #40]	; 0x28
 1010aae:	2b00      	cmp	r3, #0
 1010ab0:	d13c      	bne.n	1010b2c <prepare_cb+0x140>
		ret = lll_prepare_done(lll);
 1010ab2:	4628      	mov	r0, r5
 1010ab4:	f7ff faa6 	bl	1010004 <lll_prepare_done>
		LL_ASSERT(!ret);
 1010ab8:	bb80      	cbnz	r0, 1010b1c <prepare_cb+0x130>
}
 1010aba:	2000      	movs	r0, #0
 1010abc:	b00d      	add	sp, #52	; 0x34
 1010abe:	bdf0      	pop	{r4, r5, r6, r7, pc}
			ull_filter_lll_get(!!(lll->filter_policy & 0x1));
 1010ac0:	7da8      	ldrb	r0, [r5, #22]
 1010ac2:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 1010ac6:	f7fe ffd9 	bl	100fa7c <ull_filter_lll_get>
 1010aca:	4604      	mov	r4, r0
		u8_t count, *irks = ull_filter_lll_irks_get(&count);
 1010acc:	f10d 002b 	add.w	r0, sp, #43	; 0x2b
 1010ad0:	f7fe ff34 	bl	100f93c <ull_filter_lll_irks_get>
 1010ad4:	4607      	mov	r7, r0
		radio_filter_configure(filter->enable_bitmask,
 1010ad6:	7861      	ldrb	r1, [r4, #1]
 1010ad8:	7820      	ldrb	r0, [r4, #0]
 1010ada:	1ca2      	adds	r2, r4, #2
 1010adc:	f001 faf6 	bl	10120cc <radio_filter_configure>
		radio_ar_configure(count, irks);
 1010ae0:	4639      	mov	r1, r7
 1010ae2:	f89d 002b 	ldrb.w	r0, [sp, #43]	; 0x2b
 1010ae6:	f001 fd2f 	bl	1012548 <radio_ar_configure>
 1010aea:	e7c4      	b.n	1010a76 <prepare_cb+0x8a>
		err = lll_hfclock_off();
 1010aec:	f7ff fb66 	bl	10101bc <lll_hfclock_off>
		LL_ASSERT(!err || err == -EBUSY);
 1010af0:	b128      	cbz	r0, 1010afe <prepare_cb+0x112>
 1010af2:	3010      	adds	r0, #16
 1010af4:	d003      	beq.n	1010afe <prepare_cb+0x112>
 1010af6:	218b      	movs	r1, #139	; 0x8b
 1010af8:	4822      	ldr	r0, [pc, #136]	; (1010b84 <prepare_cb+0x198>)
 1010afa:	f7f2 fdc1 	bl	1003680 <bt_ctlr_assert_handle>
		lll_done(NULL);
 1010afe:	2000      	movs	r0, #0
 1010b00:	f7ff fa82 	bl	1010008 <lll_done>
}
 1010b04:	2000      	movs	r0, #0
 1010b06:	b00d      	add	sp, #52	; 0x34
 1010b08:	bdf0      	pop	{r4, r5, r6, r7, pc}
		radio_isr_set(isr_abort, lll);
 1010b0a:	4629      	mov	r1, r5
 1010b0c:	481e      	ldr	r0, [pc, #120]	; (1010b88 <prepare_cb+0x19c>)
 1010b0e:	f001 f92f 	bl	1011d70 <radio_isr_set>
		radio_disable();
 1010b12:	f001 fa2b 	bl	1011f6c <radio_disable>
}
 1010b16:	2000      	movs	r0, #0
 1010b18:	b00d      	add	sp, #52	; 0x34
 1010b1a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LL_ASSERT(!ret);
 1010b1c:	f44f 7182 	mov.w	r1, #260	; 0x104
 1010b20:	4818      	ldr	r0, [pc, #96]	; (1010b84 <prepare_cb+0x198>)
 1010b22:	f7f2 fdad 	bl	1003680 <bt_ctlr_assert_handle>
}
 1010b26:	2000      	movs	r0, #0
 1010b28:	b00d      	add	sp, #52	; 0x34
 1010b2a:	bdf0      	pop	{r4, r5, r6, r7, pc}
			ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1010b2c:	22fe      	movs	r2, #254	; 0xfe
 1010b2e:	4e17      	ldr	r6, [pc, #92]	; (1010b8c <prepare_cb+0x1a0>)
 1010b30:	9208      	str	r2, [sp, #32]
 1010b32:	4a17      	ldr	r2, [pc, #92]	; (1010b90 <prepare_cb+0x1a4>)
 1010b34:	9300      	str	r3, [sp, #0]
 1010b36:	9205      	str	r2, [sp, #20]
 1010b38:	4623      	mov	r3, r4
 1010b3a:	2203      	movs	r2, #3
 1010b3c:	e9cd 0003 	strd	r0, r0, [sp, #12]
 1010b40:	e9cd 0001 	strd	r0, r0, [sp, #4]
 1010b44:	9506      	str	r5, [sp, #24]
 1010b46:	9607      	str	r6, [sp, #28]
 1010b48:	f7f6 fb8a 	bl	1007260 <ticker_start>
			LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 1010b4c:	f030 0302 	bics.w	r3, r0, #2
 1010b50:	d0af      	beq.n	1010ab2 <prepare_cb+0xc6>
 1010b52:	21ff      	movs	r1, #255	; 0xff
 1010b54:	480b      	ldr	r0, [pc, #44]	; (1010b84 <prepare_cb+0x198>)
 1010b56:	f7f2 fd93 	bl	1003680 <bt_ctlr_assert_handle>
 1010b5a:	e7aa      	b.n	1010ab2 <prepare_cb+0xc6>
		struct lll_filter *wl = ull_filter_lll_get(true);
 1010b5c:	2001      	movs	r0, #1
 1010b5e:	f7fe ff8d 	bl	100fa7c <ull_filter_lll_get>
		radio_filter_configure(wl->enable_bitmask,
 1010b62:	7841      	ldrb	r1, [r0, #1]
 1010b64:	1c82      	adds	r2, r0, #2
 1010b66:	7800      	ldrb	r0, [r0, #0]
 1010b68:	f001 fab0 	bl	10120cc <radio_filter_configure>
 1010b6c:	e783      	b.n	1010a76 <prepare_cb+0x8a>
	LL_ASSERT(node_rx);
 1010b6e:	21a4      	movs	r1, #164	; 0xa4
 1010b70:	4804      	ldr	r0, [pc, #16]	; (1010b84 <prepare_cb+0x198>)
 1010b72:	f7f2 fd85 	bl	1003680 <bt_ctlr_assert_handle>
 1010b76:	e758      	b.n	1010a2a <prepare_cb+0x3e>
 1010b78:	8e89bed6 	.word	0x8e89bed6
 1010b7c:	00555555 	.word	0x00555555
 1010b80:	01002df1 	.word	0x01002df1
 1010b84:	01018b6c 	.word	0x01018b6c
 1010b88:	01010e51 	.word	0x01010e51
 1010b8c:	01010d19 	.word	0x01010d19
 1010b90:	010109d5 	.word	0x010109d5

01010b94 <isr_race>:
	radio_status_reset();
 1010b94:	f001 ba00 	b.w	1011f98 <radio_status_reset>

01010b98 <isr_common_done>:
{
 1010b98:	b530      	push	{r4, r5, lr}
 1010b9a:	b083      	sub	sp, #12
 1010b9c:	4605      	mov	r5, r0
	radio_status_reset();
 1010b9e:	f001 f9fb 	bl	1011f98 <radio_status_reset>
	radio_tmr_status_reset();
 1010ba2:	f001 fad1 	bl	1012148 <radio_tmr_status_reset>
	radio_filter_status_reset();
 1010ba6:	f001 fab7 	bl	1012118 <radio_filter_status_reset>
	radio_ar_status_reset();
 1010baa:	f001 fd0b 	bl	10125c4 <radio_ar_status_reset>
	radio_rssi_status_reset();
 1010bae:	f001 fa7b 	bl	10120a8 <radio_rssi_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
 1010bb2:	2096      	movs	r0, #150	; 0x96
 1010bb4:	f001 fad8 	bl	1012168 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
 1010bb8:	2300      	movs	r3, #0
 1010bba:	4618      	mov	r0, r3
 1010bbc:	461a      	mov	r2, r3
 1010bbe:	4619      	mov	r1, r3
 1010bc0:	f001 fa40 	bl	1012044 <radio_switch_complete_and_tx>
	node_rx = ull_pdu_rx_alloc_peek(1);
 1010bc4:	2001      	movs	r0, #1
 1010bc6:	f7f9 fbc5 	bl	100a354 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
 1010bca:	4604      	mov	r4, r0
 1010bcc:	b1c0      	cbz	r0, 1010c00 <isr_common_done+0x68>
	radio_pkt_rx_set(node_rx->pdu);
 1010bce:	f104 0020 	add.w	r0, r4, #32
 1010bd2:	f001 f997 	bl	1011f04 <radio_pkt_rx_set>
	if (ull_filter_lll_rl_enabled()) {
 1010bd6:	f7fe ffe3 	bl	100fba0 <ull_filter_lll_rl_enabled>
 1010bda:	b938      	cbnz	r0, 1010bec <isr_common_done+0x54>
	radio_rssi_measure();
 1010bdc:	f001 fa54 	bl	1012088 <radio_rssi_measure>
	radio_isr_set(isr_rx, param);
 1010be0:	4629      	mov	r1, r5
 1010be2:	480a      	ldr	r0, [pc, #40]	; (1010c0c <isr_common_done+0x74>)
 1010be4:	f001 f8c4 	bl	1011d70 <radio_isr_set>
}
 1010be8:	b003      	add	sp, #12
 1010bea:	bd30      	pop	{r4, r5, pc}
		u8_t count, *irks = ull_filter_lll_irks_get(&count);
 1010bec:	f10d 0007 	add.w	r0, sp, #7
 1010bf0:	f7fe fea4 	bl	100f93c <ull_filter_lll_irks_get>
 1010bf4:	4601      	mov	r1, r0
		radio_ar_configure(count, irks);
 1010bf6:	f89d 0007 	ldrb.w	r0, [sp, #7]
 1010bfa:	f001 fca5 	bl	1012548 <radio_ar_configure>
 1010bfe:	e7ed      	b.n	1010bdc <isr_common_done+0x44>
	LL_ASSERT(node_rx);
 1010c00:	f44f 71fe 	mov.w	r1, #508	; 0x1fc
 1010c04:	4802      	ldr	r0, [pc, #8]	; (1010c10 <isr_common_done+0x78>)
 1010c06:	f7f2 fd3b 	bl	1003680 <bt_ctlr_assert_handle>
 1010c0a:	e7e0      	b.n	1010bce <isr_common_done+0x36>
 1010c0c:	01002df1 	.word	0x01002df1
 1010c10:	01018b6c 	.word	0x01018b6c

01010c14 <isr_done>:
{
 1010c14:	b508      	push	{r3, lr}
	isr_common_done(param);
 1010c16:	f7ff ffbf 	bl	1010b98 <isr_common_done>
	radio_rx_enable();
 1010c1a:	f001 f99b 	bl	1011f54 <radio_rx_enable>
}
 1010c1e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_tmr_end_capture();
 1010c22:	f001 bbc5 	b.w	10123b0 <radio_tmr_end_capture>
 1010c26:	bf00      	nop

01010c28 <isr_tx>:
{
 1010c28:	b570      	push	{r4, r5, r6, lr}
 1010c2a:	b082      	sub	sp, #8
 1010c2c:	4605      	mov	r5, r0
	radio_status_reset();
 1010c2e:	f001 f9b3 	bl	1011f98 <radio_status_reset>
	radio_tmr_status_reset();
 1010c32:	f001 fa89 	bl	1012148 <radio_tmr_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
 1010c36:	2096      	movs	r0, #150	; 0x96
 1010c38:	f001 fa96 	bl	1012168 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
 1010c3c:	2300      	movs	r3, #0
 1010c3e:	4618      	mov	r0, r3
 1010c40:	461a      	mov	r2, r3
 1010c42:	4619      	mov	r1, r3
 1010c44:	f001 f9fe 	bl	1012044 <radio_switch_complete_and_tx>
	node_rx = ull_pdu_rx_alloc_peek(1);
 1010c48:	2001      	movs	r0, #1
 1010c4a:	f7f9 fb83 	bl	100a354 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
 1010c4e:	4604      	mov	r4, r0
 1010c50:	b3a8      	cbz	r0, 1010cbe <isr_tx+0x96>
	radio_pkt_rx_set(node_rx->pdu);
 1010c52:	f104 0020 	add.w	r0, r4, #32
 1010c56:	f001 f955 	bl	1011f04 <radio_pkt_rx_set>
	LL_ASSERT(!radio_is_ready());
 1010c5a:	f001 f9a9 	bl	1011fb0 <radio_is_ready>
 1010c5e:	b9d8      	cbnz	r0, 1010c98 <isr_tx+0x70>
	if (ull_filter_lll_rl_enabled()) {
 1010c60:	f7fe ff9e 	bl	100fba0 <ull_filter_lll_rl_enabled>
 1010c64:	bb08      	cbnz	r0, 1010caa <isr_tx+0x82>
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
 1010c66:	f001 fbbf 	bl	10123e8 <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(0, 0);
 1010c6a:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
 1010c6c:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(0, 0);
 1010c6e:	4608      	mov	r0, r1
 1010c70:	f001 f962 	bl	1011f38 <radio_rx_chain_delay_get>
	hcto -= radio_tx_chain_delay_get(0, 0);
 1010c74:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(0, 0);
 1010c76:	4606      	mov	r6, r0
	hcto -= radio_tx_chain_delay_get(0, 0);
 1010c78:	4608      	mov	r0, r1
 1010c7a:	f001 f959 	bl	1011f30 <radio_tx_chain_delay_get>
 1010c7e:	4434      	add	r4, r6
 1010c80:	34c3      	adds	r4, #195	; 0xc3
	radio_tmr_hcto_configure(hcto);
 1010c82:	1a20      	subs	r0, r4, r0
 1010c84:	f001 fb3e 	bl	1012304 <radio_tmr_hcto_configure>
	radio_rssi_measure();
 1010c88:	f001 f9fe 	bl	1012088 <radio_rssi_measure>
	radio_isr_set(isr_rx, param);
 1010c8c:	4629      	mov	r1, r5
 1010c8e:	480f      	ldr	r0, [pc, #60]	; (1010ccc <isr_tx+0xa4>)
 1010c90:	f001 f86e 	bl	1011d70 <radio_isr_set>
}
 1010c94:	b002      	add	sp, #8
 1010c96:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(!radio_is_ready());
 1010c98:	f240 11c7 	movw	r1, #455	; 0x1c7
 1010c9c:	480c      	ldr	r0, [pc, #48]	; (1010cd0 <isr_tx+0xa8>)
 1010c9e:	f7f2 fcef 	bl	1003680 <bt_ctlr_assert_handle>
	if (ull_filter_lll_rl_enabled()) {
 1010ca2:	f7fe ff7d 	bl	100fba0 <ull_filter_lll_rl_enabled>
 1010ca6:	2800      	cmp	r0, #0
 1010ca8:	d0dd      	beq.n	1010c66 <isr_tx+0x3e>
		u8_t count, *irks = ull_filter_lll_irks_get(&count);
 1010caa:	f10d 0007 	add.w	r0, sp, #7
 1010cae:	f7fe fe45 	bl	100f93c <ull_filter_lll_irks_get>
 1010cb2:	4601      	mov	r1, r0
		radio_ar_configure(count, irks);
 1010cb4:	f89d 0007 	ldrb.w	r0, [sp, #7]
 1010cb8:	f001 fc46 	bl	1012548 <radio_ar_configure>
 1010cbc:	e7d3      	b.n	1010c66 <isr_tx+0x3e>
	LL_ASSERT(node_rx);
 1010cbe:	f240 11c3 	movw	r1, #451	; 0x1c3
 1010cc2:	4803      	ldr	r0, [pc, #12]	; (1010cd0 <isr_tx+0xa8>)
 1010cc4:	f7f2 fcdc 	bl	1003680 <bt_ctlr_assert_handle>
 1010cc8:	e7c3      	b.n	1010c52 <isr_tx+0x2a>
 1010cca:	bf00      	nop
 1010ccc:	01002df1 	.word	0x01002df1
 1010cd0:	01018b6c 	.word	0x01018b6c

01010cd4 <resume_prepare_cb>:
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
 1010cd4:	68c3      	ldr	r3, [r0, #12]
{
 1010cd6:	b570      	push	{r4, r5, r6, lr}
 1010cd8:	4604      	mov	r4, r0
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
 1010cda:	681e      	ldr	r6, [r3, #0]
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
 1010cdc:	f7f6 fb60 	bl	10073a0 <ticker_ticks_now_get>
 1010ce0:	4605      	mov	r5, r0
 1010ce2:	4630      	mov	r0, r6
 1010ce4:	f7ff f9cc 	bl	1010080 <lll_evt_offset_get>
	p->remainder = 0;
 1010ce8:	2300      	movs	r3, #0
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
 1010cea:	1a2d      	subs	r5, r5, r0
	p->remainder = 0;
 1010cec:	e9c4 5300 	strd	r5, r3, [r4]
	return prepare_cb(p);
 1010cf0:	4620      	mov	r0, r4
	p->lazy = 0;
 1010cf2:	8123      	strh	r3, [r4, #8]
}
 1010cf4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return prepare_cb(p);
 1010cf8:	f7ff be78 	b.w	10109ec <prepare_cb>

01010cfc <isr_window>:
{
 1010cfc:	b508      	push	{r3, lr}
	isr_common_done(param);
 1010cfe:	f7ff ff4b 	bl	1010b98 <isr_common_done>
	ticks_at_start = ticker_ticks_now_get() +
 1010d02:	f7f6 fb4d 	bl	10073a0 <ticker_ticks_now_get>
 1010d06:	4601      	mov	r1, r0
	remainder_us = radio_tmr_start_tick(0, ticks_at_start);
 1010d08:	2000      	movs	r0, #0
 1010d0a:	3103      	adds	r1, #3
 1010d0c:	f001 faa8 	bl	1012260 <radio_tmr_start_tick>
}
 1010d10:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_tmr_end_capture();
 1010d14:	f001 bb4c 	b.w	10123b0 <radio_tmr_end_capture>

01010d18 <ticker_op_start_cb>:
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 1010d18:	b900      	cbnz	r0, 1010d1c <ticker_op_start_cb+0x4>
}
 1010d1a:	4770      	bx	lr
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 1010d1c:	f44f 71b0 	mov.w	r1, #352	; 0x160
 1010d20:	4801      	ldr	r0, [pc, #4]	; (1010d28 <ticker_op_start_cb+0x10>)
 1010d22:	f7f2 bcad 	b.w	1003680 <bt_ctlr_assert_handle>
 1010d26:	bf00      	nop
 1010d28:	01018b6c 	.word	0x01018b6c

01010d2c <abort_cb>:
{
 1010d2c:	b510      	push	{r4, lr}
	if (!prepare_param) {
 1010d2e:	b178      	cbz	r0, 1010d50 <abort_cb+0x24>
	err = lll_hfclock_off();
 1010d30:	460c      	mov	r4, r1
 1010d32:	f7ff fa43 	bl	10101bc <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
 1010d36:	b130      	cbz	r0, 1010d46 <abort_cb+0x1a>
 1010d38:	3010      	adds	r0, #16
 1010d3a:	d004      	beq.n	1010d46 <abort_cb+0x1a>
 1010d3c:	f44f 71a8 	mov.w	r1, #336	; 0x150
 1010d40:	4807      	ldr	r0, [pc, #28]	; (1010d60 <abort_cb+0x34>)
 1010d42:	f7f2 fc9d 	bl	1003680 <bt_ctlr_assert_handle>
	lll_done(param);
 1010d46:	4620      	mov	r0, r4
}
 1010d48:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
 1010d4c:	f7ff b95c 	b.w	1010008 <lll_done>
			radio_isr_set(isr_abort, param);
 1010d50:	4804      	ldr	r0, [pc, #16]	; (1010d64 <abort_cb+0x38>)
 1010d52:	f001 f80d 	bl	1011d70 <radio_isr_set>
}
 1010d56:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			radio_disable();
 1010d5a:	f001 b907 	b.w	1011f6c <radio_disable>
 1010d5e:	bf00      	nop
 1010d60:	01018b6c 	.word	0x01018b6c
 1010d64:	01010e51 	.word	0x01010e51

01010d68 <is_abort_cb>:
	if (next != curr) {
 1010d68:	4282      	cmp	r2, r0
{
 1010d6a:	b510      	push	{r4, lr}
	if (next != curr) {
 1010d6c:	d11b      	bne.n	1010da6 <is_abort_cb+0x3e>
	radio_isr_set(isr_window, lll);
 1010d6e:	4614      	mov	r4, r2
 1010d70:	4817      	ldr	r0, [pc, #92]	; (1010dd0 <is_abort_cb+0x68>)
 1010d72:	4611      	mov	r1, r2
 1010d74:	f000 fffc 	bl	1011d70 <radio_isr_set>
	radio_disable();
 1010d78:	f001 f8f8 	bl	1011f6c <radio_disable>
	if (++lll->chan == 3U) {
 1010d7c:	7da3      	ldrb	r3, [r4, #22]
 1010d7e:	f3c3 0041 	ubfx	r0, r3, #1, #2
 1010d82:	3001      	adds	r0, #1
 1010d84:	f000 0003 	and.w	r0, r0, #3
 1010d88:	2803      	cmp	r0, #3
 1010d8a:	d007      	beq.n	1010d9c <is_abort_cb+0x34>
 1010d8c:	f360 0342 	bfi	r3, r0, #1, #2
 1010d90:	75a3      	strb	r3, [r4, #22]
 1010d92:	3025      	adds	r0, #37	; 0x25
	lll_chan_set(37 + lll->chan);
 1010d94:	f7ff f990 	bl	10100b8 <lll_chan_set>
	return 0;
 1010d98:	2000      	movs	r0, #0
}
 1010d9a:	bd10      	pop	{r4, pc}
		lll->chan = 0U;
 1010d9c:	f36f 0342 	bfc	r3, #1, #2
 1010da0:	2025      	movs	r0, #37	; 0x25
 1010da2:	75a3      	strb	r3, [r4, #22]
 1010da4:	e7f6      	b.n	1010d94 <is_abort_cb+0x2c>
		*resume_prio = 0; /* TODO: */
 1010da6:	2200      	movs	r2, #0
		*resume_cb = resume_prepare_cb;
 1010da8:	490a      	ldr	r1, [pc, #40]	; (1010dd4 <is_abort_cb+0x6c>)
 1010daa:	6019      	str	r1, [r3, #0]
		*resume_prio = 0; /* TODO: */
 1010dac:	9b02      	ldr	r3, [sp, #8]
 1010dae:	601a      	str	r2, [r3, #0]
		err = lll_hfclock_on();
 1010db0:	f7ff f9fc 	bl	10101ac <lll_hfclock_on>
		LL_ASSERT(!err || err == -EINPROGRESS);
 1010db4:	b148      	cbz	r0, 1010dca <is_abort_cb+0x62>
 1010db6:	3044      	adds	r0, #68	; 0x44
 1010db8:	d007      	beq.n	1010dca <is_abort_cb+0x62>
 1010dba:	f44f 7193 	mov.w	r1, #294	; 0x126
 1010dbe:	4806      	ldr	r0, [pc, #24]	; (1010dd8 <is_abort_cb+0x70>)
 1010dc0:	f7f2 fc5e 	bl	1003680 <bt_ctlr_assert_handle>
 1010dc4:	f06f 000a 	mvn.w	r0, #10
}
 1010dc8:	bd10      	pop	{r4, pc}
 1010dca:	f06f 000a 	mvn.w	r0, #10
 1010dce:	bd10      	pop	{r4, pc}
 1010dd0:	01010cfd 	.word	0x01010cfd
 1010dd4:	01010cd5 	.word	0x01010cd5
 1010dd8:	01018b6c 	.word	0x01018b6c

01010ddc <isr_cleanup>:
{
 1010ddc:	b538      	push	{r3, r4, r5, lr}
 1010dde:	4604      	mov	r4, r0
	if (lll_is_done(param)) {
 1010de0:	f7ff f946 	bl	1010070 <lll_is_done>
 1010de4:	b100      	cbz	r0, 1010de8 <isr_cleanup+0xc>
}
 1010de6:	bd38      	pop	{r3, r4, r5, pc}
	radio_filter_disable();
 1010de8:	4605      	mov	r5, r0
 1010dea:	f001 f98b 	bl	1012104 <radio_filter_disable>
	if (++lll->chan == 3U) {
 1010dee:	7da2      	ldrb	r2, [r4, #22]
	radio_isr_set(isr_race, param);
 1010df0:	4621      	mov	r1, r4
	if (++lll->chan == 3U) {
 1010df2:	f3c2 0341 	ubfx	r3, r2, #1, #2
 1010df6:	3301      	adds	r3, #1
 1010df8:	f003 0303 	and.w	r3, r3, #3
 1010dfc:	2b03      	cmp	r3, #3
 1010dfe:	bf14      	ite	ne
 1010e00:	f363 0242 	bfine	r2, r3, #1, #2
		lll->chan = 0U;
 1010e04:	f365 0242 	bfieq	r2, r5, #1, #2
	radio_isr_set(isr_race, param);
 1010e08:	480f      	ldr	r0, [pc, #60]	; (1010e48 <isr_cleanup+0x6c>)
		lll->chan = 0U;
 1010e0a:	75a2      	strb	r2, [r4, #22]
	radio_isr_set(isr_race, param);
 1010e0c:	f000 ffb0 	bl	1011d70 <radio_isr_set>
	if (!radio_is_idle()) {
 1010e10:	f001 f8e2 	bl	1011fd8 <radio_is_idle>
 1010e14:	b1a8      	cbz	r0, 1010e42 <isr_cleanup+0x66>
	radio_tmr_stop();
 1010e16:	f001 fa61 	bl	10122dc <radio_tmr_stop>
	err = lll_hfclock_off();
 1010e1a:	f7ff f9cf 	bl	10101bc <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
 1010e1e:	b108      	cbz	r0, 1010e24 <isr_cleanup+0x48>
 1010e20:	3010      	adds	r0, #16
 1010e22:	d104      	bne.n	1010e2e <isr_cleanup+0x52>
}
 1010e24:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	lll_done(NULL);
 1010e28:	2000      	movs	r0, #0
 1010e2a:	f7ff b8ed 	b.w	1010008 <lll_done>
	LL_ASSERT(!err || err == -EBUSY);
 1010e2e:	4807      	ldr	r0, [pc, #28]	; (1010e4c <isr_cleanup+0x70>)
 1010e30:	f240 2187 	movw	r1, #647	; 0x287
 1010e34:	f7f2 fc24 	bl	1003680 <bt_ctlr_assert_handle>
}
 1010e38:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	lll_done(NULL);
 1010e3c:	2000      	movs	r0, #0
 1010e3e:	f7ff b8e3 	b.w	1010008 <lll_done>
		radio_disable();
 1010e42:	f001 f893 	bl	1011f6c <radio_disable>
 1010e46:	e7e6      	b.n	1010e16 <isr_cleanup+0x3a>
 1010e48:	01010b95 	.word	0x01010b95
 1010e4c:	01018b6c 	.word	0x01018b6c

01010e50 <isr_abort>:
{
 1010e50:	b510      	push	{r4, lr}
 1010e52:	b082      	sub	sp, #8
 1010e54:	4604      	mov	r4, r0
	radio_status_reset();
 1010e56:	f001 f89f 	bl	1011f98 <radio_status_reset>
	radio_tmr_status_reset();
 1010e5a:	f001 f975 	bl	1012148 <radio_tmr_status_reset>
	radio_filter_status_reset();
 1010e5e:	f001 f95b 	bl	1012118 <radio_filter_status_reset>
	radio_ar_status_reset();
 1010e62:	f001 fbaf 	bl	10125c4 <radio_ar_status_reset>
	radio_rssi_status_reset();
 1010e66:	f001 f91f 	bl	10120a8 <radio_rssi_status_reset>
	ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_LLL,
 1010e6a:	2300      	movs	r3, #0
 1010e6c:	2203      	movs	r2, #3
 1010e6e:	4619      	mov	r1, r3
 1010e70:	4618      	mov	r0, r3
 1010e72:	9300      	str	r3, [sp, #0]
 1010e74:	f7f6 fa5a 	bl	100732c <ticker_stop>
	radio_disable();
 1010e78:	f001 f878 	bl	1011f6c <radio_disable>
	isr_cleanup(param);
 1010e7c:	4620      	mov	r0, r4
}
 1010e7e:	b002      	add	sp, #8
 1010e80:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
 1010e84:	f7ff bfaa 	b.w	1010ddc <isr_cleanup>

01010e88 <isr_rx_scan_report.isra.0>:
			&srsp->scan_rsp.addr[0], BDADDR_SIZE) == 0));
}

static u32_t isr_rx_scan_report(struct lll_scan *lll, u8_t rssi_ready,
 1010e88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1010e8a:	4607      	mov	r7, r0
				u8_t rl_idx, bool dir_report)
{
	struct node_rx_pdu *node_rx;
	struct pdu_adv *pdu_adv_rx;

	node_rx = ull_pdu_rx_alloc_peek(3);
 1010e8c:	2003      	movs	r0, #3
static u32_t isr_rx_scan_report(struct lll_scan *lll, u8_t rssi_ready,
 1010e8e:	460e      	mov	r6, r1
 1010e90:	4615      	mov	r5, r2
	node_rx = ull_pdu_rx_alloc_peek(3);
 1010e92:	f7f9 fa5f 	bl	100a354 <ull_pdu_rx_alloc_peek>
	if (!node_rx) {
 1010e96:	b1c8      	cbz	r0, 1010ecc <isr_rx_scan_report.isra.0+0x44>
		return 1;
	}
	ull_pdu_rx_alloc();
 1010e98:	4604      	mov	r4, r0
 1010e9a:	f7f9 fa79 	bl	100a390 <ull_pdu_rx_alloc>

	/* Prepare the report (adv or scan resp) */
	node_rx->hdr.handle = 0xffff;
 1010e9e:	f64f 72ff 	movw	r2, #65535	; 0xffff
			LL_ASSERT(0);
			break;
		}
#endif /* CONFIG_BT_CTLR_ADV_EXT */
	} else {
		node_rx->hdr.type = NODE_RX_TYPE_REPORT;
 1010ea2:	2304      	movs	r3, #4
	node_rx->hdr.handle = 0xffff;
 1010ea4:	80e2      	strh	r2, [r4, #6]
		node_rx->hdr.type = NODE_RX_TYPE_REPORT;
 1010ea6:	7123      	strb	r3, [r4, #4]
	}

	pdu_adv_rx = (void *)node_rx->pdu;

	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ?
 1010ea8:	b95f      	cbnz	r7, 1010ec2 <isr_rx_scan_report.isra.0+0x3a>
 1010eaa:	207f      	movs	r0, #127	; 0x7f
		node_rx->hdr.rx_ftr.chan = _radio.scanner.chan - 1;
		node_rx->hdr.rx_ftr.ticks_anchor = _radio.ticks_anchor;
	}
#endif /* CONFIG_BT_CTLR_EXT_SCAN_FP */

	ull_rx_put(node_rx->hdr.link, node_rx);
 1010eac:	4621      	mov	r1, r4
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ?
 1010eae:	7720      	strb	r0, [r4, #28]
	node_rx->hdr.rx_ftr.rl_idx = rl_idx;
 1010eb0:	77a6      	strb	r6, [r4, #30]
	ull_rx_put(node_rx->hdr.link, node_rx);
 1010eb2:	6820      	ldr	r0, [r4, #0]
	node_rx->hdr.rx_ftr.direct = dir_report;
 1010eb4:	77e5      	strb	r5, [r4, #31]
	ull_rx_put(node_rx->hdr.link, node_rx);
 1010eb6:	f7f9 fa83 	bl	100a3c0 <ull_rx_put>
	ull_rx_sched();
 1010eba:	f7f9 fa91 	bl	100a3e0 <ull_rx_sched>

	return 0;
 1010ebe:	2000      	movs	r0, #0
}
 1010ec0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				   (radio_rssi_get() & 0x7f)
 1010ec2:	f001 f8eb 	bl	101209c <radio_rssi_get>
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ?
 1010ec6:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 1010eca:	e7ef      	b.n	1010eac <isr_rx_scan_report.isra.0+0x24>
		return 1;
 1010ecc:	2001      	movs	r0, #1
}
 1010ece:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

01010ed0 <lll_scan_init>:
}
 1010ed0:	2000      	movs	r0, #0
 1010ed2:	4770      	bx	lr

01010ed4 <lll_scan_reset>:
 1010ed4:	2000      	movs	r0, #0
 1010ed6:	4770      	bx	lr

01010ed8 <lll_scan_prepare>:
{
 1010ed8:	b510      	push	{r4, lr}
 1010eda:	b082      	sub	sp, #8
 1010edc:	4604      	mov	r4, r0
	err = lll_hfclock_on();
 1010ede:	f7ff f965 	bl	10101ac <lll_hfclock_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
 1010ee2:	b108      	cbz	r0, 1010ee8 <lll_scan_prepare+0x10>
 1010ee4:	3044      	adds	r0, #68	; 0x44
 1010ee6:	d112      	bne.n	1010f0e <lll_scan_prepare+0x36>
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, p);
 1010ee8:	2300      	movs	r3, #0
 1010eea:	4a0b      	ldr	r2, [pc, #44]	; (1010f18 <lll_scan_prepare+0x40>)
 1010eec:	490b      	ldr	r1, [pc, #44]	; (1010f1c <lll_scan_prepare+0x44>)
 1010eee:	480c      	ldr	r0, [pc, #48]	; (1010f20 <lll_scan_prepare+0x48>)
 1010ef0:	9400      	str	r4, [sp, #0]
 1010ef2:	f7ff f813 	bl	100ff1c <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
 1010ef6:	b108      	cbz	r0, 1010efc <lll_scan_prepare+0x24>
 1010ef8:	3044      	adds	r0, #68	; 0x44
 1010efa:	d101      	bne.n	1010f00 <lll_scan_prepare+0x28>
}
 1010efc:	b002      	add	sp, #8
 1010efe:	bd10      	pop	{r4, pc}
	LL_ASSERT(!err || err == -EINPROGRESS);
 1010f00:	2170      	movs	r1, #112	; 0x70
 1010f02:	4808      	ldr	r0, [pc, #32]	; (1010f24 <lll_scan_prepare+0x4c>)
}
 1010f04:	b002      	add	sp, #8
 1010f06:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LL_ASSERT(!err || err == -EINPROGRESS);
 1010f0a:	f7f2 bbb9 	b.w	1003680 <bt_ctlr_assert_handle>
	LL_ASSERT(!err || err == -EINPROGRESS);
 1010f0e:	216d      	movs	r1, #109	; 0x6d
 1010f10:	4804      	ldr	r0, [pc, #16]	; (1010f24 <lll_scan_prepare+0x4c>)
 1010f12:	f7f2 fbb5 	bl	1003680 <bt_ctlr_assert_handle>
 1010f16:	e7e7      	b.n	1010ee8 <lll_scan_prepare+0x10>
 1010f18:	010109ed 	.word	0x010109ed
 1010f1c:	01010d2d 	.word	0x01010d2d
 1010f20:	01010d69 	.word	0x01010d69
 1010f24:	01018b6c 	.word	0x01018b6c

01010f28 <isr_race>:
}

static void isr_race(void *param)
{
	/* NOTE: lll_disable could have a race with ... */
	radio_status_reset();
 1010f28:	f001 b836 	b.w	1011f98 <radio_status_reset>

01010f2c <isr_cleanup>:
{
 1010f2c:	4601      	mov	r1, r0
 1010f2e:	b508      	push	{r3, lr}
	radio_isr_set(isr_race, param);
 1010f30:	480f      	ldr	r0, [pc, #60]	; (1010f70 <isr_cleanup+0x44>)
 1010f32:	f000 ff1d 	bl	1011d70 <radio_isr_set>
	if (!radio_is_idle()) {
 1010f36:	f001 f84f 	bl	1011fd8 <radio_is_idle>
 1010f3a:	b1a8      	cbz	r0, 1010f68 <isr_cleanup+0x3c>
	radio_tmr_stop();
 1010f3c:	f001 f9ce 	bl	10122dc <radio_tmr_stop>
	err = lll_hfclock_off();
 1010f40:	f7ff f93c 	bl	10101bc <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
 1010f44:	b108      	cbz	r0, 1010f4a <isr_cleanup+0x1e>
 1010f46:	3010      	adds	r0, #16
 1010f48:	d104      	bne.n	1010f54 <isr_cleanup+0x28>
}
 1010f4a:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
 1010f4e:	2000      	movs	r0, #0
 1010f50:	f7ff b85a 	b.w	1010008 <lll_done>
	LL_ASSERT(!err || err == -EBUSY);
 1010f54:	4807      	ldr	r0, [pc, #28]	; (1010f74 <isr_cleanup+0x48>)
 1010f56:	f240 219a 	movw	r1, #666	; 0x29a
 1010f5a:	f7f2 fb91 	bl	1003680 <bt_ctlr_assert_handle>
}
 1010f5e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
 1010f62:	2000      	movs	r0, #0
 1010f64:	f7ff b850 	b.w	1010008 <lll_done>
		radio_disable();
 1010f68:	f001 f800 	bl	1011f6c <radio_disable>
 1010f6c:	e7e6      	b.n	1010f3c <isr_cleanup+0x10>
 1010f6e:	bf00      	nop
 1010f70:	01010f29 	.word	0x01010f29
 1010f74:	01018bcc 	.word	0x01018bcc

01010f78 <isr_done>:
{
 1010f78:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1010f7a:	4606      	mov	r6, r0
	radio_status_reset();
 1010f7c:	f001 f80c 	bl	1011f98 <radio_status_reset>
	radio_tmr_status_reset();
 1010f80:	f001 f8e2 	bl	1012148 <radio_tmr_status_reset>
	radio_filter_status_reset();
 1010f84:	f001 f8c8 	bl	1012118 <radio_filter_status_reset>
	radio_ar_status_reset();
 1010f88:	f001 fb1c 	bl	10125c4 <radio_ar_status_reset>
	radio_rssi_status_reset();
 1010f8c:	f001 f88c 	bl	10120a8 <radio_rssi_status_reset>
	e = ull_event_done_extra_get();
 1010f90:	f7f9 fa92 	bl	100a4b8 <ull_event_done_extra_get>
	LL_ASSERT(e);
 1010f94:	4604      	mov	r4, r0
 1010f96:	2800      	cmp	r0, #0
 1010f98:	d033      	beq.n	1011002 <isr_done+0x8a>
	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
 1010f9a:	2201      	movs	r2, #1
	e->trx_cnt = trx_cnt;
 1010f9c:	4b1c      	ldr	r3, [pc, #112]	; (1011010 <isr_done+0x98>)
	e->crc_valid = crc_valid;
 1010f9e:	4d1d      	ldr	r5, [pc, #116]	; (1011014 <isr_done+0x9c>)
	e->mic_state = mic_state;
 1010fa0:	491d      	ldr	r1, [pc, #116]	; (1011018 <isr_done+0xa0>)
	e->trx_cnt = trx_cnt;
 1010fa2:	881b      	ldrh	r3, [r3, #0]
	e->crc_valid = crc_valid;
 1010fa4:	782d      	ldrb	r5, [r5, #0]
	e->mic_state = mic_state;
 1010fa6:	7809      	ldrb	r1, [r1, #0]
	e->trx_cnt = trx_cnt;
 1010fa8:	80a3      	strh	r3, [r4, #4]
	e->crc_valid = crc_valid;
 1010faa:	71a5      	strb	r5, [r4, #6]
	e->mic_state = mic_state;
 1010fac:	71e1      	strb	r1, [r4, #7]
	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
 1010fae:	7022      	strb	r2, [r4, #0]
	if (trx_cnt) {
 1010fb0:	b11b      	cbz	r3, 1010fba <isr_done+0x42>
		if (lll->role) {
 1010fb2:	f996 3021 	ldrsb.w	r3, [r6, #33]	; 0x21
 1010fb6:	2b00      	cmp	r3, #0
 1010fb8:	db04      	blt.n	1010fc4 <isr_done+0x4c>
	isr_cleanup(param);
 1010fba:	4630      	mov	r0, r6
}
 1010fbc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	isr_cleanup(param);
 1010fc0:	f7ff bfb4 	b.w	1010f2c <isr_cleanup>
				addr_us_get(lll->phy_rx);
 1010fc4:	f896 3049 	ldrb.w	r3, [r6, #73]	; 0x49
 1010fc8:	f003 0307 	and.w	r3, r3, #7
#define RANGE_DISTANCE 1000 /* meters */
#define RANGE_DELAY_US (2 * RANGE_DISTANCE * 4 / 1000)

static inline u32_t addr_us_get(u8_t phy)
{
	switch (phy) {
 1010fcc:	2b02      	cmp	r3, #2
 1010fce:	d016      	beq.n	1010ffe <isr_done+0x86>
	case BIT(0):
		return 40;
	case BIT(1):
		return 24;
	case BIT(2):
		return 376;
 1010fd0:	2b04      	cmp	r3, #4
 1010fd2:	bf14      	ite	ne
 1010fd4:	2728      	movne	r7, #40	; 0x28
 1010fd6:	f44f 77bc 	moveq.w	r7, #376	; 0x178
				radio_tmr_aa_restore() - radio_tmr_ready_get();
 1010fda:	f001 f9dd 	bl	1012398 <radio_tmr_aa_restore>
 1010fde:	4605      	mov	r5, r0
 1010fe0:	f001 f9e0 	bl	10123a4 <radio_tmr_ready_get>
			lll->slave.window_widening_event_us = 0;
 1010fe4:	2300      	movs	r3, #0
			e->slave.window_widening_event_us =
 1010fe6:	6b72      	ldr	r2, [r6, #52]	; 0x34
				radio_tmr_aa_restore() - radio_tmr_ready_get();
 1010fe8:	1a2d      	subs	r5, r5, r0
			e->slave.window_widening_event_us =
 1010fea:	e9c4 5202 	strd	r5, r2, [r4, #8]
			e->slave.preamble_to_addr_us = preamble_to_addr_us;
 1010fee:	6127      	str	r7, [r4, #16]
	isr_cleanup(param);
 1010ff0:	4630      	mov	r0, r6
			lll->slave.window_widening_event_us = 0;
 1010ff2:	6373      	str	r3, [r6, #52]	; 0x34
			lll->slave.window_size_event_us = 0;
 1010ff4:	63f3      	str	r3, [r6, #60]	; 0x3c
}
 1010ff6:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	isr_cleanup(param);
 1010ffa:	f7ff bf97 	b.w	1010f2c <isr_cleanup>
	switch (phy) {
 1010ffe:	2718      	movs	r7, #24
 1011000:	e7eb      	b.n	1010fda <isr_done+0x62>
	LL_ASSERT(e);
 1011002:	f240 2165 	movw	r1, #613	; 0x265
 1011006:	4805      	ldr	r0, [pc, #20]	; (101101c <isr_done+0xa4>)
 1011008:	f7f2 fb3a 	bl	1003680 <bt_ctlr_assert_handle>
 101100c:	e7c5      	b.n	1010f9a <isr_done+0x22>
 101100e:	bf00      	nop
 1011010:	2100805e 	.word	0x2100805e
 1011014:	210080cb 	.word	0x210080cb
 1011018:	210080cc 	.word	0x210080cc
 101101c:	01018bcc 	.word	0x01018bcc

01011020 <empty_tx_enqueue>:

	return 0;
}

static struct pdu_data *empty_tx_enqueue(struct lll_conn *lll)
{
 1011020:	b538      	push	{r3, r4, r5, lr}
	struct pdu_data *p;

	lll->empty = 1;
 1011022:	f890 3062 	ldrb.w	r3, [r0, #98]	; 0x62
{
 1011026:	4605      	mov	r5, r0
	lll->empty = 1;
 1011028:	f043 0304 	orr.w	r3, r3, #4
 101102c:	f880 3062 	strb.w	r3, [r0, #98]	; 0x62

	p = (void *)radio_pkt_empty_get();
 1011030:	f000 fff2 	bl	1012018 <radio_pkt_empty_get>
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
	p->len = 0;
 1011034:	2200      	movs	r2, #0
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
 1011036:	2101      	movs	r1, #1
 1011038:	7803      	ldrb	r3, [r0, #0]
	p->len = 0;
 101103a:	7042      	strb	r2, [r0, #1]
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
 101103c:	f361 0301 	bfi	r3, r1, #0, #2
	p = (void *)radio_pkt_empty_get();
 1011040:	4604      	mov	r4, r0
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
 1011042:	7003      	strb	r3, [r0, #0]
	if (memq_peek(lll->memq_tx.head, lll->memq_tx.tail, NULL)) {
 1011044:	e9d5 0113 	ldrd	r0, r1, [r5, #76]	; 0x4c
 1011048:	f7f4 fed2 	bl	1005df0 <memq_peek>
 101104c:	1e03      	subs	r3, r0, #0
 101104e:	bf18      	it	ne
 1011050:	2301      	movne	r3, #1
 1011052:	7822      	ldrb	r2, [r4, #0]
	} else {
		p->md = 0;
	}

	return p;
}
 1011054:	4620      	mov	r0, r4
 1011056:	f363 1204 	bfi	r2, r3, #4, #1
 101105a:	7022      	strb	r2, [r4, #0]
 101105c:	bd38      	pop	{r3, r4, r5, pc}
 101105e:	bf00      	nop

01011060 <lll_conn_init>:
}
 1011060:	2000      	movs	r0, #0
 1011062:	4770      	bx	lr

01011064 <lll_conn_reset>:
 1011064:	2000      	movs	r0, #0
 1011066:	4770      	bx	lr

01011068 <lll_conn_sca_local_get>:
}
 1011068:	2007      	movs	r0, #7
 101106a:	4770      	bx	lr

0101106c <lll_conn_ppm_local_get>:
}
 101106c:	2014      	movs	r0, #20
 101106e:	4770      	bx	lr

01011070 <lll_conn_ppm_get>:
	return sca_ppm_lut[sca];
 1011070:	4b01      	ldr	r3, [pc, #4]	; (1011078 <lll_conn_ppm_get+0x8>)
}
 1011072:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
 1011076:	4770      	bx	lr
 1011078:	01018c2c 	.word	0x01018c2c

0101107c <lll_conn_prepare_reset>:
	trx_cnt = 0U;
 101107c:	2300      	movs	r3, #0
	crc_expire = 0U;
 101107e:	4805      	ldr	r0, [pc, #20]	; (1011094 <lll_conn_prepare_reset+0x18>)
	crc_valid = 0U;
 1011080:	4905      	ldr	r1, [pc, #20]	; (1011098 <lll_conn_prepare_reset+0x1c>)
	mic_state = LLL_CONN_MIC_NONE;
 1011082:	4a06      	ldr	r2, [pc, #24]	; (101109c <lll_conn_prepare_reset+0x20>)
{
 1011084:	b410      	push	{r4}
	trx_cnt = 0U;
 1011086:	4c06      	ldr	r4, [pc, #24]	; (10110a0 <lll_conn_prepare_reset+0x24>)
	crc_expire = 0U;
 1011088:	7003      	strb	r3, [r0, #0]
	crc_valid = 0U;
 101108a:	700b      	strb	r3, [r1, #0]
	mic_state = LLL_CONN_MIC_NONE;
 101108c:	7013      	strb	r3, [r2, #0]
	trx_cnt = 0U;
 101108e:	8023      	strh	r3, [r4, #0]
}
 1011090:	bc10      	pop	{r4}
 1011092:	4770      	bx	lr
 1011094:	210080ca 	.word	0x210080ca
 1011098:	210080cb 	.word	0x210080cb
 101109c:	210080cc 	.word	0x210080cc
 10110a0:	2100805e 	.word	0x2100805e

010110a4 <lll_conn_is_abort_cb>:
}
 10110a4:	f06f 0047 	mvn.w	r0, #71	; 0x47
 10110a8:	4770      	bx	lr
 10110aa:	bf00      	nop

010110ac <lll_conn_abort_cb>:
{
 10110ac:	b510      	push	{r4, lr}
	if (!prepare_param) {
 10110ae:	b170      	cbz	r0, 10110ce <lll_conn_abort_cb+0x22>
	err = lll_hfclock_off();
 10110b0:	460c      	mov	r4, r1
 10110b2:	f7ff f883 	bl	10101bc <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
 10110b6:	b128      	cbz	r0, 10110c4 <lll_conn_abort_cb+0x18>
 10110b8:	3010      	adds	r0, #16
 10110ba:	d003      	beq.n	10110c4 <lll_conn_abort_cb+0x18>
 10110bc:	2182      	movs	r1, #130	; 0x82
 10110be:	4807      	ldr	r0, [pc, #28]	; (10110dc <lll_conn_abort_cb+0x30>)
 10110c0:	f7f2 fade 	bl	1003680 <bt_ctlr_assert_handle>
	lll_done(param);
 10110c4:	4620      	mov	r0, r4
}
 10110c6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
 10110ca:	f7fe bf9d 	b.w	1010008 <lll_done>
		radio_isr_set(isr_done, param);
 10110ce:	4804      	ldr	r0, [pc, #16]	; (10110e0 <lll_conn_abort_cb+0x34>)
 10110d0:	f000 fe4e 	bl	1011d70 <radio_isr_set>
}
 10110d4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_disable();
 10110d8:	f000 bf48 	b.w	1011f6c <radio_disable>
 10110dc:	01018bcc 	.word	0x01018bcc
 10110e0:	01010f79 	.word	0x01010f79

010110e4 <lll_conn_isr_abort>:
{
 10110e4:	b510      	push	{r4, lr}
 10110e6:	4604      	mov	r4, r0
	radio_status_reset();
 10110e8:	f000 ff56 	bl	1011f98 <radio_status_reset>
	radio_tmr_status_reset();
 10110ec:	f001 f82c 	bl	1012148 <radio_tmr_status_reset>
	radio_filter_status_reset();
 10110f0:	f001 f812 	bl	1012118 <radio_filter_status_reset>
	radio_ar_status_reset();
 10110f4:	f001 fa66 	bl	10125c4 <radio_ar_status_reset>
	radio_rssi_status_reset();
 10110f8:	f000 ffd6 	bl	10120a8 <radio_rssi_status_reset>
	isr_cleanup(param);
 10110fc:	4620      	mov	r0, r4
}
 10110fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
 1011102:	f7ff bf13 	b.w	1010f2c <isr_cleanup>
 1011106:	bf00      	nop

01011108 <lll_conn_rx_pkt_set>:
{
 1011108:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 101110a:	4605      	mov	r5, r0
	node_rx = ull_pdu_rx_alloc_peek(1);
 101110c:	2001      	movs	r0, #1
 101110e:	f7f9 f921 	bl	100a354 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
 1011112:	4606      	mov	r6, r0
 1011114:	b368      	cbz	r0, 1011172 <lll_conn_rx_pkt_set+0x6a>
	phy = lll->phy_rx;
 1011116:	f895 4049 	ldrb.w	r4, [r5, #73]	; 0x49
	radio_phy_set(phy, 0);
 101111a:	2100      	movs	r1, #0
	phy = lll->phy_rx;
 101111c:	f004 0407 	and.w	r4, r4, #7
	radio_phy_set(phy, 0);
 1011120:	4620      	mov	r0, r4
	max_rx_octets = lll->max_rx_octets;
 1011122:	f8b5 7042 	ldrh.w	r7, [r5, #66]	; 0x42
	radio_phy_set(phy, 0);
 1011126:	f000 fe67 	bl	1011df8 <radio_phy_set>
	} else if (lll->enc_rx) {
 101112a:	f895 3062 	ldrb.w	r3, [r5, #98]	; 0x62
 101112e:	071b      	lsls	r3, r3, #28
 1011130:	d512      	bpl.n	1011158 <lll_conn_rx_pkt_set+0x50>
		radio_pkt_configure(8, (max_rx_octets + 4), (phy << 1) | 0x01);
 1011132:	1d39      	adds	r1, r7, #4
 1011134:	0062      	lsls	r2, r4, #1
 1011136:	2008      	movs	r0, #8
 1011138:	b2c9      	uxtb	r1, r1
 101113a:	f042 0201 	orr.w	r2, r2, #1
 101113e:	f000 feab 	bl	1011e98 <radio_pkt_configure>
		radio_pkt_rx_set(radio_ccm_rx_pkt_set(&lll->ccm_rx, phy,
 1011142:	4621      	mov	r1, r4
 1011144:	f106 0220 	add.w	r2, r6, #32
 1011148:	f105 0063 	add.w	r0, r5, #99	; 0x63
 101114c:	f001 f952 	bl	10123f4 <radio_ccm_rx_pkt_set>
}
 1011150:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_rx_set(radio_ccm_rx_pkt_set(&lll->ccm_rx, phy,
 1011154:	f000 bed6 	b.w	1011f04 <radio_pkt_rx_set>
		radio_pkt_configure(8, max_rx_octets, (phy << 1) | 0x01);
 1011158:	0062      	lsls	r2, r4, #1
 101115a:	2008      	movs	r0, #8
 101115c:	b2f9      	uxtb	r1, r7
 101115e:	f042 0201 	orr.w	r2, r2, #1
 1011162:	f000 fe99 	bl	1011e98 <radio_pkt_configure>
		radio_pkt_rx_set(node_rx->pdu);
 1011166:	f106 0020 	add.w	r0, r6, #32
}
 101116a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_rx_set(node_rx->pdu);
 101116e:	f000 bec9 	b.w	1011f04 <radio_pkt_rx_set>
	LL_ASSERT(node_rx);
 1011172:	f240 11cf 	movw	r1, #463	; 0x1cf
 1011176:	4802      	ldr	r0, [pc, #8]	; (1011180 <lll_conn_rx_pkt_set+0x78>)
 1011178:	f7f2 fa82 	bl	1003680 <bt_ctlr_assert_handle>
 101117c:	e7cb      	b.n	1011116 <lll_conn_rx_pkt_set+0xe>
 101117e:	bf00      	nop
 1011180:	01018bcc 	.word	0x01018bcc

01011184 <lll_conn_isr_tx>:
{
 1011184:	b538      	push	{r3, r4, r5, lr}
 1011186:	4604      	mov	r4, r0
	radio_status_reset();
 1011188:	f000 ff06 	bl	1011f98 <radio_status_reset>
	radio_tmr_status_reset();
 101118c:	f000 ffdc 	bl	1012148 <radio_tmr_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
 1011190:	2096      	movs	r0, #150	; 0x96
 1011192:	f000 ffe9 	bl	1012168 <radio_tmr_tifs_set>
				     lll->phy_flags);
 1011196:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
	radio_switch_complete_and_tx(lll->phy_rx, 0,
 101119a:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
 101119e:	f3c2 03c0 	ubfx	r3, r2, #3, #1
 10111a2:	2100      	movs	r1, #0
 10111a4:	f002 0207 	and.w	r2, r2, #7
 10111a8:	f000 0007 	and.w	r0, r0, #7
 10111ac:	f000 ff4a 	bl	1012044 <radio_switch_complete_and_tx>
	lll_conn_rx_pkt_set(lll);
 10111b0:	4620      	mov	r0, r4
 10111b2:	f7ff ffa9 	bl	1011108 <lll_conn_rx_pkt_set>
	LL_ASSERT(!radio_is_ready());
 10111b6:	f000 fefb 	bl	1011fb0 <radio_is_ready>
 10111ba:	bba0      	cbnz	r0, 1011226 <lll_conn_isr_tx+0xa2>
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 +
 10111bc:	f001 f914 	bl	10123e8 <radio_tmr_tifs_base_get>
 10111c0:	4605      	mov	r5, r0
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
 10111c2:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
 10111c6:	2101      	movs	r1, #1
 10111c8:	f000 0007 	and.w	r0, r0, #7
 10111cc:	f000 feb4 	bl	1011f38 <radio_rx_chain_delay_get>
	hcto += addr_us_get(lll->phy_rx);
 10111d0:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
 10111d4:	4405      	add	r5, r0
	hcto += addr_us_get(lll->phy_rx);
 10111d6:	f003 0307 	and.w	r3, r3, #7
 10111da:	2b02      	cmp	r3, #2
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
 10111dc:	f105 05a3 	add.w	r5, r5, #163	; 0xa3
 10111e0:	d01f      	beq.n	1011222 <lll_conn_isr_tx+0x9e>
		return 376;
 10111e2:	2b04      	cmp	r3, #4
 10111e4:	bf14      	ite	ne
 10111e6:	2328      	movne	r3, #40	; 0x28
 10111e8:	f44f 73bc 	moveq.w	r3, #376	; 0x178
	hcto -= radio_tx_chain_delay_get(lll->phy_tx, lll->phy_flags);
 10111ec:	f894 0048 	ldrb.w	r0, [r4, #72]	; 0x48
	hcto += addr_us_get(lll->phy_rx);
 10111f0:	441d      	add	r5, r3
	hcto -= radio_tx_chain_delay_get(lll->phy_tx, lll->phy_flags);
 10111f2:	f3c0 01c0 	ubfx	r1, r0, #3, #1
 10111f6:	f000 0007 	and.w	r0, r0, #7
 10111fa:	f000 fe99 	bl	1011f30 <radio_tx_chain_delay_get>
	radio_tmr_hcto_configure(hcto);
 10111fe:	1a28      	subs	r0, r5, r0
 1011200:	f001 f880 	bl	1012304 <radio_tmr_hcto_configure>
	if (!trx_cnt && !lll->role) {
 1011204:	4b0b      	ldr	r3, [pc, #44]	; (1011234 <lll_conn_isr_tx+0xb0>)
 1011206:	881b      	ldrh	r3, [r3, #0]
 1011208:	b92b      	cbnz	r3, 1011216 <lll_conn_isr_tx+0x92>
 101120a:	f994 3021 	ldrsb.w	r3, [r4, #33]	; 0x21
 101120e:	2b00      	cmp	r3, #0
 1011210:	db01      	blt.n	1011216 <lll_conn_isr_tx+0x92>
		radio_rssi_measure();
 1011212:	f000 ff39 	bl	1012088 <radio_rssi_measure>
	radio_isr_set(lll_conn_isr_rx, param);
 1011216:	4621      	mov	r1, r4
}
 1011218:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	radio_isr_set(lll_conn_isr_rx, param);
 101121c:	4806      	ldr	r0, [pc, #24]	; (1011238 <lll_conn_isr_tx+0xb4>)
 101121e:	f000 bda7 	b.w	1011d70 <radio_isr_set>
	switch (phy) {
 1011222:	2318      	movs	r3, #24
 1011224:	e7e2      	b.n	10111ec <lll_conn_isr_tx+0x68>
	LL_ASSERT(!radio_is_ready());
 1011226:	f44f 71c5 	mov.w	r1, #394	; 0x18a
 101122a:	4804      	ldr	r0, [pc, #16]	; (101123c <lll_conn_isr_tx+0xb8>)
 101122c:	f7f2 fa28 	bl	1003680 <bt_ctlr_assert_handle>
 1011230:	e7c4      	b.n	10111bc <lll_conn_isr_tx+0x38>
 1011232:	bf00      	nop
 1011234:	2100805e 	.word	0x2100805e
 1011238:	01011345 	.word	0x01011345
 101123c:	01018bcc 	.word	0x01018bcc

01011240 <lll_conn_tx_pkt_set>:
{
 1011240:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1011242:	4604      	mov	r4, r0
	phy = lll->phy_tx;
 1011244:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
{
 1011248:	460e      	mov	r6, r1
	phy = lll->phy_tx;
 101124a:	f003 0507 	and.w	r5, r3, #7
	radio_phy_set(phy, flags);
 101124e:	f3c3 01c0 	ubfx	r1, r3, #3, #1
 1011252:	4628      	mov	r0, r5
	max_tx_octets = lll->max_tx_octets;
 1011254:	f8b4 7040 	ldrh.w	r7, [r4, #64]	; 0x40
	radio_phy_set(phy, flags);
 1011258:	f000 fdce 	bl	1011df8 <radio_phy_set>
	} else if (lll->enc_tx) {
 101125c:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
				    (phy << 1) | 0x01);
 1011260:	006a      	lsls	r2, r5, #1
	} else if (lll->enc_tx) {
 1011262:	06db      	lsls	r3, r3, #27
 1011264:	d50f      	bpl.n	1011286 <lll_conn_tx_pkt_set+0x46>
		radio_pkt_configure(8, (max_tx_octets + 4U),
 1011266:	1d39      	adds	r1, r7, #4
 1011268:	2008      	movs	r0, #8
 101126a:	f042 0201 	orr.w	r2, r2, #1
 101126e:	b2c9      	uxtb	r1, r1
 1011270:	f000 fe12 	bl	1011e98 <radio_pkt_configure>
		radio_pkt_tx_set(radio_ccm_tx_pkt_set(&lll->ccm_tx,
 1011274:	4631      	mov	r1, r6
 1011276:	f104 0084 	add.w	r0, r4, #132	; 0x84
 101127a:	f001 f911 	bl	10124a0 <radio_ccm_tx_pkt_set>
}
 101127e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_tx_set(radio_ccm_tx_pkt_set(&lll->ccm_tx,
 1011282:	f000 be45 	b.w	1011f10 <radio_pkt_tx_set>
		radio_pkt_configure(8, max_tx_octets, (phy << 1) | 0x01);
 1011286:	2008      	movs	r0, #8
 1011288:	b2f9      	uxtb	r1, r7
 101128a:	f042 0201 	orr.w	r2, r2, #1
 101128e:	f000 fe03 	bl	1011e98 <radio_pkt_configure>
		radio_pkt_tx_set(pdu_data_tx);
 1011292:	4630      	mov	r0, r6
}
 1011294:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_tx_set(pdu_data_tx);
 1011298:	f000 be3a 	b.w	1011f10 <radio_pkt_tx_set>

0101129c <lll_conn_pdu_tx_prep>:
{
 101129c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (lll->empty) {
 10112a0:	f890 3062 	ldrb.w	r3, [r0, #98]	; 0x62
{
 10112a4:	4688      	mov	r8, r1
	if (lll->empty) {
 10112a6:	075b      	lsls	r3, r3, #29
{
 10112a8:	b083      	sub	sp, #12
	if (lll->empty) {
 10112aa:	d43e      	bmi.n	101132a <lll_conn_pdu_tx_prep+0x8e>
	link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail, (void **)&tx);
 10112ac:	4604      	mov	r4, r0
 10112ae:	e9d0 0113 	ldrd	r0, r1, [r0, #76]	; 0x4c
 10112b2:	aa01      	add	r2, sp, #4
 10112b4:	f7f4 fd9c 	bl	1005df0 <memq_peek>
	if (!link) {
 10112b8:	4681      	mov	r9, r0
 10112ba:	2800      	cmp	r0, #0
 10112bc:	d03c      	beq.n	1011338 <lll_conn_pdu_tx_prep+0x9c>
		p = (void *)(tx->pdu + lll->packet_tx_head_offset);
 10112be:	9f01      	ldr	r7, [sp, #4]
 10112c0:	f894 6061 	ldrb.w	r6, [r4, #97]	; 0x61
		if (!lll->packet_tx_head_len) {
 10112c4:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
		p = (void *)(tx->pdu + lll->packet_tx_head_offset);
 10112c8:	3704      	adds	r7, #4
 10112ca:	19bd      	adds	r5, r7, r6
		if (!lll->packet_tx_head_len) {
 10112cc:	b913      	cbnz	r3, 10112d4 <lll_conn_pdu_tx_prep+0x38>
			lll->packet_tx_head_len = p->len;
 10112ce:	786b      	ldrb	r3, [r5, #1]
 10112d0:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
		if (lll->packet_tx_head_offset) {
 10112d4:	b126      	cbz	r6, 10112e0 <lll_conn_pdu_tx_prep+0x44>
			p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
 10112d6:	2101      	movs	r1, #1
 10112d8:	5dba      	ldrb	r2, [r7, r6]
 10112da:	f361 0201 	bfi	r2, r1, #0, #2
 10112de:	55ba      	strb	r2, [r7, r6]
		p->len = lll->packet_tx_head_len - lll->packet_tx_head_offset;
 10112e0:	1b9b      	subs	r3, r3, r6
 10112e2:	706b      	strb	r3, [r5, #1]
		p->md = 0;
 10112e4:	5dbb      	ldrb	r3, [r7, r6]
		max_tx_octets = ull_conn_lll_max_tx_octets_get(lll);
 10112e6:	4620      	mov	r0, r4
		p->md = 0;
 10112e8:	f36f 1304 	bfc	r3, #4, #1
 10112ec:	55bb      	strb	r3, [r7, r6]
		max_tx_octets = ull_conn_lll_max_tx_octets_get(lll);
 10112ee:	f7fc ff2d 	bl	100e14c <ull_conn_lll_max_tx_octets_get>
		if (p->len > max_tx_octets) {
 10112f2:	786b      	ldrb	r3, [r5, #1]
 10112f4:	4283      	cmp	r3, r0
 10112f6:	d904      	bls.n	1011302 <lll_conn_pdu_tx_prep+0x66>
			p->len = max_tx_octets;
 10112f8:	7068      	strb	r0, [r5, #1]
			p->md = 1;
 10112fa:	5dbb      	ldrb	r3, [r7, r6]
 10112fc:	f043 0310 	orr.w	r3, r3, #16
 1011300:	55bb      	strb	r3, [r7, r6]
		if (link->next != lll->memq_tx.tail) {
 1011302:	f8d9 2000 	ldr.w	r2, [r9]
 1011306:	6d23      	ldr	r3, [r4, #80]	; 0x50
 1011308:	429a      	cmp	r2, r3
 101130a:	d003      	beq.n	1011314 <lll_conn_pdu_tx_prep+0x78>
			p->md = 1;
 101130c:	5dbb      	ldrb	r3, [r7, r6]
 101130e:	f043 0310 	orr.w	r3, r3, #16
 1011312:	55bb      	strb	r3, [r7, r6]
	p->resv = 0U;
 1011314:	2200      	movs	r2, #0
	p->rfu = 0U;
 1011316:	782b      	ldrb	r3, [r5, #0]
	p->resv = 0U;
 1011318:	70aa      	strb	r2, [r5, #2]
	p->rfu = 0U;
 101131a:	f36f 1347 	bfc	r3, #5, #3
 101131e:	702b      	strb	r3, [r5, #0]
	*pdu_data_tx = p;
 1011320:	f8c8 5000 	str.w	r5, [r8]
}
 1011324:	b003      	add	sp, #12
 1011326:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		*pdu_data_tx = empty_tx_enqueue(lll);
 101132a:	f7ff fe79 	bl	1011020 <empty_tx_enqueue>
 101132e:	f8c8 0000 	str.w	r0, [r8]
}
 1011332:	b003      	add	sp, #12
 1011334:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		p = empty_tx_enqueue(lll);
 1011338:	4620      	mov	r0, r4
 101133a:	f7ff fe71 	bl	1011020 <empty_tx_enqueue>
 101133e:	4605      	mov	r5, r0
 1011340:	e7e8      	b.n	1011314 <lll_conn_pdu_tx_prep+0x78>
 1011342:	bf00      	nop

01011344 <lll_conn_isr_rx>:
{
 1011344:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1011348:	b083      	sub	sp, #12
 101134a:	4604      	mov	r4, r0
	trx_done = radio_is_done();
 101134c:	f000 fe3a 	bl	1011fc4 <radio_is_done>
	if (trx_done) {
 1011350:	f010 0fff 	tst.w	r0, #255	; 0xff
 1011354:	d10e      	bne.n	1011374 <lll_conn_isr_rx+0x30>
	radio_status_reset();
 1011356:	f000 fe1f 	bl	1011f98 <radio_status_reset>
	radio_tmr_status_reset();
 101135a:	f000 fef5 	bl	1012148 <radio_tmr_status_reset>
	radio_rssi_status_reset();
 101135e:	f000 fea3 	bl	10120a8 <radio_rssi_status_reset>
		radio_isr_set(isr_done, param);
 1011362:	4621      	mov	r1, r4
 1011364:	48b8      	ldr	r0, [pc, #736]	; (1011648 <lll_conn_isr_rx+0x304>)
 1011366:	f000 fd03 	bl	1011d70 <radio_isr_set>
		radio_disable();
 101136a:	f000 fdff 	bl	1011f6c <radio_disable>
}
 101136e:	b003      	add	sp, #12
 1011370:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		crc_ok = radio_crc_is_valid();
 1011374:	f000 fe46 	bl	1012004 <radio_crc_is_valid>
 1011378:	b2c5      	uxtb	r5, r0
		rssi_ready = radio_rssi_is_ready();
 101137a:	f000 fe9d 	bl	10120b8 <radio_rssi_is_ready>
 101137e:	fa5f f880 	uxtb.w	r8, r0
	radio_status_reset();
 1011382:	f000 fe09 	bl	1011f98 <radio_status_reset>
	radio_tmr_status_reset();
 1011386:	f000 fedf 	bl	1012148 <radio_tmr_status_reset>
	radio_rssi_status_reset();
 101138a:	f000 fe8d 	bl	10120a8 <radio_rssi_status_reset>
	node_rx = ull_pdu_rx_alloc_peek(1);
 101138e:	2001      	movs	r0, #1
	trx_cnt++;
 1011390:	4aae      	ldr	r2, [pc, #696]	; (101164c <lll_conn_isr_rx+0x308>)
 1011392:	8813      	ldrh	r3, [r2, #0]
 1011394:	4403      	add	r3, r0
 1011396:	8013      	strh	r3, [r2, #0]
	node_rx = ull_pdu_rx_alloc_peek(1);
 1011398:	f7f8 ffdc 	bl	100a354 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
 101139c:	4607      	mov	r7, r0
 101139e:	2800      	cmp	r0, #0
 10113a0:	f000 80c8 	beq.w	1011534 <lll_conn_isr_rx+0x1f0>
	if (crc_ok) {
 10113a4:	2d00      	cmp	r5, #0
 10113a6:	d15d      	bne.n	1011464 <lll_conn_isr_rx+0x120>
		if (crc_expire == 0U) {
 10113a8:	4aa9      	ldr	r2, [pc, #676]	; (1011650 <lll_conn_isr_rx+0x30c>)
 10113aa:	7816      	ldrb	r6, [r2, #0]
 10113ac:	2e00      	cmp	r6, #0
 10113ae:	f040 809b 	bne.w	10114e8 <lll_conn_isr_rx+0x1a4>
		crc_expire--;
 10113b2:	2301      	movs	r3, #1
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 10113b4:	4620      	mov	r0, r4
 10113b6:	a901      	add	r1, sp, #4
		crc_expire--;
 10113b8:	7013      	strb	r3, [r2, #0]
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 10113ba:	f7ff ff6f 	bl	101129c <lll_conn_pdu_tx_prep>
		radio_tmr_tifs_set(EVENT_IFS_US);
 10113be:	2096      	movs	r0, #150	; 0x96
 10113c0:	f000 fed2 	bl	1012168 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(lll->phy_rx);
 10113c4:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
 10113c8:	f000 0007 	and.w	r0, r0, #7
 10113cc:	f000 fe2c 	bl	1012028 <radio_switch_complete_and_rx>
		radio_isr_set(lll_conn_isr_tx, param);
 10113d0:	4621      	mov	r1, r4
 10113d2:	48a0      	ldr	r0, [pc, #640]	; (1011654 <lll_conn_isr_rx+0x310>)
 10113d4:	f000 fccc 	bl	1011d70 <radio_isr_set>
		radio_tmr_end_capture();
 10113d8:	f000 ffea 	bl	10123b0 <radio_tmr_end_capture>
	pdu_data_tx->sn = lll->sn;
 10113dc:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
 10113e0:	9901      	ldr	r1, [sp, #4]
	pdu_data_tx->nesn = lll->nesn;
 10113e2:	f3c2 0340 	ubfx	r3, r2, #1, #1
 10113e6:	7808      	ldrb	r0, [r1, #0]
	pdu_data_tx->sn = lll->sn;
 10113e8:	f3c2 0200 	ubfx	r2, r2, #0, #1
	pdu_data_tx->nesn = lll->nesn;
 10113ec:	009b      	lsls	r3, r3, #2
 10113ee:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 10113f2:	f020 020c 	bic.w	r2, r0, #12
 10113f6:	4313      	orrs	r3, r2
	lll_conn_tx_pkt_set(lll, pdu_data_tx);
 10113f8:	4620      	mov	r0, r4
	pdu_data_tx->nesn = lll->nesn;
 10113fa:	700b      	strb	r3, [r1, #0]
	lll_conn_tx_pkt_set(lll, pdu_data_tx);
 10113fc:	f7ff ff20 	bl	1011240 <lll_conn_tx_pkt_set>
	LL_ASSERT(!radio_is_ready());
 1011400:	f000 fdd6 	bl	1011fb0 <radio_is_ready>
 1011404:	2800      	cmp	r0, #0
 1011406:	f040 809f 	bne.w	1011548 <lll_conn_isr_rx+0x204>
	if (!radio_tmr_aa_restore()) {
 101140a:	f000 ffc5 	bl	1012398 <radio_tmr_aa_restore>
 101140e:	b1b0      	cbz	r0, 101143e <lll_conn_isr_rx+0xfa>
	if (tx_release) {
 1011410:	b1dd      	cbz	r5, 101144a <lll_conn_isr_rx+0x106>
		LL_ASSERT(lll->handle != 0xFFFF);
 1011412:	f64f 73ff 	movw	r3, #65535	; 0xffff
 1011416:	8a20      	ldrh	r0, [r4, #16]
 1011418:	4298      	cmp	r0, r3
 101141a:	f000 809b 	beq.w	1011554 <lll_conn_isr_rx+0x210>
		ull_conn_lll_ack_enqueue(lll->handle, tx_release);
 101141e:	4629      	mov	r1, r5
 1011420:	f7fc fcca 	bl	100ddb8 <ull_conn_lll_ack_enqueue>
	if (is_rx_enqueue) {
 1011424:	b99e      	cbnz	r6, 101144e <lll_conn_isr_rx+0x10a>
		ull_rx_sched();
 1011426:	f7f8 ffdb 	bl	100a3e0 <ull_rx_sched>
	if (rssi_ready) {
 101142a:	f1b8 0f00 	cmp.w	r8, #0
 101142e:	d09e      	beq.n	101136e <lll_conn_isr_rx+0x2a>
		u8_t rssi = radio_rssi_get();
 1011430:	f000 fe34 	bl	101209c <radio_rssi_get>
 1011434:	f884 00a5 	strb.w	r0, [r4, #165]	; 0xa5
}
 1011438:	b003      	add	sp, #12
 101143a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		radio_tmr_aa_save(radio_tmr_aa_get());
 101143e:	f000 ff9f 	bl	1012380 <radio_tmr_aa_get>
 1011442:	f000 ffa3 	bl	101238c <radio_tmr_aa_save>
	if (tx_release) {
 1011446:	2d00      	cmp	r5, #0
 1011448:	d1e3      	bne.n	1011412 <lll_conn_isr_rx+0xce>
	if (is_rx_enqueue) {
 101144a:	2e00      	cmp	r6, #0
 101144c:	d0ed      	beq.n	101142a <lll_conn_isr_rx+0xe6>
		ull_pdu_rx_alloc();
 101144e:	f7f8 ff9f 	bl	100a390 <ull_pdu_rx_alloc>
		node_rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 1011452:	2302      	movs	r3, #2
 1011454:	713b      	strb	r3, [r7, #4]
		node_rx->hdr.handle = lll->handle;
 1011456:	8a23      	ldrh	r3, [r4, #16]
		ull_rx_put(node_rx->hdr.link, node_rx);
 1011458:	4639      	mov	r1, r7
 101145a:	6838      	ldr	r0, [r7, #0]
		node_rx->hdr.handle = lll->handle;
 101145c:	80fb      	strh	r3, [r7, #6]
		ull_rx_put(node_rx->hdr.link, node_rx);
 101145e:	f7f8 ffaf 	bl	100a3c0 <ull_rx_put>
	if (is_ull_rx) {
 1011462:	e7e0      	b.n	1011426 <lll_conn_isr_rx+0xe2>
	if (pdu_data_rx->nesn != lll->sn) {
 1011464:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 1011468:	f897 2020 	ldrb.w	r2, [r7, #32]
 101146c:	f003 0101 	and.w	r1, r3, #1
 1011470:	f3c2 0080 	ubfx	r0, r2, #2, #1
 1011474:	4288      	cmp	r0, r1
 1011476:	d065      	beq.n	1011544 <lll_conn_isr_rx+0x200>
		if (lll->role) {
 1011478:	f994 0021 	ldrsb.w	r0, [r4, #33]	; 0x21
		lll->sn++;
 101147c:	f081 0101 	eor.w	r1, r1, #1
 1011480:	f361 0300 	bfi	r3, r1, #0, #1
		if (lll->role) {
 1011484:	2800      	cmp	r0, #0
		lll->sn++;
 1011486:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62
		if (lll->role) {
 101148a:	da05      	bge.n	1011498 <lll_conn_isr_rx+0x154>
			lll->slave.latency_enabled = 1;
 101148c:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 1011490:	f043 0301 	orr.w	r3, r3, #1
 1011494:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
		if (!lll->empty) {
 1011498:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 101149c:	075d      	lsls	r5, r3, #29
 101149e:	d560      	bpl.n	1011562 <lll_conn_isr_rx+0x21e>
	struct node_tx *tx_release = NULL;
 10114a0:	2500      	movs	r5, #0
			lll->empty = 0;
 10114a2:	f36f 0382 	bfc	r3, #2, #1
 10114a6:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62
		if (link) {
 10114aa:	b2db      	uxtb	r3, r3
	if ((pdu_data_rx->sn == lll->nesn) &&
 10114ac:	f3c2 02c0 	ubfx	r2, r2, #3, #1
 10114b0:	f3c3 0140 	ubfx	r1, r3, #1, #1
 10114b4:	428a      	cmp	r2, r1
 10114b6:	d07b      	beq.n	10115b0 <lll_conn_isr_rx+0x26c>
	u8_t is_rx_enqueue = 0U;
 10114b8:	2600      	movs	r6, #0
		crc_expire = 0U;
 10114ba:	f04f 0c00 	mov.w	ip, #0
		crc_valid = 1U;
 10114be:	2001      	movs	r0, #1
		crc_expire = 0U;
 10114c0:	4963      	ldr	r1, [pc, #396]	; (1011650 <lll_conn_isr_rx+0x30c>)
		crc_valid = 1U;
 10114c2:	4a65      	ldr	r2, [pc, #404]	; (1011658 <lll_conn_isr_rx+0x314>)
		crc_expire = 0U;
 10114c4:	f881 c000 	strb.w	ip, [r1]
		crc_valid = 1U;
 10114c8:	7010      	strb	r0, [r2, #0]
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 10114ca:	a901      	add	r1, sp, #4
 10114cc:	4620      	mov	r0, r4
	is_empty_pdu_tx_retry = lll->empty;
 10114ce:	f3c3 0980 	ubfx	r9, r3, #2, #1
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 10114d2:	f7ff fee3 	bl	101129c <lll_conn_pdu_tx_prep>
	is_done = is_crc_backoff || ((crc_ok) && (pdu_data_rx->md == 0) &&
 10114d6:	f897 3020 	ldrb.w	r3, [r7, #32]
 10114da:	06db      	lsls	r3, r3, #27
 10114dc:	f53f af6f 	bmi.w	10113be <lll_conn_isr_rx+0x7a>
				     (pdu_data_tx->len == 0));
 10114e0:	9b01      	ldr	r3, [sp, #4]
	is_done = is_crc_backoff || ((crc_ok) && (pdu_data_rx->md == 0) &&
 10114e2:	785b      	ldrb	r3, [r3, #1]
 10114e4:	b173      	cbz	r3, 1011504 <lll_conn_isr_rx+0x1c0>
 10114e6:	e76a      	b.n	10113be <lll_conn_isr_rx+0x7a>
	is_empty_pdu_tx_retry = lll->empty;
 10114e8:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
		crc_expire--;
 10114ec:	3e01      	subs	r6, #1
 10114ee:	b2f6      	uxtb	r6, r6
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 10114f0:	4620      	mov	r0, r4
 10114f2:	a901      	add	r1, sp, #4
		crc_expire--;
 10114f4:	7016      	strb	r6, [r2, #0]
	is_empty_pdu_tx_retry = lll->empty;
 10114f6:	f3c3 0980 	ubfx	r9, r3, #2, #1
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 10114fa:	f7ff fecf 	bl	101129c <lll_conn_pdu_tx_prep>
	is_done = is_crc_backoff || ((crc_ok) && (pdu_data_rx->md == 0) &&
 10114fe:	2e00      	cmp	r6, #0
 1011500:	f040 80df 	bne.w	10116c2 <lll_conn_isr_rx+0x37e>
		radio_isr_set(isr_done, param);
 1011504:	4621      	mov	r1, r4
 1011506:	4850      	ldr	r0, [pc, #320]	; (1011648 <lll_conn_isr_rx+0x304>)
 1011508:	f000 fc32 	bl	1011d70 <radio_isr_set>
		} else if (!lll->role) {
 101150c:	f994 3021 	ldrsb.w	r3, [r4, #33]	; 0x21
 1011510:	2b00      	cmp	r3, #0
 1011512:	da02      	bge.n	101151a <lll_conn_isr_rx+0x1d6>
			radio_switch_complete_and_disable();
 1011514:	f000 fda2 	bl	101205c <radio_switch_complete_and_disable>
 1011518:	e760      	b.n	10113dc <lll_conn_isr_rx+0x98>
			radio_disable();
 101151a:	f000 fd27 	bl	1011f6c <radio_disable>
			LL_ASSERT(!radio_is_ready());
 101151e:	f000 fd47 	bl	1011fb0 <radio_is_ready>
 1011522:	2800      	cmp	r0, #0
 1011524:	d157      	bne.n	10115d6 <lll_conn_isr_rx+0x292>
			lll->empty = is_empty_pdu_tx_retry;
 1011526:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 101152a:	f369 0382 	bfi	r3, r9, #2, #1
 101152e:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62
			goto lll_conn_isr_rx_exit;
 1011532:	e76a      	b.n	101140a <lll_conn_isr_rx+0xc6>
	LL_ASSERT(node_rx);
 1011534:	21b8      	movs	r1, #184	; 0xb8
 1011536:	4849      	ldr	r0, [pc, #292]	; (101165c <lll_conn_isr_rx+0x318>)
 1011538:	f7f2 f8a2 	bl	1003680 <bt_ctlr_assert_handle>
	if (crc_ok) {
 101153c:	2d00      	cmp	r5, #0
 101153e:	f43f af33 	beq.w	10113a8 <lll_conn_isr_rx+0x64>
 1011542:	e78f      	b.n	1011464 <lll_conn_isr_rx+0x120>
	struct node_tx *tx_release = NULL;
 1011544:	2500      	movs	r5, #0
 1011546:	e7b1      	b.n	10114ac <lll_conn_isr_rx+0x168>
	LL_ASSERT(!radio_is_ready());
 1011548:	f44f 7191 	mov.w	r1, #290	; 0x122
 101154c:	4843      	ldr	r0, [pc, #268]	; (101165c <lll_conn_isr_rx+0x318>)
 101154e:	f7f2 f897 	bl	1003680 <bt_ctlr_assert_handle>
 1011552:	e75a      	b.n	101140a <lll_conn_isr_rx+0xc6>
		LL_ASSERT(lll->handle != 0xFFFF);
 1011554:	4841      	ldr	r0, [pc, #260]	; (101165c <lll_conn_isr_rx+0x318>)
 1011556:	f240 112f 	movw	r1, #303	; 0x12f
 101155a:	f7f2 f891 	bl	1003680 <bt_ctlr_assert_handle>
 101155e:	8a20      	ldrh	r0, [r4, #16]
 1011560:	e75d      	b.n	101141e <lll_conn_isr_rx+0xda>
			link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail,
 1011562:	aa01      	add	r2, sp, #4
 1011564:	e9d4 0113 	ldrd	r0, r1, [r4, #76]	; 0x4c
 1011568:	f7f4 fc42 	bl	1005df0 <memq_peek>
		if (link) {
 101156c:	4606      	mov	r6, r0
 101156e:	2800      	cmp	r0, #0
 1011570:	d039      	beq.n	10115e6 <lll_conn_isr_rx+0x2a2>
					       lll->packet_tx_head_offset);
 1011572:	f894 2061 	ldrb.w	r2, [r4, #97]	; 0x61
			pdu_data_tx_len = pdu_data_tx->len;
 1011576:	9b01      	ldr	r3, [sp, #4]
 1011578:	4413      	add	r3, r2
 101157a:	7959      	ldrb	r1, [r3, #5]
			if (pdu_data_tx_len != 0U) {
 101157c:	b151      	cbz	r1, 1011594 <lll_conn_isr_rx+0x250>
				if (lll->enc_tx) {
 101157e:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 1011582:	06d8      	lsls	r0, r3, #27
 1011584:	d506      	bpl.n	1011594 <lll_conn_isr_rx+0x250>
					lll->ccm_tx.counter++;
 1011586:	e9d4 3025 	ldrd	r3, r0, [r4, #148]	; 0x94
 101158a:	3301      	adds	r3, #1
 101158c:	f140 0000 	adc.w	r0, r0, #0
 1011590:	e9c4 3025 	strd	r3, r0, [r4, #148]	; 0x94
			if (offset < lll->packet_tx_head_len) {
 1011594:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
			offset = lll->packet_tx_head_offset + pdu_data_tx_len;
 1011598:	440a      	add	r2, r1
 101159a:	b2d2      	uxtb	r2, r2
			if (offset < lll->packet_tx_head_len) {
 101159c:	429a      	cmp	r2, r3
 101159e:	d228      	bcs.n	10115f2 <lll_conn_isr_rx+0x2ae>
				lll->packet_tx_head_offset = offset;
 10115a0:	f884 2061 	strb.w	r2, [r4, #97]	; 0x61
	struct node_tx *tx_release = NULL;
 10115a4:	2500      	movs	r5, #0
 10115a6:	f897 2020 	ldrb.w	r2, [r7, #32]
 10115aa:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 10115ae:	e77d      	b.n	10114ac <lll_conn_isr_rx+0x168>
	    (ull_pdu_rx_alloc_peek(3) != 0)) {
 10115b0:	2003      	movs	r0, #3
 10115b2:	f7f8 fecf 	bl	100a354 <ull_pdu_rx_alloc_peek>
	if ((pdu_data_rx->sn == lll->nesn) &&
 10115b6:	b198      	cbz	r0, 10115e0 <lll_conn_isr_rx+0x29c>
		lll->nesn++;
 10115b8:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 10115bc:	f083 0302 	eor.w	r3, r3, #2
 10115c0:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62
		if (pdu_data_rx->len != 0) {
 10115c4:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 10115c8:	b153      	cbz	r3, 10115e0 <lll_conn_isr_rx+0x29c>
			if (lll->enc_rx) {
 10115ca:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 10115ce:	071a      	lsls	r2, r3, #28
 10115d0:	d421      	bmi.n	1011616 <lll_conn_isr_rx+0x2d2>
			*is_rx_enqueue = 1U;
 10115d2:	2601      	movs	r6, #1
 10115d4:	e771      	b.n	10114ba <lll_conn_isr_rx+0x176>
			LL_ASSERT(!radio_is_ready());
 10115d6:	21e8      	movs	r1, #232	; 0xe8
 10115d8:	4820      	ldr	r0, [pc, #128]	; (101165c <lll_conn_isr_rx+0x318>)
 10115da:	f7f2 f851 	bl	1003680 <bt_ctlr_assert_handle>
 10115de:	e7a2      	b.n	1011526 <lll_conn_isr_rx+0x1e2>
 10115e0:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 10115e4:	e768      	b.n	10114b8 <lll_conn_isr_rx+0x174>
	struct node_tx *tx_release = NULL;
 10115e6:	2500      	movs	r5, #0
 10115e8:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 10115ec:	f897 2020 	ldrb.w	r2, [r7, #32]
 10115f0:	e75c      	b.n	10114ac <lll_conn_isr_rx+0x168>
			} else if (offset == lll->packet_tx_head_len) {
 10115f2:	d1f8      	bne.n	10115e6 <lll_conn_isr_rx+0x2a2>
				lll->packet_tx_head_len = 0;
 10115f4:	2200      	movs	r2, #0
				memq_dequeue(lll->memq_tx.tail,
 10115f6:	6d20      	ldr	r0, [r4, #80]	; 0x50
				lll->packet_tx_head_len = 0;
 10115f8:	f8a4 2060 	strh.w	r2, [r4, #96]	; 0x60
				memq_dequeue(lll->memq_tx.tail,
 10115fc:	f104 014c 	add.w	r1, r4, #76	; 0x4c
 1011600:	f7f4 fbfe 	bl	1005e00 <memq_dequeue>
				link->next = tx->next; /* Indicates ctrl or data
 1011604:	9d01      	ldr	r5, [sp, #4]
 1011606:	f897 2020 	ldrb.w	r2, [r7, #32]
 101160a:	682b      	ldr	r3, [r5, #0]
 101160c:	6033      	str	r3, [r6, #0]
				tx->next = link;
 101160e:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 1011612:	602e      	str	r6, [r5, #0]
				*tx_release = tx;
 1011614:	e74a      	b.n	10114ac <lll_conn_isr_rx+0x168>
				done = radio_ccm_is_done();
 1011616:	f000 ff6b 	bl	10124f0 <radio_ccm_is_done>
				LL_ASSERT(done);
 101161a:	2800      	cmp	r0, #0
 101161c:	d04b      	beq.n	10116b6 <lll_conn_isr_rx+0x372>
				bool mic_failure = !radio_ccm_mic_is_valid();
 101161e:	f000 ff89 	bl	1012534 <radio_ccm_mic_is_valid>
				if (mic_failure &&
 1011622:	bbb0      	cbnz	r0, 1011692 <lll_conn_isr_rx+0x34e>
				    lll->ccm_rx.counter == 0 &&
 1011624:	f8d4 2073 	ldr.w	r2, [r4, #115]	; 0x73
 1011628:	f8d4 3077 	ldr.w	r3, [r4, #119]	; 0x77
				if (mic_failure &&
 101162c:	4313      	orrs	r3, r2
 101162e:	d105      	bne.n	101163c <lll_conn_isr_rx+0x2f8>
				    (pdu_data_rx->ll_id ==
 1011630:	f897 3020 	ldrb.w	r3, [r7, #32]
				    lll->ccm_rx.counter == 0 &&
 1011634:	f003 0303 	and.w	r3, r3, #3
 1011638:	2b03      	cmp	r3, #3
 101163a:	d013      	beq.n	1011664 <lll_conn_isr_rx+0x320>
					mic_state = LLL_CONN_MIC_FAIL;
 101163c:	2202      	movs	r2, #2
 101163e:	4b08      	ldr	r3, [pc, #32]	; (1011660 <lll_conn_isr_rx+0x31c>)
	u8_t is_rx_enqueue = 0U;
 1011640:	2600      	movs	r6, #0
					mic_state = LLL_CONN_MIC_FAIL;
 1011642:	701a      	strb	r2, [r3, #0]
		if (err) {
 1011644:	e6e1      	b.n	101140a <lll_conn_isr_rx+0xc6>
 1011646:	bf00      	nop
 1011648:	01010f79 	.word	0x01010f79
 101164c:	2100805e 	.word	0x2100805e
 1011650:	210080ca 	.word	0x210080ca
 1011654:	01011185 	.word	0x01011185
 1011658:	210080cb 	.word	0x210080cb
 101165c:	01018bcc 	.word	0x01018bcc
 1011660:	210080cc 	.word	0x210080cc
						radio_pkt_scratch_get();
 1011664:	f000 fcdc 	bl	1012020 <radio_pkt_scratch_get>
					if (ctrl_pdu_len_check(
 1011668:	7842      	ldrb	r2, [r0, #1]
						radio_pkt_scratch_get();
 101166a:	4601      	mov	r1, r0
					if (ctrl_pdu_len_check(
 101166c:	2a1b      	cmp	r2, #27
 101166e:	d8e5      	bhi.n	101163c <lll_conn_isr_rx+0x2f8>
						memcpy(pdu_data_rx,
 1011670:	3203      	adds	r2, #3
 1011672:	f107 0020 	add.w	r0, r7, #32
 1011676:	f005 f9cf 	bl	1016a18 <memcpy>
						lll->ccm_rx.counter--;
 101167a:	f8d4 3073 	ldr.w	r3, [r4, #115]	; 0x73
 101167e:	f8d4 2077 	ldr.w	r2, [r4, #119]	; 0x77
 1011682:	f113 33ff 	adds.w	r3, r3, #4294967295
 1011686:	f142 32ff 	adc.w	r2, r2, #4294967295
 101168a:	f8c4 3073 	str.w	r3, [r4, #115]	; 0x73
 101168e:	f8c4 2077 	str.w	r2, [r4, #119]	; 0x77
				mic_state = LLL_CONN_MIC_PASS;
 1011692:	2601      	movs	r6, #1
				lll->ccm_rx.counter++;
 1011694:	f8d4 3073 	ldr.w	r3, [r4, #115]	; 0x73
 1011698:	f8d4 2077 	ldr.w	r2, [r4, #119]	; 0x77
 101169c:	199b      	adds	r3, r3, r6
				mic_state = LLL_CONN_MIC_PASS;
 101169e:	490a      	ldr	r1, [pc, #40]	; (10116c8 <lll_conn_isr_rx+0x384>)
						lll->ccm_rx.counter--;
 10116a0:	f104 0073 	add.w	r0, r4, #115	; 0x73
				lll->ccm_rx.counter++;
 10116a4:	f142 0200 	adc.w	r2, r2, #0
 10116a8:	f8c4 3073 	str.w	r3, [r4, #115]	; 0x73
 10116ac:	6042      	str	r2, [r0, #4]
				mic_state = LLL_CONN_MIC_PASS;
 10116ae:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 10116b2:	700e      	strb	r6, [r1, #0]
		if (err) {
 10116b4:	e701      	b.n	10114ba <lll_conn_isr_rx+0x176>
				LL_ASSERT(done);
 10116b6:	f240 310d 	movw	r1, #781	; 0x30d
 10116ba:	4804      	ldr	r0, [pc, #16]	; (10116cc <lll_conn_isr_rx+0x388>)
 10116bc:	f7f1 ffe0 	bl	1003680 <bt_ctlr_assert_handle>
 10116c0:	e7ad      	b.n	101161e <lll_conn_isr_rx+0x2da>
	u8_t is_rx_enqueue = 0U;
 10116c2:	462e      	mov	r6, r5
 10116c4:	e67b      	b.n	10113be <lll_conn_isr_rx+0x7a>
 10116c6:	bf00      	nop
 10116c8:	210080cc 	.word	0x210080cc
 10116cc:	01018bcc 	.word	0x01018bcc

010116d0 <lll_conn_flush>:

void lll_conn_flush(u16_t handle, struct lll_conn *lll)
{
	/* Nothing to be flushed */
}
 10116d0:	4770      	bx	lr
 10116d2:	bf00      	nop

010116d4 <prepare_cb>:
{
	return 0;
}

static int prepare_cb(struct lll_prepare_param *prepare_param)
{
 10116d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 10116d8:	b082      	sub	sp, #8
	struct lll_conn *lll = prepare_param->param;
 10116da:	68c4      	ldr	r4, [r0, #12]
{
 10116dc:	4680      	mov	r8, r0
	u32_t hcto;

	DEBUG_RADIO_START_S(1);

	/* Reset connection event global variables */
	lll_conn_prepare_reset();
 10116de:	f7ff fccd 	bl	101107c <lll_conn_prepare_reset>

	/* Update event counter to next value */
	lll->event_counter = lll->event_counter + lll->latency_prepare;

	/* Reset accumulated latencies */
	lll->latency_prepare = 0;
 10116e2:	2100      	movs	r1, #0
	lll->latency_event = lll->latency_prepare - 1;
 10116e4:	8ae3      	ldrh	r3, [r4, #22]
	event_counter = lll->event_counter + lll->latency_event;
 10116e6:	8b60      	ldrh	r0, [r4, #26]
	lll->latency_event = lll->latency_prepare - 1;
 10116e8:	1e5a      	subs	r2, r3, #1
	lll->event_counter = lll->event_counter + lll->latency_prepare;
 10116ea:	4403      	add	r3, r0
 10116ec:	8363      	strh	r3, [r4, #26]

	if (lll->data_chan_sel) {
 10116ee:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
	lll->latency_event = lll->latency_prepare - 1;
 10116f2:	b292      	uxth	r2, r2
	lll->latency_prepare = 0;
 10116f4:	82e1      	strh	r1, [r4, #22]
	if (lll->data_chan_sel) {
 10116f6:	0659      	lsls	r1, r3, #25
	lll->latency_event = lll->latency_prepare - 1;
 10116f8:	8322      	strh	r2, [r4, #24]
	if (lll->data_chan_sel) {
 10116fa:	f140 808e 	bpl.w	101181a <prepare_cb+0x146>
	event_counter = lll->event_counter + lll->latency_event;
 10116fe:	4410      	add	r0, r2
#if defined(CONFIG_BT_CTLR_CHAN_SEL_2)
		data_chan_use = lll_chan_sel_2(event_counter, lll->data_chan_id,
 1011700:	8c61      	ldrh	r1, [r4, #34]	; 0x22
 1011702:	b280      	uxth	r0, r0
 1011704:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 1011708:	f104 021c 	add.w	r2, r4, #28
 101170c:	f7f8 ff50 	bl	100a5b0 <lll_chan_sel_2>
 1011710:	4606      	mov	r6, r0
					       &lll->data_chan_map[0],
					       lll->data_chan_count);
	}

	/* current window widening */
	lll->slave.window_widening_event_us +=
 1011712:	e9d4 120c 	ldrd	r1, r2, [r4, #48]	; 0x30
		lll->slave.window_widening_prepare_us;
	lll->slave.window_widening_prepare_us = 0;
	if (lll->slave.window_widening_event_us >
	    lll->slave.window_widening_max_us) {
 1011716:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	lll->slave.window_widening_event_us +=
 1011718:	440a      	add	r2, r1
		lll->slave.window_widening_event_us =
 101171a:	429a      	cmp	r2, r3
 101171c:	bf28      	it	cs
 101171e:	461a      	movcs	r2, r3
			lll->slave.window_widening_max_us;
	}

	/* current window size */
	lll->slave.window_size_event_us +=
 1011720:	e9d4 130e 	ldrd	r1, r3, [r4, #56]	; 0x38
	lll->slave.window_widening_prepare_us = 0;
 1011724:	2500      	movs	r5, #0
	lll->slave.window_size_event_us +=
 1011726:	440b      	add	r3, r1
		lll->slave.window_widening_event_us =
 1011728:	6362      	str	r2, [r4, #52]	; 0x34
	lll->slave.window_size_event_us +=
 101172a:	63e3      	str	r3, [r4, #60]	; 0x3c
	lll->slave.window_widening_prepare_us = 0;
 101172c:	6325      	str	r5, [r4, #48]	; 0x30
		lll->slave.window_size_prepare_us;
	lll->slave.window_size_prepare_us = 0;
 101172e:	63a5      	str	r5, [r4, #56]	; 0x38

	/* Start setting up Radio h/w */
	radio_reset();
 1011730:	f000 fb3e 	bl	1011db0 <radio_reset>
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	radio_tx_power_set(lll->tx_pwr_lvl);
#else
	radio_tx_power_set(RADIO_TXP_DEFAULT);
 1011734:	4628      	mov	r0, r5
 1011736:	f000 fb77 	bl	1011e28 <radio_tx_power_set>
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */

	lll_conn_rx_pkt_set(lll);
 101173a:	4620      	mov	r0, r4
 101173c:	f7ff fce4 	bl	1011108 <lll_conn_rx_pkt_set>

	radio_aa_set(lll->access_addr);
 1011740:	f104 0008 	add.w	r0, r4, #8
 1011744:	f000 fb8e 	bl	1011e64 <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
			    (((u32_t)lll->crc_init[2] << 16) |
			     ((u32_t)lll->crc_init[1] << 8) |
 1011748:	7b63      	ldrb	r3, [r4, #13]
			    (((u32_t)lll->crc_init[2] << 16) |
 101174a:	7ba2      	ldrb	r2, [r4, #14]
			     ((u32_t)lll->crc_init[0])));
 101174c:	7b21      	ldrb	r1, [r4, #12]
			     ((u32_t)lll->crc_init[1] << 8) |
 101174e:	021b      	lsls	r3, r3, #8
			    (((u32_t)lll->crc_init[2] << 16) |
 1011750:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
 1011754:	4319      	orrs	r1, r3
 1011756:	f240 605b 	movw	r0, #1627	; 0x65b
 101175a:	f000 fc47 	bl	1011fec <radio_crc_configure>

	lll_chan_set(data_chan_use);
 101175e:	4630      	mov	r0, r6
 1011760:	f7fe fcaa 	bl	10100b8 <lll_chan_set>

	radio_isr_set(lll_conn_isr_rx, lll);
 1011764:	4621      	mov	r1, r4
 1011766:	483d      	ldr	r0, [pc, #244]	; (101185c <prepare_cb+0x188>)
 1011768:	f000 fb02 	bl	1011d70 <radio_isr_set>

	radio_tmr_tifs_set(EVENT_IFS_US);
 101176c:	2096      	movs	r0, #150	; 0x96
 101176e:	f000 fcfb 	bl	1012168 <radio_tmr_tifs_set>

#if defined(CONFIG_BT_CTLR_PHY)
	radio_switch_complete_and_tx(lll->phy_rx, 0, lll->phy_tx,
				     lll->phy_flags);
 1011772:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
	radio_switch_complete_and_tx(lll->phy_rx, 0, lll->phy_tx,
 1011776:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
 101177a:	f3c2 03c0 	ubfx	r3, r2, #3, #1
 101177e:	4629      	mov	r1, r5
 1011780:	f002 0207 	and.w	r2, r2, #7
 1011784:	f000 0007 	and.w	r0, r0, #7
 1011788:	f000 fc5c 	bl	1012044 <radio_switch_complete_and_tx>
#else /* !CONFIG_BT_CTLR_PHY */
	radio_switch_complete_and_tx(0, 0, 0, 0);
#endif /* !CONFIG_BT_CTLR_PHY */

	ticks_at_event = prepare_param->ticks_at_expire;
	evt = HDR_LLL2EVT(lll);
 101178c:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = prepare_param->ticks_at_expire;
 101178e:	f8d8 6000 	ldr.w	r6, [r8]
	ticks_at_event += lll_evt_offset_get(evt);
 1011792:	4638      	mov	r0, r7
 1011794:	f7fe fc74 	bl	1010080 <lll_evt_offset_get>
 1011798:	4406      	add	r6, r0

	ticks_at_start = ticks_at_event;
	ticks_at_start += HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US);

	remainder = prepare_param->remainder;
	remainder_us = radio_tmr_start(0, ticks_at_start, remainder);
 101179a:	f8d8 2004 	ldr.w	r2, [r8, #4]
 101179e:	f106 0109 	add.w	r1, r6, #9
 10117a2:	4628      	mov	r0, r5
 10117a4:	f000 fcec 	bl	1012180 <radio_tmr_start>
 10117a8:	4680      	mov	r8, r0

	radio_tmr_aa_capture();
 10117aa:	f000 fdcb 	bl	1012344 <radio_tmr_aa_capture>
	radio_tmr_aa_save(0);
 10117ae:	4628      	mov	r0, r5
 10117b0:	f000 fdec 	bl	101238c <radio_tmr_aa_save>

	hcto = remainder_us + EVENT_JITTER_US + (EVENT_JITTER_US << 2) +
 10117b4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	       (lll->slave.window_widening_event_us << 1) +
	       lll->slave.window_size_event_us;

#if defined(CONFIG_BT_CTLR_PHY)
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
 10117b6:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
	       (lll->slave.window_widening_event_us << 1) +
 10117ba:	6b62      	ldr	r2, [r4, #52]	; 0x34
	hcto = remainder_us + EVENT_JITTER_US + (EVENT_JITTER_US << 2) +
 10117bc:	f103 0550 	add.w	r5, r3, #80	; 0x50
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
 10117c0:	2101      	movs	r1, #1
 10117c2:	f000 0007 	and.w	r0, r0, #7
	hcto = remainder_us + EVENT_JITTER_US + (EVENT_JITTER_US << 2) +
 10117c6:	eb05 0542 	add.w	r5, r5, r2, lsl #1
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
 10117ca:	f000 fbb3 	bl	1011f34 <radio_rx_ready_delay_get>
	hcto += addr_us_get(lll->phy_rx);
 10117ce:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
	hcto = remainder_us + EVENT_JITTER_US + (EVENT_JITTER_US << 2) +
 10117d2:	4445      	add	r5, r8
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
 10117d4:	4405      	add	r5, r0
	hcto += addr_us_get(lll->phy_rx);
 10117d6:	f003 0007 	and.w	r0, r3, #7
 10117da:	2802      	cmp	r0, #2
 10117dc:	d034      	beq.n	1011848 <prepare_cb+0x174>
		return 40;
 10117de:	2804      	cmp	r0, #4
 10117e0:	bf0c      	ite	eq
 10117e2:	f44f 73bc 	moveq.w	r3, #376	; 0x178
 10117e6:	2328      	movne	r3, #40	; 0x28
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
 10117e8:	2101      	movs	r1, #1
	hcto += addr_us_get(lll->phy_rx);
 10117ea:	441d      	add	r5, r3
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
 10117ec:	f000 fba4 	bl	1011f38 <radio_rx_chain_delay_get>
	hcto += radio_rx_ready_delay_get(0, 0);
	hcto += addr_us_get(0);
	hcto += radio_rx_chain_delay_get(0, 0);
#endif /* !CONFIG_BT_CTLR_PHY */

	radio_tmr_hcto_configure(hcto);
 10117f0:	4428      	add	r0, r5
 10117f2:	f000 fd87 	bl	1012304 <radio_tmr_hcto_configure>
	defined(CONFIG_BT_CTLR_GPIO_PA_PIN)
	radio_tmr_end_capture();
#endif /* CONFIG_BT_CTLR_PROFILE_ISR */

#if defined(CONFIG_BT_CTLR_CONN_RSSI)
	radio_rssi_measure();
 10117f6:	f000 fc47 	bl	1012088 <radio_rssi_measure>
#endif /* CONFIG_BT_CTLR_CONN_RSSI */

#if defined(CONFIG_BT_CTLR_XTAL_ADVANCED) && \
	(EVENT_OVERHEAD_PREEMPT_US <= EVENT_OVERHEAD_PREEMPT_MIN_US)
	/* check if preempt to start has changed */
	if (lll_preempt_calc(evt, (TICKER_ID_CONN_BASE + lll->handle),
 10117fa:	7c21      	ldrb	r1, [r4, #16]
 10117fc:	4632      	mov	r2, r6
 10117fe:	3105      	adds	r1, #5
 1011800:	4638      	mov	r0, r7
 1011802:	b2c9      	uxtb	r1, r1
 1011804:	f7fe fc46 	bl	1010094 <lll_preempt_calc>
 1011808:	b9a0      	cbnz	r0, 1011834 <prepare_cb+0x160>
	} else
#endif /* CONFIG_BT_CTLR_XTAL_ADVANCED */
	{
		u32_t ret;

		ret = lll_prepare_done(lll);
 101180a:	4620      	mov	r0, r4
 101180c:	f7fe fbfa 	bl	1010004 <lll_prepare_done>
		LL_ASSERT(!ret);
 1011810:	b9e0      	cbnz	r0, 101184c <prepare_cb+0x178>
	}

	DEBUG_RADIO_START_S(1);

	return 0;
}
 1011812:	2000      	movs	r0, #0
 1011814:	b002      	add	sp, #8
 1011816:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		data_chan_use = lll_chan_sel_1(&lll->data_chan_use,
 101181a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 101181e:	f894 1022 	ldrb.w	r1, [r4, #34]	; 0x22
 1011822:	f104 0023 	add.w	r0, r4, #35	; 0x23
 1011826:	9300      	str	r3, [sp, #0]
 1011828:	f104 031c 	add.w	r3, r4, #28
 101182c:	f7f8 fe84 	bl	100a538 <lll_chan_sel_1>
 1011830:	4606      	mov	r6, r0
 1011832:	e76e      	b.n	1011712 <prepare_cb+0x3e>
		radio_isr_set(lll_conn_isr_abort, lll);
 1011834:	4621      	mov	r1, r4
 1011836:	480a      	ldr	r0, [pc, #40]	; (1011860 <prepare_cb+0x18c>)
 1011838:	f000 fa9a 	bl	1011d70 <radio_isr_set>
		radio_disable();
 101183c:	f000 fb96 	bl	1011f6c <radio_disable>
}
 1011840:	2000      	movs	r0, #0
 1011842:	b002      	add	sp, #8
 1011844:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (phy) {
 1011848:	2318      	movs	r3, #24
 101184a:	e7cd      	b.n	10117e8 <prepare_cb+0x114>
		LL_ASSERT(!ret);
 101184c:	21fe      	movs	r1, #254	; 0xfe
 101184e:	4805      	ldr	r0, [pc, #20]	; (1011864 <prepare_cb+0x190>)
 1011850:	f7f1 ff16 	bl	1003680 <bt_ctlr_assert_handle>
}
 1011854:	2000      	movs	r0, #0
 1011856:	b002      	add	sp, #8
 1011858:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 101185c:	01011345 	.word	0x01011345
 1011860:	010110e5 	.word	0x010110e5
 1011864:	01018c3c 	.word	0x01018c3c

01011868 <lll_slave_prepare>:
{
 1011868:	b530      	push	{r4, r5, lr}
 101186a:	b083      	sub	sp, #12
 101186c:	4605      	mov	r5, r0
	struct lll_conn *lll = p->param;
 101186e:	68c4      	ldr	r4, [r0, #12]
	err = lll_hfclock_on();
 1011870:	f7fe fc9c 	bl	10101ac <lll_hfclock_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
 1011874:	b108      	cbz	r0, 101187a <lll_slave_prepare+0x12>
 1011876:	3044      	adds	r0, #68	; 0x44
 1011878:	d121      	bne.n	10118be <lll_slave_prepare+0x56>
	elapsed = p->lazy + 1;
 101187a:	892b      	ldrh	r3, [r5, #8]
	    lll->slave.window_widening_periodic_us * elapsed;
 101187c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
	lll->slave.window_widening_prepare_us +=
 101187e:	6b21      	ldr	r1, [r4, #48]	; 0x30
	elapsed = p->lazy + 1;
 1011880:	3301      	adds	r3, #1
 1011882:	b29b      	uxth	r3, r3
	lll->slave.window_widening_prepare_us +=
 1011884:	fb02 1103 	mla	r1, r2, r3, r1
	    lll->slave.window_widening_max_us) {
 1011888:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
	lll->latency_prepare += elapsed;
 101188a:	8ae0      	ldrh	r0, [r4, #22]
		lll->slave.window_widening_prepare_us =
 101188c:	428a      	cmp	r2, r1
 101188e:	bf28      	it	cs
 1011890:	460a      	movcs	r2, r1
	lll->latency_prepare += elapsed;
 1011892:	4403      	add	r3, r0
		lll->slave.window_widening_prepare_us =
 1011894:	6322      	str	r2, [r4, #48]	; 0x30
	lll->latency_prepare += elapsed;
 1011896:	82e3      	strh	r3, [r4, #22]
	err = lll_prepare(lll_conn_is_abort_cb, lll_conn_abort_cb, prepare_cb,
 1011898:	4a0b      	ldr	r2, [pc, #44]	; (10118c8 <lll_slave_prepare+0x60>)
 101189a:	2300      	movs	r3, #0
 101189c:	490b      	ldr	r1, [pc, #44]	; (10118cc <lll_slave_prepare+0x64>)
 101189e:	480c      	ldr	r0, [pc, #48]	; (10118d0 <lll_slave_prepare+0x68>)
 10118a0:	9500      	str	r5, [sp, #0]
 10118a2:	f7fe fb3b 	bl	100ff1c <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
 10118a6:	b108      	cbz	r0, 10118ac <lll_slave_prepare+0x44>
 10118a8:	3044      	adds	r0, #68	; 0x44
 10118aa:	d101      	bne.n	10118b0 <lll_slave_prepare+0x48>
}
 10118ac:	b003      	add	sp, #12
 10118ae:	bd30      	pop	{r4, r5, pc}
	LL_ASSERT(!err || err == -EINPROGRESS);
 10118b0:	215c      	movs	r1, #92	; 0x5c
 10118b2:	4808      	ldr	r0, [pc, #32]	; (10118d4 <lll_slave_prepare+0x6c>)
}
 10118b4:	b003      	add	sp, #12
 10118b6:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	LL_ASSERT(!err || err == -EINPROGRESS);
 10118ba:	f7f1 bee1 	b.w	1003680 <bt_ctlr_assert_handle>
	LL_ASSERT(!err || err == -EINPROGRESS);
 10118be:	2148      	movs	r1, #72	; 0x48
 10118c0:	4804      	ldr	r0, [pc, #16]	; (10118d4 <lll_slave_prepare+0x6c>)
 10118c2:	f7f1 fedd 	bl	1003680 <bt_ctlr_assert_handle>
 10118c6:	e7d8      	b.n	101187a <lll_slave_prepare+0x12>
 10118c8:	010116d5 	.word	0x010116d5
 10118cc:	010110ad 	.word	0x010110ad
 10118d0:	010110a5 	.word	0x010110a5
 10118d4:	01018c3c 	.word	0x01018c3c

010118d8 <prepare_cb>:
{
	return 0;
}

static int prepare_cb(struct lll_prepare_param *prepare_param)
{
 10118d8:	b5f0      	push	{r4, r5, r6, r7, lr}
 10118da:	b085      	sub	sp, #20
	struct lll_conn *lll = prepare_param->param;
 10118dc:	68c4      	ldr	r4, [r0, #12]
{
 10118de:	4605      	mov	r5, r0
	u32_t remainder;

	DEBUG_RADIO_START_M(1);

	/* Reset connection event global variables */
	lll_conn_prepare_reset();
 10118e0:	f7ff fbcc 	bl	101107c <lll_conn_prepare_reset>

	/* Update event counter to next value */
	lll->event_counter = lll->event_counter + lll->latency_prepare;

	/* Reset accumulated latencies */
	lll->latency_prepare = 0;
 10118e4:	2100      	movs	r1, #0
	lll->latency_event = lll->latency_prepare - 1;
 10118e6:	8ae3      	ldrh	r3, [r4, #22]
	event_counter = lll->event_counter + lll->latency_event;
 10118e8:	8b60      	ldrh	r0, [r4, #26]
	lll->latency_event = lll->latency_prepare - 1;
 10118ea:	1e5a      	subs	r2, r3, #1
	lll->event_counter = lll->event_counter + lll->latency_prepare;
 10118ec:	4403      	add	r3, r0
 10118ee:	8363      	strh	r3, [r4, #26]

	if (lll->data_chan_sel) {
 10118f0:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
	lll->latency_event = lll->latency_prepare - 1;
 10118f4:	b292      	uxth	r2, r2
	lll->latency_prepare = 0;
 10118f6:	82e1      	strh	r1, [r4, #22]
	if (lll->data_chan_sel) {
 10118f8:	0659      	lsls	r1, r3, #25
	lll->latency_event = lll->latency_prepare - 1;
 10118fa:	8322      	strh	r2, [r4, #24]
	if (lll->data_chan_sel) {
 10118fc:	d563      	bpl.n	10119c6 <prepare_cb+0xee>
	event_counter = lll->event_counter + lll->latency_event;
 10118fe:	4410      	add	r0, r2
#if defined(CONFIG_BT_CTLR_CHAN_SEL_2)
		data_chan_use = lll_chan_sel_2(event_counter, lll->data_chan_id,
 1011900:	8c61      	ldrh	r1, [r4, #34]	; 0x22
 1011902:	b280      	uxth	r0, r0
 1011904:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 1011908:	f104 021c 	add.w	r2, r4, #28
 101190c:	f7f8 fe50 	bl	100a5b0 <lll_chan_sel_2>
 1011910:	4606      	mov	r6, r0
					       &lll->data_chan_map[0],
					       lll->data_chan_count);
	}

	/* Prepare the Tx PDU */
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 1011912:	4620      	mov	r0, r4
 1011914:	a903      	add	r1, sp, #12
 1011916:	f7ff fcc1 	bl	101129c <lll_conn_pdu_tx_prep>
	pdu_data_tx->sn = lll->sn;
 101191a:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
 101191e:	9803      	ldr	r0, [sp, #12]
	pdu_data_tx->nesn = lll->nesn;
 1011920:	f3c2 0340 	ubfx	r3, r2, #1, #1
 1011924:	7801      	ldrb	r1, [r0, #0]
	pdu_data_tx->sn = lll->sn;
 1011926:	f3c2 0200 	ubfx	r2, r2, #0, #1
	pdu_data_tx->nesn = lll->nesn;
 101192a:	009b      	lsls	r3, r3, #2
 101192c:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 1011930:	f021 020c 	bic.w	r2, r1, #12
 1011934:	4313      	orrs	r3, r2
 1011936:	7003      	strb	r3, [r0, #0]

	/* Start setting up of Radio h/w */
	radio_reset();
 1011938:	f000 fa3a 	bl	1011db0 <radio_reset>
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	radio_tx_power_set(lll->tx_pwr_lvl);
#else
	radio_tx_power_set(RADIO_TXP_DEFAULT);
 101193c:	2000      	movs	r0, #0
 101193e:	f000 fa73 	bl	1011e28 <radio_tx_power_set>
#endif

	radio_aa_set(lll->access_addr);
 1011942:	f104 0008 	add.w	r0, r4, #8
 1011946:	f000 fa8d 	bl	1011e64 <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
			    (((u32_t)lll->crc_init[2] << 16) |
			     ((u32_t)lll->crc_init[1] << 8) |
 101194a:	7b63      	ldrb	r3, [r4, #13]
			    (((u32_t)lll->crc_init[2] << 16) |
 101194c:	7ba2      	ldrb	r2, [r4, #14]
			     ((u32_t)lll->crc_init[0])));
 101194e:	7b21      	ldrb	r1, [r4, #12]
			     ((u32_t)lll->crc_init[1] << 8) |
 1011950:	021b      	lsls	r3, r3, #8
			    (((u32_t)lll->crc_init[2] << 16) |
 1011952:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
 1011956:	4319      	orrs	r1, r3
 1011958:	f240 605b 	movw	r0, #1627	; 0x65b
 101195c:	f000 fb46 	bl	1011fec <radio_crc_configure>
	lll_chan_set(data_chan_use);
 1011960:	4630      	mov	r0, r6
 1011962:	f7fe fba9 	bl	10100b8 <lll_chan_set>

	/* setup the radio tx packet buffer */
	lll_conn_tx_pkt_set(lll, pdu_data_tx);
 1011966:	4620      	mov	r0, r4
 1011968:	9903      	ldr	r1, [sp, #12]
 101196a:	f7ff fc69 	bl	1011240 <lll_conn_tx_pkt_set>

	radio_isr_set(lll_conn_isr_tx, lll);
 101196e:	4621      	mov	r1, r4
 1011970:	4821      	ldr	r0, [pc, #132]	; (10119f8 <prepare_cb+0x120>)
 1011972:	f000 f9fd 	bl	1011d70 <radio_isr_set>

	radio_tmr_tifs_set(EVENT_IFS_US);
 1011976:	2096      	movs	r0, #150	; 0x96
 1011978:	f000 fbf6 	bl	1012168 <radio_tmr_tifs_set>

#if defined(CONFIG_BT_CTLR_PHY)
	radio_switch_complete_and_rx(lll->phy_rx);
 101197c:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
 1011980:	f000 0007 	and.w	r0, r0, #7
 1011984:	f000 fb50 	bl	1012028 <radio_switch_complete_and_rx>
#else /* !CONFIG_BT_CTLR_PHY */
	radio_switch_complete_and_rx(0);
#endif /* !CONFIG_BT_CTLR_PHY */

	ticks_at_event = prepare_param->ticks_at_expire;
	evt = HDR_LLL2EVT(lll);
 1011988:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = prepare_param->ticks_at_expire;
 101198a:	682e      	ldr	r6, [r5, #0]
	ticks_at_event += lll_evt_offset_get(evt);
 101198c:	4638      	mov	r0, r7
 101198e:	f7fe fb77 	bl	1010080 <lll_evt_offset_get>
 1011992:	4406      	add	r6, r0

	ticks_at_start = ticks_at_event;
	ticks_at_start += HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US);

	remainder = prepare_param->remainder;
	remainder_us = radio_tmr_start(1, ticks_at_start, remainder);
 1011994:	686a      	ldr	r2, [r5, #4]
 1011996:	f106 0109 	add.w	r1, r6, #9
 101199a:	2001      	movs	r0, #1
 101199c:	f000 fbf0 	bl	1012180 <radio_tmr_start>

	/* capture end of Tx-ed PDU, used to calculate HCTO. */
	radio_tmr_end_capture();
 10119a0:	f000 fd06 	bl	10123b0 <radio_tmr_end_capture>
#endif /* !CONFIG_BT_CTLR_GPIO_PA_PIN */

#if defined(CONFIG_BT_CTLR_XTAL_ADVANCED) && \
	(EVENT_OVERHEAD_PREEMPT_US <= EVENT_OVERHEAD_PREEMPT_MIN_US)
	/* check if preempt to start has changed */
	if (lll_preempt_calc(evt, (TICKER_ID_CONN_BASE + lll->handle),
 10119a4:	7c21      	ldrb	r1, [r4, #16]
 10119a6:	4632      	mov	r2, r6
 10119a8:	3105      	adds	r1, #5
 10119aa:	4638      	mov	r0, r7
 10119ac:	b2c9      	uxtb	r1, r1
 10119ae:	f7fe fb71 	bl	1010094 <lll_preempt_calc>
 10119b2:	b1a8      	cbz	r0, 10119e0 <prepare_cb+0x108>
			     ticks_at_event)) {
		radio_isr_set(lll_conn_isr_abort, lll);
 10119b4:	4621      	mov	r1, r4
 10119b6:	4811      	ldr	r0, [pc, #68]	; (10119fc <prepare_cb+0x124>)
 10119b8:	f000 f9da 	bl	1011d70 <radio_isr_set>
		radio_disable();
 10119bc:	f000 fad6 	bl	1011f6c <radio_disable>
	}

	DEBUG_RADIO_START_M(1);

	return 0;
}
 10119c0:	2000      	movs	r0, #0
 10119c2:	b005      	add	sp, #20
 10119c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		data_chan_use = lll_chan_sel_1(&lll->data_chan_use,
 10119c6:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 10119ca:	f894 1022 	ldrb.w	r1, [r4, #34]	; 0x22
 10119ce:	f104 0023 	add.w	r0, r4, #35	; 0x23
 10119d2:	9300      	str	r3, [sp, #0]
 10119d4:	f104 031c 	add.w	r3, r4, #28
 10119d8:	f7f8 fdae 	bl	100a538 <lll_chan_sel_1>
 10119dc:	4606      	mov	r6, r0
 10119de:	e798      	b.n	1011912 <prepare_cb+0x3a>
		ret = lll_prepare_done(lll);
 10119e0:	4620      	mov	r0, r4
 10119e2:	f7fe fb0f 	bl	1010004 <lll_prepare_done>
		LL_ASSERT(!ret);
 10119e6:	2800      	cmp	r0, #0
 10119e8:	d0ea      	beq.n	10119c0 <prepare_cb+0xe8>
 10119ea:	21d4      	movs	r1, #212	; 0xd4
 10119ec:	4804      	ldr	r0, [pc, #16]	; (1011a00 <prepare_cb+0x128>)
 10119ee:	f7f1 fe47 	bl	1003680 <bt_ctlr_assert_handle>
}
 10119f2:	2000      	movs	r0, #0
 10119f4:	b005      	add	sp, #20
 10119f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
 10119f8:	01011185 	.word	0x01011185
 10119fc:	010110e5 	.word	0x010110e5
 1011a00:	01018c9c 	.word	0x01018c9c

01011a04 <lll_master_prepare>:
{
 1011a04:	b530      	push	{r4, r5, lr}
 1011a06:	b083      	sub	sp, #12
 1011a08:	4604      	mov	r4, r0
	struct lll_conn *lll = p->param;
 1011a0a:	68c5      	ldr	r5, [r0, #12]
	err = lll_hfclock_on();
 1011a0c:	f7fe fbce 	bl	10101ac <lll_hfclock_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
 1011a10:	b108      	cbz	r0, 1011a16 <lll_master_prepare+0x12>
 1011a12:	3044      	adds	r0, #68	; 0x44
 1011a14:	d117      	bne.n	1011a46 <lll_master_prepare+0x42>
	elapsed = p->lazy + 1;
 1011a16:	8923      	ldrh	r3, [r4, #8]
	lll->latency_prepare += elapsed;
 1011a18:	8aea      	ldrh	r2, [r5, #22]
	elapsed = p->lazy + 1;
 1011a1a:	3301      	adds	r3, #1
	lll->latency_prepare += elapsed;
 1011a1c:	4413      	add	r3, r2
 1011a1e:	82eb      	strh	r3, [r5, #22]
	err = lll_prepare(lll_conn_is_abort_cb, lll_conn_abort_cb, prepare_cb,
 1011a20:	4a0b      	ldr	r2, [pc, #44]	; (1011a50 <lll_master_prepare+0x4c>)
 1011a22:	2300      	movs	r3, #0
 1011a24:	490b      	ldr	r1, [pc, #44]	; (1011a54 <lll_master_prepare+0x50>)
 1011a26:	480c      	ldr	r0, [pc, #48]	; (1011a58 <lll_master_prepare+0x54>)
 1011a28:	9400      	str	r4, [sp, #0]
 1011a2a:	f7fe fa77 	bl	100ff1c <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
 1011a2e:	b108      	cbz	r0, 1011a34 <lll_master_prepare+0x30>
 1011a30:	3044      	adds	r0, #68	; 0x44
 1011a32:	d101      	bne.n	1011a38 <lll_master_prepare+0x34>
}
 1011a34:	b003      	add	sp, #12
 1011a36:	bd30      	pop	{r4, r5, pc}
	LL_ASSERT(!err || err == -EINPROGRESS);
 1011a38:	2153      	movs	r1, #83	; 0x53
 1011a3a:	4808      	ldr	r0, [pc, #32]	; (1011a5c <lll_master_prepare+0x58>)
}
 1011a3c:	b003      	add	sp, #12
 1011a3e:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	LL_ASSERT(!err || err == -EINPROGRESS);
 1011a42:	f7f1 be1d 	b.w	1003680 <bt_ctlr_assert_handle>
	LL_ASSERT(!err || err == -EINPROGRESS);
 1011a46:	2148      	movs	r1, #72	; 0x48
 1011a48:	4804      	ldr	r0, [pc, #16]	; (1011a5c <lll_master_prepare+0x58>)
 1011a4a:	f7f1 fe19 	bl	1003680 <bt_ctlr_assert_handle>
 1011a4e:	e7e2      	b.n	1011a16 <lll_master_prepare+0x12>
 1011a50:	010118d9 	.word	0x010118d9
 1011a54:	010110ad 	.word	0x010110ad
 1011a58:	010110a5 	.word	0x010110a5
 1011a5c:	01018c9c 	.word	0x01018c9c

01011a60 <cntr_init>:
    p_reg->EVTENSET = mask;
 1011a60:	f44f 3280 	mov.w	r2, #65536	; 0x10000

static u8_t _refcount;

void cntr_init(void)
{
	NRF_RTC->PRESCALER = 0;
 1011a64:	2100      	movs	r1, #0
 1011a66:	4b04      	ldr	r3, [pc, #16]	; (1011a78 <cntr_init+0x18>)
 1011a68:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
 1011a6c:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344
    p_reg->INTENSET = mask;
 1011a70:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	nrf_rtc_event_enable(NRF_RTC, RTC_EVTENSET_COMPARE0_Msk);
	nrf_rtc_int_enable(NRF_RTC, RTC_INTENSET_COMPARE0_Msk);
}
 1011a74:	4770      	bx	lr
 1011a76:	bf00      	nop
 1011a78:	41011000 	.word	0x41011000

01011a7c <cntr_start>:

u32_t cntr_start(void)
{
	if (_refcount++) {
 1011a7c:	4b05      	ldr	r3, [pc, #20]	; (1011a94 <cntr_start+0x18>)
 1011a7e:	7818      	ldrb	r0, [r3, #0]
 1011a80:	1c42      	adds	r2, r0, #1
 1011a82:	701a      	strb	r2, [r3, #0]
 1011a84:	b918      	cbnz	r0, 1011a8e <cntr_start+0x12>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
 1011a86:	2201      	movs	r2, #1
 1011a88:	4b03      	ldr	r3, [pc, #12]	; (1011a98 <cntr_start+0x1c>)
 1011a8a:	601a      	str	r2, [r3, #0]
		return 1;
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_START);

	return 0;
 1011a8c:	4770      	bx	lr
		return 1;
 1011a8e:	2001      	movs	r0, #1
}
 1011a90:	4770      	bx	lr
 1011a92:	bf00      	nop
 1011a94:	210080cd 	.word	0x210080cd
 1011a98:	41011000 	.word	0x41011000

01011a9c <cntr_stop>:

u32_t cntr_stop(void)
{
 1011a9c:	b510      	push	{r4, lr}
	LL_ASSERT(_refcount);
 1011a9e:	4c09      	ldr	r4, [pc, #36]	; (1011ac4 <cntr_stop+0x28>)
 1011aa0:	7820      	ldrb	r0, [r4, #0]
 1011aa2:	b148      	cbz	r0, 1011ab8 <cntr_stop+0x1c>

	if (--_refcount) {
 1011aa4:	3801      	subs	r0, #1
 1011aa6:	b2c0      	uxtb	r0, r0
 1011aa8:	7020      	strb	r0, [r4, #0]
 1011aaa:	b918      	cbnz	r0, 1011ab4 <cntr_stop+0x18>
 1011aac:	2201      	movs	r2, #1
 1011aae:	4b06      	ldr	r3, [pc, #24]	; (1011ac8 <cntr_stop+0x2c>)
 1011ab0:	601a      	str	r2, [r3, #0]
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_STOP);

	return 0;
}
 1011ab2:	bd10      	pop	{r4, pc}
		return 1;
 1011ab4:	2001      	movs	r0, #1
}
 1011ab6:	bd10      	pop	{r4, pc}
	LL_ASSERT(_refcount);
 1011ab8:	4804      	ldr	r0, [pc, #16]	; (1011acc <cntr_stop+0x30>)
 1011aba:	212e      	movs	r1, #46	; 0x2e
 1011abc:	f7f1 fde0 	bl	1003680 <bt_ctlr_assert_handle>
 1011ac0:	7820      	ldrb	r0, [r4, #0]
 1011ac2:	e7ef      	b.n	1011aa4 <cntr_stop+0x8>
 1011ac4:	210080cd 	.word	0x210080cd
 1011ac8:	41011004 	.word	0x41011004
 1011acc:	01018d00 	.word	0x01018d00

01011ad0 <cntr_cnt_get>:
     return p_reg->COUNTER;
 1011ad0:	4b01      	ldr	r3, [pc, #4]	; (1011ad8 <cntr_cnt_get+0x8>)
 1011ad2:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504

u32_t cntr_cnt_get(void)
{
	return nrf_rtc_counter_get(NRF_RTC);
}
 1011ad6:	4770      	bx	lr
 1011ad8:	41011000 	.word	0x41011000

01011adc <cntr_cmp_set>:
    p_reg->CC[ch] = cc_val;
 1011adc:	4b02      	ldr	r3, [pc, #8]	; (1011ae8 <cntr_cmp_set+0xc>)
 1011ade:	f500 70a8 	add.w	r0, r0, #336	; 0x150
 1011ae2:	f843 1020 	str.w	r1, [r3, r0, lsl #2]

void cntr_cmp_set(u8_t cmp, u32_t value)
{
	nrf_rtc_cc_set(NRF_RTC, cmp, value);
}
 1011ae6:	4770      	bx	lr
 1011ae8:	41011000 	.word	0x41011000

01011aec <do_ecb>:
	u8_t clear_text[16];
	u8_t cipher_text[16];
} __packed;

static void do_ecb(struct ecb_param *ecb)
{
 1011aec:	b4f0      	push	{r4, r5, r6, r7}

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ecb_task_trigger(NRF_ECB_Type * p_reg, nrf_ecb_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1011aee:	2601      	movs	r6, #1
	do {
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
		NRF_ECB->ECBDATAPTR = (u32_t)ecb;
		NRF_ECB->EVENTS_ENDECB = 0;
 1011af0:	2400      	movs	r4, #0
 1011af2:	4635      	mov	r5, r6
 1011af4:	4910      	ldr	r1, [pc, #64]	; (1011b38 <do_ecb+0x4c>)
		NRF_ECB->ECBDATAPTR = (u32_t)ecb;
 1011af6:	4b11      	ldr	r3, [pc, #68]	; (1011b3c <do_ecb+0x50>)
 1011af8:	600d      	str	r5, [r1, #0]
 1011afa:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
		NRF_ECB->EVENTS_ENDECB = 0;
 1011afe:	f8c3 4100 	str.w	r4, [r3, #256]	; 0x100
		NRF_ECB->EVENTS_ERRORECB = 0;
 1011b02:	f8c3 4104 	str.w	r4, [r3, #260]	; 0x104
 1011b06:	601d      	str	r5, [r3, #0]
}
 1011b08:	e005      	b.n	1011b16 <do_ecb+0x2a>
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STARTECB);
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
 1011b0a:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
 1011b0e:	b932      	cbnz	r2, 1011b1e <do_ecb+0x32>
		       (NRF_ECB->ECBDATAPTR != 0)) {
 1011b10:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
 1011b14:	b11a      	cbz	r2, 1011b1e <do_ecb+0x32>
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
 1011b16:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 1011b1a:	2a00      	cmp	r2, #0
 1011b1c:	d0f5      	beq.n	1011b0a <do_ecb+0x1e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1011b1e:	600e      	str	r6, [r1, #0]
#else
			/*__WFE();*/
#endif
		}
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
	} while ((NRF_ECB->EVENTS_ERRORECB != 0) || (NRF_ECB->ECBDATAPTR == 0));
 1011b20:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 1011b24:	2a00      	cmp	r2, #0
 1011b26:	d1e7      	bne.n	1011af8 <do_ecb+0xc>
 1011b28:	f8d3 7504 	ldr.w	r7, [r3, #1284]	; 0x504
 1011b2c:	2f00      	cmp	r7, #0
 1011b2e:	d0e3      	beq.n	1011af8 <do_ecb+0xc>

	NRF_ECB->ECBDATAPTR = 0;
}
 1011b30:	bcf0      	pop	{r4, r5, r6, r7}
	NRF_ECB->ECBDATAPTR = 0;
 1011b32:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
 1011b36:	4770      	bx	lr
 1011b38:	4100d004 	.word	0x4100d004
 1011b3c:	4100d000 	.word	0x4100d000

01011b40 <ecb_encrypt>:
	memcpy(cipher_text_be, &ecb.cipher_text[0], sizeof(ecb.cipher_text));
}

void ecb_encrypt(u8_t const *const key_le, u8_t const *const clear_text_le,
		 u8_t * const cipher_text_le, u8_t * const cipher_text_be)
{
 1011b40:	b570      	push	{r4, r5, r6, lr}
 1011b42:	b08c      	sub	sp, #48	; 0x30
 1011b44:	460e      	mov	r6, r1
 1011b46:	4615      	mov	r5, r2
 1011b48:	4601      	mov	r1, r0
	struct ecb_param ecb;

	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
 1011b4a:	2210      	movs	r2, #16
 1011b4c:	4668      	mov	r0, sp
{
 1011b4e:	461c      	mov	r4, r3
	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
 1011b50:	f7f4 f91e 	bl	1005d90 <mem_rcopy>
	mem_rcopy(&ecb.clear_text[0], clear_text_le, sizeof(ecb.clear_text));
 1011b54:	2210      	movs	r2, #16
 1011b56:	4631      	mov	r1, r6
 1011b58:	eb0d 0002 	add.w	r0, sp, r2
 1011b5c:	f7f4 f918 	bl	1005d90 <mem_rcopy>

	do_ecb(&ecb);
 1011b60:	4668      	mov	r0, sp
 1011b62:	f7ff ffc3 	bl	1011aec <do_ecb>

	if (cipher_text_le) {
 1011b66:	b125      	cbz	r5, 1011b72 <ecb_encrypt+0x32>
		mem_rcopy(cipher_text_le, &ecb.cipher_text[0],
 1011b68:	4628      	mov	r0, r5
 1011b6a:	2210      	movs	r2, #16
 1011b6c:	a908      	add	r1, sp, #32
 1011b6e:	f7f4 f90f 	bl	1005d90 <mem_rcopy>
			  sizeof(ecb.cipher_text));
	}

	if (cipher_text_be) {
 1011b72:	b124      	cbz	r4, 1011b7e <ecb_encrypt+0x3e>
		memcpy(cipher_text_be, &ecb.cipher_text[0],
 1011b74:	4620      	mov	r0, r4
 1011b76:	2210      	movs	r2, #16
 1011b78:	a908      	add	r1, sp, #32
 1011b7a:	f004 ff4d 	bl	1016a18 <memcpy>
			 sizeof(ecb.cipher_text));
	}
}
 1011b7e:	b00c      	add	sp, #48	; 0x30
 1011b80:	bd70      	pop	{r4, r5, r6, pc}
 1011b82:	bf00      	nop

01011b84 <sw_switch.isra.0>:
#endif

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
static u8_t sw_tifs_toggle;

static void sw_switch(u8_t dir, u8_t phy_curr, u8_t flags_curr, u8_t phy_next,
 1011b84:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		      u8_t flags_next)
{
	u8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
 1011b88:	f8df e1c0 	ldr.w	lr, [pc, #448]	; 1011d4c <sw_switch.isra.0+0x1c8>
	/* Set up software switch mechanism for next Radio switch. */

	/* Wire RADIO END event to PPI Group[<index>] enable task,
	 * over PPI[<HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI>]
	 */
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_EVT =
 1011b8c:	4b6a      	ldr	r3, [pc, #424]	; (1011d38 <sw_switch.isra.0+0x1b4>)
 1011b8e:	f89e 4000 	ldrb.w	r4, [lr]
 1011b92:	f99e c000 	ldrsb.w	ip, [lr]
 1011b96:	00e7      	lsls	r7, r4, #3
 1011b98:	4e68      	ldr	r6, [pc, #416]	; (1011d3c <sw_switch.isra.0+0x1b8>)
 1011b9a:	f107 4782 	add.w	r7, r7, #1090519040	; 0x41000000
 1011b9e:	f507 4770 	add.w	r7, r7, #61440	; 0xf000
 1011ba2:	f10c 0508 	add.w	r5, ip, #8
 1011ba6:	f8c6 318c 	str.w	r3, [r6, #396]	; 0x18c
 1011baa:	b2ed      	uxtb	r5, r5
	    HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_EVT;
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(ppi_group_index) =
 1011bac:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
			HAL_SW_SWITCH_TIMER_CLEAR_PPI_EVT,
		"Radio End Timer Capture and Group Disable"
		" not on the same PPI channel.");

	/* We need to un-subscribe the other group from the PPI channel. */
	if (ppi_group_index == 0) {
 1011bb0:	2c00      	cmp	r4, #0
 1011bb2:	d142      	bne.n	1011c3a <sw_switch.isra.0+0xb6>
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(1)	= 0;
 1011bb4:	4b62      	ldr	r3, [pc, #392]	; (1011d40 <sw_switch.isra.0+0x1bc>)
 1011bb6:	f8c3 4088 	str.w	r4, [r3, #136]	; 0x88
	 * PPI[<radio_enable_ppi>] for enabling Radio. Do
	 * not wire the task; it is done by the caller of
	 * the function depending on the desired direction
	 * (TX/RX).
	 */
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_EVT(compare_reg) =
 1011bba:	00a3      	lsls	r3, r4, #2
 1011bbc:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(radio_enable_ppi);
 1011bc0:	f045 4500 	orr.w	r5, r5, #2147483648	; 0x80000000
 1011bc4:	f503 33c0 	add.w	r3, r3, #98304	; 0x18000
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_EVT(compare_reg) =
 1011bc8:	f8c3 51c0 	str.w	r5, [r3, #448]	; 0x1c0
	u8_t cc = SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle);
	u32_t delay;

	hal_radio_sw_switch_setup(cc, ppi, sw_tifs_toggle);

	if (dir) {
 1011bcc:	b1c8      	cbz	r0, 1011c02 <sw_switch.isra.0+0x7e>
	}
}

static inline u32_t hal_radio_tx_ready_delay_ns_get(u8_t phy, u8_t flags)
{
	switch (phy) {
 1011bce:	2a02      	cmp	r2, #2
 1011bd0:	d040      	beq.n	1011c54 <sw_switch.isra.0+0xd0>
	default:
	case BIT(0):
		return HAL_RADIO_NRF5340_TXEN_TXIDLE_TX_1M_NS;
 1011bd2:	f24a 563c 	movw	r6, #42300	; 0xa53c
 1011bd6:	f649 70c4 	movw	r0, #40900	; 0x9fc4
 1011bda:	2a04      	cmp	r2, #4
 1011bdc:	bf18      	it	ne
 1011bde:	4606      	movne	r6, r0
	}
}

static inline u32_t hal_radio_rx_chain_delay_ns_get(u8_t phy, u8_t flags)
{
	switch (phy) {
 1011be0:	2902      	cmp	r1, #2
 1011be2:	f000 8085 	beq.w	1011cf0 <sw_switch.isra.0+0x16c>
 1011be6:	2904      	cmp	r1, #4
 1011be8:	f040 8094 	bne.w	1011d14 <sw_switch.isra.0+0x190>
 1011bec:	4855      	ldr	r0, [pc, #340]	; (1011d44 <sw_switch.isra.0+0x1c0>)
 1011bee:	f506 46eb 	add.w	r6, r6, #30080	; 0x7580
 1011bf2:	3614      	adds	r6, #20
 1011bf4:	fba0 0606 	umull	r0, r6, r0, r6
 1011bf8:	09b6      	lsrs	r6, r6, #6
}

static inline void hal_radio_txen_on_sw_switch(u8_t ppi)
{
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_TASK_TX =
 1011bfa:	4850      	ldr	r0, [pc, #320]	; (1011d3c <sw_switch.isra.0+0x1b8>)
 1011bfc:	f8c0 5080 	str.w	r5, [r0, #128]	; 0x80
		    HAL_SW_SWITCH_RADIO_ENABLE_S2_PPI(sw_tifs_toggle);
		u8_t ppi_dis =
			HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI(
			    sw_tifs_toggle);

		if (phy_curr & BIT(2)) {
 1011c00:	e032      	b.n	1011c68 <sw_switch.isra.0+0xe4>
		}
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
	} else {
		/* RX */
		delay = HAL_RADIO_NS2US_CEIL(
 1011c02:	2628      	movs	r6, #40	; 0x28
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_TASK_TX_SET(ppi);
}

static inline void hal_radio_rxen_on_sw_switch(u8_t ppi)
{
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_TASK_RX =
 1011c04:	4a4d      	ldr	r2, [pc, #308]	; (1011d3c <sw_switch.isra.0+0x1b8>)
 1011c06:	f8c2 5084 	str.w	r5, [r2, #132]	; 0x84
	 *
	 * Note: we do not un-subscribe the Radio enable task because
	 * we use the same PPI for both SW Switch Timer compare events.
	 */
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_EVT(
		SW_SWITCH_TIMER_S2_EVTS_COMP(group_index)) = 0;
 1011c0a:	f8c3 01c8 	str.w	r0, [r3, #456]	; 0x1c8

	/* Wire the Group[group_index] task disable to the default
	 * SW Switch Timer EVENTS_COMPARE.
	 */
	HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_REGISTER_EVT(
		cc_reg) =
 1011c0e:	f8c3 51c0 	str.w	r5, [r3, #448]	; 0x1c0
		HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_EVT(
			ppi_dis);
	HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_REGISTER_TASK(
		group_index) =
 1011c12:	f8c7 5084 	str.w	r5, [r7, #132]	; 0x84
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
	}

	if (delay <
		SW_SWITCH_TIMER->CC[cc]) {
 1011c16:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
	if (delay <
 1011c1a:	42b2      	cmp	r2, r6
 1011c1c:	d814      	bhi.n	1011c48 <sw_switch.isra.0+0xc4>

NRF_STATIC_INLINE void nrf_timer_cc_set(NRF_TIMER_Type *       p_reg,
                                        nrf_timer_cc_channel_t cc_channel,
                                        uint32_t               cc_value)
{
    p_reg->CC[cc_channel] = cc_value;
 1011c1e:	2201      	movs	r2, #1
 1011c20:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    p_reg->CHENCLR = 0xFFFFFFFFuL;
}

NRF_STATIC_INLINE void nrf_dppi_channels_enable(NRF_DPPIC_Type * p_reg, uint32_t mask)
{
    p_reg->CHENSET = mask;
 1011c24:	2220      	movs	r2, #32
 1011c26:	4b46      	ldr	r3, [pc, #280]	; (1011d40 <sw_switch.isra.0+0x1bc>)
	 * always need to capture the PDU END time-stamp.
	 */
	radio_tmr_end_capture();
#endif /* CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */

	sw_tifs_toggle += 1U;
 1011c28:	3401      	adds	r4, #1
	sw_tifs_toggle &= 1;
 1011c2a:	f004 0401 	and.w	r4, r4, #1
 1011c2e:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
 1011c32:	f88e 4000 	strb.w	r4, [lr]
}
 1011c36:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (ppi_group_index == 1) {
 1011c3a:	2c01      	cmp	r4, #1
 1011c3c:	d1bd      	bne.n	1011bba <sw_switch.isra.0+0x36>
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(0)	= 0;
 1011c3e:	2600      	movs	r6, #0
 1011c40:	4b3f      	ldr	r3, [pc, #252]	; (1011d40 <sw_switch.isra.0+0x1bc>)
 1011c42:	f8c3 6080 	str.w	r6, [r3, #128]	; 0x80
 1011c46:	e7b8      	b.n	1011bba <sw_switch.isra.0+0x36>
				 SW_SWITCH_TIMER->CC[cc] - delay);
 1011c48:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
 1011c4c:	1b96      	subs	r6, r2, r6
 1011c4e:	f8c3 6540 	str.w	r6, [r3, #1344]	; 0x540
}
 1011c52:	e7e7      	b.n	1011c24 <sw_switch.isra.0+0xa0>
 1011c54:	2902      	cmp	r1, #2
 1011c56:	d06a      	beq.n	1011d2e <sw_switch.isra.0+0x1aa>
 1011c58:	2904      	cmp	r1, #4
 1011c5a:	d066      	beq.n	1011d2a <sw_switch.isra.0+0x1a6>
 1011c5c:	2631      	movs	r6, #49	; 0x31
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_TASK_TX =
 1011c5e:	4837      	ldr	r0, [pc, #220]	; (1011d3c <sw_switch.isra.0+0x1b8>)
 1011c60:	f8c0 5080 	str.w	r5, [r0, #128]	; 0x80
		if (phy_curr & BIT(2)) {
 1011c64:	0748      	lsls	r0, r1, #29
 1011c66:	d54d      	bpl.n	1011d04 <sw_switch.isra.0+0x180>
	switch (phy) {
 1011c68:	2a02      	cmp	r2, #2
 1011c6a:	d05b      	beq.n	1011d24 <sw_switch.isra.0+0x1a0>
 1011c6c:	f24a 18b8 	movw	r8, #41400	; 0xa1b8
 1011c70:	f24a 7030 	movw	r0, #42800	; 0xa730
 1011c74:	2a04      	cmp	r2, #4
 1011c76:	bf14      	ite	ne
 1011c78:	4642      	movne	r2, r8
 1011c7a:	4602      	moveq	r2, r0
#if defined(CONFIG_BT_CTLR_PHY_CODED)
	case BIT(2):
		if (flags & 0x01) {
			return HAL_RADIO_NRF5340_RX_CHAIN_DELAY_S8_NS;
		} else {
			return HAL_RADIO_NRF5340_RX_CHAIN_DELAY_S2_NS;
 1011c7c:	f242 48b8 	movw	r8, #9400	; 0x24b8
 1011c80:	f246 0018 	movw	r0, #24600	; 0x6018
 1011c84:	2904      	cmp	r1, #4
 1011c86:	bf14      	ite	ne
 1011c88:	4641      	movne	r1, r8
 1011c8a:	4601      	moveq	r1, r0
			    SW_SWITCH_TIMER_S2_EVTS_COMP(sw_tifs_toggle);
 1011c8c:	f10c 0002 	add.w	r0, ip, #2
 1011c90:	b2c0      	uxtb	r0, r0
			delay_s2 = HAL_RADIO_NS2US_ROUND(
 1011c92:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 1011d44 <sw_switch.isra.0+0x1c0>
 1011c96:	0080      	lsls	r0, r0, #2
				SW_SWITCH_TIMER->CC[cc];
 1011c98:	f8d3 c540 	ldr.w	ip, [r3, #1344]	; 0x540
			delay_s2 = HAL_RADIO_NS2US_ROUND(
 1011c9c:	440a      	add	r2, r1
 1011c9e:	f100 4082 	add.w	r0, r0, #1090519040	; 0x41000000
 1011ca2:	fba8 1202 	umull	r1, r2, r8, r2
 1011ca6:	f500 30c0 	add.w	r0, r0, #98304	; 0x18000
			SW_SWITCH_TIMER->CC[cc_s2] =
 1011caa:	f8c0 c540 	str.w	ip, [r0, #1344]	; 0x540
			if (delay_s2 < SW_SWITCH_TIMER->CC[cc_s2]) {
 1011cae:	f8d0 1540 	ldr.w	r1, [r0, #1344]	; 0x540
			delay_s2 = HAL_RADIO_NS2US_ROUND(
 1011cb2:	ea4f 1c92 	mov.w	ip, r2, lsr #6
			if (delay_s2 < SW_SWITCH_TIMER->CC[cc_s2]) {
 1011cb6:	ebb1 1f92 	cmp.w	r1, r2, lsr #6
				SW_SWITCH_TIMER->CC[cc_s2] -= delay_s2;
 1011cba:	bf8a      	itet	hi
 1011cbc:	f8d0 2540 	ldrhi.w	r2, [r0, #1344]	; 0x540
				SW_SWITCH_TIMER->CC[cc_s2] = 1;
 1011cc0:	2201      	movls	r2, #1
				SW_SWITCH_TIMER->CC[cc_s2] -= delay_s2;
 1011cc2:	eba2 020c 	subhi.w	r2, r2, ip
 1011cc6:	f44f 5c00 	mov.w	ip, #8192	; 0x2000
				SW_SWITCH_TIMER->CC[cc_s2] = 1;
 1011cca:	f8c0 2540 	str.w	r2, [r0, #1344]	; 0x540
	HAL_SW_SWITCH_TIMER_S8_DISABLE_PPI_REGISTER_EVT =
 1011cce:	f8df 806c 	ldr.w	r8, [pc, #108]	; 1011d3c <sw_switch.isra.0+0x1b8>
 1011cd2:	4a1d      	ldr	r2, [pc, #116]	; (1011d48 <sw_switch.isra.0+0x1c4>)
 1011cd4:	491a      	ldr	r1, [pc, #104]	; (1011d40 <sw_switch.isra.0+0x1bc>)
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_EVT(cc_s2) =
 1011cd6:	f8c0 51c0 	str.w	r5, [r0, #448]	; 0x1c0
	HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_REGISTER_EVT(cc_s2) =
 1011cda:	f8c0 51c0 	str.w	r5, [r0, #448]	; 0x1c0
	HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_REGISTER_TASK(group_index) =
 1011cde:	f8c7 5084 	str.w	r5, [r7, #132]	; 0x84
	HAL_SW_SWITCH_TIMER_S8_DISABLE_PPI_REGISTER_EVT =
 1011ce2:	f8c8 21d0 	str.w	r2, [r8, #464]	; 0x1d0
		SW_SWITCH_TIMER_EVTS_COMP(group_index)) =
 1011ce6:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
 1011cea:	f8c1 c504 	str.w	ip, [r1, #1284]	; 0x504
}
 1011cee:	e792      	b.n	1011c16 <sw_switch.isra.0+0x92>
		delay = HAL_RADIO_NS2US_ROUND(
 1011cf0:	4a14      	ldr	r2, [pc, #80]	; (1011d44 <sw_switch.isra.0+0x1c0>)
 1011cf2:	f506 56ab 	add.w	r6, r6, #5472	; 0x1560
 1011cf6:	361c      	adds	r6, #28
 1011cf8:	fba2 2606 	umull	r2, r6, r2, r6
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_TASK_TX =
 1011cfc:	4a0f      	ldr	r2, [pc, #60]	; (1011d3c <sw_switch.isra.0+0x1b8>)
 1011cfe:	09b6      	lsrs	r6, r6, #6
 1011d00:	f8c2 5080 	str.w	r5, [r2, #128]	; 0x80
		SW_SWITCH_TIMER_S2_EVTS_COMP(group_index)) = 0;
 1011d04:	2200      	movs	r2, #0
 1011d06:	f8c3 21c8 	str.w	r2, [r3, #456]	; 0x1c8
		cc_reg) =
 1011d0a:	f8c3 51c0 	str.w	r5, [r3, #448]	; 0x1c0
		group_index) =
 1011d0e:	f8c7 5084 	str.w	r5, [r7, #132]	; 0x84
		HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_TASK(
			ppi_dis);
}
 1011d12:	e780      	b.n	1011c16 <sw_switch.isra.0+0x92>
 1011d14:	480b      	ldr	r0, [pc, #44]	; (1011d44 <sw_switch.isra.0+0x1c0>)
 1011d16:	f506 561a 	add.w	r6, r6, #9856	; 0x2680
 1011d1a:	362c      	adds	r6, #44	; 0x2c
 1011d1c:	fba0 0606 	umull	r0, r6, r0, r6
 1011d20:	09b6      	lsrs	r6, r6, #6
 1011d22:	e79c      	b.n	1011c5e <sw_switch.isra.0+0xda>
	switch (phy) {
 1011d24:	f649 6234 	movw	r2, #40500	; 0x9e34
 1011d28:	e7a8      	b.n	1011c7c <sw_switch.isra.0+0xf8>
	switch (phy) {
 1011d2a:	2646      	movs	r6, #70	; 0x46
 1011d2c:	e765      	b.n	1011bfa <sw_switch.isra.0+0x76>
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_TASK_TX =
 1011d2e:	4a03      	ldr	r2, [pc, #12]	; (1011d3c <sw_switch.isra.0+0x1b8>)
 1011d30:	262d      	movs	r6, #45	; 0x2d
 1011d32:	f8c2 5080 	str.w	r5, [r2, #128]	; 0x80
		if (phy_curr & BIT(2)) {
 1011d36:	e7e5      	b.n	1011d04 <sw_switch.isra.0+0x180>
 1011d38:	80000005 	.word	0x80000005
 1011d3c:	41008000 	.word	0x41008000
 1011d40:	4100f000 	.word	0x4100f000
 1011d44:	10624dd3 	.word	0x10624dd3
 1011d48:	8000000d 	.word	0x8000000d
 1011d4c:	210080ce 	.word	0x210080ce

01011d50 <isr_radio>:
	return (NRF_RADIO->EVENTS_DISABLED != 0);
 1011d50:	4b04      	ldr	r3, [pc, #16]	; (1011d64 <isr_radio+0x14>)
 1011d52:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
	if (radio_has_disabled()) {
 1011d56:	b123      	cbz	r3, 1011d62 <isr_radio+0x12>
		isr_cb(isr_cb_param);
 1011d58:	4a03      	ldr	r2, [pc, #12]	; (1011d68 <isr_radio+0x18>)
 1011d5a:	4b04      	ldr	r3, [pc, #16]	; (1011d6c <isr_radio+0x1c>)
 1011d5c:	6810      	ldr	r0, [r2, #0]
 1011d5e:	681b      	ldr	r3, [r3, #0]
 1011d60:	4718      	bx	r3
}
 1011d62:	4770      	bx	lr
 1011d64:	41008000 	.word	0x41008000
 1011d68:	210058bc 	.word	0x210058bc
 1011d6c:	210058b8 	.word	0x210058b8

01011d70 <radio_isr_set>:
{
 1011d70:	b570      	push	{r4, r5, r6, lr}
 1011d72:	460d      	mov	r5, r1
 1011d74:	4604      	mov	r4, r0
	irq_disable(RADIO_IRQn);
 1011d76:	2008      	movs	r0, #8
 1011d78:	f7f3 f858 	bl	1004e2c <arch_irq_disable>
    return p_reg->SHORTS;
}

NRF_STATIC_INLINE void nrf_radio_int_enable(NRF_RADIO_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
 1011d7c:	2610      	movs	r6, #16
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 1011d7e:	f44f 7280 	mov.w	r2, #256	; 0x100
	isr_cb_param = param;
 1011d82:	4b07      	ldr	r3, [pc, #28]	; (1011da0 <radio_isr_set+0x30>)
	isr_cb = cb;
 1011d84:	4807      	ldr	r0, [pc, #28]	; (1011da4 <radio_isr_set+0x34>)
	isr_cb_param = param;
 1011d86:	601d      	str	r5, [r3, #0]
 1011d88:	4907      	ldr	r1, [pc, #28]	; (1011da8 <radio_isr_set+0x38>)
 1011d8a:	4b08      	ldr	r3, [pc, #32]	; (1011dac <radio_isr_set+0x3c>)
	isr_cb = cb;
 1011d8c:	6004      	str	r4, [r0, #0]
 1011d8e:	f8c1 6304 	str.w	r6, [r1, #772]	; 0x304
	irq_enable(RADIO_IRQn);
 1011d92:	2008      	movs	r0, #8
}
 1011d94:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 1011d98:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
	irq_enable(RADIO_IRQn);
 1011d9c:	f7f3 b836 	b.w	1004e0c <arch_irq_enable>
 1011da0:	210058bc 	.word	0x210058bc
 1011da4:	210058b8 	.word	0x210058b8
 1011da8:	41008000 	.word	0x41008000
 1011dac:	e000e100 	.word	0xe000e100

01011db0 <radio_reset>:
{
 1011db0:	b538      	push	{r3, r4, r5, lr}
	irq_disable(RADIO_IRQn);
 1011db2:	2008      	movs	r0, #8
 1011db4:	f7f3 f83a 	bl	1004e2c <arch_irq_disable>

	NRF_DPPIC->TASKS_CHG[SW_SWITCH_TIMER_TASK_GROUP(0)].DIS = 1;
	NRF_DPPIC->TASKS_CHG[SW_SWITCH_TIMER_TASK_GROUP(1)].DIS = 1;

	/* Include the appropriate PPI channels in the two PPI Groups. */
	NRF_DPPIC->CHG[SW_SWITCH_TIMER_TASK_GROUP(0)] =
 1011db8:	f44f 7580 	mov.w	r5, #256	; 0x100
}
#endif

NRF_STATIC_INLINE void nrf_radio_power_set(NRF_RADIO_Type * p_reg, bool radio_power)
{
    p_reg->POWER = (uint32_t) radio_power;
 1011dbc:	2200      	movs	r2, #0
 1011dbe:	2101      	movs	r1, #1
		HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_0_INCLUDE |
			HAL_SW_SWITCH_RADIO_ENABLE_PPI_0_INCLUDE;
	NRF_DPPIC->CHG[SW_SWITCH_TIMER_TASK_GROUP(1)] =
 1011dc0:	f44f 7400 	mov.w	r4, #512	; 0x200
	NRF_DPPIC->SUBSCRIBE_CHG[SW_SWITCH_TIMER_TASK_GROUP(0)].EN = 0;
 1011dc4:	4b0a      	ldr	r3, [pc, #40]	; (1011df0 <radio_reset+0x40>)
 1011dc6:	480b      	ldr	r0, [pc, #44]	; (1011df4 <radio_reset+0x44>)
 1011dc8:	f8c0 2ffc 	str.w	r2, [r0, #4092]	; 0xffc
 1011dcc:	f8c0 1ffc 	str.w	r1, [r0, #4092]	; 0xffc
 1011dd0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	NRF_DPPIC->SUBSCRIBE_CHG[SW_SWITCH_TIMER_TASK_GROUP(0)].DIS = 0;
 1011dd4:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	NRF_DPPIC->SUBSCRIBE_CHG[SW_SWITCH_TIMER_TASK_GROUP(1)].EN = 0;
 1011dd8:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	NRF_DPPIC->SUBSCRIBE_CHG[SW_SWITCH_TIMER_TASK_GROUP(1)].DIS = 0;
 1011ddc:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	NRF_DPPIC->TASKS_CHG[SW_SWITCH_TIMER_TASK_GROUP(0)].DIS = 1;
 1011de0:	6059      	str	r1, [r3, #4]
	NRF_DPPIC->TASKS_CHG[SW_SWITCH_TIMER_TASK_GROUP(1)].DIS = 1;
 1011de2:	60d9      	str	r1, [r3, #12]
	NRF_DPPIC->CHG[SW_SWITCH_TIMER_TASK_GROUP(0)] =
 1011de4:	f8c3 5800 	str.w	r5, [r3, #2048]	; 0x800
	NRF_DPPIC->CHG[SW_SWITCH_TIMER_TASK_GROUP(1)] =
 1011de8:	f8c3 4804 	str.w	r4, [r3, #2052]	; 0x804
}
 1011dec:	bd38      	pop	{r3, r4, r5, pc}
 1011dee:	bf00      	nop
 1011df0:	4100f000 	.word	0x4100f000
 1011df4:	41008000 	.word	0x41008000

01011df8 <radio_phy_set>:
	switch (phy) {
 1011df8:	2802      	cmp	r0, #2
 1011dfa:	d011      	beq.n	1011e20 <radio_phy_set+0x28>
 1011dfc:	2804      	cmp	r0, #4
 1011dfe:	d10d      	bne.n	1011e1c <radio_phy_set+0x24>
		if (flags & 0x01) {
 1011e00:	f001 0101 	and.w	r1, r1, #1
 1011e04:	f1c1 0106 	rsb	r1, r1, #6
	NRF_RADIO->MODE = (mode << RADIO_MODE_MODE_Pos) & RADIO_MODE_MODE_Msk;
 1011e08:	4b06      	ldr	r3, [pc, #24]	; (1011e24 <radio_phy_set+0x2c>)
 1011e0a:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
	NRF_RADIO->MODECNF0 |= (RADIO_MODECNF0_RU_Fast <<
 1011e0e:	f8d3 2650 	ldr.w	r2, [r3, #1616]	; 0x650
 1011e12:	f042 0201 	orr.w	r2, r2, #1
 1011e16:	f8c3 2650 	str.w	r2, [r3, #1616]	; 0x650
}
 1011e1a:	4770      	bx	lr
		mode = RADIO_MODE_MODE_Ble_1Mbit;
 1011e1c:	2103      	movs	r1, #3
 1011e1e:	e7f3      	b.n	1011e08 <radio_phy_set+0x10>
	switch (phy) {
 1011e20:	2104      	movs	r1, #4
 1011e22:	e7f1      	b.n	1011e08 <radio_phy_set+0x10>
 1011e24:	41008000 	.word	0x41008000

01011e28 <radio_tx_power_set>:
	NRF_RADIO->TXPOWER = (u32_t)power;
 1011e28:	4b01      	ldr	r3, [pc, #4]	; (1011e30 <radio_tx_power_set+0x8>)
 1011e2a:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
}
 1011e2e:	4770      	bx	lr
 1011e30:	41008000 	.word	0x41008000

01011e34 <radio_freq_chan_set>:
	NRF_RADIO->FREQUENCY = chan;
 1011e34:	4b01      	ldr	r3, [pc, #4]	; (1011e3c <radio_freq_chan_set+0x8>)
 1011e36:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
}
 1011e3a:	4770      	bx	lr
 1011e3c:	41008000 	.word	0x41008000

01011e40 <radio_whiten_iv_set>:
	NRF_RADIO->DATAWHITEIV = iv;
 1011e40:	4b07      	ldr	r3, [pc, #28]	; (1011e60 <radio_whiten_iv_set+0x20>)
 1011e42:	f8c3 0554 	str.w	r0, [r3, #1364]	; 0x554
	NRF_RADIO->PCNF1 &= ~RADIO_PCNF1_WHITEEN_Msk;
 1011e46:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
 1011e4a:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
 1011e4e:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((1UL) << RADIO_PCNF1_WHITEEN_Pos) &
 1011e52:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
 1011e56:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 1011e5a:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}
 1011e5e:	4770      	bx	lr
 1011e60:	41008000 	.word	0x41008000

01011e64 <radio_aa_set>:
	NRF_RADIO->TXADDRESS =
 1011e64:	2100      	movs	r1, #0
	NRF_RADIO->RXADDRESSES =
 1011e66:	2301      	movs	r3, #1
	NRF_RADIO->TXADDRESS =
 1011e68:	4a0a      	ldr	r2, [pc, #40]	; (1011e94 <radio_aa_set+0x30>)
{
 1011e6a:	b410      	push	{r4}
	NRF_RADIO->TXADDRESS =
 1011e6c:	f8c2 152c 	str.w	r1, [r2, #1324]	; 0x52c
	NRF_RADIO->RXADDRESSES =
 1011e70:	f8c2 3530 	str.w	r3, [r2, #1328]	; 0x530
	NRF_RADIO->PREFIX0 = aa[3];
 1011e74:	78c3      	ldrb	r3, [r0, #3]
 1011e76:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
	NRF_RADIO->BASE0 = (aa[2] << 24) | (aa[1] << 16) | (aa[0] << 8);
 1011e7a:	7843      	ldrb	r3, [r0, #1]
 1011e7c:	7884      	ldrb	r4, [r0, #2]
 1011e7e:	7801      	ldrb	r1, [r0, #0]
 1011e80:	041b      	lsls	r3, r3, #16
 1011e82:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
 1011e86:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
}
 1011e8a:	bc10      	pop	{r4}
	NRF_RADIO->BASE0 = (aa[2] << 24) | (aa[1] << 16) | (aa[0] << 8);
 1011e8c:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c
}
 1011e90:	4770      	bx	lr
 1011e92:	bf00      	nop
 1011e94:	41008000 	.word	0x41008000

01011e98 <radio_pkt_configure>:
	phy = (flags >> 1) & 0x07; /* phy */
 1011e98:	f3c2 0342 	ubfx	r3, r2, #1, #3
	switch (phy) {
 1011e9c:	2b02      	cmp	r3, #2
{
 1011e9e:	b410      	push	{r4}
	u8_t dc = flags & 0x01; /* Adv or Data channel */
 1011ea0:	f002 0201 	and.w	r2, r2, #1
	switch (phy) {
 1011ea4:	d024      	beq.n	1011ef0 <radio_pkt_configure+0x58>
		extra |= (3UL << RADIO_PCNF0_TERMLEN_Pos) &
 1011ea6:	2b04      	cmp	r3, #4
 1011ea8:	bf14      	ite	ne
 1011eaa:	2400      	movne	r4, #0
 1011eac:	f04f 44c7 	moveq.w	r4, #1669332992	; 0x63800000
	if (dc) {
 1011eb0:	b10a      	cbz	r2, 1011eb6 <radio_pkt_configure+0x1e>
		extra |= (RADIO_PCNF0_S1INCL_Include <<
 1011eb2:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
			   ((((u32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
 1011eb6:	f1c0 0308 	rsb	r3, r0, #8
 1011eba:	041b      	lsls	r3, r3, #16
			   ((((u32_t)bits_len) << RADIO_PCNF0_LFLEN_Pos) &
 1011ebc:	f000 000f 	and.w	r0, r0, #15
			    RADIO_PCNF0_S1LEN_Msk) |
 1011ec0:	4320      	orrs	r0, r4
			   ((((u32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
 1011ec2:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
	NRF_RADIO->PCNF0 = (((1UL) << RADIO_PCNF0_S0LEN_Pos) &
 1011ec6:	4a0d      	ldr	r2, [pc, #52]	; (1011efc <radio_pkt_configure+0x64>)
			    RADIO_PCNF0_S1LEN_Msk) |
 1011ec8:	4303      	orrs	r3, r0
 1011eca:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	NRF_RADIO->PCNF0 = (((1UL) << RADIO_PCNF0_S0LEN_Pos) &
 1011ece:	f8c2 3514 	str.w	r3, [r2, #1300]	; 0x514
	NRF_RADIO->PCNF1 &= ~(RADIO_PCNF1_MAXLEN_Msk | RADIO_PCNF1_STATLEN_Msk |
 1011ed2:	f8d2 0518 	ldr.w	r0, [r2, #1304]	; 0x518
 1011ed6:	4b0a      	ldr	r3, [pc, #40]	; (1011f00 <radio_pkt_configure+0x68>)
}
 1011ed8:	bc10      	pop	{r4}
	NRF_RADIO->PCNF1 &= ~(RADIO_PCNF1_MAXLEN_Msk | RADIO_PCNF1_STATLEN_Msk |
 1011eda:	4003      	ands	r3, r0
 1011edc:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((((u32_t)max_len) << RADIO_PCNF1_MAXLEN_Pos) &
 1011ee0:	f8d2 3518 	ldr.w	r3, [r2, #1304]	; 0x518
 1011ee4:	4319      	orrs	r1, r3
 1011ee6:	f441 3140 	orr.w	r1, r1, #196608	; 0x30000
 1011eea:	f8c2 1518 	str.w	r1, [r2, #1304]	; 0x518
}
 1011eee:	4770      	bx	lr
	switch (phy) {
 1011ef0:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
	if (dc) {
 1011ef4:	2a00      	cmp	r2, #0
 1011ef6:	d0de      	beq.n	1011eb6 <radio_pkt_configure+0x1e>
 1011ef8:	e7db      	b.n	1011eb2 <radio_pkt_configure+0x1a>
 1011efa:	bf00      	nop
 1011efc:	41008000 	.word	0x41008000
 1011f00:	fef80000 	.word	0xfef80000

01011f04 <radio_pkt_rx_set>:
	NRF_RADIO->PACKETPTR = (u32_t)rx_packet;
 1011f04:	4b01      	ldr	r3, [pc, #4]	; (1011f0c <radio_pkt_rx_set+0x8>)
 1011f06:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
}
 1011f0a:	4770      	bx	lr
 1011f0c:	41008000 	.word	0x41008000

01011f10 <radio_pkt_tx_set>:
 1011f10:	4b01      	ldr	r3, [pc, #4]	; (1011f18 <radio_pkt_tx_set+0x8>)
 1011f12:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
 1011f16:	4770      	bx	lr
 1011f18:	41008000 	.word	0x41008000

01011f1c <radio_tx_ready_delay_get>:
	switch (phy) {
 1011f1c:	2802      	cmp	r0, #2
 1011f1e:	d004      	beq.n	1011f2a <radio_tx_ready_delay_get+0xe>
 1011f20:	2804      	cmp	r0, #4
			return HAL_RADIO_NRF5340_TXEN_TXIDLE_TX_S8_US;
 1011f22:	bf14      	ite	ne
 1011f24:	2029      	movne	r0, #41	; 0x29
 1011f26:	202a      	moveq	r0, #42	; 0x2a
 1011f28:	4770      	bx	lr
	switch (phy) {
 1011f2a:	2028      	movs	r0, #40	; 0x28
}
 1011f2c:	4770      	bx	lr
 1011f2e:	bf00      	nop

01011f30 <radio_tx_chain_delay_get>:
}
 1011f30:	2001      	movs	r0, #1
 1011f32:	4770      	bx	lr

01011f34 <radio_rx_ready_delay_get>:
}
 1011f34:	2029      	movs	r0, #41	; 0x29
 1011f36:	4770      	bx	lr

01011f38 <radio_rx_chain_delay_get>:
	switch (phy) {
 1011f38:	2802      	cmp	r0, #2
 1011f3a:	d009      	beq.n	1011f50 <radio_rx_chain_delay_get+0x18>
 1011f3c:	2804      	cmp	r0, #4
 1011f3e:	d105      	bne.n	1011f4c <radio_rx_chain_delay_get+0x14>
		if (flags & 0x01) {
 1011f40:	f011 0f01 	tst.w	r1, #1
			return HAL_RADIO_NRF5340_RX_CHAIN_DELAY_S2_US;
 1011f44:	bf14      	ite	ne
 1011f46:	201e      	movne	r0, #30
 1011f48:	2019      	moveq	r0, #25
 1011f4a:	4770      	bx	lr
		return HAL_RADIO_NRF5340_RX_CHAIN_DELAY_1M_US;
 1011f4c:	200a      	movs	r0, #10
}
 1011f4e:	4770      	bx	lr
	switch (phy) {
 1011f50:	2005      	movs	r0, #5
 1011f52:	4770      	bx	lr

01011f54 <radio_rx_enable>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1011f54:	2201      	movs	r2, #1
 1011f56:	4b01      	ldr	r3, [pc, #4]	; (1011f5c <radio_rx_enable+0x8>)
 1011f58:	601a      	str	r2, [r3, #0]
}
 1011f5a:	4770      	bx	lr
 1011f5c:	41008004 	.word	0x41008004

01011f60 <radio_tx_enable>:
 1011f60:	2201      	movs	r2, #1
 1011f62:	4b01      	ldr	r3, [pc, #4]	; (1011f68 <radio_tx_enable+0x8>)
 1011f64:	601a      	str	r2, [r3, #0]
}
 1011f66:	4770      	bx	lr
 1011f68:	41008000 	.word	0x41008000

01011f6c <radio_disable>:
{
 1011f6c:	b430      	push	{r4, r5}
}

NRF_STATIC_INLINE void nrf_dppi_group_disable(NRF_DPPIC_Type *         p_reg,
                                              nrf_dppi_channel_group_t group)
{
    p_reg->TASKS_CHG[(uint32_t) group].DIS = 1;
 1011f6e:	2301      	movs	r3, #1
    p_reg->CHENCLR = mask;
 1011f70:	2520      	movs	r5, #32
	NRF_RADIO->SHORTS = 0;
 1011f72:	2400      	movs	r4, #0
 1011f74:	4a05      	ldr	r2, [pc, #20]	; (1011f8c <radio_disable+0x20>)
 1011f76:	4806      	ldr	r0, [pc, #24]	; (1011f90 <radio_disable+0x24>)
 1011f78:	4906      	ldr	r1, [pc, #24]	; (1011f94 <radio_disable+0x28>)
 1011f7a:	f8c2 5508 	str.w	r5, [r2, #1288]	; 0x508
    p_reg->TASKS_CHG[(uint32_t) group].DIS = 1;
 1011f7e:	6053      	str	r3, [r2, #4]
 1011f80:	60d3      	str	r3, [r2, #12]
 1011f82:	f8c0 4200 	str.w	r4, [r0, #512]	; 0x200
 1011f86:	600b      	str	r3, [r1, #0]
}
 1011f88:	bc30      	pop	{r4, r5}
 1011f8a:	4770      	bx	lr
 1011f8c:	4100f000 	.word	0x4100f000
 1011f90:	41008000 	.word	0x41008000
 1011f94:	41008010 	.word	0x41008010

01011f98 <radio_status_reset>:
	NRF_RADIO->EVENTS_READY = 0;
 1011f98:	2200      	movs	r2, #0
 1011f9a:	4b04      	ldr	r3, [pc, #16]	; (1011fac <radio_status_reset+0x14>)
 1011f9c:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	NRF_RADIO->EVENTS_END = 0;
 1011fa0:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
	NRF_RADIO->EVENTS_DISABLED = 0;
 1011fa4:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
}
 1011fa8:	4770      	bx	lr
 1011faa:	bf00      	nop
 1011fac:	41008000 	.word	0x41008000

01011fb0 <radio_is_ready>:
	return (NRF_RADIO->EVENTS_READY != 0);
 1011fb0:	4b03      	ldr	r3, [pc, #12]	; (1011fc0 <radio_is_ready+0x10>)
 1011fb2:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
}
 1011fb6:	3800      	subs	r0, #0
 1011fb8:	bf18      	it	ne
 1011fba:	2001      	movne	r0, #1
 1011fbc:	4770      	bx	lr
 1011fbe:	bf00      	nop
 1011fc0:	41008000 	.word	0x41008000

01011fc4 <radio_is_done>:
	return (NRF_RADIO->EVENTS_END != 0);
 1011fc4:	4b03      	ldr	r3, [pc, #12]	; (1011fd4 <radio_is_done+0x10>)
 1011fc6:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
}
 1011fca:	3800      	subs	r0, #0
 1011fcc:	bf18      	it	ne
 1011fce:	2001      	movne	r0, #1
 1011fd0:	4770      	bx	lr
 1011fd2:	bf00      	nop
 1011fd4:	41008000 	.word	0x41008000

01011fd8 <radio_is_idle>:
	return (NRF_RADIO->STATE == 0);
 1011fd8:	4b03      	ldr	r3, [pc, #12]	; (1011fe8 <radio_is_idle+0x10>)
 1011fda:	f8d3 0550 	ldr.w	r0, [r3, #1360]	; 0x550
}
 1011fde:	fab0 f080 	clz	r0, r0
 1011fe2:	0940      	lsrs	r0, r0, #5
 1011fe4:	4770      	bx	lr
 1011fe6:	bf00      	nop
 1011fe8:	41008000 	.word	0x41008000

01011fec <radio_crc_configure>:
	NRF_RADIO->CRCCNF =
 1011fec:	f240 1203 	movw	r2, #259	; 0x103
 1011ff0:	4b03      	ldr	r3, [pc, #12]	; (1012000 <radio_crc_configure+0x14>)
 1011ff2:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
	NRF_RADIO->CRCPOLY = polynomial;
 1011ff6:	f8c3 0538 	str.w	r0, [r3, #1336]	; 0x538
	NRF_RADIO->CRCINIT = iv;
 1011ffa:	f8c3 153c 	str.w	r1, [r3, #1340]	; 0x53c
}
 1011ffe:	4770      	bx	lr
 1012000:	41008000 	.word	0x41008000

01012004 <radio_crc_is_valid>:
	return (NRF_RADIO->CRCSTATUS != 0);
 1012004:	4b03      	ldr	r3, [pc, #12]	; (1012014 <radio_crc_is_valid+0x10>)
 1012006:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
 101200a:	3800      	subs	r0, #0
 101200c:	bf18      	it	ne
 101200e:	2001      	movne	r0, #1
 1012010:	4770      	bx	lr
 1012012:	bf00      	nop
 1012014:	41008000 	.word	0x41008000

01012018 <radio_pkt_empty_get>:
}
 1012018:	4800      	ldr	r0, [pc, #0]	; (101201c <radio_pkt_empty_get+0x4>)
 101201a:	4770      	bx	lr
 101201c:	210057b0 	.word	0x210057b0

01012020 <radio_pkt_scratch_get>:
}
 1012020:	4800      	ldr	r0, [pc, #0]	; (1012024 <radio_pkt_scratch_get+0x4>)
 1012022:	4770      	bx	lr
 1012024:	210057b4 	.word	0x210057b4

01012028 <radio_switch_complete_and_rx>:
#endif /* CONFIG_BT_CTLR_TIFS_HW */

void radio_switch_complete_and_rx(u8_t phy_rx)
{
 1012028:	b410      	push	{r4}
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_RXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk;
	sw_switch(0, 0, 0, phy_rx, 0);
 101202a:	2100      	movs	r1, #0
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
 101202c:	2403      	movs	r4, #3
 101202e:	4b04      	ldr	r3, [pc, #16]	; (1012040 <radio_switch_complete_and_rx+0x18>)
{
 1012030:	4602      	mov	r2, r0
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
 1012032:	f8c3 4200 	str.w	r4, [r3, #512]	; 0x200
	sw_switch(0, 0, 0, phy_rx, 0);
 1012036:	4608      	mov	r0, r1
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
 1012038:	bc10      	pop	{r4}
	sw_switch(0, 0, 0, phy_rx, 0);
 101203a:	f7ff bda3 	b.w	1011b84 <sw_switch.isra.0>
 101203e:	bf00      	nop
 1012040:	41008000 	.word	0x41008000

01012044 <radio_switch_complete_and_tx>:

void radio_switch_complete_and_tx(u8_t phy_rx, u8_t flags_rx, u8_t phy_tx,
				  u8_t flags_tx)
{
 1012044:	b410      	push	{r4}
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_TXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
 1012046:	2403      	movs	r4, #3
 1012048:	4b03      	ldr	r3, [pc, #12]	; (1012058 <radio_switch_complete_and_tx+0x14>)
{
 101204a:	4601      	mov	r1, r0
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
 101204c:	f8c3 4200 	str.w	r4, [r3, #512]	; 0x200
			    RADIO_SHORTS_END_DISABLE_Msk;
	sw_switch(1, phy_rx, flags_rx, phy_tx, flags_tx);
 1012050:	2001      	movs	r0, #1
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
 1012052:	bc10      	pop	{r4}
	sw_switch(1, phy_rx, flags_rx, phy_tx, flags_tx);
 1012054:	f7ff bd96 	b.w	1011b84 <sw_switch.isra.0>
 1012058:	41008000 	.word	0x41008000

0101205c <radio_switch_complete_and_disable>:

void radio_switch_complete_and_disable(void)
{
 101205c:	b410      	push	{r4}
	HAL_SW_SWITCH_TIMER_CLEAR_PPI_REGISTER_TASK = 0;
 101205e:	2300      	movs	r3, #0
	NRF_RADIO->SHORTS =
 1012060:	2403      	movs	r4, #3
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(0) = 0;
 1012062:	4a06      	ldr	r2, [pc, #24]	; (101207c <radio_switch_complete_and_disable+0x20>)
 1012064:	4806      	ldr	r0, [pc, #24]	; (1012080 <radio_switch_complete_and_disable+0x24>)
	HAL_SW_SWITCH_TIMER_CLEAR_PPI_REGISTER_TASK = 0;
 1012066:	4907      	ldr	r1, [pc, #28]	; (1012084 <radio_switch_complete_and_disable+0x28>)
 1012068:	f8c0 4200 	str.w	r4, [r0, #512]	; 0x200
 101206c:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
	    (RADIO_SHORTS_READY_START_Msk | RADIO_SHORTS_END_DISABLE_Msk);

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	hal_radio_sw_switch_disable();
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
 1012070:	bc10      	pop	{r4}
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(0) = 0;
 1012072:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(1) = 0;
 1012076:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
 101207a:	4770      	bx	lr
 101207c:	4100f000 	.word	0x4100f000
 1012080:	41008000 	.word	0x41008000
 1012084:	41018000 	.word	0x41018000

01012088 <radio_rssi_measure>:

void radio_rssi_measure(void)
{
	NRF_RADIO->SHORTS |=
 1012088:	4a03      	ldr	r2, [pc, #12]	; (1012098 <radio_rssi_measure+0x10>)
 101208a:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
 101208e:	f443 7388 	orr.w	r3, r3, #272	; 0x110
 1012092:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
	    (RADIO_SHORTS_ADDRESS_RSSISTART_Msk |
	     RADIO_SHORTS_DISABLED_RSSISTOP_Msk);
}
 1012096:	4770      	bx	lr
 1012098:	41008000 	.word	0x41008000

0101209c <radio_rssi_get>:

u32_t radio_rssi_get(void)
{
	return NRF_RADIO->RSSISAMPLE;
 101209c:	4b01      	ldr	r3, [pc, #4]	; (10120a4 <radio_rssi_get+0x8>)
 101209e:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
}
 10120a2:	4770      	bx	lr
 10120a4:	41008000 	.word	0x41008000

010120a8 <radio_rssi_status_reset>:

void radio_rssi_status_reset(void)
{
	NRF_RADIO->EVENTS_RSSIEND = 0;
 10120a8:	2200      	movs	r2, #0
 10120aa:	4b02      	ldr	r3, [pc, #8]	; (10120b4 <radio_rssi_status_reset+0xc>)
 10120ac:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
}
 10120b0:	4770      	bx	lr
 10120b2:	bf00      	nop
 10120b4:	41008000 	.word	0x41008000

010120b8 <radio_rssi_is_ready>:

u32_t radio_rssi_is_ready(void)
{
	return (NRF_RADIO->EVENTS_RSSIEND != 0);
 10120b8:	4b03      	ldr	r3, [pc, #12]	; (10120c8 <radio_rssi_is_ready+0x10>)
 10120ba:	f8d3 011c 	ldr.w	r0, [r3, #284]	; 0x11c
}
 10120be:	3800      	subs	r0, #0
 10120c0:	bf18      	it	ne
 10120c2:	2001      	movne	r0, #1
 10120c4:	4770      	bx	lr
 10120c6:	bf00      	nop
 10120c8:	41008000 	.word	0x41008000

010120cc <radio_filter_configure>:

void radio_filter_configure(u8_t bitmask_enable, u8_t bitmask_addr_type,
			    u8_t *bdaddr)
{
 10120cc:	b430      	push	{r4, r5}
 10120ce:	2400      	movs	r4, #0
	u8_t index;

	for (index = 0U; index < 8; index++) {
		NRF_RADIO->DAB[index] = ((u32_t)bdaddr[3] << 24) |
 10120d0:	00a3      	lsls	r3, r4, #2
			((u32_t)bdaddr[2] << 16) |
			((u32_t)bdaddr[1] << 8) |
 10120d2:	6815      	ldr	r5, [r2, #0]
 10120d4:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
 10120d8:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
		NRF_RADIO->DAB[index] = ((u32_t)bdaddr[3] << 24) |
 10120dc:	f8c3 5600 	str.w	r5, [r3, #1536]	; 0x600
			bdaddr[0];
		NRF_RADIO->DAP[index] = ((u32_t)bdaddr[5] << 8) | bdaddr[4];
 10120e0:	8895      	ldrh	r5, [r2, #4]
 10120e2:	3401      	adds	r4, #1
	for (index = 0U; index < 8; index++) {
 10120e4:	2c08      	cmp	r4, #8
		NRF_RADIO->DAP[index] = ((u32_t)bdaddr[5] << 8) | bdaddr[4];
 10120e6:	f8c3 5620 	str.w	r5, [r3, #1568]	; 0x620
		bdaddr += 6;
 10120ea:	f102 0206 	add.w	r2, r2, #6
	for (index = 0U; index < 8; index++) {
 10120ee:	d1ef      	bne.n	10120d0 <radio_filter_configure+0x4>
	}

	NRF_RADIO->DACNF = ((u32_t)bitmask_addr_type << 8) | bitmask_enable;
}
 10120f0:	bc30      	pop	{r4, r5}
	NRF_RADIO->DACNF = ((u32_t)bitmask_addr_type << 8) | bitmask_enable;
 10120f2:	4b03      	ldr	r3, [pc, #12]	; (1012100 <radio_filter_configure+0x34>)
 10120f4:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
 10120f8:	f8c3 0640 	str.w	r0, [r3, #1600]	; 0x640
}
 10120fc:	4770      	bx	lr
 10120fe:	bf00      	nop
 1012100:	41008000 	.word	0x41008000

01012104 <radio_filter_disable>:

void radio_filter_disable(void)
{
	NRF_RADIO->DACNF &= ~(0x000000FF);
 1012104:	4a03      	ldr	r2, [pc, #12]	; (1012114 <radio_filter_disable+0x10>)
 1012106:	f8d2 3640 	ldr.w	r3, [r2, #1600]	; 0x640
 101210a:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 101210e:	f8c2 3640 	str.w	r3, [r2, #1600]	; 0x640
}
 1012112:	4770      	bx	lr
 1012114:	41008000 	.word	0x41008000

01012118 <radio_filter_status_reset>:

void radio_filter_status_reset(void)
{
	NRF_RADIO->EVENTS_DEVMATCH = 0;
 1012118:	2200      	movs	r2, #0
 101211a:	4b02      	ldr	r3, [pc, #8]	; (1012124 <radio_filter_status_reset+0xc>)
 101211c:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
 1012120:	4770      	bx	lr
 1012122:	bf00      	nop
 1012124:	41008000 	.word	0x41008000

01012128 <radio_filter_has_match>:

u32_t radio_filter_has_match(void)
{
	return (NRF_RADIO->EVENTS_DEVMATCH != 0);
 1012128:	4b03      	ldr	r3, [pc, #12]	; (1012138 <radio_filter_has_match+0x10>)
 101212a:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
}
 101212e:	3800      	subs	r0, #0
 1012130:	bf18      	it	ne
 1012132:	2001      	movne	r0, #1
 1012134:	4770      	bx	lr
 1012136:	bf00      	nop
 1012138:	41008000 	.word	0x41008000

0101213c <radio_filter_match_get>:

u32_t radio_filter_match_get(void)
{
	return NRF_RADIO->DAI;
 101213c:	4b01      	ldr	r3, [pc, #4]	; (1012144 <radio_filter_match_get+0x8>)
 101213e:	f8d3 0410 	ldr.w	r0, [r3, #1040]	; 0x410
}
 1012142:	4770      	bx	lr
 1012144:	41008000 	.word	0x41008000

01012148 <radio_tmr_status_reset>:
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
 1012148:	f44f 2080 	mov.w	r0, #262144	; 0x40000
    p_reg->CHENCLR = mask;
 101214c:	f242 023f 	movw	r2, #8255	; 0x203f
 1012150:	4903      	ldr	r1, [pc, #12]	; (1012160 <radio_tmr_status_reset+0x18>)
 1012152:	4b04      	ldr	r3, [pc, #16]	; (1012164 <radio_tmr_status_reset+0x1c>)
 1012154:	f8c1 0348 	str.w	r0, [r1, #840]	; 0x348
 1012158:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
			BIT(HAL_SW_SWITCH_TIMER_S8_DISABLE_PPI) |
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
			BIT(HAL_TRIGGER_CRYPT_PPI));
}
 101215c:	4770      	bx	lr
 101215e:	bf00      	nop
 1012160:	41011000 	.word	0x41011000
 1012164:	4100f000 	.word	0x4100f000

01012168 <radio_tmr_tifs_set>:
void radio_tmr_tifs_set(u32_t tifs)
{
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->TIFS = tifs;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	nrf_timer_cc_set(SW_SWITCH_TIMER,
 1012168:	4b03      	ldr	r3, [pc, #12]	; (1012178 <radio_tmr_tifs_set+0x10>)
    p_reg->CC[cc_channel] = cc_value;
 101216a:	4a04      	ldr	r2, [pc, #16]	; (101217c <radio_tmr_tifs_set+0x14>)
 101216c:	781b      	ldrb	r3, [r3, #0]
 101216e:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 1012172:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
			 SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle), tifs);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
 1012176:	4770      	bx	lr
 1012178:	210080ce 	.word	0x210080ce
 101217c:	41018000 	.word	0x41018000

01012180 <radio_tmr_start>:

u32_t radio_tmr_start(u8_t trx, u32_t ticks_start, u32_t remainder)
{
 1012180:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if ((!(remainder / 1000000UL)) || (remainder & 0x80000000)) {
 1012184:	f5a2 2374 	sub.w	r3, r2, #999424	; 0xf4000
 1012188:	4d2c      	ldr	r5, [pc, #176]	; (101223c <radio_tmr_start+0xbc>)
 101218a:	f5a3 7310 	sub.w	r3, r3, #576	; 0x240
 101218e:	42ab      	cmp	r3, r5
{
 1012190:	4604      	mov	r4, r0
	if ((!(remainder / 1000000UL)) || (remainder & 0x80000000)) {
 1012192:	d906      	bls.n	10121a2 <radio_tmr_start+0x22>
		ticks_start--;
		remainder += 30517578UL;
 1012194:	f102 72e8 	add.w	r2, r2, #30408704	; 0x1d00000
 1012198:	f502 32d4 	add.w	r2, r2, #108544	; 0x1a800
 101219c:	f502 72a5 	add.w	r2, r2, #330	; 0x14a
		ticks_start--;
 10121a0:	3901      	subs	r1, #1
	remainder /= 1000000UL;

	nrf_timer_task_trigger(EVENT_TIMER, NRF_TIMER_TASK_CLEAR);
	EVENT_TIMER->MODE = 0;
	EVENT_TIMER->PRESCALER = 4;
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
 10121a2:	2602      	movs	r6, #2
    p_reg->EVTENSET = mask;
 10121a4:	f44f 2780 	mov.w	r7, #262144	; 0x40000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 10121a8:	f04f 0801 	mov.w	r8, #1
	EVENT_TIMER->MODE = 0;
 10121ac:	f04f 0e00 	mov.w	lr, #0
	EVENT_TIMER->PRESCALER = 4;
 10121b0:	f04f 0c04 	mov.w	ip, #4
	HAL_RADIO_ENABLE_ON_TICK_PPI_REGISTER_EVT =
 10121b4:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
	remainder /= 1000000UL;
 10121b8:	4821      	ldr	r0, [pc, #132]	; (1012240 <radio_tmr_start+0xc0>)
 10121ba:	4b22      	ldr	r3, [pc, #136]	; (1012244 <radio_tmr_start+0xc4>)
 10121bc:	fba0 0202 	umull	r0, r2, r0, r2
 10121c0:	0c90      	lsrs	r0, r2, #18
    p_reg->CC[ch] = cc_val;
 10121c2:	4a21      	ldr	r2, [pc, #132]	; (1012248 <radio_tmr_start+0xc8>)
 10121c4:	f8c3 8000 	str.w	r8, [r3]
	EVENT_TIMER->MODE = 0;
 10121c8:	f8c3 e4f8 	str.w	lr, [r3, #1272]	; 0x4f8
	EVENT_TIMER->PRESCALER = 4;
 10121cc:	f8c3 c504 	str.w	ip, [r3, #1284]	; 0x504
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
 10121d0:	f8c3 64fc 	str.w	r6, [r3, #1276]	; 0x4fc
    p_reg->CC[cc_channel] = cc_value;
 10121d4:	f8c3 0534 	str.w	r0, [r3, #1332]	; 0x534
 10121d8:	f8c2 1548 	str.w	r1, [r2, #1352]	; 0x548
    p_reg->EVTENSET = mask;
 10121dc:	f8c2 7344 	str.w	r7, [r2, #836]	; 0x344
	HAL_EVENT_TIMER_START_PPI_REGISTER_EVT =
 10121e0:	491a      	ldr	r1, [pc, #104]	; (101224c <radio_tmr_start+0xcc>)
    p_reg->CHENSET = mask;
 10121e2:	4f1b      	ldr	r7, [pc, #108]	; (1012250 <radio_tmr_start+0xd0>)
 10121e4:	f8c2 11c8 	str.w	r1, [r2, #456]	; 0x1c8
	EVENT_TIMER->MODE = 0;
 10121e8:	3b0c      	subs	r3, #12
	HAL_EVENT_TIMER_START_PPI_REGISTER_TASK =
 10121ea:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
 10121ee:	f8c7 6504 	str.w	r6, [r7, #1284]	; 0x504
	HAL_RADIO_ENABLE_ON_TICK_PPI_REGISTER_EVT =
 10121f2:	f8c3 51c0 	str.w	r5, [r3, #448]	; 0x1c0
	if (trx) {
 10121f6:	b1e4      	cbz	r4, 1012232 <radio_tmr_start+0xb2>
		HAL_RADIO_ENABLE_ON_TICK_PPI_REGISTER_TASK_TX =
 10121f8:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
 10121fc:	f8c3 5080 	str.w	r5, [r3, #128]	; 0x80
 1012200:	2201      	movs	r2, #1
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	last_pdu_end_us = 0U;

#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_CLEAR);
	SW_SWITCH_TIMER->MODE = 0;
 1012202:	2400      	movs	r4, #0
	SW_SWITCH_TIMER->PRESCALER = 4;
 1012204:	2604      	movs	r6, #4
 1012206:	4b12      	ldr	r3, [pc, #72]	; (1012250 <radio_tmr_start+0xd0>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1012208:	4912      	ldr	r1, [pc, #72]	; (1012254 <radio_tmr_start+0xd4>)
 101220a:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	HAL_SW_SWITCH_TIMER_CLEAR_PPI_REGISTER_EVT =
 101220e:	4d12      	ldr	r5, [pc, #72]	; (1012258 <radio_tmr_start+0xd8>)
 1012210:	600a      	str	r2, [r1, #0]
 1012212:	4912      	ldr	r1, [pc, #72]	; (101225c <radio_tmr_start+0xdc>)
	SW_SWITCH_TIMER->MODE = 0;
 1012214:	f503 4310 	add.w	r3, r3, #36864	; 0x9000
 1012218:	f8c3 4504 	str.w	r4, [r3, #1284]	; 0x504
	SW_SWITCH_TIMER->PRESCALER = 4;
 101221c:	f8c3 6510 	str.w	r6, [r3, #1296]	; 0x510
	SW_SWITCH_TIMER->BITMODE = 0; /* 16 bit */
 1012220:	f8c3 4508 	str.w	r4, [r3, #1288]	; 0x508
 1012224:	601a      	str	r2, [r3, #0]
 1012226:	f8c5 118c 	str.w	r1, [r5, #396]	; 0x18c
	HAL_SW_SWITCH_TIMER_CLEAR_PPI_REGISTER_TASK =
 101222a:	f8c3 108c 	str.w	r1, [r3, #140]	; 0x8c
	 */
#endif /* CONFIG_BT_CTLR_PHY_CODED && CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	return remainder;
}
 101222e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		HAL_RADIO_ENABLE_ON_TICK_PPI_REGISTER_TASK_RX =
 1012232:	4b09      	ldr	r3, [pc, #36]	; (1012258 <radio_tmr_start+0xd8>)
 1012234:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
 1012238:	e7e2      	b.n	1012200 <radio_tmr_start+0x80>
 101223a:	bf00      	nop
 101223c:	7ff0bdbf 	.word	0x7ff0bdbf
 1012240:	431bde83 	.word	0x431bde83
 1012244:	4100c00c 	.word	0x4100c00c
 1012248:	41011000 	.word	0x41011000
 101224c:	80000001 	.word	0x80000001
 1012250:	4100f000 	.word	0x4100f000
 1012254:	4101800c 	.word	0x4101800c
 1012258:	41008000 	.word	0x41008000
 101225c:	80000005 	.word	0x80000005

01012260 <radio_tmr_start_tick>:

u32_t radio_tmr_start_tick(u8_t trx, u32_t tick)
{
 1012260:	b4f0      	push	{r4, r5, r6, r7}
 1012262:	2401      	movs	r4, #1
 1012264:	f44f 2780 	mov.w	r7, #262144	; 0x40000
 1012268:	2602      	movs	r6, #2
	HAL_RADIO_ENABLE_ON_TICK_PPI_REGISTER_EVT =
 101226a:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
 101226e:	4a12      	ldr	r2, [pc, #72]	; (10122b8 <radio_tmr_start_tick+0x58>)
 1012270:	4b12      	ldr	r3, [pc, #72]	; (10122bc <radio_tmr_start_tick+0x5c>)
 1012272:	6014      	str	r4, [r2, #0]
    p_reg->CC[ch] = cc_val;
 1012274:	4a12      	ldr	r2, [pc, #72]	; (10122c0 <radio_tmr_start_tick+0x60>)
 1012276:	601c      	str	r4, [r3, #0]
    p_reg->CC[cc_channel] = cc_value;
 1012278:	f8c3 4534 	str.w	r4, [r3, #1332]	; 0x534
 101227c:	f8c2 1548 	str.w	r1, [r2, #1352]	; 0x548
 1012280:	4c10      	ldr	r4, [pc, #64]	; (10122c4 <radio_tmr_start_tick+0x64>)
	HAL_EVENT_TIMER_START_PPI_REGISTER_EVT =
 1012282:	4911      	ldr	r1, [pc, #68]	; (10122c8 <radio_tmr_start_tick+0x68>)
    p_reg->EVTENSET = mask;
 1012284:	f8c2 7344 	str.w	r7, [r2, #836]	; 0x344
 1012288:	f8c2 11c8 	str.w	r1, [r2, #456]	; 0x1c8
	HAL_EVENT_TIMER_START_PPI_REGISTER_TASK =
 101228c:	6759      	str	r1, [r3, #116]	; 0x74
 101228e:	f8c4 6504 	str.w	r6, [r4, #1284]	; 0x504
	HAL_RADIO_ENABLE_ON_TICK_PPI_REGISTER_EVT =
 1012292:	f8c3 51b4 	str.w	r5, [r3, #436]	; 0x1b4
	if (trx) {
 1012296:	b150      	cbz	r0, 10122ae <radio_tmr_start_tick+0x4e>
 1012298:	3b0c      	subs	r3, #12
		HAL_RADIO_ENABLE_ON_TICK_PPI_REGISTER_TASK_TX =
 101229a:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
 101229e:	f8c3 5080 	str.w	r5, [r3, #128]	; 0x80
 10122a2:	2001      	movs	r0, #1
	last_pdu_end_us = 0U;
#endif /* CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	return remainder_us;
}
 10122a4:	bcf0      	pop	{r4, r5, r6, r7}
 10122a6:	4b07      	ldr	r3, [pc, #28]	; (10122c4 <radio_tmr_start_tick+0x64>)
 10122a8:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
 10122ac:	4770      	bx	lr
		HAL_RADIO_ENABLE_ON_TICK_PPI_REGISTER_TASK_RX =
 10122ae:	4b07      	ldr	r3, [pc, #28]	; (10122cc <radio_tmr_start_tick+0x6c>)
 10122b0:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
 10122b4:	e7f5      	b.n	10122a2 <radio_tmr_start_tick+0x42>
 10122b6:	bf00      	nop
 10122b8:	4100c004 	.word	0x4100c004
 10122bc:	4100c00c 	.word	0x4100c00c
 10122c0:	41011000 	.word	0x41011000
 10122c4:	4100f000 	.word	0x4100f000
 10122c8:	80000001 	.word	0x80000001
 10122cc:	41008000 	.word	0x41008000

010122d0 <radio_tmr_start_get>:
    return p_reg->CC[ch];
 10122d0:	4b01      	ldr	r3, [pc, #4]	; (10122d8 <radio_tmr_start_get+0x8>)
 10122d2:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
}

u32_t radio_tmr_start_get(void)
{
	return nrf_rtc_cc_get(NRF_RTC0, 2);
}
 10122d6:	4770      	bx	lr
 10122d8:	41011000 	.word	0x41011000

010122dc <radio_tmr_stop>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 10122dc:	2301      	movs	r3, #1

void radio_tmr_stop(void)
{
 10122de:	b410      	push	{r4}
 10122e0:	4804      	ldr	r0, [pc, #16]	; (10122f4 <radio_tmr_stop+0x18>)
 10122e2:	4c05      	ldr	r4, [pc, #20]	; (10122f8 <radio_tmr_stop+0x1c>)
 10122e4:	4905      	ldr	r1, [pc, #20]	; (10122fc <radio_tmr_stop+0x20>)
 10122e6:	4a06      	ldr	r2, [pc, #24]	; (1012300 <radio_tmr_stop+0x24>)
 10122e8:	6023      	str	r3, [r4, #0]
 10122ea:	6003      	str	r3, [r0, #0]

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_STOP);
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_SHUTDOWN);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
 10122ec:	bc10      	pop	{r4}
 10122ee:	600b      	str	r3, [r1, #0]
 10122f0:	6013      	str	r3, [r2, #0]
 10122f2:	4770      	bx	lr
 10122f4:	4100c010 	.word	0x4100c010
 10122f8:	4100c004 	.word	0x4100c004
 10122fc:	41018004 	.word	0x41018004
 1012300:	41018010 	.word	0x41018010

01012304 <radio_tmr_hcto_configure>:

void radio_tmr_hcto_configure(u32_t hcto)
{
 1012304:	b430      	push	{r4, r5}
 1012306:	2518      	movs	r5, #24
    p_reg->CC[cc_channel] = cc_value;
 1012308:	4b09      	ldr	r3, [pc, #36]	; (1012330 <radio_tmr_hcto_configure+0x2c>)
	HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI_REGISTER_EVT =
 101230a:	4c0a      	ldr	r4, [pc, #40]	; (1012334 <radio_tmr_hcto_configure+0x30>)
 101230c:	f8c3 0544 	str.w	r0, [r3, #1348]	; 0x544
 1012310:	4a09      	ldr	r2, [pc, #36]	; (1012338 <radio_tmr_hcto_configure+0x34>)
	HAL_RADIO_DISABLE_ON_HCTO_PPI_REGISTER_EVT =
 1012312:	490a      	ldr	r1, [pc, #40]	; (101233c <radio_tmr_hcto_configure+0x38>)
 1012314:	480a      	ldr	r0, [pc, #40]	; (1012340 <radio_tmr_hcto_configure+0x3c>)
	HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI_REGISTER_EVT =
 1012316:	f8c2 4184 	str.w	r4, [r2, #388]	; 0x184
	HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI_REGISTER_TASK =
 101231a:	f8c3 40c4 	str.w	r4, [r3, #196]	; 0xc4
	HAL_RADIO_DISABLE_ON_HCTO_PPI_REGISTER_EVT =
 101231e:	f8c3 11c4 	str.w	r1, [r3, #452]	; 0x1c4
	HAL_RADIO_DISABLE_ON_HCTO_PPI_REGISTER_TASK =
 1012322:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
 1012326:	f8c0 5504 	str.w	r5, [r0, #1284]	; 0x504
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_disable_on_hcto_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI) |
		BIT(HAL_RADIO_DISABLE_ON_HCTO_PPI));
}
 101232a:	bc30      	pop	{r4, r5}
 101232c:	4770      	bx	lr
 101232e:	bf00      	nop
 1012330:	4100c000 	.word	0x4100c000
 1012334:	80000003 	.word	0x80000003
 1012338:	41008000 	.word	0x41008000
 101233c:	80000004 	.word	0x80000004
 1012340:	4100f000 	.word	0x4100f000

01012344 <radio_tmr_aa_capture>:

void radio_tmr_aa_capture(void)
{
 1012344:	b430      	push	{r4, r5}
 1012346:	250c      	movs	r5, #12
	HAL_RADIO_READY_TIME_CAPTURE_PPI_REGISTER_EVT =
 1012348:	4908      	ldr	r1, [pc, #32]	; (101236c <radio_tmr_aa_capture+0x28>)
 101234a:	4809      	ldr	r0, [pc, #36]	; (1012370 <radio_tmr_aa_capture+0x2c>)
	HAL_RADIO_READY_TIME_CAPTURE_PPI_REGISTER_TASK =
 101234c:	4b09      	ldr	r3, [pc, #36]	; (1012374 <radio_tmr_aa_capture+0x30>)
	HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI_REGISTER_EVT =
 101234e:	4a0a      	ldr	r2, [pc, #40]	; (1012378 <radio_tmr_aa_capture+0x34>)
 1012350:	4c0a      	ldr	r4, [pc, #40]	; (101237c <radio_tmr_aa_capture+0x38>)
	HAL_RADIO_READY_TIME_CAPTURE_PPI_REGISTER_EVT =
 1012352:	f8c1 0180 	str.w	r0, [r1, #384]	; 0x180
	HAL_RADIO_READY_TIME_CAPTURE_PPI_REGISTER_TASK =
 1012356:	f8c3 00c0 	str.w	r0, [r3, #192]	; 0xc0
	HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI_REGISTER_EVT =
 101235a:	f8c1 2184 	str.w	r2, [r1, #388]	; 0x184
	HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI_REGISTER_TASK =
 101235e:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
 1012362:	f8c4 5504 	str.w	r5, [r4, #1284]	; 0x504
	hal_radio_ready_time_capture_ppi_config();
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_READY_TIME_CAPTURE_PPI) |
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI));
}
 1012366:	bc30      	pop	{r4, r5}
 1012368:	4770      	bx	lr
 101236a:	bf00      	nop
 101236c:	41008000 	.word	0x41008000
 1012370:	80000002 	.word	0x80000002
 1012374:	4100c000 	.word	0x4100c000
 1012378:	80000003 	.word	0x80000003
 101237c:	4100f000 	.word	0x4100f000

01012380 <radio_tmr_aa_get>:

u32_t radio_tmr_aa_get(void)
{
	return EVENT_TIMER->CC[1];
 1012380:	4b01      	ldr	r3, [pc, #4]	; (1012388 <radio_tmr_aa_get+0x8>)
 1012382:	f8d3 0544 	ldr.w	r0, [r3, #1348]	; 0x544
}
 1012386:	4770      	bx	lr
 1012388:	4100c000 	.word	0x4100c000

0101238c <radio_tmr_aa_save>:

static u32_t radio_tmr_aa;

void radio_tmr_aa_save(u32_t aa)
{
	radio_tmr_aa = aa;
 101238c:	4b01      	ldr	r3, [pc, #4]	; (1012394 <radio_tmr_aa_save+0x8>)
 101238e:	6018      	str	r0, [r3, #0]
}
 1012390:	4770      	bx	lr
 1012392:	bf00      	nop
 1012394:	210058c0 	.word	0x210058c0

01012398 <radio_tmr_aa_restore>:

u32_t radio_tmr_aa_restore(void)
{
	/* NOTE: we dont need to restore for now, but return the saved value. */
	return radio_tmr_aa;
 1012398:	4b01      	ldr	r3, [pc, #4]	; (10123a0 <radio_tmr_aa_restore+0x8>)
}
 101239a:	6818      	ldr	r0, [r3, #0]
 101239c:	4770      	bx	lr
 101239e:	bf00      	nop
 10123a0:	210058c0 	.word	0x210058c0

010123a4 <radio_tmr_ready_get>:

u32_t radio_tmr_ready_get(void)
{
	return EVENT_TIMER->CC[0];
 10123a4:	4b01      	ldr	r3, [pc, #4]	; (10123ac <radio_tmr_ready_get+0x8>)
 10123a6:	f8d3 0540 	ldr.w	r0, [r3, #1344]	; 0x540
}
 10123aa:	4770      	bx	lr
 10123ac:	4100c000 	.word	0x4100c000

010123b0 <radio_tmr_end_capture>:
 10123b0:	2120      	movs	r1, #32

void radio_tmr_end_capture(void)
{
 10123b2:	b410      	push	{r4}
	HAL_RADIO_END_TIME_CAPTURE_PPI_REGISTER_EVT =
 10123b4:	4b05      	ldr	r3, [pc, #20]	; (10123cc <radio_tmr_end_capture+0x1c>)
 10123b6:	4c06      	ldr	r4, [pc, #24]	; (10123d0 <radio_tmr_end_capture+0x20>)
	HAL_RADIO_END_TIME_CAPTURE_PPI_REGISTER_TASK =
 10123b8:	4806      	ldr	r0, [pc, #24]	; (10123d4 <radio_tmr_end_capture+0x24>)
 10123ba:	4a07      	ldr	r2, [pc, #28]	; (10123d8 <radio_tmr_end_capture+0x28>)
	HAL_RADIO_END_TIME_CAPTURE_PPI_REGISTER_EVT =
 10123bc:	f8c4 318c 	str.w	r3, [r4, #396]	; 0x18c
	HAL_RADIO_END_TIME_CAPTURE_PPI_REGISTER_TASK =
 10123c0:	f8c0 30c8 	str.w	r3, [r0, #200]	; 0xc8
	hal_radio_end_time_capture_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_RADIO_END_TIME_CAPTURE_PPI));
}
 10123c4:	bc10      	pop	{r4}
 10123c6:	f8c2 1504 	str.w	r1, [r2, #1284]	; 0x504
 10123ca:	4770      	bx	lr
 10123cc:	80000005 	.word	0x80000005
 10123d0:	41008000 	.word	0x41008000
 10123d4:	4100c000 	.word	0x4100c000
 10123d8:	4100f000 	.word	0x4100f000

010123dc <radio_tmr_end_get>:
u32_t radio_tmr_end_get(void)
{
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	return last_pdu_end_us;
#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	return EVENT_TIMER->CC[2];
 10123dc:	4b01      	ldr	r3, [pc, #4]	; (10123e4 <radio_tmr_end_get+0x8>)
 10123de:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
#endif /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
}
 10123e2:	4770      	bx	lr
 10123e4:	4100c000 	.word	0x4100c000

010123e8 <radio_tmr_tifs_base_get>:
 10123e8:	4b01      	ldr	r3, [pc, #4]	; (10123f0 <radio_tmr_tifs_base_get+0x8>)
 10123ea:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
 10123ee:	4770      	bx	lr
 10123f0:	4100c000 	.word	0x4100c000

010123f4 <radio_ccm_rx_pkt_set>:
#endif /* CONFIG_BT_CTLR_GPIO_PA_PIN || CONFIG_BT_CTLR_GPIO_LNA_PIN */

static u8_t MALIGN(4) _ccm_scratch[(HAL_RADIO_PDU_LEN_MAX - 4) + 16];

void *radio_ccm_rx_pkt_set(struct ccm *ccm, u8_t phy, void *pkt)
{
 10123f4:	b4f0      	push	{r4, r5, r6, r7}
	u32_t mode;

	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
 10123f6:	2402      	movs	r4, #2
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
 10123f8:	2500      	movs	r5, #0
 10123fa:	4b1f      	ldr	r3, [pc, #124]	; (1012478 <radio_ccm_rx_pkt_set+0x84>)
	/* Enable CCM support for 8-bit length field PDUs. */
	mode |= (CCM_MODE_LENGTH_Extended << CCM_MODE_LENGTH_Pos) &
		CCM_MODE_LENGTH_Msk;

	/* Select CCM data rate based on current PHY in use. */
	switch (phy) {
 10123fc:	42a1      	cmp	r1, r4
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
 10123fe:	f8c3 5500 	str.w	r5, [r3, #1280]	; 0x500
{
 1012402:	4606      	mov	r6, r0
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
 1012404:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500
	switch (phy) {
 1012408:	d034      	beq.n	1012474 <radio_ccm_rx_pkt_set+0x80>
 101240a:	2904      	cmp	r1, #4
 101240c:	d130      	bne.n	1012470 <radio_ccm_rx_pkt_set+0x7c>
	case BIT(2):
		mode |= (CCM_MODE_DATARATE_125Kbps <<
			 CCM_MODE_DATARATE_Pos) &
			CCM_MODE_DATARATE_Msk;

		NRF_CCM->RATEOVERRIDE =
 101240e:	2103      	movs	r1, #3
 1012410:	f44f 5500 	mov.w	r5, #8192	; 0x2000
 1012414:	f8c3 151c 	str.w	r1, [r3, #1308]	; 0x51c
	HAL_TRIGGER_RATEOVERRIDE_PPI_REGISTER_EVT =
 1012418:	4c18      	ldr	r4, [pc, #96]	; (101247c <radio_ccm_rx_pkt_set+0x88>)
 101241a:	4919      	ldr	r1, [pc, #100]	; (1012480 <radio_ccm_rx_pkt_set+0x8c>)
 101241c:	4819      	ldr	r0, [pc, #100]	; (1012484 <radio_ccm_rx_pkt_set+0x90>)
 101241e:	f8c4 11d0 	str.w	r1, [r4, #464]	; 0x1d0
		mode |= (CCM_MODE_DATARATE_125Kbps <<
 1012422:	4c19      	ldr	r4, [pc, #100]	; (1012488 <radio_ccm_rx_pkt_set+0x94>)
	HAL_TRIGGER_RATEOVERRIDE_PPI_REGISTER_TASK =
 1012424:	f8c3 108c 	str.w	r1, [r3, #140]	; 0x8c
 1012428:	f8c0 5504 	str.w	r5, [r0, #1284]	; 0x504
	NRF_CCM->MODE = mode;
	NRF_CCM->CNFPTR = (u32_t)ccm;
	NRF_CCM->INPTR = (u32_t)_pkt_scratch;
	NRF_CCM->OUTPTR = (u32_t)pkt;
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
	NRF_CCM->SHORTS = 0;
 101242c:	2100      	movs	r1, #0
 101242e:	2708      	movs	r7, #8
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ccm_task_trigger(NRF_CCM_Type * p_reg,
                                            nrf_ccm_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1012430:	2501      	movs	r5, #1
	NRF_CCM->MODE = mode;
 1012432:	4b11      	ldr	r3, [pc, #68]	; (1012478 <radio_ccm_rx_pkt_set+0x84>)
	NRF_CCM->INPTR = (u32_t)_pkt_scratch;
 1012434:	4815      	ldr	r0, [pc, #84]	; (101248c <radio_ccm_rx_pkt_set+0x98>)
	NRF_CCM->MODE = mode;
 1012436:	f8c3 4504 	str.w	r4, [r3, #1284]	; 0x504
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
 101243a:	4c15      	ldr	r4, [pc, #84]	; (1012490 <radio_ccm_rx_pkt_set+0x9c>)
	NRF_CCM->CNFPTR = (u32_t)ccm;
 101243c:	f8c3 6508 	str.w	r6, [r3, #1288]	; 0x508
	NRF_CCM->INPTR = (u32_t)_pkt_scratch;
 1012440:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
	NRF_CCM->OUTPTR = (u32_t)pkt;
 1012444:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
 1012448:	f8c3 4514 	str.w	r4, [r3, #1300]	; 0x514
	HAL_TRIGGER_CRYPT_PPI_REGISTER_EVT =
 101244c:	4a11      	ldr	r2, [pc, #68]	; (1012494 <radio_ccm_rx_pkt_set+0xa0>)
	NRF_CCM->SHORTS = 0;
 101244e:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
 1012452:	4c0a      	ldr	r4, [pc, #40]	; (101247c <radio_ccm_rx_pkt_set+0x88>)
	NRF_CCM->EVENTS_ENDCRYPT = 0;
 1012454:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
	NRF_CCM->EVENTS_ERROR = 0;
 1012458:	f8c3 1108 	str.w	r1, [r3, #264]	; 0x108
 101245c:	4909      	ldr	r1, [pc, #36]	; (1012484 <radio_ccm_rx_pkt_set+0x90>)
 101245e:	f8c4 2184 	str.w	r2, [r4, #388]	; 0x184
	HAL_TRIGGER_CRYPT_PPI_REGISTER_TASK =
 1012462:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
 1012466:	f8c1 7504 	str.w	r7, [r1, #1284]	; 0x504
 101246a:	601d      	str	r5, [r3, #0]
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_TRIGGER_CRYPT_PPI));

	nrf_ccm_task_trigger(NRF_CCM, NRF_CCM_TASK_KSGEN);

	return _pkt_scratch;
}
 101246c:	bcf0      	pop	{r4, r5, r6, r7}
 101246e:	4770      	bx	lr
		mode |= (CCM_MODE_DATARATE_1Mbit <<
 1012470:	4c09      	ldr	r4, [pc, #36]	; (1012498 <radio_ccm_rx_pkt_set+0xa4>)
 1012472:	e7db      	b.n	101242c <radio_ccm_rx_pkt_set+0x38>
	switch (phy) {
 1012474:	4c09      	ldr	r4, [pc, #36]	; (101249c <radio_ccm_rx_pkt_set+0xa8>)
 1012476:	e7d9      	b.n	101242c <radio_ccm_rx_pkt_set+0x38>
 1012478:	4100e000 	.word	0x4100e000
 101247c:	41008000 	.word	0x41008000
 1012480:	8000000d 	.word	0x8000000d
 1012484:	4100f000 	.word	0x4100f000
 1012488:	01020001 	.word	0x01020001
 101248c:	210057b4 	.word	0x210057b4
 1012490:	210056a4 	.word	0x210056a4
 1012494:	80000003 	.word	0x80000003
 1012498:	01000001 	.word	0x01000001
 101249c:	01010001 	.word	0x01010001

010124a0 <radio_ccm_tx_pkt_set>:

void *radio_ccm_tx_pkt_set(struct ccm *ccm, void *pkt)
{
 10124a0:	b470      	push	{r4, r5, r6}
	u32_t mode;

	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
 10124a2:	2200      	movs	r2, #0
{
 10124a4:	4604      	mov	r4, r0
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
 10124a6:	2602      	movs	r6, #2
	NRF_CCM->MODE = mode;
	NRF_CCM->CNFPTR = (u32_t)ccm;
	NRF_CCM->INPTR = (u32_t)pkt;
	NRF_CCM->OUTPTR = (u32_t)_pkt_scratch;
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
	NRF_CCM->SHORTS = CCM_SHORTS_ENDKSGEN_CRYPT_Msk;
 10124a8:	2501      	movs	r5, #1
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
 10124aa:	4b0d      	ldr	r3, [pc, #52]	; (10124e0 <radio_ccm_tx_pkt_set+0x40>)
	NRF_CCM->MODE = mode;
 10124ac:	480d      	ldr	r0, [pc, #52]	; (10124e4 <radio_ccm_tx_pkt_set+0x44>)
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
 10124ae:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
 10124b2:	f8c3 6500 	str.w	r6, [r3, #1280]	; 0x500
	NRF_CCM->MODE = mode;
 10124b6:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
	NRF_CCM->CNFPTR = (u32_t)ccm;
 10124ba:	f8c3 4508 	str.w	r4, [r3, #1288]	; 0x508
	NRF_CCM->OUTPTR = (u32_t)_pkt_scratch;
 10124be:	480a      	ldr	r0, [pc, #40]	; (10124e8 <radio_ccm_tx_pkt_set+0x48>)
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
 10124c0:	4c0a      	ldr	r4, [pc, #40]	; (10124ec <radio_ccm_tx_pkt_set+0x4c>)
	NRF_CCM->INPTR = (u32_t)pkt;
 10124c2:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
	NRF_CCM->OUTPTR = (u32_t)_pkt_scratch;
 10124c6:	f8c3 0510 	str.w	r0, [r3, #1296]	; 0x510
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
 10124ca:	f8c3 4514 	str.w	r4, [r3, #1300]	; 0x514
	NRF_CCM->SHORTS = CCM_SHORTS_ENDKSGEN_CRYPT_Msk;
 10124ce:	f8c3 5200 	str.w	r5, [r3, #512]	; 0x200
	NRF_CCM->EVENTS_ENDCRYPT = 0;
 10124d2:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	NRF_CCM->EVENTS_ERROR = 0;
 10124d6:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
 10124da:	601d      	str	r5, [r3, #0]

	nrf_ccm_task_trigger(NRF_CCM, NRF_CCM_TASK_KSGEN);

	return _pkt_scratch;
}
 10124dc:	bc70      	pop	{r4, r5, r6}
 10124de:	4770      	bx	lr
 10124e0:	4100e000 	.word	0x4100e000
 10124e4:	01010000 	.word	0x01010000
 10124e8:	210057b4 	.word	0x210057b4
 10124ec:	210056a4 	.word	0x210056a4

010124f0 <radio_ccm_is_done>:
    return ((uint32_t)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE void nrf_ccm_int_enable(NRF_CCM_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
 10124f0:	2302      	movs	r3, #2
 10124f2:	4a0e      	ldr	r2, [pc, #56]	; (101252c <radio_ccm_is_done+0x3c>)
 10124f4:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304

u32_t radio_ccm_is_done(void)
{
	nrf_ccm_int_enable(NRF_CCM, CCM_INTENSET_ENDCRYPT_Msk);
	while (NRF_CCM->EVENTS_ENDCRYPT == 0) {
 10124f8:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
 10124fc:	b933      	cbnz	r3, 101250c <radio_ccm_is_done+0x1c>
		__WFE();
 10124fe:	bf20      	wfe
		__SEV();
 1012500:	bf40      	sev
		__WFE();
 1012502:	bf20      	wfe
	while (NRF_CCM->EVENTS_ENDCRYPT == 0) {
 1012504:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
 1012508:	2b00      	cmp	r3, #0
 101250a:	d0f8      	beq.n	10124fe <radio_ccm_is_done+0xe>
}

NRF_STATIC_INLINE void nrf_ccm_int_disable(NRF_CCM_Type * p_reg, uint32_t mask)
{
    p_reg->INTENCLR = mask;
 101250c:	2002      	movs	r0, #2
 101250e:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 1012512:	4b06      	ldr	r3, [pc, #24]	; (101252c <radio_ccm_is_done+0x3c>)
 1012514:	4a06      	ldr	r2, [pc, #24]	; (1012530 <radio_ccm_is_done+0x40>)
 1012516:	f8c3 0308 	str.w	r0, [r3, #776]	; 0x308
 101251a:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
	}
	nrf_ccm_int_disable(NRF_CCM, CCM_INTENCLR_ENDCRYPT_Msk);
	NVIC_ClearPendingIRQ(nrfx_get_irq_number(NRF_CCM));

	return (NRF_CCM->EVENTS_ERROR == 0);
 101251e:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
}
 1012522:	fab0 f080 	clz	r0, r0
 1012526:	0940      	lsrs	r0, r0, #5
 1012528:	4770      	bx	lr
 101252a:	bf00      	nop
 101252c:	4100e000 	.word	0x4100e000
 1012530:	e000e100 	.word	0xe000e100

01012534 <radio_ccm_mic_is_valid>:

u32_t radio_ccm_mic_is_valid(void)
{
	return (NRF_CCM->MICSTATUS != 0);
 1012534:	4b03      	ldr	r3, [pc, #12]	; (1012544 <radio_ccm_mic_is_valid+0x10>)
 1012536:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
 101253a:	3800      	subs	r0, #0
 101253c:	bf18      	it	ne
 101253e:	2001      	movne	r0, #1
 1012540:	4770      	bx	lr
 1012542:	bf00      	nop
 1012544:	4100e000 	.word	0x4100e000

01012548 <radio_ar_configure>:

static u8_t MALIGN(4) _aar_scratch[3];

void radio_ar_configure(u32_t nirk, void *irk)
{
 1012548:	b470      	push	{r4, r5, r6}
	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Enabled << AAR_ENABLE_ENABLE_Pos) &
 101254a:	2603      	movs	r6, #3
	NRF_AAR->NIRK = nirk;
	NRF_AAR->IRKPTR = (u32_t)irk;
	NRF_AAR->ADDRPTR = (u32_t)NRF_RADIO->PACKETPTR - 1;
	NRF_AAR->SCRATCHPTR = (u32_t)&_aar_scratch[0];

	NRF_AAR->EVENTS_END = 0;
 101254c:	2400      	movs	r4, #0
    p_reg->BCC = radio_bcc;
 101254e:	2540      	movs	r5, #64	; 0x40
	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Enabled << AAR_ENABLE_ENABLE_Pos) &
 1012550:	4b14      	ldr	r3, [pc, #80]	; (10125a4 <radio_ar_configure+0x5c>)
	NRF_AAR->ADDRPTR = (u32_t)NRF_RADIO->PACKETPTR - 1;
 1012552:	4a15      	ldr	r2, [pc, #84]	; (10125a8 <radio_ar_configure+0x60>)
	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Enabled << AAR_ENABLE_ENABLE_Pos) &
 1012554:	f8c3 6500 	str.w	r6, [r3, #1280]	; 0x500
	NRF_AAR->NIRK = nirk;
 1012558:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
	NRF_AAR->IRKPTR = (u32_t)irk;
 101255c:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
	NRF_AAR->ADDRPTR = (u32_t)NRF_RADIO->PACKETPTR - 1;
 1012560:	f8d2 1504 	ldr.w	r1, [r2, #1284]	; 0x504
	NRF_AAR->SCRATCHPTR = (u32_t)&_aar_scratch[0];
 1012564:	4811      	ldr	r0, [pc, #68]	; (10125ac <radio_ar_configure+0x64>)
	NRF_AAR->ADDRPTR = (u32_t)NRF_RADIO->PACKETPTR - 1;
 1012566:	3901      	subs	r1, #1
 1012568:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
	NRF_AAR->SCRATCHPTR = (u32_t)&_aar_scratch[0];
 101256c:	f8c3 0514 	str.w	r0, [r3, #1300]	; 0x514
	NRF_AAR->EVENTS_END = 0;
 1012570:	f8c3 4100 	str.w	r4, [r3, #256]	; 0x100
	NRF_AAR->EVENTS_RESOLVED = 0;
 1012574:	f8c3 4104 	str.w	r4, [r3, #260]	; 0x104
	NRF_AAR->EVENTS_NOTRESOLVED = 0;
 1012578:	f8c3 4108 	str.w	r4, [r3, #264]	; 0x108
 101257c:	f8c2 5560 	str.w	r5, [r2, #1376]	; 0x560
	NRF_RADIO->SHORTS |= RADIO_SHORTS_ADDRESS_BCSTART_Msk;
 1012580:	f8d2 1200 	ldr.w	r1, [r2, #512]	; 0x200
	HAL_TRIGGER_AAR_PPI_REGISTER_EVT =
 1012584:	480a      	ldr	r0, [pc, #40]	; (10125b0 <radio_ar_configure+0x68>)
 1012586:	4329      	orrs	r1, r5
 1012588:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
 101258c:	4909      	ldr	r1, [pc, #36]	; (10125b4 <radio_ar_configure+0x6c>)
	NRF_RADIO->EVENTS_BCMATCH = 0;
 101258e:	f8c2 4128 	str.w	r4, [r2, #296]	; 0x128
 1012592:	f8c2 01a8 	str.w	r0, [r2, #424]	; 0x1a8
	HAL_TRIGGER_AAR_PPI_REGISTER_TASK =
 1012596:	f8c3 0080 	str.w	r0, [r3, #128]	; 0x80
 101259a:	f8c1 5504 	str.w	r5, [r1, #1284]	; 0x504
	radio_bc_configure(64);
	radio_bc_status_reset();

	hal_trigger_aar_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_TRIGGER_AAR_PPI));
}
 101259e:	bc70      	pop	{r4, r5, r6}
 10125a0:	4770      	bx	lr
 10125a2:	bf00      	nop
 10125a4:	4100e000 	.word	0x4100e000
 10125a8:	41008000 	.word	0x41008000
 10125ac:	210056a0 	.word	0x210056a0
 10125b0:	80000006 	.word	0x80000006
 10125b4:	4100f000 	.word	0x4100f000

010125b8 <radio_ar_match_get>:

u32_t radio_ar_match_get(void)
{
	return NRF_AAR->STATUS;
 10125b8:	4b01      	ldr	r3, [pc, #4]	; (10125c0 <radio_ar_match_get+0x8>)
 10125ba:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
 10125be:	4770      	bx	lr
 10125c0:	4100e000 	.word	0x4100e000

010125c4 <radio_ar_status_reset>:
	NRF_RADIO->EVENTS_BCMATCH = 0;
 10125c4:	2300      	movs	r3, #0
 10125c6:	4903      	ldr	r1, [pc, #12]	; (10125d4 <radio_ar_status_reset+0x10>)

void radio_ar_status_reset(void)
{
	radio_bc_status_reset();

	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Disabled << AAR_ENABLE_ENABLE_Pos) &
 10125c8:	4a03      	ldr	r2, [pc, #12]	; (10125d8 <radio_ar_status_reset+0x14>)
	NRF_RADIO->EVENTS_BCMATCH = 0;
 10125ca:	f8c1 3128 	str.w	r3, [r1, #296]	; 0x128
	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Disabled << AAR_ENABLE_ENABLE_Pos) &
 10125ce:	f8c2 3500 	str.w	r3, [r2, #1280]	; 0x500
			  AAR_ENABLE_ENABLE_Msk;
}
 10125d2:	4770      	bx	lr
 10125d4:	41008000 	.word	0x41008000
 10125d8:	4100e000 	.word	0x4100e000

010125dc <radio_ar_has_match>:
	return (NRF_RADIO->EVENTS_BCMATCH != 0);
 10125dc:	4b08      	ldr	r3, [pc, #32]	; (1012600 <radio_ar_has_match+0x24>)
 10125de:	f8d3 0128 	ldr.w	r0, [r3, #296]	; 0x128

u32_t radio_ar_has_match(void)
{
	return (radio_bc_has_match() &&
		NRF_AAR->EVENTS_END &&
		NRF_AAR->EVENTS_RESOLVED &&
 10125e2:	b160      	cbz	r0, 10125fe <radio_ar_has_match+0x22>
		NRF_AAR->EVENTS_END &&
 10125e4:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
 10125e8:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
	return (radio_bc_has_match() &&
 10125ec:	b138      	cbz	r0, 10125fe <radio_ar_has_match+0x22>
		NRF_AAR->EVENTS_RESOLVED &&
 10125ee:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
		NRF_AAR->EVENTS_END &&
 10125f2:	b120      	cbz	r0, 10125fe <radio_ar_has_match+0x22>
		!NRF_AAR->EVENTS_NOTRESOLVED);
 10125f4:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
		NRF_AAR->EVENTS_RESOLVED &&
 10125f8:	fab0 f080 	clz	r0, r0
 10125fc:	0940      	lsrs	r0, r0, #5
}
 10125fe:	4770      	bx	lr
 1012600:	41008000 	.word	0x41008000

01012604 <mayfly_enable_cb>:

void mayfly_enable_cb(u8_t caller_id, u8_t callee_id, u8_t enable)
{
	(void)caller_id;

	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
 1012604:	2902      	cmp	r1, #2
{
 1012606:	b510      	push	{r4, lr}
 1012608:	4614      	mov	r4, r2
	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
 101260a:	d003      	beq.n	1012614 <mayfly_enable_cb+0x10>
 101260c:	2122      	movs	r1, #34	; 0x22
 101260e:	4806      	ldr	r0, [pc, #24]	; (1012628 <mayfly_enable_cb+0x24>)
 1012610:	f7f1 f836 	bl	1003680 <bt_ctlr_assert_handle>

	if (enable) {
		irq_enable(HAL_SWI_JOB_IRQ);
 1012614:	2011      	movs	r0, #17
	if (enable) {
 1012616:	b11c      	cbz	r4, 1012620 <mayfly_enable_cb+0x1c>
	} else {
		irq_disable(HAL_SWI_JOB_IRQ);
	}
}
 1012618:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_enable(HAL_SWI_JOB_IRQ);
 101261c:	f7f2 bbf6 	b.w	1004e0c <arch_irq_enable>
}
 1012620:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_disable(HAL_SWI_JOB_IRQ);
 1012624:	f7f2 bc02 	b.w	1004e2c <arch_irq_disable>
 1012628:	01018d70 	.word	0x01018d70

0101262c <mayfly_is_enabled>:

u32_t mayfly_is_enabled(u8_t caller_id, u8_t callee_id)
{
	(void)caller_id;

	switch (callee_id) {
 101262c:	b129      	cbz	r1, 101263a <mayfly_is_enabled+0xe>
 101262e:	3901      	subs	r1, #1
 1012630:	2901      	cmp	r1, #1
 1012632:	d805      	bhi.n	1012640 <mayfly_is_enabled+0x14>
	case MAYFLY_CALL_ID_LLL:
		return irq_is_enabled(HAL_SWI_RADIO_IRQ);
#endif /* CONFIG_BT_LL_SW_SPLIT */

	case MAYFLY_CALL_ID_WORKER:
		return irq_is_enabled(HAL_SWI_WORKER_IRQ);
 1012634:	2011      	movs	r0, #17
 1012636:	f7f2 bc0d 	b.w	1004e54 <arch_irq_is_enabled>
		return irq_is_enabled(HAL_SWI_RADIO_IRQ);
 101263a:	2014      	movs	r0, #20
 101263c:	f7f2 bc0a 	b.w	1004e54 <arch_irq_is_enabled>
{
 1012640:	b508      	push	{r3, lr}

	case MAYFLY_CALL_ID_JOB:
		return irq_is_enabled(HAL_SWI_JOB_IRQ);

	default:
		LL_ASSERT(0);
 1012642:	213c      	movs	r1, #60	; 0x3c
 1012644:	4802      	ldr	r0, [pc, #8]	; (1012650 <mayfly_is_enabled+0x24>)
 1012646:	f7f1 f81b 	bl	1003680 <bt_ctlr_assert_handle>
		break;
	}

	return 0;
}
 101264a:	2000      	movs	r0, #0
 101264c:	bd08      	pop	{r3, pc}
 101264e:	bf00      	nop
 1012650:	01018d70 	.word	0x01018d70

01012654 <mayfly_prio_is_equal>:
#endif
#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	       ((caller_id == MAYFLY_CALL_ID_WORKER) &&
		(callee_id == MAYFLY_CALL_ID_JOB)) ||
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
 1012654:	4288      	cmp	r0, r1
 1012656:	d013      	beq.n	1012680 <mayfly_prio_is_equal+0x2c>
	return (caller_id == callee_id) ||
 1012658:	b928      	cbnz	r0, 1012666 <mayfly_prio_is_equal+0x12>
	       ((caller_id == MAYFLY_CALL_ID_LLL) &&
 101265a:	1e48      	subs	r0, r1, #1
 101265c:	2801      	cmp	r0, #1
 101265e:	bf8c      	ite	hi
 1012660:	2000      	movhi	r0, #0
 1012662:	2001      	movls	r0, #1
 1012664:	4770      	bx	lr
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
 1012666:	2801      	cmp	r0, #1
 1012668:	d106      	bne.n	1012678 <mayfly_prio_is_equal+0x24>
	       ((caller_id == MAYFLY_CALL_ID_WORKER) &&
 101266a:	b159      	cbz	r1, 1012684 <mayfly_prio_is_equal+0x30>
	       ((caller_id == MAYFLY_CALL_ID_WORKER) &&
 101266c:	f1a1 0002 	sub.w	r0, r1, #2
 1012670:	fab0 f080 	clz	r0, r0
 1012674:	0940      	lsrs	r0, r0, #5
 1012676:	4770      	bx	lr
		(callee_id == MAYFLY_CALL_ID_JOB)) ||
 1012678:	2802      	cmp	r0, #2
 101267a:	d004      	beq.n	1012686 <mayfly_prio_is_equal+0x32>
 101267c:	2000      	movs	r0, #0
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
 101267e:	4770      	bx	lr
 1012680:	2001      	movs	r0, #1
 1012682:	4770      	bx	lr
#endif
#endif
	       0;
}
 1012684:	4770      	bx	lr
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
 1012686:	2901      	cmp	r1, #1
 1012688:	bf8c      	ite	hi
 101268a:	2000      	movhi	r0, #0
 101268c:	2001      	movls	r0, #1
 101268e:	4770      	bx	lr

01012690 <mayfly_pend>:

void mayfly_pend(u8_t caller_id, u8_t callee_id)
{
	(void)caller_id;

	switch (callee_id) {
 1012690:	2901      	cmp	r1, #1
 1012692:	d006      	beq.n	10126a2 <mayfly_pend+0x12>
 1012694:	2902      	cmp	r1, #2
 1012696:	d004      	beq.n	10126a2 <mayfly_pend+0x12>
 1012698:	b149      	cbz	r1, 10126ae <mayfly_pend+0x1e>
	case MAYFLY_CALL_ID_JOB:
		hal_swi_job_pend();
		break;

	default:
		LL_ASSERT(0);
 101269a:	2171      	movs	r1, #113	; 0x71
 101269c:	4807      	ldr	r0, [pc, #28]	; (10126bc <mayfly_pend+0x2c>)
 101269e:	f7f0 bfef 	b.w	1003680 <bt_ctlr_assert_handle>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 10126a2:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 10126a6:	4b06      	ldr	r3, [pc, #24]	; (10126c0 <mayfly_pend+0x30>)
 10126a8:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
		break;
	}
}
 10126ac:	4770      	bx	lr
 10126ae:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 10126b2:	4b03      	ldr	r3, [pc, #12]	; (10126c0 <mayfly_pend+0x30>)
 10126b4:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
 10126b8:	4770      	bx	lr
 10126ba:	bf00      	nop
 10126bc:	01018d70 	.word	0x01018d70
 10126c0:	e000e100 	.word	0xe000e100

010126c4 <hal_ticker_instance0_caller_id_get>:

u8_t hal_ticker_instance0_caller_id_get(u8_t user_id)
{
	u8_t caller_id;

	LL_ASSERT(user_id < sizeof(caller_id_lut));
 10126c4:	2803      	cmp	r0, #3
{
 10126c6:	b510      	push	{r4, lr}
 10126c8:	4604      	mov	r4, r0
	LL_ASSERT(user_id < sizeof(caller_id_lut));
 10126ca:	d804      	bhi.n	10126d6 <hal_ticker_instance0_caller_id_get+0x12>

	caller_id = caller_id_lut[user_id];
 10126cc:	4b09      	ldr	r3, [pc, #36]	; (10126f4 <hal_ticker_instance0_caller_id_get+0x30>)
 10126ce:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(caller_id != TICKER_CALL_ID_NONE);
 10126d0:	b14c      	cbz	r4, 10126e6 <hal_ticker_instance0_caller_id_get+0x22>

	return caller_id;
}
 10126d2:	4620      	mov	r0, r4
 10126d4:	bd10      	pop	{r4, pc}
	LL_ASSERT(user_id < sizeof(caller_id_lut));
 10126d6:	212d      	movs	r1, #45	; 0x2d
 10126d8:	4807      	ldr	r0, [pc, #28]	; (10126f8 <hal_ticker_instance0_caller_id_get+0x34>)
 10126da:	f7f0 ffd1 	bl	1003680 <bt_ctlr_assert_handle>
	caller_id = caller_id_lut[user_id];
 10126de:	4b05      	ldr	r3, [pc, #20]	; (10126f4 <hal_ticker_instance0_caller_id_get+0x30>)
 10126e0:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(caller_id != TICKER_CALL_ID_NONE);
 10126e2:	2c00      	cmp	r4, #0
 10126e4:	d1f5      	bne.n	10126d2 <hal_ticker_instance0_caller_id_get+0xe>
 10126e6:	2130      	movs	r1, #48	; 0x30
 10126e8:	4803      	ldr	r0, [pc, #12]	; (10126f8 <hal_ticker_instance0_caller_id_get+0x34>)
 10126ea:	f7f0 ffc9 	bl	1003680 <bt_ctlr_assert_handle>
}
 10126ee:	4620      	mov	r0, r4
 10126f0:	bd10      	pop	{r4, pc}
 10126f2:	bf00      	nop
 10126f4:	01018e38 	.word	0x01018e38
 10126f8:	01018dd4 	.word	0x01018dd4

010126fc <hal_ticker_instance0_sched>:
{
	/* return value not checked as we allow multiple calls to schedule
	 * before being actually needing the work to complete before new
	 * schedule.
	 */
	switch (caller_id) {
 10126fc:	3801      	subs	r0, #1
{
 10126fe:	b410      	push	{r4}
 1012700:	461c      	mov	r4, r3
 1012702:	2804      	cmp	r0, #4
 1012704:	d853      	bhi.n	10127ae <hal_ticker_instance0_sched+0xb2>
 1012706:	e8df f000 	tbb	[pc, r0]
 101270a:	180a      	.short	0x180a
 101270c:	1f11      	.short	0x1f11
 101270e:	03          	.byte	0x03
 101270f:	00          	.byte	0x00
			break;
		}
		break;

	case TICKER_CALL_ID_PROGRAM:
		switch (callee_id) {
 1012710:	2904      	cmp	r1, #4
 1012712:	d022      	beq.n	101275a <hal_ticker_instance0_sched+0x5e>
				       &m);
		}
		break;

		default:
			LL_ASSERT(0);
 1012714:	21be      	movs	r1, #190	; 0xbe
 1012716:	4828      	ldr	r0, [pc, #160]	; (10127b8 <hal_ticker_instance0_sched+0xbc>)

	default:
		LL_ASSERT(0);
		break;
	}
}
 1012718:	bc10      	pop	{r4}
			LL_ASSERT(0);
 101271a:	f7f0 bfb1 	b.w	1003680 <bt_ctlr_assert_handle>
		switch (callee_id) {
 101271e:	2904      	cmp	r1, #4
 1012720:	d029      	beq.n	1012776 <hal_ticker_instance0_sched+0x7a>
			LL_ASSERT(0);
 1012722:	2151      	movs	r1, #81	; 0x51
 1012724:	4824      	ldr	r0, [pc, #144]	; (10127b8 <hal_ticker_instance0_sched+0xbc>)
}
 1012726:	bc10      	pop	{r4}
			LL_ASSERT(0);
 1012728:	f7f0 bfaa 	b.w	1003680 <bt_ctlr_assert_handle>
		switch (callee_id) {
 101272c:	2904      	cmp	r1, #4
 101272e:	d01b      	beq.n	1012768 <hal_ticker_instance0_sched+0x6c>
			LL_ASSERT(0);
 1012730:	2180      	movs	r1, #128	; 0x80
 1012732:	4821      	ldr	r0, [pc, #132]	; (10127b8 <hal_ticker_instance0_sched+0xbc>)
}
 1012734:	bc10      	pop	{r4}
			LL_ASSERT(0);
 1012736:	f7f0 bfa3 	b.w	1003680 <bt_ctlr_assert_handle>
		switch (callee_id) {
 101273a:	2903      	cmp	r1, #3
 101273c:	d022      	beq.n	1012784 <hal_ticker_instance0_sched+0x88>
			LL_ASSERT(0);
 101273e:	2169      	movs	r1, #105	; 0x69
 1012740:	481d      	ldr	r0, [pc, #116]	; (10127b8 <hal_ticker_instance0_sched+0xbc>)
}
 1012742:	bc10      	pop	{r4}
			LL_ASSERT(0);
 1012744:	f7f0 bf9c 	b.w	1003680 <bt_ctlr_assert_handle>
		switch (callee_id) {
 1012748:	2903      	cmp	r1, #3
 101274a:	d029      	beq.n	10127a0 <hal_ticker_instance0_sched+0xa4>
 101274c:	2904      	cmp	r1, #4
 101274e:	d020      	beq.n	1012792 <hal_ticker_instance0_sched+0x96>
			LL_ASSERT(0);
 1012750:	21a6      	movs	r1, #166	; 0xa6
 1012752:	4819      	ldr	r0, [pc, #100]	; (10127b8 <hal_ticker_instance0_sched+0xbc>)
}
 1012754:	bc10      	pop	{r4}
			LL_ASSERT(0);
 1012756:	f7f0 bf93 	b.w	1003680 <bt_ctlr_assert_handle>
			m.param = instance;
 101275a:	4b18      	ldr	r3, [pc, #96]	; (10127bc <hal_ticker_instance0_sched+0xc0>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
 101275c:	2102      	movs	r1, #2
			m.param = instance;
 101275e:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
 1012760:	2003      	movs	r0, #3
}
 1012762:	bc10      	pop	{r4}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
 1012764:	f7f3 bbb0 	b.w	1005ec8 <mayfly_enqueue>
			m.param = instance;
 1012768:	4b15      	ldr	r3, [pc, #84]	; (10127c0 <hal_ticker_instance0_sched+0xc4>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
 101276a:	2102      	movs	r1, #2
			m.param = instance;
 101276c:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
 101276e:	2001      	movs	r0, #1
}
 1012770:	bc10      	pop	{r4}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
 1012772:	f7f3 bba9 	b.w	1005ec8 <mayfly_enqueue>
			m.param = instance;
 1012776:	4b13      	ldr	r3, [pc, #76]	; (10127c4 <hal_ticker_instance0_sched+0xc8>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
 1012778:	2102      	movs	r1, #2
			m.param = instance;
 101277a:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
 101277c:	2000      	movs	r0, #0
}
 101277e:	bc10      	pop	{r4}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
 1012780:	f7f3 bba2 	b.w	1005ec8 <mayfly_enqueue>
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_TRIGGER,
 1012784:	2101      	movs	r1, #1
			m.param = instance;
 1012786:	4b10      	ldr	r3, [pc, #64]	; (10127c8 <hal_ticker_instance0_sched+0xcc>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_TRIGGER,
 1012788:	4608      	mov	r0, r1
			m.param = instance;
 101278a:	609c      	str	r4, [r3, #8]
}
 101278c:	bc10      	pop	{r4}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_TRIGGER,
 101278e:	f7f3 bb9b 	b.w	1005ec8 <mayfly_enqueue>
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
 1012792:	2102      	movs	r1, #2
			m.param = instance;
 1012794:	4b0d      	ldr	r3, [pc, #52]	; (10127cc <hal_ticker_instance0_sched+0xd0>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
 1012796:	4608      	mov	r0, r1
			m.param = instance;
 1012798:	609c      	str	r4, [r3, #8]
}
 101279a:	bc10      	pop	{r4}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
 101279c:	f7f3 bb94 	b.w	1005ec8 <mayfly_enqueue>
			m.param = instance;
 10127a0:	4b0b      	ldr	r3, [pc, #44]	; (10127d0 <hal_ticker_instance0_sched+0xd4>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
 10127a2:	2101      	movs	r1, #1
			m.param = instance;
 10127a4:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
 10127a6:	2002      	movs	r0, #2
}
 10127a8:	bc10      	pop	{r4}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
 10127aa:	f7f3 bb8d 	b.w	1005ec8 <mayfly_enqueue>
		LL_ASSERT(0);
 10127ae:	21c4      	movs	r1, #196	; 0xc4
 10127b0:	4801      	ldr	r0, [pc, #4]	; (10127b8 <hal_ticker_instance0_sched+0xbc>)
}
 10127b2:	bc10      	pop	{r4}
		LL_ASSERT(0);
 10127b4:	f7f0 bf64 	b.w	1003680 <bt_ctlr_assert_handle>
 10127b8:	01018dd4 	.word	0x01018dd4
 10127bc:	210004a4 	.word	0x210004a4
 10127c0:	21000474 	.word	0x21000474
 10127c4:	21000454 	.word	0x21000454
 10127c8:	21000464 	.word	0x21000464
 10127cc:	21000494 	.word	0x21000494
 10127d0:	21000484 	.word	0x21000484

010127d4 <hal_ticker_instance0_trigger_set>:

void hal_ticker_instance0_trigger_set(u32_t value)
{
 10127d4:	4601      	mov	r1, r0
	cntr_cmp_set(0, value);
 10127d6:	2000      	movs	r0, #0
 10127d8:	f7ff b980 	b.w	1011adc <cntr_cmp_set>

010127dc <hci_vendor_read_static_addr>:
				 u8_t size)
{
	/* only one supported */
	ARG_UNUSED(size);

	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
 10127dc:	4a34      	ldr	r2, [pc, #208]	; (10128b0 <hci_vendor_read_static_addr+0xd4>)
{
 10127de:	b538      	push	{r3, r4, r5, lr}
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
 10127e0:	f8d2 12a4 	ldr.w	r1, [r2, #676]	; 0x2a4
{
 10127e4:	4603      	mov	r3, r0
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
 10127e6:	3101      	adds	r1, #1
 10127e8:	d059      	beq.n	101289e <hci_vendor_read_static_addr+0xc2>
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
	     (NRF_FICR->DEVICEADDRTYPE & 0x01)) {
 10127ea:	4a31      	ldr	r2, [pc, #196]	; (10128b0 <hci_vendor_read_static_addr+0xd4>)
 10127ec:	f8d2 02a0 	ldr.w	r0, [r2, #672]	; 0x2a0
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
 10127f0:	f010 0001 	ands.w	r0, r0, #1
 10127f4:	d100      	bne.n	10127f8 <hci_vendor_read_static_addr+0x1c>

		return 1;
	}

	return 0;
}
 10127f6:	bd38      	pop	{r3, r4, r5, pc}
		sys_put_le32(NRF_FICR->DEVICEADDR[0], &addrs[0].bdaddr.val[0]);
 10127f8:	f8d2 12a4 	ldr.w	r1, [r2, #676]	; 0x2a4
	sys_put_le16(val >> 16, &dst[2]);
 10127fc:	0c08      	lsrs	r0, r1, #16
	dst[1] = val >> 8;
 10127fe:	0a05      	lsrs	r5, r0, #8
 1012800:	f3c1 2407 	ubfx	r4, r1, #8, #8
	dst[0] = val;
 1012804:	7019      	strb	r1, [r3, #0]
 1012806:	7098      	strb	r0, [r3, #2]
	dst[1] = val >> 8;
 1012808:	70dd      	strb	r5, [r3, #3]
 101280a:	705c      	strb	r4, [r3, #1]
		sys_put_le16(NRF_FICR->DEVICEADDR[1], &addrs[0].bdaddr.val[4]);
 101280c:	f8d2 02a8 	ldr.w	r0, [r2, #680]	; 0x2a8
 1012810:	f3c0 2107 	ubfx	r1, r0, #8, #8
		BT_ADDR_SET_STATIC(&addrs[0].bdaddr);
 1012814:	f061 013f 	orn	r1, r1, #63	; 0x3f
	dst[0] = val;
 1012818:	7118      	strb	r0, [r3, #4]
 101281a:	7159      	strb	r1, [r3, #5]
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
 101281c:	f8d2 1290 	ldr.w	r1, [r2, #656]	; 0x290
 1012820:	3101      	adds	r1, #1
 1012822:	d035      	beq.n	1012890 <hci_vendor_read_static_addr+0xb4>
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
 1012824:	f8d2 1294 	ldr.w	r1, [r2, #660]	; 0x294
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
 1012828:	3101      	adds	r1, #1
 101282a:	d031      	beq.n	1012890 <hci_vendor_read_static_addr+0xb4>
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
 101282c:	f8d2 1298 	ldr.w	r1, [r2, #664]	; 0x298
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
 1012830:	3101      	adds	r1, #1
 1012832:	d02d      	beq.n	1012890 <hci_vendor_read_static_addr+0xb4>
		    (NRF_FICR->IR[3] != UINT32_MAX)) {
 1012834:	f8d2 129c 	ldr.w	r1, [r2, #668]	; 0x29c
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
 1012838:	3101      	adds	r1, #1
 101283a:	d029      	beq.n	1012890 <hci_vendor_read_static_addr+0xb4>
			sys_put_le32(NRF_FICR->IR[0], &addrs[0].ir[0]);
 101283c:	f8d2 1290 	ldr.w	r1, [r2, #656]	; 0x290
		return 1;
 1012840:	2001      	movs	r0, #1
	sys_put_le16(val >> 16, &dst[2]);
 1012842:	0c0c      	lsrs	r4, r1, #16
	dst[0] = val;
 1012844:	7199      	strb	r1, [r3, #6]
	dst[1] = val >> 8;
 1012846:	0a25      	lsrs	r5, r4, #8
 1012848:	f3c1 2107 	ubfx	r1, r1, #8, #8
	dst[0] = val;
 101284c:	721c      	strb	r4, [r3, #8]
	dst[1] = val >> 8;
 101284e:	725d      	strb	r5, [r3, #9]
 1012850:	71d9      	strb	r1, [r3, #7]
			sys_put_le32(NRF_FICR->IR[1], &addrs[0].ir[4]);
 1012852:	f8d2 1294 	ldr.w	r1, [r2, #660]	; 0x294
	sys_put_le16(val >> 16, &dst[2]);
 1012856:	0c0c      	lsrs	r4, r1, #16
	dst[0] = val;
 1012858:	7299      	strb	r1, [r3, #10]
	dst[1] = val >> 8;
 101285a:	0a25      	lsrs	r5, r4, #8
 101285c:	f3c1 2107 	ubfx	r1, r1, #8, #8
	dst[0] = val;
 1012860:	731c      	strb	r4, [r3, #12]
	dst[1] = val >> 8;
 1012862:	735d      	strb	r5, [r3, #13]
 1012864:	72d9      	strb	r1, [r3, #11]
			sys_put_le32(NRF_FICR->IR[2], &addrs[0].ir[8]);
 1012866:	f8d2 1298 	ldr.w	r1, [r2, #664]	; 0x298
	sys_put_le16(val >> 16, &dst[2]);
 101286a:	0c0c      	lsrs	r4, r1, #16
	dst[1] = val >> 8;
 101286c:	0a25      	lsrs	r5, r4, #8
	dst[0] = val;
 101286e:	7399      	strb	r1, [r3, #14]
	dst[1] = val >> 8;
 1012870:	f3c1 2107 	ubfx	r1, r1, #8, #8
	dst[0] = val;
 1012874:	741c      	strb	r4, [r3, #16]
	dst[1] = val >> 8;
 1012876:	745d      	strb	r5, [r3, #17]
 1012878:	73d9      	strb	r1, [r3, #15]
			sys_put_le32(NRF_FICR->IR[3], &addrs[0].ir[12]);
 101287a:	f8d2 229c 	ldr.w	r2, [r2, #668]	; 0x29c
	sys_put_le16(val >> 16, &dst[2]);
 101287e:	0c11      	lsrs	r1, r2, #16
	dst[1] = val >> 8;
 1012880:	0a0d      	lsrs	r5, r1, #8
 1012882:	f3c2 2407 	ubfx	r4, r2, #8, #8
	dst[0] = val;
 1012886:	749a      	strb	r2, [r3, #18]
 1012888:	7519      	strb	r1, [r3, #20]
	dst[1] = val >> 8;
 101288a:	755d      	strb	r5, [r3, #21]
 101288c:	74dc      	strb	r4, [r3, #19]
}
 101288e:	bd38      	pop	{r3, r4, r5, pc}
			(void)memset(addrs[0].ir, 0x00, sizeof(addrs[0].ir));
 1012890:	2210      	movs	r2, #16
 1012892:	2100      	movs	r1, #0
 1012894:	1d98      	adds	r0, r3, #6
 1012896:	f004 f8ea 	bl	1016a6e <memset>
		return 1;
 101289a:	2001      	movs	r0, #1
}
 101289c:	bd38      	pop	{r3, r4, r5, pc}
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
 101289e:	f64f 71ff 	movw	r1, #65535	; 0xffff
 10128a2:	f8d2 22a8 	ldr.w	r2, [r2, #680]	; 0x2a8
 10128a6:	b292      	uxth	r2, r2
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
 10128a8:	428a      	cmp	r2, r1
 10128aa:	d19e      	bne.n	10127ea <hci_vendor_read_static_addr+0xe>
	return 0;
 10128ac:	2000      	movs	r0, #0
}
 10128ae:	bd38      	pop	{r3, r4, r5, pc}
 10128b0:	01ff0000 	.word	0x01ff0000

010128b4 <hci_vendor_read_key_hierarchy_roots>:

void hci_vendor_read_key_hierarchy_roots(u8_t ir[16], u8_t er[16])
{
 10128b4:	b538      	push	{r3, r4, r5, lr}
	/* Mark IR as invalid.
	 * No public address is available, and static address IR should be read
	 * using Read Static Addresses command.
	 */
	(void)memset(ir, 0x00, 16);
 10128b6:	2210      	movs	r2, #16
{
 10128b8:	460c      	mov	r4, r1
	(void)memset(ir, 0x00, 16);
 10128ba:	2100      	movs	r1, #0
 10128bc:	f004 f8d7 	bl	1016a6e <memset>

	/* Fill in ER if present */
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
 10128c0:	4b20      	ldr	r3, [pc, #128]	; (1012944 <hci_vendor_read_key_hierarchy_roots+0x90>)
 10128c2:	f8d3 2280 	ldr.w	r2, [r3, #640]	; 0x280
 10128c6:	3201      	adds	r2, #1
 10128c8:	d034      	beq.n	1012934 <hci_vendor_read_key_hierarchy_roots+0x80>
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
 10128ca:	f8d3 2284 	ldr.w	r2, [r3, #644]	; 0x284
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
 10128ce:	3201      	adds	r2, #1
 10128d0:	d030      	beq.n	1012934 <hci_vendor_read_key_hierarchy_roots+0x80>
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
 10128d2:	f8d3 2288 	ldr.w	r2, [r3, #648]	; 0x288
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
 10128d6:	3201      	adds	r2, #1
 10128d8:	d02c      	beq.n	1012934 <hci_vendor_read_key_hierarchy_roots+0x80>
	    (NRF_FICR->ER[3] != UINT32_MAX)) {
 10128da:	f8d3 228c 	ldr.w	r2, [r3, #652]	; 0x28c
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
 10128de:	3201      	adds	r2, #1
 10128e0:	d028      	beq.n	1012934 <hci_vendor_read_key_hierarchy_roots+0x80>
		sys_put_le32(NRF_FICR->ER[0], &er[0]);
 10128e2:	f8d3 2280 	ldr.w	r2, [r3, #640]	; 0x280
	sys_put_le16(val >> 16, &dst[2]);
 10128e6:	0c11      	lsrs	r1, r2, #16
	dst[1] = val >> 8;
 10128e8:	0a0d      	lsrs	r5, r1, #8
 10128ea:	f3c2 2007 	ubfx	r0, r2, #8, #8
	dst[0] = val;
 10128ee:	70a1      	strb	r1, [r4, #2]
	dst[1] = val >> 8;
 10128f0:	70e5      	strb	r5, [r4, #3]
 10128f2:	7060      	strb	r0, [r4, #1]
	dst[0] = val;
 10128f4:	7022      	strb	r2, [r4, #0]
		sys_put_le32(NRF_FICR->ER[1], &er[4]);
 10128f6:	f8d3 2284 	ldr.w	r2, [r3, #644]	; 0x284
	sys_put_le16(val >> 16, &dst[2]);
 10128fa:	0c11      	lsrs	r1, r2, #16
	dst[1] = val >> 8;
 10128fc:	0a0d      	lsrs	r5, r1, #8
 10128fe:	f3c2 2007 	ubfx	r0, r2, #8, #8
	dst[0] = val;
 1012902:	71a1      	strb	r1, [r4, #6]
	dst[1] = val >> 8;
 1012904:	71e5      	strb	r5, [r4, #7]
 1012906:	7160      	strb	r0, [r4, #5]
	dst[0] = val;
 1012908:	7122      	strb	r2, [r4, #4]
		sys_put_le32(NRF_FICR->ER[2], &er[8]);
 101290a:	f8d3 2288 	ldr.w	r2, [r3, #648]	; 0x288
	sys_put_le16(val >> 16, &dst[2]);
 101290e:	0c11      	lsrs	r1, r2, #16
	dst[1] = val >> 8;
 1012910:	f3c2 2007 	ubfx	r0, r2, #8, #8
 1012914:	0a0d      	lsrs	r5, r1, #8
	dst[0] = val;
 1012916:	7222      	strb	r2, [r4, #8]
 1012918:	72a1      	strb	r1, [r4, #10]
	dst[1] = val >> 8;
 101291a:	7260      	strb	r0, [r4, #9]
 101291c:	72e5      	strb	r5, [r4, #11]
		sys_put_le32(NRF_FICR->ER[3], &er[12]);
 101291e:	f8d3 328c 	ldr.w	r3, [r3, #652]	; 0x28c
	sys_put_le16(val >> 16, &dst[2]);
 1012922:	0c1a      	lsrs	r2, r3, #16
	dst[1] = val >> 8;
 1012924:	0a10      	lsrs	r0, r2, #8
 1012926:	f3c3 2107 	ubfx	r1, r3, #8, #8
	dst[0] = val;
 101292a:	7323      	strb	r3, [r4, #12]
 101292c:	73a2      	strb	r2, [r4, #14]
	dst[1] = val >> 8;
 101292e:	73e0      	strb	r0, [r4, #15]
 1012930:	7361      	strb	r1, [r4, #13]
	} else {
		/* Mark ER as invalid */
		(void)memset(er, 0x00, 16);
	}
}
 1012932:	bd38      	pop	{r3, r4, r5, pc}
		(void)memset(er, 0x00, 16);
 1012934:	4620      	mov	r0, r4
}
 1012936:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		(void)memset(er, 0x00, 16);
 101293a:	2210      	movs	r2, #16
 101293c:	2100      	movs	r1, #0
 101293e:	f004 b896 	b.w	1016a6e <memset>
 1012942:	bf00      	nop
 1012944:	01ff0000 	.word	0x01ff0000

01012948 <net_buf_id>:

int net_buf_id(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);

	return buf - pool->__bufs;
 1012948:	2128      	movs	r1, #40	; 0x28
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 101294a:	7983      	ldrb	r3, [r0, #6]
	return buf - pool->__bufs;
 101294c:	4a04      	ldr	r2, [pc, #16]	; (1012960 <net_buf_id+0x18>)
 101294e:	fb01 2303 	mla	r3, r1, r3, r2
 1012952:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 1012954:	1ac0      	subs	r0, r0, r3
}
 1012956:	4b03      	ldr	r3, [pc, #12]	; (1012964 <net_buf_id+0x1c>)
	return buf - pool->__bufs;
 1012958:	10c0      	asrs	r0, r0, #3
}
 101295a:	4358      	muls	r0, r3
 101295c:	4770      	bx	lr
 101295e:	bf00      	nop
 1012960:	2100063c 	.word	0x2100063c
 1012964:	aaaaaaab 	.word	0xaaaaaaab

01012968 <fixed_data_alloc>:
	.unref = mem_pool_data_unref,
};

static u8_t *fixed_data_alloc(struct net_buf *buf, size_t *size,
			      k_timeout_t timeout)
{
 1012968:	b510      	push	{r4, lr}
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
 101296a:	2428      	movs	r4, #40	; 0x28
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 101296c:	7983      	ldrb	r3, [r0, #6]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
 101296e:	4a09      	ldr	r2, [pc, #36]	; (1012994 <fixed_data_alloc+0x2c>)
 1012970:	fb04 2303 	mla	r3, r4, r3, r2
 1012974:	6a1b      	ldr	r3, [r3, #32]

	*size = MIN(fixed->data_size, *size);
 1012976:	680a      	ldr	r2, [r1, #0]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
 1012978:	685c      	ldr	r4, [r3, #4]
	*size = MIN(fixed->data_size, *size);
 101297a:	6823      	ldr	r3, [r4, #0]
 101297c:	429a      	cmp	r2, r3
 101297e:	bf94      	ite	ls
 1012980:	600a      	strls	r2, [r1, #0]
 1012982:	600b      	strhi	r3, [r1, #0]

	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
 1012984:	f7ff ffe0 	bl	1012948 <net_buf_id>
 1012988:	e9d4 2300 	ldrd	r2, r3, [r4]
}
 101298c:	fb02 3000 	mla	r0, r2, r0, r3
 1012990:	bd10      	pop	{r4, pc}
 1012992:	bf00      	nop
 1012994:	2100063c 	.word	0x2100063c

01012998 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
 1012998:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 101299c:	4605      	mov	r5, r0
 101299e:	9101      	str	r1, [sp, #4]
	u64_t end = z_timeout_end_calc(timeout);
 10129a0:	4610      	mov	r0, r2
 10129a2:	4619      	mov	r1, r3
{
 10129a4:	4616      	mov	r6, r2
 10129a6:	461f      	mov	r7, r3
	u64_t end = z_timeout_end_calc(timeout);
 10129a8:	f005 fa15 	bl	1017dd6 <z_timeout_end_calc>
 10129ac:	4680      	mov	r8, r0
 10129ae:	4689      	mov	r9, r1
 10129b0:	f04f 0320 	mov.w	r3, #32
 10129b4:	f3ef 8a11 	mrs	sl, BASEPRI
 10129b8:	f383 8811 	msr	BASEPRI, r3
 10129bc:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
 10129c0:	8b6b      	ldrh	r3, [r5, #26]
 10129c2:	2b00      	cmp	r3, #0
 10129c4:	d053      	beq.n	1012a6e <net_buf_alloc_len+0xd6>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
 10129c6:	8b2a      	ldrh	r2, [r5, #24]
 10129c8:	429a      	cmp	r2, r3
 10129ca:	d93c      	bls.n	1012a46 <net_buf_alloc_len+0xae>
	return z_impl_k_queue_get(queue, timeout);
 10129cc:	2200      	movs	r2, #0
 10129ce:	2300      	movs	r3, #0
 10129d0:	4628      	mov	r0, r5
 10129d2:	f001 fbb3 	bl	101413c <z_impl_k_queue_get>
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
 10129d6:	4604      	mov	r4, r0
 10129d8:	2800      	cmp	r0, #0
 10129da:	d034      	beq.n	1012a46 <net_buf_alloc_len+0xae>
	__asm__ volatile(
 10129dc:	f38a 8811 	msr	BASEPRI, sl
 10129e0:	f3bf 8f6f 	isb	sy
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
 10129e4:	9b01      	ldr	r3, [sp, #4]
 10129e6:	2b00      	cmp	r3, #0
 10129e8:	d051      	beq.n	1012a8e <net_buf_alloc_len+0xf6>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
 10129ea:	ea56 0307 	orrs.w	r3, r6, r7
 10129ee:	d010      	beq.n	1012a12 <net_buf_alloc_len+0x7a>
 10129f0:	1c7b      	adds	r3, r7, #1
 10129f2:	bf08      	it	eq
 10129f4:	f1b6 3fff 	cmpeq.w	r6, #4294967295
 10129f8:	d00b      	beq.n	1012a12 <net_buf_alloc_len+0x7a>
		    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
			s64_t remaining = end - z_tick_get();
 10129fa:	f002 f95f 	bl	1014cbc <z_tick_get>
 10129fe:	ebb8 0600 	subs.w	r6, r8, r0
 1012a02:	eb69 0701 	sbc.w	r7, r9, r1
 1012a06:	2e00      	cmp	r6, #0
 1012a08:	f177 0300 	sbcs.w	r3, r7, #0
 1012a0c:	bfbc      	itt	lt
 1012a0e:	2600      	movlt	r6, #0
 1012a10:	2700      	movlt	r7, #0
	return pool->alloc->cb->alloc(buf, size, timeout);
 1012a12:	f04f 0928 	mov.w	r9, #40	; 0x28
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 1012a16:	79a3      	ldrb	r3, [r4, #6]
	return pool->alloc->cb->alloc(buf, size, timeout);
 1012a18:	f8df 8088 	ldr.w	r8, [pc, #136]	; 1012aa4 <net_buf_alloc_len+0x10c>
 1012a1c:	4632      	mov	r2, r6
 1012a1e:	fb09 8303 	mla	r3, r9, r3, r8
 1012a22:	6a1b      	ldr	r3, [r3, #32]
 1012a24:	4620      	mov	r0, r4
 1012a26:	681b      	ldr	r3, [r3, #0]
 1012a28:	a901      	add	r1, sp, #4
 1012a2a:	681d      	ldr	r5, [r3, #0]
 1012a2c:	463b      	mov	r3, r7
 1012a2e:	47a8      	blx	r5
 1012a30:	4605      	mov	r5, r0
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
 1012a32:	6120      	str	r0, [r4, #16]
		if (!buf->__buf) {
 1012a34:	bb60      	cbnz	r0, 1012a90 <net_buf_alloc_len+0xf8>
 */
static inline void net_buf_destroy(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);

	k_lifo_put(&pool->free, buf);
 1012a36:	79a0      	ldrb	r0, [r4, #6]
 1012a38:	4621      	mov	r1, r4
 1012a3a:	fb09 8000 	mla	r0, r9, r0, r8
 1012a3e:	f004 ff87 	bl	1017950 <k_queue_prepend>
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
			return NULL;
 1012a42:	462c      	mov	r4, r5
}
 1012a44:	e01f      	b.n	1012a86 <net_buf_alloc_len+0xee>
		uninit_count = pool->uninit_count--;
 1012a46:	8b68      	ldrh	r0, [r5, #26]
 1012a48:	1e43      	subs	r3, r0, #1
 1012a4a:	836b      	strh	r3, [r5, #26]
 1012a4c:	f38a 8811 	msr	BASEPRI, sl
 1012a50:	f3bf 8f6f 	isb	sy
	buf = &pool->__bufs[pool->buf_count - uninit_count];
 1012a54:	2318      	movs	r3, #24
 1012a56:	8b2c      	ldrh	r4, [r5, #24]
 1012a58:	1a24      	subs	r4, r4, r0
 1012a5a:	6a68      	ldr	r0, [r5, #36]	; 0x24
 1012a5c:	fb03 0404 	mla	r4, r3, r4, r0
	return pool - _net_buf_pool_list;
 1012a60:	4810      	ldr	r0, [pc, #64]	; (1012aa4 <net_buf_alloc_len+0x10c>)
 1012a62:	4b11      	ldr	r3, [pc, #68]	; (1012aa8 <net_buf_alloc_len+0x110>)
 1012a64:	1a2d      	subs	r5, r5, r0
 1012a66:	10ed      	asrs	r5, r5, #3
 1012a68:	435d      	muls	r5, r3
	buf->pool_id = pool_id(pool);
 1012a6a:	71a5      	strb	r5, [r4, #6]
		goto success;
 1012a6c:	e7ba      	b.n	10129e4 <net_buf_alloc_len+0x4c>
 1012a6e:	f38a 8811 	msr	BASEPRI, sl
 1012a72:	f3bf 8f6f 	isb	sy
 1012a76:	4632      	mov	r2, r6
 1012a78:	463b      	mov	r3, r7
 1012a7a:	4628      	mov	r0, r5
 1012a7c:	f001 fb5e 	bl	101413c <z_impl_k_queue_get>
	if (!buf) {
 1012a80:	4604      	mov	r4, r0
 1012a82:	2800      	cmp	r0, #0
 1012a84:	d1ae      	bne.n	10129e4 <net_buf_alloc_len+0x4c>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	pool->avail_count--;
	__ASSERT_NO_MSG(pool->avail_count >= 0);
#endif
	return buf;
}
 1012a86:	4620      	mov	r0, r4
 1012a88:	b002      	add	sp, #8
 1012a8a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		buf->__buf = NULL;
 1012a8e:	6123      	str	r3, [r4, #16]
	buf->frags = NULL;
 1012a90:	2300      	movs	r3, #0
	buf->ref   = 1U;
 1012a92:	2201      	movs	r2, #1
	buf->frags = NULL;
 1012a94:	6023      	str	r3, [r4, #0]
	buf->ref   = 1U;
 1012a96:	80a2      	strh	r2, [r4, #4]
	buf->len  = 0U;
 1012a98:	81a3      	strh	r3, [r4, #12]
	buf->size  = size;
 1012a9a:	9a01      	ldr	r2, [sp, #4]
	buf->data = buf->__buf;
 1012a9c:	6923      	ldr	r3, [r4, #16]
 1012a9e:	81e2      	strh	r2, [r4, #14]
 1012aa0:	60a3      	str	r3, [r4, #8]
	return buf;
 1012aa2:	e7f0      	b.n	1012a86 <net_buf_alloc_len+0xee>
 1012aa4:	2100063c 	.word	0x2100063c
 1012aa8:	cccccccd 	.word	0xcccccccd

01012aac <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
 1012aac:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1012ab0:	4604      	mov	r4, r0
			return;
		}

		if (buf->__buf) {
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
 1012ab2:	2500      	movs	r5, #0
	pool->alloc->cb->unref(buf, data);
 1012ab4:	2728      	movs	r7, #40	; 0x28
 1012ab6:	4e14      	ldr	r6, [pc, #80]	; (1012b08 <net_buf_unref+0x5c>)
	while (buf) {
 1012ab8:	b90c      	cbnz	r4, 1012abe <net_buf_unref+0x12>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
 1012aba:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (--buf->ref > 0) {
 1012abe:	7923      	ldrb	r3, [r4, #4]
		struct net_buf *frags = buf->frags;
 1012ac0:	f8d4 8000 	ldr.w	r8, [r4]
		if (--buf->ref > 0) {
 1012ac4:	3b01      	subs	r3, #1
 1012ac6:	b2db      	uxtb	r3, r3
 1012ac8:	7123      	strb	r3, [r4, #4]
 1012aca:	2b00      	cmp	r3, #0
 1012acc:	d1f5      	bne.n	1012aba <net_buf_unref+0xe>
		if (buf->__buf) {
 1012ace:	6921      	ldr	r1, [r4, #16]
 1012ad0:	b159      	cbz	r1, 1012aea <net_buf_unref+0x3e>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
 1012ad2:	7963      	ldrb	r3, [r4, #5]
 1012ad4:	079b      	lsls	r3, r3, #30
 1012ad6:	d407      	bmi.n	1012ae8 <net_buf_unref+0x3c>
	pool->alloc->cb->unref(buf, data);
 1012ad8:	79a3      	ldrb	r3, [r4, #6]
 1012ada:	4620      	mov	r0, r4
 1012adc:	fb07 6303 	mla	r3, r7, r3, r6
 1012ae0:	6a1b      	ldr	r3, [r3, #32]
 1012ae2:	681b      	ldr	r3, [r3, #0]
 1012ae4:	689b      	ldr	r3, [r3, #8]
 1012ae6:	4798      	blx	r3
			buf->__buf = NULL;
 1012ae8:	6125      	str	r5, [r4, #16]
		pool = net_buf_pool_get(buf->pool_id);
 1012aea:	79a0      	ldrb	r0, [r4, #6]
		buf->data = NULL;
 1012aec:	60a5      	str	r5, [r4, #8]
		if (pool->destroy) {
 1012aee:	fb07 6000 	mla	r0, r7, r0, r6
 1012af2:	69c3      	ldr	r3, [r0, #28]
		buf->frags = NULL;
 1012af4:	6025      	str	r5, [r4, #0]
		if (pool->destroy) {
 1012af6:	b11b      	cbz	r3, 1012b00 <net_buf_unref+0x54>
			pool->destroy(buf);
 1012af8:	4620      	mov	r0, r4
 1012afa:	4798      	blx	r3
{
 1012afc:	4644      	mov	r4, r8
 1012afe:	e7db      	b.n	1012ab8 <net_buf_unref+0xc>
	k_lifo_put(&pool->free, buf);
 1012b00:	4621      	mov	r1, r4
 1012b02:	f004 ff25 	bl	1017950 <k_queue_prepend>
}
 1012b06:	e7f9      	b.n	1012afc <net_buf_unref+0x50>
 1012b08:	2100063c 	.word	0x2100063c

01012b0c <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(struct device *port)
{
 1012b0c:	b508      	push	{r3, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
 1012b0e:	4b09      	ldr	r3, [pc, #36]	; (1012b34 <gpio_nrfx_init+0x28>)
 1012b10:	781a      	ldrb	r2, [r3, #0]
 1012b12:	b96a      	cbnz	r2, 1012b30 <gpio_nrfx_init+0x24>
		gpio_initialized = true;
 1012b14:	2101      	movs	r1, #1
		IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
 1012b16:	200a      	movs	r0, #10
		gpio_initialized = true;
 1012b18:	7019      	strb	r1, [r3, #0]
		IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
 1012b1a:	2105      	movs	r1, #5
 1012b1c:	f7f2 f9a8 	bl	1004e70 <z_arm_irq_priority_set>
			    gpiote_event_handler, NULL, 0);

		irq_enable(DT_IRQN(GPIOTE_NODE));
 1012b20:	200a      	movs	r0, #10
 1012b22:	f7f2 f973 	bl	1004e0c <arch_irq_enable>
    return ((uint32_t)p_reg + event);
}

NRF_STATIC_INLINE void nrf_gpiote_int_enable(NRF_GPIOTE_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
 1012b26:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 1012b2a:	4b03      	ldr	r3, [pc, #12]	; (1012b38 <gpio_nrfx_init+0x2c>)
 1012b2c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
 1012b30:	2000      	movs	r0, #0
 1012b32:	bd08      	pop	{r3, pc}
 1012b34:	210080cf 	.word	0x210080cf
 1012b38:	4100a000 	.word	0x4100a000

01012b3c <gpio_nrfx_config>:
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
 1012b3c:	4b2b      	ldr	r3, [pc, #172]	; (1012bec <gpio_nrfx_config+0xb0>)
{
 1012b3e:	b5f0      	push	{r4, r5, r6, r7, lr}
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1012b40:	6846      	ldr	r6, [r0, #4]
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
 1012b42:	482b      	ldr	r0, [pc, #172]	; (1012bf0 <gpio_nrfx_config+0xb4>)
 1012b44:	4013      	ands	r3, r2
 1012b46:	4283      	cmp	r3, r0
 1012b48:	d042      	beq.n	1012bd0 <gpio_nrfx_config+0x94>
 1012b4a:	d80d      	bhi.n	1012b68 <gpio_nrfx_config+0x2c>
 1012b4c:	2b06      	cmp	r3, #6
 1012b4e:	d015      	beq.n	1012b7c <gpio_nrfx_config+0x40>
 1012b50:	d805      	bhi.n	1012b5e <gpio_nrfx_config+0x22>
 1012b52:	b19b      	cbz	r3, 1012b7c <gpio_nrfx_config+0x40>
 1012b54:	2b02      	cmp	r3, #2
 1012b56:	d03d      	beq.n	1012bd4 <gpio_nrfx_config+0x98>
 1012b58:	f06f 0015 	mvn.w	r0, #21
 1012b5c:	e037      	b.n	1012bce <gpio_nrfx_config+0x92>
 1012b5e:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 1012b62:	d1f9      	bne.n	1012b58 <gpio_nrfx_config+0x1c>
		drive = NRF_GPIO_PIN_H0S1;
 1012b64:	2301      	movs	r3, #1
 1012b66:	e009      	b.n	1012b7c <gpio_nrfx_config+0x40>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
 1012b68:	4822      	ldr	r0, [pc, #136]	; (1012bf4 <gpio_nrfx_config+0xb8>)
 1012b6a:	4283      	cmp	r3, r0
 1012b6c:	d034      	beq.n	1012bd8 <gpio_nrfx_config+0x9c>
 1012b6e:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
 1012b72:	d033      	beq.n	1012bdc <gpio_nrfx_config+0xa0>
 1012b74:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 1012b78:	d1ee      	bne.n	1012b58 <gpio_nrfx_config+0x1c>
		drive = NRF_GPIO_PIN_S0H1;
 1012b7a:	2302      	movs	r3, #2
	if ((flags & GPIO_PULL_UP) != 0) {
 1012b7c:	06d0      	lsls	r0, r2, #27
		pull = NRF_GPIO_PIN_PULLUP;
 1012b7e:	bf4c      	ite	mi
 1012b80:	2503      	movmi	r5, #3
		pull = NRF_GPIO_PIN_NOPULL;
 1012b82:	f3c2 1540 	ubfxpl	r5, r2, #5, #1
		: NRF_GPIO_PIN_INPUT_DISCONNECT;
 1012b86:	f482 7480 	eor.w	r4, r2, #256	; 0x100
	if ((flags & GPIO_OUTPUT) != 0) {
 1012b8a:	0597      	lsls	r7, r2, #22
	dir = ((flags & GPIO_OUTPUT) != 0)
 1012b8c:	f3c2 2040 	ubfx	r0, r2, #9, #1
		: NRF_GPIO_PIN_INPUT_DISCONNECT;
 1012b90:	f3c4 2400 	ubfx	r4, r4, #8, #1
	if ((flags & GPIO_OUTPUT) != 0) {
 1012b94:	d506      	bpl.n	1012ba4 <gpio_nrfx_config+0x68>
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
 1012b96:	f412 6f00 	tst.w	r2, #2048	; 0x800
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1012b9a:	6877      	ldr	r7, [r6, #4]
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
 1012b9c:	d020      	beq.n	1012be0 <gpio_nrfx_config+0xa4>
			nrf_gpio_port_out_set(reg, BIT(pin));
 1012b9e:	2201      	movs	r2, #1
 1012ba0:	408a      	lsls	r2, r1
}


NRF_STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
 1012ba2:	60ba      	str	r2, [r7, #8]
	nrf_gpio_cfg(NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin),
 1012ba4:	7a32      	ldrb	r2, [r6, #8]
 1012ba6:	f001 011f 	and.w	r1, r1, #31
 1012baa:	ea41 1142 	orr.w	r1, r1, r2, lsl #5
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
 1012bae:	ea40 0244 	orr.w	r2, r0, r4, lsl #1
	return 0;
 1012bb2:	2000      	movs	r0, #0
    if (*p_pin < P0_PIN_NUM)
 1012bb4:	291f      	cmp	r1, #31
        return NRF_P1;
 1012bb6:	bfca      	itet	gt
 1012bb8:	4e0f      	ldrgt	r6, [pc, #60]	; (1012bf8 <gpio_nrfx_config+0xbc>)
        return NRF_P0;
 1012bba:	4e10      	ldrle	r6, [pc, #64]	; (1012bfc <gpio_nrfx_config+0xc0>)
        *p_pin = *p_pin & 0x1F;
 1012bbc:	f001 011f 	andgt.w	r1, r1, #31
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
 1012bc0:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 1012bc4:	ea43 0385 	orr.w	r3, r3, r5, lsl #2
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
 1012bc8:	3180      	adds	r1, #128	; 0x80
 1012bca:	f846 3021 	str.w	r3, [r6, r1, lsl #2]
}
 1012bce:	bdf0      	pop	{r4, r5, r6, r7, pc}
		drive = NRF_GPIO_PIN_H0D1;
 1012bd0:	2307      	movs	r3, #7
 1012bd2:	e7d3      	b.n	1012b7c <gpio_nrfx_config+0x40>
		drive = NRF_GPIO_PIN_D0S1;
 1012bd4:	2304      	movs	r3, #4
 1012bd6:	e7d1      	b.n	1012b7c <gpio_nrfx_config+0x40>
		drive = NRF_GPIO_PIN_D0H1;
 1012bd8:	2305      	movs	r3, #5
 1012bda:	e7cf      	b.n	1012b7c <gpio_nrfx_config+0x40>
		drive = NRF_GPIO_PIN_H0H1;
 1012bdc:	2303      	movs	r3, #3
 1012bde:	e7cd      	b.n	1012b7c <gpio_nrfx_config+0x40>
		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
 1012be0:	0552      	lsls	r2, r2, #21
			nrf_gpio_port_out_clear(reg, BIT(pin));
 1012be2:	bf42      	ittt	mi
 1012be4:	2201      	movmi	r2, #1
 1012be6:	408a      	lslmi	r2, r1
}


NRF_STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
    p_reg->OUTCLR = clr_mask;
 1012be8:	60fa      	strmi	r2, [r7, #12]
}
 1012bea:	e7db      	b.n	1012ba4 <gpio_nrfx_config+0x68>
 1012bec:	00f00006 	.word	0x00f00006
 1012bf0:	00100006 	.word	0x00100006
 1012bf4:	00400002 	.word	0x00400002
 1012bf8:	418c0800 	.word	0x418c0800
 1012bfc:	418c0500 	.word	0x418c0500

01012c00 <nrf_gpio_cfg_sense_set>:
    if (*p_pin < P0_PIN_NUM)
 1012c00:	281f      	cmp	r0, #31
        return NRF_P1;
 1012c02:	bf8a      	itet	hi
 1012c04:	4b07      	ldrhi	r3, [pc, #28]	; (1012c24 <nrf_gpio_cfg_sense_set+0x24>)
        return NRF_P0;
 1012c06:	4b08      	ldrls	r3, [pc, #32]	; (1012c28 <nrf_gpio_cfg_sense_set+0x28>)
        *p_pin = *p_pin & 0x1F;
 1012c08:	f000 001f 	andhi.w	r0, r0, #31
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
 1012c0c:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 1012c10:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
 1012c14:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
 1012c18:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 1012c1c:	f8c0 1200 	str.w	r1, [r0, #512]	; 0x200
}
 1012c20:	4770      	bx	lr
 1012c22:	bf00      	nop
 1012c24:	418c0800 	.word	0x418c0800
 1012c28:	418c0500 	.word	0x418c0500

01012c2c <gpiote_pin_int_cfg>:
{
 1012c2c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
 1012c2e:	6843      	ldr	r3, [r0, #4]
	struct gpio_nrfx_data *data = get_port_data(port);
 1012c30:	68c6      	ldr	r6, [r0, #12]
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
 1012c32:	7a18      	ldrb	r0, [r3, #8]
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
 1012c34:	2300      	movs	r3, #0
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
 1012c36:	f001 041f 	and.w	r4, r1, #31
{
 1012c3a:	460d      	mov	r5, r1
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg, uint32_t mask)
{
    return p_reg->INTENSET & mask;
 1012c3c:	4947      	ldr	r1, [pc, #284]	; (1012d5c <gpiote_pin_int_cfg+0x130>)
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
 1012c3e:	ea44 1440 	orr.w	r4, r4, r0, lsl #5
 1012c42:	f8d1 2304 	ldr.w	r2, [r1, #772]	; 0x304
 1012c46:	b2d2      	uxtb	r2, r2
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
 1012c48:	f503 70a2 	add.w	r0, r3, #324	; 0x144
 1012c4c:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
 1012c50:	f3c0 2005 	ubfx	r0, r0, #8, #6
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
 1012c54:	4284      	cmp	r4, r0
 1012c56:	d16a      	bne.n	1012d2e <gpiote_pin_int_cfg+0x102>
		    && (intenset & BIT(i))) {
 1012c58:	fa22 f003 	lsr.w	r0, r2, r3
 1012c5c:	07c0      	lsls	r0, r0, #31
 1012c5e:	d566      	bpl.n	1012d2e <gpiote_pin_int_cfg+0x102>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
 1012c60:	009a      	lsls	r2, r3, #2
 1012c62:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
 1012c66:	f502 4220 	add.w	r2, r2, #40960	; 0xa000
 1012c6a:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
 1012c6e:	f020 0001 	bic.w	r0, r0, #1
 1012c72:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
 1012c76:	2201      	movs	r2, #1
 1012c78:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENCLR = mask;
 1012c7c:	f8c1 3308 	str.w	r3, [r1, #776]	; 0x308
	nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
 1012c80:	4620      	mov	r0, r4
 1012c82:	2100      	movs	r1, #0
 1012c84:	f7ff ffbc 	bl	1012c00 <nrf_gpio_cfg_sense_set>
	if ((data->pin_int_en & BIT(pin)) && (data->int_en & BIT(pin))) {
 1012c88:	68f3      	ldr	r3, [r6, #12]
 1012c8a:	40eb      	lsrs	r3, r5
 1012c8c:	f013 0001 	ands.w	r0, r3, #1
 1012c90:	d04c      	beq.n	1012d2c <gpiote_pin_int_cfg+0x100>
 1012c92:	6933      	ldr	r3, [r6, #16]
 1012c94:	40eb      	lsrs	r3, r5
 1012c96:	f013 0001 	ands.w	r0, r3, #1
 1012c9a:	d047      	beq.n	1012d2c <gpiote_pin_int_cfg+0x100>
		if (data->trig_edge & BIT(pin)) {
 1012c9c:	69b3      	ldr	r3, [r6, #24]
 1012c9e:	40eb      	lsrs	r3, r5
 1012ca0:	f013 0201 	ands.w	r2, r3, #1
 1012ca4:	d04d      	beq.n	1012d42 <gpiote_pin_int_cfg+0x116>
			if (data->double_edge & BIT(pin)) {
 1012ca6:	69f3      	ldr	r3, [r6, #28]
    p_reg->CONFIG[idx] = 0;
}

NRF_STATIC_INLINE bool nrf_gpiote_te_is_enabled(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return (p_reg->CONFIG[idx] & GPIOTE_CONFIG_MODE_Msk) != GPIOTE_CONFIG_MODE_Disabled;
 1012ca8:	4f2c      	ldr	r7, [pc, #176]	; (1012d5c <gpiote_pin_int_cfg+0x130>)
 1012caa:	40eb      	lsrs	r3, r5
 1012cac:	07db      	lsls	r3, r3, #31
			} else if ((data->int_active_level & BIT(pin)) != 0U) {
 1012cae:	bf54      	ite	pl
 1012cb0:	6971      	ldrpl	r1, [r6, #20]
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
 1012cb2:	2503      	movmi	r5, #3
 1012cb4:	f04f 0600 	mov.w	r6, #0
			} else if ((data->int_active_level & BIT(pin)) != 0U) {
 1012cb8:	bf5f      	itttt	pl
 1012cba:	fa21 f505 	lsrpl.w	r5, r1, r5
 1012cbe:	f005 0501 	andpl.w	r5, r5, #1
 1012cc2:	f1c5 0502 	rsbpl	r5, r5, #2
 1012cc6:	b2ed      	uxtbpl	r5, r5
 1012cc8:	f506 73a2 	add.w	r3, r6, #324	; 0x144
 1012ccc:	f857 0023 	ldr.w	r0, [r7, r3, lsl #2]
		if (!nrf_gpiote_te_is_enabled(NRF_GPIOTE, channel)) {
 1012cd0:	f010 0003 	ands.w	r0, r0, #3
 1012cd4:	d12f      	bne.n	1012d36 <gpiote_pin_int_cfg+0x10a>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
 1012cd6:	00b2      	lsls	r2, r6, #2
 1012cd8:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
 1012cdc:	f502 4220 	add.w	r2, r2, #40960	; 0xa000
 1012ce0:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
 1012ce4:	0224      	lsls	r4, r4, #8
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
 1012ce6:	f421 314f 	bic.w	r1, r1, #211968	; 0x33c00
 1012cea:	f421 7140 	bic.w	r1, r1, #768	; 0x300
 1012cee:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
 1012cf2:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
 1012cf6:	f404 547c 	and.w	r4, r4, #16128	; 0x3f00
 1012cfa:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 1012cfe:	430d      	orrs	r5, r1
			nrf_gpiote_event_t evt =
 1012d00:	f106 0140 	add.w	r1, r6, #64	; 0x40
 1012d04:	0089      	lsls	r1, r1, #2
    return ((uint32_t)p_reg + event);
 1012d06:	b289      	uxth	r1, r1
 1012d08:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
 1012d0c:	f501 4120 	add.w	r1, r1, #40960	; 0xa000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
 1012d10:	f8c2 5510 	str.w	r5, [r2, #1296]	; 0x510
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
 1012d14:	6008      	str	r0, [r1, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
 1012d16:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
 1012d1a:	f041 0101 	orr.w	r1, r1, #1
 1012d1e:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
			nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
 1012d22:	2201      	movs	r2, #1
 1012d24:	fa02 f606 	lsl.w	r6, r2, r6
    p_reg->INTENSET = mask;
 1012d28:	f8c7 6304 	str.w	r6, [r7, #772]	; 0x304
}
 1012d2c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
 1012d2e:	3301      	adds	r3, #1
 1012d30:	2b08      	cmp	r3, #8
 1012d32:	d189      	bne.n	1012c48 <gpiote_pin_int_cfg+0x1c>
 1012d34:	e7a4      	b.n	1012c80 <gpiote_pin_int_cfg+0x54>
	for (u8_t channel = 0; channel < GPIOTE_CH_NUM; ++channel) {
 1012d36:	3601      	adds	r6, #1
 1012d38:	2e08      	cmp	r6, #8
 1012d3a:	d1c5      	bne.n	1012cc8 <gpiote_pin_int_cfg+0x9c>
	return -ENODEV;
 1012d3c:	f06f 0012 	mvn.w	r0, #18
 1012d40:	e7f4      	b.n	1012d2c <gpiote_pin_int_cfg+0x100>
	if ((BIT(pin) & data->int_active_level) != 0U) {
 1012d42:	6971      	ldr	r1, [r6, #20]
			nrf_gpio_cfg_sense_set(abs_pin, sense);
 1012d44:	4620      	mov	r0, r4
	if ((BIT(pin) & data->int_active_level) != 0U) {
 1012d46:	40e9      	lsrs	r1, r5
 1012d48:	f001 0101 	and.w	r1, r1, #1
 1012d4c:	f1c1 0103 	rsb	r1, r1, #3
			nrf_gpio_cfg_sense_set(abs_pin, sense);
 1012d50:	b2c9      	uxtb	r1, r1
 1012d52:	f7ff ff55 	bl	1012c00 <nrf_gpio_cfg_sense_set>
	int res = 0;
 1012d56:	4610      	mov	r0, r2
 1012d58:	e7e8      	b.n	1012d2c <gpiote_pin_int_cfg+0x100>
 1012d5a:	bf00      	nop
 1012d5c:	4100a000 	.word	0x4100a000

01012d60 <gpio_nrfx_pin_interrupt_configure>:
	if ((mode == GPIO_INT_MODE_EDGE) &&
 1012d60:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
{
 1012d64:	b470      	push	{r4, r5, r6}
	struct gpio_nrfx_data *data = get_port_data(port);
 1012d66:	68c4      	ldr	r4, [r0, #12]
	if ((mode == GPIO_INT_MODE_EDGE) &&
 1012d68:	d114      	bne.n	1012d94 <gpio_nrfx_pin_interrupt_configure+0x34>
	u32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
 1012d6a:	6845      	ldr	r5, [r0, #4]
 1012d6c:	7a2e      	ldrb	r6, [r5, #8]
 1012d6e:	f001 051f 	and.w	r5, r1, #31
 1012d72:	ea45 1546 	orr.w	r5, r5, r6, lsl #5
    if (*p_pin < P0_PIN_NUM)
 1012d76:	2d1f      	cmp	r5, #31
        return NRF_P1;
 1012d78:	bfca      	itet	gt
 1012d7a:	4e1e      	ldrgt	r6, [pc, #120]	; (1012df4 <gpio_nrfx_pin_interrupt_configure+0x94>)
        return NRF_P0;
 1012d7c:	4e1e      	ldrle	r6, [pc, #120]	; (1012df8 <gpio_nrfx_pin_interrupt_configure+0x98>)
        *p_pin = *p_pin & 0x1F;
 1012d7e:	f005 051f 	andgt.w	r5, r5, #31
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
 1012d82:	3580      	adds	r5, #128	; 0x80
 1012d84:	f856 5025 	ldr.w	r5, [r6, r5, lsl #2]
	if ((mode == GPIO_INT_MODE_EDGE) &&
 1012d88:	07ed      	lsls	r5, r5, #31
 1012d8a:	d507      	bpl.n	1012d9c <gpio_nrfx_pin_interrupt_configure+0x3c>
}
 1012d8c:	f06f 0022 	mvn.w	r0, #34	; 0x22
 1012d90:	bc70      	pop	{r4, r5, r6}
 1012d92:	4770      	bx	lr
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
 1012d94:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 1012d98:	68e5      	ldr	r5, [r4, #12]
 1012d9a:	d026      	beq.n	1012dea <gpio_nrfx_pin_interrupt_configure+0x8a>
 1012d9c:	2501      	movs	r5, #1
 1012d9e:	68e6      	ldr	r6, [r4, #12]
 1012da0:	408d      	lsls	r5, r1
 1012da2:	4335      	orrs	r5, r6
 1012da4:	60e5      	str	r5, [r4, #12]
	WRITE_BIT(data->int_en, pin, mode != GPIO_INT_MODE_DISABLED);
 1012da6:	2501      	movs	r5, #1
 1012da8:	6926      	ldr	r6, [r4, #16]
 1012daa:	408d      	lsls	r5, r1
 1012dac:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 1012db0:	bf14      	ite	ne
 1012db2:	432e      	orrne	r6, r5
 1012db4:	43ae      	biceq	r6, r5
 1012db6:	6126      	str	r6, [r4, #16]
	WRITE_BIT(data->trig_edge, pin, mode == GPIO_INT_MODE_EDGE);
 1012db8:	69a6      	ldr	r6, [r4, #24]
 1012dba:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
 1012dbe:	69e2      	ldr	r2, [r4, #28]
 1012dc0:	bf0c      	ite	eq
 1012dc2:	432e      	orreq	r6, r5
 1012dc4:	43ae      	bicne	r6, r5
	WRITE_BIT(data->double_edge, pin, trig == GPIO_INT_TRIG_BOTH);
 1012dc6:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
 1012dca:	bf0c      	ite	eq
 1012dcc:	432a      	orreq	r2, r5
 1012dce:	43aa      	bicne	r2, r5
 1012dd0:	61e2      	str	r2, [r4, #28]
 1012dd2:	6962      	ldr	r2, [r4, #20]
	WRITE_BIT(data->int_active_level, pin, trig == GPIO_INT_TRIG_HIGH);
 1012dd4:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 1012dd8:	bf0c      	ite	eq
 1012dda:	4315      	orreq	r5, r2
 1012ddc:	ea22 0505 	bicne.w	r5, r2, r5
	WRITE_BIT(data->trig_edge, pin, mode == GPIO_INT_MODE_EDGE);
 1012de0:	61a6      	str	r6, [r4, #24]
	WRITE_BIT(data->int_active_level, pin, trig == GPIO_INT_TRIG_HIGH);
 1012de2:	6165      	str	r5, [r4, #20]
}
 1012de4:	bc70      	pop	{r4, r5, r6}
	return gpiote_pin_int_cfg(port, pin);
 1012de6:	f7ff bf21 	b.w	1012c2c <gpiote_pin_int_cfg>
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
 1012dea:	2601      	movs	r6, #1
 1012dec:	408e      	lsls	r6, r1
 1012dee:	ea25 0506 	bic.w	r5, r5, r6
 1012df2:	e7d7      	b.n	1012da4 <gpio_nrfx_pin_interrupt_configure+0x44>
 1012df4:	418c0800 	.word	0x418c0800
 1012df8:	418c0500 	.word	0x418c0500

01012dfc <gpiote_event_handler>:
{
 1012dfc:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	u32_t fired_triggers[GPIO_COUNT] = {0};
 1012dfe:	2500      	movs	r5, #0
 1012e00:	e9cd 5500 	strd	r5, r5, [sp]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 1012e04:	4e24      	ldr	r6, [pc, #144]	; (1012e98 <gpiote_event_handler+0x9c>)
 1012e06:	6834      	ldr	r4, [r6, #0]
	if (port_event) {
 1012e08:	b144      	cbz	r4, 1012e1c <gpiote_event_handler+0x20>
			check_level_trigger_pins(DEVICE_GET(gpio_nrfx_p0));
 1012e0a:	4824      	ldr	r0, [pc, #144]	; (1012e9c <gpiote_event_handler+0xa0>)
 1012e0c:	f003 ffa5 	bl	1016d5a <check_level_trigger_pins>
		fired_triggers[0] =
 1012e10:	9000      	str	r0, [sp, #0]
			check_level_trigger_pins(DEVICE_GET(gpio_nrfx_p1));
 1012e12:	4823      	ldr	r0, [pc, #140]	; (1012ea0 <gpiote_event_handler+0xa4>)
 1012e14:	f003 ffa1 	bl	1016d5a <check_level_trigger_pins>
		fired_triggers[1] =
 1012e18:	9001      	str	r0, [sp, #4]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
 1012e1a:	6035      	str	r5, [r6, #0]
{
 1012e1c:	2200      	movs	r2, #0
		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
 1012e1e:	2601      	movs	r6, #1
 1012e20:	4694      	mov	ip, r2
    return p_reg->INTENSET & mask;
 1012e22:	4d20      	ldr	r5, [pc, #128]	; (1012ea4 <gpiote_event_handler+0xa8>)
 1012e24:	f8d5 3304 	ldr.w	r3, [r5, #772]	; 0x304
 1012e28:	fa06 f102 	lsl.w	r1, r6, r2
 1012e2c:	4219      	tst	r1, r3
 1012e2e:	d01a      	beq.n	1012e66 <gpiote_event_handler+0x6a>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 1012e30:	0091      	lsls	r1, r2, #2
 1012e32:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
 1012e36:	f501 4121 	add.w	r1, r1, #41216	; 0xa100
 1012e3a:	680b      	ldr	r3, [r1, #0]
 1012e3c:	b19b      	cbz	r3, 1012e66 <gpiote_event_handler+0x6a>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
 1012e3e:	f502 73a2 	add.w	r3, r2, #324	; 0x144
 1012e42:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
 1012e46:	af02      	add	r7, sp, #8
 1012e48:	f3c3 3040 	ubfx	r0, r3, #13, #1
 1012e4c:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 1012e50:	f850 7c08 	ldr.w	r7, [r0, #-8]
 1012e54:	f3c3 2304 	ubfx	r3, r3, #8, #5
 1012e58:	fa06 f303 	lsl.w	r3, r6, r3
 1012e5c:	433b      	orrs	r3, r7
 1012e5e:	f840 3c08 	str.w	r3, [r0, #-8]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
 1012e62:	f8c1 c000 	str.w	ip, [r1]
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
 1012e66:	3201      	adds	r2, #1
 1012e68:	2a08      	cmp	r2, #8
 1012e6a:	d1db      	bne.n	1012e24 <gpiote_event_handler+0x28>
	if (fired_triggers[0]) {
 1012e6c:	9900      	ldr	r1, [sp, #0]
 1012e6e:	b111      	cbz	r1, 1012e76 <gpiote_event_handler+0x7a>
		fire_callbacks(DEVICE_GET(gpio_nrfx_p0), fired_triggers[0]);
 1012e70:	480a      	ldr	r0, [pc, #40]	; (1012e9c <gpiote_event_handler+0xa0>)
 1012e72:	f003 ff52 	bl	1016d1a <fire_callbacks>
	if (fired_triggers[1]) {
 1012e76:	9901      	ldr	r1, [sp, #4]
 1012e78:	b111      	cbz	r1, 1012e80 <gpiote_event_handler+0x84>
		fire_callbacks(DEVICE_GET(gpio_nrfx_p1), fired_triggers[1]);
 1012e7a:	4809      	ldr	r0, [pc, #36]	; (1012ea0 <gpiote_event_handler+0xa4>)
 1012e7c:	f003 ff4d 	bl	1016d1a <fire_callbacks>
	if (port_event) {
 1012e80:	b144      	cbz	r4, 1012e94 <gpiote_event_handler+0x98>
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p0));
 1012e82:	4806      	ldr	r0, [pc, #24]	; (1012e9c <gpiote_event_handler+0xa0>)
 1012e84:	f003 ff8e 	bl	1016da4 <cfg_level_pins>
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p1));
 1012e88:	4805      	ldr	r0, [pc, #20]	; (1012ea0 <gpiote_event_handler+0xa4>)
}
 1012e8a:	b003      	add	sp, #12
 1012e8c:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p1));
 1012e90:	f003 bf88 	b.w	1016da4 <cfg_level_pins>
}
 1012e94:	b003      	add	sp, #12
 1012e96:	bdf0      	pop	{r4, r5, r6, r7, pc}
 1012e98:	4100a17c 	.word	0x4100a17c
 1012e9c:	21000564 	.word	0x21000564
 1012ea0:	21000574 	.word	0x21000574
 1012ea4:	4100a000 	.word	0x4100a000

01012ea8 <vipm_nrf_0_register_callback>:
		    &vipm_nrf_##_idx##_driver_api)

#define VIPM_DEVICE(_idx, _)						\
	IF_ENABLED(CONFIG_IPM_MSG_CH_##_idx##_ENABLE, (VIPM_DEVICE_1(_idx);))

UTIL_LISTIFY(NRFX_IPC_ID_MAX_VALUE, VIPM_DEVICE, _);
 1012ea8:	4b01      	ldr	r3, [pc, #4]	; (1012eb0 <vipm_nrf_0_register_callback+0x8>)
 1012eaa:	6019      	str	r1, [r3, #0]
 1012eac:	641a      	str	r2, [r3, #64]	; 0x40
 1012eae:	4770      	bx	lr
 1012eb0:	2100593c 	.word	0x2100593c

01012eb4 <vipm_nrf_0_send>:
 1012eb4:	b508      	push	{r3, lr}
 1012eb6:	4906      	ldr	r1, [pc, #24]	; (1012ed0 <vipm_nrf_0_send+0x1c>)
 1012eb8:	4b06      	ldr	r3, [pc, #24]	; (1012ed4 <vipm_nrf_0_send+0x20>)
 1012eba:	4807      	ldr	r0, [pc, #28]	; (1012ed8 <vipm_nrf_0_send+0x24>)
 1012ebc:	1ac9      	subs	r1, r1, r3
 1012ebe:	08c9      	lsrs	r1, r1, #3
 1012ec0:	0189      	lsls	r1, r1, #6
 1012ec2:	f041 0101 	orr.w	r1, r1, #1
 1012ec6:	f002 fb12 	bl	10154ee <log_0>
 1012eca:	f06f 0015 	mvn.w	r0, #21
 1012ece:	bd08      	pop	{r3, pc}
 1012ed0:	010182f0 	.word	0x010182f0
 1012ed4:	01018208 	.word	0x01018208
 1012ed8:	01019926 	.word	0x01019926

01012edc <vipm_nrf_1_set_enabled>:
 1012edc:	b508      	push	{r3, lr}
 1012ede:	4906      	ldr	r1, [pc, #24]	; (1012ef8 <vipm_nrf_1_set_enabled+0x1c>)
 1012ee0:	4b06      	ldr	r3, [pc, #24]	; (1012efc <vipm_nrf_1_set_enabled+0x20>)
 1012ee2:	4807      	ldr	r0, [pc, #28]	; (1012f00 <vipm_nrf_1_set_enabled+0x24>)
 1012ee4:	1ac9      	subs	r1, r1, r3
 1012ee6:	08c9      	lsrs	r1, r1, #3
 1012ee8:	0189      	lsls	r1, r1, #6
 1012eea:	f041 0101 	orr.w	r1, r1, #1
 1012eee:	f002 fafe 	bl	10154ee <log_0>
 1012ef2:	f06f 0015 	mvn.w	r0, #21
 1012ef6:	bd08      	pop	{r3, pc}
 1012ef8:	010182f0 	.word	0x010182f0
 1012efc:	01018208 	.word	0x01018208
 1012f00:	01019942 	.word	0x01019942

01012f04 <vipm_nrf_1_register_callback>:
 1012f04:	4904      	ldr	r1, [pc, #16]	; (1012f18 <vipm_nrf_1_register_callback+0x14>)
 1012f06:	4b05      	ldr	r3, [pc, #20]	; (1012f1c <vipm_nrf_1_register_callback+0x18>)
 1012f08:	4805      	ldr	r0, [pc, #20]	; (1012f20 <vipm_nrf_1_register_callback+0x1c>)
 1012f0a:	1ac9      	subs	r1, r1, r3
 1012f0c:	08c9      	lsrs	r1, r1, #3
 1012f0e:	0189      	lsls	r1, r1, #6
 1012f10:	f041 0102 	orr.w	r1, r1, #2
 1012f14:	f002 baeb 	b.w	10154ee <log_0>
 1012f18:	010182f0 	.word	0x010182f0
 1012f1c:	01018208 	.word	0x01018208
 1012f20:	0101995e 	.word	0x0101995e

01012f24 <vipm_nrf_init>:
{
 1012f24:	b538      	push	{r3, r4, r5, lr}
	if (!nrfx_vipm_data.ipm_init) {
 1012f26:	4d0b      	ldr	r5, [pc, #44]	; (1012f54 <vipm_nrf_init+0x30>)
 1012f28:	f895 4080 	ldrb.w	r4, [r5, #128]	; 0x80
 1012f2c:	b97c      	cbnz	r4, 1012f4e <vipm_nrf_init+0x2a>
{
	/* Init IPC */
#if IS_ENABLED(CONFIG_IPM_NRF_SINGLE_INSTANCE)
	nrfx_ipc_init(0, nrfx_ipc_handler, (void *)&nrfx_ipm_data);
#else
	nrfx_ipc_init(0, vipm_dispatcher, (void *)&nrfx_ipm_data);
 1012f2e:	4a0a      	ldr	r2, [pc, #40]	; (1012f58 <vipm_nrf_init+0x34>)
 1012f30:	490a      	ldr	r1, [pc, #40]	; (1012f5c <vipm_nrf_init+0x38>)
 1012f32:	4620      	mov	r0, r4
 1012f34:	f000 fb02 	bl	101353c <nrfx_ipc_init>
#endif
	IRQ_CONNECT(DT_INST_IRQN(0),
 1012f38:	4622      	mov	r2, r4
 1012f3a:	2101      	movs	r1, #1
 1012f3c:	2012      	movs	r0, #18
 1012f3e:	f7f1 ff97 	bl	1004e70 <z_arm_irq_priority_set>
		    DT_INST_IRQ(0, priority),
		    nrfx_isr, nrfx_ipc_irq_handler, 0);

	/* Set up signals and channels */
	nrfx_ipc_config_load(&ipc_cfg);
 1012f42:	4807      	ldr	r0, [pc, #28]	; (1012f60 <vipm_nrf_init+0x3c>)
 1012f44:	f000 fb12 	bl	101356c <nrfx_ipc_config_load>
		nrfx_vipm_data.ipm_init = true;
 1012f48:	2301      	movs	r3, #1
 1012f4a:	f885 3080 	strb.w	r3, [r5, #128]	; 0x80
}
 1012f4e:	2000      	movs	r0, #0
 1012f50:	bd38      	pop	{r3, r4, r5, pc}
 1012f52:	bf00      	nop
 1012f54:	2100593c 	.word	0x2100593c
 1012f58:	21005934 	.word	0x21005934
 1012f5c:	01012f65 	.word	0x01012f65
 1012f60:	01018e8c 	.word	0x01018e8c

01012f64 <vipm_dispatcher>:
{
 1012f64:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1012f66:	4604      	mov	r4, r0
		event_mask &= ~BIT(event_idx);
 1012f68:	2701      	movs	r7, #1
		if (nrfx_vipm_data.callback[event_idx] != NULL) {
 1012f6a:	4d0b      	ldr	r5, [pc, #44]	; (1012f98 <vipm_dispatcher+0x34>)
	while (event_mask) {
 1012f6c:	b904      	cbnz	r4, 1012f70 <vipm_dispatcher+0xc>
}
 1012f6e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 1012f70:	fa94 f3a4 	rbit	r3, r4
   */
  if (value == 0U)
  {
    return 32U;
  }
  return __builtin_clz(value);
 1012f74:	fab3 f383 	clz	r3, r3
		if (nrfx_vipm_data.callback[event_idx] != NULL) {
 1012f78:	f855 6023 	ldr.w	r6, [r5, r3, lsl #2]
		event_mask &= ~BIT(event_idx);
 1012f7c:	fa07 f203 	lsl.w	r2, r7, r3
 1012f80:	ea24 0402 	bic.w	r4, r4, r2
		if (nrfx_vipm_data.callback[event_idx] != NULL) {
 1012f84:	2e00      	cmp	r6, #0
 1012f86:	d0f1      	beq.n	1012f6c <vipm_dispatcher+0x8>
			nrfx_vipm_data.callback[event_idx]
 1012f88:	2200      	movs	r2, #0
 1012f8a:	3310      	adds	r3, #16
 1012f8c:	4611      	mov	r1, r2
 1012f8e:	f855 0023 	ldr.w	r0, [r5, r3, lsl #2]
 1012f92:	47b0      	blx	r6
 1012f94:	e7ea      	b.n	1012f6c <vipm_dispatcher+0x8>
 1012f96:	bf00      	nop
 1012f98:	2100593c 	.word	0x2100593c

01012f9c <vipm_nrf_1_send>:
UTIL_LISTIFY(NRFX_IPC_ID_MAX_VALUE, VIPM_DEVICE, _);
 1012f9c:	2a10      	cmp	r2, #16
 1012f9e:	b508      	push	{r3, lr}
 1012fa0:	d81c      	bhi.n	1012fdc <vipm_nrf_1_send+0x40>
 1012fa2:	b14a      	cbz	r2, 1012fb8 <vipm_nrf_1_send+0x1c>
 1012fa4:	490f      	ldr	r1, [pc, #60]	; (1012fe4 <vipm_nrf_1_send+0x48>)
 1012fa6:	4b10      	ldr	r3, [pc, #64]	; (1012fe8 <vipm_nrf_1_send+0x4c>)
 1012fa8:	4810      	ldr	r0, [pc, #64]	; (1012fec <vipm_nrf_1_send+0x50>)
 1012faa:	1ac9      	subs	r1, r1, r3
 1012fac:	08c9      	lsrs	r1, r1, #3
 1012fae:	0189      	lsls	r1, r1, #6
 1012fb0:	f041 0102 	orr.w	r1, r1, #2
 1012fb4:	f002 fa9b 	bl	10154ee <log_0>
 1012fb8:	9b02      	ldr	r3, [sp, #8]
 1012fba:	2b00      	cmp	r3, #0
 1012fbc:	dd09      	ble.n	1012fd2 <vipm_nrf_1_send+0x36>
 1012fbe:	4909      	ldr	r1, [pc, #36]	; (1012fe4 <vipm_nrf_1_send+0x48>)
 1012fc0:	4b09      	ldr	r3, [pc, #36]	; (1012fe8 <vipm_nrf_1_send+0x4c>)
 1012fc2:	480b      	ldr	r0, [pc, #44]	; (1012ff0 <vipm_nrf_1_send+0x54>)
 1012fc4:	1ac9      	subs	r1, r1, r3
 1012fc6:	08c9      	lsrs	r1, r1, #3
 1012fc8:	0189      	lsls	r1, r1, #6
 1012fca:	f041 0102 	orr.w	r1, r1, #2
 1012fce:	f002 fa8e 	bl	10154ee <log_0>

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ipc_task_trigger(NRF_IPC_Type * p_reg, nrf_ipc_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1012fd2:	2201      	movs	r2, #1
 1012fd4:	2000      	movs	r0, #0
 1012fd6:	4b07      	ldr	r3, [pc, #28]	; (1012ff4 <vipm_nrf_1_send+0x58>)
 1012fd8:	601a      	str	r2, [r3, #0]
 1012fda:	bd08      	pop	{r3, pc}
 1012fdc:	f06f 0015 	mvn.w	r0, #21
 1012fe0:	e7fb      	b.n	1012fda <vipm_nrf_1_send+0x3e>
 1012fe2:	bf00      	nop
 1012fe4:	010182f0 	.word	0x010182f0
 1012fe8:	01018208 	.word	0x01018208
 1012fec:	01019990 	.word	0x01019990
 1012ff0:	010199c4 	.word	0x010199c4
 1012ff4:	41012004 	.word	0x41012004

01012ff8 <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(struct device *dev,
				const struct uart_config *cfg)
{
 1012ff8:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_config_t uarte_cfg;

#if defined(UARTE_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
 1012ffa:	794b      	ldrb	r3, [r1, #5]
 1012ffc:	2b01      	cmp	r3, #1
 1012ffe:	d02b      	beq.n	1013058 <uarte_nrfx_configure+0x60>
 1013000:	2b03      	cmp	r3, #3
 1013002:	d126      	bne.n	1013052 <uarte_nrfx_configure+0x5a>
	case UART_CFG_STOP_BITS_1:
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
		break;
	case UART_CFG_STOP_BITS_2:
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
 1013004:	2710      	movs	r7, #16
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
 1013006:	798b      	ldrb	r3, [r1, #6]
 1013008:	2b03      	cmp	r3, #3
 101300a:	d122      	bne.n	1013052 <uarte_nrfx_configure+0x5a>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
 101300c:	79cd      	ldrb	r5, [r1, #7]
 101300e:	b125      	cbz	r5, 101301a <uarte_nrfx_configure+0x22>
 1013010:	2d01      	cmp	r5, #1
 1013012:	d11e      	bne.n	1013052 <uarte_nrfx_configure+0x5a>
	case UART_CFG_FLOW_CTRL_NONE:
		uarte_cfg.hwfc = NRF_UARTE_HWFC_DISABLED;
		break;
	case UART_CFG_FLOW_CTRL_RTS_CTS:
		if (get_dev_config(dev)->rts_cts_pins_set) {
 1013014:	6843      	ldr	r3, [r0, #4]
 1013016:	791b      	ldrb	r3, [r3, #4]
 1013018:	b1db      	cbz	r3, 1013052 <uarte_nrfx_configure+0x5a>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
 101301a:	790a      	ldrb	r2, [r1, #4]
 101301c:	2a01      	cmp	r2, #1
 101301e:	d01d      	beq.n	101305c <uarte_nrfx_configure+0x64>
 1013020:	2a02      	cmp	r2, #2
 1013022:	d01f      	beq.n	1013064 <uarte_nrfx_configure+0x6c>
 1013024:	b9aa      	cbnz	r2, 1013052 <uarte_nrfx_configure+0x5a>
 1013026:	4614      	mov	r4, r2
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
 1013028:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
 101302a:	6846      	ldr	r6, [r0, #4]
	switch (baudrate) {
 101302c:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
	return config->uarte_regs;
 1013030:	6836      	ldr	r6, [r6, #0]
	switch (baudrate) {
 1013032:	d06d      	beq.n	1013110 <uarte_nrfx_configure+0x118>
 1013034:	d833      	bhi.n	101309e <uarte_nrfx_configure+0xa6>
 1013036:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
 101303a:	d06c      	beq.n	1013116 <uarte_nrfx_configure+0x11e>
 101303c:	d81c      	bhi.n	1013078 <uarte_nrfx_configure+0x80>
 101303e:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
 1013042:	d06a      	beq.n	101311a <uarte_nrfx_configure+0x122>
 1013044:	d810      	bhi.n	1013068 <uarte_nrfx_configure+0x70>
 1013046:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 101304a:	d069      	beq.n	1013120 <uarte_nrfx_configure+0x128>
 101304c:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
 1013050:	d069      	beq.n	1013126 <uarte_nrfx_configure+0x12e>
 1013052:	f06f 0022 	mvn.w	r0, #34	; 0x22
 1013056:	e05a      	b.n	101310e <uarte_nrfx_configure+0x116>
	switch (cfg->stop_bits) {
 1013058:	2700      	movs	r7, #0
 101305a:	e7d4      	b.n	1013006 <uarte_nrfx_configure+0xe>
		uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_ODD;
 101305c:	f44f 7480 	mov.w	r4, #256	; 0x100
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
 1013060:	220e      	movs	r2, #14
 1013062:	e7e1      	b.n	1013028 <uarte_nrfx_configure+0x30>
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
 1013064:	2400      	movs	r4, #0
 1013066:	e7fb      	b.n	1013060 <uarte_nrfx_configure+0x68>
	switch (baudrate) {
 1013068:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
 101306c:	d05e      	beq.n	101312c <uarte_nrfx_configure+0x134>
 101306e:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
 1013072:	d1ee      	bne.n	1013052 <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
 1013074:	4b38      	ldr	r3, [pc, #224]	; (1013158 <uarte_nrfx_configure+0x160>)
 1013076:	e03e      	b.n	10130f6 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
 1013078:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
 101307c:	d059      	beq.n	1013132 <uarte_nrfx_configure+0x13a>
 101307e:	d807      	bhi.n	1013090 <uarte_nrfx_configure+0x98>
 1013080:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
 1013084:	d057      	beq.n	1013136 <uarte_nrfx_configure+0x13e>
 1013086:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
 101308a:	d1e2      	bne.n	1013052 <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
 101308c:	4b33      	ldr	r3, [pc, #204]	; (101315c <uarte_nrfx_configure+0x164>)
 101308e:	e032      	b.n	10130f6 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
 1013090:	f647 2c12 	movw	ip, #31250	; 0x7a12
 1013094:	4563      	cmp	r3, ip
 1013096:	d1dc      	bne.n	1013052 <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
 1013098:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
 101309c:	e02b      	b.n	10130f6 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
 101309e:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
 10130a2:	d04a      	beq.n	101313a <uarte_nrfx_configure+0x142>
 10130a4:	d813      	bhi.n	10130ce <uarte_nrfx_configure+0xd6>
 10130a6:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
 10130aa:	d049      	beq.n	1013140 <uarte_nrfx_configure+0x148>
 10130ac:	d809      	bhi.n	10130c2 <uarte_nrfx_configure+0xca>
 10130ae:	f64d 2cc0 	movw	ip, #56000	; 0xdac0
 10130b2:	4563      	cmp	r3, ip
 10130b4:	d046      	beq.n	1013144 <uarte_nrfx_configure+0x14c>
 10130b6:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
 10130ba:	d1ca      	bne.n	1013052 <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
 10130bc:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
 10130c0:	e019      	b.n	10130f6 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
 10130c2:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
 10130c6:	d1c4      	bne.n	1013052 <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
 10130c8:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
 10130cc:	e013      	b.n	10130f6 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
 10130ce:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
 10130d2:	d03a      	beq.n	101314a <uarte_nrfx_configure+0x152>
 10130d4:	d809      	bhi.n	10130ea <uarte_nrfx_configure+0xf2>
 10130d6:	f8df c098 	ldr.w	ip, [pc, #152]	; 1013170 <uarte_nrfx_configure+0x178>
 10130da:	4563      	cmp	r3, ip
 10130dc:	d038      	beq.n	1013150 <uarte_nrfx_configure+0x158>
 10130de:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
 10130e2:	d1b6      	bne.n	1013052 <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
 10130e4:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
 10130e8:	e005      	b.n	10130f6 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
 10130ea:	f8df c088 	ldr.w	ip, [pc, #136]	; 1013174 <uarte_nrfx_configure+0x17c>
 10130ee:	4563      	cmp	r3, ip
 10130f0:	d1af      	bne.n	1013052 <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
 10130f2:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
 10130f6:	f8c6 3524 	str.w	r3, [r6, #1316]	; 0x524
                    | (uint32_t)p_cfg->hwfc;
 10130fa:	432c      	orrs	r4, r5
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	get_dev_data(dev)->uart_config = *cfg;
 10130fc:	68c3      	ldr	r3, [r0, #12]
                    | (uint32_t)p_cfg->stop
 10130fe:	433a      	orrs	r2, r7
                    | (uint32_t)p_cfg->hwfc;
 1013100:	4322      	orrs	r2, r4
 1013102:	c903      	ldmia	r1, {r0, r1}
    p_reg->CONFIG = (uint32_t)p_cfg->parity
 1013104:	f8c6 256c 	str.w	r2, [r6, #1388]	; 0x56c
 1013108:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
 101310c:	2000      	movs	r0, #0
}
 101310e:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
 1013110:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
 1013114:	e7ef      	b.n	10130f6 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
 1013116:	4b12      	ldr	r3, [pc, #72]	; (1013160 <uarte_nrfx_configure+0x168>)
 1013118:	e7ed      	b.n	10130f6 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
 101311a:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
 101311e:	e7ea      	b.n	10130f6 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = 0x00014000;
 1013120:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
 1013124:	e7e7      	b.n	10130f6 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
 1013126:	f44f 331c 	mov.w	r3, #159744	; 0x27000
 101312a:	e7e4      	b.n	10130f6 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
 101312c:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
 1013130:	e7e1      	b.n	10130f6 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
 1013132:	4b0c      	ldr	r3, [pc, #48]	; (1013164 <uarte_nrfx_configure+0x16c>)
 1013134:	e7df      	b.n	10130f6 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
 1013136:	4b0c      	ldr	r3, [pc, #48]	; (1013168 <uarte_nrfx_configure+0x170>)
 1013138:	e7dd      	b.n	10130f6 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
 101313a:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
 101313e:	e7da      	b.n	10130f6 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
 1013140:	4b0a      	ldr	r3, [pc, #40]	; (101316c <uarte_nrfx_configure+0x174>)
 1013142:	e7d8      	b.n	10130f6 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
 1013144:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
 1013148:	e7d5      	b.n	10130f6 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
 101314a:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
 101314e:	e7d2      	b.n	10130f6 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
 1013150:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 1013154:	e7cf      	b.n	10130f6 <uarte_nrfx_configure+0xfe>
 1013156:	bf00      	nop
 1013158:	0013b000 	.word	0x0013b000
 101315c:	004ea000 	.word	0x004ea000
 1013160:	00275000 	.word	0x00275000
 1013164:	0075c000 	.word	0x0075c000
 1013168:	003af000 	.word	0x003af000
 101316c:	013a9000 	.word	0x013a9000
 1013170:	0003d090 	.word	0x0003d090
 1013174:	000f4240 	.word	0x000f4240

01013178 <uarte_0_init>:
	return config->uarte_regs;
 1013178:	6842      	ldr	r2, [r0, #4]
				.tx_buffer = uarte##idx##_tx_buffer,	       \
				.tx_buff_size = sizeof(uarte##idx##_tx_buffer),\
			};))

#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
 101317a:	b570      	push	{r4, r5, r6, lr}
	return config->uarte_regs;
 101317c:	6814      	ldr	r4, [r2, #0]
    p_reg->OUTSET = set_mask;
 101317e:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 1013182:	4b16      	ldr	r3, [pc, #88]	; (10131dc <uarte_0_init+0x64>)
	struct uarte_nrfx_data *data = get_dev_data(dev);
 1013184:	68c5      	ldr	r5, [r0, #12]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
 1013186:	2103      	movs	r1, #3
    p_reg->OUTSET = set_mask;
 1013188:	609a      	str	r2, [r3, #8]
    p_reg->PSEL.TXD = pseltxd;
 101318a:	2619      	movs	r6, #25
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
 101318c:	2200      	movs	r2, #0
 101318e:	f8c3 1264 	str.w	r1, [r3, #612]	; 0x264
 1013192:	f8c3 2268 	str.w	r2, [r3, #616]	; 0x268
 1013196:	f8c4 650c 	str.w	r6, [r4, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
 101319a:	261a      	movs	r6, #26
 101319c:	f8c4 6514 	str.w	r6, [r4, #1300]	; 0x514
    p_reg->OUTSET = set_mask;
 10131a0:	f44f 6680 	mov.w	r6, #1024	; 0x400
 10131a4:	609e      	str	r6, [r3, #8]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
 10131a6:	f8c3 1228 	str.w	r1, [r3, #552]	; 0x228
 10131aa:	f8c3 2230 	str.w	r2, [r3, #560]	; 0x230
    p_reg->PSEL.RTS = pselrts;
 10131ae:	230a      	movs	r3, #10
 10131b0:	f8c4 3508 	str.w	r3, [r4, #1288]	; 0x508
    p_reg->PSEL.CTS = pselcts;
 10131b4:	230c      	movs	r3, #12
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
 10131b6:	4629      	mov	r1, r5
 10131b8:	f8c4 3510 	str.w	r3, [r4, #1296]	; 0x510
 10131bc:	f7ff ff1c 	bl	1012ff8 <uarte_nrfx_configure>
	if (err) {
 10131c0:	b958      	cbnz	r0, 10131da <uarte_0_init+0x62>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
 10131c2:	2308      	movs	r3, #8
 10131c4:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    p_reg->RXD.MAXCNT = length;
 10131c8:	2301      	movs	r3, #1
		nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
 10131ca:	350c      	adds	r5, #12
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 10131cc:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
 10131d0:	f8c4 5534 	str.w	r5, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
 10131d4:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 10131d8:	6023      	str	r3, [r4, #0]
UART_NRF_UARTE_DEVICE(0);
 10131da:	bd70      	pop	{r4, r5, r6, pc}
 10131dc:	418c0500 	.word	0x418c0500

010131e0 <random_byte_get>:
	__asm__ volatile(
 10131e0:	f04f 0320 	mov.w	r3, #32
 10131e4:	f3ef 8211 	mrs	r2, BASEPRI
 10131e8:	f383 8811 	msr	BASEPRI, r3
 10131ec:	f3bf 8f6f 	isb	sy
#endif
}

NRF_STATIC_INLINE bool nrf_rng_event_check(NRF_RNG_Type const * p_reg, nrf_rng_event_t rng_event)
{
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
 10131f0:	4b08      	ldr	r3, [pc, #32]	; (1013214 <random_byte_get+0x34>)
 10131f2:	6819      	ldr	r1, [r3, #0]
	int retval = -EAGAIN;
	unsigned int key;

	key = irq_lock();

	if (nrf_rng_event_check(NRF_RNG, NRF_RNG_EVENT_VALRDY)) {
 10131f4:	b151      	cbz	r1, 101320c <random_byte_get+0x2c>
     p_reg->SHORTS &= ~mask;
}

NRF_STATIC_INLINE uint8_t nrf_rng_random_value_get(NRF_RNG_Type const * p_reg)
{
    return (uint8_t)(p_reg->VALUE & RNG_VALUE_VALUE_Msk);
 10131f6:	4908      	ldr	r1, [pc, #32]	; (1013218 <random_byte_get+0x38>)
 10131f8:	f8d1 0508 	ldr.w	r0, [r1, #1288]	; 0x508
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
 10131fc:	2100      	movs	r1, #0
		retval = nrf_rng_random_value_get(NRF_RNG);
 10131fe:	b2c0      	uxtb	r0, r0
 1013200:	6019      	str	r1, [r3, #0]
	__asm__ volatile(
 1013202:	f382 8811 	msr	BASEPRI, r2
 1013206:	f3bf 8f6f 	isb	sy
	}

	irq_unlock(key);

	return retval;
}
 101320a:	4770      	bx	lr
	int retval = -EAGAIN;
 101320c:	f06f 000a 	mvn.w	r0, #10
 1013210:	e7f7      	b.n	1013202 <random_byte_get+0x22>
 1013212:	bf00      	nop
 1013214:	41009100 	.word	0x41009100
 1013218:	41009000 	.word	0x41009000

0101321c <rng_pool_get>:
#pragma GCC push_options
#if defined(CONFIG_BT_CTLR_FAST_ENC)
#pragma GCC optimize ("Ofast")
#endif
static u16_t rng_pool_get(struct rng_pool *rngp, u8_t *buf, u16_t len)
{
 101321c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1013220:	4604      	mov	r4, r0
	u32_t last  = rngp->last;
 1013222:	f890 c002 	ldrb.w	ip, [r0, #2]
	u32_t mask  = rngp->mask;
 1013226:	78c6      	ldrb	r6, [r0, #3]
	__asm__ volatile(
 1013228:	f04f 0320 	mov.w	r3, #32
 101322c:	f3ef 8511 	mrs	r5, BASEPRI
 1013230:	f383 8811 	msr	BASEPRI, r3
 1013234:	f3bf 8f6f 	isb	sy
	u32_t first, available;
	u32_t other_read_in_progress;
	unsigned int key;

	key = irq_lock();
	first = rngp->first_alloc;
 1013238:	f890 e000 	ldrb.w	lr, [r0]
	/*
	 * The other_read_in_progress is non-zero if rngp->first_read != first,
	 * which means that lower-priority code (which was interrupted by this
	 * call) already allocated area for read.
	 */
	other_read_in_progress = (rngp->first_read ^ first);
 101323c:	f890 8001 	ldrb.w	r8, [r0, #1]

	available = (last - first) & mask;
 1013240:	ebac 0c0e 	sub.w	ip, ip, lr
 1013244:	ea0c 0c06 	and.w	ip, ip, r6
	if (available < len) {
 1013248:	4562      	cmp	r2, ip
 101324a:	bf94      	ite	ls
 101324c:	4610      	movls	r0, r2
		len = available;
 101324e:	fa1f f08c 	uxthhi.w	r0, ip

	/*
	 * Move alloc index forward to signal, that part of the buffer is
	 * now reserved for this call.
	 */
	rngp->first_alloc = (first + len) & mask;
 1013252:	eb0e 0200 	add.w	r2, lr, r0
 1013256:	4032      	ands	r2, r6
	first = rngp->first_alloc;
 1013258:	4673      	mov	r3, lr
	rngp->first_alloc = (first + len) & mask;
 101325a:	7022      	strb	r2, [r4, #0]
	__asm__ volatile(
 101325c:	f385 8811 	msr	BASEPRI, r5
 1013260:	f3bf 8f6f 	isb	sy
	irq_unlock(key);

	while (likely(len--)) {
 1013264:	1e42      	subs	r2, r0, #1
 1013266:	b292      	uxth	r2, r2
 1013268:	b168      	cbz	r0, 1013286 <rng_pool_get+0x6a>
 101326a:	3201      	adds	r2, #1
 101326c:	188f      	adds	r7, r1, r2
		*dst++ = rngp->buffer[first];
 101326e:	18e5      	adds	r5, r4, r3
 1013270:	796d      	ldrb	r5, [r5, #5]
		first = (first + 1) & mask;
 1013272:	3301      	adds	r3, #1
		*dst++ = rngp->buffer[first];
 1013274:	f801 5b01 	strb.w	r5, [r1], #1
	while (likely(len--)) {
 1013278:	42b9      	cmp	r1, r7
		first = (first + 1) & mask;
 101327a:	ea03 0306 	and.w	r3, r3, r6
	while (likely(len--)) {
 101327e:	d1f6      	bne.n	101326e <rng_pool_get+0x52>
 1013280:	b292      	uxth	r2, r2
 1013282:	ebac 0c02 	sub.w	ip, ip, r2
	/*
	 * If this call is the last one accessing the pool, move read index
	 * to signal that all allocated regions are now read and could be
	 * overwritten.
	 */
	if (likely(!other_read_in_progress)) {
 1013286:	45c6      	cmp	lr, r8
 1013288:	d10d      	bne.n	10132a6 <rng_pool_get+0x8a>
	__asm__ volatile(
 101328a:	f04f 0220 	mov.w	r2, #32
 101328e:	f3ef 8311 	mrs	r3, BASEPRI
 1013292:	f382 8811 	msr	BASEPRI, r2
 1013296:	f3bf 8f6f 	isb	sy
		key = irq_lock();
		rngp->first_read = rngp->first_alloc;
 101329a:	7822      	ldrb	r2, [r4, #0]
 101329c:	7062      	strb	r2, [r4, #1]
	__asm__ volatile(
 101329e:	f383 8811 	msr	BASEPRI, r3
 10132a2:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}

	len = dst - buf;
	available = available - len;
	if (available <= rngp->threshold) {
 10132a6:	7923      	ldrb	r3, [r4, #4]
 10132a8:	4563      	cmp	r3, ip
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
 10132aa:	bf22      	ittt	cs
 10132ac:	2201      	movcs	r2, #1
 10132ae:	4b02      	ldrcs	r3, [pc, #8]	; (10132b8 <rng_pool_get+0x9c>)
 10132b0:	601a      	strcs	r2, [r3, #0]
		nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);
	}

	return len;
}
 10132b2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 10132b6:	bf00      	nop
 10132b8:	41009000 	.word	0x41009000

010132bc <entropy_nrf5_get_entropy_isr>:
	u16_t cnt = len;

	/* Check if this API is called on correct driver instance. */
	__ASSERT_NO_MSG(&entropy_nrf5_data == DEV_DATA(dev));

	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
 10132bc:	43db      	mvns	r3, r3
{
 10132be:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
 10132c2:	f013 0501 	ands.w	r5, r3, #1
{
 10132c6:	460e      	mov	r6, r1
 10132c8:	4614      	mov	r4, r2
	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
 10132ca:	d004      	beq.n	10132d6 <entropy_nrf5_get_entropy_isr+0x1a>
		return rng_pool_get((struct rng_pool *)(entropy_nrf5_data.isr),
 10132cc:	481d      	ldr	r0, [pc, #116]	; (1013344 <entropy_nrf5_get_entropy_isr+0x88>)
 10132ce:	f7ff ffa5 	bl	101321c <rng_pool_get>
			irq_enable(IRQN);
		}
	}

	return cnt;
}
 10132d2:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (len) {
 10132d6:	b37a      	cbz	r2, 1013338 <entropy_nrf5_get_entropy_isr+0x7c>
	__asm__ volatile(
 10132d8:	f04f 0320 	mov.w	r3, #32
 10132dc:	f3ef 8811 	mrs	r8, BASEPRI
 10132e0:	f383 8811 	msr	BASEPRI, r3
 10132e4:	f3bf 8f6f 	isb	sy
		irq_enabled = irq_is_enabled(IRQN);
 10132e8:	2009      	movs	r0, #9
 10132ea:	f7f1 fdb3 	bl	1004e54 <arch_irq_is_enabled>
 10132ee:	4607      	mov	r7, r0
		irq_disable(IRQN);
 10132f0:	2009      	movs	r0, #9
 10132f2:	f7f1 fd9b 	bl	1004e2c <arch_irq_disable>
	__asm__ volatile(
 10132f6:	f388 8811 	msr	BASEPRI, r8
 10132fa:	f3bf 8f6f 	isb	sy
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
 10132fe:	4b12      	ldr	r3, [pc, #72]	; (1013348 <entropy_nrf5_get_entropy_isr+0x8c>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
 1013300:	2101      	movs	r1, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
 1013302:	601d      	str	r5, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
 1013304:	4698      	mov	r8, r3
}
 1013306:	4625      	mov	r5, r4
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 1013308:	f44f 7a00 	mov.w	sl, #512	; 0x200
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
 101330c:	4a0f      	ldr	r2, [pc, #60]	; (101334c <entropy_nrf5_get_entropy_isr+0x90>)
 101330e:	f8df 9040 	ldr.w	r9, [pc, #64]	; 1013350 <entropy_nrf5_get_entropy_isr+0x94>
 1013312:	6011      	str	r1, [r2, #0]
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
 1013314:	f8d8 3000 	ldr.w	r3, [r8]
			while (!nrf_rng_event_check(NRF_RNG,
 1013318:	b183      	cbz	r3, 101333c <entropy_nrf5_get_entropy_isr+0x80>
			byte = random_byte_get();
 101331a:	f7ff ff61 	bl	10131e0 <random_byte_get>
			if (byte < 0) {
 101331e:	1e03      	subs	r3, r0, #0
 1013320:	f8c9 a180 	str.w	sl, [r9, #384]	; 0x180
 1013324:	dbf6      	blt.n	1013314 <entropy_nrf5_get_entropy_isr+0x58>
 1013326:	3d01      	subs	r5, #1
 1013328:	b2ad      	uxth	r5, r5
			buf[--len] = byte;
 101332a:	5573      	strb	r3, [r6, r5]
		} while (len);
 101332c:	2d00      	cmp	r5, #0
 101332e:	d1f1      	bne.n	1013314 <entropy_nrf5_get_entropy_isr+0x58>
		if (irq_enabled) {
 1013330:	b117      	cbz	r7, 1013338 <entropy_nrf5_get_entropy_isr+0x7c>
			irq_enable(IRQN);
 1013332:	2009      	movs	r0, #9
 1013334:	f7f1 fd6a 	bl	1004e0c <arch_irq_enable>
	return cnt;
 1013338:	4620      	mov	r0, r4
 101333a:	e7ca      	b.n	10132d2 <entropy_nrf5_get_entropy_isr+0x16>
				__WFE();
 101333c:	bf20      	wfe
				__SEV();
 101333e:	bf40      	sev
				__WFE();
 1013340:	bf20      	wfe
 1013342:	e7e7      	b.n	1013314 <entropy_nrf5_get_entropy_isr+0x58>
 1013344:	210059f4 	.word	0x210059f4
 1013348:	41009100 	.word	0x41009100
 101334c:	41009000 	.word	0x41009000
 1013350:	e000e100 	.word	0xe000e100

01013354 <entropy_nrf5_get_entropy>:
{
 1013354:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1013358:	460d      	mov	r5, r1
 101335a:	4614      	mov	r4, r2
	return z_impl_k_sem_take(sem, timeout);
 101335c:	4f12      	ldr	r7, [pc, #72]	; (10133a8 <entropy_nrf5_get_entropy+0x54>)
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
 101335e:	f107 0845 	add.w	r8, r7, #69	; 0x45
 1013362:	f107 0918 	add.w	r9, r7, #24
	while (len) {
 1013366:	b914      	cbnz	r4, 101336e <entropy_nrf5_get_entropy+0x1a>
}
 1013368:	4620      	mov	r0, r4
 101336a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 101336e:	f04f 33ff 	mov.w	r3, #4294967295
 1013372:	f04f 32ff 	mov.w	r2, #4294967295
 1013376:	4638      	mov	r0, r7
 1013378:	f001 fa3c 	bl	10147f4 <z_impl_k_sem_take>
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
 101337c:	4622      	mov	r2, r4
 101337e:	4629      	mov	r1, r5
 1013380:	4640      	mov	r0, r8
 1013382:	f7ff ff4b 	bl	101321c <rng_pool_get>
 1013386:	4606      	mov	r6, r0
	z_impl_k_sem_give(sem);
 1013388:	4638      	mov	r0, r7
 101338a:	f001 fa0d 	bl	10147a8 <z_impl_k_sem_give>
		if (bytes == 0U) {
 101338e:	b93e      	cbnz	r6, 10133a0 <entropy_nrf5_get_entropy+0x4c>
	return z_impl_k_sem_take(sem, timeout);
 1013390:	f04f 32ff 	mov.w	r2, #4294967295
 1013394:	f04f 33ff 	mov.w	r3, #4294967295
 1013398:	4648      	mov	r0, r9
 101339a:	f001 fa2b 	bl	10147f4 <z_impl_k_sem_take>
			continue;
 101339e:	e7e2      	b.n	1013366 <entropy_nrf5_get_entropy+0x12>
		len -= bytes;
 10133a0:	1ba4      	subs	r4, r4, r6
 10133a2:	b2a4      	uxth	r4, r4
		buf += bytes;
 10133a4:	4435      	add	r5, r6
 10133a6:	e7de      	b.n	1013366 <entropy_nrf5_get_entropy+0x12>
 10133a8:	210059c4 	.word	0x210059c4

010133ac <entropy_nrf5_init>:
		    entropy_nrf5_init, &entropy_nrf5_data, NULL,
		    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &entropy_nrf5_api_funcs);

static int entropy_nrf5_init(struct device *device)
{
 10133ac:	b538      	push	{r3, r4, r5, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
 10133ae:	2201      	movs	r2, #1
 10133b0:	4c17      	ldr	r4, [pc, #92]	; (1013410 <entropy_nrf5_init+0x64>)
 10133b2:	4611      	mov	r1, r2
 10133b4:	4620      	mov	r0, r4
 10133b6:	f004 fc32 	bl	1017c1e <z_impl_k_sem_init>
 10133ba:	2201      	movs	r2, #1
 10133bc:	2100      	movs	r1, #0
 10133be:	f104 0018 	add.w	r0, r4, #24
 10133c2:	f004 fc2c 	bl	1017c1e <z_impl_k_sem_init>
	rngp->mask	  = size - 1;
 10133c6:	f240 4307 	movw	r3, #1031	; 0x407
 10133ca:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
	rngp->first_alloc = 0U;
 10133ce:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
 10133d2:	6323      	str	r3, [r4, #48]	; 0x30
	rngp->threshold	  = threshold;
 10133d4:	230c      	movs	r3, #12
	rngp->first_alloc = 0U;
 10133d6:	2500      	movs	r5, #0
    p_reg->INTENSET = mask;
 10133d8:	2101      	movs	r1, #1
	rngp->threshold	  = threshold;
 10133da:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}

NRF_STATIC_INLINE void nrf_rng_error_correction_enable(NRF_RNG_Type * p_reg)
{
    p_reg->CONFIG |= RNG_CONFIG_DERCEN_Msk;
 10133de:	4b0d      	ldr	r3, [pc, #52]	; (1013414 <entropy_nrf5_init+0x68>)
	rngp->first_alloc = 0U;
 10133e0:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
	rngp->first_read  = 0U;
 10133e4:	f8a4 5046 	strh.w	r5, [r4, #70]	; 0x46
 10133e8:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504

	nrf_rng_event_clear(NRF_RNG, NRF_RNG_EVENT_VALRDY);
	nrf_rng_int_enable(NRF_RNG, NRF_RNG_INT_VALRDY_MASK);
	nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);

	IRQ_CONNECT(IRQN, IRQ_PRIO, isr, &entropy_nrf5_data, 0);
 10133ec:	2009      	movs	r0, #9
 10133ee:	f042 0201 	orr.w	r2, r2, #1
 10133f2:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
 10133f6:	4a08      	ldr	r2, [pc, #32]	; (1013418 <entropy_nrf5_init+0x6c>)
 10133f8:	6015      	str	r5, [r2, #0]
    p_reg->INTENSET = mask;
 10133fa:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304
 10133fe:	462a      	mov	r2, r5
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
 1013400:	6019      	str	r1, [r3, #0]
 1013402:	f7f1 fd35 	bl	1004e70 <z_arm_irq_priority_set>
	irq_enable(IRQN);
 1013406:	2009      	movs	r0, #9
 1013408:	f7f1 fd00 	bl	1004e0c <arch_irq_enable>

	return 0;
}
 101340c:	4628      	mov	r0, r5
 101340e:	bd38      	pop	{r3, r4, r5, pc}
 1013410:	210059c4 	.word	0x210059c4
 1013414:	41009000 	.word	0x41009000
 1013418:	41009100 	.word	0x41009100

0101341c <isr>:
{
 101341c:	b510      	push	{r4, lr}
	byte = random_byte_get();
 101341e:	f7ff fedf 	bl	10131e0 <random_byte_get>
	if (byte < 0) {
 1013422:	2800      	cmp	r0, #0
 1013424:	db20      	blt.n	1013468 <isr+0x4c>
	u8_t last  = rngp->last;
 1013426:	4b17      	ldr	r3, [pc, #92]	; (1013484 <isr+0x68>)
	ret = rng_pool_put((struct rng_pool *)(entropy_nrf5_data.isr), byte);
 1013428:	b2c0      	uxtb	r0, r0
	u8_t last  = rngp->last;
 101342a:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
	if (((last - first) & mask) == mask) {
 101342e:	f893 1031 	ldrb.w	r1, [r3, #49]	; 0x31
	u8_t mask  = rngp->mask;
 1013432:	f893 4033 	ldrb.w	r4, [r3, #51]	; 0x33
	if (((last - first) & mask) == mask) {
 1013436:	1a51      	subs	r1, r2, r1
 1013438:	ea34 0101 	bics.w	r1, r4, r1
 101343c:	d10d      	bne.n	101345a <isr+0x3e>
	u8_t last  = rngp->last;
 101343e:	f893 2047 	ldrb.w	r2, [r3, #71]	; 0x47
	if (((last - first) & mask) == mask) {
 1013442:	f893 1046 	ldrb.w	r1, [r3, #70]	; 0x46
	u8_t mask  = rngp->mask;
 1013446:	f893 4048 	ldrb.w	r4, [r3, #72]	; 0x48
	if (((last - first) & mask) == mask) {
 101344a:	1a51      	subs	r1, r2, r1
 101344c:	ea34 0101 	bics.w	r1, r4, r1
 1013450:	d10b      	bne.n	101346a <isr+0x4e>
 1013452:	2201      	movs	r2, #1
 1013454:	4b0c      	ldr	r3, [pc, #48]	; (1013488 <isr+0x6c>)
 1013456:	601a      	str	r2, [r3, #0]
}
 1013458:	e00e      	b.n	1013478 <isr+0x5c>
	rngp->buffer[last] = byte;
 101345a:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
 101345c:	3201      	adds	r2, #1
 101345e:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
 1013460:	f881 0035 	strb.w	r0, [r1, #53]	; 0x35
	rngp->last = (last + 1) & mask;
 1013464:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
}
 1013468:	bd10      	pop	{r4, pc}
	rngp->buffer[last] = byte;
 101346a:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
 101346c:	3201      	adds	r2, #1
 101346e:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
 1013470:	f881 004a 	strb.w	r0, [r1, #74]	; 0x4a
	rngp->last = (last + 1) & mask;
 1013474:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
	z_impl_k_sem_give(sem);
 1013478:	4804      	ldr	r0, [pc, #16]	; (101348c <isr+0x70>)
}
 101347a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 101347e:	f001 b993 	b.w	10147a8 <z_impl_k_sem_give>
 1013482:	bf00      	nop
 1013484:	210059c4 	.word	0x210059c4
 1013488:	41009004 	.word	0x41009004
 101348c:	210059dc 	.word	0x210059dc

01013490 <k_sys_fatal_error_handler>:

extern void sys_arch_reboot(int type);

void k_sys_fatal_error_handler(unsigned int reason,
			       const z_arch_esf_t *esf)
{
 1013490:	b508      	push	{r3, lr}
	z_impl_log_panic();
 1013492:	f7f0 fee3 	bl	100425c <z_impl_log_panic>
 1013496:	4b06      	ldr	r3, [pc, #24]	; (10134b0 <k_sys_fatal_error_handler+0x20>)
 1013498:	4906      	ldr	r1, [pc, #24]	; (10134b4 <k_sys_fatal_error_handler+0x24>)
	ARG_UNUSED(esf);
	ARG_UNUSED(reason);

	LOG_PANIC();

	LOG_ERR("Resetting system");
 101349a:	4807      	ldr	r0, [pc, #28]	; (10134b8 <k_sys_fatal_error_handler+0x28>)
 101349c:	1ac9      	subs	r1, r1, r3
 101349e:	08c9      	lsrs	r1, r1, #3
 10134a0:	0189      	lsls	r1, r1, #6
 10134a2:	f041 0101 	orr.w	r1, r1, #1
 10134a6:	f002 f822 	bl	10154ee <log_0>
	sys_arch_reboot(0);
 10134aa:	2000      	movs	r0, #0
 10134ac:	f7f1 ffe8 	bl	1005480 <sys_arch_reboot>

	CODE_UNREACHABLE;
 10134b0:	01018208 	.word	0x01018208
 10134b4:	010182e0 	.word	0x010182e0
 10134b8:	01019a16 	.word	0x01019a16

010134bc <SystemInit>:
void SystemInit(void)
{
    /* Trimming of the device. Copy all the trimming values from FICR into the target addresses. Trim
     until one ADDR is not initialized. */
    uint32_t index = 0;
    for (index = 0; index < 32ul && NRF_FICR_NS->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
 10134bc:	2200      	movs	r2, #0
 10134be:	00d3      	lsls	r3, r2, #3
 10134c0:	f103 73ff 	add.w	r3, r3, #33423360	; 0x1fe0000
 10134c4:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 10134c8:	f8d3 1300 	ldr.w	r1, [r3, #768]	; 0x300
 10134cc:	3101      	adds	r1, #1
 10134ce:	d007      	beq.n	10134e0 <SystemInit+0x24>
        #if defined ( __ICCARM__ )
            /* IAR will complain about the order of volatile pointer accesses. */
            #pragma diag_suppress=Pa082
        #endif
        *NRF_FICR_NS->TRIMCNF[index].ADDR = NRF_FICR_NS->TRIMCNF[index].DATA;
 10134d0:	f8d3 1300 	ldr.w	r1, [r3, #768]	; 0x300
    for (index = 0; index < 32ul && NRF_FICR_NS->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
 10134d4:	3201      	adds	r2, #1
        *NRF_FICR_NS->TRIMCNF[index].ADDR = NRF_FICR_NS->TRIMCNF[index].DATA;
 10134d6:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
    for (index = 0; index < 32ul && NRF_FICR_NS->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
 10134da:	2a20      	cmp	r2, #32
        *NRF_FICR_NS->TRIMCNF[index].ADDR = NRF_FICR_NS->TRIMCNF[index].DATA;
 10134dc:	600b      	str	r3, [r1, #0]
    for (index = 0; index < 32ul && NRF_FICR_NS->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
 10134de:	d1ee      	bne.n	10134be <SystemInit+0x2>
         || defined (NRF5340_XXAA_NETWORK) || defined (DEVELOP_IN_NRF5340_NETWORK)
            #if defined(NRF_APPLICATION)
                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
            #elif defined(NRF_NETWORK)
                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
 10134e0:	4b11      	ldr	r3, [pc, #68]	; (1013528 <SystemInit+0x6c>)
                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
            #endif
        #endif
        #if defined (NRF5340_XXAA_APPLICATION) || defined (DEVELOP_IN_NRF5340_APPLICATION)\
         || defined (NRF5340_XXAA_NETWORK) || defined (DEVELOP_IN_NRF5340_NETWORK)
            if (var1 == 0x07)
 10134e2:	681b      	ldr	r3, [r3, #0]
 10134e4:	2b07      	cmp	r3, #7
 10134e6:	d11a      	bne.n	101351e <SystemInit+0x62>
                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
 10134e8:	4b10      	ldr	r3, [pc, #64]	; (101352c <SystemInit+0x70>)
            {
                switch(var2)
 10134ea:	681a      	ldr	r2, [r3, #0]
 10134ec:	2a02      	cmp	r2, #2
 10134ee:	d109      	bne.n	1013504 <SystemInit+0x48>

    /* Workaround for Errata 49 "SLEEPENTER and SLEEPEXIT events asserted after pin reset" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf53_errata_49())
    {
        if (NRF_RESET_NS->RESETREAS & RESET_RESETREAS_RESETPIN_Msk)
 10134f0:	4a0f      	ldr	r2, [pc, #60]	; (1013530 <SystemInit+0x74>)
 10134f2:	f8d2 1400 	ldr.w	r1, [r2, #1024]	; 0x400
 10134f6:	07c9      	lsls	r1, r1, #31
        {
            NRF_POWER_NS->EVENTS_SLEEPENTER = 0;
 10134f8:	bf42      	ittt	mi
 10134fa:	2100      	movmi	r1, #0
 10134fc:	f8c2 1114 	strmi.w	r1, [r2, #276]	; 0x114
            NRF_POWER_NS->EVENTS_SLEEPEXIT = 0;
 1013500:	f8c2 1118 	strmi.w	r1, [r2, #280]	; 0x118
        #endif
        #if defined (NRF5340_XXAA_APPLICATION) || defined (DEVELOP_IN_NRF5340_APPLICATION)\
         || defined (NRF5340_XXAA_NETWORK) || defined (DEVELOP_IN_NRF5340_NETWORK)
            if (var1 == 0x07)
            {
                switch(var2)
 1013504:	681b      	ldr	r3, [r3, #0]
 1013506:	3b02      	subs	r3, #2
 1013508:	2b01      	cmp	r3, #1
 101350a:	d808      	bhi.n	101351e <SystemInit+0x62>

    /* Workaround for Errata 55 "Bits in RESETREAS are set when they should not be" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf53_errata_55())
    {
        if (NRF_RESET_NS->RESETREAS & RESET_RESETREAS_RESETPIN_Msk){
 101350c:	4b08      	ldr	r3, [pc, #32]	; (1013530 <SystemInit+0x74>)
 101350e:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
 1013512:	07d2      	lsls	r2, r2, #31
            NRF_RESET_NS->RESETREAS = ~RESET_RESETREAS_RESETPIN_Msk;
 1013514:	bf44      	itt	mi
 1013516:	f06f 0201 	mvnmi.w	r2, #1
 101351a:	f8c3 2400 	strmi.w	r2, [r3, #1024]	; 0x400
    SystemCoreClock = __SYSTEM_CLOCK;
 101351e:	4b05      	ldr	r3, [pc, #20]	; (1013534 <SystemInit+0x78>)
 1013520:	4a05      	ldr	r2, [pc, #20]	; (1013538 <SystemInit+0x7c>)
 1013522:	601a      	str	r2, [r3, #0]
        }
    }    

    SystemCoreClockUpdate();
}
 1013524:	4770      	bx	lr
 1013526:	bf00      	nop
 1013528:	01ff0130 	.word	0x01ff0130
 101352c:	01ff0134 	.word	0x01ff0134
 1013530:	41005000 	.word	0x41005000
 1013534:	210004c4 	.word	0x210004c4
 1013538:	03d09000 	.word	0x03d09000

0101353c <nrfx_ipc_init>:
} ipc_control_block_t;

static ipc_control_block_t m_ipc_cb;

nrfx_err_t nrfx_ipc_init(uint8_t irq_priority, nrfx_ipc_handler_t handler, void * p_context)
{
 101353c:	b570      	push	{r4, r5, r6, lr}
    NRFX_ASSERT(handler);
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
 101353e:	4c08      	ldr	r4, [pc, #32]	; (1013560 <nrfx_ipc_init+0x24>)
{
 1013540:	460e      	mov	r6, r1
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
 1013542:	7923      	ldrb	r3, [r4, #4]
{
 1013544:	4615      	mov	r5, r2
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
 1013546:	b943      	cbnz	r3, 101355a <nrfx_ipc_init+0x1e>
    {
        return NRFX_ERROR_ALREADY_INITIALIZED;
    }

    NRFX_IRQ_PRIORITY_SET(IPC_IRQn, irq_priority);
    NRFX_IRQ_ENABLE(IPC_IRQn);
 1013548:	2012      	movs	r0, #18
 101354a:	f7f1 fc5f 	bl	1004e0c <arch_irq_enable>

    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
 101354e:	2301      	movs	r3, #1
    m_ipc_cb.handler = handler;
    m_ipc_cb.p_context = p_context;

    return NRFX_SUCCESS;
 1013550:	4804      	ldr	r0, [pc, #16]	; (1013564 <nrfx_ipc_init+0x28>)
    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
 1013552:	7123      	strb	r3, [r4, #4]
    m_ipc_cb.handler = handler;
 1013554:	6026      	str	r6, [r4, #0]
    m_ipc_cb.p_context = p_context;
 1013556:	60a5      	str	r5, [r4, #8]
}
 1013558:	bd70      	pop	{r4, r5, r6, pc}
        return NRFX_ERROR_ALREADY_INITIALIZED;
 101355a:	4803      	ldr	r0, [pc, #12]	; (1013568 <nrfx_ipc_init+0x2c>)
 101355c:	e7fc      	b.n	1013558 <nrfx_ipc_init+0x1c>
 101355e:	bf00      	nop
 1013560:	21005a18 	.word	0x21005a18
 1013564:	0bad0000 	.word	0x0bad0000
 1013568:	0bad000c 	.word	0x0bad000c

0101356c <nrfx_ipc_config_load>:
{
    NRFX_ASSERT(p_config);
    NRFX_ASSERT(m_ipc_cb.state == NRFX_DRV_STATE_INITIALIZED);

    uint32_t i;
    for (i = 0; i < IPC_CONF_NUM; ++i)
 101356c:	2300      	movs	r3, #0
{
 101356e:	b530      	push	{r4, r5, lr}

NRF_STATIC_INLINE void nrf_ipc_send_config_set(NRF_IPC_Type * p_reg,
                                               uint8_t        index,
                                               uint32_t       channels_mask)
{
    p_reg->SEND_CNF[index] = channels_mask;
 1013570:	4a0d      	ldr	r2, [pc, #52]	; (10135a8 <nrfx_ipc_config_load+0x3c>)
    {
        nrf_ipc_send_config_set(NRF_IPC, i, p_config->send_task_config[i]);
 1013572:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
 1013576:	f503 71a2 	add.w	r1, r3, #324	; 0x144
    for (i = 0; i < IPC_CONF_NUM; ++i)
 101357a:	3301      	adds	r3, #1
 101357c:	2b10      	cmp	r3, #16
 101357e:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
 1013582:	d1f6      	bne.n	1013572 <nrfx_ipc_config_load+0x6>
    }

    for (i = 0; i < IPC_CONF_NUM; ++i)
 1013584:	2300      	movs	r3, #0

NRF_STATIC_INLINE void nrf_ipc_receive_config_set(NRF_IPC_Type * p_reg,
                                                  uint8_t        index,
                                                  uint32_t       channels_mask)
{
    p_reg->RECEIVE_CNF[index] = channels_mask;
 1013586:	4a08      	ldr	r2, [pc, #32]	; (10135a8 <nrfx_ipc_config_load+0x3c>)
 1013588:	f100 0140 	add.w	r1, r0, #64	; 0x40
 101358c:	f503 74b2 	add.w	r4, r3, #356	; 0x164
    {
        nrf_ipc_receive_config_set(NRF_IPC, i, p_config->receive_event_config[i]);
 1013590:	f851 5b04 	ldr.w	r5, [r1], #4
    for (i = 0; i < IPC_CONF_NUM; ++i)
 1013594:	3301      	adds	r3, #1
 1013596:	2b10      	cmp	r3, #16
 1013598:	f842 5024 	str.w	r5, [r2, r4, lsl #2]
 101359c:	d1f6      	bne.n	101358c <nrfx_ipc_config_load+0x20>
    }

    nrf_ipc_int_enable(NRF_IPC, p_config->receive_events_enabled);
 101359e:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
    p_reg->INTENSET = mask;
 10135a2:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
 10135a6:	bd30      	pop	{r4, r5, pc}
 10135a8:	41012000 	.word	0x41012000

010135ac <nrfx_ipc_receive_event_enable>:
}

void nrfx_ipc_receive_event_enable(uint8_t event_index)
{
    NRFX_ASSERT(m_ipc_cb.state == NRFX_DRV_STATE_INITIALIZED);
    nrf_ipc_int_enable(NRF_IPC, (1UL << event_index));
 10135ac:	2301      	movs	r3, #1
 10135ae:	4a02      	ldr	r2, [pc, #8]	; (10135b8 <nrfx_ipc_receive_event_enable+0xc>)
 10135b0:	4083      	lsls	r3, r0
 10135b2:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
 10135b6:	4770      	bx	lr
 10135b8:	41012000 	.word	0x41012000

010135bc <nrfx_ipc_receive_event_disable>:

void nrfx_ipc_receive_event_disable(uint8_t event_index)
{
    NRFX_ASSERT(m_ipc_cb.state == NRFX_DRV_STATE_INITIALIZED);
    nrf_ipc_int_disable(NRF_IPC, (1UL << event_index));
 10135bc:	2301      	movs	r3, #1
    p_reg->INTENCLR = mask;
 10135be:	4a02      	ldr	r2, [pc, #8]	; (10135c8 <nrfx_ipc_receive_event_disable+0xc>)
 10135c0:	4083      	lsls	r3, r0
 10135c2:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
}
 10135c6:	4770      	bx	lr
 10135c8:	41012000 	.word	0x41012000

010135cc <nrfx_ipc_irq_handler>:
    return p_reg->INTPEND;
 10135cc:	4b0c      	ldr	r3, [pc, #48]	; (1013600 <nrfx_ipc_irq_handler+0x34>)
    channel_bitmask |= nrf_ipc_send_config_get(NRF_IPC, send_index);
    nrf_ipc_send_config_set(NRF_IPC, send_index, channel_bitmask);
}

void nrfx_ipc_irq_handler(void)
{
 10135ce:	b430      	push	{r4, r5}
 10135d0:	f8d3 030c 	ldr.w	r0, [r3, #780]	; 0x30c
    // Clear these events
    uint32_t bitmask = events_map;
    while (bitmask)
    {
        uint8_t event_idx = __CLZ(__RBIT(bitmask));
        bitmask &= ~(1UL << event_idx);
 10135d4:	2401      	movs	r4, #1
    uint32_t bitmask = events_map;
 10135d6:	4602      	mov	r2, r0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 10135d8:	2500      	movs	r5, #0
    while (bitmask)
 10135da:	b922      	cbnz	r2, 10135e6 <nrfx_ipc_irq_handler+0x1a>
        nrf_ipc_event_clear(NRF_IPC, nrf_ipc_receive_event_get(event_idx));
    }

    // Execute interrupt handler to provide information about events to app
    m_ipc_cb.handler(events_map, m_ipc_cb.p_context);
}
 10135dc:	bc30      	pop	{r4, r5}
    m_ipc_cb.handler(events_map, m_ipc_cb.p_context);
 10135de:	4b09      	ldr	r3, [pc, #36]	; (1013604 <nrfx_ipc_irq_handler+0x38>)
 10135e0:	681a      	ldr	r2, [r3, #0]
 10135e2:	6899      	ldr	r1, [r3, #8]
 10135e4:	4710      	bx	r2
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 10135e6:	fa92 f3a2 	rbit	r3, r2
  return __builtin_clz(value);
 10135ea:	fab3 f383 	clz	r3, r3
        bitmask &= ~(1UL << event_idx);
 10135ee:	fa04 f103 	lsl.w	r1, r4, r3
 10135f2:	ea22 0201 	bic.w	r2, r2, r1
 10135f6:	4904      	ldr	r1, [pc, #16]	; (1013608 <nrfx_ipc_irq_handler+0x3c>)
}

NRF_STATIC_INLINE nrf_ipc_event_t nrf_ipc_receive_event_get(uint8_t index)
{
    NRFX_ASSERT(index < IPC_CH_NUM);
    return (nrf_ipc_event_t)(NRFX_OFFSETOF(NRF_IPC_Type, EVENTS_RECEIVE[index]));
 10135f8:	009b      	lsls	r3, r3, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 10135fa:	50cd      	str	r5, [r1, r3]
}
 10135fc:	e7ed      	b.n	10135da <nrfx_ipc_irq_handler+0xe>
 10135fe:	bf00      	nop
 1013600:	41012000 	.word	0x41012000
 1013604:	21005a18 	.word	0x21005a18
 1013608:	41012100 	.word	0x41012100

0101360c <metal_generic_dev_open>:
	return 0;
}

int metal_generic_dev_open(struct metal_bus *bus, const char *dev_name,
			   struct metal_device **device)
{
 101360c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1013610:	460e      	mov	r6, r1
 1013612:	4617      	mov	r7, r2
	struct metal_list *node;
	struct metal_device *dev;

	(void)bus;

	metal_list_for_each(&_metal.common.generic_device_list, node) {
 1013614:	4d0c      	ldr	r5, [pc, #48]	; (1013648 <metal_generic_dev_open+0x3c>)
 1013616:	f855 4f18 	ldr.w	r4, [r5, #24]!
 101361a:	42ac      	cmp	r4, r5
 101361c:	d103      	bne.n	1013626 <metal_generic_dev_open+0x1a>
			return metal_generic_dev_sys_open(dev);
		}
	}

	return -ENODEV;
}
 101361e:	f06f 0012 	mvn.w	r0, #18
 1013622:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (strcmp(dev->name, dev_name) == 0) {
 1013626:	4631      	mov	r1, r6
 1013628:	f854 0c44 	ldr.w	r0, [r4, #-68]
		dev = metal_container_of(node, struct metal_device, node);
 101362c:	f1a4 0844 	sub.w	r8, r4, #68	; 0x44
		if (strcmp(dev->name, dev_name) == 0) {
 1013630:	f003 f9c7 	bl	10169c2 <strcmp>
 1013634:	b930      	cbnz	r0, 1013644 <metal_generic_dev_open+0x38>
			return metal_generic_dev_sys_open(dev);
 1013636:	4640      	mov	r0, r8
			*device = dev;
 1013638:	f8c7 8000 	str.w	r8, [r7]
}
 101363c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			return metal_generic_dev_sys_open(dev);
 1013640:	f003 bd2b 	b.w	101709a <metal_generic_dev_sys_open>
	metal_list_for_each(&_metal.common.generic_device_list, node) {
 1013644:	6824      	ldr	r4, [r4, #0]
 1013646:	e7e8      	b.n	101361a <metal_generic_dev_open+0xe>
 1013648:	21005a24 	.word	0x21005a24

0101364c <metal_bus_find>:
{
 101364c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1013650:	4607      	mov	r7, r0
 1013652:	460d      	mov	r5, r1
	metal_list_for_each(&_metal.common.bus_list, node) {
 1013654:	4e0b      	ldr	r6, [pc, #44]	; (1013684 <metal_bus_find+0x38>)
 1013656:	f856 4f08 	ldr.w	r4, [r6, #8]!
 101365a:	42b4      	cmp	r4, r6
 101365c:	d102      	bne.n	1013664 <metal_bus_find+0x18>
	return -ENOENT;
 101365e:	f06f 0001 	mvn.w	r0, #1
 1013662:	e00a      	b.n	101367a <metal_bus_find+0x2e>
		if (strcmp(bus->name, name) == 0 && result) {
 1013664:	4639      	mov	r1, r7
 1013666:	f854 0c24 	ldr.w	r0, [r4, #-36]
		bus = metal_container_of(node, struct metal_bus, node);
 101366a:	f1a4 0824 	sub.w	r8, r4, #36	; 0x24
		if (strcmp(bus->name, name) == 0 && result) {
 101366e:	f003 f9a8 	bl	10169c2 <strcmp>
 1013672:	b920      	cbnz	r0, 101367e <metal_bus_find+0x32>
 1013674:	b11d      	cbz	r5, 101367e <metal_bus_find+0x32>
			*result = bus;
 1013676:	f8c5 8000 	str.w	r8, [r5]
}
 101367a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	metal_list_for_each(&_metal.common.bus_list, node) {
 101367e:	6824      	ldr	r4, [r4, #0]
 1013680:	e7eb      	b.n	101365a <metal_bus_find+0xe>
 1013682:	bf00      	nop
 1013684:	21005a24 	.word	0x21005a24

01013688 <metal_bus_register>:
{
 1013688:	b510      	push	{r4, lr}
	if (!bus || !bus->name || !strlen(bus->name))
 101368a:	4604      	mov	r4, r0
 101368c:	b910      	cbnz	r0, 1013694 <metal_bus_register+0xc>
		return -EINVAL;
 101368e:	f06f 0015 	mvn.w	r0, #21
}
 1013692:	bd10      	pop	{r4, pc}
	if (!bus || !bus->name || !strlen(bus->name))
 1013694:	6800      	ldr	r0, [r0, #0]
 1013696:	2800      	cmp	r0, #0
 1013698:	d0f9      	beq.n	101368e <metal_bus_register+0x6>
 101369a:	f003 f98b 	bl	10169b4 <strlen>
 101369e:	2800      	cmp	r0, #0
 10136a0:	d0f5      	beq.n	101368e <metal_bus_register+0x6>
	if (metal_bus_find(bus->name, NULL) == 0)
 10136a2:	2100      	movs	r1, #0
 10136a4:	6820      	ldr	r0, [r4, #0]
 10136a6:	f7ff ffd1 	bl	101364c <metal_bus_find>
 10136aa:	b1c0      	cbz	r0, 10136de <metal_bus_register+0x56>
	metal_list_init(&bus->devices);
 10136ac:	f104 031c 	add.w	r3, r4, #28
	struct metal_list name = METAL_INIT_LIST(name)

static inline void metal_list_init(struct metal_list *list)
{
	list->prev = list;
	list->next = list;
 10136b0:	e9c4 3307 	strd	r3, r3, [r4, #28]
}

static inline void metal_list_add_before(struct metal_list *node,
					 struct metal_list *new_node)
{
	new_node->prev = node->prev;
 10136b4:	4b0c      	ldr	r3, [pc, #48]	; (10136e8 <metal_bus_register+0x60>)
	metal_list_add_tail(&_metal.common.bus_list, &bus->node);
 10136b6:	f104 0224 	add.w	r2, r4, #36	; 0x24
 10136ba:	68d9      	ldr	r1, [r3, #12]
	new_node->next = node;
 10136bc:	f103 0008 	add.w	r0, r3, #8
	new_node->next->prev = new_node;
 10136c0:	60da      	str	r2, [r3, #12]
	new_node->prev = node->prev;
 10136c2:	62a1      	str	r1, [r4, #40]	; 0x28
	new_node->next = node;
 10136c4:	6260      	str	r0, [r4, #36]	; 0x24
	new_node->prev->next = new_node;
 10136c6:	600a      	str	r2, [r1, #0]
	metal_log(METAL_LOG_DEBUG, "registered %s bus\n", bus->name);
 10136c8:	781a      	ldrb	r2, [r3, #0]
 10136ca:	2a06      	cmp	r2, #6
 10136cc:	d905      	bls.n	10136da <metal_bus_register+0x52>
 10136ce:	685b      	ldr	r3, [r3, #4]
 10136d0:	b143      	cbz	r3, 10136e4 <metal_bus_register+0x5c>
 10136d2:	2007      	movs	r0, #7
 10136d4:	6822      	ldr	r2, [r4, #0]
 10136d6:	4905      	ldr	r1, [pc, #20]	; (10136ec <metal_bus_register+0x64>)
 10136d8:	4798      	blx	r3
	return 0;
 10136da:	2000      	movs	r0, #0
 10136dc:	e7d9      	b.n	1013692 <metal_bus_register+0xa>
		return -EEXIST;
 10136de:	f06f 0010 	mvn.w	r0, #16
 10136e2:	e7d6      	b.n	1013692 <metal_bus_register+0xa>
	return 0;
 10136e4:	4618      	mov	r0, r3
 10136e6:	e7d4      	b.n	1013692 <metal_bus_register+0xa>
 10136e8:	21005a24 	.word	0x21005a24
 10136ec:	01019a33 	.word	0x01019a33

010136f0 <metal_register_generic_device>:
{
 10136f0:	b510      	push	{r4, lr}
 10136f2:	4604      	mov	r4, r0
	if (!device->name || !strlen(device->name) ||
 10136f4:	6800      	ldr	r0, [r0, #0]
 10136f6:	b910      	cbnz	r0, 10136fe <metal_register_generic_device+0xe>
		return -EINVAL;
 10136f8:	f06f 0015 	mvn.w	r0, #21
}
 10136fc:	bd10      	pop	{r4, pc}
	if (!device->name || !strlen(device->name) ||
 10136fe:	f003 f959 	bl	10169b4 <strlen>
 1013702:	2800      	cmp	r0, #0
 1013704:	d0f8      	beq.n	10136f8 <metal_register_generic_device+0x8>
 1013706:	68a3      	ldr	r3, [r4, #8]
 1013708:	2b01      	cmp	r3, #1
 101370a:	d8f5      	bhi.n	10136f8 <metal_register_generic_device+0x8>
	device->bus = &metal_generic_bus;
 101370c:	4b06      	ldr	r3, [pc, #24]	; (1013728 <metal_register_generic_device+0x38>)
	metal_list_add_tail(&_metal.common.generic_device_list,
 101370e:	f104 0144 	add.w	r1, r4, #68	; 0x44
	device->bus = &metal_generic_bus;
 1013712:	6063      	str	r3, [r4, #4]
	new_node->prev = node->prev;
 1013714:	4b05      	ldr	r3, [pc, #20]	; (101372c <metal_register_generic_device+0x3c>)
 1013716:	69da      	ldr	r2, [r3, #28]
	new_node->next = node;
 1013718:	f103 0018 	add.w	r0, r3, #24
 101371c:	6460      	str	r0, [r4, #68]	; 0x44
	new_node->prev = node->prev;
 101371e:	64a2      	str	r2, [r4, #72]	; 0x48
	new_node->next->prev = new_node;
 1013720:	61d9      	str	r1, [r3, #28]
	return 0;
 1013722:	2000      	movs	r0, #0
	new_node->prev->next = new_node;
 1013724:	6011      	str	r1, [r2, #0]
}
 1013726:	e7e9      	b.n	10136fc <metal_register_generic_device+0xc>
 1013728:	210004c8 	.word	0x210004c8
 101372c:	21005a24 	.word	0x21005a24

01013730 <metal_init>:

#include <string.h>
#include <metal/sys.h>

int metal_init(const struct metal_init_params *params)
{
 1013730:	b538      	push	{r3, r4, r5, lr}
 1013732:	4605      	mov	r5, r0
	int error = 0;

	memset(&_metal, 0, sizeof(_metal));
 1013734:	4c0d      	ldr	r4, [pc, #52]	; (101376c <metal_init+0x3c>)
 1013736:	2220      	movs	r2, #32
 1013738:	4620      	mov	r0, r4
 101373a:	2100      	movs	r1, #0
 101373c:	f003 f997 	bl	1016a6e <memset>

	_metal.common.log_handler   = params->log_handler;
 1013740:	682b      	ldr	r3, [r5, #0]

	metal_list_init(&_metal.common.bus_list);
	metal_list_init(&_metal.common.generic_shmem_list);
	metal_list_init(&_metal.common.generic_device_list);

	error = metal_sys_init(params);
 1013742:	4628      	mov	r0, r5
	_metal.common.log_handler   = params->log_handler;
 1013744:	6063      	str	r3, [r4, #4]
	_metal.common.log_level     = params->log_level;
 1013746:	4623      	mov	r3, r4
 1013748:	792a      	ldrb	r2, [r5, #4]
 101374a:	f803 2b08 	strb.w	r2, [r3], #8
	list->next = list;
 101374e:	e9c4 3302 	strd	r3, r3, [r4, #8]
	list->prev = list;
 1013752:	f104 0310 	add.w	r3, r4, #16
	list->next = list;
 1013756:	e9c4 3304 	strd	r3, r3, [r4, #16]
	list->prev = list;
 101375a:	f104 0318 	add.w	r3, r4, #24
	list->next = list;
 101375e:	e9c4 3306 	strd	r3, r3, [r4, #24]
	if (error)
		return error;

	return error;
}
 1013762:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	error = metal_sys_init(params);
 1013766:	f000 b803 	b.w	1013770 <metal_sys_init>
 101376a:	bf00      	nop
 101376c:	21005a24 	.word	0x21005a24

01013770 <metal_sys_init>:
#include <metal/utilities.h>

struct metal_state _metal;

int metal_sys_init(const struct metal_init_params *params)
{
 1013770:	b508      	push	{r3, lr}
	metal_bus_register(&metal_generic_bus);
 1013772:	4802      	ldr	r0, [pc, #8]	; (101377c <metal_sys_init+0xc>)
 1013774:	f7ff ff88 	bl	1013688 <metal_bus_register>
	return 0;
}
 1013778:	2000      	movs	r0, #0
 101377a:	bd08      	pop	{r3, pc}
 101377c:	210004c8 	.word	0x210004c8

01013780 <metal_zephyr_log_handler>:
	"metal: debug:     ",
};

void metal_zephyr_log_handler(enum metal_log_level level,
			      const char *format, ...)
{
 1013780:	b40e      	push	{r1, r2, r3}
	va_list args;

	if (level <= METAL_LOG_EMERGENCY || level > METAL_LOG_DEBUG)
 1013782:	1e43      	subs	r3, r0, #1
		level = METAL_LOG_EMERGENCY;
 1013784:	2b06      	cmp	r3, #6
{
 1013786:	b533      	push	{r0, r1, r4, r5, lr}
		level = METAL_LOG_EMERGENCY;
 1013788:	bf88      	it	hi
 101378a:	2000      	movhi	r0, #0
	printk("%s", level_strs[level]);
 101378c:	4b09      	ldr	r3, [pc, #36]	; (10137b4 <metal_zephyr_log_handler+0x34>)
{
 101378e:	ac05      	add	r4, sp, #20
 1013790:	f854 5b04 	ldr.w	r5, [r4], #4
	printk("%s", level_strs[level]);
 1013794:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]
 1013798:	4807      	ldr	r0, [pc, #28]	; (10137b8 <metal_zephyr_log_handler+0x38>)
 101379a:	f001 fbcc 	bl	1014f36 <printk>

	va_start(args, format);
	vprintk(format, args);
 101379e:	4621      	mov	r1, r4
 10137a0:	4628      	mov	r0, r5
	va_start(args, format);
 10137a2:	9401      	str	r4, [sp, #4]
	vprintk(format, args);
 10137a4:	f7f0 fad0 	bl	1003d48 <vprintk>
	va_end(args);
}
 10137a8:	b002      	add	sp, #8
 10137aa:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 10137ae:	b003      	add	sp, #12
 10137b0:	4770      	bx	lr
 10137b2:	bf00      	nop
 10137b4:	01018f5c 	.word	0x01018f5c
 10137b8:	0101935a 	.word	0x0101935a

010137bc <virtio_create_virtqueues>:
}

int virtio_create_virtqueues(struct virtio_device *vdev, unsigned int flags,
			     unsigned int nvqs, const char *names[],
			     vq_callback callbacks[])
{
 10137bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10137c0:	b087      	sub	sp, #28
 10137c2:	9305      	str	r3, [sp, #20]
	unsigned int num_vrings, i;
	int ret;
	(void)flags;

	num_vrings = vdev->vrings_num;
	if (nvqs > num_vrings)
 10137c4:	6a83      	ldr	r3, [r0, #40]	; 0x28
{
 10137c6:	4606      	mov	r6, r0
	if (nvqs > num_vrings)
 10137c8:	4293      	cmp	r3, r2
{
 10137ca:	4617      	mov	r7, r2
	if (nvqs > num_vrings)
 10137cc:	d342      	bcc.n	1013854 <virtio_create_virtqueues+0x98>
		return ERROR_VQUEUE_INVLD_PARAM;
	/* Initialize virtqueue for each vring */
	for (i = 0; i < nvqs; i++) {
 10137ce:	2500      	movs	r5, #0
		vring_info = &vdev->vrings_info[i];
 10137d0:	f04f 0b18 	mov.w	fp, #24
	for (i = 0; i < nvqs; i++) {
 10137d4:	42bd      	cmp	r5, r7
 10137d6:	d103      	bne.n	10137e0 <virtio_create_virtqueues+0x24>
				       callbacks[i], vdev->func->notify,
				       vring_info->vq);
		if (ret)
			return ret;
	}
	return 0;
 10137d8:	2000      	movs	r0, #0
}
 10137da:	b007      	add	sp, #28
 10137dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		vring_info = &vdev->vrings_info[i];
 10137e0:	fb0b f805 	mul.w	r8, fp, r5
 10137e4:	f8d6 902c 	ldr.w	r9, [r6, #44]	; 0x2c
		if (vdev->role == VIRTIO_DEV_MASTER) {
 10137e8:	69b2      	ldr	r2, [r6, #24]
		vring_info = &vdev->vrings_info[i];
 10137ea:	eb09 0408 	add.w	r4, r9, r8
		vring_alloc = &vring_info->info;
 10137ee:	f104 0a04 	add.w	sl, r4, #4
		if (vdev->role == VIRTIO_DEV_MASTER) {
 10137f2:	b9ca      	cbnz	r2, 1013828 <virtio_create_virtqueues+0x6c>
			struct metal_io_region *io = vring_info->io;
 10137f4:	6960      	ldr	r0, [r4, #20]
 * @return	METAL_BAD_OFFSET if out of range, or offset.
 */
static inline unsigned long
metal_io_virt_to_offset(struct metal_io_region *io, void *virt)
{
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
 10137f6:	6863      	ldr	r3, [r4, #4]
 10137f8:	6801      	ldr	r1, [r0, #0]
			metal_io_block_set(io, offset, 0,
 10137fa:	f8b4 c00c 	ldrh.w	ip, [r4, #12]
 10137fe:	1a59      	subs	r1, r3, r1
						      vring_alloc->align));
 1013800:	68a3      	ldr	r3, [r4, #8]
static inline int vring_size(unsigned int num, unsigned long align)
{
	int size;

	size = num * sizeof(struct vring_desc);
	size += sizeof(struct vring_avail) + (num * sizeof(uint16_t)) +
 1013802:	f10c 0e03 	add.w	lr, ip, #3
	    sizeof(uint16_t);
	size = (size + align - 1) & ~(align - 1);
 1013806:	1e5c      	subs	r4, r3, #1
 1013808:	eb04 140c 	add.w	r4, r4, ip, lsl #4
 101380c:	eb04 044e 	add.w	r4, r4, lr, lsl #1
 1013810:	425b      	negs	r3, r3
 1013812:	4023      	ands	r3, r4
			metal_io_block_set(io, offset, 0,
 1013814:	6884      	ldr	r4, [r0, #8]
	size += sizeof(struct vring_used) +
 1013816:	eb03 03cc 	add.w	r3, r3, ip, lsl #3
 101381a:	42a1      	cmp	r1, r4
 101381c:	bf28      	it	cs
 101381e:	f04f 31ff 	movcs.w	r1, #4294967295
 1013822:	3306      	adds	r3, #6
 1013824:	f003 fc00 	bl	1017028 <metal_io_block_set>
		ret = virtqueue_create(vdev, i, names[i], vring_alloc,
 1013828:	f859 3008 	ldr.w	r3, [r9, r8]
 101382c:	9a05      	ldr	r2, [sp, #20]
 101382e:	9302      	str	r3, [sp, #8]
 1013830:	6a33      	ldr	r3, [r6, #32]
 1013832:	4630      	mov	r0, r6
 1013834:	6a1b      	ldr	r3, [r3, #32]
 1013836:	b2a9      	uxth	r1, r5
 1013838:	9301      	str	r3, [sp, #4]
 101383a:	9b10      	ldr	r3, [sp, #64]	; 0x40
 101383c:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 1013840:	9300      	str	r3, [sp, #0]
 1013842:	f852 2025 	ldr.w	r2, [r2, r5, lsl #2]
 1013846:	4653      	mov	r3, sl
 1013848:	f003 fc44 	bl	10170d4 <virtqueue_create>
		if (ret)
 101384c:	2800      	cmp	r0, #0
 101384e:	d1c4      	bne.n	10137da <virtio_create_virtqueues+0x1e>
	for (i = 0; i < nvqs; i++) {
 1013850:	3501      	adds	r5, #1
 1013852:	e7bf      	b.n	10137d4 <virtio_create_virtqueues+0x18>
		return ERROR_VQUEUE_INVLD_PARAM;
 1013854:	4800      	ldr	r0, [pc, #0]	; (1013858 <virtio_create_virtqueues+0x9c>)
 1013856:	e7c0      	b.n	10137da <virtio_create_virtqueues+0x1e>
 1013858:	fffff440 	.word	0xfffff440

0101385c <virtqueue_add_consumed_buffer>:
 *
 * @return                       - Function status
 */
int virtqueue_add_consumed_buffer(struct virtqueue *vq, uint16_t head_idx,
				  uint32_t len)
{
 101385c:	b530      	push	{r4, r5, lr}
	struct vring_used_elem *used_desc = NULL;
	uint16_t used_idx;

	if (head_idx > vq->vq_nentries) {
 101385e:	8944      	ldrh	r4, [r0, #10]
 1013860:	428c      	cmp	r4, r1
 1013862:	d312      	bcc.n	101388a <virtqueue_add_consumed_buffer+0x2e>
		return ERROR_VRING_NO_BUFF;
	}

	VQUEUE_BUSY(vq);

	used_idx = vq->vq_ring.used->idx & (vq->vq_nentries - 1);
 1013864:	6a03      	ldr	r3, [r0, #32]
 1013866:	3c01      	subs	r4, #1
 1013868:	885d      	ldrh	r5, [r3, #2]
 101386a:	402c      	ands	r4, r5
 101386c:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
	used_desc = &vq->vq_ring.used->ring[used_idx];
	used_desc->id = head_idx;
	used_desc->len = len;
 1013870:	609a      	str	r2, [r3, #8]
	used_desc->id = head_idx;
 1013872:	6059      	str	r1, [r3, #4]

	atomic_thread_fence(memory_order_seq_cst);
 1013874:	f3bf 8f5b 	dmb	ish

	vq->vq_ring.used->idx++;
 1013878:	6a02      	ldr	r2, [r0, #32]
 101387a:	8853      	ldrh	r3, [r2, #2]
 101387c:	3301      	adds	r3, #1
 101387e:	8053      	strh	r3, [r2, #2]

	/* Keep pending count until virtqueue_notify(). */
	vq->vq_queued_cnt++;
 1013880:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
 1013882:	3301      	adds	r3, #1
 1013884:	84c3      	strh	r3, [r0, #38]	; 0x26

	VQUEUE_IDLE(vq);

	return VQUEUE_SUCCESS;
 1013886:	2000      	movs	r0, #0
}
 1013888:	bd30      	pop	{r4, r5, pc}
		return ERROR_VRING_NO_BUFF;
 101388a:	4801      	ldr	r0, [pc, #4]	; (1013890 <virtqueue_add_consumed_buffer+0x34>)
 101388c:	e7fc      	b.n	1013888 <virtqueue_add_consumed_buffer+0x2c>
 101388e:	bf00      	nop
 1013890:	fffff441 	.word	0xfffff441

01013894 <rpmsg_send_offchannel_raw>:
 *
 */
int rpmsg_send_offchannel_raw(struct rpmsg_endpoint *ept, uint32_t src,
			      uint32_t dst, const void *data, int size,
			      int wait)
{
 1013894:	b430      	push	{r4, r5}
 1013896:	4614      	mov	r4, r2
	struct rpmsg_device *rdev;

	if (!ept || !ept->rdev || !data || dst == RPMSG_ADDR_ANY)
 1013898:	b148      	cbz	r0, 10138ae <rpmsg_send_offchannel_raw+0x1a>
 101389a:	6a00      	ldr	r0, [r0, #32]
 101389c:	b138      	cbz	r0, 10138ae <rpmsg_send_offchannel_raw+0x1a>
 101389e:	b133      	cbz	r3, 10138ae <rpmsg_send_offchannel_raw+0x1a>
 10138a0:	3401      	adds	r4, #1
 10138a2:	d004      	beq.n	10138ae <rpmsg_send_offchannel_raw+0x1a>
		return RPMSG_ERR_PARAM;

	rdev = ept->rdev;

	if (rdev->ops.send_offchannel_raw)
 10138a4:	6f44      	ldr	r4, [r0, #116]	; 0x74
 10138a6:	b114      	cbz	r4, 10138ae <rpmsg_send_offchannel_raw+0x1a>
		return rdev->ops.send_offchannel_raw(rdev, src, dst, data,
 10138a8:	46a4      	mov	ip, r4
						      size, wait);

	return RPMSG_ERR_PARAM;
}
 10138aa:	bc30      	pop	{r4, r5}
		return rdev->ops.send_offchannel_raw(rdev, src, dst, data,
 10138ac:	4760      	bx	ip
		return RPMSG_ERR_PARAM;
 10138ae:	4801      	ldr	r0, [pc, #4]	; (10138b4 <rpmsg_send_offchannel_raw+0x20>)
}
 10138b0:	bc30      	pop	{r4, r5}
 10138b2:	4770      	bx	lr
 10138b4:	fffff82d 	.word	0xfffff82d

010138b8 <rpmsg_create_ept>:
}

int rpmsg_create_ept(struct rpmsg_endpoint *ept, struct rpmsg_device *rdev,
		     const char *name, uint32_t src, uint32_t dest,
		     rpmsg_ept_cb cb, rpmsg_ns_unbind_cb unbind_cb)
{
 10138b8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 10138bc:	460e      	mov	r6, r1
 10138be:	4690      	mov	r8, r2
 10138c0:	461d      	mov	r5, r3
	int status = RPMSG_SUCCESS;
	uint32_t addr = src;

	if (!ept)
 10138c2:	4604      	mov	r4, r0
 10138c4:	2800      	cmp	r0, #0
 10138c6:	d066      	beq.n	1013996 <rpmsg_create_ept+0xde>
		return RPMSG_ERR_PARAM;

	metal_mutex_acquire(&rdev->lock);
 10138c8:	f101 0758 	add.w	r7, r1, #88	; 0x58
 * @brief	Acquire a mutex
 * @param[in]	mutex	Mutex to mutex.
 */
static inline void metal_mutex_acquire(metal_mutex_t *mutex)
{
	__metal_mutex_acquire(mutex);
 10138cc:	4638      	mov	r0, r7
 10138ce:	f003 fdb8 	bl	1017442 <__metal_mutex_acquire>
	if (src != RPMSG_ADDR_ANY) {
 10138d2:	1c69      	adds	r1, r5, #1
 10138d4:	f106 0248 	add.w	r2, r6, #72	; 0x48
 10138d8:	d059      	beq.n	101398e <rpmsg_create_ept+0xd6>
	if (addr < size)
 10138da:	2d7f      	cmp	r5, #127	; 0x7f
 10138dc:	dc59      	bgt.n	1013992 <rpmsg_create_ept+0xda>
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
}

static inline int metal_bitmap_is_bit_set(unsigned long *bitmap, int bit)
{
	return ((bitmap[bit / METAL_BITS_PER_ULONG] &
 10138de:	0969      	lsrs	r1, r5, #5
 10138e0:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1))) == 0) ? 0 : 1;
 10138e4:	f005 0c1f 	and.w	ip, r5, #31
 10138e8:	fa20 f30c 	lsr.w	r3, r0, ip
		status = rpmsg_is_address_set(rdev->bitmap,
					      RPMSG_ADDR_BMP_SIZE, src);
		if (!status) {
 10138ec:	07db      	lsls	r3, r3, #31
 10138ee:	d506      	bpl.n	10138fe <rpmsg_create_ept+0x46>
			/* Mark the address as used in the address bitmap. */
			rpmsg_set_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE,
					  src);
		} else if (status > 0) {
			status = RPMSG_SUCCESS;
 10138f0:	2500      	movs	r5, #0
 10138f2:	4638      	mov	r0, r7
 10138f4:	f000 ff58 	bl	10147a8 <z_impl_k_sem_give>
	}

ret_status:
	metal_mutex_release(&rdev->lock);
	return status;
}
 10138f8:	4628      	mov	r0, r5
 10138fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
 10138fe:	2301      	movs	r3, #1
 1013900:	fa03 f30c 	lsl.w	r3, r3, ip
	bitmap[bit / METAL_BITS_PER_ULONG] |=
 1013904:	4303      	orrs	r3, r0
 1013906:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
				  const char *name,
				  uint32_t src, uint32_t dest,
				  rpmsg_ept_cb cb,
				  rpmsg_ns_unbind_cb ns_unbind_cb)
{
	strncpy(ept->name, name ? name : "", sizeof(ept->name));
 101390a:	4924      	ldr	r1, [pc, #144]	; (101399c <rpmsg_create_ept+0xe4>)
 101390c:	2220      	movs	r2, #32
 101390e:	f1b8 0f00 	cmp.w	r8, #0
 1013912:	bf18      	it	ne
 1013914:	4641      	movne	r1, r8
 1013916:	4620      	mov	r0, r4
 1013918:	f003 f839 	bl	101698e <strncpy>
	ept->addr = src;
	ept->dest_addr = dest;
 101391c:	9b06      	ldr	r3, [sp, #24]
	rpmsg_register_endpoint(rdev, ept);
 101391e:	4621      	mov	r1, r4
 1013920:	62a3      	str	r3, [r4, #40]	; 0x28
	ept->cb = cb;
 1013922:	9b07      	ldr	r3, [sp, #28]
 1013924:	4630      	mov	r0, r6
 1013926:	62e3      	str	r3, [r4, #44]	; 0x2c
	ept->ns_unbind_cb = ns_unbind_cb;
 1013928:	9b08      	ldr	r3, [sp, #32]
	ept->addr = src;
 101392a:	6265      	str	r5, [r4, #36]	; 0x24
	ept->ns_unbind_cb = ns_unbind_cb;
 101392c:	6323      	str	r3, [r4, #48]	; 0x30
 101392e:	f003 fdd7 	bl	10174e0 <rpmsg_register_endpoint>
	if (rdev->support_ns && ept->dest_addr == RPMSG_ADDR_ANY) {
 1013932:	f896 3078 	ldrb.w	r3, [r6, #120]	; 0x78
 1013936:	2b00      	cmp	r3, #0
 1013938:	d0da      	beq.n	10138f0 <rpmsg_create_ept+0x38>
 101393a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 101393c:	3301      	adds	r3, #1
 101393e:	d1d7      	bne.n	10138f0 <rpmsg_create_ept+0x38>
 1013940:	4638      	mov	r0, r7
 1013942:	f000 ff31 	bl	10147a8 <z_impl_k_sem_give>
		status = rpmsg_send_ns_message(ept, RPMSG_NS_CREATE);
 1013946:	2100      	movs	r1, #0
 1013948:	4620      	mov	r0, r4
 101394a:	f003 fd80 	bl	101744e <rpmsg_send_ns_message>
 101394e:	4605      	mov	r5, r0
 1013950:	4638      	mov	r0, r7
 1013952:	f003 fd76 	bl	1017442 <__metal_mutex_acquire>
		if (status)
 1013956:	2d00      	cmp	r5, #0
 1013958:	d0cb      	beq.n	10138f2 <rpmsg_create_ept+0x3a>
			rpmsg_unregister_endpoint(ept);
 101395a:	4620      	mov	r0, r4
 101395c:	f003 fd53 	bl	1017406 <rpmsg_unregister_endpoint>
 1013960:	e7c7      	b.n	10138f2 <rpmsg_create_ept+0x3a>
{
	unsigned int bit;

	for (bit = start;
	     bit < max && !metal_bitmap_is_bit_clear(bitmap, bit);
	     bit++)
 1013962:	3301      	adds	r3, #1
	for (bit = start;
 1013964:	2b80      	cmp	r3, #128	; 0x80
 1013966:	d0d0      	beq.n	101390a <rpmsg_create_ept+0x52>
	return ((bitmap[bit / METAL_BITS_PER_ULONG] &
 1013968:	0959      	lsrs	r1, r3, #5
 101396a:	eb02 0e81 	add.w	lr, r2, r1, lsl #2
 101396e:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1))) == 0) ? 0 : 1;
 1013972:	f003 0c1f 	and.w	ip, r3, #31
 1013976:	fa21 f00c 	lsr.w	r0, r1, ip
	     bit < max && !metal_bitmap_is_bit_clear(bitmap, bit);
 101397a:	07c0      	lsls	r0, r0, #31
 101397c:	d4f1      	bmi.n	1013962 <rpmsg_create_ept+0xaa>
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
 101397e:	2001      	movs	r0, #1
 1013980:	fa00 f00c 	lsl.w	r0, r0, ip
	bitmap[bit / METAL_BITS_PER_ULONG] |=
 1013984:	4308      	orrs	r0, r1
}
 1013986:	461d      	mov	r5, r3
	bitmap[bit / METAL_BITS_PER_ULONG] |=
 1013988:	f8ce 0000 	str.w	r0, [lr]
}
 101398c:	e7bd      	b.n	101390a <rpmsg_create_ept+0x52>
	for (bit = start;
 101398e:	2300      	movs	r3, #0
 1013990:	e7ea      	b.n	1013968 <rpmsg_create_ept+0xb0>
		return RPMSG_ERR_PARAM;
 1013992:	4d03      	ldr	r5, [pc, #12]	; (10139a0 <rpmsg_create_ept+0xe8>)
 1013994:	e7ad      	b.n	10138f2 <rpmsg_create_ept+0x3a>
		return RPMSG_ERR_PARAM;
 1013996:	4d02      	ldr	r5, [pc, #8]	; (10139a0 <rpmsg_create_ept+0xe8>)
 1013998:	e7ae      	b.n	10138f8 <rpmsg_create_ept+0x40>
 101399a:	bf00      	nop
 101399c:	01019365 	.word	0x01019365
 10139a0:	fffff82d 	.word	0xfffff82d

010139a4 <rpmsg_virtio_send_offchannel_raw>:
 */
static int rpmsg_virtio_send_offchannel_raw(struct rpmsg_device *rdev,
					    uint32_t src, uint32_t dst,
					    const void *data,
					    int size, int wait)
{
 10139a4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10139a8:	4604      	mov	r4, r0
	struct metal_io_region *io;

	/* Get the associated remote device for channel. */
	rvdev = metal_container_of(rdev, struct rpmsg_virtio_device, rdev);

	status = rpmsg_virtio_get_status(rvdev);
 10139aa:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
{
 10139ac:	469b      	mov	fp, r3
	rvdev->vdev->func->set_status(rvdev->vdev, status);
}

static inline uint8_t rpmsg_virtio_get_status(struct rpmsg_virtio_device *rvdev)
{
	return rvdev->vdev->func->get_status(rvdev->vdev);
 10139ae:	6a03      	ldr	r3, [r0, #32]
 10139b0:	b08d      	sub	sp, #52	; 0x34
 10139b2:	681b      	ldr	r3, [r3, #0]
 10139b4:	4692      	mov	sl, r2
 10139b6:	e9dd 6716 	ldrd	r6, r7, [sp, #88]	; 0x58
 10139ba:	9103      	str	r1, [sp, #12]
 10139bc:	4798      	blx	r3
	/* Validate device state */
	if (!(status & VIRTIO_CONFIG_STATUS_DRIVER_OK)) {
 10139be:	0743      	lsls	r3, r0, #29
 10139c0:	f140 8089 	bpl.w	1013ad6 <rpmsg_virtio_send_offchannel_raw+0x132>
		return RPMSG_ERR_DEV_STATE;
	}

	if (wait)
		tick_count = RPMSG_TICK_COUNT / RPMSG_TICKS_PER_INTERVAL;
 10139c4:	f643 2398 	movw	r3, #15000	; 0x3a98
 10139c8:	2f00      	cmp	r7, #0
 10139ca:	bf18      	it	ne
 10139cc:	461f      	movne	r7, r3

	while (1) {
		int avail_size;

		/* Lock the device to enable exclusive access to virtqueues */
		metal_mutex_acquire(&rdev->lock);
 10139ce:	f104 0858 	add.w	r8, r4, #88	; 0x58
 10139d2:	4640      	mov	r0, r8
 10139d4:	f003 fdc3 	bl	101755e <__metal_mutex_acquire>
	return rvdev->vdev->role;
 10139d8:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 10139da:	699b      	ldr	r3, [r3, #24]
	if (role == RPMSG_MASTER) {
 10139dc:	b373      	cbz	r3, 1013a3c <rpmsg_virtio_send_offchannel_raw+0x98>
	if (role == RPMSG_REMOTE) {
 10139de:	2b01      	cmp	r3, #1
 10139e0:	d108      	bne.n	10139f4 <rpmsg_virtio_send_offchannel_raw+0x50>
		    (int)virtqueue_get_desc_size(rvdev->svq) -
 10139e2:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 10139e6:	f003 fcf6 	bl	10173d6 <virtqueue_get_desc_size>
 10139ea:	3810      	subs	r0, #16
		avail_size = _rpmsg_virtio_get_buffer_size(rvdev);
		if (avail_size && size > avail_size) {
 10139ec:	2800      	cmp	r0, #0
 10139ee:	ea20 79e0 	bic.w	r9, r0, r0, asr #31
 10139f2:	dc25      	bgt.n	1013a40 <rpmsg_virtio_send_offchannel_raw+0x9c>
		length = RPMSG_BUFFER_SIZE - sizeof(struct rpmsg_hdr);
 10139f4:	f04f 0900 	mov.w	r9, #0
 10139f8:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 10139fa:	699b      	ldr	r3, [r3, #24]
	if (role == RPMSG_MASTER) {
 10139fc:	bb3b      	cbnz	r3, 1013a4e <rpmsg_virtio_send_offchannel_raw+0xaa>
		data = virtqueue_get_buffer(rvdev->svq, len, idx);
 10139fe:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 1013a02:	f10d 0212 	add.w	r2, sp, #18
 1013a06:	a905      	add	r1, sp, #20
 1013a08:	f003 fbf4 	bl	10171f4 <virtqueue_get_buffer>
		if (!data) {
 1013a0c:	4605      	mov	r5, r0
 1013a0e:	b948      	cbnz	r0, 1013a24 <rpmsg_virtio_send_offchannel_raw+0x80>
			data = rpmsg_virtio_shm_pool_get_buffer(rvdev->shpool,
 1013a10:	f44f 7100 	mov.w	r1, #512	; 0x200
 1013a14:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 1013a18:	f003 fe50 	bl	10176bc <rpmsg_virtio_shm_pool_get_buffer>
			*len = RPMSG_BUFFER_SIZE;
 1013a1c:	f44f 7300 	mov.w	r3, #512	; 0x200
			data = rpmsg_virtio_shm_pool_get_buffer(rvdev->shpool,
 1013a20:	4605      	mov	r5, r0
			*len = RPMSG_BUFFER_SIZE;
 1013a22:	9305      	str	r3, [sp, #20]
	k_sem_take(m, K_FOREVER);
}

static inline void __metal_mutex_release(metal_mutex_t *m)
{
	k_sem_give(m);
 1013a24:	4640      	mov	r0, r8
 1013a26:	f003 fd82 	bl	101752e <k_sem_give>
			return RPMSG_ERR_BUFF_SIZE;
		}

		buffer = rpmsg_virtio_get_tx_buffer(rvdev, &buff_len, &idx);
		metal_mutex_release(&rdev->lock);
		if (buffer || !tick_count)
 1013a2a:	2d00      	cmp	r5, #0
 1013a2c:	d157      	bne.n	1013ade <rpmsg_virtio_send_offchannel_raw+0x13a>
 1013a2e:	2f00      	cmp	r7, #0
 1013a30:	d053      	beq.n	1013ada <rpmsg_virtio_send_offchannel_raw+0x136>
			break;
		if (avail_size != 0)
 1013a32:	f1b9 0f00 	cmp.w	r9, #0
 1013a36:	d108      	bne.n	1013a4a <rpmsg_virtio_send_offchannel_raw+0xa6>
			return RPMSG_ERR_BUFF_SIZE;
		metal_sleep_usec(RPMSG_TICKS_PER_INTERVAL);
		tick_count--;
 1013a38:	3f01      	subs	r7, #1
	while (1) {
 1013a3a:	e7ca      	b.n	10139d2 <rpmsg_virtio_send_offchannel_raw+0x2e>
		length = RPMSG_BUFFER_SIZE - sizeof(struct rpmsg_hdr);
 1013a3c:	f44f 79f8 	mov.w	r9, #496	; 0x1f0
		if (avail_size && size > avail_size) {
 1013a40:	454e      	cmp	r6, r9
 1013a42:	ddd9      	ble.n	10139f8 <rpmsg_virtio_send_offchannel_raw+0x54>
 1013a44:	4640      	mov	r0, r8
 1013a46:	f003 fd72 	bl	101752e <k_sem_give>
			return RPMSG_ERR_BUFF_SIZE;
 1013a4a:	4e31      	ldr	r6, [pc, #196]	; (1013b10 <rpmsg_virtio_send_offchannel_raw+0x16c>)
 1013a4c:	e03f      	b.n	1013ace <rpmsg_virtio_send_offchannel_raw+0x12a>
	if (role == RPMSG_REMOTE) {
 1013a4e:	2b01      	cmp	r3, #1
 1013a50:	d108      	bne.n	1013a64 <rpmsg_virtio_send_offchannel_raw+0xc0>
		data = virtqueue_get_available_buffer(rvdev->svq, idx, len);
 1013a52:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 1013a56:	aa05      	add	r2, sp, #20
 1013a58:	f10d 0112 	add.w	r1, sp, #18
 1013a5c:	f003 fc04 	bl	1017268 <virtqueue_get_available_buffer>
 1013a60:	4605      	mov	r5, r0
 1013a62:	e7df      	b.n	1013a24 <rpmsg_virtio_send_offchannel_raw+0x80>
	void *data = NULL;
 1013a64:	2500      	movs	r5, #0
 1013a66:	e7dd      	b.n	1013a24 <rpmsg_virtio_send_offchannel_raw+0x80>
 1013a68:	683b      	ldr	r3, [r7, #0]

	return (offset < io->size ? offset : METAL_BAD_OFFSET);
 1013a6a:	68b8      	ldr	r0, [r7, #8]
	io = rvdev->shbuf_io;
	status = metal_io_block_write(io, metal_io_virt_to_offset(io, buffer),
				      &rp_hdr, sizeof(rp_hdr));
	RPMSG_ASSERT(status == sizeof(rp_hdr), "failed to write header\r\n");

	status = metal_io_block_write(io,
 1013a6c:	f105 0110 	add.w	r1, r5, #16
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
 1013a70:	1ac9      	subs	r1, r1, r3
 1013a72:	4281      	cmp	r1, r0
 1013a74:	bf28      	it	cs
 1013a76:	f04f 31ff 	movcs.w	r1, #4294967295
 1013a7a:	4633      	mov	r3, r6
 1013a7c:	465a      	mov	r2, fp
 1013a7e:	4638      	mov	r0, r7
 1013a80:	f003 fa97 	bl	1016fb2 <metal_io_block_write>
				      metal_io_virt_to_offset(io,
						RPMSG_LOCATE_DATA(buffer)),
				      data, size);
	RPMSG_ASSERT(status == size, "failed to write buffer\r\n");
 1013a84:	4286      	cmp	r6, r0
 1013a86:	d000      	beq.n	1013a8a <rpmsg_virtio_send_offchannel_raw+0xe6>
 1013a88:	e7fe      	b.n	1013a88 <rpmsg_virtio_send_offchannel_raw+0xe4>
 1013a8a:	4640      	mov	r0, r8
 1013a8c:	f003 fd67 	bl	101755e <__metal_mutex_acquire>
 1013a90:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
	metal_mutex_acquire(&rdev->lock);

	/* Enqueue buffer on virtqueue. */
	status = rpmsg_virtio_enqueue_buffer(rvdev, buffer, buff_len, idx);
 1013a92:	9a05      	ldr	r2, [sp, #20]
 1013a94:	699b      	ldr	r3, [r3, #24]
	if (role == RPMSG_MASTER) {
 1013a96:	b953      	cbnz	r3, 1013aae <rpmsg_virtio_send_offchannel_raw+0x10a>
		vqbuf.len = len;
 1013a98:	e9cd 5206 	strd	r5, r2, [sp, #24]
		return virtqueue_add_buffer(rvdev->svq, &vqbuf, 1, 0, buffer);
 1013a9c:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 1013aa0:	2201      	movs	r2, #1
 1013aa2:	9500      	str	r5, [sp, #0]
 1013aa4:	a906      	add	r1, sp, #24
 1013aa6:	f003 fb45 	bl	1017134 <virtqueue_add_buffer>
	RPMSG_ASSERT(status == VQUEUE_SUCCESS, "failed to enqueue buffer\r\n");
 1013aaa:	b148      	cbz	r0, 1013ac0 <rpmsg_virtio_send_offchannel_raw+0x11c>
 1013aac:	e7fe      	b.n	1013aac <rpmsg_virtio_send_offchannel_raw+0x108>
	if (role == RPMSG_REMOTE) {
 1013aae:	2b01      	cmp	r3, #1
 1013ab0:	d106      	bne.n	1013ac0 <rpmsg_virtio_send_offchannel_raw+0x11c>
		return virtqueue_add_consumed_buffer(rvdev->svq, idx, len);
 1013ab2:	f8bd 1012 	ldrh.w	r1, [sp, #18]
 1013ab6:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 1013aba:	f7ff fecf 	bl	101385c <virtqueue_add_consumed_buffer>
 1013abe:	e7f4      	b.n	1013aaa <rpmsg_virtio_send_offchannel_raw+0x106>
	/* Let the other side know that there is a job to process. */
	virtqueue_kick(rvdev->svq);
 1013ac0:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 1013ac4:	f003 fc4f 	bl	1017366 <virtqueue_kick>
 1013ac8:	4640      	mov	r0, r8
 1013aca:	f003 fd30 	bl	101752e <k_sem_give>

	metal_mutex_release(&rdev->lock);

	return size;
}
 1013ace:	4630      	mov	r0, r6
 1013ad0:	b00d      	add	sp, #52	; 0x34
 1013ad2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return RPMSG_ERR_DEV_STATE;
 1013ad6:	4e0f      	ldr	r6, [pc, #60]	; (1013b14 <rpmsg_virtio_send_offchannel_raw+0x170>)
 1013ad8:	e7f9      	b.n	1013ace <rpmsg_virtio_send_offchannel_raw+0x12a>
		return RPMSG_ERR_NO_BUFF;
 1013ada:	4e0f      	ldr	r6, [pc, #60]	; (1013b18 <rpmsg_virtio_send_offchannel_raw+0x174>)
 1013adc:	e7f7      	b.n	1013ace <rpmsg_virtio_send_offchannel_raw+0x12a>
	rp_hdr.src = src;
 1013ade:	9b03      	ldr	r3, [sp, #12]
	io = rvdev->shbuf_io;
 1013ae0:	f8d4 7088 	ldr.w	r7, [r4, #136]	; 0x88
	rp_hdr.src = src;
 1013ae4:	9308      	str	r3, [sp, #32]
	rp_hdr.reserved = 0;
 1013ae6:	2300      	movs	r3, #0
 1013ae8:	6839      	ldr	r1, [r7, #0]
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
 1013aea:	68b8      	ldr	r0, [r7, #8]
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
 1013aec:	1a69      	subs	r1, r5, r1
	status = metal_io_block_write(io, metal_io_virt_to_offset(io, buffer),
 1013aee:	4281      	cmp	r1, r0
 1013af0:	bf28      	it	cs
 1013af2:	f04f 31ff 	movcs.w	r1, #4294967295
	rp_hdr.reserved = 0;
 1013af6:	930a      	str	r3, [sp, #40]	; 0x28
	status = metal_io_block_write(io, metal_io_virt_to_offset(io, buffer),
 1013af8:	4638      	mov	r0, r7
 1013afa:	2310      	movs	r3, #16
 1013afc:	aa08      	add	r2, sp, #32
	rp_hdr.dst = dst;
 1013afe:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
	rp_hdr.len = size;
 1013b02:	f8ad 602c 	strh.w	r6, [sp, #44]	; 0x2c
	status = metal_io_block_write(io, metal_io_virt_to_offset(io, buffer),
 1013b06:	f003 fa54 	bl	1016fb2 <metal_io_block_write>
	RPMSG_ASSERT(status == sizeof(rp_hdr), "failed to write header\r\n");
 1013b0a:	2810      	cmp	r0, #16
 1013b0c:	d0ac      	beq.n	1013a68 <rpmsg_virtio_send_offchannel_raw+0xc4>
 1013b0e:	e7fe      	b.n	1013b0e <rpmsg_virtio_send_offchannel_raw+0x16a>
 1013b10:	fffff82b 	.word	0xfffff82b
 1013b14:	fffff82c 	.word	0xfffff82c
 1013b18:	fffff82e 	.word	0xfffff82e

01013b1c <rpmsg_init_vdev>:
int rpmsg_init_vdev(struct rpmsg_virtio_device *rvdev,
		    struct virtio_device *vdev,
		    rpmsg_ns_bind_cb ns_bind_cb,
		    struct metal_io_region *shm_io,
		    struct rpmsg_virtio_shm_pool *shpool)
{
 1013b1c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1013b20:	460d      	mov	r5, r1
 1013b22:	b088      	sub	sp, #32
 1013b24:	4617      	mov	r7, r2
	vq_callback callback[RPMSG_NUM_VRINGS];
	int status;
	unsigned int i, role;

	rdev = &rvdev->rdev;
	memset(rdev, 0, sizeof(*rdev));
 1013b26:	2100      	movs	r1, #0
 1013b28:	227c      	movs	r2, #124	; 0x7c
{
 1013b2a:	4604      	mov	r4, r0
 1013b2c:	461e      	mov	r6, r3
 1013b2e:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
	memset(rdev, 0, sizeof(*rdev));
 1013b32:	f002 ff9c 	bl	1016a6e <memset>
	return z_impl_k_sem_init(sem, initial_count, limit);
 1013b36:	2201      	movs	r2, #1
 1013b38:	f104 0058 	add.w	r0, r4, #88	; 0x58
 1013b3c:	4611      	mov	r1, r2
 1013b3e:	f004 f86e 	bl	1017c1e <z_impl_k_sem_init>
	metal_mutex_init(&rdev->lock);
	rvdev->vdev = vdev;
	rdev->ns_bind_cb = ns_bind_cb;
	vdev->priv = rvdev;
	rdev->ops.send_offchannel_raw = rpmsg_virtio_send_offchannel_raw;
 1013b42:	4b5e      	ldr	r3, [pc, #376]	; (1013cbc <rpmsg_init_vdev+0x1a0>)
	rvdev->vdev = vdev;
 1013b44:	67e5      	str	r5, [r4, #124]	; 0x7c
	rdev->ns_bind_cb = ns_bind_cb;
 1013b46:	6727      	str	r7, [r4, #112]	; 0x70
	vdev->priv = rvdev;
 1013b48:	626c      	str	r4, [r5, #36]	; 0x24
	rdev->ops.send_offchannel_raw = rpmsg_virtio_send_offchannel_raw;
 1013b4a:	6763      	str	r3, [r4, #116]	; 0x74
 1013b4c:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 1013b4e:	f8d3 8018 	ldr.w	r8, [r3, #24]
	role = rpmsg_virtio_get_role(rvdev);

#ifndef VIRTIO_MASTER_ONLY
	if (role == RPMSG_REMOTE) {
 1013b52:	f1b8 0f01 	cmp.w	r8, #1
 1013b56:	d020      	beq.n	1013b9a <rpmsg_init_vdev+0x7e>
		/* wait synchro with the master */
		rpmsg_virtio_wait_remote_ready(rvdev);
	}
#endif /*!VIRTIO_MASTER_ONLY*/
	vdev->features = rpmsg_virtio_get_features(rvdev);
 1013b58:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
}

static inline uint32_t
rpmsg_virtio_get_features(struct rpmsg_virtio_device *rvdev)
{
	return rvdev->vdev->func->get_features(rvdev->vdev);
 1013b5a:	6a03      	ldr	r3, [r0, #32]
 1013b5c:	689b      	ldr	r3, [r3, #8]
 1013b5e:	4798      	blx	r3
 1013b60:	2300      	movs	r3, #0
 1013b62:	6128      	str	r0, [r5, #16]
	rdev->support_ns = !!(vdev->features & (1 << VIRTIO_RPMSG_F_NS));
 1013b64:	f000 0001 	and.w	r0, r0, #1
	vdev->features = rpmsg_virtio_get_features(rvdev);
 1013b68:	616b      	str	r3, [r5, #20]
	rdev->support_ns = !!(vdev->features & (1 << VIRTIO_RPMSG_F_NS));
 1013b6a:	f884 0078 	strb.w	r0, [r4, #120]	; 0x78

#ifndef VIRTIO_SLAVE_ONLY
	if (role == RPMSG_MASTER) {
 1013b6e:	f1b8 0f00 	cmp.w	r8, #0
 1013b72:	d01e      	beq.n	1013bb2 <rpmsg_init_vdev+0x96>
	}
#endif /*!VIRTIO_SLAVE_ONLY*/

#ifndef VIRTIO_MASTER_ONLY
	(void)shpool;
	if (role == RPMSG_REMOTE) {
 1013b74:	f1b8 0f01 	cmp.w	r8, #1
 1013b78:	d133      	bne.n	1013be2 <rpmsg_init_vdev+0xc6>
		vq_names[0] = "tx_vq";
 1013b7a:	4b51      	ldr	r3, [pc, #324]	; (1013cc0 <rpmsg_init_vdev+0x1a4>)
 1013b7c:	9302      	str	r3, [sp, #8]
		vq_names[1] = "rx_vq";
 1013b7e:	4b51      	ldr	r3, [pc, #324]	; (1013cc4 <rpmsg_init_vdev+0x1a8>)
 1013b80:	9303      	str	r3, [sp, #12]
		callback[0] = rpmsg_virtio_tx_callback;
 1013b82:	4b51      	ldr	r3, [pc, #324]	; (1013cc8 <rpmsg_init_vdev+0x1ac>)
 1013b84:	9304      	str	r3, [sp, #16]
		callback[1] = rpmsg_virtio_rx_callback;
 1013b86:	4b51      	ldr	r3, [pc, #324]	; (1013ccc <rpmsg_init_vdev+0x1b0>)
 1013b88:	9305      	str	r3, [sp, #20]
		rvdev->rvq  = vdev->vrings_info[1].vq;
 1013b8a:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 1013b8c:	699a      	ldr	r2, [r3, #24]
		rvdev->svq  = vdev->vrings_info[0].vq;
 1013b8e:	681b      	ldr	r3, [r3, #0]
		rvdev->rvq  = vdev->vrings_info[1].vq;
 1013b90:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
		rvdev->svq  = vdev->vrings_info[0].vq;
 1013b94:	e023      	b.n	1013bde <rpmsg_init_vdev+0xc2>
		} else if (status & VIRTIO_CONFIG_STATUS_DRIVER_OK) {
 1013b96:	0743      	lsls	r3, r0, #29
 1013b98:	d4de      	bmi.n	1013b58 <rpmsg_init_vdev+0x3c>
		status = rpmsg_virtio_get_status(rvdev);
 1013b9a:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
	return rvdev->vdev->func->get_status(rvdev->vdev);
 1013b9c:	6a03      	ldr	r3, [r0, #32]
 1013b9e:	681b      	ldr	r3, [r3, #0]
 1013ba0:	4798      	blx	r3
		if (status & VIRTIO_CONFIG_STATUS_NEEDS_RESET) {
 1013ba2:	0642      	lsls	r2, r0, #25
 1013ba4:	d5f7      	bpl.n	1013b96 <rpmsg_init_vdev+0x7a>
			rpmsg_virtio_set_status(rvdev, 0);
 1013ba6:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
	rvdev->vdev->func->set_status(rvdev->vdev, status);
 1013ba8:	2100      	movs	r1, #0
 1013baa:	6a03      	ldr	r3, [r0, #32]
 1013bac:	685b      	ldr	r3, [r3, #4]
 1013bae:	4798      	blx	r3
}
 1013bb0:	e7f3      	b.n	1013b9a <rpmsg_init_vdev+0x7e>
		if (!shpool)
 1013bb2:	f1b9 0f00 	cmp.w	r9, #0
 1013bb6:	d07d      	beq.n	1013cb4 <rpmsg_init_vdev+0x198>
		if (!shpool->size)
 1013bb8:	f8d9 3008 	ldr.w	r3, [r9, #8]
 1013bbc:	2b00      	cmp	r3, #0
 1013bbe:	d07b      	beq.n	1013cb8 <rpmsg_init_vdev+0x19c>
		vq_names[0] = "rx_vq";
 1013bc0:	4b40      	ldr	r3, [pc, #256]	; (1013cc4 <rpmsg_init_vdev+0x1a8>)
		rvdev->shpool = shpool;
 1013bc2:	f8c4 908c 	str.w	r9, [r4, #140]	; 0x8c
		vq_names[0] = "rx_vq";
 1013bc6:	9302      	str	r3, [sp, #8]
		vq_names[1] = "tx_vq";
 1013bc8:	4b3d      	ldr	r3, [pc, #244]	; (1013cc0 <rpmsg_init_vdev+0x1a4>)
 1013bca:	9303      	str	r3, [sp, #12]
		callback[0] = rpmsg_virtio_rx_callback;
 1013bcc:	4b3f      	ldr	r3, [pc, #252]	; (1013ccc <rpmsg_init_vdev+0x1b0>)
 1013bce:	9304      	str	r3, [sp, #16]
		callback[1] = rpmsg_virtio_tx_callback;
 1013bd0:	4b3d      	ldr	r3, [pc, #244]	; (1013cc8 <rpmsg_init_vdev+0x1ac>)
 1013bd2:	9305      	str	r3, [sp, #20]
		rvdev->rvq  = vdev->vrings_info[0].vq;
 1013bd4:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 1013bd6:	681a      	ldr	r2, [r3, #0]
		rvdev->svq  = vdev->vrings_info[1].vq;
 1013bd8:	699b      	ldr	r3, [r3, #24]
		rvdev->rvq  = vdev->vrings_info[0].vq;
 1013bda:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
		rvdev->svq  = vdev->vrings_info[0].vq;
 1013bde:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
rpmsg_virtio_create_virtqueues(struct rpmsg_virtio_device *rvdev,
			       int flags, unsigned int nvqs,
			       const char *names[],
			       vq_callback *callbacks)
{
	return virtio_create_virtqueues(rvdev->vdev, flags, nvqs, names,
 1013be2:	ab04      	add	r3, sp, #16
 1013be4:	9300      	str	r3, [sp, #0]
 1013be6:	2202      	movs	r2, #2
 1013be8:	2100      	movs	r1, #0
 1013bea:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
	}
#endif /*!VIRTIO_MASTER_ONLY*/
	rvdev->shbuf_io = shm_io;
 1013bec:	f8c4 6088 	str.w	r6, [r4, #136]	; 0x88
 1013bf0:	ab02      	add	r3, sp, #8
 1013bf2:	f7ff fde3 	bl	10137bc <virtio_create_virtqueues>

	/* Create virtqueues for remote device */
	status = rpmsg_virtio_create_virtqueues(rvdev, 0, RPMSG_NUM_VRINGS,
						vq_names, callback);
	if (status != RPMSG_SUCCESS)
 1013bf6:	4607      	mov	r7, r0
 1013bf8:	2800      	cmp	r0, #0
 1013bfa:	d157      	bne.n	1013cac <rpmsg_init_vdev+0x190>

	/*
	 * Suppress "tx-complete" interrupts
	 * since send method use busy loop when buffer pool exhaust
	 */
	virtqueue_disable_cb(rvdev->svq);
 1013bfc:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 1013c00:	f003 fb87 	bl	1017312 <virtqueue_disable_cb>

	/* TODO: can have a virtio function to set the shared memory I/O */
	for (i = 0; i < RPMSG_NUM_VRINGS; i++) {
		struct virtqueue *vq;

		vq = vdev->vrings_info[i].vq;
 1013c04:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
		vq->shm_io = shm_io;
 1013c06:	681a      	ldr	r2, [r3, #0]
 1013c08:	699b      	ldr	r3, [r3, #24]
 1013c0a:	6296      	str	r6, [r2, #40]	; 0x28
 1013c0c:	629e      	str	r6, [r3, #40]	; 0x28
	}

#ifndef VIRTIO_SLAVE_ONLY
	if (role == RPMSG_MASTER) {
 1013c0e:	f1b8 0f00 	cmp.w	r8, #0
 1013c12:	d108      	bne.n	1013c26 <rpmsg_init_vdev+0x10a>
		struct virtqueue_buf vqbuf;
		unsigned int idx;
		void *buffer;

		vqbuf.len = RPMSG_BUFFER_SIZE;
 1013c14:	f44f 7300 	mov.w	r3, #512	; 0x200
		for (idx = 0; idx < rvdev->rvq->vq_nentries; idx++) {
 1013c18:	46c2      	mov	sl, r8
		vqbuf.len = RPMSG_BUFFER_SIZE;
 1013c1a:	9307      	str	r3, [sp, #28]
		for (idx = 0; idx < rvdev->rvq->vq_nentries; idx++) {
 1013c1c:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 1013c20:	895b      	ldrh	r3, [r3, #10]
 1013c22:	4553      	cmp	r3, sl
 1013c24:	d81f      	bhi.n	1013c66 <rpmsg_init_vdev+0x14a>

	/*
	 * Create name service announcement endpoint if device supports name
	 * service announcement feature.
	 */
	if (rdev->support_ns) {
 1013c26:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
 1013c2a:	e9c4 4400 	strd	r4, r4, [r4]
 1013c2e:	b18b      	cbz	r3, 1013c54 <rpmsg_init_vdev+0x138>
		rpmsg_init_ept(&rdev->ns_ept, "NS",
 1013c30:	f104 0508 	add.w	r5, r4, #8
	strncpy(ept->name, name ? name : "", sizeof(ept->name));
 1013c34:	4926      	ldr	r1, [pc, #152]	; (1013cd0 <rpmsg_init_vdev+0x1b4>)
 1013c36:	2220      	movs	r2, #32
 1013c38:	4628      	mov	r0, r5
 1013c3a:	f002 fea8 	bl	101698e <strncpy>
	ept->addr = src;
 1013c3e:	2335      	movs	r3, #53	; 0x35
	ept->dest_addr = dest;
 1013c40:	e9c4 330b 	strd	r3, r3, [r4, #44]	; 0x2c
	ept->cb = cb;
 1013c44:	4b23      	ldr	r3, [pc, #140]	; (1013cd4 <rpmsg_init_vdev+0x1b8>)
			       RPMSG_NS_EPT_ADDR, RPMSG_NS_EPT_ADDR,
			       rpmsg_virtio_ns_callback, NULL);
		rpmsg_register_endpoint(rdev, &rdev->ns_ept);
 1013c46:	4629      	mov	r1, r5
 1013c48:	6363      	str	r3, [r4, #52]	; 0x34
	ept->ns_unbind_cb = ns_unbind_cb;
 1013c4a:	2300      	movs	r3, #0
 1013c4c:	4620      	mov	r0, r4
 1013c4e:	63a3      	str	r3, [r4, #56]	; 0x38
 1013c50:	f003 fc46 	bl	10174e0 <rpmsg_register_endpoint>
	}

#ifndef VIRTIO_SLAVE_ONLY
	if (role == RPMSG_MASTER)
 1013c54:	f1b8 0f00 	cmp.w	r8, #0
 1013c58:	d128      	bne.n	1013cac <rpmsg_init_vdev+0x190>
		rpmsg_virtio_set_status(rvdev, VIRTIO_CONFIG_STATUS_DRIVER_OK);
 1013c5a:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
	rvdev->vdev->func->set_status(rvdev->vdev, status);
 1013c5c:	2104      	movs	r1, #4
 1013c5e:	6a03      	ldr	r3, [r0, #32]
 1013c60:	685b      	ldr	r3, [r3, #4]
 1013c62:	4798      	blx	r3
}
 1013c64:	e022      	b.n	1013cac <rpmsg_init_vdev+0x190>
			buffer = rpmsg_virtio_shm_pool_get_buffer(shpool,
 1013c66:	f44f 7100 	mov.w	r1, #512	; 0x200
 1013c6a:	4648      	mov	r0, r9
 1013c6c:	f003 fd26 	bl	10176bc <rpmsg_virtio_shm_pool_get_buffer>
			if (!buffer) {
 1013c70:	4605      	mov	r5, r0
 1013c72:	b1c8      	cbz	r0, 1013ca8 <rpmsg_init_vdev+0x18c>
 1013c74:	6831      	ldr	r1, [r6, #0]
			vqbuf.buf = buffer;
 1013c76:	9006      	str	r0, [sp, #24]
 1013c78:	1a41      	subs	r1, r0, r1
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
 1013c7a:	68b0      	ldr	r0, [r6, #8]
			metal_io_block_set(shm_io,
 1013c7c:	f44f 7300 	mov.w	r3, #512	; 0x200
 1013c80:	4281      	cmp	r1, r0
 1013c82:	bf28      	it	cs
 1013c84:	f04f 31ff 	movcs.w	r1, #4294967295
 1013c88:	2200      	movs	r2, #0
 1013c8a:	4630      	mov	r0, r6
 1013c8c:	f003 f9cc 	bl	1017028 <metal_io_block_set>
				virtqueue_add_buffer(rvdev->rvq, &vqbuf, 0, 1,
 1013c90:	2301      	movs	r3, #1
 1013c92:	2200      	movs	r2, #0
 1013c94:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 1013c98:	9500      	str	r5, [sp, #0]
 1013c9a:	a906      	add	r1, sp, #24
 1013c9c:	f003 fa4a 	bl	1017134 <virtqueue_add_buffer>
			if (status != RPMSG_SUCCESS) {
 1013ca0:	b918      	cbnz	r0, 1013caa <rpmsg_init_vdev+0x18e>
		for (idx = 0; idx < rvdev->rvq->vq_nentries; idx++) {
 1013ca2:	f10a 0a01 	add.w	sl, sl, #1
 1013ca6:	e7b9      	b.n	1013c1c <rpmsg_init_vdev+0x100>
				return RPMSG_ERR_NO_BUFF;
 1013ca8:	480b      	ldr	r0, [pc, #44]	; (1013cd8 <rpmsg_init_vdev+0x1bc>)
 1013caa:	4607      	mov	r7, r0
#endif /*!VIRTIO_SLAVE_ONLY*/

	return status;
}
 1013cac:	4638      	mov	r0, r7
 1013cae:	b008      	add	sp, #32
 1013cb0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			return RPMSG_ERR_PARAM;
 1013cb4:	4f09      	ldr	r7, [pc, #36]	; (1013cdc <rpmsg_init_vdev+0x1c0>)
 1013cb6:	e7f9      	b.n	1013cac <rpmsg_init_vdev+0x190>
			return RPMSG_ERR_NO_BUFF;
 1013cb8:	4f07      	ldr	r7, [pc, #28]	; (1013cd8 <rpmsg_init_vdev+0x1bc>)
 1013cba:	e7f7      	b.n	1013cac <rpmsg_init_vdev+0x190>
 1013cbc:	010139a5 	.word	0x010139a5
 1013cc0:	01019ae4 	.word	0x01019ae4
 1013cc4:	01019ade 	.word	0x01019ade
 1013cc8:	0101752d 	.word	0x0101752d
 1013ccc:	010175fd 	.word	0x010175fd
 1013cd0:	01019aea 	.word	0x01019aea
 1013cd4:	0101756b 	.word	0x0101756b
 1013cd8:	fffff82e 	.word	0xfffff82e
 1013cdc:	fffff82d 	.word	0xfffff82d

01013ce0 <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(s32_t level)
{
 1013ce0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
			if (dev) {
				/* Initialization failed. Clear the API struct
				 * so that device_get_binding() will not succeed
				 * for it.
				 */
				dev->driver_api = NULL;
 1013ce2:	2700      	movs	r7, #0
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 1013ce4:	4b08      	ldr	r3, [pc, #32]	; (1013d08 <z_sys_init_run_level+0x28>)
 1013ce6:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
 1013cea:	3001      	adds	r0, #1
 1013cec:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
 1013cf0:	42a6      	cmp	r6, r4
 1013cf2:	d800      	bhi.n	1013cf6 <z_sys_init_run_level+0x16>
			}
		}
	}
}
 1013cf4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		retval = entry->init(dev);
 1013cf6:	e9d4 3500 	ldrd	r3, r5, [r4]
 1013cfa:	4628      	mov	r0, r5
 1013cfc:	4798      	blx	r3
		if (retval != 0) {
 1013cfe:	b108      	cbz	r0, 1013d04 <z_sys_init_run_level+0x24>
			if (dev) {
 1013d00:	b105      	cbz	r5, 1013d04 <z_sys_init_run_level+0x24>
				dev->driver_api = NULL;
 1013d02:	60af      	str	r7, [r5, #8]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 1013d04:	3408      	adds	r4, #8
 1013d06:	e7f3      	b.n	1013cf0 <z_sys_init_run_level+0x10>
 1013d08:	01018f7c 	.word	0x01018f7c

01013d0c <z_impl_device_get_binding>:
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed. Reserve string comparisons for a fallback.
	 */
	for (dev = __device_start; dev != __device_end; dev++) {
 1013d0c:	4b0f      	ldr	r3, [pc, #60]	; (1013d4c <z_impl_device_get_binding+0x40>)
{
 1013d0e:	b570      	push	{r4, r5, r6, lr}
 1013d10:	4605      	mov	r5, r0
 1013d12:	461e      	mov	r6, r3
	for (dev = __device_start; dev != __device_end; dev++) {
 1013d14:	4c0e      	ldr	r4, [pc, #56]	; (1013d50 <z_impl_device_get_binding+0x44>)
 1013d16:	429c      	cmp	r4, r3
 1013d18:	d104      	bne.n	1013d24 <z_impl_device_get_binding+0x18>
		    (dev->name == name)) {
			return dev;
		}
	}

	for (dev = __device_start; dev != __device_end; dev++) {
 1013d1a:	4c0d      	ldr	r4, [pc, #52]	; (1013d50 <z_impl_device_get_binding+0x44>)
 1013d1c:	42b4      	cmp	r4, r6
 1013d1e:	d108      	bne.n	1013d32 <z_impl_device_get_binding+0x26>
		    (strcmp(name, dev->name) == 0)) {
			return dev;
		}
	}

	return NULL;
 1013d20:	2400      	movs	r4, #0
 1013d22:	e010      	b.n	1013d46 <z_impl_device_get_binding+0x3a>
		if ((dev->driver_api != NULL) &&
 1013d24:	68a2      	ldr	r2, [r4, #8]
 1013d26:	b112      	cbz	r2, 1013d2e <z_impl_device_get_binding+0x22>
 1013d28:	6822      	ldr	r2, [r4, #0]
 1013d2a:	42aa      	cmp	r2, r5
 1013d2c:	d00b      	beq.n	1013d46 <z_impl_device_get_binding+0x3a>
	for (dev = __device_start; dev != __device_end; dev++) {
 1013d2e:	3410      	adds	r4, #16
 1013d30:	e7f1      	b.n	1013d16 <z_impl_device_get_binding+0xa>
		if ((dev->driver_api != NULL) &&
 1013d32:	68a3      	ldr	r3, [r4, #8]
 1013d34:	b90b      	cbnz	r3, 1013d3a <z_impl_device_get_binding+0x2e>
	for (dev = __device_start; dev != __device_end; dev++) {
 1013d36:	3410      	adds	r4, #16
 1013d38:	e7f0      	b.n	1013d1c <z_impl_device_get_binding+0x10>
		    (strcmp(name, dev->name) == 0)) {
 1013d3a:	4628      	mov	r0, r5
 1013d3c:	6821      	ldr	r1, [r4, #0]
 1013d3e:	f002 fe40 	bl	10169c2 <strcmp>
		if ((dev->driver_api != NULL) &&
 1013d42:	2800      	cmp	r0, #0
 1013d44:	d1f7      	bne.n	1013d36 <z_impl_device_get_binding+0x2a>
}
 1013d46:	4620      	mov	r0, r4
 1013d48:	bd70      	pop	{r4, r5, r6, pc}
 1013d4a:	bf00      	nop
 1013d4c:	21000584 	.word	0x21000584
 1013d50:	21000504 	.word	0x21000504

01013d54 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
 1013d54:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 1013d58:	4605      	mov	r5, r0
 1013d5a:	460f      	mov	r7, r1
	__asm__ volatile(
 1013d5c:	f04f 0320 	mov.w	r3, #32
 1013d60:	f3ef 8811 	mrs	r8, BASEPRI
 1013d64:	f383 8811 	msr	BASEPRI, r3
 1013d68:	f3bf 8f6f 	isb	sy
	return z_impl_k_current_get();
 1013d6c:	f000 fd16 	bl	101479c <z_impl_k_current_get>
 1013d70:	4c22      	ldr	r4, [pc, #136]	; (1013dfc <z_fatal_error+0xa8>)
 1013d72:	4b23      	ldr	r3, [pc, #140]	; (1013e00 <z_fatal_error+0xac>)
 1013d74:	2d04      	cmp	r5, #4
 1013d76:	eba4 0403 	sub.w	r4, r4, r3
 1013d7a:	ea4f 04d4 	mov.w	r4, r4, lsr #3
 1013d7e:	bf98      	it	ls
 1013d80:	4a20      	ldrls	r2, [pc, #128]	; (1013e04 <z_fatal_error+0xb0>)
	struct k_thread *thread = k_current_get();

	/* sanitycheck looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating sanitycheck
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
 1013d82:	ea4f 1484 	mov.w	r4, r4, lsl #6
 1013d86:	f044 0301 	orr.w	r3, r4, #1
 1013d8a:	4606      	mov	r6, r0
	switch (reason) {
 1013d8c:	bf94      	ite	ls
 1013d8e:	f852 2025 	ldrls.w	r2, [r2, r5, lsl #2]
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
 1013d92:	4a1d      	ldrhi	r2, [pc, #116]	; (1013e08 <z_fatal_error+0xb4>)
 1013d94:	f8ad 3000 	strh.w	r3, [sp]
 1013d98:	4629      	mov	r1, r5
 1013d9a:	2300      	movs	r3, #0
 1013d9c:	481b      	ldr	r0, [pc, #108]	; (1013e0c <z_fatal_error+0xb8>)
 1013d9e:	f001 fbe0 	bl	1015562 <log_3>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 1013da2:	b147      	cbz	r7, 1013db6 <z_fatal_error+0x62>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
 1013da4:	69fb      	ldr	r3, [r7, #28]
 1013da6:	f3c3 0308 	ubfx	r3, r3, #0, #9
 1013daa:	b123      	cbz	r3, 1013db6 <z_fatal_error+0x62>
		LOG_ERR("Fault during interrupt handling\n");
 1013dac:	4818      	ldr	r0, [pc, #96]	; (1013e10 <z_fatal_error+0xbc>)
 1013dae:	f044 0101 	orr.w	r1, r4, #1
 1013db2:	f001 fb9c 	bl	10154ee <log_0>
	const char *thread_name = k_thread_name_get(thread);
 1013db6:	4630      	mov	r0, r6
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
 1013db8:	f044 0401 	orr.w	r4, r4, #1
	const char *thread_name = k_thread_name_get(thread);
 1013dbc:	f003 ff4a 	bl	1017c54 <k_thread_name_get>
	if (thread_name == NULL || thread_name[0] == '\0') {
 1013dc0:	b1d0      	cbz	r0, 1013df8 <z_fatal_error+0xa4>
 1013dc2:	7802      	ldrb	r2, [r0, #0]
		thread_name = "unknown";
 1013dc4:	4b13      	ldr	r3, [pc, #76]	; (1013e14 <z_fatal_error+0xc0>)
 1013dc6:	2a00      	cmp	r2, #0
 1013dc8:	bf08      	it	eq
 1013dca:	4618      	moveq	r0, r3
	LOG_ERR("Current thread: %p (%s)", thread,
 1013dcc:	f7f0 f8d0 	bl	1003f70 <log_strdup>
 1013dd0:	4623      	mov	r3, r4
 1013dd2:	4602      	mov	r2, r0
 1013dd4:	4631      	mov	r1, r6
 1013dd6:	4810      	ldr	r0, [pc, #64]	; (1013e18 <z_fatal_error+0xc4>)
 1013dd8:	f001 fbaa 	bl	1015530 <log_2>
		log_strdup(thread_name_get(thread)));

	k_sys_fatal_error_handler(reason, esf);
 1013ddc:	4639      	mov	r1, r7
 1013dde:	4628      	mov	r0, r5
 1013de0:	f7ff fb56 	bl	1013490 <k_sys_fatal_error_handler>
	__asm__ volatile(
 1013de4:	f388 8811 	msr	BASEPRI, r8
 1013de8:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
 1013dec:	4630      	mov	r0, r6
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	arch_irq_unlock(key);
	k_thread_abort(thread);
}
 1013dee:	b002      	add	sp, #8
 1013df0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 1013df4:	f7f1 bb62 	b.w	10054bc <z_impl_k_thread_abort>
		thread_name = "unknown";
 1013df8:	4806      	ldr	r0, [pc, #24]	; (1013e14 <z_fatal_error+0xc0>)
 1013dfa:	e7e7      	b.n	1013dcc <z_fatal_error+0x78>
 1013dfc:	01018310 	.word	0x01018310
 1013e00:	01018208 	.word	0x01018208
 1013e04:	01018f94 	.word	0x01018f94
 1013e08:	01019aed 	.word	0x01019aed
 1013e0c:	01019b03 	.word	0x01019b03
 1013e10:	01019b2b 	.word	0x01019b2b
 1013e14:	01019afb 	.word	0x01019afb
 1013e18:	01019b4c 	.word	0x01019b4c

01013e1c <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
 1013e1c:	b508      	push	{r3, lr}
	_kernel.idle = ticks;
 1013e1e:	4d0b      	ldr	r5, [pc, #44]	; (1013e4c <idle+0x30>)
	__asm__ volatile(
 1013e20:	f04f 0220 	mov.w	r2, #32
 1013e24:	f3ef 8311 	mrs	r3, BASEPRI
 1013e28:	f382 8811 	msr	BASEPRI, r2
 1013e2c:	f3bf 8f6f 	isb	sy
	s32_t ticks = z_get_next_timeout_expiry();
 1013e30:	f003 ffa1 	bl	1017d76 <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
 1013e34:	2101      	movs	r1, #1
	s32_t ticks = z_get_next_timeout_expiry();
 1013e36:	4604      	mov	r4, r0
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
 1013e38:	2802      	cmp	r0, #2
 1013e3a:	bfd8      	it	le
 1013e3c:	4608      	movle	r0, r1
 1013e3e:	f003 ffaa 	bl	1017d96 <z_set_timeout_expiry>
	_kernel.idle = ticks;
 1013e42:	622c      	str	r4, [r5, #32]
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
 1013e44:	f7f1 f874 	bl	1004f30 <arch_cpu_idle>
}
 1013e48:	e7ea      	b.n	1013e20 <idle+0x4>
 1013e4a:	bf00      	nop
 1013e4c:	21007f8c 	.word	0x21007f8c

01013e50 <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
 1013e50:	4802      	ldr	r0, [pc, #8]	; (1013e5c <z_bss_zero+0xc>)
 1013e52:	4a03      	ldr	r2, [pc, #12]	; (1013e60 <z_bss_zero+0x10>)
 1013e54:	2100      	movs	r1, #0
 1013e56:	1a12      	subs	r2, r2, r0
 1013e58:	f002 be09 	b.w	1016a6e <memset>
 1013e5c:	210006b8 	.word	0x210006b8
 1013e60:	210080d4 	.word	0x210080d4

01013e64 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
 1013e64:	b508      	push	{r3, lr}
	(void)memcpy(&__data_ram_start, &__data_rom_start,
		 __data_ram_end - __data_ram_start);
 1013e66:	4806      	ldr	r0, [pc, #24]	; (1013e80 <z_data_copy+0x1c>)
	(void)memcpy(&__data_ram_start, &__data_rom_start,
 1013e68:	4a06      	ldr	r2, [pc, #24]	; (1013e84 <z_data_copy+0x20>)
 1013e6a:	4907      	ldr	r1, [pc, #28]	; (1013e88 <z_data_copy+0x24>)
 1013e6c:	1a12      	subs	r2, r2, r0
 1013e6e:	f002 fdd3 	bl	1016a18 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
 1013e72:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
 1013e76:	4a05      	ldr	r2, [pc, #20]	; (1013e8c <z_data_copy+0x28>)
 1013e78:	4905      	ldr	r1, [pc, #20]	; (1013e90 <z_data_copy+0x2c>)
 1013e7a:	4806      	ldr	r0, [pc, #24]	; (1013e94 <z_data_copy+0x30>)
 1013e7c:	f002 bdcc 	b.w	1016a18 <memcpy>
 1013e80:	21000000 	.word	0x21000000
 1013e84:	210006b4 	.word	0x210006b4
 1013e88:	01019c00 	.word	0x01019c00
 1013e8c:	00000000 	.word	0x00000000
 1013e90:	01019c00 	.word	0x01019c00
 1013e94:	21000000 	.word	0x21000000

01013e98 <bg_thread_main>:
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_post_kernel = true;
 1013e98:	2201      	movs	r2, #1
{
 1013e9a:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
 1013e9c:	4b0b      	ldr	r3, [pc, #44]	; (1013ecc <bg_thread_main+0x34>)

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
 1013e9e:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
 1013ea0:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
 1013ea2:	f7ff ff1d 	bl	1013ce0 <z_sys_init_run_level>
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
 1013ea6:	4a0a      	ldr	r2, [pc, #40]	; (1013ed0 <bg_thread_main+0x38>)
 1013ea8:	490a      	ldr	r1, [pc, #40]	; (1013ed4 <bg_thread_main+0x3c>)
 1013eaa:	480b      	ldr	r0, [pc, #44]	; (1013ed8 <bg_thread_main+0x40>)
 1013eac:	f001 f843 	bl	1014f36 <printk>
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
 1013eb0:	2003      	movs	r0, #3
 1013eb2:	f7ff ff15 	bl	1013ce0 <z_sys_init_run_level>

	z_init_static_threads();
 1013eb6:	f000 fd31 	bl	101491c <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
 1013eba:	f7ef fbf3 	bl	10036a4 <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
 1013ebe:	4a07      	ldr	r2, [pc, #28]	; (1013edc <bg_thread_main+0x44>)
 1013ec0:	7b13      	ldrb	r3, [r2, #12]
 1013ec2:	f023 0301 	bic.w	r3, r3, #1
 1013ec6:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
 1013ec8:	bd08      	pop	{r3, pc}
 1013eca:	bf00      	nop
 1013ecc:	210080d0 	.word	0x210080d0
 1013ed0:	01019365 	.word	0x01019365
 1013ed4:	01019bae 	.word	0x01019bae
 1013ed8:	01019bbe 	.word	0x01019bbe
 1013edc:	21005ab8 	.word	0x21005ab8

01013ee0 <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
 1013ee0:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 1013ee4:	b0a5      	sub	sp, #148	; 0x94
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
 1013ee6:	f7ef ffa7 	bl	1003e38 <log_core_init>
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	u32_t msp = (u32_t)(Z_THREAD_STACK_BUFFER(z_interrupt_stacks[0])) +
 1013eea:	f8df 90ec 	ldr.w	r9, [pc, #236]	; 1013fd8 <z_cstart+0xf8>
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 1013eee:	f389 8808 	msr	MSP, r9
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1013ef2:	2400      	movs	r4, #0
 1013ef4:	23e0      	movs	r3, #224	; 0xe0
 1013ef6:	4d31      	ldr	r5, [pc, #196]	; (1013fbc <z_cstart+0xdc>)
	z_setup_new_thread(&z_main_thread, z_main_stack,
 1013ef8:	f04f 0b01 	mov.w	fp, #1
 1013efc:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
 1013f00:	77ec      	strb	r4, [r5, #31]
 1013f02:	762c      	strb	r4, [r5, #24]
 1013f04:	766c      	strb	r4, [r5, #25]
 1013f06:	76ac      	strb	r4, [r5, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
 1013f08:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	_kernel.ready_q.cache = &z_main_thread;
 1013f0a:	4e2d      	ldr	r6, [pc, #180]	; (1013fc0 <z_cstart+0xe0>)
 1013f0c:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
 1013f10:	626b      	str	r3, [r5, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
 1013f12:	f7f1 fa9f 	bl	1005454 <z_arm_fault_init>
	z_arm_cpu_idle_init();
 1013f16:	f7f1 f805 	bl	1004f24 <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
 1013f1a:	f04f 33ff 	mov.w	r3, #4294967295
 1013f1e:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
 1013f20:	62eb      	str	r3, [r5, #44]	; 0x2c
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
 1013f22:	f240 1301 	movw	r3, #257	; 0x101
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = 0;
#endif

	_current_cpu->current = dummy_thread;
 1013f26:	4d27      	ldr	r5, [pc, #156]	; (1013fc4 <z_cstart+0xe4>)
	dummy_thread->base.user_options = K_ESSENTIAL;
 1013f28:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
	_current_cpu->current = dummy_thread;
 1013f2c:	ab07      	add	r3, sp, #28
 1013f2e:	60ab      	str	r3, [r5, #8]

	z_dummy_thread_init(&dummy_thread);
#endif

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
 1013f30:	4620      	mov	r0, r4
	dummy_thread->stack_info.size = 0U;
 1013f32:	e9cd 441f 	strd	r4, r4, [sp, #124]	; 0x7c
 1013f36:	f7ff fed3 	bl	1013ce0 <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
 1013f3a:	2001      	movs	r0, #1
 1013f3c:	f7ff fed0 	bl	1013ce0 <z_sys_init_run_level>
	z_setup_new_thread(&z_main_thread, z_main_stack,
 1013f40:	f8df a098 	ldr.w	sl, [pc, #152]	; 1013fdc <z_cstart+0xfc>
	z_sched_init();
 1013f44:	f000 fbb2 	bl	10146ac <z_sched_init>
	z_setup_new_thread(&z_main_thread, z_main_stack,
 1013f48:	f8df 8094 	ldr.w	r8, [pc, #148]	; 1013fe0 <z_cstart+0x100>
 1013f4c:	4b1e      	ldr	r3, [pc, #120]	; (1013fc8 <z_cstart+0xe8>)
	_kernel.ready_q.cache = &z_main_thread;
 1013f4e:	626e      	str	r6, [r5, #36]	; 0x24
	z_setup_new_thread(&z_main_thread, z_main_stack,
 1013f50:	f44f 6200 	mov.w	r2, #2048	; 0x800
 1013f54:	4641      	mov	r1, r8
 1013f56:	4630      	mov	r0, r6
 1013f58:	9305      	str	r3, [sp, #20]
 1013f5a:	e9cd 4b03 	strd	r4, fp, [sp, #12]
 1013f5e:	4653      	mov	r3, sl
 1013f60:	e9cd 4401 	strd	r4, r4, [sp, #4]
 1013f64:	9400      	str	r4, [sp, #0]
 1013f66:	f000 fc87 	bl	1014878 <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
 1013f6a:	7b73      	ldrb	r3, [r6, #13]
	z_ready_thread(&z_main_thread);
 1013f6c:	4630      	mov	r0, r6
 1013f6e:	f023 0304 	bic.w	r3, r3, #4
 1013f72:	7373      	strb	r3, [r6, #13]
 1013f74:	f003 fda3 	bl	1017abe <z_ready_thread>
	z_setup_new_thread(thread, stack,
 1013f78:	230f      	movs	r3, #15
 1013f7a:	4f14      	ldr	r7, [pc, #80]	; (1013fcc <z_cstart+0xec>)
 1013f7c:	f44f 7280 	mov.w	r2, #256	; 0x100
 1013f80:	4638      	mov	r0, r7
 1013f82:	e9cd 4302 	strd	r4, r3, [sp, #8]
 1013f86:	4912      	ldr	r1, [pc, #72]	; (1013fd0 <z_cstart+0xf0>)
 1013f88:	4b12      	ldr	r3, [pc, #72]	; (1013fd4 <z_cstart+0xf4>)
 1013f8a:	e9cd b404 	strd	fp, r4, [sp, #16]
 1013f8e:	e9cd 4400 	strd	r4, r4, [sp]
 1013f92:	f000 fc71 	bl	1014878 <z_setup_new_thread>
 1013f96:	7b7b      	ldrb	r3, [r7, #13]
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
 1013f98:	f44f 6200 	mov.w	r2, #2048	; 0x800
 1013f9c:	f023 0304 	bic.w	r3, r3, #4
 1013fa0:	737b      	strb	r3, [r7, #13]
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
 1013fa2:	f105 0318 	add.w	r3, r5, #24
	list->tail = (sys_dnode_t *)list;
 1013fa6:	e9c5 3306 	strd	r3, r3, [r5, #24]
 1013faa:	4641      	mov	r1, r8
 1013fac:	4653      	mov	r3, sl
 1013fae:	4630      	mov	r0, r6
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
 1013fb0:	60ef      	str	r7, [r5, #12]
		_kernel.cpus[i].id = i;
 1013fb2:	752c      	strb	r4, [r5, #20]
		_kernel.cpus[i].irq_stack =
 1013fb4:	f8c5 9004 	str.w	r9, [r5, #4]
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
 1013fb8:	f7f0 ff98 	bl	1004eec <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
 1013fbc:	e000ed00 	.word	0xe000ed00
 1013fc0:	21005ab8 	.word	0x21005ab8
 1013fc4:	21007f8c 	.word	0x21007f8c
 1013fc8:	01019be5 	.word	0x01019be5
 1013fcc:	21005a44 	.word	0x21005a44
 1013fd0:	210097e8 	.word	0x210097e8
 1013fd4:	01013e1d 	.word	0x01013e1d
 1013fd8:	2100a0e8 	.word	0x2100a0e8
 1013fdc:	01013e99 	.word	0x01013e99
 1013fe0:	21008fe8 	.word	0x21008fe8

01013fe4 <statics_init>:
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
}

static int statics_init(struct device *unused)
{
 1013fe4:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
 1013fe6:	4c06      	ldr	r4, [pc, #24]	; (1014000 <statics_init+0x1c>)
 1013fe8:	4d06      	ldr	r5, [pc, #24]	; (1014004 <statics_init+0x20>)
 1013fea:	42ac      	cmp	r4, r5
 1013fec:	d301      	bcc.n	1013ff2 <statics_init+0xe>
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
	}
	return 0;
}
 1013fee:	2000      	movs	r0, #0
 1013ff0:	bd38      	pop	{r3, r4, r5, pc}
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
 1013ff2:	4620      	mov	r0, r4
 1013ff4:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
 1013ff8:	f003 fb70 	bl	10176dc <k_heap_init>
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
 1013ffc:	3414      	adds	r4, #20
 1013ffe:	e7f4      	b.n	1013fea <statics_init+0x6>
 1014000:	21000584 	.word	0x21000584
 1014004:	21000598 	.word	0x21000598

01014008 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(struct device *dev)
{
 1014008:	b570      	push	{r4, r5, r6, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
 101400a:	4b0e      	ldr	r3, [pc, #56]	; (1014044 <init_mem_slab_module+0x3c>)
 101400c:	4c0e      	ldr	r4, [pc, #56]	; (1014048 <init_mem_slab_module+0x40>)
 101400e:	42a3      	cmp	r3, r4
 1014010:	d301      	bcc.n	1014016 <init_mem_slab_module+0xe>
		}
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}

out:
 1014012:	2000      	movs	r0, #0
	return rc;
}
 1014014:	bd70      	pop	{r4, r5, r6, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
 1014016:	e9d3 0103 	ldrd	r0, r1, [r3, #12]
 101401a:	ea41 0200 	orr.w	r2, r1, r0
 101401e:	f012 0203 	ands.w	r2, r2, #3
 1014022:	d10b      	bne.n	101403c <init_mem_slab_module+0x34>
	for (j = 0U; j < slab->num_blocks; j++) {
 1014024:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
 1014026:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
 1014028:	42aa      	cmp	r2, r5
 101402a:	d101      	bne.n	1014030 <init_mem_slab_module+0x28>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
 101402c:	331c      	adds	r3, #28
 101402e:	e7ee      	b.n	101400e <init_mem_slab_module+0x6>
		*(char **)p = slab->free_list;
 1014030:	695e      	ldr	r6, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
 1014032:	3201      	adds	r2, #1
		*(char **)p = slab->free_list;
 1014034:	600e      	str	r6, [r1, #0]
		slab->free_list = p;
 1014036:	6159      	str	r1, [r3, #20]
		p += slab->block_size;
 1014038:	4401      	add	r1, r0
	for (j = 0U; j < slab->num_blocks; j++) {
 101403a:	e7f5      	b.n	1014028 <init_mem_slab_module+0x20>
		return -EINVAL;
 101403c:	f06f 0015 	mvn.w	r0, #21
	return rc;
 1014040:	e7e8      	b.n	1014014 <init_mem_slab_module+0xc>
 1014042:	bf00      	nop
 1014044:	21000584 	.word	0x21000584
 1014048:	21000584 	.word	0x21000584

0101404c <k_mem_slab_alloc>:
out:
	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
 101404c:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
 101404e:	460c      	mov	r4, r1
 1014050:	4616      	mov	r6, r2
 1014052:	461f      	mov	r7, r3
 1014054:	f04f 0320 	mov.w	r3, #32
 1014058:	f3ef 8111 	mrs	r1, BASEPRI
 101405c:	f383 8811 	msr	BASEPRI, r3
 1014060:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
 1014064:	6943      	ldr	r3, [r0, #20]
 1014066:	b15b      	cbz	r3, 1014080 <k_mem_slab_alloc+0x34>
		/* take a free block */
		*mem = slab->free_list;
 1014068:	6023      	str	r3, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
 101406a:	681b      	ldr	r3, [r3, #0]
 101406c:	6143      	str	r3, [r0, #20]
		slab->num_used++;
 101406e:	6983      	ldr	r3, [r0, #24]
 1014070:	3301      	adds	r3, #1
 1014072:	6183      	str	r3, [r0, #24]
		result = 0;
 1014074:	2000      	movs	r0, #0
	__asm__ volatile(
 1014076:	f381 8811 	msr	BASEPRI, r1
 101407a:	f3bf 8f6f 	isb	sy
		return result;
	}

	k_spin_unlock(&lock, key);

	return result;
 101407e:	e011      	b.n	10140a4 <k_mem_slab_alloc+0x58>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 1014080:	ea56 0207 	orrs.w	r2, r6, r7
 1014084:	d103      	bne.n	101408e <k_mem_slab_alloc+0x42>
		result = -ENOMEM;
 1014086:	f06f 000b 	mvn.w	r0, #11
		*mem = NULL;
 101408a:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
 101408c:	e7f3      	b.n	1014076 <k_mem_slab_alloc+0x2a>
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
 101408e:	4602      	mov	r2, r0
 1014090:	e9cd 6700 	strd	r6, r7, [sp]
 1014094:	4804      	ldr	r0, [pc, #16]	; (10140a8 <k_mem_slab_alloc+0x5c>)
 1014096:	f000 faf5 	bl	1014684 <z_pend_curr>
		if (result == 0) {
 101409a:	b918      	cbnz	r0, 10140a4 <k_mem_slab_alloc+0x58>
			*mem = _current->base.swap_data;
 101409c:	4b03      	ldr	r3, [pc, #12]	; (10140ac <k_mem_slab_alloc+0x60>)
 101409e:	689b      	ldr	r3, [r3, #8]
 10140a0:	695b      	ldr	r3, [r3, #20]
 10140a2:	6023      	str	r3, [r4, #0]
}
 10140a4:	b002      	add	sp, #8
 10140a6:	bdd0      	pop	{r4, r6, r7, pc}
 10140a8:	210080d1 	.word	0x210080d1
 10140ac:	21007f8c 	.word	0x21007f8c

010140b0 <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
 10140b0:	b570      	push	{r4, r5, r6, lr}
 10140b2:	4604      	mov	r4, r0
 10140b4:	460d      	mov	r5, r1
	__asm__ volatile(
 10140b6:	f04f 0320 	mov.w	r3, #32
 10140ba:	f3ef 8611 	mrs	r6, BASEPRI
 10140be:	f383 8811 	msr	BASEPRI, r3
 10140c2:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
 10140c6:	f003 fd6d 	bl	1017ba4 <z_unpend_first_thread>

	if (pending_thread != NULL) {
 10140ca:	b158      	cbz	r0, 10140e4 <k_mem_slab_free+0x34>
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
 10140cc:	2100      	movs	r1, #0
		z_thread_return_value_set_with_data(pending_thread, 0, *mem);
 10140ce:	682a      	ldr	r2, [r5, #0]
 10140d0:	6701      	str	r1, [r0, #112]	; 0x70
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
 10140d2:	6142      	str	r2, [r0, #20]
		z_ready_thread(pending_thread);
 10140d4:	f003 fcf3 	bl	1017abe <z_ready_thread>
		z_reschedule(&lock, key);
 10140d8:	4631      	mov	r1, r6
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
 10140da:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
 10140de:	4808      	ldr	r0, [pc, #32]	; (1014100 <k_mem_slab_free+0x50>)
 10140e0:	f003 bca9 	b.w	1017a36 <z_reschedule>
		**(char ***)mem = slab->free_list;
 10140e4:	682b      	ldr	r3, [r5, #0]
 10140e6:	6962      	ldr	r2, [r4, #20]
 10140e8:	601a      	str	r2, [r3, #0]
		slab->free_list = *(char **)mem;
 10140ea:	682b      	ldr	r3, [r5, #0]
 10140ec:	6163      	str	r3, [r4, #20]
		slab->num_used--;
 10140ee:	69a3      	ldr	r3, [r4, #24]
 10140f0:	3b01      	subs	r3, #1
 10140f2:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
 10140f4:	f386 8811 	msr	BASEPRI, r6
 10140f8:	f3bf 8f6f 	isb	sy
}
 10140fc:	bd70      	pop	{r4, r5, r6, pc}
 10140fe:	bf00      	nop
 1014100:	210080d1 	.word	0x210080d1

01014104 <k_malloc>:
K_MEM_POOL_DEFINE(_heap_mem_pool, CONFIG_HEAP_MEM_POOL_MIN_SIZE,
		  CONFIG_HEAP_MEM_POOL_SIZE, 1, 4);
#define _HEAP_MEM_POOL (&_heap_mem_pool)

void *k_malloc(size_t size)
{
 1014104:	4601      	mov	r1, r0
	return k_mem_pool_malloc(_HEAP_MEM_POOL, size);
 1014106:	4801      	ldr	r0, [pc, #4]	; (101410c <k_malloc+0x8>)
 1014108:	f003 bb88 	b.w	101781c <k_mem_pool_malloc>
 101410c:	210004f4 	.word	0x210004f4

01014110 <z_thread_malloc>:
#else
#define _HEAP_MEM_POOL	NULL
#endif

void *z_thread_malloc(size_t size)
{
 1014110:	b510      	push	{r4, lr}
 1014112:	4604      	mov	r4, r0
	void *ret;
	struct k_mem_pool *pool;

	if (k_is_in_isr()) {
 1014114:	f003 fd93 	bl	1017c3e <k_is_in_isr>
 1014118:	b948      	cbnz	r0, 101412e <z_thread_malloc+0x1e>
		pool = _HEAP_MEM_POOL;
	} else {
		pool = _current->resource_pool;
 101411a:	4b06      	ldr	r3, [pc, #24]	; (1014134 <z_thread_malloc+0x24>)
 101411c:	689b      	ldr	r3, [r3, #8]
 101411e:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	}

	if (pool) {
 1014120:	b13b      	cbz	r3, 1014132 <z_thread_malloc+0x22>
		ret = k_mem_pool_malloc(pool, size);
 1014122:	4621      	mov	r1, r4
	} else {
		ret = NULL;
	}

	return ret;
}
 1014124:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ret = k_mem_pool_malloc(pool, size);
 1014128:	4618      	mov	r0, r3
 101412a:	f003 bb77 	b.w	101781c <k_mem_pool_malloc>
		pool = _HEAP_MEM_POOL;
 101412e:	4b02      	ldr	r3, [pc, #8]	; (1014138 <z_thread_malloc+0x28>)
 1014130:	e7f7      	b.n	1014122 <z_thread_malloc+0x12>
}
 1014132:	bd10      	pop	{r4, pc}
 1014134:	21007f8c 	.word	0x21007f8c
 1014138:	210004f4 	.word	0x210004f4

0101413c <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
 101413c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 101413e:	4616      	mov	r6, r2
 1014140:	461f      	mov	r7, r3
	__asm__ volatile(
 1014142:	f04f 0320 	mov.w	r3, #32
 1014146:	f3ef 8511 	mrs	r5, BASEPRI
 101414a:	f383 8811 	msr	BASEPRI, r3
 101414e:	f3bf 8f6f 	isb	sy
 *
 * @return a boolean, true if it's empty, false otherwise
 */
static inline bool sys_sflist_is_empty(sys_sflist_t *list);

Z_GENLIST_IS_EMPTY(sflist)
 1014152:	6804      	ldr	r4, [r0, #0]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
 1014154:	b19c      	cbz	r4, 101417e <z_impl_k_queue_get+0x42>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
 1014156:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
 1014158:	6842      	ldr	r2, [r0, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
 101415a:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
 101415e:	4294      	cmp	r4, r2
	list->head = node;
 1014160:	6003      	str	r3, [r0, #0]
	list->tail = node;
 1014162:	bf08      	it	eq
 1014164:	6043      	streq	r3, [r0, #4]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
 1014166:	2101      	movs	r1, #1
 1014168:	4620      	mov	r0, r4
 101416a:	f003 fbd4 	bl	1017916 <z_queue_node_peek>
 101416e:	4604      	mov	r4, r0
	__asm__ volatile(
 1014170:	f385 8811 	msr	BASEPRI, r5
 1014174:	f3bf 8f6f 	isb	sy
	}

	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);

	return (ret != 0) ? NULL : _current->base.swap_data;
}
 1014178:	4620      	mov	r0, r4
 101417a:	b003      	add	sp, #12
 101417c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 101417e:	ea56 0307 	orrs.w	r3, r6, r7
 1014182:	d0f5      	beq.n	1014170 <z_impl_k_queue_get+0x34>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
 1014184:	f100 0208 	add.w	r2, r0, #8
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
 1014188:	4629      	mov	r1, r5
 101418a:	4610      	mov	r0, r2
 101418c:	e9cd 6700 	strd	r6, r7, [sp]
 1014190:	f000 fa78 	bl	1014684 <z_pend_curr>
	return (ret != 0) ? NULL : _current->base.swap_data;
 1014194:	2800      	cmp	r0, #0
 1014196:	d1ef      	bne.n	1014178 <z_impl_k_queue_get+0x3c>
 1014198:	4b01      	ldr	r3, [pc, #4]	; (10141a0 <z_impl_k_queue_get+0x64>)
 101419a:	689b      	ldr	r3, [r3, #8]
 101419c:	695c      	ldr	r4, [r3, #20]
 101419e:	e7eb      	b.n	1014178 <z_impl_k_queue_get+0x3c>
 10141a0:	21007f8c 	.word	0x21007f8c

010141a4 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
 10141a4:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
 10141a6:	4c08      	ldr	r4, [pc, #32]	; (10141c8 <z_reset_time_slice+0x24>)
 10141a8:	6823      	ldr	r3, [r4, #0]
 10141aa:	b15b      	cbz	r3, 10141c4 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
 10141ac:	f7f0 fcd6 	bl	1004b5c <z_clock_elapsed>
 10141b0:	4603      	mov	r3, r0
 10141b2:	6820      	ldr	r0, [r4, #0]
 10141b4:	4a05      	ldr	r2, [pc, #20]	; (10141cc <z_reset_time_slice+0x28>)
 10141b6:	4403      	add	r3, r0
		z_set_timeout_expiry(slice_time, false);
 10141b8:	2100      	movs	r1, #0
	}
}
 10141ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
 10141be:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
 10141c0:	f003 bde9 	b.w	1017d96 <z_set_timeout_expiry>
}
 10141c4:	bd10      	pop	{r4, pc}
 10141c6:	bf00      	nop
 10141c8:	21007fc4 	.word	0x21007fc4
 10141cc:	21007f8c 	.word	0x21007f8c

010141d0 <k_sched_time_slice_set>:

void k_sched_time_slice_set(s32_t slice, int prio)
{
 10141d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 10141d2:	4605      	mov	r5, r0
 10141d4:	460c      	mov	r4, r1
	__asm__ volatile(
 10141d6:	f04f 0320 	mov.w	r3, #32
 10141da:	f3ef 8611 	mrs	r6, BASEPRI
 10141de:	f383 8811 	msr	BASEPRI, r3
 10141e2:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
 10141e6:	2200      	movs	r2, #0
 10141e8:	f44f 4700 	mov.w	r7, #32768	; 0x8000
 10141ec:	f240 30e7 	movw	r0, #999	; 0x3e7
 10141f0:	2100      	movs	r1, #0
 10141f2:	4b0a      	ldr	r3, [pc, #40]	; (101421c <k_sched_time_slice_set+0x4c>)
 10141f4:	fbe7 0105 	umlal	r0, r1, r7, r5
 10141f8:	611a      	str	r2, [r3, #16]
 10141fa:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 10141fe:	2300      	movs	r3, #0
 1014200:	f7eb ff5a 	bl	10000b8 <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
 1014204:	4b06      	ldr	r3, [pc, #24]	; (1014220 <k_sched_time_slice_set+0x50>)
 1014206:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
 1014208:	4b06      	ldr	r3, [pc, #24]	; (1014224 <k_sched_time_slice_set+0x54>)
 101420a:	601c      	str	r4, [r3, #0]
		z_reset_time_slice();
 101420c:	f7ff ffca 	bl	10141a4 <z_reset_time_slice>
	__asm__ volatile(
 1014210:	f386 8811 	msr	BASEPRI, r6
 1014214:	f3bf 8f6f 	isb	sy
	}
}
 1014218:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 101421a:	bf00      	nop
 101421c:	21007f8c 	.word	0x21007f8c
 1014220:	21007fc4 	.word	0x21007fc4
 1014224:	21007fc0 	.word	0x21007fc0

01014228 <k_sched_lock>:
	__asm__ volatile(
 1014228:	f04f 0320 	mov.w	r3, #32
 101422c:	f3ef 8111 	mrs	r1, BASEPRI
 1014230:	f383 8811 	msr	BASEPRI, r3
 1014234:	f3bf 8f6f 	isb	sy
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
 1014238:	4b04      	ldr	r3, [pc, #16]	; (101424c <k_sched_lock+0x24>)
 101423a:	689a      	ldr	r2, [r3, #8]
 101423c:	7bd3      	ldrb	r3, [r2, #15]
 101423e:	3b01      	subs	r3, #1
 1014240:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
 1014242:	f381 8811 	msr	BASEPRI, r1
 1014246:	f3bf 8f6f 	isb	sy
void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
 101424a:	4770      	bx	lr
 101424c:	21007f8c 	.word	0x21007f8c

01014250 <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
 1014250:	4b09      	ldr	r3, [pc, #36]	; (1014278 <z_priq_dumb_remove+0x28>)
 1014252:	f103 0228 	add.w	r2, r3, #40	; 0x28
 1014256:	4282      	cmp	r2, r0
 1014258:	d105      	bne.n	1014266 <z_priq_dumb_remove+0x16>
 101425a:	689b      	ldr	r3, [r3, #8]
 101425c:	428b      	cmp	r3, r1
 101425e:	d102      	bne.n	1014266 <z_priq_dumb_remove+0x16>
 1014260:	7b4b      	ldrb	r3, [r1, #13]
 1014262:	06db      	lsls	r3, r3, #27
 1014264:	d106      	bne.n	1014274 <z_priq_dumb_remove+0x24>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
 1014266:	e9d1 3200 	ldrd	r3, r2, [r1]
 101426a:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
 101426c:	605a      	str	r2, [r3, #4]
	node->next = NULL;
 101426e:	2300      	movs	r3, #0
	node->prev = NULL;
 1014270:	e9c1 3300 	strd	r3, r3, [r1]
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
 1014274:	4770      	bx	lr
 1014276:	bf00      	nop
 1014278:	21007f8c 	.word	0x21007f8c

0101427c <update_cache>:
{
 101427c:	b570      	push	{r4, r5, r6, lr}
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
 101427e:	4c10      	ldr	r4, [pc, #64]	; (10142c0 <update_cache+0x44>)
{
 1014280:	4606      	mov	r6, r0
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
 1014282:	f104 0028 	add.w	r0, r4, #40	; 0x28
 1014286:	f003 fc14 	bl	1017ab2 <z_priq_dumb_best>
 101428a:	4605      	mov	r5, r0
	if (_current->base.thread_state & _THREAD_ABORTING) {
 101428c:	68a3      	ldr	r3, [r4, #8]
 101428e:	7b59      	ldrb	r1, [r3, #13]
 1014290:	0688      	lsls	r0, r1, #26
		_current->base.thread_state |= _THREAD_DEAD;
 1014292:	bf44      	itt	mi
 1014294:	f041 0108 	orrmi.w	r1, r1, #8
 1014298:	7359      	strbmi	r1, [r3, #13]
	return thread ? thread : _current_cpu->idle_thread;
 101429a:	b905      	cbnz	r5, 101429e <update_cache+0x22>
 101429c:	68e5      	ldr	r5, [r4, #12]
	if (preempt_ok != 0) {
 101429e:	b94e      	cbnz	r6, 10142b4 <update_cache+0x38>
	if (z_is_thread_prevented_from_running(_current)) {
 10142a0:	7b5a      	ldrb	r2, [r3, #13]
 10142a2:	06d2      	lsls	r2, r2, #27
 10142a4:	d106      	bne.n	10142b4 <update_cache+0x38>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 10142a6:	69aa      	ldr	r2, [r5, #24]
 10142a8:	b922      	cbnz	r2, 10142b4 <update_cache+0x38>
	if (is_preempt(_current) || is_metairq(thread)) {
 10142aa:	89da      	ldrh	r2, [r3, #14]
 10142ac:	2a7f      	cmp	r2, #127	; 0x7f
 10142ae:	d901      	bls.n	10142b4 <update_cache+0x38>
		_kernel.ready_q.cache = _current;
 10142b0:	6263      	str	r3, [r4, #36]	; 0x24
}
 10142b2:	bd70      	pop	{r4, r5, r6, pc}
		if (thread != _current) {
 10142b4:	42ab      	cmp	r3, r5
 10142b6:	d001      	beq.n	10142bc <update_cache+0x40>
			z_reset_time_slice();
 10142b8:	f7ff ff74 	bl	10141a4 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
 10142bc:	6265      	str	r5, [r4, #36]	; 0x24
}
 10142be:	e7f8      	b.n	10142b2 <update_cache+0x36>
 10142c0:	21007f8c 	.word	0x21007f8c

010142c4 <k_sched_unlock>:
{
 10142c4:	b510      	push	{r4, lr}
	__asm__ volatile(
 10142c6:	f04f 0320 	mov.w	r3, #32
 10142ca:	f3ef 8411 	mrs	r4, BASEPRI
 10142ce:	f383 8811 	msr	BASEPRI, r3
 10142d2:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
 10142d6:	4b08      	ldr	r3, [pc, #32]	; (10142f8 <k_sched_unlock+0x34>)
		update_cache(0);
 10142d8:	2000      	movs	r0, #0
		++_current->base.sched_locked;
 10142da:	689a      	ldr	r2, [r3, #8]
 10142dc:	7bd3      	ldrb	r3, [r2, #15]
 10142de:	3301      	adds	r3, #1
 10142e0:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
 10142e2:	f7ff ffcb 	bl	101427c <update_cache>
	__asm__ volatile(
 10142e6:	f384 8811 	msr	BASEPRI, r4
 10142ea:	f3bf 8f6f 	isb	sy
}
 10142ee:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
 10142f2:	f003 bbb7 	b.w	1017a64 <z_reschedule_unlocked>
 10142f6:	bf00      	nop
 10142f8:	21007f8c 	.word	0x21007f8c

010142fc <ready_thread>:
{
 10142fc:	b470      	push	{r4, r5, r6}
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
 10142fe:	7b43      	ldrb	r3, [r0, #13]
 1014300:	06db      	lsls	r3, r3, #27
 1014302:	d127      	bne.n	1014354 <ready_thread+0x58>
	if (z_is_thread_ready(thread)) {
 1014304:	6983      	ldr	r3, [r0, #24]
 1014306:	bb2b      	cbnz	r3, 1014354 <ready_thread+0x58>
	return list->head == list;
 1014308:	4a13      	ldr	r2, [pc, #76]	; (1014358 <ready_thread+0x5c>)
	return sys_dlist_is_empty(list) ? NULL : list->head;
 101430a:	f102 0128 	add.w	r1, r2, #40	; 0x28
 101430e:	e9d2 340a 	ldrd	r3, r4, [r2, #40]	; 0x28
 1014312:	428b      	cmp	r3, r1
 1014314:	d018      	beq.n	1014348 <ready_thread+0x4c>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 1014316:	b1bb      	cbz	r3, 1014348 <ready_thread+0x4c>
	if (thread_1->base.prio < thread_2->base.prio) {
 1014318:	f990 500e 	ldrsb.w	r5, [r0, #14]
 101431c:	f993 600e 	ldrsb.w	r6, [r3, #14]
 1014320:	42ae      	cmp	r6, r5
 1014322:	dd0c      	ble.n	101433e <ready_thread+0x42>
	node->prev = successor->prev;
 1014324:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
 1014326:	e9c0 3200 	strd	r3, r2, [r0]
	successor->prev->next = node;
 101432a:	6010      	str	r0, [r2, #0]
	successor->prev = node;
 101432c:	6058      	str	r0, [r3, #4]
	thread->base.thread_state |= states;
 101432e:	7b43      	ldrb	r3, [r0, #13]
 1014330:	f063 037f 	orn	r3, r3, #127	; 0x7f
 1014334:	7343      	strb	r3, [r0, #13]
}
 1014336:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
 1014338:	2000      	movs	r0, #0
 101433a:	f7ff bf9f 	b.w	101427c <update_cache>
	return (node == list->tail) ? NULL : node->next;
 101433e:	429c      	cmp	r4, r3
 1014340:	d002      	beq.n	1014348 <ready_thread+0x4c>
 1014342:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 1014344:	2b00      	cmp	r3, #0
 1014346:	d1e9      	bne.n	101431c <ready_thread+0x20>
	node->prev = list->tail;
 1014348:	e9c0 1400 	strd	r1, r4, [r0]
	list->tail->next = node;
 101434c:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 101434e:	6018      	str	r0, [r3, #0]
	list->tail = node;
 1014350:	62d0      	str	r0, [r2, #44]	; 0x2c
}
 1014352:	e7ec      	b.n	101432e <ready_thread+0x32>
}
 1014354:	bc70      	pop	{r4, r5, r6}
 1014356:	4770      	bx	lr
 1014358:	21007f8c 	.word	0x21007f8c

0101435c <z_sched_start>:
{
 101435c:	b510      	push	{r4, lr}
	__asm__ volatile(
 101435e:	f04f 0220 	mov.w	r2, #32
 1014362:	f3ef 8411 	mrs	r4, BASEPRI
 1014366:	f382 8811 	msr	BASEPRI, r2
 101436a:	f3bf 8f6f 	isb	sy
	if (z_has_thread_started(thread)) {
 101436e:	7b42      	ldrb	r2, [r0, #13]
 1014370:	0751      	lsls	r1, r2, #29
 1014372:	d404      	bmi.n	101437e <z_sched_start+0x22>
	__asm__ volatile(
 1014374:	f384 8811 	msr	BASEPRI, r4
 1014378:	f3bf 8f6f 	isb	sy
}
 101437c:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
 101437e:	f022 0204 	bic.w	r2, r2, #4
 1014382:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
 1014384:	f7ff ffba 	bl	10142fc <ready_thread>
	z_reschedule(&sched_spinlock, key);
 1014388:	4621      	mov	r1, r4
}
 101438a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
 101438e:	4801      	ldr	r0, [pc, #4]	; (1014394 <z_sched_start+0x38>)
 1014390:	f003 bb51 	b.w	1017a36 <z_reschedule>
 1014394:	210080d1 	.word	0x210080d1

01014398 <z_move_thread_to_end_of_prio_q>:
{
 1014398:	4601      	mov	r1, r0
 101439a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
 101439c:	f04f 0320 	mov.w	r3, #32
 10143a0:	f3ef 8411 	mrs	r4, BASEPRI
 10143a4:	f383 8811 	msr	BASEPRI, r3
 10143a8:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
 10143ac:	f990 300d 	ldrsb.w	r3, [r0, #13]
 10143b0:	2b00      	cmp	r3, #0
 10143b2:	da02      	bge.n	10143ba <z_move_thread_to_end_of_prio_q+0x22>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
 10143b4:	4817      	ldr	r0, [pc, #92]	; (1014414 <z_move_thread_to_end_of_prio_q+0x7c>)
 10143b6:	f7ff ff4b 	bl	1014250 <z_priq_dumb_remove>
	return list->head == list;
 10143ba:	4a17      	ldr	r2, [pc, #92]	; (1014418 <z_move_thread_to_end_of_prio_q+0x80>)
	return sys_dlist_is_empty(list) ? NULL : list->head;
 10143bc:	f102 0028 	add.w	r0, r2, #40	; 0x28
 10143c0:	e9d2 350a 	ldrd	r3, r5, [r2, #40]	; 0x28
 10143c4:	4283      	cmp	r3, r0
 10143c6:	d01f      	beq.n	1014408 <z_move_thread_to_end_of_prio_q+0x70>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 10143c8:	b1f3      	cbz	r3, 1014408 <z_move_thread_to_end_of_prio_q+0x70>
	if (thread_1->base.prio < thread_2->base.prio) {
 10143ca:	f991 600e 	ldrsb.w	r6, [r1, #14]
 10143ce:	f993 700e 	ldrsb.w	r7, [r3, #14]
 10143d2:	42b7      	cmp	r7, r6
 10143d4:	dd13      	ble.n	10143fe <z_move_thread_to_end_of_prio_q+0x66>
	node->prev = successor->prev;
 10143d6:	6858      	ldr	r0, [r3, #4]
	node->next = successor;
 10143d8:	e9c1 3000 	strd	r3, r0, [r1]
	successor->prev->next = node;
 10143dc:	6001      	str	r1, [r0, #0]
	successor->prev = node;
 10143de:	6059      	str	r1, [r3, #4]
	thread->base.thread_state |= states;
 10143e0:	7b4b      	ldrb	r3, [r1, #13]
		update_cache(thread == _current);
 10143e2:	6890      	ldr	r0, [r2, #8]
 10143e4:	f063 037f 	orn	r3, r3, #127	; 0x7f
 10143e8:	734b      	strb	r3, [r1, #13]
 10143ea:	1a43      	subs	r3, r0, r1
 10143ec:	4258      	negs	r0, r3
 10143ee:	4158      	adcs	r0, r3
 10143f0:	f7ff ff44 	bl	101427c <update_cache>
	__asm__ volatile(
 10143f4:	f384 8811 	msr	BASEPRI, r4
 10143f8:	f3bf 8f6f 	isb	sy
}
 10143fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return (node == list->tail) ? NULL : node->next;
 10143fe:	429d      	cmp	r5, r3
 1014400:	d002      	beq.n	1014408 <z_move_thread_to_end_of_prio_q+0x70>
 1014402:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 1014404:	2b00      	cmp	r3, #0
 1014406:	d1e2      	bne.n	10143ce <z_move_thread_to_end_of_prio_q+0x36>
	node->prev = list->tail;
 1014408:	e9c1 0500 	strd	r0, r5, [r1]
	list->tail->next = node;
 101440c:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 101440e:	6019      	str	r1, [r3, #0]
	list->tail = node;
 1014410:	62d1      	str	r1, [r2, #44]	; 0x2c
}
 1014412:	e7e5      	b.n	10143e0 <z_move_thread_to_end_of_prio_q+0x48>
 1014414:	21007fb4 	.word	0x21007fb4
 1014418:	21007f8c 	.word	0x21007f8c

0101441c <z_time_slice>:
{
 101441c:	b538      	push	{r3, r4, r5, lr}
	if (pending_current == _current) {
 101441e:	4a15      	ldr	r2, [pc, #84]	; (1014474 <z_time_slice+0x58>)
 1014420:	4b15      	ldr	r3, [pc, #84]	; (1014478 <z_time_slice+0x5c>)
 1014422:	6814      	ldr	r4, [r2, #0]
{
 1014424:	4601      	mov	r1, r0
	if (pending_current == _current) {
 1014426:	6898      	ldr	r0, [r3, #8]
 1014428:	42a0      	cmp	r0, r4
 101442a:	461c      	mov	r4, r3
 101442c:	d103      	bne.n	1014436 <z_time_slice+0x1a>
}
 101442e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			z_reset_time_slice();
 1014432:	f7ff beb7 	b.w	10141a4 <z_reset_time_slice>
	pending_current = NULL;
 1014436:	2500      	movs	r5, #0
 1014438:	6015      	str	r5, [r2, #0]
	if (slice_time && sliceable(_current)) {
 101443a:	4a10      	ldr	r2, [pc, #64]	; (101447c <z_time_slice+0x60>)
 101443c:	6812      	ldr	r2, [r2, #0]
 101443e:	b1b2      	cbz	r2, 101446e <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
 1014440:	89c2      	ldrh	r2, [r0, #14]
 1014442:	2a7f      	cmp	r2, #127	; 0x7f
 1014444:	d813      	bhi.n	101446e <z_time_slice+0x52>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
 1014446:	4a0e      	ldr	r2, [pc, #56]	; (1014480 <z_time_slice+0x64>)
 1014448:	f990 500e 	ldrsb.w	r5, [r0, #14]
 101444c:	6812      	ldr	r2, [r2, #0]
 101444e:	4295      	cmp	r5, r2
 1014450:	db0d      	blt.n	101446e <z_time_slice+0x52>
		&& !z_is_idle_thread_object(thread)
 1014452:	4a0c      	ldr	r2, [pc, #48]	; (1014484 <z_time_slice+0x68>)
 1014454:	4290      	cmp	r0, r2
 1014456:	d00a      	beq.n	101446e <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
 1014458:	6982      	ldr	r2, [r0, #24]
 101445a:	b942      	cbnz	r2, 101446e <z_time_slice+0x52>
		if (ticks >= _current_cpu->slice_ticks) {
 101445c:	691a      	ldr	r2, [r3, #16]
 101445e:	428a      	cmp	r2, r1
 1014460:	dc02      	bgt.n	1014468 <z_time_slice+0x4c>
			z_move_thread_to_end_of_prio_q(_current);
 1014462:	f7ff ff99 	bl	1014398 <z_move_thread_to_end_of_prio_q>
 1014466:	e7e2      	b.n	101442e <z_time_slice+0x12>
			_current_cpu->slice_ticks -= ticks;
 1014468:	1a52      	subs	r2, r2, r1
 101446a:	611a      	str	r2, [r3, #16]
}
 101446c:	bd38      	pop	{r3, r4, r5, pc}
		_current_cpu->slice_ticks = 0;
 101446e:	2300      	movs	r3, #0
 1014470:	6123      	str	r3, [r4, #16]
 1014472:	e7fb      	b.n	101446c <z_time_slice+0x50>
 1014474:	21007fbc 	.word	0x21007fbc
 1014478:	21007f8c 	.word	0x21007f8c
 101447c:	21007fc4 	.word	0x21007fc4
 1014480:	21007fc0 	.word	0x21007fc0
 1014484:	21005a44 	.word	0x21005a44

01014488 <z_impl_k_thread_suspend>:
{
 1014488:	b570      	push	{r4, r5, r6, lr}
 101448a:	4604      	mov	r4, r0
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
 101448c:	3018      	adds	r0, #24
 101448e:	f003 fc5c 	bl	1017d4a <z_abort_timeout>
	__asm__ volatile(
 1014492:	f04f 0320 	mov.w	r3, #32
 1014496:	f3ef 8611 	mrs	r6, BASEPRI
 101449a:	f383 8811 	msr	BASEPRI, r3
 101449e:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
 10144a2:	f994 300d 	ldrsb.w	r3, [r4, #13]
 10144a6:	2b00      	cmp	r3, #0
 10144a8:	da07      	bge.n	10144ba <z_impl_k_thread_suspend+0x32>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
 10144aa:	4621      	mov	r1, r4
 10144ac:	480e      	ldr	r0, [pc, #56]	; (10144e8 <z_impl_k_thread_suspend+0x60>)
 10144ae:	f7ff fecf 	bl	1014250 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
 10144b2:	7b63      	ldrb	r3, [r4, #13]
 10144b4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 10144b8:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
 10144ba:	4d0c      	ldr	r5, [pc, #48]	; (10144ec <z_impl_k_thread_suspend+0x64>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
 10144bc:	7b63      	ldrb	r3, [r4, #13]
 10144be:	68a8      	ldr	r0, [r5, #8]
 10144c0:	f043 0310 	orr.w	r3, r3, #16
 10144c4:	7363      	strb	r3, [r4, #13]
 10144c6:	1b03      	subs	r3, r0, r4
 10144c8:	4258      	negs	r0, r3
 10144ca:	4158      	adcs	r0, r3
 10144cc:	f7ff fed6 	bl	101427c <update_cache>
	__asm__ volatile(
 10144d0:	f386 8811 	msr	BASEPRI, r6
 10144d4:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
 10144d8:	68ab      	ldr	r3, [r5, #8]
 10144da:	42a3      	cmp	r3, r4
 10144dc:	d103      	bne.n	10144e6 <z_impl_k_thread_suspend+0x5e>
}
 10144de:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
 10144e2:	f003 babf 	b.w	1017a64 <z_reschedule_unlocked>
}
 10144e6:	bd70      	pop	{r4, r5, r6, pc}
 10144e8:	21007fb4 	.word	0x21007fb4
 10144ec:	21007f8c 	.word	0x21007f8c

010144f0 <z_thread_single_abort>:
	if (thread->fn_abort != NULL) {
 10144f0:	6d83      	ldr	r3, [r0, #88]	; 0x58
{
 10144f2:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 10144f6:	4604      	mov	r4, r0
	if (thread->fn_abort != NULL) {
 10144f8:	b103      	cbz	r3, 10144fc <z_thread_single_abort+0xc>
		thread->fn_abort();
 10144fa:	4798      	blx	r3
 10144fc:	f104 0018 	add.w	r0, r4, #24
 1014500:	f003 fc23 	bl	1017d4a <z_abort_timeout>
	__asm__ volatile(
 1014504:	f04f 0320 	mov.w	r3, #32
 1014508:	f3ef 8611 	mrs	r6, BASEPRI
 101450c:	f383 8811 	msr	BASEPRI, r3
 1014510:	f3bf 8f6f 	isb	sy
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
 1014514:	7b63      	ldrb	r3, [r4, #13]
 1014516:	06d8      	lsls	r0, r3, #27
 1014518:	d123      	bne.n	1014562 <z_thread_single_abort+0x72>
		if (z_is_thread_ready(thread)) {
 101451a:	69a2      	ldr	r2, [r4, #24]
 101451c:	bb0a      	cbnz	r2, 1014562 <z_thread_single_abort+0x72>
			if (z_is_thread_queued(thread)) {
 101451e:	0619      	lsls	r1, r3, #24
 1014520:	d507      	bpl.n	1014532 <z_thread_single_abort+0x42>
				_priq_run_remove(&_kernel.ready_q.runq,
 1014522:	4621      	mov	r1, r4
 1014524:	481e      	ldr	r0, [pc, #120]	; (10145a0 <z_thread_single_abort+0xb0>)
 1014526:	f7ff fe93 	bl	1014250 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
 101452a:	7b63      	ldrb	r3, [r4, #13]
 101452c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 1014530:	7363      	strb	r3, [r4, #13]
			update_cache(thread == _current);
 1014532:	4b1c      	ldr	r3, [pc, #112]	; (10145a4 <z_thread_single_abort+0xb4>)
 1014534:	6898      	ldr	r0, [r3, #8]
 1014536:	1b02      	subs	r2, r0, r4
 1014538:	4250      	negs	r0, r2
 101453a:	4150      	adcs	r0, r2
 101453c:	f7ff fe9e 	bl	101427c <update_cache>
			waiter->base.pended_on = NULL;
 1014540:	2700      	movs	r7, #0
		thread->base.thread_state |= mask;
 1014542:	7b63      	ldrb	r3, [r4, #13]
	sys_dlist_init(&w->waitq);
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 1014544:	f104 0828 	add.w	r8, r4, #40	; 0x28
 1014548:	f043 0308 	orr.w	r3, r3, #8
 101454c:	7363      	strb	r3, [r4, #13]
	return list->head == list;
 101454e:	6aa5      	ldr	r5, [r4, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1014550:	4545      	cmp	r5, r8
 1014552:	d000      	beq.n	1014556 <z_thread_single_abort+0x66>
		while ((waiter = z_waitq_head(&thread->base.join_waiters)) !=
 1014554:	b995      	cbnz	r5, 101457c <z_thread_single_abort+0x8c>
	__asm__ volatile(
 1014556:	f386 8811 	msr	BASEPRI, r6
 101455a:	f3bf 8f6f 	isb	sy
}
 101455e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (z_is_thread_pending(thread)) {
 1014562:	079b      	lsls	r3, r3, #30
 1014564:	d5ec      	bpl.n	1014540 <z_thread_single_abort+0x50>
				_priq_wait_remove(&pended_on(thread)->waitq,
 1014566:	4621      	mov	r1, r4
 1014568:	68a0      	ldr	r0, [r4, #8]
 101456a:	f7ff fe71 	bl	1014250 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
 101456e:	7b63      	ldrb	r3, [r4, #13]
 1014570:	f023 0302 	bic.w	r3, r3, #2
 1014574:	7363      	strb	r3, [r4, #13]
				thread->base.pended_on = NULL;
 1014576:	2300      	movs	r3, #0
 1014578:	60a3      	str	r3, [r4, #8]
 101457a:	e7e1      	b.n	1014540 <z_thread_single_abort+0x50>
 101457c:	f105 0018 	add.w	r0, r5, #24
 1014580:	f003 fbe3 	bl	1017d4a <z_abort_timeout>
			_priq_wait_remove(&pended_on(waiter)->waitq, waiter);
 1014584:	68a8      	ldr	r0, [r5, #8]
 1014586:	4629      	mov	r1, r5
 1014588:	f7ff fe62 	bl	1014250 <z_priq_dumb_remove>
 101458c:	7b6b      	ldrb	r3, [r5, #13]
			ready_thread(waiter);
 101458e:	4628      	mov	r0, r5
 1014590:	f023 0302 	bic.w	r3, r3, #2
 1014594:	736b      	strb	r3, [r5, #13]
			waiter->base.pended_on = NULL;
 1014596:	60af      	str	r7, [r5, #8]
 1014598:	672f      	str	r7, [r5, #112]	; 0x70
			ready_thread(waiter);
 101459a:	f7ff feaf 	bl	10142fc <ready_thread>
 101459e:	e7d6      	b.n	101454e <z_thread_single_abort+0x5e>
 10145a0:	21007fb4 	.word	0x21007fb4
 10145a4:	21007f8c 	.word	0x21007f8c

010145a8 <unready_thread>:
{
 10145a8:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
 10145aa:	f990 300d 	ldrsb.w	r3, [r0, #13]
{
 10145ae:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
 10145b0:	2b00      	cmp	r3, #0
 10145b2:	da06      	bge.n	10145c2 <unready_thread+0x1a>
		_priq_run_remove(&_kernel.ready_q.runq, thread);
 10145b4:	4807      	ldr	r0, [pc, #28]	; (10145d4 <unready_thread+0x2c>)
 10145b6:	f7ff fe4b 	bl	1014250 <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
 10145ba:	7b4b      	ldrb	r3, [r1, #13]
 10145bc:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 10145c0:	734b      	strb	r3, [r1, #13]
	update_cache(thread == _current);
 10145c2:	4b05      	ldr	r3, [pc, #20]	; (10145d8 <unready_thread+0x30>)
 10145c4:	6898      	ldr	r0, [r3, #8]
 10145c6:	1a43      	subs	r3, r0, r1
 10145c8:	4258      	negs	r0, r3
 10145ca:	4158      	adcs	r0, r3
}
 10145cc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
 10145d0:	f7ff be54 	b.w	101427c <update_cache>
 10145d4:	21007fb4 	.word	0x21007fb4
 10145d8:	21007f8c 	.word	0x21007f8c

010145dc <z_tick_sleep.part.0>:
	z_impl_k_yield();
}
#include <syscalls/k_yield_mrsh.c>
#endif

static s32_t z_tick_sleep(s32_t ticks)
 10145dc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 10145de:	4605      	mov	r5, r0
#else
	ticks += _TICK_ALIGN;
	timeout = (k_ticks_t) ticks;
#endif

	expected_wakeup_time = ticks + z_tick_get_32();
 10145e0:	f003 fbf3 	bl	1017dca <z_tick_get_32>
 10145e4:	182c      	adds	r4, r5, r0
	__asm__ volatile(
 10145e6:	f04f 0320 	mov.w	r3, #32
 10145ea:	f3ef 8711 	mrs	r7, BASEPRI
 10145ee:	f383 8811 	msr	BASEPRI, r3
 10145f2:	f3bf 8f6f 	isb	sy
	 */
	struct k_spinlock local_lock = {};
	k_spinlock_key_t key = k_spin_lock(&local_lock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
 10145f6:	4e0d      	ldr	r6, [pc, #52]	; (101462c <z_tick_sleep.part.0+0x50>)
 10145f8:	4b0d      	ldr	r3, [pc, #52]	; (1014630 <z_tick_sleep.part.0+0x54>)
 10145fa:	68b0      	ldr	r0, [r6, #8]
 10145fc:	6018      	str	r0, [r3, #0]
#endif
	z_remove_thread_from_ready_q(_current);
 10145fe:	f003 fa99 	bl	1017b34 <z_remove_thread_from_ready_q>
	z_add_thread_timeout(_current, timeout);
 1014602:	68b0      	ldr	r0, [r6, #8]
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
 1014604:	490b      	ldr	r1, [pc, #44]	; (1014634 <z_tick_sleep.part.0+0x58>)
 1014606:	462a      	mov	r2, r5
 1014608:	17eb      	asrs	r3, r5, #31
 101460a:	3018      	adds	r0, #24
 101460c:	f000 fa88 	bl	1014b20 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
 1014610:	68b2      	ldr	r2, [r6, #8]
	ret = arch_swap(key);
 1014612:	4638      	mov	r0, r7
	thread->base.thread_state |= _THREAD_SUSPENDED;
 1014614:	7b53      	ldrb	r3, [r2, #13]
 1014616:	f043 0310 	orr.w	r3, r3, #16
 101461a:	7353      	strb	r3, [r2, #13]
 101461c:	f7f0 fba8 	bl	1004d70 <arch_swap>

	(void)z_swap(&local_lock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = expected_wakeup_time - z_tick_get_32();
 1014620:	f003 fbd3 	bl	1017dca <z_tick_get_32>
 1014624:	1a20      	subs	r0, r4, r0
		return ticks;
	}
#endif

	return 0;
}
 1014626:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 101462a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 101462c:	21007f8c 	.word	0x21007f8c
 1014630:	21007fbc 	.word	0x21007fbc
 1014634:	01017adf 	.word	0x01017adf

01014638 <pend>:
{
 1014638:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 101463c:	4606      	mov	r6, r0
 101463e:	4614      	mov	r4, r2
 1014640:	461d      	mov	r5, r3
 1014642:	f04f 0320 	mov.w	r3, #32
 1014646:	f3ef 8711 	mrs	r7, BASEPRI
 101464a:	f383 8811 	msr	BASEPRI, r3
 101464e:	f3bf 8f6f 	isb	sy
		add_to_waitq_locked(thread, wait_q);
 1014652:	f003 fa7f 	bl	1017b54 <add_to_waitq_locked>
	__asm__ volatile(
 1014656:	f387 8811 	msr	BASEPRI, r7
 101465a:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 101465e:	1c6b      	adds	r3, r5, #1
 1014660:	bf08      	it	eq
 1014662:	f1b4 3fff 	cmpeq.w	r4, #4294967295
 1014666:	d008      	beq.n	101467a <pend+0x42>
 1014668:	4622      	mov	r2, r4
 101466a:	462b      	mov	r3, r5
 101466c:	f106 0018 	add.w	r0, r6, #24
 1014670:	4903      	ldr	r1, [pc, #12]	; (1014680 <pend+0x48>)
}
 1014672:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 1014676:	f000 ba53 	b.w	1014b20 <z_add_timeout>
 101467a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 101467e:	bf00      	nop
 1014680:	01017adf 	.word	0x01017adf

01014684 <z_pend_curr>:
{
 1014684:	b510      	push	{r4, lr}
 1014686:	460c      	mov	r4, r1
	pending_current = _current;
 1014688:	4b06      	ldr	r3, [pc, #24]	; (10146a4 <z_pend_curr+0x20>)
{
 101468a:	4611      	mov	r1, r2
	pending_current = _current;
 101468c:	6898      	ldr	r0, [r3, #8]
 101468e:	4b06      	ldr	r3, [pc, #24]	; (10146a8 <z_pend_curr+0x24>)
 1014690:	6018      	str	r0, [r3, #0]
	pend(_current, wait_q, timeout);
 1014692:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 1014696:	f7ff ffcf 	bl	1014638 <pend>
 101469a:	4620      	mov	r0, r4
}
 101469c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 10146a0:	f7f0 bb66 	b.w	1004d70 <arch_swap>
 10146a4:	21007f8c 	.word	0x21007f8c
 10146a8:	21007fbc 	.word	0x21007fbc

010146ac <z_sched_init>:
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
 10146ac:	2100      	movs	r1, #0
	list->head = (sys_dnode_t *)list;
 10146ae:	4b04      	ldr	r3, [pc, #16]	; (10146c0 <z_sched_init+0x14>)
 10146b0:	4608      	mov	r0, r1
 10146b2:	f103 0228 	add.w	r2, r3, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
 10146b6:	e9c3 220a 	strd	r2, r2, [r3, #40]	; 0x28
 10146ba:	f7ff bd89 	b.w	10141d0 <k_sched_time_slice_set>
 10146be:	bf00      	nop
 10146c0:	21007f8c 	.word	0x21007f8c

010146c4 <z_impl_k_yield>:
{
 10146c4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!z_is_idle_thread_object(_current)) {
 10146c6:	4c23      	ldr	r4, [pc, #140]	; (1014754 <z_impl_k_yield+0x90>)
 10146c8:	4b23      	ldr	r3, [pc, #140]	; (1014758 <z_impl_k_yield+0x94>)
 10146ca:	68a2      	ldr	r2, [r4, #8]
 10146cc:	429a      	cmp	r2, r3
 10146ce:	d028      	beq.n	1014722 <z_impl_k_yield+0x5e>
	__asm__ volatile(
 10146d0:	f04f 0320 	mov.w	r3, #32
 10146d4:	f3ef 8511 	mrs	r5, BASEPRI
 10146d8:	f383 8811 	msr	BASEPRI, r3
 10146dc:	f3bf 8f6f 	isb	sy
				_priq_run_remove(&_kernel.ready_q.runq,
 10146e0:	f104 0028 	add.w	r0, r4, #40	; 0x28
 10146e4:	68a1      	ldr	r1, [r4, #8]
 10146e6:	f7ff fdb3 	bl	1014250 <z_priq_dumb_remove>
	return list->head == list;
 10146ea:	6aa2      	ldr	r2, [r4, #40]	; 0x28
			_priq_run_add(&_kernel.ready_q.runq, _current);
 10146ec:	68a3      	ldr	r3, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 10146ee:	4282      	cmp	r2, r0
 10146f0:	d028      	beq.n	1014744 <z_impl_k_yield+0x80>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 10146f2:	b33a      	cbz	r2, 1014744 <z_impl_k_yield+0x80>
 10146f4:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
	if (thread_1->base.prio < thread_2->base.prio) {
 10146f6:	f993 100e 	ldrsb.w	r1, [r3, #14]
 10146fa:	f992 700e 	ldrsb.w	r7, [r2, #14]
 10146fe:	428f      	cmp	r7, r1
 1014700:	dd1b      	ble.n	101473a <z_impl_k_yield+0x76>
	node->prev = successor->prev;
 1014702:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
 1014704:	e9c3 2100 	strd	r2, r1, [r3]
	successor->prev->next = node;
 1014708:	600b      	str	r3, [r1, #0]
	successor->prev = node;
 101470a:	6053      	str	r3, [r2, #4]
	thread->base.thread_state |= states;
 101470c:	7b5a      	ldrb	r2, [r3, #13]
			update_cache(1);
 101470e:	2001      	movs	r0, #1
 1014710:	f062 027f 	orn	r2, r2, #127	; 0x7f
 1014714:	735a      	strb	r2, [r3, #13]
 1014716:	f7ff fdb1 	bl	101427c <update_cache>
	__asm__ volatile(
 101471a:	f385 8811 	msr	BASEPRI, r5
 101471e:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
 1014722:	f04f 0320 	mov.w	r3, #32
 1014726:	f3ef 8011 	mrs	r0, BASEPRI
 101472a:	f383 8811 	msr	BASEPRI, r3
 101472e:	f3bf 8f6f 	isb	sy
}
 1014732:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 1014736:	f7f0 bb1b 	b.w	1004d70 <arch_swap>
	return (node == list->tail) ? NULL : node->next;
 101473a:	4296      	cmp	r6, r2
 101473c:	d002      	beq.n	1014744 <z_impl_k_yield+0x80>
 101473e:	6812      	ldr	r2, [r2, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 1014740:	2a00      	cmp	r2, #0
 1014742:	d1da      	bne.n	10146fa <z_impl_k_yield+0x36>
	node->prev = list->tail;
 1014744:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
	node->next = list;
 1014746:	6018      	str	r0, [r3, #0]
	node->prev = list->tail;
 1014748:	605a      	str	r2, [r3, #4]
	list->tail->next = node;
 101474a:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
 101474c:	6013      	str	r3, [r2, #0]
	list->tail = node;
 101474e:	62e3      	str	r3, [r4, #44]	; 0x2c
}
 1014750:	e7dc      	b.n	101470c <z_impl_k_yield+0x48>
 1014752:	bf00      	nop
 1014754:	21007f8c 	.word	0x21007f8c
 1014758:	21005a44 	.word	0x21005a44

0101475c <z_impl_k_sleep>:

s32_t z_impl_k_sleep(k_timeout_t timeout)
{
 101475c:	460b      	mov	r3, r1
	k_ticks_t ticks;

	__ASSERT(!arch_is_in_isr(), "");

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 101475e:	3301      	adds	r3, #1
 1014760:	bf08      	it	eq
 1014762:	f1b0 3fff 	cmpeq.w	r0, #4294967295
{
 1014766:	b510      	push	{r4, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 1014768:	d106      	bne.n	1014778 <z_impl_k_sleep+0x1c>
		k_thread_suspend(_current);
 101476a:	4b0b      	ldr	r3, [pc, #44]	; (1014798 <z_impl_k_sleep+0x3c>)
 101476c:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
 101476e:	f7ff fe8b 	bl	1014488 <z_impl_k_thread_suspend>
		return (s32_t) K_TICKS_FOREVER;
 1014772:	f04f 30ff 	mov.w	r0, #4294967295
	ticks = timeout.ticks;
#endif

	ticks = z_tick_sleep(ticks);
	return k_ticks_to_ms_floor64(ticks);
}
 1014776:	bd10      	pop	{r4, pc}
	ticks = z_tick_sleep(ticks);
 1014778:	4604      	mov	r4, r0
	if (ticks == 0) {
 101477a:	b948      	cbnz	r0, 1014790 <z_impl_k_sleep+0x34>
	z_impl_k_yield();
 101477c:	f7ff ffa2 	bl	10146c4 <z_impl_k_yield>
			return (t * to_hz + off) / from_hz;
 1014780:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 1014784:	fb84 3400 	smull	r3, r4, r4, r0
 1014788:	0bd8      	lsrs	r0, r3, #15
 101478a:	ea40 4044 	orr.w	r0, r0, r4, lsl #17
	return k_ticks_to_ms_floor64(ticks);
 101478e:	e7f2      	b.n	1014776 <z_impl_k_sleep+0x1a>
 1014790:	f7ff ff24 	bl	10145dc <z_tick_sleep.part.0>
 1014794:	4604      	mov	r4, r0
 1014796:	e7f3      	b.n	1014780 <z_impl_k_sleep+0x24>
 1014798:	21007f8c 	.word	0x21007f8c

0101479c <z_impl_k_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
 101479c:	4b01      	ldr	r3, [pc, #4]	; (10147a4 <z_impl_k_current_get+0x8>)
 101479e:	6898      	ldr	r0, [r3, #8]
 10147a0:	4770      	bx	lr
 10147a2:	bf00      	nop
 10147a4:	21007f8c 	.word	0x21007f8c

010147a8 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
 10147a8:	b538      	push	{r3, r4, r5, lr}
 10147aa:	4604      	mov	r4, r0
 10147ac:	f04f 0320 	mov.w	r3, #32
 10147b0:	f3ef 8511 	mrs	r5, BASEPRI
 10147b4:	f383 8811 	msr	BASEPRI, r3
 10147b8:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
 10147bc:	f003 f9f2 	bl	1017ba4 <z_unpend_first_thread>

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);

	if (thread != NULL) {
 10147c0:	b148      	cbz	r0, 10147d6 <z_impl_k_sem_give+0x2e>
 10147c2:	2200      	movs	r2, #0
 10147c4:	6702      	str	r2, [r0, #112]	; 0x70
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
 10147c6:	f003 f97a 	bl	1017abe <z_ready_thread>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
 10147ca:	4629      	mov	r1, r5
}
 10147cc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
 10147d0:	4807      	ldr	r0, [pc, #28]	; (10147f0 <z_impl_k_sem_give+0x48>)
 10147d2:	f003 b930 	b.w	1017a36 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
 10147d6:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
 10147da:	429a      	cmp	r2, r3
 10147dc:	bf18      	it	ne
 10147de:	3301      	addne	r3, #1
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
 10147e0:	2102      	movs	r1, #2
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
 10147e2:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
 10147e4:	f104 0010 	add.w	r0, r4, #16
 10147e8:	f003 fc43 	bl	1018072 <z_handle_obj_poll_events>
}
 10147ec:	e7ed      	b.n	10147ca <z_impl_k_sem_give+0x22>
 10147ee:	bf00      	nop
 10147f0:	210080d1 	.word	0x210080d1

010147f4 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
 10147f4:	b537      	push	{r0, r1, r2, r4, r5, lr}
 10147f6:	4614      	mov	r4, r2
 10147f8:	461d      	mov	r5, r3
 10147fa:	f04f 0320 	mov.w	r3, #32
 10147fe:	f3ef 8111 	mrs	r1, BASEPRI
 1014802:	f383 8811 	msr	BASEPRI, r3
 1014806:	f3bf 8f6f 	isb	sy
		  K_TIMEOUT_EQ(timeout, K_NO_WAIT)), "");

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
 101480a:	6883      	ldr	r3, [r0, #8]
 101480c:	b143      	cbz	r3, 1014820 <z_impl_k_sem_take+0x2c>
		sem->count--;
 101480e:	3b01      	subs	r3, #1
 1014810:	6083      	str	r3, [r0, #8]
	__asm__ volatile(
 1014812:	f381 8811 	msr	BASEPRI, r1
 1014816:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
 101481a:	2000      	movs	r0, #0
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);

out:
	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
	return ret;
}
 101481c:	b003      	add	sp, #12
 101481e:	bd30      	pop	{r4, r5, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 1014820:	ea54 0305 	orrs.w	r3, r4, r5
 1014824:	d106      	bne.n	1014834 <z_impl_k_sem_take+0x40>
 1014826:	f381 8811 	msr	BASEPRI, r1
 101482a:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
 101482e:	f06f 000f 	mvn.w	r0, #15
 1014832:	e7f3      	b.n	101481c <z_impl_k_sem_take+0x28>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
 1014834:	4602      	mov	r2, r0
 1014836:	e9cd 4500 	strd	r4, r5, [sp]
 101483a:	4802      	ldr	r0, [pc, #8]	; (1014844 <z_impl_k_sem_take+0x50>)
 101483c:	f7ff ff22 	bl	1014684 <z_pend_curr>
	return ret;
 1014840:	e7ec      	b.n	101481c <z_impl_k_sem_take+0x28>
 1014842:	bf00      	nop
 1014844:	210080d1 	.word	0x210080d1

01014848 <k_sys_work_q_init>:
K_THREAD_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(struct device *dev)
{
 1014848:	b510      	push	{r4, lr}
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
 101484a:	4c08      	ldr	r4, [pc, #32]	; (101486c <k_sys_work_q_init+0x24>)
 101484c:	f04f 33ff 	mov.w	r3, #4294967295
 1014850:	f44f 6200 	mov.w	r2, #2048	; 0x800
 1014854:	4620      	mov	r0, r4
 1014856:	4906      	ldr	r1, [pc, #24]	; (1014870 <k_sys_work_q_init+0x28>)
 1014858:	f000 f8c2 	bl	10149e0 <k_work_q_start>
	return z_impl_k_thread_name_set(thread_id, value);
 101485c:	4905      	ldr	r1, [pc, #20]	; (1014874 <k_sys_work_q_init+0x2c>)
 101485e:	f104 0018 	add.w	r0, r4, #24
 1014862:	f003 f9f4 	bl	1017c4e <z_impl_k_thread_name_set>
		       K_THREAD_STACK_SIZEOF(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);
	k_thread_name_set(&k_sys_work_q.thread, "sysworkq");

	return 0;
}
 1014866:	2000      	movs	r0, #0
 1014868:	bd10      	pop	{r4, pc}
 101486a:	bf00      	nop
 101486c:	21007fc8 	.word	0x21007fc8
 1014870:	2100a0e8 	.word	0x2100a0e8
 1014874:	01019bed 	.word	0x01019bed

01014878 <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
 1014878:	b5f0      	push	{r4, r5, r6, r7, lr}
	sys_dlist_init(&w->waitq);
 101487a:	f100 0528 	add.w	r5, r0, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
 101487e:	e9c0 550a 	strd	r5, r5, [r0, #40]	; 0x28
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
	thread_base->thread_state = (u8_t)initial_state;
 1014882:	2504      	movs	r5, #4
 1014884:	7345      	strb	r5, [r0, #13]

	thread_base->prio = priority;

	thread_base->sched_locked = 0U;
 1014886:	2500      	movs	r5, #0
{
 1014888:	4604      	mov	r4, r0
 101488a:	b087      	sub	sp, #28
 101488c:	e9dd 670f 	ldrd	r6, r7, [sp, #60]	; 0x3c
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 1014890:	e9cd 6703 	strd	r6, r7, [sp, #12]
	thread_base->prio = priority;
 1014894:	7386      	strb	r6, [r0, #14]
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 1014896:	9e0e      	ldr	r6, [sp, #56]	; 0x38
	node->prev = NULL;
 1014898:	e9c0 5506 	strd	r5, r5, [r0, #24]
 101489c:	9602      	str	r6, [sp, #8]
 101489e:	9e0d      	ldr	r6, [sp, #52]	; 0x34
	thread_base->user_options = (u8_t)options;
 10148a0:	7307      	strb	r7, [r0, #12]
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 10148a2:	9601      	str	r6, [sp, #4]
 10148a4:	9e0c      	ldr	r6, [sp, #48]	; 0x30
	thread_base->sched_locked = 0U;
 10148a6:	73c5      	strb	r5, [r0, #15]
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 10148a8:	9600      	str	r6, [sp, #0]
 10148aa:	f7f0 fb05 	bl	1004eb8 <arch_new_thread>
	if (!_current) {
 10148ae:	4b04      	ldr	r3, [pc, #16]	; (10148c0 <z_setup_new_thread+0x48>)
	new_thread->fn_abort = NULL;
 10148b0:	e9c4 5515 	strd	r5, r5, [r4, #84]	; 0x54
	if (!_current) {
 10148b4:	689b      	ldr	r3, [r3, #8]
 10148b6:	b103      	cbz	r3, 10148ba <z_setup_new_thread+0x42>
	new_thread->resource_pool = _current->resource_pool;
 10148b8:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 10148ba:	66a3      	str	r3, [r4, #104]	; 0x68
}
 10148bc:	b007      	add	sp, #28
 10148be:	bdf0      	pop	{r4, r5, r6, r7, pc}
 10148c0:	21007f8c 	.word	0x21007f8c

010148c4 <z_impl_k_thread_create>:
{
 10148c4:	b5f0      	push	{r4, r5, r6, r7, lr}
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 10148c6:	2500      	movs	r5, #0
{
 10148c8:	b087      	sub	sp, #28
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 10148ca:	9505      	str	r5, [sp, #20]
 10148cc:	9d10      	ldr	r5, [sp, #64]	; 0x40
{
 10148ce:	e9dd 6712 	ldrd	r6, r7, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 10148d2:	9504      	str	r5, [sp, #16]
 10148d4:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
{
 10148d6:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 10148d8:	9503      	str	r5, [sp, #12]
 10148da:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 10148dc:	9502      	str	r5, [sp, #8]
 10148de:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 10148e0:	9501      	str	r5, [sp, #4]
 10148e2:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 10148e4:	9500      	str	r5, [sp, #0]
 10148e6:	f7ff ffc7 	bl	1014878 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
 10148ea:	1c7b      	adds	r3, r7, #1
 10148ec:	bf08      	it	eq
 10148ee:	f1b6 3fff 	cmpeq.w	r6, #4294967295
 10148f2:	d005      	beq.n	1014900 <z_impl_k_thread_create+0x3c>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 10148f4:	ea56 0307 	orrs.w	r3, r6, r7
 10148f8:	d105      	bne.n	1014906 <z_impl_k_thread_create+0x42>
	z_sched_start(thread);
 10148fa:	4620      	mov	r0, r4
 10148fc:	f7ff fd2e 	bl	101435c <z_sched_start>
}
 1014900:	4620      	mov	r0, r4
 1014902:	b007      	add	sp, #28
 1014904:	bdf0      	pop	{r4, r5, r6, r7, pc}
 1014906:	4632      	mov	r2, r6
 1014908:	463b      	mov	r3, r7
 101490a:	4903      	ldr	r1, [pc, #12]	; (1014918 <z_impl_k_thread_create+0x54>)
 101490c:	f104 0018 	add.w	r0, r4, #24
 1014910:	f000 f906 	bl	1014b20 <z_add_timeout>
 1014914:	e7f4      	b.n	1014900 <z_impl_k_thread_create+0x3c>
 1014916:	bf00      	nop
 1014918:	01017adf 	.word	0x01017adf

0101491c <z_init_static_threads>:
{
 101491c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
 1014920:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 10149d8 <z_init_static_threads+0xbc>
 1014924:	4d2b      	ldr	r5, [pc, #172]	; (10149d4 <z_init_static_threads+0xb8>)
 1014926:	46c8      	mov	r8, r9
{
 1014928:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
 101492a:	454d      	cmp	r5, r9
 101492c:	f105 0430 	add.w	r4, r5, #48	; 0x30
 1014930:	d30d      	bcc.n	101494e <z_init_static_threads+0x32>
	k_sched_lock();
 1014932:	f7ff fc79 	bl	1014228 <k_sched_lock>
			return (u32_t)((t * to_hz + off) / from_hz);
 1014936:	f44f 4900 	mov.w	r9, #32768	; 0x8000
	_FOREACH_STATIC_THREAD(thread_data) {
 101493a:	4c26      	ldr	r4, [pc, #152]	; (10149d4 <z_init_static_threads+0xb8>)
 101493c:	f8df a09c 	ldr.w	sl, [pc, #156]	; 10149dc <z_init_static_threads+0xc0>
 1014940:	4544      	cmp	r4, r8
 1014942:	d321      	bcc.n	1014988 <z_init_static_threads+0x6c>
}
 1014944:	b007      	add	sp, #28
 1014946:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	k_sched_unlock();
 101494a:	f7ff bcbb 	b.w	10142c4 <k_sched_unlock>
		z_setup_new_thread(
 101494e:	f854 3c04 	ldr.w	r3, [r4, #-4]
 1014952:	9305      	str	r3, [sp, #20]
 1014954:	f854 3c10 	ldr.w	r3, [r4, #-16]
 1014958:	9304      	str	r3, [sp, #16]
 101495a:	f854 3c14 	ldr.w	r3, [r4, #-20]
 101495e:	9303      	str	r3, [sp, #12]
 1014960:	f854 3c18 	ldr.w	r3, [r4, #-24]
 1014964:	9302      	str	r3, [sp, #8]
 1014966:	f854 3c1c 	ldr.w	r3, [r4, #-28]
 101496a:	9301      	str	r3, [sp, #4]
 101496c:	f854 3c20 	ldr.w	r3, [r4, #-32]
 1014970:	9300      	str	r3, [sp, #0]
 1014972:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
 1014976:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
 101497a:	f7ff ff7d 	bl	1014878 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
 101497e:	f854 3c30 	ldr.w	r3, [r4, #-48]
 1014982:	655d      	str	r5, [r3, #84]	; 0x54
 1014984:	4625      	mov	r5, r4
 1014986:	e7d0      	b.n	101492a <z_init_static_threads+0xe>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
 1014988:	6a61      	ldr	r1, [r4, #36]	; 0x24
 101498a:	1c4b      	adds	r3, r1, #1
 101498c:	d017      	beq.n	10149be <z_init_static_threads+0xa2>
 101498e:	f240 3be7 	movw	fp, #999	; 0x3e7
 1014992:	f04f 0c00 	mov.w	ip, #0
					    K_MSEC(thread_data->init_delay));
 1014996:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
 101499a:	fbc9 bc01 	smlal	fp, ip, r9, r1
 101499e:	2300      	movs	r3, #0
 10149a0:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 10149a4:	4658      	mov	r0, fp
 10149a6:	4661      	mov	r1, ip
 10149a8:	f7eb fb86 	bl	10000b8 <__aeabi_uldivmod>
 10149ac:	2700      	movs	r7, #0
 10149ae:	4606      	mov	r6, r0
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 10149b0:	ea56 0307 	orrs.w	r3, r6, r7
			schedule_new_thread(thread_data->init_thread,
 10149b4:	6825      	ldr	r5, [r4, #0]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 10149b6:	d104      	bne.n	10149c2 <z_init_static_threads+0xa6>
	z_sched_start(thread);
 10149b8:	4628      	mov	r0, r5
 10149ba:	f7ff fccf 	bl	101435c <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
 10149be:	3430      	adds	r4, #48	; 0x30
 10149c0:	e7be      	b.n	1014940 <z_init_static_threads+0x24>
 10149c2:	4602      	mov	r2, r0
 10149c4:	463b      	mov	r3, r7
 10149c6:	4651      	mov	r1, sl
 10149c8:	f105 0018 	add.w	r0, r5, #24
 10149cc:	f000 f8a8 	bl	1014b20 <z_add_timeout>
 10149d0:	e7f5      	b.n	10149be <z_init_static_threads+0xa2>
 10149d2:	bf00      	nop
 10149d4:	21000584 	.word	0x21000584
 10149d8:	21000584 	.word	0x21000584
 10149dc:	01017adf 	.word	0x01017adf

010149e0 <k_work_q_start>:

extern void z_work_q_main(void *work_q_ptr, void *p2, void *p3);

void k_work_q_start(struct k_work_q *work_q, k_thread_stack_t *stack,
		    size_t stack_size, int prio)
{
 10149e0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 10149e4:	4604      	mov	r4, r0
 10149e6:	b088      	sub	sp, #32
 10149e8:	460d      	mov	r5, r1
 10149ea:	4616      	mov	r6, r2
 10149ec:	461f      	mov	r7, r3
	z_impl_k_queue_init(queue);
 10149ee:	f002 ff9e 	bl	101792e <z_impl_k_queue_init>
	k_queue_init(&work_q->queue);
	(void)k_thread_create(&work_q->thread, stack, stack_size, z_work_q_main,
 10149f2:	f104 0818 	add.w	r8, r4, #24
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 10149f6:	2200      	movs	r2, #0
 10149f8:	2300      	movs	r3, #0
 10149fa:	e9cd 7203 	strd	r7, r2, [sp, #12]
 10149fe:	e9cd 2306 	strd	r2, r3, [sp, #24]
 1014a02:	e9cd 2201 	strd	r2, r2, [sp, #4]
 1014a06:	4629      	mov	r1, r5
 1014a08:	4632      	mov	r2, r6
 1014a0a:	4640      	mov	r0, r8
 1014a0c:	4b05      	ldr	r3, [pc, #20]	; (1014a24 <k_work_q_start+0x44>)
 1014a0e:	9400      	str	r4, [sp, #0]
 1014a10:	f7ff ff58 	bl	10148c4 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
 1014a14:	4640      	mov	r0, r8
 1014a16:	4904      	ldr	r1, [pc, #16]	; (1014a28 <k_work_q_start+0x48>)
			work_q, NULL, NULL, prio, 0, K_NO_WAIT);

	k_thread_name_set(&work_q->thread, WORKQUEUE_THREAD_NAME);
}
 1014a18:	b008      	add	sp, #32
 1014a1a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 1014a1e:	f003 b916 	b.w	1017c4e <z_impl_k_thread_name_set>
 1014a22:	bf00      	nop
 1014a24:	01014f7f 	.word	0x01014f7f
 1014a28:	01019bf6 	.word	0x01019bf6

01014a2c <k_delayed_work_submit_to_queue>:
}

int k_delayed_work_submit_to_queue(struct k_work_q *work_q,
				   struct k_delayed_work *work,
				   k_timeout_t delay)
{
 1014a2c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1014a30:	4606      	mov	r6, r0
 1014a32:	460d      	mov	r5, r1
 1014a34:	4690      	mov	r8, r2
 1014a36:	4699      	mov	r9, r3
	__asm__ volatile(
 1014a38:	f04f 0320 	mov.w	r3, #32
 1014a3c:	f3ef 8711 	mrs	r7, BASEPRI
 1014a40:	f383 8811 	msr	BASEPRI, r3
 1014a44:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int err = 0;

	/* Work cannot be active in multiple queues */
	if (work->work_q != NULL && work->work_q != work_q) {
 1014a48:	69cb      	ldr	r3, [r1, #28]
 1014a4a:	b17b      	cbz	r3, 1014a6c <k_delayed_work_submit_to_queue+0x40>
 1014a4c:	4283      	cmp	r3, r0
 1014a4e:	d128      	bne.n	1014aa2 <k_delayed_work_submit_to_queue+0x76>
		goto done;
	}

	/* Cancel if work has been submitted */
	if (work->work_q == work_q) {
		err = work_cancel(work);
 1014a50:	4628      	mov	r0, r5
 1014a52:	f003 f91a 	bl	1017c8a <work_cancel>
		/* -EALREADY indicates the work has already completed so this
		 * is likely a recurring work.
		 */
		if (err == -EALREADY) {
 1014a56:	f110 0f45 	cmn.w	r0, #69	; 0x45
		err = work_cancel(work);
 1014a5a:	4604      	mov	r4, r0
		if (err == -EALREADY) {
 1014a5c:	d008      	beq.n	1014a70 <k_delayed_work_submit_to_queue+0x44>
			err = 0;
		} else if (err < 0) {
 1014a5e:	2800      	cmp	r0, #0
 1014a60:	da07      	bge.n	1014a72 <k_delayed_work_submit_to_queue+0x46>
	__asm__ volatile(
 1014a62:	f387 8811 	msr	BASEPRI, r7
 1014a66:	f3bf 8f6f 	isb	sy
	/* Add timeout */
	z_add_timeout(&work->timeout, work_timeout, delay);

done:
	k_spin_unlock(&lock, key);
	return err;
 1014a6a:	e00f      	b.n	1014a8c <k_delayed_work_submit_to_queue+0x60>
	if (work->work_q == work_q) {
 1014a6c:	2800      	cmp	r0, #0
 1014a6e:	d0ef      	beq.n	1014a50 <k_delayed_work_submit_to_queue+0x24>
	int err = 0;
 1014a70:	2400      	movs	r4, #0
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 1014a72:	ea58 0309 	orrs.w	r3, r8, r9
	work->work_q = work_q;
 1014a76:	61ee      	str	r6, [r5, #28]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 1014a78:	d10b      	bne.n	1014a92 <k_delayed_work_submit_to_queue+0x66>
 1014a7a:	f387 8811 	msr	BASEPRI, r7
 1014a7e:	f3bf 8f6f 	isb	sy
		k_work_submit_to_queue(work_q, &work->work);
 1014a82:	4629      	mov	r1, r5
 1014a84:	4630      	mov	r0, r6
 1014a86:	f003 f8e7 	bl	1017c58 <k_work_submit_to_queue>
		return 0;
 1014a8a:	2400      	movs	r4, #0
}
 1014a8c:	4620      	mov	r0, r4
 1014a8e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	z_add_timeout(&work->timeout, work_timeout, delay);
 1014a92:	4642      	mov	r2, r8
 1014a94:	464b      	mov	r3, r9
 1014a96:	4904      	ldr	r1, [pc, #16]	; (1014aa8 <k_delayed_work_submit_to_queue+0x7c>)
 1014a98:	f105 000c 	add.w	r0, r5, #12
 1014a9c:	f000 f840 	bl	1014b20 <z_add_timeout>
 1014aa0:	e7df      	b.n	1014a62 <k_delayed_work_submit_to_queue+0x36>
		err = -EADDRINUSE;
 1014aa2:	f06f 042f 	mvn.w	r4, #47	; 0x2f
 1014aa6:	e7dc      	b.n	1014a62 <k_delayed_work_submit_to_queue+0x36>
 1014aa8:	01017c81 	.word	0x01017c81

01014aac <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
 1014aac:	4b03      	ldr	r3, [pc, #12]	; (1014abc <elapsed+0x10>)
 1014aae:	681b      	ldr	r3, [r3, #0]
 1014ab0:	b90b      	cbnz	r3, 1014ab6 <elapsed+0xa>
 1014ab2:	f7f0 b853 	b.w	1004b5c <z_clock_elapsed>
}
 1014ab6:	2000      	movs	r0, #0
 1014ab8:	4770      	bx	lr
 1014aba:	bf00      	nop
 1014abc:	21008054 	.word	0x21008054

01014ac0 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 1014ac0:	6803      	ldr	r3, [r0, #0]
 1014ac2:	b140      	cbz	r0, 1014ad6 <remove_timeout+0x16>
 1014ac4:	4a07      	ldr	r2, [pc, #28]	; (1014ae4 <remove_timeout+0x24>)
	return (node == list->tail) ? NULL : node->next;
 1014ac6:	6852      	ldr	r2, [r2, #4]
 1014ac8:	4290      	cmp	r0, r2
 1014aca:	d004      	beq.n	1014ad6 <remove_timeout+0x16>
	if (next(t) != NULL) {
 1014acc:	b11b      	cbz	r3, 1014ad6 <remove_timeout+0x16>
		next(t)->dticks += t->dticks;
 1014ace:	689a      	ldr	r2, [r3, #8]
 1014ad0:	6881      	ldr	r1, [r0, #8]
 1014ad2:	440a      	add	r2, r1
 1014ad4:	609a      	str	r2, [r3, #8]
	node->prev->next = node->next;
 1014ad6:	6842      	ldr	r2, [r0, #4]
 1014ad8:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
 1014ada:	605a      	str	r2, [r3, #4]
	node->next = NULL;
 1014adc:	2300      	movs	r3, #0
	node->prev = NULL;
 1014ade:	e9c0 3300 	strd	r3, r3, [r0]
}
 1014ae2:	4770      	bx	lr
 1014ae4:	210004f8 	.word	0x210004f8

01014ae8 <next_timeout>:
	return list->head == list;
 1014ae8:	4b0b      	ldr	r3, [pc, #44]	; (1014b18 <next_timeout+0x30>)

static s32_t next_timeout(void)
{
 1014aea:	b510      	push	{r4, lr}
 1014aec:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1014aee:	429c      	cmp	r4, r3
 1014af0:	bf08      	it	eq
 1014af2:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	s32_t ticks_elapsed = elapsed();
 1014af4:	f7ff ffda 	bl	1014aac <elapsed>
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
 1014af8:	b154      	cbz	r4, 1014b10 <next_timeout+0x28>
 1014afa:	68a3      	ldr	r3, [r4, #8]
 1014afc:	1a18      	subs	r0, r3, r0
 1014afe:	ea20 70e0 	bic.w	r0, r0, r0, asr #31

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
 1014b02:	4b06      	ldr	r3, [pc, #24]	; (1014b1c <next_timeout+0x34>)
 1014b04:	691b      	ldr	r3, [r3, #16]
 1014b06:	b113      	cbz	r3, 1014b0e <next_timeout+0x26>
 1014b08:	4298      	cmp	r0, r3
 1014b0a:	bfa8      	it	ge
 1014b0c:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
 1014b0e:	bd10      	pop	{r4, pc}
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
 1014b10:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
 1014b14:	e7f5      	b.n	1014b02 <next_timeout+0x1a>
 1014b16:	bf00      	nop
 1014b18:	210004f8 	.word	0x210004f8
 1014b1c:	21007f8c 	.word	0x21007f8c

01014b20 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
 1014b20:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1014b24:	9101      	str	r1, [sp, #4]
 1014b26:	4619      	mov	r1, r3
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 1014b28:	1c4b      	adds	r3, r1, #1
 1014b2a:	bf08      	it	eq
 1014b2c:	f1b2 3fff 	cmpeq.w	r2, #4294967295
{
 1014b30:	4682      	mov	sl, r0
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 1014b32:	d061      	beq.n	1014bf8 <z_add_timeout+0xd8>
#ifdef CONFIG_LEGACY_TIMEOUT_API
	k_ticks_t ticks = timeout;
#else
	k_ticks_t ticks = timeout.ticks + 1;

	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
 1014b34:	f06f 0301 	mvn.w	r3, #1
 1014b38:	f04f 3bff 	mov.w	fp, #4294967295
	k_ticks_t ticks = timeout.ticks + 1;
 1014b3c:	1c54      	adds	r4, r2, #1
 1014b3e:	f141 0500 	adc.w	r5, r1, #0
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
 1014b42:	ebb3 0804 	subs.w	r8, r3, r4
 1014b46:	eb6b 0905 	sbc.w	r9, fp, r5
 1014b4a:	f1b8 0f00 	cmp.w	r8, #0
 1014b4e:	f179 0300 	sbcs.w	r3, r9, #0
 1014b52:	db0f      	blt.n	1014b74 <z_add_timeout+0x54>
		ticks = Z_TICK_ABS(ticks) - (curr_tick + elapsed());
 1014b54:	f7ff ffaa 	bl	1014aac <elapsed>
 1014b58:	f06f 0301 	mvn.w	r3, #1
 1014b5c:	4a2b      	ldr	r2, [pc, #172]	; (1014c0c <z_add_timeout+0xec>)
 1014b5e:	e9d2 1c00 	ldrd	r1, ip, [r2]
 1014b62:	1a5b      	subs	r3, r3, r1
 1014b64:	eb6b 020c 	sbc.w	r2, fp, ip
 1014b68:	1b1e      	subs	r6, r3, r4
 1014b6a:	eb62 0705 	sbc.w	r7, r2, r5
 1014b6e:	1a34      	subs	r4, r6, r0
 1014b70:	eb67 75e0 	sbc.w	r5, r7, r0, asr #31
	}
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
 1014b74:	9b01      	ldr	r3, [sp, #4]
 1014b76:	f8ca 300c 	str.w	r3, [sl, #12]
	__asm__ volatile(
 1014b7a:	f04f 0320 	mov.w	r3, #32
 1014b7e:	f3ef 8611 	mrs	r6, BASEPRI
 1014b82:	f383 8811 	msr	BASEPRI, r3
 1014b86:	f3bf 8f6f 	isb	sy
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
 1014b8a:	f7ff ff8f 	bl	1014aac <elapsed>
	ticks = MAX(1, ticks);
 1014b8e:	2c01      	cmp	r4, #1
 1014b90:	f175 0300 	sbcs.w	r3, r5, #0
 1014b94:	bfb8      	it	lt
 1014b96:	2401      	movlt	r4, #1
	return list->head == list;
 1014b98:	4b1d      	ldr	r3, [pc, #116]	; (1014c10 <z_add_timeout+0xf0>)
		to->dticks = ticks + elapsed();
 1014b9a:	4404      	add	r4, r0
 1014b9c:	681a      	ldr	r2, [r3, #0]
 1014b9e:	f8ca 4008 	str.w	r4, [sl, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1014ba2:	429a      	cmp	r2, r3
 1014ba4:	d001      	beq.n	1014baa <z_add_timeout+0x8a>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 1014ba6:	685c      	ldr	r4, [r3, #4]
		for (t = first(); t != NULL; t = next(t)) {
 1014ba8:	b952      	cbnz	r2, 1014bc0 <z_add_timeout+0xa0>
	node->prev = list->tail;
 1014baa:	685a      	ldr	r2, [r3, #4]
	node->next = list;
 1014bac:	f8ca 3000 	str.w	r3, [sl]
	node->prev = list->tail;
 1014bb0:	f8ca 2004 	str.w	r2, [sl, #4]
	list->tail->next = node;
 1014bb4:	685a      	ldr	r2, [r3, #4]
 1014bb6:	f8c2 a000 	str.w	sl, [r2]
	list->tail = node;
 1014bba:	f8c3 a004 	str.w	sl, [r3, #4]
}
 1014bbe:	e00d      	b.n	1014bdc <z_add_timeout+0xbc>
			__ASSERT(t->dticks >= 0, "");

			if (t->dticks > to->dticks) {
 1014bc0:	6890      	ldr	r0, [r2, #8]
 1014bc2:	f8da 1008 	ldr.w	r1, [sl, #8]
 1014bc6:	4288      	cmp	r0, r1
 1014bc8:	dd19      	ble.n	1014bfe <z_add_timeout+0xde>
				t->dticks -= to->dticks;
 1014bca:	1a41      	subs	r1, r0, r1
 1014bcc:	6091      	str	r1, [r2, #8]
	node->prev = successor->prev;
 1014bce:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
 1014bd0:	e9ca 2100 	strd	r2, r1, [sl]
	successor->prev->next = node;
 1014bd4:	f8c1 a000 	str.w	sl, [r1]
	successor->prev = node;
 1014bd8:	f8c2 a004 	str.w	sl, [r2, #4]
	return list->head == list;
 1014bdc:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1014bde:	429a      	cmp	r2, r3
 1014be0:	d006      	beq.n	1014bf0 <z_add_timeout+0xd0>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
 1014be2:	4592      	cmp	sl, r2
 1014be4:	d104      	bne.n	1014bf0 <z_add_timeout+0xd0>
			z_clock_set_timeout(next_timeout(), false);
 1014be6:	f7ff ff7f 	bl	1014ae8 <next_timeout>
 1014bea:	2100      	movs	r1, #0
 1014bec:	f7ef ff52 	bl	1004a94 <z_clock_set_timeout>
	__asm__ volatile(
 1014bf0:	f386 8811 	msr	BASEPRI, r6
 1014bf4:	f3bf 8f6f 	isb	sy
		}
	}
}
 1014bf8:	b003      	add	sp, #12
 1014bfa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			to->dticks -= t->dticks;
 1014bfe:	1a09      	subs	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
 1014c00:	4294      	cmp	r4, r2
 1014c02:	f8ca 1008 	str.w	r1, [sl, #8]
 1014c06:	d0d0      	beq.n	1014baa <z_add_timeout+0x8a>
 1014c08:	6812      	ldr	r2, [r2, #0]
 1014c0a:	e7cd      	b.n	1014ba8 <z_add_timeout+0x88>
 1014c0c:	21000728 	.word	0x21000728
 1014c10:	210004f8 	.word	0x210004f8

01014c14 <z_clock_announce>:
		}
	}
}

void z_clock_announce(s32_t ticks)
{
 1014c14:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1014c18:	4606      	mov	r6, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
 1014c1a:	f7ff fbff 	bl	101441c <z_time_slice>
	__asm__ volatile(
 1014c1e:	f04f 0320 	mov.w	r3, #32
 1014c22:	f3ef 8411 	mrs	r4, BASEPRI
 1014c26:	f383 8811 	msr	BASEPRI, r3
 1014c2a:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
 1014c2e:	f8df 8084 	ldr.w	r8, [pc, #132]	; 1014cb4 <z_clock_announce+0xa0>
 1014c32:	4d1f      	ldr	r5, [pc, #124]	; (1014cb0 <z_clock_announce+0x9c>)
 1014c34:	46c1      	mov	r9, r8
	return list->head == list;
 1014c36:	f8df a080 	ldr.w	sl, [pc, #128]	; 1014cb8 <z_clock_announce+0xa4>
 1014c3a:	602e      	str	r6, [r5, #0]
 1014c3c:	f8da 0000 	ldr.w	r0, [sl]
 1014c40:	682a      	ldr	r2, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1014c42:	4550      	cmp	r0, sl
 1014c44:	e9d8 6700 	ldrd	r6, r7, [r8]
 1014c48:	d005      	beq.n	1014c56 <z_clock_announce+0x42>

	while (first() != NULL && first()->dticks <= announce_remaining) {
 1014c4a:	b120      	cbz	r0, 1014c56 <z_clock_announce+0x42>
 1014c4c:	6883      	ldr	r3, [r0, #8]
 1014c4e:	4293      	cmp	r3, r2
 1014c50:	dd13      	ble.n	1014c7a <z_clock_announce+0x66>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
 1014c52:	1a9b      	subs	r3, r3, r2
 1014c54:	6083      	str	r3, [r0, #8]
	}

	curr_tick += announce_remaining;
 1014c56:	18b6      	adds	r6, r6, r2
 1014c58:	eb47 77e2 	adc.w	r7, r7, r2, asr #31
 1014c5c:	e9c9 6700 	strd	r6, r7, [r9]
	announce_remaining = 0;
 1014c60:	2600      	movs	r6, #0
 1014c62:	602e      	str	r6, [r5, #0]

	z_clock_set_timeout(next_timeout(), false);
 1014c64:	f7ff ff40 	bl	1014ae8 <next_timeout>
 1014c68:	4631      	mov	r1, r6
 1014c6a:	f7ef ff13 	bl	1004a94 <z_clock_set_timeout>
	__asm__ volatile(
 1014c6e:	f384 8811 	msr	BASEPRI, r4
 1014c72:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
 1014c76:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		curr_tick += dt;
 1014c7a:	18f6      	adds	r6, r6, r3
 1014c7c:	eb47 77e3 	adc.w	r7, r7, r3, asr #31
		announce_remaining -= dt;
 1014c80:	1ad3      	subs	r3, r2, r3
 1014c82:	602b      	str	r3, [r5, #0]
		t->dticks = 0;
 1014c84:	2300      	movs	r3, #0
 1014c86:	6083      	str	r3, [r0, #8]
		curr_tick += dt;
 1014c88:	e9c8 6700 	strd	r6, r7, [r8]
		remove_timeout(t);
 1014c8c:	f7ff ff18 	bl	1014ac0 <remove_timeout>
 1014c90:	f384 8811 	msr	BASEPRI, r4
 1014c94:	f3bf 8f6f 	isb	sy
		t->fn(t);
 1014c98:	68c3      	ldr	r3, [r0, #12]
 1014c9a:	4798      	blx	r3
	__asm__ volatile(
 1014c9c:	f04f 0320 	mov.w	r3, #32
 1014ca0:	f3ef 8411 	mrs	r4, BASEPRI
 1014ca4:	f383 8811 	msr	BASEPRI, r3
 1014ca8:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
 1014cac:	e7c6      	b.n	1014c3c <z_clock_announce+0x28>
 1014cae:	bf00      	nop
 1014cb0:	21008054 	.word	0x21008054
 1014cb4:	21000728 	.word	0x21000728
 1014cb8:	210004f8 	.word	0x210004f8

01014cbc <z_tick_get>:

s64_t z_tick_get(void)
{
 1014cbc:	b510      	push	{r4, lr}
 1014cbe:	f04f 0320 	mov.w	r3, #32
 1014cc2:	f3ef 8411 	mrs	r4, BASEPRI
 1014cc6:	f383 8811 	msr	BASEPRI, r3
 1014cca:	f3bf 8f6f 	isb	sy
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
 1014cce:	f7ef ff45 	bl	1004b5c <z_clock_elapsed>
 1014cd2:	4b06      	ldr	r3, [pc, #24]	; (1014cec <z_tick_get+0x30>)
 1014cd4:	e9d3 2300 	ldrd	r2, r3, [r3]
 1014cd8:	1812      	adds	r2, r2, r0
 1014cda:	f143 0300 	adc.w	r3, r3, #0
	__asm__ volatile(
 1014cde:	f384 8811 	msr	BASEPRI, r4
 1014ce2:	f3bf 8f6f 	isb	sy
	}
	return t;
}
 1014ce6:	4610      	mov	r0, r2
 1014ce8:	4619      	mov	r1, r3
 1014cea:	bd10      	pop	{r4, pc}
 1014cec:	21000728 	.word	0x21000728

01014cf0 <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
 1014cf0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
 1014cf2:	e9d0 2308 	ldrd	r2, r3, [r0, #32]
 1014cf6:	1c56      	adds	r6, r2, #1
 1014cf8:	f143 0700 	adc.w	r7, r3, #0
 1014cfc:	2f00      	cmp	r7, #0
 1014cfe:	bf08      	it	eq
 1014d00:	2e02      	cmpeq	r6, #2
{
 1014d02:	4604      	mov	r4, r0
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
 1014d04:	d302      	bcc.n	1014d0c <z_timer_expiration_handler+0x1c>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
 1014d06:	490c      	ldr	r1, [pc, #48]	; (1014d38 <z_timer_expiration_handler+0x48>)
 1014d08:	f7ff ff0a 	bl	1014b20 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
 1014d0c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1014d0e:	3301      	adds	r3, #1
 1014d10:	62a3      	str	r3, [r4, #40]	; 0x28

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
 1014d12:	69a3      	ldr	r3, [r4, #24]
 1014d14:	b10b      	cbz	r3, 1014d1a <z_timer_expiration_handler+0x2a>
		timer->expiry_fn(timer);
 1014d16:	4620      	mov	r0, r4
 1014d18:	4798      	blx	r3
	return list->head == list;
 1014d1a:	f854 5f10 	ldr.w	r5, [r4, #16]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1014d1e:	42a5      	cmp	r5, r4
 1014d20:	d008      	beq.n	1014d34 <z_timer_expiration_handler+0x44>
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
 1014d22:	b13d      	cbz	r5, 1014d34 <z_timer_expiration_handler+0x44>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
 1014d24:	4628      	mov	r0, r5
 1014d26:	f002 fe6d 	bl	1017a04 <z_unpend_thread_no_timeout>

	z_ready_thread(thread);
 1014d2a:	4628      	mov	r0, r5
 1014d2c:	f002 fec7 	bl	1017abe <z_ready_thread>
 1014d30:	2300      	movs	r3, #0
 1014d32:	672b      	str	r3, [r5, #112]	; 0x70

	arch_thread_return_value_set(thread, 0);
}
 1014d34:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 1014d36:	bf00      	nop
 1014d38:	01014cf1 	.word	0x01014cf1

01014d3c <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
 1014d3c:	e92d 4df3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, sl, fp, lr}
 1014d40:	e9dd 450a 	ldrd	r4, r5, [sp, #40]	; 0x28
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (period.ticks != 0 && Z_TICK_ABS(period.ticks) < 0) {
 1014d44:	ea54 0105 	orrs.w	r1, r4, r5
{
 1014d48:	4680      	mov	r8, r0
 1014d4a:	4616      	mov	r6, r2
 1014d4c:	461f      	mov	r7, r3
	if (period.ticks != 0 && Z_TICK_ABS(period.ticks) < 0) {
 1014d4e:	d016      	beq.n	1014d7e <z_impl_k_timer_start+0x42>
 1014d50:	f06f 0101 	mvn.w	r1, #1
 1014d54:	ebb1 0a04 	subs.w	sl, r1, r4
 1014d58:	f04f 31ff 	mov.w	r1, #4294967295
 1014d5c:	eb61 0b05 	sbc.w	fp, r1, r5
 1014d60:	f1ba 0f00 	cmp.w	sl, #0
 1014d64:	f17b 0100 	sbcs.w	r1, fp, #0
 1014d68:	da09      	bge.n	1014d7e <z_impl_k_timer_start+0x42>
		period.ticks = MAX(period.ticks - 1, 1);
 1014d6a:	f114 34ff 	adds.w	r4, r4, #4294967295
 1014d6e:	f145 35ff 	adc.w	r5, r5, #4294967295
 1014d72:	2c01      	cmp	r4, #1
 1014d74:	f175 0100 	sbcs.w	r1, r5, #0
 1014d78:	bfbc      	itt	lt
 1014d7a:	2401      	movlt	r4, #1
 1014d7c:	2500      	movlt	r5, #0
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
 1014d7e:	f06f 0101 	mvn.w	r1, #1
 1014d82:	1a89      	subs	r1, r1, r2
 1014d84:	9100      	str	r1, [sp, #0]
 1014d86:	f04f 31ff 	mov.w	r1, #4294967295
 1014d8a:	eb61 0103 	sbc.w	r1, r1, r3
 1014d8e:	9101      	str	r1, [sp, #4]
 1014d90:	e9dd 0100 	ldrd	r0, r1, [sp]
 1014d94:	2800      	cmp	r0, #0
 1014d96:	f171 0100 	sbcs.w	r1, r1, #0
 1014d9a:	da09      	bge.n	1014db0 <z_impl_k_timer_start+0x74>
		duration.ticks = MAX(duration.ticks - 1, 0);
 1014d9c:	f112 36ff 	adds.w	r6, r2, #4294967295
 1014da0:	f143 37ff 	adc.w	r7, r3, #4294967295
 1014da4:	2e00      	cmp	r6, #0
 1014da6:	f177 0300 	sbcs.w	r3, r7, #0
 1014daa:	bfbc      	itt	lt
 1014dac:	2600      	movlt	r6, #0
 1014dae:	2700      	movlt	r7, #0
	}
#endif

	(void)z_abort_timeout(&timer->timeout);
 1014db0:	4640      	mov	r0, r8
 1014db2:	f002 ffca 	bl	1017d4a <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
 1014db6:	2300      	movs	r3, #0

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
 1014db8:	4632      	mov	r2, r6
	timer->status = 0U;
 1014dba:	f8c8 3028 	str.w	r3, [r8, #40]	; 0x28
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
 1014dbe:	4640      	mov	r0, r8
 1014dc0:	463b      	mov	r3, r7
 1014dc2:	4904      	ldr	r1, [pc, #16]	; (1014dd4 <z_impl_k_timer_start+0x98>)
	timer->period = period;
 1014dc4:	e9c8 4508 	strd	r4, r5, [r8, #32]
		     duration);
}
 1014dc8:	b002      	add	sp, #8
 1014dca:	e8bd 4df0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, fp, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
 1014dce:	f7ff bea7 	b.w	1014b20 <z_add_timeout>
 1014dd2:	bf00      	nop
 1014dd4:	01014cf1 	.word	0x01014cf1

01014dd8 <z_impl_k_poll>:
	return 0;
}

int z_impl_k_poll(struct k_poll_event *events, int num_events,
		  k_timeout_t timeout)
{
 1014dd8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1014ddc:	461f      	mov	r7, r3
	int events_registered;
	k_spinlock_key_t key;
	struct _poller poller = { .is_polling = true,
 1014dde:	2301      	movs	r3, #1
{
 1014de0:	b089      	sub	sp, #36	; 0x24
	struct _poller poller = { .is_polling = true,
 1014de2:	f88d 3014 	strb.w	r3, [sp, #20]
				  .thread     = _current,
 1014de6:	4b29      	ldr	r3, [pc, #164]	; (1014e8c <z_impl_k_poll+0xb4>)
{
 1014de8:	4616      	mov	r6, r2
	struct _poller poller = { .is_polling = true,
 1014dea:	689b      	ldr	r3, [r3, #8]
{
 1014dec:	4605      	mov	r5, r0
	struct _poller poller = { .is_polling = true,
 1014dee:	9306      	str	r3, [sp, #24]
 1014df0:	4b27      	ldr	r3, [pc, #156]	; (1014e90 <z_impl_k_poll+0xb8>)
 1014df2:	9307      	str	r3, [sp, #28]

	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(events != NULL, "NULL events\n");
	__ASSERT(num_events >= 0, "<0 events\n");

	events_registered = register_events(events, num_events, &poller,
 1014df4:	ea52 0307 	orrs.w	r3, r2, r7
 1014df8:	bf0c      	ite	eq
 1014dfa:	2301      	moveq	r3, #1
 1014dfc:	2300      	movne	r3, #0
 1014dfe:	aa05      	add	r2, sp, #20
 1014e00:	f003 f8d6 	bl	1017fb0 <register_events>
 1014e04:	4680      	mov	r8, r0
	__asm__ volatile(
 1014e06:	f04f 0320 	mov.w	r3, #32
 1014e0a:	f3ef 8911 	mrs	r9, BASEPRI
 1014e0e:	f383 8811 	msr	BASEPRI, r3
 1014e12:	f3bf 8f6f 	isb	sy
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller.is_polling) {
 1014e16:	f89d 3014 	ldrb.w	r3, [sp, #20]
 1014e1a:	f003 04ff 	and.w	r4, r3, #255	; 0xff
 1014e1e:	b963      	cbnz	r3, 1014e3a <z_impl_k_poll+0x62>
		clear_event_registrations(events, events_registered, key);
 1014e20:	4601      	mov	r1, r0
 1014e22:	464a      	mov	r2, r9
 1014e24:	4628      	mov	r0, r5
 1014e26:	f003 f82d 	bl	1017e84 <clear_event_registrations>
	__asm__ volatile(
 1014e2a:	f389 8811 	msr	BASEPRI, r9
 1014e2e:	f3bf 8f6f 	isb	sy
	key = k_spin_lock(&lock);
	clear_event_registrations(events, events_registered, key);
	k_spin_unlock(&lock, key);

	return swap_rc;
}
 1014e32:	4620      	mov	r0, r4
 1014e34:	b009      	add	sp, #36	; 0x24
 1014e36:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	poller.is_polling = false;
 1014e3a:	2300      	movs	r3, #0
 1014e3c:	f88d 3014 	strb.w	r3, [sp, #20]
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 1014e40:	ea56 0307 	orrs.w	r3, r6, r7
 1014e44:	d106      	bne.n	1014e54 <z_impl_k_poll+0x7c>
 1014e46:	f389 8811 	msr	BASEPRI, r9
 1014e4a:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
 1014e4e:	f06f 040a 	mvn.w	r4, #10
 1014e52:	e7ee      	b.n	1014e32 <z_impl_k_poll+0x5a>
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
 1014e54:	aa03      	add	r2, sp, #12
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
 1014e56:	4649      	mov	r1, r9
 1014e58:	e9cd 6700 	strd	r6, r7, [sp]
 1014e5c:	480d      	ldr	r0, [pc, #52]	; (1014e94 <z_impl_k_poll+0xbc>)
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
 1014e5e:	e9cd 2203 	strd	r2, r2, [sp, #12]
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
 1014e62:	f7ff fc0f 	bl	1014684 <z_pend_curr>
 1014e66:	4604      	mov	r4, r0
	__asm__ volatile(
 1014e68:	f04f 0320 	mov.w	r3, #32
 1014e6c:	f3ef 8611 	mrs	r6, BASEPRI
 1014e70:	f383 8811 	msr	BASEPRI, r3
 1014e74:	f3bf 8f6f 	isb	sy
	clear_event_registrations(events, events_registered, key);
 1014e78:	4632      	mov	r2, r6
 1014e7a:	4641      	mov	r1, r8
 1014e7c:	4628      	mov	r0, r5
 1014e7e:	f003 f801 	bl	1017e84 <clear_event_registrations>
	__asm__ volatile(
 1014e82:	f386 8811 	msr	BASEPRI, r6
 1014e86:	f3bf 8f6f 	isb	sy
	return swap_rc;
 1014e8a:	e7d2      	b.n	1014e32 <z_impl_k_poll+0x5a>
 1014e8c:	21007f8c 	.word	0x21007f8c
 1014e90:	01017f11 	.word	0x01017f11
 1014e94:	210080d1 	.word	0x210080d1

01014e98 <z_impl_k_poll_signal_raise>:
}
#include <syscalls/k_poll_signal_check_mrsh.c>
#endif

int z_impl_k_poll_signal_raise(struct k_poll_signal *signal, int result)
{
 1014e98:	b538      	push	{r3, r4, r5, lr}
 1014e9a:	4603      	mov	r3, r0
	__asm__ volatile(
 1014e9c:	f04f 0220 	mov.w	r2, #32
 1014ea0:	f3ef 8511 	mrs	r5, BASEPRI
 1014ea4:	f382 8811 	msr	BASEPRI, r2
 1014ea8:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_poll_event *poll_event;

	signal->result = result;
 1014eac:	60c1      	str	r1, [r0, #12]
	signal->signaled = 1U;
 1014eae:	2101      	movs	r1, #1
 1014eb0:	6081      	str	r1, [r0, #8]
	return list->head == list;
 1014eb2:	6800      	ldr	r0, [r0, #0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
 1014eb4:	4283      	cmp	r3, r0
 1014eb6:	d106      	bne.n	1014ec6 <z_impl_k_poll_signal_raise+0x2e>
	__asm__ volatile(
 1014eb8:	f385 8811 	msr	BASEPRI, r5
 1014ebc:	f3bf 8f6f 	isb	sy

	poll_event = (struct k_poll_event *)sys_dlist_get(&signal->poll_events);
	if (poll_event == NULL) {
		k_spin_unlock(&lock, key);
		return 0;
 1014ec0:	2400      	movs	r4, #0

	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);

	z_reschedule(&lock, key);
	return rc;
}
 1014ec2:	4620      	mov	r0, r4
 1014ec4:	bd38      	pop	{r3, r4, r5, pc}
	node->prev->next = node->next;
 1014ec6:	e9d0 3200 	ldrd	r3, r2, [r0]
 1014eca:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
 1014ecc:	605a      	str	r2, [r3, #4]
	node->next = NULL;
 1014ece:	2300      	movs	r3, #0
	node->prev = NULL;
 1014ed0:	e9c0 3300 	strd	r3, r3, [r0]
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
 1014ed4:	f003 f801 	bl	1017eda <signal_poll_event>
	z_reschedule(&lock, key);
 1014ed8:	4629      	mov	r1, r5
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
 1014eda:	4604      	mov	r4, r0
	z_reschedule(&lock, key);
 1014edc:	4801      	ldr	r0, [pc, #4]	; (1014ee4 <z_impl_k_poll_signal_raise+0x4c>)
 1014ede:	f002 fdaa 	bl	1017a36 <z_reschedule>
	return rc;
 1014ee2:	e7ee      	b.n	1014ec2 <z_impl_k_poll_signal_raise+0x2a>
 1014ee4:	210080d1 	.word	0x210080d1

01014ee8 <virtio_get_features>:
}
 1014ee8:	2001      	movs	r0, #1
 1014eea:	4770      	bx	lr

01014eec <rpmsg_service_unbind>:
	rpmsg_destroy_ept(ep);
 1014eec:	f002 bb02 	b.w	10174f4 <rpmsg_destroy_ept>

01014ef0 <arch_printk_char_out>:
}
 1014ef0:	2000      	movs	r0, #0
 1014ef2:	4770      	bx	lr

01014ef4 <print_err>:
{
 1014ef4:	b570      	push	{r4, r5, r6, lr}
 1014ef6:	460d      	mov	r5, r1
 1014ef8:	4604      	mov	r4, r0
	out('E', ctx);
 1014efa:	2045      	movs	r0, #69	; 0x45
 1014efc:	47a0      	blx	r4
	out('R', ctx);
 1014efe:	4629      	mov	r1, r5
 1014f00:	2052      	movs	r0, #82	; 0x52
 1014f02:	47a0      	blx	r4
	out('R', ctx);
 1014f04:	4629      	mov	r1, r5
 1014f06:	4623      	mov	r3, r4
}
 1014f08:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	out('R', ctx);
 1014f0c:	2052      	movs	r0, #82	; 0x52
 1014f0e:	4718      	bx	r3

01014f10 <str_out>:
{
 1014f10:	b530      	push	{r4, r5, lr}
 1014f12:	688a      	ldr	r2, [r1, #8]
	if (ctx->str == NULL || ctx->count >= ctx->max) {
 1014f14:	680c      	ldr	r4, [r1, #0]
 1014f16:	1c55      	adds	r5, r2, #1
 1014f18:	b114      	cbz	r4, 1014f20 <str_out+0x10>
 1014f1a:	684b      	ldr	r3, [r1, #4]
 1014f1c:	4293      	cmp	r3, r2
 1014f1e:	dc01      	bgt.n	1014f24 <str_out+0x14>
		ctx->count++;
 1014f20:	608d      	str	r5, [r1, #8]
}
 1014f22:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
 1014f24:	3b01      	subs	r3, #1
 1014f26:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
 1014f28:	bf08      	it	eq
 1014f2a:	2200      	moveq	r2, #0
 1014f2c:	608d      	str	r5, [r1, #8]
 1014f2e:	bf0c      	ite	eq
 1014f30:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
 1014f32:	54a0      	strbne	r0, [r4, r2]
 1014f34:	e7f5      	b.n	1014f22 <str_out+0x12>

01014f36 <printk>:
{
 1014f36:	b40f      	push	{r0, r1, r2, r3}
 1014f38:	b507      	push	{r0, r1, r2, lr}
 1014f3a:	a904      	add	r1, sp, #16
 1014f3c:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
 1014f40:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
 1014f42:	f7ee ff01 	bl	1003d48 <vprintk>
}
 1014f46:	b003      	add	sp, #12
 1014f48:	f85d eb04 	ldr.w	lr, [sp], #4
 1014f4c:	b004      	add	sp, #16
 1014f4e:	4770      	bx	lr

01014f50 <snprintk>:
{
 1014f50:	b40c      	push	{r2, r3}
 1014f52:	b507      	push	{r0, r1, r2, lr}
 1014f54:	ab04      	add	r3, sp, #16
 1014f56:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
 1014f5a:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
 1014f5c:	f7ee ff02 	bl	1003d64 <vsnprintk>
}
 1014f60:	b003      	add	sp, #12
 1014f62:	f85d eb04 	ldr.w	lr, [sp], #4
 1014f66:	b002      	add	sp, #8
 1014f68:	4770      	bx	lr

01014f6a <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
 1014f6a:	4604      	mov	r4, r0
 1014f6c:	b508      	push	{r3, lr}
 1014f6e:	4608      	mov	r0, r1
 1014f70:	4611      	mov	r1, r2
	entry(p1, p2, p3);
 1014f72:	461a      	mov	r2, r3
 1014f74:	47a0      	blx	r4
	return z_impl_k_current_get();
 1014f76:	f7ff fc11 	bl	101479c <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
 1014f7a:	f7f0 fa9f 	bl	10054bc <z_impl_k_thread_abort>

01014f7e <z_work_q_main>:

#include <kernel.h>
#define WORKQUEUE_THREAD_NAME	"workqueue"

void z_work_q_main(void *work_q_ptr, void *p2, void *p3)
{
 1014f7e:	b510      	push	{r4, lr}
 1014f80:	4604      	mov	r4, r0
	return z_impl_k_queue_get(queue, timeout);
 1014f82:	f04f 33ff 	mov.w	r3, #4294967295
 1014f86:	f04f 32ff 	mov.w	r2, #4294967295
 1014f8a:	4620      	mov	r0, r4
 1014f8c:	f7ff f8d6 	bl	101413c <z_impl_k_queue_get>
 1014f90:	4603      	mov	r3, r0
	while (true) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_queue_get(&work_q->queue, K_FOREVER);
		if (work == NULL) {
 1014f92:	2800      	cmp	r0, #0
 1014f94:	d0f5      	beq.n	1014f82 <z_work_q_main+0x4>
			continue;
		}

		handler = work->handler;
 1014f96:	6842      	ldr	r2, [r0, #4]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 1014f98:	3308      	adds	r3, #8
 1014f9a:	e8d3 1fef 	ldaex	r1, [r3]
 1014f9e:	f021 0c01 	bic.w	ip, r1, #1
 1014fa2:	e8c3 cfee 	stlex	lr, ip, [r3]
 1014fa6:	f1be 0f00 	cmp.w	lr, #0
 1014faa:	d1f6      	bne.n	1014f9a <z_work_q_main+0x1c>

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
 1014fac:	07cb      	lsls	r3, r1, #31
 1014fae:	d500      	bpl.n	1014fb2 <z_work_q_main+0x34>
					      K_WORK_STATE_PENDING)) {
			handler(work);
 1014fb0:	4790      	blx	r2
	z_impl_k_yield();
 1014fb2:	f7ff fb87 	bl	10146c4 <z_impl_k_yield>
 1014fb6:	e7e4      	b.n	1014f82 <z_work_q_main+0x4>

01014fb8 <chunk_field>:
}

static inline size_t chunk_field(struct z_heap *h, chunkid_t c,
				 enum chunk_fields f)
{
	void *cmem = &h->buf[c];
 1014fb8:	6803      	ldr	r3, [r0, #0]
 1014fba:	eb03 01c1 	add.w	r1, r3, r1, lsl #3

	if (big_heap(h)) {
 1014fbe:	6883      	ldr	r3, [r0, #8]
 1014fc0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
		return ((u32_t *)cmem)[f];
 1014fc4:	bf2c      	ite	cs
 1014fc6:	f851 0022 	ldrcs.w	r0, [r1, r2, lsl #2]
	} else {
		return ((u16_t *)cmem)[f];
 1014fca:	f831 0012 	ldrhcc.w	r0, [r1, r2, lsl #1]
	}
}
 1014fce:	4770      	bx	lr

01014fd0 <chunk_set>:

static inline void chunk_set(struct z_heap *h, chunkid_t c,
			     enum chunk_fields f, chunkid_t val)
{
 1014fd0:	b510      	push	{r4, lr}
	CHECK(c >= h->chunk0 && c < h->len);
	CHECK((val & ~((h->size_mask << 1) + 1)) == 0);
	CHECK((val & h->size_mask) < h->len);

	void *cmem = &h->buf[c];
 1014fd2:	6804      	ldr	r4, [r0, #0]

	if (big_heap(h)) {
 1014fd4:	6880      	ldr	r0, [r0, #8]
	void *cmem = &h->buf[c];
 1014fd6:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
	if (big_heap(h)) {
 1014fda:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
		((u32_t *)cmem)[f] = (u32_t) val;
 1014fde:	bf2c      	ite	cs
 1014fe0:	f841 3022 	strcs.w	r3, [r1, r2, lsl #2]
	} else {
		((u16_t *)cmem)[f] = (u16_t) val;
 1014fe4:	f821 3012 	strhcc.w	r3, [r1, r2, lsl #1]
	}
}
 1014fe8:	bd10      	pop	{r4, pc}

01014fea <right_chunk>:
{
	return c - left_size(h, c);
}

static inline chunkid_t right_chunk(struct z_heap *h, chunkid_t c)
{
 1014fea:	b538      	push	{r3, r4, r5, lr}
 1014fec:	4605      	mov	r5, r0
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 1014fee:	2200      	movs	r2, #0
{
 1014ff0:	460c      	mov	r4, r1
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 1014ff2:	f7ff ffe1 	bl	1014fb8 <chunk_field>
 1014ff6:	68eb      	ldr	r3, [r5, #12]
 1014ff8:	4018      	ands	r0, r3
	return c + size(h, c);
}
 1014ffa:	4420      	add	r0, r4
 1014ffc:	bd38      	pop	{r3, r4, r5, pc}

01014ffe <free_list_remove>:
	return ret;
}

static void free_list_remove(struct z_heap *h, int bidx,
			     chunkid_t c)
{
 1014ffe:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct z_heap_bucket *b = &h->buckets[bidx];
 1015002:	f8d0 8004 	ldr.w	r8, [r0, #4]
{
 1015006:	4616      	mov	r6, r2
	struct z_heap_bucket *b = &h->buckets[bidx];
 1015008:	eb08 02c1 	add.w	r2, r8, r1, lsl #3
	CHECK(b->next != 0);
	CHECK(b->list_size > 0);
	CHECK((((h->avail_buckets & (1 << bidx)) == 0)
	       == (h->buckets[bidx].next == 0)));

	b->list_size--;
 101500c:	6853      	ldr	r3, [r2, #4]
{
 101500e:	4604      	mov	r4, r0
	b->list_size--;
 1015010:	3b01      	subs	r3, #1
{
 1015012:	460d      	mov	r5, r1
	b->list_size--;
 1015014:	6053      	str	r3, [r2, #4]

	if (b->list_size == 0) {
 1015016:	b953      	cbnz	r3, 101502e <free_list_remove+0x30>
		h->avail_buckets &= ~(1 << bidx);
 1015018:	2201      	movs	r2, #1
 101501a:	fa02 f101 	lsl.w	r1, r2, r1
 101501e:	6942      	ldr	r2, [r0, #20]
 1015020:	ea22 0201 	bic.w	r2, r2, r1
 1015024:	6142      	str	r2, [r0, #20]
		b->next = 0;
 1015026:	f848 3035 	str.w	r3, [r8, r5, lsl #3]

		b->next = second;
		chunk_set(h, first, FREE_NEXT, second);
		chunk_set(h, second, FREE_PREV, first);
	}
}
 101502a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return chunk_field(h, c, FREE_PREV);
 101502e:	4631      	mov	r1, r6
 1015030:	2202      	movs	r2, #2
 1015032:	f7ff ffc1 	bl	1014fb8 <chunk_field>
	return chunk_field(h, c, FREE_NEXT);
 1015036:	4631      	mov	r1, r6
	return chunk_field(h, c, FREE_PREV);
 1015038:	4607      	mov	r7, r0
	return chunk_field(h, c, FREE_NEXT);
 101503a:	2203      	movs	r2, #3
 101503c:	4620      	mov	r0, r4
 101503e:	f7ff ffbb 	bl	1014fb8 <chunk_field>
 1015042:	4606      	mov	r6, r0
		chunk_set(h, first, FREE_NEXT, second);
 1015044:	4603      	mov	r3, r0
 1015046:	4639      	mov	r1, r7
		b->next = second;
 1015048:	f848 0035 	str.w	r0, [r8, r5, lsl #3]
		chunk_set(h, first, FREE_NEXT, second);
 101504c:	2203      	movs	r2, #3
 101504e:	4620      	mov	r0, r4
 1015050:	f7ff ffbe 	bl	1014fd0 <chunk_set>
		chunk_set(h, second, FREE_PREV, first);
 1015054:	463b      	mov	r3, r7
 1015056:	4631      	mov	r1, r6
 1015058:	4620      	mov	r0, r4
}
 101505a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		chunk_set(h, second, FREE_PREV, first);
 101505e:	2202      	movs	r2, #2
 1015060:	f7ff bfb6 	b.w	1014fd0 <chunk_set>

01015064 <free_list_add>:

static void free_list_add(struct z_heap *h, chunkid_t c)
{
 1015064:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1015068:	4604      	mov	r4, r0
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 101506a:	2200      	movs	r2, #0
 101506c:	460d      	mov	r5, r1
 101506e:	f7ff ffa3 	bl	1014fb8 <chunk_field>
 1015072:	68e2      	ldr	r2, [r4, #12]
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 1015074:	68a3      	ldr	r3, [r4, #8]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 1015076:	4010      	ands	r0, r2
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 1015078:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
}

static int bucket_idx(struct z_heap *h, size_t sz)
{
	/* A chunk of size 2 is the minimum size on big heaps */
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
 101507c:	fab0 f280 	clz	r2, r0
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 1015080:	bf34      	ite	cc
 1015082:	2000      	movcc	r0, #0
 1015084:	2001      	movcs	r0, #1
	int b = bucket_idx(h, size(h, c));

	if (h->buckets[b].list_size++ == 0) {
 1015086:	6863      	ldr	r3, [r4, #4]
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
 1015088:	f1c0 001f 	rsb	r0, r0, #31
 101508c:	1a80      	subs	r0, r0, r2
 101508e:	eb03 01c0 	add.w	r1, r3, r0, lsl #3
 1015092:	684a      	ldr	r2, [r1, #4]
 1015094:	1c56      	adds	r6, r2, #1
 1015096:	604e      	str	r6, [r1, #4]
 1015098:	b9a2      	cbnz	r2, 10150c4 <free_list_add+0x60>
		CHECK(h->buckets[b].next == 0);
		CHECK((h->avail_buckets & (1 << b)) == 0);

		/* Empty list, first item */
		h->avail_buckets |= (1 << b);
 101509a:	2201      	movs	r2, #1
 101509c:	fa02 f100 	lsl.w	r1, r2, r0
 10150a0:	6962      	ldr	r2, [r4, #20]
 10150a2:	430a      	orrs	r2, r1
 10150a4:	6162      	str	r2, [r4, #20]
		h->buckets[b].next = c;
		chunk_set(h, c, FREE_PREV, c);
 10150a6:	4629      	mov	r1, r5
		h->buckets[b].next = c;
 10150a8:	f843 5030 	str.w	r5, [r3, r0, lsl #3]
		chunk_set(h, c, FREE_PREV, c);
 10150ac:	2202      	movs	r2, #2
 10150ae:	462b      	mov	r3, r5
 10150b0:	4620      	mov	r0, r4
 10150b2:	f7ff ff8d 	bl	1014fd0 <chunk_set>
		chunk_set(h, c, FREE_NEXT, c);
 10150b6:	2203      	movs	r2, #3
 10150b8:	4629      	mov	r1, r5
		chunkid_t first = free_prev(h, second);

		chunk_set(h, c, FREE_PREV, first);
		chunk_set(h, c, FREE_NEXT, second);
		chunk_set(h, first, FREE_NEXT, c);
		chunk_set(h, second, FREE_PREV, c);
 10150ba:	4620      	mov	r0, r4
	}

	CHECK(h->avail_buckets & (1 << bucket_idx(h, size(h, c))));
}
 10150bc:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		chunk_set(h, second, FREE_PREV, c);
 10150c0:	f7ff bf86 	b.w	1014fd0 <chunk_set>
		chunkid_t second = h->buckets[b].next;
 10150c4:	f853 7030 	ldr.w	r7, [r3, r0, lsl #3]
	return chunk_field(h, c, FREE_PREV);
 10150c8:	2202      	movs	r2, #2
 10150ca:	4639      	mov	r1, r7
 10150cc:	4620      	mov	r0, r4
 10150ce:	f7ff ff73 	bl	1014fb8 <chunk_field>
 10150d2:	4606      	mov	r6, r0
		chunk_set(h, c, FREE_PREV, first);
 10150d4:	4603      	mov	r3, r0
 10150d6:	2202      	movs	r2, #2
 10150d8:	4629      	mov	r1, r5
 10150da:	4620      	mov	r0, r4
 10150dc:	f7ff ff78 	bl	1014fd0 <chunk_set>
		chunk_set(h, c, FREE_NEXT, second);
 10150e0:	463b      	mov	r3, r7
 10150e2:	2203      	movs	r2, #3
 10150e4:	4629      	mov	r1, r5
 10150e6:	4620      	mov	r0, r4
 10150e8:	f7ff ff72 	bl	1014fd0 <chunk_set>
		chunk_set(h, first, FREE_NEXT, c);
 10150ec:	2203      	movs	r2, #3
 10150ee:	4631      	mov	r1, r6
 10150f0:	462b      	mov	r3, r5
 10150f2:	4620      	mov	r0, r4
 10150f4:	f7ff ff6c 	bl	1014fd0 <chunk_set>
		chunk_set(h, second, FREE_PREV, c);
 10150f8:	2202      	movs	r2, #2
 10150fa:	4639      	mov	r1, r7
 10150fc:	e7dd      	b.n	10150ba <free_list_add+0x56>

010150fe <split_alloc>:

/* Allocates (fit check has already been perfomred) from the next
 * chunk at the specified bucket level
 */
static void *split_alloc(struct z_heap *h, int bidx, size_t sz)
{
 10150fe:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1015102:	4604      	mov	r4, r0
	CHECK(h->buckets[bidx].next != 0
	      && sz <= size(h, h->buckets[bidx].next));

	chunkid_t c = h->buckets[bidx].next;
 1015104:	6843      	ldr	r3, [r0, #4]
{
 1015106:	4617      	mov	r7, r2
	chunkid_t c = h->buckets[bidx].next;
 1015108:	f853 5031 	ldr.w	r5, [r3, r1, lsl #3]

	free_list_remove(h, bidx, c);
 101510c:	462a      	mov	r2, r5
 101510e:	f7ff ff76 	bl	1014ffe <free_list_remove>
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 1015112:	2200      	movs	r2, #0
 1015114:	4629      	mov	r1, r5
 1015116:	4620      	mov	r0, r4
 1015118:	f7ff ff4e 	bl	1014fb8 <chunk_field>
	/* Split off remainder if it's usefully large */
	size_t rem = size(h, c) - sz;

	CHECK(rem < h->len);

	if (rem >= (big_heap(h) ? 2 : 1)) {
 101511c:	68a3      	ldr	r3, [r4, #8]
 101511e:	68e6      	ldr	r6, [r4, #12]
 1015120:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 1015124:	bf2c      	ite	cs
 1015126:	2302      	movcs	r3, #2
 1015128:	2301      	movcc	r3, #1
 101512a:	4006      	ands	r6, r0
	size_t rem = size(h, c) - sz;
 101512c:	1bf6      	subs	r6, r6, r7
	if (rem >= (big_heap(h) ? 2 : 1)) {
 101512e:	42b3      	cmp	r3, r6
 1015130:	d82d      	bhi.n	101518e <split_alloc+0x90>
		chunkid_t c2 = c + sz;
		chunkid_t c3 = right_chunk(h, c);
 1015132:	4629      	mov	r1, r5
 1015134:	4620      	mov	r0, r4
 1015136:	f7ff ff58 	bl	1014fea <right_chunk>
		chunkid_t c2 = c + sz;
 101513a:	eb05 0807 	add.w	r8, r5, r7

		chunk_set(h, c, SIZE_AND_USED, sz);
 101513e:	463b      	mov	r3, r7
 1015140:	2200      	movs	r2, #0
 1015142:	4629      	mov	r1, r5
		chunkid_t c3 = right_chunk(h, c);
 1015144:	4681      	mov	r9, r0
		chunk_set(h, c, SIZE_AND_USED, sz);
 1015146:	4620      	mov	r0, r4
 1015148:	f7ff ff42 	bl	1014fd0 <chunk_set>
		chunk_set(h, c2, SIZE_AND_USED, rem);
 101514c:	4633      	mov	r3, r6
 101514e:	2200      	movs	r2, #0
 1015150:	4641      	mov	r1, r8
 1015152:	4620      	mov	r0, r4
 1015154:	f7ff ff3c 	bl	1014fd0 <chunk_set>
		chunk_set(h, c2, LEFT_SIZE, sz);
 1015158:	463b      	mov	r3, r7
 101515a:	2201      	movs	r2, #1
 101515c:	4641      	mov	r1, r8
 101515e:	4620      	mov	r0, r4
 1015160:	f7ff ff36 	bl	1014fd0 <chunk_set>
 1015164:	2200      	movs	r2, #0
 1015166:	4641      	mov	r1, r8
 1015168:	4620      	mov	r0, r4
 101516a:	f7ff ff25 	bl	1014fb8 <chunk_field>
 101516e:	68e3      	ldr	r3, [r4, #12]
		if (!last_chunk(h, c2)) {
 1015170:	68a2      	ldr	r2, [r4, #8]
 1015172:	4003      	ands	r3, r0
	return (c + size(h, c)) == h->len;
 1015174:	4443      	add	r3, r8
		if (!last_chunk(h, c2)) {
 1015176:	4293      	cmp	r3, r2
 1015178:	d005      	beq.n	1015186 <split_alloc+0x88>
			chunk_set(h, c3, LEFT_SIZE, rem);
 101517a:	4633      	mov	r3, r6
 101517c:	2201      	movs	r2, #1
 101517e:	4649      	mov	r1, r9
 1015180:	4620      	mov	r0, r4
 1015182:	f7ff ff25 	bl	1014fd0 <chunk_set>
		}
		free_list_add(h, c2);
 1015186:	4641      	mov	r1, r8
 1015188:	4620      	mov	r0, r4
 101518a:	f7ff ff6b 	bl	1015064 <free_list_add>
 101518e:	4629      	mov	r1, r5
 1015190:	2200      	movs	r2, #0
 1015192:	4620      	mov	r0, r4
 1015194:	f7ff ff10 	bl	1014fb8 <chunk_field>
 1015198:	68e2      	ldr	r2, [r4, #12]
	chunk_set(h, c, SIZE_AND_USED,
 101519a:	4629      	mov	r1, r5
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 101519c:	ea00 0302 	and.w	r3, r0, r2
		  size(h, c) | (used ? (h->size_mask + 1) : 0));
 10151a0:	3201      	adds	r2, #1
	chunk_set(h, c, SIZE_AND_USED,
 10151a2:	4620      	mov	r0, r4
 10151a4:	4313      	orrs	r3, r2
 10151a6:	2200      	movs	r2, #0
 10151a8:	f7ff ff12 	bl	1014fd0 <chunk_set>
	return big_heap(h) ? 8 : 4;
 10151ac:	68a3      	ldr	r3, [r4, #8]
	u8_t *ret = ((u8_t *)&h->buf[c]) + chunk_header_bytes(h);
 10151ae:	6820      	ldr	r0, [r4, #0]
 10151b0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 10151b4:	bf2c      	ite	cs
 10151b6:	2308      	movcs	r3, #8
 10151b8:	2304      	movcc	r3, #4
 10151ba:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
	}

	chunk_set_used(h, c, true);

	return chunk_mem(h, c);
}
 10151be:	4428      	add	r0, r5
 10151c0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

010151c4 <sys_heap_free>:

void sys_heap_free(struct sys_heap *heap, void *mem)
{
 10151c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (mem == NULL) {
 10151c8:	2900      	cmp	r1, #0
 10151ca:	f000 80ac 	beq.w	1015326 <sys_heap_free+0x162>
		return; /* ISO C free() semantics */
	}

	struct z_heap *h = heap->heap;
 10151ce:	6804      	ldr	r4, [r0, #0]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 10151d0:	2200      	movs	r2, #0
	return big_heap(h) ? 8 : 4;
 10151d2:	68a7      	ldr	r7, [r4, #8]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 10151d4:	4620      	mov	r0, r4
	return big_heap(h) ? 8 : 4;
 10151d6:	f5b7 4f00 	cmp.w	r7, #32768	; 0x8000
 10151da:	bf2c      	ite	cs
 10151dc:	2508      	movcs	r5, #8
 10151de:	2504      	movcc	r5, #4
	chunkid_t c = ((u8_t *)mem - chunk_header_bytes(h)
 10151e0:	1b4d      	subs	r5, r1, r5
		       - (u8_t *)h->buf) / CHUNK_UNIT;
 10151e2:	6821      	ldr	r1, [r4, #0]
 10151e4:	1a6d      	subs	r5, r5, r1
 10151e6:	bf48      	it	mi
 10151e8:	3507      	addmi	r5, #7
 10151ea:	10ed      	asrs	r5, r5, #3
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 10151ec:	4629      	mov	r1, r5
 10151ee:	f7ff fee3 	bl	1014fb8 <chunk_field>
 10151f2:	68e6      	ldr	r6, [r4, #12]
 10151f4:	ea06 0800 	and.w	r8, r6, r0
	return (c + size(h, c)) == h->len;
 10151f8:	eb05 0308 	add.w	r3, r5, r8

	/* Merge with right chunk?  We can just absorb it. */
	if (!last_chunk(h, c) && !used(h, right_chunk(h, c))) {
 10151fc:	42bb      	cmp	r3, r7
 10151fe:	d036      	beq.n	101526e <sys_heap_free+0xaa>
 1015200:	4629      	mov	r1, r5
 1015202:	4620      	mov	r0, r4
 1015204:	f7ff fef1 	bl	1014fea <right_chunk>
	return (chunk_field(h, c, SIZE_AND_USED) & ~h->size_mask) != 0;
 1015208:	2200      	movs	r2, #0
 101520a:	4601      	mov	r1, r0
 101520c:	4682      	mov	sl, r0
 101520e:	4620      	mov	r0, r4
 1015210:	f7ff fed2 	bl	1014fb8 <chunk_field>
 1015214:	ea30 0906 	bics.w	r9, r0, r6
 1015218:	d129      	bne.n	101526e <sys_heap_free+0xaa>
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 101521a:	f5b7 4f00 	cmp.w	r7, #32768	; 0x8000
 101521e:	bf34      	ite	cc
 1015220:	2700      	movcc	r7, #0
 1015222:	2701      	movcs	r7, #1
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 1015224:	4006      	ands	r6, r0
		chunkid_t rc = right_chunk(h, c);
		size_t newsz = size(h, c) + size(h, rc);
 1015226:	44b0      	add	r8, r6
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
 1015228:	fab6 f686 	clz	r6, r6
 101522c:	f1c7 071f 	rsb	r7, r7, #31

		free_list_remove(h, bucket_idx(h, size(h, rc)), rc);
 1015230:	4652      	mov	r2, sl
 1015232:	4620      	mov	r0, r4
 1015234:	1bb9      	subs	r1, r7, r6
 1015236:	f7ff fee2 	bl	1014ffe <free_list_remove>
		chunk_set(h, c, SIZE_AND_USED, newsz);
 101523a:	4643      	mov	r3, r8
 101523c:	464a      	mov	r2, r9
 101523e:	4629      	mov	r1, r5
 1015240:	4620      	mov	r0, r4
 1015242:	f7ff fec5 	bl	1014fd0 <chunk_set>
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 1015246:	4629      	mov	r1, r5
 1015248:	4620      	mov	r0, r4
 101524a:	f7ff feb5 	bl	1014fb8 <chunk_field>
 101524e:	68e3      	ldr	r3, [r4, #12]
 1015250:	4018      	ands	r0, r3
		if (!last_chunk(h, c)) {
 1015252:	68a3      	ldr	r3, [r4, #8]
	return (c + size(h, c)) == h->len;
 1015254:	4428      	add	r0, r5
		if (!last_chunk(h, c)) {
 1015256:	4283      	cmp	r3, r0
 1015258:	d009      	beq.n	101526e <sys_heap_free+0xaa>
			chunk_set(h, right_chunk(h, c), LEFT_SIZE, newsz);
 101525a:	4629      	mov	r1, r5
 101525c:	4620      	mov	r0, r4
 101525e:	f7ff fec4 	bl	1014fea <right_chunk>
 1015262:	4643      	mov	r3, r8
 1015264:	4601      	mov	r1, r0
 1015266:	2201      	movs	r2, #1
 1015268:	4620      	mov	r0, r4
 101526a:	f7ff feb1 	bl	1014fd0 <chunk_set>
		}
	}

	/* Merge with left chunk?  It absorbs us. */
	if (c != h->chunk0 && !used(h, left_chunk(h, c))) {
 101526e:	6923      	ldr	r3, [r4, #16]
 1015270:	42ab      	cmp	r3, r5
 1015272:	d046      	beq.n	1015302 <sys_heap_free+0x13e>
	return chunk_field(h, c, LEFT_SIZE);
 1015274:	2201      	movs	r2, #1
 1015276:	4629      	mov	r1, r5
 1015278:	4620      	mov	r0, r4
 101527a:	f7ff fe9d 	bl	1014fb8 <chunk_field>
	return c - left_size(h, c);
 101527e:	1a2f      	subs	r7, r5, r0
	return (chunk_field(h, c, SIZE_AND_USED) & ~h->size_mask) != 0;
 1015280:	2200      	movs	r2, #0
 1015282:	4639      	mov	r1, r7
 1015284:	4620      	mov	r0, r4
 1015286:	f7ff fe97 	bl	1014fb8 <chunk_field>
 101528a:	f8d4 800c 	ldr.w	r8, [r4, #12]
 101528e:	4606      	mov	r6, r0
 1015290:	ea30 0908 	bics.w	r9, r0, r8
 1015294:	d135      	bne.n	1015302 <sys_heap_free+0x13e>
 1015296:	464a      	mov	r2, r9
 1015298:	4629      	mov	r1, r5
 101529a:	4620      	mov	r0, r4
 101529c:	f7ff fe8c 	bl	1014fb8 <chunk_field>
 10152a0:	4682      	mov	sl, r0
		chunkid_t lc = left_chunk(h, c);
		chunkid_t rc = right_chunk(h, c);
 10152a2:	4629      	mov	r1, r5
 10152a4:	4620      	mov	r0, r4
 10152a6:	f7ff fea0 	bl	1014fea <right_chunk>
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 10152aa:	68a1      	ldr	r1, [r4, #8]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 10152ac:	ea06 0608 	and.w	r6, r6, r8
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 10152b0:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 10152b4:	bf34      	ite	cc
 10152b6:	2100      	movcc	r1, #0
 10152b8:	2101      	movcs	r1, #1
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 10152ba:	ea08 080a 	and.w	r8, r8, sl
		size_t csz = size(h, c);
		size_t merged_sz = csz + size(h, lc);
 10152be:	44b0      	add	r8, r6
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
 10152c0:	fab6 f686 	clz	r6, r6
 10152c4:	f1c1 011f 	rsb	r1, r1, #31

		free_list_remove(h, bucket_idx(h, size(h, lc)), lc);
 10152c8:	463a      	mov	r2, r7
 10152ca:	1b89      	subs	r1, r1, r6
		chunkid_t rc = right_chunk(h, c);
 10152cc:	4605      	mov	r5, r0
		free_list_remove(h, bucket_idx(h, size(h, lc)), lc);
 10152ce:	4620      	mov	r0, r4
 10152d0:	f7ff fe95 	bl	1014ffe <free_list_remove>
		chunk_set(h, lc, SIZE_AND_USED, merged_sz);
 10152d4:	4643      	mov	r3, r8
 10152d6:	464a      	mov	r2, r9
 10152d8:	4639      	mov	r1, r7
 10152da:	4620      	mov	r0, r4
 10152dc:	f7ff fe78 	bl	1014fd0 <chunk_set>
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 10152e0:	4639      	mov	r1, r7
 10152e2:	4620      	mov	r0, r4
 10152e4:	f7ff fe68 	bl	1014fb8 <chunk_field>
 10152e8:	68e3      	ldr	r3, [r4, #12]
 10152ea:	4018      	ands	r0, r3
		if (!last_chunk(h, lc)) {
 10152ec:	68a3      	ldr	r3, [r4, #8]
	return (c + size(h, c)) == h->len;
 10152ee:	4438      	add	r0, r7
		if (!last_chunk(h, lc)) {
 10152f0:	4298      	cmp	r0, r3
 10152f2:	d005      	beq.n	1015300 <sys_heap_free+0x13c>
			chunk_set(h, rc, LEFT_SIZE, merged_sz);
 10152f4:	4643      	mov	r3, r8
 10152f6:	2201      	movs	r2, #1
 10152f8:	4629      	mov	r1, r5
 10152fa:	4620      	mov	r0, r4
 10152fc:	f7ff fe68 	bl	1014fd0 <chunk_set>
		}

		c = lc;
 1015300:	463d      	mov	r5, r7
 1015302:	4629      	mov	r1, r5
 1015304:	2200      	movs	r2, #0
 1015306:	4620      	mov	r0, r4
 1015308:	f7ff fe56 	bl	1014fb8 <chunk_field>
 101530c:	68e3      	ldr	r3, [r4, #12]
	chunk_set(h, c, SIZE_AND_USED,
 101530e:	4629      	mov	r1, r5
 1015310:	4003      	ands	r3, r0
 1015312:	2200      	movs	r2, #0
 1015314:	4620      	mov	r0, r4
 1015316:	f7ff fe5b 	bl	1014fd0 <chunk_set>
	}

	chunk_set_used(h, c, false);
	free_list_add(h, c);
 101531a:	4629      	mov	r1, r5
 101531c:	4620      	mov	r0, r4
}
 101531e:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	free_list_add(h, c);
 1015322:	f7ff be9f 	b.w	1015064 <free_list_add>
}
 1015326:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

0101532a <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
 101532a:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct z_heap *h = heap->heap;
 101532e:	6804      	ldr	r4, [r0, #0]
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
 1015330:	1dcd      	adds	r5, r1, #7
	return big_heap(h) ? 8 : 4;
 1015332:	68a2      	ldr	r2, [r4, #8]
 1015334:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 1015338:	bf2c      	ite	cs
 101533a:	2308      	movcs	r3, #8
 101533c:	2304      	movcc	r3, #4
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
 101533e:	441d      	add	r5, r3
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 1015340:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
 1015344:	ea4f 05d5 	mov.w	r5, r5, lsr #3
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
 1015348:	fab5 f685 	clz	r6, r5
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 101534c:	bf34      	ite	cc
 101534e:	2300      	movcc	r3, #0
 1015350:	2301      	movcs	r3, #1
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
 1015352:	441e      	add	r6, r3
 1015354:	f1c6 081f 	rsb	r8, r6, #31
	size_t sz = bytes_to_chunksz(h, bytes);
	int bi = bucket_idx(h, sz);
	struct z_heap_bucket *b = &h->buckets[bi];

	if (bytes == 0 || bi > bucket_idx(h, h->len)) {
 1015358:	2900      	cmp	r1, #0
 101535a:	d03b      	beq.n	10153d4 <sys_heap_alloc+0xaa>
 101535c:	fab2 f282 	clz	r2, r2
 1015360:	f1c3 031f 	rsb	r3, r3, #31
 1015364:	1a9b      	subs	r3, r3, r2
 1015366:	4598      	cmp	r8, r3
 1015368:	dc34      	bgt.n	10153d4 <sys_heap_alloc+0xaa>
	struct z_heap_bucket *b = &h->buckets[bi];
 101536a:	6867      	ldr	r7, [r4, #4]
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	int loops = MIN(b->list_size, CONFIG_SYS_HEAP_ALLOC_LOOPS);

	for (int i = 0; i < loops; i++) {
 101536c:	f04f 0a00 	mov.w	sl, #0
	struct z_heap_bucket *b = &h->buckets[bi];
 1015370:	eb07 07c8 	add.w	r7, r7, r8, lsl #3
	int loops = MIN(b->list_size, CONFIG_SYS_HEAP_ALLOC_LOOPS);
 1015374:	687b      	ldr	r3, [r7, #4]
 1015376:	2b03      	cmp	r3, #3
 1015378:	bf28      	it	cs
 101537a:	2303      	movcs	r3, #3
 101537c:	4699      	mov	r9, r3
	for (int i = 0; i < loops; i++) {
 101537e:	45ca      	cmp	sl, r9
 1015380:	db0d      	blt.n	101539e <sys_heap_alloc+0x74>
	}

	/* Otherwise pick the smallest non-empty bucket guaranteed to
	 * fit and use that unconditionally.
	 */
	size_t bmask = h->avail_buckets & ~((1 << (bi + 1)) - 1);
 1015382:	f04f 31ff 	mov.w	r1, #4294967295
 1015386:	6963      	ldr	r3, [r4, #20]
 1015388:	f1c6 0620 	rsb	r6, r6, #32
 101538c:	40b1      	lsls	r1, r6

	if ((bmask & h->avail_buckets) != 0) {
 101538e:	4019      	ands	r1, r3
 1015390:	d020      	beq.n	10153d4 <sys_heap_alloc+0xaa>
		int minbucket = __builtin_ctz(bmask & h->avail_buckets);

		return split_alloc(h, minbucket, sz);
 1015392:	fa91 f1a1 	rbit	r1, r1
 1015396:	462a      	mov	r2, r5
 1015398:	fab1 f181 	clz	r1, r1
 101539c:	e00c      	b.n	10153b8 <sys_heap_alloc+0x8e>
		if (size(h, b->next) >= sz) {
 101539e:	f8d7 b000 	ldr.w	fp, [r7]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 10153a2:	2200      	movs	r2, #0
 10153a4:	4659      	mov	r1, fp
 10153a6:	4620      	mov	r0, r4
 10153a8:	f7ff fe06 	bl	1014fb8 <chunk_field>
 10153ac:	68e3      	ldr	r3, [r4, #12]
 10153ae:	4018      	ands	r0, r3
 10153b0:	42a8      	cmp	r0, r5
 10153b2:	d306      	bcc.n	10153c2 <sys_heap_alloc+0x98>
			return split_alloc(h, bi, sz);
 10153b4:	462a      	mov	r2, r5
 10153b6:	4641      	mov	r1, r8
		return split_alloc(h, minbucket, sz);
 10153b8:	4620      	mov	r0, r4
	}

	return NULL;
}
 10153ba:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		return split_alloc(h, minbucket, sz);
 10153be:	f7ff be9e 	b.w	10150fe <split_alloc>
	return chunk_field(h, c, FREE_NEXT);
 10153c2:	2203      	movs	r2, #3
 10153c4:	4659      	mov	r1, fp
 10153c6:	4620      	mov	r0, r4
 10153c8:	f7ff fdf6 	bl	1014fb8 <chunk_field>
	for (int i = 0; i < loops; i++) {
 10153cc:	f10a 0a01 	add.w	sl, sl, #1
		b->next = free_next(h, b->next);
 10153d0:	6038      	str	r0, [r7, #0]
	for (int i = 0; i < loops; i++) {
 10153d2:	e7d4      	b.n	101537e <sys_heap_alloc+0x54>
}
 10153d4:	2000      	movs	r0, #0
 10153d6:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

010153da <sys_heap_init>:

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
 10153da:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	CHECK(bytes < 0x800000000ULL);
#endif

	/* Round the start up, the end down */
	size_t addr = ((size_t)mem + CHUNK_UNIT - 1) & ~(CHUNK_UNIT - 1);
	size_t end = ((size_t)mem + bytes) & ~(CHUNK_UNIT - 1);
 10153dc:	188b      	adds	r3, r1, r2

	heap->heap = (struct z_heap *)addr;
	h->buf = (u64_t *)addr;
	h->buckets = (void *)(addr + CHUNK_UNIT * hdr_chunks);
	h->len = buf_sz;
	h->size_mask = (1 << (big_heap(h) ? 31 : 15)) - 1;
 10153de:	f647 72ff 	movw	r2, #32767	; 0x7fff
	size_t addr = ((size_t)mem + CHUNK_UNIT - 1) & ~(CHUNK_UNIT - 1);
 10153e2:	1dcc      	adds	r4, r1, #7
 10153e4:	f024 0407 	bic.w	r4, r4, #7
	size_t end = ((size_t)mem + bytes) & ~(CHUNK_UNIT - 1);
 10153e8:	f023 0307 	bic.w	r3, r3, #7
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
 10153ec:	1b1b      	subs	r3, r3, r4
 10153ee:	08db      	lsrs	r3, r3, #3
	h->size_mask = (1 << (big_heap(h) ? 31 : 15)) - 1;
 10153f0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 10153f4:	bf2c      	ite	cs
 10153f6:	f06f 4100 	mvncs.w	r1, #2147483648	; 0x80000000
 10153fa:	4611      	movcc	r1, r2
	heap->heap = (struct z_heap *)addr;
 10153fc:	6004      	str	r4, [r0, #0]
	h->avail_buckets = 0;
 10153fe:	2000      	movs	r0, #0
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 1015400:	4293      	cmp	r3, r2
	h->size_mask = (1 << (big_heap(h) ? 31 : 15)) - 1;
 1015402:	60e1      	str	r1, [r4, #12]
 1015404:	bf94      	ite	ls
 1015406:	2100      	movls	r1, #0
 1015408:	2101      	movhi	r1, #1
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
 101540a:	fab3 f683 	clz	r6, r3
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 101540e:	4617      	mov	r7, r2
				* sizeof(struct z_heap_bucket));

	h->chunk0 = hdr_chunks + chunksz(buckets_bytes);

	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
		heap->heap->buckets[i].list_size = 0;
 1015410:	4684      	mov	ip, r0
	size_t buckets_bytes = ((bucket_idx(h, buf_sz) + 1)
 1015412:	f1c1 0120 	rsb	r1, r1, #32
	h->buckets = (void *)(addr + CHUNK_UNIT * hdr_chunks);
 1015416:	f104 0518 	add.w	r5, r4, #24
	size_t buckets_bytes = ((bucket_idx(h, buf_sz) + 1)
 101541a:	1b89      	subs	r1, r1, r6
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
 101541c:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
	h->len = buf_sz;
 1015420:	e9c4 5301 	strd	r5, r3, [r4, #4]
	h->chunk0 = hdr_chunks + chunksz(buckets_bytes);
 1015424:	3103      	adds	r1, #3
	h->buf = (u64_t *)addr;
 1015426:	6024      	str	r4, [r4, #0]
	h->avail_buckets = 0;
 1015428:	6160      	str	r0, [r4, #20]
	h->chunk0 = hdr_chunks + chunksz(buckets_bytes);
 101542a:	6121      	str	r1, [r4, #16]
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 101542c:	68a2      	ldr	r2, [r4, #8]
 101542e:	42ba      	cmp	r2, r7
 1015430:	bf94      	ite	ls
 1015432:	2200      	movls	r2, #0
 1015434:	2201      	movhi	r2, #1
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
 1015436:	f1c2 021f 	rsb	r2, r2, #31
 101543a:	1b92      	subs	r2, r2, r6
	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
 101543c:	4290      	cmp	r0, r2
 101543e:	dd0a      	ble.n	1015456 <sys_heap_init+0x7c>
		heap->heap->buckets[i].next = 0;
	}

	chunk_set(h, h->chunk0, SIZE_AND_USED, buf_sz - h->chunk0);
 1015440:	4620      	mov	r0, r4
 1015442:	1a5b      	subs	r3, r3, r1
 1015444:	2200      	movs	r2, #0
 1015446:	f7ff fdc3 	bl	1014fd0 <chunk_set>
	free_list_add(h, h->chunk0);
 101544a:	4620      	mov	r0, r4
 101544c:	6921      	ldr	r1, [r4, #16]
}
 101544e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	free_list_add(h, h->chunk0);
 1015452:	f7ff be07 	b.w	1015064 <free_list_add>
		heap->heap->buckets[i].list_size = 0;
 1015456:	f8c5 c004 	str.w	ip, [r5, #4]
	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
 101545a:	3001      	adds	r0, #1
		heap->heap->buckets[i].next = 0;
 101545c:	f845 cb08 	str.w	ip, [r5], #8
	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
 1015460:	e7e4      	b.n	101542c <sys_heap_init+0x52>

01015462 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
 1015462:	4770      	bx	lr

01015464 <z_platform_init>:

void z_platform_init(void)
{
	SystemInit();
 1015464:	f7fe b82a 	b.w	10134bc <SystemInit>

01015468 <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
 1015468:	2300      	movs	r3, #0
	list->head = NULL;
 101546a:	e9c0 3300 	strd	r3, r3, [r0]
}
 101546e:	4770      	bx	lr

01015470 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
 1015470:	6803      	ldr	r3, [r0, #0]
 1015472:	b923      	cbnz	r3, 101547e <log_list_add_tail+0xe>
		list->head = msg;
 1015474:	6001      	str	r1, [r0, #0]
	} else {
		list->tail->next = msg;
	}

	list->tail = msg;
	msg->next = NULL;
 1015476:	2300      	movs	r3, #0
	list->tail = msg;
 1015478:	6041      	str	r1, [r0, #4]
	msg->next = NULL;
 101547a:	600b      	str	r3, [r1, #0]
}
 101547c:	4770      	bx	lr
		list->tail->next = msg;
 101547e:	6843      	ldr	r3, [r0, #4]
 1015480:	6019      	str	r1, [r3, #0]
 1015482:	e7f8      	b.n	1015476 <log_list_add_tail+0x6>

01015484 <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
 1015484:	6800      	ldr	r0, [r0, #0]
 1015486:	4770      	bx	lr

01015488 <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
 1015488:	4603      	mov	r3, r0
	struct log_msg *msg = list->head;
 101548a:	6800      	ldr	r0, [r0, #0]

	if (list->head != NULL) {
 101548c:	b108      	cbz	r0, 1015492 <log_list_head_get+0xa>
		list->head = list->head->next;
 101548e:	6802      	ldr	r2, [r0, #0]
 1015490:	601a      	str	r2, [r3, #0]
	}

	return msg;
}
 1015492:	4770      	bx	lr

01015494 <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
 1015494:	b508      	push	{r3, lr}
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
 1015496:	f7ee ff3d 	bl	1004314 <log_msg_chunk_alloc>

	if (msg != NULL) {
 101549a:	b118      	cbz	r0, 10154a4 <z_log_msg_std_alloc+0x10>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
 101549c:	2301      	movs	r3, #1
 101549e:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
 10154a0:	2300      	movs	r3, #0
 10154a2:	8103      	strh	r3, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
	}

	return msg;
}
 10154a4:	bd08      	pop	{r3, pc}

010154a6 <k_cycle_get_32_wrapper>:
#ifndef _ASMLANGUAGE
extern u32_t z_timer_cycle_get_32(void);

static inline u32_t arch_k_cycle_get_32(void)
{
	return z_timer_cycle_get_32();
 10154a6:	f7ef bb73 	b.w	1004b90 <z_timer_cycle_get_32>

010154aa <dummy_timestamp>:
 10154aa:	2000      	movs	r0, #0
 10154ac:	4770      	bx	lr

010154ae <z_log_get_s_mask>:
{
 10154ae:	b5f0      	push	{r4, r5, r6, r7, lr}
 10154b0:	4605      	mov	r5, r0
	u32_t mask = 0;
 10154b2:	2000      	movs	r0, #0
				mask |= BIT(arg);
 10154b4:	2701      	movs	r7, #1
	u32_t arg = 0;
 10154b6:	4603      	mov	r3, r0
	bool arm = false;
 10154b8:	4602      	mov	r2, r0
	while ((curr = *str++) && arg < nargs) {
 10154ba:	f815 4b01 	ldrb.w	r4, [r5], #1
 10154be:	b10c      	cbz	r4, 10154c4 <z_log_get_s_mask+0x16>
 10154c0:	428b      	cmp	r3, r1
 10154c2:	d300      	bcc.n	10154c6 <z_log_get_s_mask+0x18>
}
 10154c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (curr == '%') {
 10154c6:	2c25      	cmp	r4, #37	; 0x25
 10154c8:	d102      	bne.n	10154d0 <z_log_get_s_mask+0x22>
			arm = !arm;
 10154ca:	f082 0201 	eor.w	r2, r2, #1
 10154ce:	e7f4      	b.n	10154ba <z_log_get_s_mask+0xc>
		} else if (arm && isalpha((int)curr)) {
 10154d0:	2a00      	cmp	r2, #0
 10154d2:	d0f2      	beq.n	10154ba <z_log_get_s_mask+0xc>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
 10154d4:	f044 0620 	orr.w	r6, r4, #32
 10154d8:	3e61      	subs	r6, #97	; 0x61
 10154da:	2e19      	cmp	r6, #25
 10154dc:	d8ed      	bhi.n	10154ba <z_log_get_s_mask+0xc>
			if (curr == 's') {
 10154de:	2c73      	cmp	r4, #115	; 0x73
				mask |= BIT(arg);
 10154e0:	bf04      	itt	eq
 10154e2:	fa07 f203 	lsleq.w	r2, r7, r3
 10154e6:	4310      	orreq	r0, r2
			arg++;
 10154e8:	3301      	adds	r3, #1
			arm = false;
 10154ea:	2200      	movs	r2, #0
 10154ec:	e7e5      	b.n	10154ba <z_log_get_s_mask+0xc>

010154ee <log_0>:
{
 10154ee:	b538      	push	{r3, r4, r5, lr}
 10154f0:	4605      	mov	r5, r0
 10154f2:	460c      	mov	r4, r1
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
 10154f4:	f7ff ffce 	bl	1015494 <z_log_msg_std_alloc>

	if (msg != NULL) {
 10154f8:	b128      	cbz	r0, 1015506 <log_0+0x18>
		msg_finalize(msg, src_level);
 10154fa:	4621      	mov	r1, r4
		msg->str = str;
 10154fc:	6105      	str	r5, [r0, #16]
}
 10154fe:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		msg_finalize(msg, src_level);
 1015502:	f7ee be29 	b.w	1004158 <msg_finalize>
}
 1015506:	bd38      	pop	{r3, r4, r5, pc}

01015508 <log_1>:
{
 1015508:	b570      	push	{r4, r5, r6, lr}
 101550a:	4606      	mov	r6, r0
 101550c:	460d      	mov	r5, r1
 101550e:	4614      	mov	r4, r2
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
 1015510:	f7ff ffc0 	bl	1015494 <z_log_msg_std_alloc>

	if (msg != NULL) {
 1015514:	b158      	cbz	r0, 101552e <log_1+0x26>
		msg->str = str;
		msg->hdr.params.std.nargs = 1U;
 1015516:	2101      	movs	r1, #1
 1015518:	7a42      	ldrb	r2, [r0, #9]
		msg->str = str;
 101551a:	6106      	str	r6, [r0, #16]
		msg->hdr.params.std.nargs = 1U;
 101551c:	f361 1207 	bfi	r2, r1, #4, #4
 1015520:	7242      	strb	r2, [r0, #9]
		msg_finalize(msg, src_level);
 1015522:	4621      	mov	r1, r4
		msg->payload.single.args[0] = arg1;
 1015524:	6145      	str	r5, [r0, #20]
}
 1015526:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		msg_finalize(msg, src_level);
 101552a:	f7ee be15 	b.w	1004158 <msg_finalize>
}
 101552e:	bd70      	pop	{r4, r5, r6, pc}

01015530 <log_2>:
{
 1015530:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1015534:	4680      	mov	r8, r0
 1015536:	460f      	mov	r7, r1
 1015538:	4616      	mov	r6, r2
 101553a:	461d      	mov	r5, r3
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
 101553c:	f7ff ffaa 	bl	1015494 <z_log_msg_std_alloc>

	if (msg != NULL) {
 1015540:	b168      	cbz	r0, 101555e <log_2+0x2e>
		msg->str = str;
		msg->hdr.params.std.nargs = 2U;
 1015542:	2202      	movs	r2, #2
 1015544:	7a43      	ldrb	r3, [r0, #9]
		msg_finalize(msg, src_level);
 1015546:	4629      	mov	r1, r5
 1015548:	f362 1307 	bfi	r3, r2, #4, #4
 101554c:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
 101554e:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg->str = str;
 1015552:	f8c0 8010 	str.w	r8, [r0, #16]
}
 1015556:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		msg_finalize(msg, src_level);
 101555a:	f7ee bdfd 	b.w	1004158 <msg_finalize>
}
 101555e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

01015562 <log_3>:
{
 1015562:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1015566:	4680      	mov	r8, r0
 1015568:	460f      	mov	r7, r1
 101556a:	4616      	mov	r6, r2
 101556c:	461d      	mov	r5, r3
 101556e:	f8bd 9020 	ldrh.w	r9, [sp, #32]
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
 1015572:	f7ff ff8f 	bl	1015494 <z_log_msg_std_alloc>

	if (msg != NULL) {
 1015576:	b170      	cbz	r0, 1015596 <log_3+0x34>
		msg->str = str;
		msg->hdr.params.std.nargs = 3U;
 1015578:	2203      	movs	r2, #3
 101557a:	7a43      	ldrb	r3, [r0, #9]
		msg_finalize(msg, src_level);
 101557c:	4649      	mov	r1, r9
 101557e:	f362 1307 	bfi	r3, r2, #4, #4
 1015582:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
 1015584:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg->str = str;
 1015588:	f8c0 8010 	str.w	r8, [r0, #16]
		msg->payload.single.args[2] = arg3;
 101558c:	61c5      	str	r5, [r0, #28]
}
 101558e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		msg_finalize(msg, src_level);
 1015592:	f7ee bde1 	b.w	1004158 <msg_finalize>
}
 1015596:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0101559a <log_n>:
{
 101559a:	b510      	push	{r4, lr}
 101559c:	461c      	mov	r4, r3
		struct log_msg *msg = log_msg_create_n(str, args, narg);
 101559e:	f000 f896 	bl	10156ce <log_msg_create_n>
		if (msg == NULL) {
 10155a2:	b120      	cbz	r0, 10155ae <log_n+0x14>
		msg_finalize(msg, src_level);
 10155a4:	4621      	mov	r1, r4
}
 10155a6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		msg_finalize(msg, src_level);
 10155aa:	f7ee bdd5 	b.w	1004158 <msg_finalize>
}
 10155ae:	bd10      	pop	{r4, pc}

010155b0 <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    u8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
 10155b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 10155b4:	461c      	mov	r4, r3
	u32_t available_len = msg->hdr.params.hexdump.length;
 10155b6:	8903      	ldrh	r3, [r0, #8]
{
 10155b8:	460e      	mov	r6, r1
 10155ba:	4611      	mov	r1, r2
	u32_t available_len = msg->hdr.params.hexdump.length;
 10155bc:	f3c3 028d 	ubfx	r2, r3, #2, #14
	u8_t *head_data;
	u32_t chunk_len;
	u32_t req_len;
	u32_t cpy_len;

	if (offset >= available_len) {
 10155c0:	42a2      	cmp	r2, r4
{
 10155c2:	f89d 7020 	ldrb.w	r7, [sp, #32]
	if (offset >= available_len) {
 10155c6:	d803      	bhi.n	10155d0 <log_msg_hexdump_data_op+0x20>
		*length = 0;
 10155c8:	2300      	movs	r3, #0
 10155ca:	600b      	str	r3, [r1, #0]
		offset = 0;
		cont = cont->next;
		req_len -= cpy_len;
		data += cpy_len;
	}
}
 10155cc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((offset + *length) > available_len) {
 10155d0:	680b      	ldr	r3, [r1, #0]
 10155d2:	4423      	add	r3, r4
 10155d4:	4293      	cmp	r3, r2
		*length = available_len - offset;
 10155d6:	bf84      	itt	hi
 10155d8:	1b13      	subhi	r3, r2, r4
 10155da:	600b      	strhi	r3, [r1, #0]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
 10155dc:	2a0c      	cmp	r2, #12
	req_len = *length;
 10155de:	f8d1 9000 	ldr.w	r9, [r1]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
 10155e2:	d927      	bls.n	1015634 <log_msg_hexdump_data_op+0x84>
	if (offset < chunk_len) {
 10155e4:	2c07      	cmp	r4, #7
		cont = msg->payload.ext.next;
 10155e6:	f8d0 8014 	ldr.w	r8, [r0, #20]
	if (offset < chunk_len) {
 10155ea:	d82a      	bhi.n	1015642 <log_msg_hexdump_data_op+0x92>
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
 10155ec:	2208      	movs	r2, #8
		head_data = msg->payload.ext.data.bytes;
 10155ee:	3018      	adds	r0, #24
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
 10155f0:	454a      	cmp	r2, r9
 10155f2:	bf28      	it	cs
 10155f4:	464a      	movcs	r2, r9
 10155f6:	4420      	add	r0, r4
 10155f8:	4615      	mov	r5, r2
		if (put_op) {
 10155fa:	b1ff      	cbz	r7, 101563c <log_msg_hexdump_data_op+0x8c>
			(void)memcpy(&head_data[offset], data, cpy_len);
 10155fc:	4631      	mov	r1, r6
			(void)memcpy(data, &head_data[offset], cpy_len);
 10155fe:	f001 fa0b 	bl	1016a18 <memcpy>
		req_len -= cpy_len;
 1015602:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
 1015606:	442e      	add	r6, r5
	while (req_len > 0) {
 1015608:	f1b9 0f00 	cmp.w	r9, #0
 101560c:	d0de      	beq.n	10155cc <log_msg_hexdump_data_op+0x1c>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
 101560e:	f1c4 051c 	rsb	r5, r4, #28
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
 1015612:	454d      	cmp	r5, r9
 1015614:	bf28      	it	cs
 1015616:	464d      	movcs	r5, r9
		if (put_op) {
 1015618:	1d20      	adds	r0, r4, #4
			(void)memcpy(&cont->payload.bytes[offset],
 101561a:	462a      	mov	r2, r5
 101561c:	4440      	add	r0, r8
		if (put_op) {
 101561e:	b1bf      	cbz	r7, 1015650 <log_msg_hexdump_data_op+0xa0>
			(void)memcpy(&cont->payload.bytes[offset],
 1015620:	4631      	mov	r1, r6
			(void)memcpy(data, &cont->payload.bytes[offset],
 1015622:	f001 f9f9 	bl	1016a18 <memcpy>
		offset = 0;
 1015626:	2400      	movs	r4, #0
		cont = cont->next;
 1015628:	f8d8 8000 	ldr.w	r8, [r8]
		req_len -= cpy_len;
 101562c:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
 1015630:	442e      	add	r6, r5
 1015632:	e7e9      	b.n	1015608 <log_msg_hexdump_data_op+0x58>
	struct log_msg_cont *cont = NULL;
 1015634:	f04f 0800 	mov.w	r8, #0
		head_data = msg->payload.single.bytes;
 1015638:	3014      	adds	r0, #20
	if (offset < chunk_len) {
 101563a:	e7d9      	b.n	10155f0 <log_msg_hexdump_data_op+0x40>
			(void)memcpy(data, &head_data[offset], cpy_len);
 101563c:	4601      	mov	r1, r0
 101563e:	4630      	mov	r0, r6
 1015640:	e7dd      	b.n	10155fe <log_msg_hexdump_data_op+0x4e>
		offset -= chunk_len;
 1015642:	3c08      	subs	r4, #8
		while (offset >= chunk_len) {
 1015644:	2c1b      	cmp	r4, #27
 1015646:	d9df      	bls.n	1015608 <log_msg_hexdump_data_op+0x58>
			cont = cont->next;
 1015648:	f8d8 8000 	ldr.w	r8, [r8]
			offset -= chunk_len;
 101564c:	3c1c      	subs	r4, #28
 101564e:	e7f9      	b.n	1015644 <log_msg_hexdump_data_op+0x94>
			(void)memcpy(data, &cont->payload.bytes[offset],
 1015650:	4601      	mov	r1, r0
 1015652:	4630      	mov	r0, r6
 1015654:	e7e5      	b.n	1015622 <log_msg_hexdump_data_op+0x72>

01015656 <log_msg_get>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 1015656:	3004      	adds	r0, #4
 1015658:	e8d0 3fef 	ldaex	r3, [r0]
 101565c:	3301      	adds	r3, #1
 101565e:	e8c0 3fe2 	stlex	r2, r3, [r0]
 1015662:	2a00      	cmp	r2, #0
 1015664:	d1f8      	bne.n	1015658 <log_msg_get+0x2>
}
 1015666:	4770      	bx	lr

01015668 <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
 1015668:	7a40      	ldrb	r0, [r0, #9]
}
 101566a:	0900      	lsrs	r0, r0, #4
 101566c:	4770      	bx	lr

0101566e <log_msg_arg_get>:
	if (arg_idx >= msg->hdr.params.std.nargs) {
 101566e:	7a43      	ldrb	r3, [r0, #9]
 1015670:	ebb1 1f13 	cmp.w	r1, r3, lsr #4
 1015674:	ea4f 1213 	mov.w	r2, r3, lsr #4
 1015678:	d216      	bcs.n	10156a8 <log_msg_arg_get+0x3a>
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
 101567a:	2a03      	cmp	r2, #3
 101567c:	d803      	bhi.n	1015686 <log_msg_arg_get+0x18>
		arg = msg->payload.single.args[arg_idx];
 101567e:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 1015682:	6948      	ldr	r0, [r1, #20]
 1015684:	4770      	bx	lr
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
 1015686:	2901      	cmp	r1, #1
 1015688:	d803      	bhi.n	1015692 <log_msg_arg_get+0x24>
		return msg->payload.ext.data.args[arg_idx];
 101568a:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 101568e:	6988      	ldr	r0, [r1, #24]
 1015690:	4770      	bx	lr
	cont = msg->payload.ext.next;
 1015692:	6943      	ldr	r3, [r0, #20]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
 1015694:	3902      	subs	r1, #2
	while (arg_idx >= ARGS_CONT_MSG) {
 1015696:	2906      	cmp	r1, #6
 1015698:	d803      	bhi.n	10156a2 <log_msg_arg_get+0x34>
	return cont->payload.args[arg_idx];
 101569a:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 101569e:	6848      	ldr	r0, [r1, #4]
 10156a0:	4770      	bx	lr
		cont = cont->next;
 10156a2:	681b      	ldr	r3, [r3, #0]
		arg_idx -= ARGS_CONT_MSG;
 10156a4:	3907      	subs	r1, #7
		cont = cont->next;
 10156a6:	e7f6      	b.n	1015696 <log_msg_arg_get+0x28>
		return 0;
 10156a8:	2000      	movs	r0, #0
}
 10156aa:	4770      	bx	lr

010156ac <log_msg_put>:
{
 10156ac:	4603      	mov	r3, r0
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
 10156ae:	1d02      	adds	r2, r0, #4
 10156b0:	e8d2 1fef 	ldaex	r1, [r2]
 10156b4:	3901      	subs	r1, #1
 10156b6:	e8c2 1fec 	stlex	ip, r1, [r2]
 10156ba:	f1bc 0f00 	cmp.w	ip, #0
 10156be:	d1f7      	bne.n	10156b0 <log_msg_put+0x4>
	if (msg->hdr.ref_cnt == 0) {
 10156c0:	685b      	ldr	r3, [r3, #4]
 10156c2:	b90b      	cbnz	r3, 10156c8 <log_msg_put+0x1c>
		msg_free(msg);
 10156c4:	f7ee be3a 	b.w	100433c <msg_free>
}
 10156c8:	4770      	bx	lr

010156ca <log_msg_str_get>:
}
 10156ca:	6900      	ldr	r0, [r0, #16]
 10156cc:	4770      	bx	lr

010156ce <log_msg_create_n>:
{
 10156ce:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10156d2:	4681      	mov	r9, r0
 10156d4:	4688      	mov	r8, r1
 10156d6:	4615      	mov	r5, r2
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
 10156d8:	f7ee fe1c 	bl	1004314 <log_msg_chunk_alloc>
	if (msg != NULL) {
 10156dc:	4604      	mov	r4, r0
 10156de:	b330      	cbz	r0, 101572e <log_msg_create_n+0x60>
		msg->hdr.ref_cnt = 1;
 10156e0:	2301      	movs	r3, #1
		msg->hdr.params.raw = 0U;
 10156e2:	2700      	movs	r7, #0
	if ((msg == NULL) || nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
 10156e4:	2d03      	cmp	r5, #3
		msg->hdr.ref_cnt = 1;
 10156e6:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
 10156e8:	8107      	strh	r7, [r0, #8]
 10156ea:	d909      	bls.n	1015700 <log_msg_create_n+0x32>
	msg->hdr.params.generic.ext = 1;
 10156ec:	2202      	movs	r2, #2
	n -= LOG_MSG_NARGS_HEAD_CHUNK;
 10156ee:	f1a5 0a02 	sub.w	sl, r5, #2
	msg->hdr.params.generic.ext = 1;
 10156f2:	8102      	strh	r2, [r0, #8]
	next = &msg->payload.ext.next;
 10156f4:	f100 0b14 	add.w	fp, r0, #20
	*next = NULL;
 10156f8:	6147      	str	r7, [r0, #20]
	while (n > 0) {
 10156fa:	f1ba 0f00 	cmp.w	sl, #0
 10156fe:	dc0e      	bgt.n	101571e <log_msg_create_n+0x50>
		msg->hdr.params.std.nargs = nargs;
 1015700:	7a63      	ldrb	r3, [r4, #9]
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
 1015702:	2d03      	cmp	r5, #3
		msg->hdr.params.std.nargs = nargs;
 1015704:	f365 1307 	bfi	r3, r5, #4, #4
		msg->str = str;
 1015708:	f8c4 9010 	str.w	r9, [r4, #16]
		msg->hdr.params.std.nargs = nargs;
 101570c:	7263      	strb	r3, [r4, #9]
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
 101570e:	d818      	bhi.n	1015742 <log_msg_create_n+0x74>
		(void)memcpy(msg->payload.single.args, args,
 1015710:	4641      	mov	r1, r8
 1015712:	00aa      	lsls	r2, r5, #2
 1015714:	f104 0014 	add.w	r0, r4, #20
 1015718:	f001 f97e 	bl	1016a18 <memcpy>
	while (nargs != 0U) {
 101571c:	e007      	b.n	101572e <log_msg_create_n+0x60>
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
 101571e:	f7ee fdf9 	bl	1004314 <log_msg_chunk_alloc>
		if (cont == NULL) {
 1015722:	4606      	mov	r6, r0
 1015724:	b930      	cbnz	r0, 1015734 <log_msg_create_n+0x66>
			msg_free(msg);
 1015726:	4620      	mov	r0, r4
 1015728:	f7ee fe08 	bl	100433c <msg_free>
			return NULL;
 101572c:	4634      	mov	r4, r6
}
 101572e:	4620      	mov	r0, r4
 1015730:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		*next = cont;
 1015734:	f8cb 0000 	str.w	r0, [fp]
		cont->next = NULL;
 1015738:	f1aa 0a07 	sub.w	sl, sl, #7
		next = &cont->next;
 101573c:	4683      	mov	fp, r0
		cont->next = NULL;
 101573e:	6007      	str	r7, [r0, #0]
		n -= ARGS_CONT_MSG;
 1015740:	e7db      	b.n	10156fa <log_msg_create_n+0x2c>
		(void)memcpy(msg->payload.ext.data.args, args,
 1015742:	4641      	mov	r1, r8
 1015744:	2208      	movs	r2, #8
 1015746:	f104 0018 	add.w	r0, r4, #24
	struct log_msg_cont *cont = msg->payload.ext.next;
 101574a:	6967      	ldr	r7, [r4, #20]
		(void)memcpy(msg->payload.ext.data.args, args,
 101574c:	f001 f964 	bl	1016a18 <memcpy>
		nargs -= LOG_MSG_NARGS_HEAD_CHUNK;
 1015750:	3d02      	subs	r5, #2
		args += LOG_MSG_NARGS_HEAD_CHUNK;
 1015752:	f108 0808 	add.w	r8, r8, #8
		u32_t cpy_args = MIN(nargs, ARGS_CONT_MSG);
 1015756:	2d07      	cmp	r5, #7
 1015758:	462e      	mov	r6, r5
 101575a:	bf28      	it	cs
 101575c:	2607      	movcs	r6, #7
		(void)memcpy(cont->payload.args, args,
 101575e:	ea4f 0986 	mov.w	r9, r6, lsl #2
 1015762:	4641      	mov	r1, r8
 1015764:	1d38      	adds	r0, r7, #4
 1015766:	464a      	mov	r2, r9
 1015768:	f001 f956 	bl	1016a18 <memcpy>
	while (nargs != 0U) {
 101576c:	1bad      	subs	r5, r5, r6
		cont = cont->next;
 101576e:	683f      	ldr	r7, [r7, #0]
		args += cpy_args;
 1015770:	44c8      	add	r8, r9
	while (nargs != 0U) {
 1015772:	d1f0      	bne.n	1015756 <log_msg_create_n+0x88>
 1015774:	e7db      	b.n	101572e <log_msg_create_n+0x60>

01015776 <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      u8_t *data,
			      size_t *length,
			      size_t offset)
{
 1015776:	b513      	push	{r0, r1, r4, lr}
	log_msg_hexdump_data_op(msg, data, length, offset, false);
 1015778:	2400      	movs	r4, #0
 101577a:	9400      	str	r4, [sp, #0]
 101577c:	f7ff ff18 	bl	10155b0 <log_msg_hexdump_data_op>
}
 1015780:	b002      	add	sp, #8
 1015782:	bd10      	pop	{r4, pc}

01015784 <buffer_write>:
{
 1015784:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1015786:	4606      	mov	r6, r0
 1015788:	460d      	mov	r5, r1
 101578a:	4614      	mov	r4, r2
 101578c:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
 101578e:	4621      	mov	r1, r4
 1015790:	4628      	mov	r0, r5
 1015792:	463a      	mov	r2, r7
 1015794:	47b0      	blx	r6
	} while (len != 0);
 1015796:	1a24      	subs	r4, r4, r0
		buf += processed;
 1015798:	4405      	add	r5, r0
	} while (len != 0);
 101579a:	d1f8      	bne.n	101578e <buffer_write+0xa>
}
 101579c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0101579e <std_print>:
{
 101579e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 10157a2:	b08e      	sub	sp, #56	; 0x38
 10157a4:	af0e      	add	r7, sp, #56	; 0x38
 10157a6:	4680      	mov	r8, r0
 10157a8:	460d      	mov	r5, r1
	const char *str = log_msg_str_get(msg);
 10157aa:	f7ff ff8e 	bl	10156ca <log_msg_str_get>
 10157ae:	4606      	mov	r6, r0
	u32_t nargs = log_msg_nargs_get(msg);
 10157b0:	4640      	mov	r0, r8
 10157b2:	f7ff ff59 	bl	1015668 <log_msg_nargs_get>
	for (i = 0; i < nargs; i++) {
 10157b6:	f04f 0900 	mov.w	r9, #0
	u32_t nargs = log_msg_nargs_get(msg);
 10157ba:	4682      	mov	sl, r0
	u32_t *args = alloca(sizeof(u32_t)*nargs);
 10157bc:	0083      	lsls	r3, r0, #2
 10157be:	3307      	adds	r3, #7
 10157c0:	f023 0307 	bic.w	r3, r3, #7
 10157c4:	ebad 0d03 	sub.w	sp, sp, r3
 10157c8:	ac0e      	add	r4, sp, #56	; 0x38
	for (i = 0; i < nargs; i++) {
 10157ca:	45d1      	cmp	r9, sl
 10157cc:	d116      	bne.n	10157fc <std_print+0x5e>
	switch (log_msg_nargs_get(msg)) {
 10157ce:	4640      	mov	r0, r8
 10157d0:	f7ff ff4a 	bl	1015668 <log_msg_nargs_get>
 10157d4:	280f      	cmp	r0, #15
 10157d6:	d81e      	bhi.n	1015816 <std_print+0x78>
 10157d8:	e8df f010 	tbh	[pc, r0, lsl #1]
 10157dc:	00200019 	.word	0x00200019
 10157e0:	002d0026 	.word	0x002d0026
 10157e4:	00410036 	.word	0x00410036
 10157e8:	005d004e 	.word	0x005d004e
 10157ec:	0081006e 	.word	0x0081006e
 10157f0:	00ad0096 	.word	0x00ad0096
 10157f4:	00e100c6 	.word	0x00e100c6
 10157f8:	011d00fe 	.word	0x011d00fe
		args[i] = log_msg_arg_get(msg, i);
 10157fc:	4649      	mov	r1, r9
 10157fe:	4640      	mov	r0, r8
 1015800:	f7ff ff35 	bl	101566e <log_msg_arg_get>
 1015804:	f844 0029 	str.w	r0, [r4, r9, lsl #2]
	for (i = 0; i < nargs; i++) {
 1015808:	f109 0901 	add.w	r9, r9, #1
 101580c:	e7dd      	b.n	10157ca <std_print+0x2c>
		print_formatted(log_output, str);
 101580e:	4631      	mov	r1, r6
 1015810:	4628      	mov	r0, r5
 1015812:	f7ee fdd1 	bl	10043b8 <print_formatted>
}
 1015816:	46bd      	mov	sp, r7
 1015818:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(log_output, str, args[0]);
 101581c:	4631      	mov	r1, r6
 101581e:	4628      	mov	r0, r5
 1015820:	6822      	ldr	r2, [r4, #0]
 1015822:	f7ee fdc9 	bl	10043b8 <print_formatted>
		break;
 1015826:	e7f6      	b.n	1015816 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1]);
 1015828:	4631      	mov	r1, r6
 101582a:	e9d4 2300 	ldrd	r2, r3, [r4]
 101582e:	4628      	mov	r0, r5
 1015830:	f7ee fdc2 	bl	10043b8 <print_formatted>
		break;
 1015834:	e7ef      	b.n	1015816 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2]);
 1015836:	68a3      	ldr	r3, [r4, #8]
 1015838:	4631      	mov	r1, r6
 101583a:	9300      	str	r3, [sp, #0]
 101583c:	4628      	mov	r0, r5
 101583e:	e9d4 2300 	ldrd	r2, r3, [r4]
 1015842:	f7ee fdb9 	bl	10043b8 <print_formatted>
		break;
 1015846:	e7e6      	b.n	1015816 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 1015848:	68e3      	ldr	r3, [r4, #12]
 101584a:	4631      	mov	r1, r6
 101584c:	9301      	str	r3, [sp, #4]
 101584e:	68a3      	ldr	r3, [r4, #8]
 1015850:	4628      	mov	r0, r5
 1015852:	9300      	str	r3, [sp, #0]
 1015854:	e9d4 2300 	ldrd	r2, r3, [r4]
 1015858:	f7ee fdae 	bl	10043b8 <print_formatted>
		break;
 101585c:	e7db      	b.n	1015816 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 101585e:	6923      	ldr	r3, [r4, #16]
 1015860:	4631      	mov	r1, r6
 1015862:	9302      	str	r3, [sp, #8]
 1015864:	68e3      	ldr	r3, [r4, #12]
 1015866:	4628      	mov	r0, r5
 1015868:	9301      	str	r3, [sp, #4]
 101586a:	68a3      	ldr	r3, [r4, #8]
 101586c:	9300      	str	r3, [sp, #0]
 101586e:	e9d4 2300 	ldrd	r2, r3, [r4]
 1015872:	f7ee fda1 	bl	10043b8 <print_formatted>
		break;
 1015876:	e7ce      	b.n	1015816 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 1015878:	6963      	ldr	r3, [r4, #20]
 101587a:	4631      	mov	r1, r6
 101587c:	9303      	str	r3, [sp, #12]
 101587e:	6923      	ldr	r3, [r4, #16]
 1015880:	4628      	mov	r0, r5
 1015882:	9302      	str	r3, [sp, #8]
 1015884:	68e3      	ldr	r3, [r4, #12]
 1015886:	9301      	str	r3, [sp, #4]
 1015888:	68a3      	ldr	r3, [r4, #8]
 101588a:	9300      	str	r3, [sp, #0]
 101588c:	e9d4 2300 	ldrd	r2, r3, [r4]
 1015890:	f7ee fd92 	bl	10043b8 <print_formatted>
		break;
 1015894:	e7bf      	b.n	1015816 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 1015896:	69a3      	ldr	r3, [r4, #24]
 1015898:	4631      	mov	r1, r6
 101589a:	9304      	str	r3, [sp, #16]
 101589c:	6963      	ldr	r3, [r4, #20]
 101589e:	4628      	mov	r0, r5
 10158a0:	9303      	str	r3, [sp, #12]
 10158a2:	6923      	ldr	r3, [r4, #16]
 10158a4:	9302      	str	r3, [sp, #8]
 10158a6:	68e3      	ldr	r3, [r4, #12]
 10158a8:	9301      	str	r3, [sp, #4]
 10158aa:	68a3      	ldr	r3, [r4, #8]
 10158ac:	9300      	str	r3, [sp, #0]
 10158ae:	e9d4 2300 	ldrd	r2, r3, [r4]
 10158b2:	f7ee fd81 	bl	10043b8 <print_formatted>
		break;
 10158b6:	e7ae      	b.n	1015816 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 10158b8:	69e3      	ldr	r3, [r4, #28]
 10158ba:	4631      	mov	r1, r6
 10158bc:	9305      	str	r3, [sp, #20]
 10158be:	69a3      	ldr	r3, [r4, #24]
 10158c0:	4628      	mov	r0, r5
 10158c2:	9304      	str	r3, [sp, #16]
 10158c4:	6963      	ldr	r3, [r4, #20]
 10158c6:	9303      	str	r3, [sp, #12]
 10158c8:	6923      	ldr	r3, [r4, #16]
 10158ca:	9302      	str	r3, [sp, #8]
 10158cc:	68e3      	ldr	r3, [r4, #12]
 10158ce:	9301      	str	r3, [sp, #4]
 10158d0:	68a3      	ldr	r3, [r4, #8]
 10158d2:	9300      	str	r3, [sp, #0]
 10158d4:	e9d4 2300 	ldrd	r2, r3, [r4]
 10158d8:	f7ee fd6e 	bl	10043b8 <print_formatted>
		break;
 10158dc:	e79b      	b.n	1015816 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 10158de:	6a23      	ldr	r3, [r4, #32]
 10158e0:	4631      	mov	r1, r6
 10158e2:	9306      	str	r3, [sp, #24]
 10158e4:	69e3      	ldr	r3, [r4, #28]
 10158e6:	4628      	mov	r0, r5
 10158e8:	9305      	str	r3, [sp, #20]
 10158ea:	69a3      	ldr	r3, [r4, #24]
 10158ec:	9304      	str	r3, [sp, #16]
 10158ee:	6963      	ldr	r3, [r4, #20]
 10158f0:	9303      	str	r3, [sp, #12]
 10158f2:	6923      	ldr	r3, [r4, #16]
 10158f4:	9302      	str	r3, [sp, #8]
 10158f6:	68e3      	ldr	r3, [r4, #12]
 10158f8:	9301      	str	r3, [sp, #4]
 10158fa:	68a3      	ldr	r3, [r4, #8]
 10158fc:	9300      	str	r3, [sp, #0]
 10158fe:	e9d4 2300 	ldrd	r2, r3, [r4]
 1015902:	f7ee fd59 	bl	10043b8 <print_formatted>
		break;
 1015906:	e786      	b.n	1015816 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 1015908:	6a63      	ldr	r3, [r4, #36]	; 0x24
 101590a:	4631      	mov	r1, r6
 101590c:	9307      	str	r3, [sp, #28]
 101590e:	6a23      	ldr	r3, [r4, #32]
 1015910:	4628      	mov	r0, r5
 1015912:	9306      	str	r3, [sp, #24]
 1015914:	69e3      	ldr	r3, [r4, #28]
 1015916:	9305      	str	r3, [sp, #20]
 1015918:	69a3      	ldr	r3, [r4, #24]
 101591a:	9304      	str	r3, [sp, #16]
 101591c:	6963      	ldr	r3, [r4, #20]
 101591e:	9303      	str	r3, [sp, #12]
 1015920:	6923      	ldr	r3, [r4, #16]
 1015922:	9302      	str	r3, [sp, #8]
 1015924:	68e3      	ldr	r3, [r4, #12]
 1015926:	9301      	str	r3, [sp, #4]
 1015928:	68a3      	ldr	r3, [r4, #8]
 101592a:	9300      	str	r3, [sp, #0]
 101592c:	e9d4 2300 	ldrd	r2, r3, [r4]
 1015930:	f7ee fd42 	bl	10043b8 <print_formatted>
		break;
 1015934:	e76f      	b.n	1015816 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 1015936:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1015938:	4631      	mov	r1, r6
 101593a:	9308      	str	r3, [sp, #32]
 101593c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 101593e:	4628      	mov	r0, r5
 1015940:	9307      	str	r3, [sp, #28]
 1015942:	6a23      	ldr	r3, [r4, #32]
 1015944:	9306      	str	r3, [sp, #24]
 1015946:	69e3      	ldr	r3, [r4, #28]
 1015948:	9305      	str	r3, [sp, #20]
 101594a:	69a3      	ldr	r3, [r4, #24]
 101594c:	9304      	str	r3, [sp, #16]
 101594e:	6963      	ldr	r3, [r4, #20]
 1015950:	9303      	str	r3, [sp, #12]
 1015952:	6923      	ldr	r3, [r4, #16]
 1015954:	9302      	str	r3, [sp, #8]
 1015956:	68e3      	ldr	r3, [r4, #12]
 1015958:	9301      	str	r3, [sp, #4]
 101595a:	68a3      	ldr	r3, [r4, #8]
 101595c:	9300      	str	r3, [sp, #0]
 101595e:	e9d4 2300 	ldrd	r2, r3, [r4]
 1015962:	f7ee fd29 	bl	10043b8 <print_formatted>
		break;
 1015966:	e756      	b.n	1015816 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 1015968:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 101596a:	4631      	mov	r1, r6
 101596c:	9309      	str	r3, [sp, #36]	; 0x24
 101596e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1015970:	4628      	mov	r0, r5
 1015972:	9308      	str	r3, [sp, #32]
 1015974:	6a63      	ldr	r3, [r4, #36]	; 0x24
 1015976:	9307      	str	r3, [sp, #28]
 1015978:	6a23      	ldr	r3, [r4, #32]
 101597a:	9306      	str	r3, [sp, #24]
 101597c:	69e3      	ldr	r3, [r4, #28]
 101597e:	9305      	str	r3, [sp, #20]
 1015980:	69a3      	ldr	r3, [r4, #24]
 1015982:	9304      	str	r3, [sp, #16]
 1015984:	6963      	ldr	r3, [r4, #20]
 1015986:	9303      	str	r3, [sp, #12]
 1015988:	6923      	ldr	r3, [r4, #16]
 101598a:	9302      	str	r3, [sp, #8]
 101598c:	68e3      	ldr	r3, [r4, #12]
 101598e:	9301      	str	r3, [sp, #4]
 1015990:	68a3      	ldr	r3, [r4, #8]
 1015992:	9300      	str	r3, [sp, #0]
 1015994:	e9d4 2300 	ldrd	r2, r3, [r4]
 1015998:	f7ee fd0e 	bl	10043b8 <print_formatted>
		break;
 101599c:	e73b      	b.n	1015816 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 101599e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 10159a0:	4631      	mov	r1, r6
 10159a2:	930a      	str	r3, [sp, #40]	; 0x28
 10159a4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 10159a6:	4628      	mov	r0, r5
 10159a8:	9309      	str	r3, [sp, #36]	; 0x24
 10159aa:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 10159ac:	9308      	str	r3, [sp, #32]
 10159ae:	6a63      	ldr	r3, [r4, #36]	; 0x24
 10159b0:	9307      	str	r3, [sp, #28]
 10159b2:	6a23      	ldr	r3, [r4, #32]
 10159b4:	9306      	str	r3, [sp, #24]
 10159b6:	69e3      	ldr	r3, [r4, #28]
 10159b8:	9305      	str	r3, [sp, #20]
 10159ba:	69a3      	ldr	r3, [r4, #24]
 10159bc:	9304      	str	r3, [sp, #16]
 10159be:	6963      	ldr	r3, [r4, #20]
 10159c0:	9303      	str	r3, [sp, #12]
 10159c2:	6923      	ldr	r3, [r4, #16]
 10159c4:	9302      	str	r3, [sp, #8]
 10159c6:	68e3      	ldr	r3, [r4, #12]
 10159c8:	9301      	str	r3, [sp, #4]
 10159ca:	68a3      	ldr	r3, [r4, #8]
 10159cc:	9300      	str	r3, [sp, #0]
 10159ce:	e9d4 2300 	ldrd	r2, r3, [r4]
 10159d2:	f7ee fcf1 	bl	10043b8 <print_formatted>
		break;
 10159d6:	e71e      	b.n	1015816 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 10159d8:	6b63      	ldr	r3, [r4, #52]	; 0x34
 10159da:	4631      	mov	r1, r6
 10159dc:	930b      	str	r3, [sp, #44]	; 0x2c
 10159de:	6b23      	ldr	r3, [r4, #48]	; 0x30
 10159e0:	4628      	mov	r0, r5
 10159e2:	930a      	str	r3, [sp, #40]	; 0x28
 10159e4:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 10159e6:	9309      	str	r3, [sp, #36]	; 0x24
 10159e8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 10159ea:	9308      	str	r3, [sp, #32]
 10159ec:	6a63      	ldr	r3, [r4, #36]	; 0x24
 10159ee:	9307      	str	r3, [sp, #28]
 10159f0:	6a23      	ldr	r3, [r4, #32]
 10159f2:	9306      	str	r3, [sp, #24]
 10159f4:	69e3      	ldr	r3, [r4, #28]
 10159f6:	9305      	str	r3, [sp, #20]
 10159f8:	69a3      	ldr	r3, [r4, #24]
 10159fa:	9304      	str	r3, [sp, #16]
 10159fc:	6963      	ldr	r3, [r4, #20]
 10159fe:	9303      	str	r3, [sp, #12]
 1015a00:	6923      	ldr	r3, [r4, #16]
 1015a02:	9302      	str	r3, [sp, #8]
 1015a04:	68e3      	ldr	r3, [r4, #12]
 1015a06:	9301      	str	r3, [sp, #4]
 1015a08:	68a3      	ldr	r3, [r4, #8]
 1015a0a:	9300      	str	r3, [sp, #0]
 1015a0c:	e9d4 2300 	ldrd	r2, r3, [r4]
 1015a10:	f7ee fcd2 	bl	10043b8 <print_formatted>
		break;
 1015a14:	e6ff      	b.n	1015816 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 1015a16:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 1015a18:	4631      	mov	r1, r6
 1015a1a:	930c      	str	r3, [sp, #48]	; 0x30
 1015a1c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 1015a1e:	4628      	mov	r0, r5
 1015a20:	930b      	str	r3, [sp, #44]	; 0x2c
 1015a22:	6b23      	ldr	r3, [r4, #48]	; 0x30
 1015a24:	930a      	str	r3, [sp, #40]	; 0x28
 1015a26:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 1015a28:	9309      	str	r3, [sp, #36]	; 0x24
 1015a2a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1015a2c:	9308      	str	r3, [sp, #32]
 1015a2e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 1015a30:	9307      	str	r3, [sp, #28]
 1015a32:	6a23      	ldr	r3, [r4, #32]
 1015a34:	9306      	str	r3, [sp, #24]
 1015a36:	69e3      	ldr	r3, [r4, #28]
 1015a38:	9305      	str	r3, [sp, #20]
 1015a3a:	69a3      	ldr	r3, [r4, #24]
 1015a3c:	9304      	str	r3, [sp, #16]
 1015a3e:	6963      	ldr	r3, [r4, #20]
 1015a40:	9303      	str	r3, [sp, #12]
 1015a42:	6923      	ldr	r3, [r4, #16]
 1015a44:	9302      	str	r3, [sp, #8]
 1015a46:	68e3      	ldr	r3, [r4, #12]
 1015a48:	9301      	str	r3, [sp, #4]
 1015a4a:	68a3      	ldr	r3, [r4, #8]
 1015a4c:	9300      	str	r3, [sp, #0]
 1015a4e:	e9d4 2300 	ldrd	r2, r3, [r4]
 1015a52:	f7ee fcb1 	bl	10043b8 <print_formatted>
}
 1015a56:	e6de      	b.n	1015816 <std_print+0x78>

01015a58 <log_output_flush>:
		     log_output->control_block->offset,
 1015a58:	6842      	ldr	r2, [r0, #4]
{
 1015a5a:	b510      	push	{r4, lr}
	buffer_write(log_output->func, log_output->buf,
 1015a5c:	e9d2 2300 	ldrd	r2, r3, [r2]
{
 1015a60:	4604      	mov	r4, r0
	buffer_write(log_output->func, log_output->buf,
 1015a62:	6881      	ldr	r1, [r0, #8]
 1015a64:	6800      	ldr	r0, [r0, #0]
 1015a66:	f7ff fe8d 	bl	1015784 <buffer_write>
	log_output->control_block->offset = 0;
 1015a6a:	2200      	movs	r2, #0
 1015a6c:	6863      	ldr	r3, [r4, #4]
 1015a6e:	601a      	str	r2, [r3, #0]
}
 1015a70:	bd10      	pop	{r4, pc}

01015a72 <out_func>:
{
 1015a72:	b538      	push	{r3, r4, r5, lr}
	if (out_ctx->control_block->offset == out_ctx->size) {
 1015a74:	684b      	ldr	r3, [r1, #4]
{
 1015a76:	4605      	mov	r5, r0
	if (out_ctx->control_block->offset == out_ctx->size) {
 1015a78:	681a      	ldr	r2, [r3, #0]
 1015a7a:	68cb      	ldr	r3, [r1, #12]
{
 1015a7c:	460c      	mov	r4, r1
	if (out_ctx->control_block->offset == out_ctx->size) {
 1015a7e:	429a      	cmp	r2, r3
 1015a80:	d102      	bne.n	1015a88 <out_func+0x16>
		log_output_flush(out_ctx);
 1015a82:	4608      	mov	r0, r1
 1015a84:	f7ff ffe8 	bl	1015a58 <log_output_flush>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 1015a88:	6863      	ldr	r3, [r4, #4]
 1015a8a:	e8d3 2fef 	ldaex	r2, [r3]
 1015a8e:	1c51      	adds	r1, r2, #1
 1015a90:	e8c3 1fe0 	stlex	r0, r1, [r3]
 1015a94:	2800      	cmp	r0, #0
 1015a96:	d1f8      	bne.n	1015a8a <out_func+0x18>
	out_ctx->buf[idx] = (u8_t)c;
 1015a98:	68a3      	ldr	r3, [r4, #8]
}
 1015a9a:	2000      	movs	r0, #0
	out_ctx->buf[idx] = (u8_t)c;
 1015a9c:	549d      	strb	r5, [r3, r2]
}
 1015a9e:	bd38      	pop	{r3, r4, r5, pc}

01015aa0 <char_out>:
{
 1015aa0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1015aa2:	460d      	mov	r5, r1
 1015aa4:	4616      	mov	r6, r2
	for (size_t i = 0; i < length; i++) {
 1015aa6:	4604      	mov	r4, r0
 1015aa8:	1847      	adds	r7, r0, r1
 1015aaa:	42bc      	cmp	r4, r7
 1015aac:	d101      	bne.n	1015ab2 <char_out+0x12>
}
 1015aae:	4628      	mov	r0, r5
 1015ab0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		uart_poll_out(dev, data[i]);
 1015ab2:	f814 1b01 	ldrb.w	r1, [r4], #1
 1015ab6:	68b3      	ldr	r3, [r6, #8]
 1015ab8:	4630      	mov	r0, r6
 1015aba:	685b      	ldr	r3, [r3, #4]
 1015abc:	4798      	blx	r3
	for (size_t i = 0; i < length; i++) {
 1015abe:	e7f4      	b.n	1015aaa <char_out+0xa>

01015ac0 <get_status>:
	if (data->started) {
 1015ac0:	220c      	movs	r2, #12
	data = get_sub_data(dev, type);
 1015ac2:	68c3      	ldr	r3, [r0, #12]
	return &data->subsys[type];
 1015ac4:	b2c9      	uxtb	r1, r1
	if (data->started) {
 1015ac6:	fb02 3101 	mla	r1, r2, r1, r3
 1015aca:	7a4b      	ldrb	r3, [r1, #9]
 1015acc:	b923      	cbnz	r3, 1015ad8 <get_status+0x18>
	if (data->ref > 0) {
 1015ace:	7a08      	ldrb	r0, [r1, #8]
		return CLOCK_CONTROL_STATUS_ON;
 1015ad0:	fab0 f080 	clz	r0, r0
 1015ad4:	0940      	lsrs	r0, r0, #5
 1015ad6:	4770      	bx	lr
 1015ad8:	2002      	movs	r0, #2
}
 1015ada:	4770      	bx	lr

01015adc <clock_stop>:
{
 1015adc:	b570      	push	{r4, r5, r6, lr}
 1015ade:	b2c9      	uxtb	r1, r1
	config = get_sub_config(dev, type);
 1015ae0:	6844      	ldr	r4, [r0, #4]
	data = get_sub_data(dev, type);
 1015ae2:	68c5      	ldr	r5, [r0, #12]
	__asm__ volatile(
 1015ae4:	f04f 0320 	mov.w	r3, #32
 1015ae8:	f3ef 8611 	mrs	r6, BASEPRI
 1015aec:	f383 8811 	msr	BASEPRI, r3
 1015af0:	f3bf 8f6f 	isb	sy
	if (data->ref == 0) {
 1015af4:	230c      	movs	r3, #12
 1015af6:	434b      	muls	r3, r1
 1015af8:	18ea      	adds	r2, r5, r3
 1015afa:	7a10      	ldrb	r0, [r2, #8]
 1015afc:	b1a0      	cbz	r0, 1015b28 <clock_stop+0x4c>
	data->ref--;
 1015afe:	3801      	subs	r0, #1
 1015b00:	b2c0      	uxtb	r0, r0
 1015b02:	7210      	strb	r0, [r2, #8]
	if (data->ref == 0) {
 1015b04:	b998      	cbnz	r0, 1015b2e <clock_stop+0x52>
		nrf_clock_task_trigger(NRF_CLOCK, config->stop_tsk);
 1015b06:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
	list->head = NULL;
 1015b0a:	50e8      	str	r0, [r5, r3]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1015b0c:	78cb      	ldrb	r3, [r1, #3]
 1015b0e:	2101      	movs	r1, #1
 1015b10:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
 1015b14:	f503 43a0 	add.w	r3, r3, #20480	; 0x5000
	list->tail = NULL;
 1015b18:	6050      	str	r0, [r2, #4]
 1015b1a:	6019      	str	r1, [r3, #0]
		data->started = false;
 1015b1c:	7250      	strb	r0, [r2, #9]
	__asm__ volatile(
 1015b1e:	f386 8811 	msr	BASEPRI, r6
 1015b22:	f3bf 8f6f 	isb	sy
}
 1015b26:	bd70      	pop	{r4, r5, r6, pc}
		err = -EALREADY;
 1015b28:	f06f 0044 	mvn.w	r0, #68	; 0x44
 1015b2c:	e7f7      	b.n	1015b1e <clock_stop+0x42>
	int err = 0;
 1015b2e:	2000      	movs	r0, #0
 1015b30:	e7f5      	b.n	1015b1e <clock_stop+0x42>

01015b32 <clock_start>:
	return clock_async_start(dev, sub_system, NULL);
 1015b32:	2200      	movs	r2, #0
 1015b34:	f7ee be7e 	b.w	1004834 <clock_async_start>

01015b38 <z_clock_isr>:
/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
	__ASSERT_NO_MSG(false);
}
 1015b38:	4770      	bx	lr

01015b3a <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
 1015b3a:	4770      	bx	lr

01015b3c <uECC_make_key>:
	}
	return 0;
}

int uECC_make_key(uint8_t *public_key, uint8_t *private_key, uECC_Curve curve)
{
 1015b3c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1015b40:	4606      	mov	r6, r0
 1015b42:	4688      	mov	r8, r1
 1015b44:	4614      	mov	r4, r2
 1015b46:	2740      	movs	r7, #64	; 0x40
 1015b48:	b0a9      	sub	sp, #164	; 0xa4
			!rng_function((uint8_t *)_random, 2 * NUM_ECC_WORDS*uECC_WORD_SIZE)) {
        		return 0;
		}

		/* computing modular reduction of _random (see FIPS 186.4 B.4.1): */
		uECC_vli_mmod(_private, _random, curve->n, BITS_TO_WORDS(curve->num_n_bits));
 1015b4a:	f102 0924 	add.w	r9, r2, #36	; 0x24
		uECC_RNG_Function rng_function = uECC_get_rng();
 1015b4e:	f7ef f839 	bl	1004bc4 <uECC_get_rng>
		if (!rng_function ||
 1015b52:	4603      	mov	r3, r0
 1015b54:	2800      	cmp	r0, #0
 1015b56:	d03e      	beq.n	1015bd6 <uECC_make_key+0x9a>
			!rng_function((uint8_t *)_random, 2 * NUM_ECC_WORDS*uECC_WORD_SIZE)) {
 1015b58:	2140      	movs	r1, #64	; 0x40
 1015b5a:	a808      	add	r0, sp, #32
 1015b5c:	4798      	blx	r3
		if (!rng_function ||
 1015b5e:	b3d0      	cbz	r0, 1015bd6 <uECC_make_key+0x9a>
		uECC_vli_mmod(_private, _random, curve->n, BITS_TO_WORDS(curve->num_n_bits));
 1015b60:	466d      	mov	r5, sp
 1015b62:	f9b4 2002 	ldrsh.w	r2, [r4, #2]
 1015b66:	4628      	mov	r0, r5
 1015b68:	f112 031f 	adds.w	r3, r2, #31
 1015b6c:	bf48      	it	mi
 1015b6e:	f102 033e 	addmi.w	r3, r2, #62	; 0x3e
 1015b72:	a908      	add	r1, sp, #32
 1015b74:	464a      	mov	r2, r9
 1015b76:	f343 1347 	sbfx	r3, r3, #5, #8
 1015b7a:	f000 f9fe 	bl	1015f7a <uECC_vli_mmod>

		/* Computing public-key from private: */
		if (EccPoint_compute_public_key(_public, _private, curve)) {
 1015b7e:	4622      	mov	r2, r4
 1015b80:	4629      	mov	r1, r5
 1015b82:	a818      	add	r0, sp, #96	; 0x60
 1015b84:	f000 fe17 	bl	10167b6 <EccPoint_compute_public_key>
 1015b88:	b318      	cbz	r0, 1015bd2 <uECC_make_key+0x96>

			/* Converting buffers to correct bit order: */
			uECC_vli_nativeToBytes(private_key,
					       BITS_TO_BYTES(curve->num_n_bits),
 1015b8a:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
			uECC_vli_nativeToBytes(private_key,
 1015b8e:	462a      	mov	r2, r5
 1015b90:	1dd9      	adds	r1, r3, #7
 1015b92:	bf48      	it	mi
 1015b94:	f103 010e 	addmi.w	r1, r3, #14
 1015b98:	4640      	mov	r0, r8
 1015b9a:	10c9      	asrs	r1, r1, #3
 1015b9c:	f000 fe33 	bl	1016806 <uECC_vli_nativeToBytes>
					       _private);
			uECC_vli_nativeToBytes(public_key,
 1015ba0:	4630      	mov	r0, r6
 1015ba2:	f994 1001 	ldrsb.w	r1, [r4, #1]
 1015ba6:	aa18      	add	r2, sp, #96	; 0x60
 1015ba8:	f000 fe2d 	bl	1016806 <uECC_vli_nativeToBytes>
					       curve->num_bytes,
					       _public);
			uECC_vli_nativeToBytes(public_key + curve->num_bytes,
 1015bac:	f994 1001 	ldrsb.w	r1, [r4, #1]
 					       curve->num_bytes,
					       _public + curve->num_words);
 1015bb0:	f994 2000 	ldrsb.w	r2, [r4]
			uECC_vli_nativeToBytes(public_key + curve->num_bytes,
 1015bb4:	ab18      	add	r3, sp, #96	; 0x60
 1015bb6:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 1015bba:	1870      	adds	r0, r6, r1
 1015bbc:	f000 fe23 	bl	1016806 <uECC_vli_nativeToBytes>
#ifdef TINYCRYPT_ARCH_HAS_SET_SECURE
extern void _set_secure(void *to, uint8_t val, unsigned int len);
#else /* ! TINYCRYPT_ARCH_HAS_SET_SECURE */
static inline void _set_secure(void *to, uint8_t val, unsigned int len)
{
  (void) memset(to, val, len);
 1015bc0:	2220      	movs	r2, #32
 1015bc2:	2100      	movs	r1, #0
 1015bc4:	4628      	mov	r0, r5
 1015bc6:	f000 ff52 	bl	1016a6e <memset>

			/* erasing temporary buffer that stored secret: */
			_set_secure(_private, 0, NUM_ECC_BYTES);

      			return 1;
 1015bca:	2001      	movs	r0, #1
    		}
  	}
	return 0;
}
 1015bcc:	b029      	add	sp, #164	; 0xa4
 1015bce:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
 1015bd2:	3f01      	subs	r7, #1
 1015bd4:	d1bb      	bne.n	1015b4e <uECC_make_key+0x12>
        		return 0;
 1015bd6:	2000      	movs	r0, #0
 1015bd8:	e7f8      	b.n	1015bcc <uECC_make_key+0x90>

01015bda <uECC_shared_secret>:

int uECC_shared_secret(const uint8_t *public_key, const uint8_t *private_key,
		       uint8_t *secret, uECC_Curve curve)
{
 1015bda:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1015bde:	4681      	mov	r9, r0
 1015be0:	461c      	mov	r4, r3
	uECC_word_t tmp[NUM_ECC_WORDS];
	uECC_word_t *p2[2] = {_private, tmp};
	uECC_word_t *initial_Z = 0;
	uECC_word_t carry;
	wordcount_t num_words = curve->num_words;
	wordcount_t num_bytes = curve->num_bytes;
 1015be2:	f993 7001 	ldrsb.w	r7, [r3, #1]
	wordcount_t num_words = curve->num_words;
 1015be6:	f993 a000 	ldrsb.w	sl, [r3]
	int r;

	/* Converting buffers to correct bit order: */
	uECC_vli_bytesToNative(_private,
      			       private_key,
			       BITS_TO_BYTES(curve->num_n_bits));
 1015bea:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
{
 1015bee:	b0a4      	sub	sp, #144	; 0x90
 1015bf0:	4690      	mov	r8, r2
	uECC_vli_bytesToNative(_private,
 1015bf2:	1dda      	adds	r2, r3, #7
 1015bf4:	bf48      	it	mi
 1015bf6:	f103 020e 	addmi.w	r2, r3, #14
	uECC_word_t *p2[2] = {_private, tmp};
 1015bfa:	ad04      	add	r5, sp, #16
	uECC_vli_bytesToNative(_private,
 1015bfc:	4628      	mov	r0, r5
	uECC_word_t *p2[2] = {_private, tmp};
 1015bfe:	ae0c      	add	r6, sp, #48	; 0x30
	uECC_vli_bytesToNative(_private,
 1015c00:	10d2      	asrs	r2, r2, #3
	uECC_word_t *p2[2] = {_private, tmp};
 1015c02:	9502      	str	r5, [sp, #8]
 1015c04:	9603      	str	r6, [sp, #12]
	uECC_vli_bytesToNative(_private,
 1015c06:	f000 fe12 	bl	101682e <uECC_vli_bytesToNative>
	uECC_vli_bytesToNative(_public,
 1015c0a:	463a      	mov	r2, r7
 1015c0c:	4649      	mov	r1, r9
 1015c0e:	a814      	add	r0, sp, #80	; 0x50
 1015c10:	f000 fe0d 	bl	101682e <uECC_vli_bytesToNative>
      			       public_key,
			       num_bytes);
	uECC_vli_bytesToNative(_public + num_words,
 1015c14:	ab14      	add	r3, sp, #80	; 0x50
 1015c16:	eb09 0107 	add.w	r1, r9, r7
 1015c1a:	eb03 008a 	add.w	r0, r3, sl, lsl #2
 1015c1e:	463a      	mov	r2, r7
 1015c20:	f000 fe05 	bl	101682e <uECC_vli_bytesToNative>
			       public_key + num_bytes,
			       num_bytes);

	/* Regularize the bitcount for the private key so that attackers cannot use a
	 * side channel attack to learn the number of leading zeros. */
	carry = regularize_k(_private, _private, tmp, curve);
 1015c24:	4623      	mov	r3, r4
 1015c26:	4632      	mov	r2, r6
 1015c28:	4629      	mov	r1, r5
 1015c2a:	4628      	mov	r0, r5
 1015c2c:	f000 fd97 	bl	101675e <regularize_k>
			goto clear_and_out;
    		}
    		initial_Z = p2[carry];
  	}

	EccPoint_mult(_public, _public, p2[!carry], initial_Z, curve->num_n_bits + 1,
 1015c30:	fab0 f080 	clz	r0, r0
 1015c34:	9401      	str	r4, [sp, #4]
 1015c36:	ab24      	add	r3, sp, #144	; 0x90
 1015c38:	0940      	lsrs	r0, r0, #5
 1015c3a:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 1015c3e:	8863      	ldrh	r3, [r4, #2]
 1015c40:	a914      	add	r1, sp, #80	; 0x50
 1015c42:	3301      	adds	r3, #1
 1015c44:	b21b      	sxth	r3, r3
 1015c46:	9300      	str	r3, [sp, #0]
 1015c48:	f850 2c88 	ldr.w	r2, [r0, #-136]
 1015c4c:	2300      	movs	r3, #0
 1015c4e:	4608      	mov	r0, r1
 1015c50:	f000 fcb6 	bl	10165c0 <EccPoint_mult>
		      curve);

	uECC_vli_nativeToBytes(secret, num_bytes, _public);
 1015c54:	aa14      	add	r2, sp, #80	; 0x50
 1015c56:	4639      	mov	r1, r7
 1015c58:	4640      	mov	r0, r8
 1015c5a:	f000 fdd4 	bl	1016806 <uECC_vli_nativeToBytes>
	r = !EccPoint_isZero(_public, curve);
 1015c5e:	4621      	mov	r1, r4
 1015c60:	a814      	add	r0, sp, #80	; 0x50
 1015c62:	f000 fc22 	bl	10164aa <EccPoint_isZero>
 1015c66:	af02      	add	r7, sp, #8
 1015c68:	4604      	mov	r4, r0
 1015c6a:	2208      	movs	r2, #8
 1015c6c:	2100      	movs	r1, #0
 1015c6e:	4638      	mov	r0, r7
 1015c70:	f000 fefd 	bl	1016a6e <memset>
 1015c74:	2220      	movs	r2, #32
 1015c76:	2100      	movs	r1, #0
 1015c78:	4630      	mov	r0, r6
 1015c7a:	f000 fef8 	bl	1016a6e <memset>
 1015c7e:	2220      	movs	r2, #32
 1015c80:	2100      	movs	r1, #0
 1015c82:	4628      	mov	r0, r5
 1015c84:	f000 fef3 	bl	1016a6e <memset>
	_set_secure(p2, 0, sizeof(p2));
	_set_secure(tmp, 0, sizeof(tmp));
	_set_secure(_private, 0, sizeof(_private));

	return r;
}
 1015c88:	fab4 f084 	clz	r0, r4
 1015c8c:	0940      	lsrs	r0, r0, #5
 1015c8e:	b024      	add	sp, #144	; 0x90
 1015c90:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

01015c94 <uECC_vli_add>:
{
 1015c94:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0; i < num_words; ++i) {
 1015c96:	2400      	movs	r4, #0
{
 1015c98:	4606      	mov	r6, r0
	uECC_word_t carry = 0;
 1015c9a:	4620      	mov	r0, r4
	for (i = 0; i < num_words; ++i) {
 1015c9c:	b265      	sxtb	r5, r4
 1015c9e:	42ab      	cmp	r3, r5
 1015ca0:	dc00      	bgt.n	1015ca4 <uECC_vli_add+0x10>
}
 1015ca2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uECC_word_t sum = left[i] + right[i] + carry;
 1015ca4:	f851 7024 	ldr.w	r7, [r1, r4, lsl #2]
 1015ca8:	f852 5024 	ldr.w	r5, [r2, r4, lsl #2]
 1015cac:	443d      	add	r5, r7
 1015cae:	4405      	add	r5, r0
		carry = cond_set(val, carry, (sum != left[i]));
 1015cb0:	42af      	cmp	r7, r5
		uECC_word_t val = (sum < left[i]);
 1015cb2:	bf8c      	ite	hi
 1015cb4:	2701      	movhi	r7, #1
 1015cb6:	2700      	movls	r7, #0
		result[i] = sum;
 1015cb8:	f846 5024 	str.w	r5, [r6, r4, lsl #2]
	return (p_true*(cond)) | (p_false*(!cond));
 1015cbc:	bf18      	it	ne
 1015cbe:	4638      	movne	r0, r7
	for (i = 0; i < num_words; ++i) {
 1015cc0:	3401      	adds	r4, #1
 1015cc2:	e7eb      	b.n	1015c9c <uECC_vli_add+0x8>

01015cc4 <uECC_vli_rshift1>:
	uECC_word_t carry = 0;
 1015cc4:	2300      	movs	r3, #0
	vli += num_words;
 1015cc6:	eb00 0181 	add.w	r1, r0, r1, lsl #2
	while (vli-- > end) {
 1015cca:	4288      	cmp	r0, r1
 1015ccc:	d300      	bcc.n	1015cd0 <uECC_vli_rshift1+0xc>
}
 1015cce:	4770      	bx	lr
		uECC_word_t temp = *vli;
 1015cd0:	f851 2d04 	ldr.w	r2, [r1, #-4]!
		*vli = (temp >> 1) | carry;
 1015cd4:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
 1015cd8:	600b      	str	r3, [r1, #0]
		carry = temp << (uECC_WORD_BITS - 1);
 1015cda:	07d3      	lsls	r3, r2, #31
 1015cdc:	e7f5      	b.n	1015cca <uECC_vli_rshift1+0x6>

01015cde <vli_modInv_update>:
	if (!EVEN(uv)) {
 1015cde:	6803      	ldr	r3, [r0, #0]
{
 1015ce0:	b570      	push	{r4, r5, r6, lr}
	if (!EVEN(uv)) {
 1015ce2:	f013 0601 	ands.w	r6, r3, #1
{
 1015ce6:	4605      	mov	r5, r0
 1015ce8:	4614      	mov	r4, r2
	if (!EVEN(uv)) {
 1015cea:	d005      	beq.n	1015cf8 <vli_modInv_update+0x1a>
		carry = uECC_vli_add(uv, uv, mod, num_words);
 1015cec:	4613      	mov	r3, r2
 1015cee:	460a      	mov	r2, r1
 1015cf0:	4601      	mov	r1, r0
 1015cf2:	f7ff ffcf 	bl	1015c94 <uECC_vli_add>
 1015cf6:	4606      	mov	r6, r0
	uECC_vli_rshift1(uv, num_words);
 1015cf8:	4621      	mov	r1, r4
 1015cfa:	4628      	mov	r0, r5
 1015cfc:	f7ff ffe2 	bl	1015cc4 <uECC_vli_rshift1>
	if (carry) {
 1015d00:	b146      	cbz	r6, 1015d14 <vli_modInv_update+0x36>
		uv[num_words - 1] |= HIGH_BIT_SET;
 1015d02:	f104 4280 	add.w	r2, r4, #1073741824	; 0x40000000
 1015d06:	3a01      	subs	r2, #1
 1015d08:	f855 3022 	ldr.w	r3, [r5, r2, lsl #2]
 1015d0c:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 1015d10:	f845 3022 	str.w	r3, [r5, r2, lsl #2]
}
 1015d14:	bd70      	pop	{r4, r5, r6, pc}

01015d16 <uECC_vli_mult>:
{
 1015d16:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (k = 0; k < num_words; ++k) {
 1015d1a:	2500      	movs	r5, #0
{
 1015d1c:	b087      	sub	sp, #28
 1015d1e:	e9cd 1200 	strd	r1, r2, [sp]
	uECC_word_t r1 = 0;
 1015d22:	462c      	mov	r4, r5
	uECC_word_t r0 = 0;
 1015d24:	462a      	mov	r2, r5
	for (k = 0; k < num_words; ++k) {
 1015d26:	fa4f f885 	sxtb.w	r8, r5
 1015d2a:	4543      	cmp	r3, r8
 1015d2c:	dc14      	bgt.n	1015d58 <uECC_vli_mult+0x42>
	for (k = num_words; k < num_words * 2 - 1; ++k) {
 1015d2e:	f04f 0a00 	mov.w	sl, #0
 1015d32:	005d      	lsls	r5, r3, #1
 1015d34:	3d01      	subs	r5, #1
 1015d36:	9502      	str	r5, [sp, #8]
 1015d38:	fa5f f58a 	uxtb.w	r5, sl
 1015d3c:	9e02      	ldr	r6, [sp, #8]
 1015d3e:	eb05 0c03 	add.w	ip, r5, r3
 1015d42:	fa4f fc8c 	sxtb.w	ip, ip
 1015d46:	45b4      	cmp	ip, r6
 1015d48:	db2d      	blt.n	1015da6 <uECC_vli_mult+0x90>
	result[num_words * 2 - 1] = r0;
 1015d4a:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
 1015d4e:	f840 2c04 	str.w	r2, [r0, #-4]
}
 1015d52:	b007      	add	sp, #28
 1015d54:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (k = 0; k < num_words; ++k) {
 1015d58:	f04f 0c00 	mov.w	ip, #0
 1015d5c:	46e6      	mov	lr, ip
 1015d5e:	9e01      	ldr	r6, [sp, #4]
 1015d60:	eb06 0985 	add.w	r9, r6, r5, lsl #2
	uECC_dword_t p = (uECC_dword_t)a * b;
 1015d64:	9900      	ldr	r1, [sp, #0]
			muladd(left[i], right[k - i], &r0, &r1, &r2);
 1015d66:	f859 7904 	ldr.w	r7, [r9], #-4
	uECC_dword_t p = (uECC_dword_t)a * b;
 1015d6a:	f851 602c 	ldr.w	r6, [r1, ip, lsl #2]
	uECC_dword_t r01 = ((uECC_dword_t)(*r1) << uECC_WORD_BITS) | *r0;
 1015d6e:	e9cd 2402 	strd	r2, r4, [sp, #8]
	uECC_dword_t p = (uECC_dword_t)a * b;
 1015d72:	fba7 ab06 	umull	sl, fp, r7, r6
 1015d76:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
 1015d7a:	eb1a 0601 	adds.w	r6, sl, r1
 1015d7e:	eb5b 0702 	adcs.w	r7, fp, r2
 1015d82:	bf2c      	ite	cs
 1015d84:	2201      	movcs	r2, #1
 1015d86:	2200      	movcc	r2, #0
	*r2 += (r01 < p);
 1015d88:	f10c 0c01 	add.w	ip, ip, #1
		for (i = 0; i <= k; ++i) {
 1015d8c:	fa4f fa8c 	sxtb.w	sl, ip
 1015d90:	45c2      	cmp	sl, r8
	*r2 += (r01 < p);
 1015d92:	4496      	add	lr, r2
	*r1 = r01 >> uECC_WORD_BITS;
 1015d94:	463c      	mov	r4, r7
	*r0 = (uECC_word_t)r01;
 1015d96:	4632      	mov	r2, r6
		for (i = 0; i <= k; ++i) {
 1015d98:	dde4      	ble.n	1015d64 <uECC_vli_mult+0x4e>
		result[k] = r0;
 1015d9a:	f840 6025 	str.w	r6, [r0, r5, lsl #2]
	*r1 = r01 >> uECC_WORD_BITS;
 1015d9e:	463a      	mov	r2, r7
	*r2 += (r01 < p);
 1015da0:	4674      	mov	r4, lr
 1015da2:	3501      	adds	r5, #1
 1015da4:	e7bf      	b.n	1015d26 <uECC_vli_mult+0x10>
		for (i = (k + 1) - num_words; i < num_words; ++i) {
 1015da6:	9900      	ldr	r1, [sp, #0]
 1015da8:	3501      	adds	r5, #1
 1015daa:	b26d      	sxtb	r5, r5
 1015dac:	eb01 0b85 	add.w	fp, r1, r5, lsl #2
 1015db0:	4621      	mov	r1, r4
 1015db2:	2400      	movs	r4, #0
 1015db4:	9e01      	ldr	r6, [sp, #4]
 1015db6:	ebac 0e05 	sub.w	lr, ip, r5
 1015dba:	eb06 0e8e 	add.w	lr, r6, lr, lsl #2
 1015dbe:	429d      	cmp	r5, r3
 1015dc0:	db05      	blt.n	1015dce <uECC_vli_mult+0xb8>
		result[k] = r0;
 1015dc2:	f840 202c 	str.w	r2, [r0, ip, lsl #2]
	for (k = num_words; k < num_words * 2 - 1; ++k) {
 1015dc6:	f10a 0a01 	add.w	sl, sl, #1
		result[k] = r0;
 1015dca:	460a      	mov	r2, r1
 1015dcc:	e7b4      	b.n	1015d38 <uECC_vli_mult+0x22>
			muladd(left[i], right[k - i], &r0, &r1, &r2);
 1015dce:	f85b 7b04 	ldr.w	r7, [fp], #4
 1015dd2:	f85e 6904 	ldr.w	r6, [lr], #-4
	uECC_dword_t r01 = ((uECC_dword_t)(*r1) << uECC_WORD_BITS) | *r0;
 1015dd6:	e9cd 2104 	strd	r2, r1, [sp, #16]
	uECC_dword_t p = (uECC_dword_t)a * b;
 1015dda:	fba7 6706 	umull	r6, r7, r7, r6
 1015dde:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
 1015de2:	eb16 0801 	adds.w	r8, r6, r1
 1015de6:	eb57 0902 	adcs.w	r9, r7, r2
 1015dea:	bf2c      	ite	cs
 1015dec:	2201      	movcs	r2, #1
 1015dee:	2200      	movcc	r2, #0
		for (i = (k + 1) - num_words; i < num_words; ++i) {
 1015df0:	3501      	adds	r5, #1
	*r2 += (r01 < p);
 1015df2:	4414      	add	r4, r2
	*r1 = r01 >> uECC_WORD_BITS;
 1015df4:	4649      	mov	r1, r9
	*r0 = (uECC_word_t)r01;
 1015df6:	4642      	mov	r2, r8
		for (i = (k + 1) - num_words; i < num_words; ++i) {
 1015df8:	b26d      	sxtb	r5, r5
 1015dfa:	e7e0      	b.n	1015dbe <uECC_vli_mult+0xa8>

01015dfc <uECC_vli_clear>:
	for (i = 0; i < num_words; ++i) {
 1015dfc:	2300      	movs	r3, #0
{
 1015dfe:	b510      	push	{r4, lr}
		 vli[i] = 0;
 1015e00:	461c      	mov	r4, r3
	for (i = 0; i < num_words; ++i) {
 1015e02:	b25a      	sxtb	r2, r3
 1015e04:	4291      	cmp	r1, r2
 1015e06:	dc00      	bgt.n	1015e0a <uECC_vli_clear+0xe>
}
 1015e08:	bd10      	pop	{r4, pc}
		 vli[i] = 0;
 1015e0a:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
	for (i = 0; i < num_words; ++i) {
 1015e0e:	3301      	adds	r3, #1
 1015e10:	e7f7      	b.n	1015e02 <uECC_vli_clear+0x6>

01015e12 <uECC_vli_isZero>:
	for (i = 0; i < num_words; ++i) {
 1015e12:	2300      	movs	r3, #0
	uECC_word_t bits = 0;
 1015e14:	461a      	mov	r2, r3
{
 1015e16:	b510      	push	{r4, lr}
	for (i = 0; i < num_words; ++i) {
 1015e18:	b25c      	sxtb	r4, r3
 1015e1a:	42a1      	cmp	r1, r4
 1015e1c:	dc03      	bgt.n	1015e26 <uECC_vli_isZero+0x14>
}
 1015e1e:	fab2 f082 	clz	r0, r2
 1015e22:	0940      	lsrs	r0, r0, #5
 1015e24:	bd10      	pop	{r4, pc}
		bits |= vli[i];
 1015e26:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
 1015e2a:	3301      	adds	r3, #1
 1015e2c:	4322      	orrs	r2, r4
	for (i = 0; i < num_words; ++i) {
 1015e2e:	e7f3      	b.n	1015e18 <uECC_vli_isZero+0x6>

01015e30 <uECC_vli_testBit>:
		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
 1015e30:	2301      	movs	r3, #1
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
 1015e32:	114a      	asrs	r2, r1, #5
 1015e34:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
 1015e38:	f001 011f 	and.w	r1, r1, #31
 1015e3c:	fa03 f101 	lsl.w	r1, r3, r1
}
 1015e40:	4008      	ands	r0, r1
 1015e42:	4770      	bx	lr

01015e44 <uECC_vli_numBits>:
{
 1015e44:	4603      	mov	r3, r0
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
 1015e46:	3901      	subs	r1, #1
 1015e48:	b249      	sxtb	r1, r1
 1015e4a:	eb00 0281 	add.w	r2, r0, r1, lsl #2
 1015e4e:	2900      	cmp	r1, #0
 1015e50:	da03      	bge.n	1015e5a <uECC_vli_numBits+0x16>
	return (i + 1);
 1015e52:	3101      	adds	r1, #1
 1015e54:	b248      	sxtb	r0, r1
	if (num_digits == 0) {
 1015e56:	b938      	cbnz	r0, 1015e68 <uECC_vli_numBits+0x24>
 1015e58:	4770      	bx	lr
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
 1015e5a:	f852 0904 	ldr.w	r0, [r2], #-4
 1015e5e:	2800      	cmp	r0, #0
 1015e60:	d1f7      	bne.n	1015e52 <uECC_vli_numBits+0xe>
 1015e62:	3901      	subs	r1, #1
 1015e64:	b249      	sxtb	r1, r1
 1015e66:	e7f2      	b.n	1015e4e <uECC_vli_numBits+0xa>
	for (i = 0; digit; ++i) {
 1015e68:	2100      	movs	r1, #0
	digit = vli[num_digits - 1];
 1015e6a:	f100 4280 	add.w	r2, r0, #1073741824	; 0x40000000
 1015e6e:	3a01      	subs	r2, #1
 1015e70:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
	for (i = 0; digit; ++i) {
 1015e74:	b923      	cbnz	r3, 1015e80 <uECC_vli_numBits+0x3c>
	return (((bitcount_t)(num_digits - 1) << uECC_WORD_BITS_SHIFT) + i);
 1015e76:	3801      	subs	r0, #1
 1015e78:	eb01 1040 	add.w	r0, r1, r0, lsl #5
 1015e7c:	b200      	sxth	r0, r0
}
 1015e7e:	4770      	bx	lr
		digit >>= 1;
 1015e80:	085b      	lsrs	r3, r3, #1
	for (i = 0; digit; ++i) {
 1015e82:	3101      	adds	r1, #1
 1015e84:	e7f6      	b.n	1015e74 <uECC_vli_numBits+0x30>

01015e86 <uECC_vli_set>:
	for (i = 0; i < num_words; ++i) {
 1015e86:	2300      	movs	r3, #0
{
 1015e88:	b510      	push	{r4, lr}
	for (i = 0; i < num_words; ++i) {
 1015e8a:	b25c      	sxtb	r4, r3
 1015e8c:	42a2      	cmp	r2, r4
 1015e8e:	dc00      	bgt.n	1015e92 <uECC_vli_set+0xc>
}
 1015e90:	bd10      	pop	{r4, pc}
		dest[i] = src[i];
 1015e92:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
 1015e96:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
	for (i = 0; i < num_words; ++i) {
 1015e9a:	3301      	adds	r3, #1
 1015e9c:	e7f5      	b.n	1015e8a <uECC_vli_set+0x4>

01015e9e <uECC_vli_cmp_unsafe>:
{
 1015e9e:	b530      	push	{r4, r5, lr}
	for (i = num_words - 1; i >= 0; --i) {
 1015ea0:	3a01      	subs	r2, #1
 1015ea2:	b252      	sxtb	r2, r2
 1015ea4:	0093      	lsls	r3, r2, #2
 1015ea6:	2a00      	cmp	r2, #0
 1015ea8:	da01      	bge.n	1015eae <uECC_vli_cmp_unsafe+0x10>
	return 0;
 1015eaa:	2000      	movs	r0, #0
}
 1015eac:	bd30      	pop	{r4, r5, pc}
		if (left[i] > right[i]) {
 1015eae:	58c5      	ldr	r5, [r0, r3]
 1015eb0:	58cc      	ldr	r4, [r1, r3]
 1015eb2:	42a5      	cmp	r5, r4
 1015eb4:	d805      	bhi.n	1015ec2 <uECC_vli_cmp_unsafe+0x24>
		} else if (left[i] < right[i]) {
 1015eb6:	f1a3 0304 	sub.w	r3, r3, #4
 1015eba:	d304      	bcc.n	1015ec6 <uECC_vli_cmp_unsafe+0x28>
	for (i = num_words - 1; i >= 0; --i) {
 1015ebc:	3a01      	subs	r2, #1
 1015ebe:	b252      	sxtb	r2, r2
 1015ec0:	e7f1      	b.n	1015ea6 <uECC_vli_cmp_unsafe+0x8>
			return 1;
 1015ec2:	2001      	movs	r0, #1
 1015ec4:	e7f2      	b.n	1015eac <uECC_vli_cmp_unsafe+0xe>
			return -1;
 1015ec6:	f04f 30ff 	mov.w	r0, #4294967295
 1015eca:	e7ef      	b.n	1015eac <uECC_vli_cmp_unsafe+0xe>

01015ecc <uECC_vli_equal>:
{
 1015ecc:	b570      	push	{r4, r5, r6, lr}
	uECC_word_t diff = 0;
 1015ece:	2400      	movs	r4, #0
	for (i = num_words - 1; i >= 0; --i) {
 1015ed0:	3a01      	subs	r2, #1
 1015ed2:	b252      	sxtb	r2, r2
 1015ed4:	0093      	lsls	r3, r2, #2
 1015ed6:	2a00      	cmp	r2, #0
 1015ed8:	da03      	bge.n	1015ee2 <uECC_vli_equal+0x16>
}
 1015eda:	1e20      	subs	r0, r4, #0
 1015edc:	bf18      	it	ne
 1015ede:	2001      	movne	r0, #1
 1015ee0:	bd70      	pop	{r4, r5, r6, pc}
		diff |= (left[i] ^ right[i]);
 1015ee2:	58c5      	ldr	r5, [r0, r3]
 1015ee4:	58ce      	ldr	r6, [r1, r3]
	for (i = num_words - 1; i >= 0; --i) {
 1015ee6:	3a01      	subs	r2, #1
		diff |= (left[i] ^ right[i]);
 1015ee8:	4075      	eors	r5, r6
 1015eea:	432c      	orrs	r4, r5
	for (i = num_words - 1; i >= 0; --i) {
 1015eec:	b252      	sxtb	r2, r2
 1015eee:	3b04      	subs	r3, #4
 1015ef0:	e7f1      	b.n	1015ed6 <uECC_vli_equal+0xa>

01015ef2 <uECC_vli_sub>:
{
 1015ef2:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0; i < num_words; ++i) {
 1015ef4:	2400      	movs	r4, #0
{
 1015ef6:	4606      	mov	r6, r0
 1015ef8:	469c      	mov	ip, r3
	uECC_word_t borrow = 0;
 1015efa:	4620      	mov	r0, r4
	for (i = 0; i < num_words; ++i) {
 1015efc:	b265      	sxtb	r5, r4
 1015efe:	45ac      	cmp	ip, r5
 1015f00:	dc00      	bgt.n	1015f04 <uECC_vli_sub+0x12>
}
 1015f02:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uECC_word_t diff = left[i] - right[i] - borrow;
 1015f04:	f851 7024 	ldr.w	r7, [r1, r4, lsl #2]
 1015f08:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
 1015f0c:	1a3d      	subs	r5, r7, r0
 1015f0e:	1aed      	subs	r5, r5, r3
		borrow = cond_set(val, borrow, (diff != left[i]));
 1015f10:	42af      	cmp	r7, r5
		uECC_word_t val = (diff > left[i]);
 1015f12:	bf34      	ite	cc
 1015f14:	2701      	movcc	r7, #1
 1015f16:	2700      	movcs	r7, #0
		result[i] = diff;
 1015f18:	f846 5024 	str.w	r5, [r6, r4, lsl #2]
	return (p_true*(cond)) | (p_false*(!cond));
 1015f1c:	bf18      	it	ne
 1015f1e:	4638      	movne	r0, r7
	for (i = 0; i < num_words; ++i) {
 1015f20:	3401      	adds	r4, #1
 1015f22:	e7eb      	b.n	1015efc <uECC_vli_sub+0xa>

01015f24 <uECC_vli_modAdd>:
{
 1015f24:	b570      	push	{r4, r5, r6, lr}
 1015f26:	f99d 6010 	ldrsb.w	r6, [sp, #16]
 1015f2a:	461d      	mov	r5, r3
	uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
 1015f2c:	4633      	mov	r3, r6
{
 1015f2e:	4604      	mov	r4, r0
	uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
 1015f30:	f7ff feb0 	bl	1015c94 <uECC_vli_add>
	if (carry || uECC_vli_cmp_unsafe(mod, result, num_words) != 1) {
 1015f34:	b930      	cbnz	r0, 1015f44 <uECC_vli_modAdd+0x20>
 1015f36:	4632      	mov	r2, r6
 1015f38:	4621      	mov	r1, r4
 1015f3a:	4628      	mov	r0, r5
 1015f3c:	f7ff ffaf 	bl	1015e9e <uECC_vli_cmp_unsafe>
 1015f40:	2801      	cmp	r0, #1
 1015f42:	d007      	beq.n	1015f54 <uECC_vli_modAdd+0x30>
		uECC_vli_sub(result, result, mod, num_words);
 1015f44:	4633      	mov	r3, r6
 1015f46:	462a      	mov	r2, r5
 1015f48:	4621      	mov	r1, r4
 1015f4a:	4620      	mov	r0, r4
}
 1015f4c:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		uECC_vli_sub(result, result, mod, num_words);
 1015f50:	f7ff bfcf 	b.w	1015ef2 <uECC_vli_sub>
}
 1015f54:	bd70      	pop	{r4, r5, r6, pc}

01015f56 <uECC_vli_modSub>:
{
 1015f56:	b570      	push	{r4, r5, r6, lr}
 1015f58:	f99d 6010 	ldrsb.w	r6, [sp, #16]
 1015f5c:	461d      	mov	r5, r3
	uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
 1015f5e:	4633      	mov	r3, r6
{
 1015f60:	4604      	mov	r4, r0
	uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
 1015f62:	f7ff ffc6 	bl	1015ef2 <uECC_vli_sub>
	if (l_borrow) {
 1015f66:	b138      	cbz	r0, 1015f78 <uECC_vli_modSub+0x22>
		uECC_vli_add(result, result, mod, num_words);
 1015f68:	4633      	mov	r3, r6
 1015f6a:	462a      	mov	r2, r5
 1015f6c:	4621      	mov	r1, r4
 1015f6e:	4620      	mov	r0, r4
}
 1015f70:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		uECC_vli_add(result, result, mod, num_words);
 1015f74:	f7ff be8e 	b.w	1015c94 <uECC_vli_add>
}
 1015f78:	bd70      	pop	{r4, r5, r6, pc}

01015f7a <uECC_vli_mmod>:
{
 1015f7a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1015f7e:	461d      	mov	r5, r3
 1015f80:	b0a5      	sub	sp, #148	; 0x94
	uECC_word_t *v[2] = {tmp, product};
 1015f82:	ab14      	add	r3, sp, #80	; 0x50
 1015f84:	e9cd 3102 	strd	r3, r1, [sp, #8]
{
 1015f88:	4680      	mov	r8, r0
			   uECC_vli_numBits(mod, num_words);
 1015f8a:	4629      	mov	r1, r5
 1015f8c:	4610      	mov	r0, r2
{
 1015f8e:	4616      	mov	r6, r2
			   uECC_vli_numBits(mod, num_words);
 1015f90:	f7ff ff58 	bl	1015e44 <uECC_vli_numBits>
	bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) -
 1015f94:	ebc0 1485 	rsb	r4, r0, r5, lsl #6
 1015f98:	b224      	sxth	r4, r4
	wordcount_t word_shift = shift / uECC_WORD_BITS;
 1015f9a:	4621      	mov	r1, r4
 1015f9c:	2c00      	cmp	r4, #0
 1015f9e:	bfb8      	it	lt
 1015fa0:	f104 011f 	addlt.w	r1, r4, #31
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
 1015fa4:	4263      	negs	r3, r4
	wordcount_t word_shift = shift / uECC_WORD_BITS;
 1015fa6:	f341 1147 	sbfx	r1, r1, #5, #8
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
 1015faa:	f003 031f 	and.w	r3, r3, #31
	uECC_vli_clear(mod_multiple, word_shift);
 1015fae:	a804      	add	r0, sp, #16
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
 1015fb0:	f004 071f 	and.w	r7, r4, #31
 1015fb4:	bf58      	it	pl
 1015fb6:	425f      	negpl	r7, r3
	uECC_vli_clear(mod_multiple, word_shift);
 1015fb8:	f7ff ff20 	bl	1015dfc <uECC_vli_clear>
	if (bit_shift > 0) {
 1015fbc:	2f00      	cmp	r7, #0
 1015fbe:	ea4f 0081 	mov.w	r0, r1, lsl #2
 1015fc2:	dd2c      	ble.n	101601e <uECC_vli_mmod+0xa4>
	uECC_word_t carry = 0;
 1015fc4:	2200      	movs	r2, #0
 1015fc6:	ab04      	add	r3, sp, #16
 1015fc8:	1819      	adds	r1, r3, r0
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
 1015fca:	4613      	mov	r3, r2
			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
 1015fcc:	f1c7 0e20 	rsb	lr, r7, #32
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
 1015fd0:	429d      	cmp	r5, r3
 1015fd2:	d819      	bhi.n	1016008 <uECC_vli_mmod+0x8e>
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
 1015fd4:	2601      	movs	r6, #1
		for (i = 0; i < num_words * 2; ++i) {
 1015fd6:	006b      	lsls	r3, r5, #1
 1015fd8:	9300      	str	r3, [sp, #0]
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
 1015fda:	00ab      	lsls	r3, r5, #2
 1015fdc:	9301      	str	r3, [sp, #4]
 1015fde:	ab04      	add	r3, sp, #16
 1015fe0:	eb03 0985 	add.w	r9, r3, r5, lsl #2
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
 1015fe4:	1e6f      	subs	r7, r5, #1
 1015fe6:	ab24      	add	r3, sp, #144	; 0x90
 1015fe8:	eb03 0787 	add.w	r7, r3, r7, lsl #2
	for (index = 1; shift >= 0; --shift) {
 1015fec:	2c00      	cmp	r4, #0
 1015fee:	da54      	bge.n	101609a <uECC_vli_mmod+0x120>
	uECC_vli_set(result, v[index], num_words);
 1015ff0:	ab24      	add	r3, sp, #144	; 0x90
 1015ff2:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 1015ff6:	462a      	mov	r2, r5
 1015ff8:	4640      	mov	r0, r8
 1015ffa:	f856 1c88 	ldr.w	r1, [r6, #-136]
 1015ffe:	f7ff ff42 	bl	1015e86 <uECC_vli_set>
}
 1016002:	b025      	add	sp, #148	; 0x94
 1016004:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
 1016008:	f856 c023 	ldr.w	ip, [r6, r3, lsl #2]
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
 101600c:	3301      	adds	r3, #1
			mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
 101600e:	fa0c f007 	lsl.w	r0, ip, r7
 1016012:	4302      	orrs	r2, r0
 1016014:	f841 2b04 	str.w	r2, [r1], #4
			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
 1016018:	fa2c f20e 	lsr.w	r2, ip, lr
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
 101601c:	e7d8      	b.n	1015fd0 <uECC_vli_mmod+0x56>
		uECC_vli_set(mod_multiple + word_shift, mod, num_words);
 101601e:	ab04      	add	r3, sp, #16
 1016020:	462a      	mov	r2, r5
 1016022:	4631      	mov	r1, r6
 1016024:	4418      	add	r0, r3
 1016026:	f7ff ff2e 	bl	1015e86 <uECC_vli_set>
 101602a:	e7d3      	b.n	1015fd4 <uECC_vli_mmod+0x5a>
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
 101602c:	f85a 3c88 	ldr.w	r3, [sl, #-136]
 1016030:	f10c 0c01 	add.w	ip, ip, #1
 1016034:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 1016038:	ab24      	add	r3, sp, #144	; 0x90
 101603a:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 101603e:	f853 3c80 	ldr.w	r3, [r3, #-128]
 1016042:	440b      	add	r3, r1
 1016044:	1ad3      	subs	r3, r2, r3
 1016046:	bf34      	ite	cc
 1016048:	f04f 0b01 	movcc.w	fp, #1
 101604c:	f04f 0b00 	movcs.w	fp, #0
			if (diff != v[index][i]) {
 1016050:	429a      	cmp	r2, r3
				borrow = (diff > v[index][i]);
 1016052:	bf18      	it	ne
 1016054:	4659      	movne	r1, fp
			v[1 - index][i] = diff;
 1016056:	f85e 2c88 	ldr.w	r2, [lr, #-136]
 101605a:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
		for (i = 0; i < num_words * 2; ++i) {
 101605e:	9b00      	ldr	r3, [sp, #0]
 1016060:	fa4f f08c 	sxtb.w	r0, ip
 1016064:	4298      	cmp	r0, r3
 1016066:	dbe1      	blt.n	101602c <uECC_vli_mmod+0xb2>
		index = !(index ^ borrow);
 1016068:	1a73      	subs	r3, r6, r1
 101606a:	425e      	negs	r6, r3
		uECC_vli_rshift1(mod_multiple, num_words);
 101606c:	4629      	mov	r1, r5
 101606e:	a804      	add	r0, sp, #16
		index = !(index ^ borrow);
 1016070:	415e      	adcs	r6, r3
		uECC_vli_rshift1(mod_multiple, num_words);
 1016072:	f7ff fe27 	bl	1015cc4 <uECC_vli_rshift1>
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
 1016076:	9a01      	ldr	r2, [sp, #4]
 1016078:	ab24      	add	r3, sp, #144	; 0x90
 101607a:	4413      	add	r3, r2
 101607c:	f853 2c80 	ldr.w	r2, [r3, #-128]
 1016080:	f857 3c80 	ldr.w	r3, [r7, #-128]
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
 1016084:	4629      	mov	r1, r5
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
 1016086:	ea43 73c2 	orr.w	r3, r3, r2, lsl #31
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
 101608a:	4648      	mov	r0, r9
	for (index = 1; shift >= 0; --shift) {
 101608c:	3c01      	subs	r4, #1
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
 101608e:	f847 3c80 	str.w	r3, [r7, #-128]
	for (index = 1; shift >= 0; --shift) {
 1016092:	b224      	sxth	r4, r4
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
 1016094:	f7ff fe16 	bl	1015cc4 <uECC_vli_rshift1>
	for (index = 1; shift >= 0; --shift) {
 1016098:	e7a8      	b.n	1015fec <uECC_vli_mmod+0x72>
 101609a:	f04f 0c00 	mov.w	ip, #0
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
 101609e:	ab24      	add	r3, sp, #144	; 0x90
			v[1 - index][i] = diff;
 10160a0:	f1c6 0e01 	rsb	lr, r6, #1
		uECC_word_t borrow = 0;
 10160a4:	4661      	mov	r1, ip
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
 10160a6:	eb03 0a86 	add.w	sl, r3, r6, lsl #2
			v[1 - index][i] = diff;
 10160aa:	eb03 0e8e 	add.w	lr, r3, lr, lsl #2
 10160ae:	e7d6      	b.n	101605e <uECC_vli_mmod+0xe4>

010160b0 <uECC_vli_modMult_fast>:
{
 10160b0:	b530      	push	{r4, r5, lr}
 10160b2:	4605      	mov	r5, r0
 10160b4:	461c      	mov	r4, r3
 10160b6:	b091      	sub	sp, #68	; 0x44
	uECC_vli_mult(product, left, right, curve->num_words);
 10160b8:	4668      	mov	r0, sp
 10160ba:	f993 3000 	ldrsb.w	r3, [r3]
 10160be:	f7ff fe2a 	bl	1015d16 <uECC_vli_mult>
	curve->mmod_fast(result, product);
 10160c2:	4669      	mov	r1, sp
 10160c4:	4628      	mov	r0, r5
 10160c6:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 10160ca:	4798      	blx	r3
}
 10160cc:	b011      	add	sp, #68	; 0x44
 10160ce:	bd30      	pop	{r4, r5, pc}

010160d0 <uECC_vli_modSquare_fast>:
{
 10160d0:	4613      	mov	r3, r2
	uECC_vli_modMult_fast(result, left, left, curve);
 10160d2:	460a      	mov	r2, r1
 10160d4:	f7ff bfec 	b.w	10160b0 <uECC_vli_modMult_fast>

010160d8 <double_jacobian_default>:
{
 10160d8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	wordcount_t num_words = curve->num_words;
 10160dc:	f993 6000 	ldrsb.w	r6, [r3]
{
 10160e0:	4604      	mov	r4, r0
 10160e2:	4689      	mov	r9, r1
 10160e4:	b092      	sub	sp, #72	; 0x48
	if (uECC_vli_isZero(Z1, num_words)) {
 10160e6:	4631      	mov	r1, r6
 10160e8:	4610      	mov	r0, r2
{
 10160ea:	4615      	mov	r5, r2
 10160ec:	461f      	mov	r7, r3
	if (uECC_vli_isZero(Z1, num_words)) {
 10160ee:	f7ff fe90 	bl	1015e12 <uECC_vli_isZero>
 10160f2:	2800      	cmp	r0, #0
 10160f4:	f040 8091 	bne.w	101621a <double_jacobian_default+0x142>
	uECC_vli_modSquare_fast(t4, Y1, curve);   /* t4 = y1^2 */
 10160f8:	463a      	mov	r2, r7
 10160fa:	4649      	mov	r1, r9
 10160fc:	a802      	add	r0, sp, #8
 10160fe:	f7ff ffe7 	bl	10160d0 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(t5, X1, t4, curve); /* t5 = x1*y1^2 = A */
 1016102:	463b      	mov	r3, r7
 1016104:	4621      	mov	r1, r4
 1016106:	aa02      	add	r2, sp, #8
 1016108:	a80a      	add	r0, sp, #40	; 0x28
 101610a:	f7ff ffd1 	bl	10160b0 <uECC_vli_modMult_fast>
	uECC_vli_modSquare_fast(t4, t4, curve);   /* t4 = y1^4 */
 101610e:	a902      	add	r1, sp, #8
 1016110:	4608      	mov	r0, r1
 1016112:	463a      	mov	r2, r7
 1016114:	f7ff ffdc 	bl	10160d0 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(Y1, Y1, Z1, curve); /* t2 = y1*z1 = z3 */
 1016118:	463b      	mov	r3, r7
 101611a:	462a      	mov	r2, r5
 101611c:	4649      	mov	r1, r9
 101611e:	4648      	mov	r0, r9
 1016120:	f7ff ffc6 	bl	10160b0 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
 1016124:	f107 0804 	add.w	r8, r7, #4
	uECC_vli_modSquare_fast(Z1, Z1, curve);   /* t3 = z1^2 */
 1016128:	463a      	mov	r2, r7
 101612a:	4629      	mov	r1, r5
 101612c:	4628      	mov	r0, r5
 101612e:	f7ff ffcf 	bl	10160d0 <uECC_vli_modSquare_fast>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
 1016132:	4643      	mov	r3, r8
 1016134:	462a      	mov	r2, r5
 1016136:	4621      	mov	r1, r4
 1016138:	4620      	mov	r0, r4
 101613a:	9600      	str	r6, [sp, #0]
 101613c:	f7ff fef2 	bl	1015f24 <uECC_vli_modAdd>
	uECC_vli_modAdd(Z1, Z1, Z1, curve->p, num_words); /* t3 = 2*z1^2 */
 1016140:	4643      	mov	r3, r8
 1016142:	462a      	mov	r2, r5
 1016144:	4629      	mov	r1, r5
 1016146:	4628      	mov	r0, r5
 1016148:	9600      	str	r6, [sp, #0]
 101614a:	f7ff feeb 	bl	1015f24 <uECC_vli_modAdd>
	uECC_vli_modSub(Z1, X1, Z1, curve->p, num_words); /* t3 = x1 - z1^2 */
 101614e:	4643      	mov	r3, r8
 1016150:	462a      	mov	r2, r5
 1016152:	4621      	mov	r1, r4
 1016154:	4628      	mov	r0, r5
 1016156:	9600      	str	r6, [sp, #0]
 1016158:	f7ff fefd 	bl	1015f56 <uECC_vli_modSub>
	uECC_vli_modMult_fast(X1, X1, Z1, curve); /* t1 = x1^2 - z1^4 */
 101615c:	463b      	mov	r3, r7
 101615e:	462a      	mov	r2, r5
 1016160:	4621      	mov	r1, r4
 1016162:	4620      	mov	r0, r4
 1016164:	f7ff ffa4 	bl	10160b0 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(Z1, X1, X1, curve->p, num_words); /* t3 = 2*(x1^2 - z1^4) */
 1016168:	4643      	mov	r3, r8
 101616a:	4622      	mov	r2, r4
 101616c:	4621      	mov	r1, r4
 101616e:	4628      	mov	r0, r5
 1016170:	9600      	str	r6, [sp, #0]
 1016172:	f7ff fed7 	bl	1015f24 <uECC_vli_modAdd>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = 3*(x1^2 - z1^4) */
 1016176:	4643      	mov	r3, r8
 1016178:	462a      	mov	r2, r5
 101617a:	4621      	mov	r1, r4
 101617c:	4620      	mov	r0, r4
 101617e:	9600      	str	r6, [sp, #0]
 1016180:	f7ff fed0 	bl	1015f24 <uECC_vli_modAdd>
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
 1016184:	6823      	ldr	r3, [r4, #0]
	if (uECC_vli_testBit(X1, 0)) {
 1016186:	07db      	lsls	r3, r3, #31
 1016188:	d54a      	bpl.n	1016220 <double_jacobian_default+0x148>
		uECC_word_t l_carry = uECC_vli_add(X1, X1, curve->p, num_words);
 101618a:	4633      	mov	r3, r6
 101618c:	4642      	mov	r2, r8
 101618e:	4621      	mov	r1, r4
 1016190:	4620      	mov	r0, r4
 1016192:	f7ff fd7f 	bl	1015c94 <uECC_vli_add>
 1016196:	4682      	mov	sl, r0
		uECC_vli_rshift1(X1, num_words);
 1016198:	4631      	mov	r1, r6
 101619a:	4620      	mov	r0, r4
 101619c:	f7ff fd92 	bl	1015cc4 <uECC_vli_rshift1>
		X1[num_words - 1] |= l_carry << (uECC_WORD_BITS - 1);
 10161a0:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
 10161a4:	3b01      	subs	r3, #1
 10161a6:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
 10161aa:	ea42 72ca 	orr.w	r2, r2, sl, lsl #31
 10161ae:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
	uECC_vli_modSquare_fast(Z1, X1, curve); /* t3 = B^2 */
 10161b2:	463a      	mov	r2, r7
 10161b4:	4621      	mov	r1, r4
 10161b6:	4628      	mov	r0, r5
 10161b8:	f7ff ff8a 	bl	10160d0 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - A */
 10161bc:	4643      	mov	r3, r8
 10161be:	4629      	mov	r1, r5
 10161c0:	4628      	mov	r0, r5
 10161c2:	aa0a      	add	r2, sp, #40	; 0x28
 10161c4:	9600      	str	r6, [sp, #0]
 10161c6:	f7ff fec6 	bl	1015f56 <uECC_vli_modSub>
	uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - 2A = x3 */
 10161ca:	4643      	mov	r3, r8
 10161cc:	4629      	mov	r1, r5
 10161ce:	4628      	mov	r0, r5
 10161d0:	aa0a      	add	r2, sp, #40	; 0x28
 10161d2:	9600      	str	r6, [sp, #0]
 10161d4:	f7ff febf 	bl	1015f56 <uECC_vli_modSub>
	uECC_vli_modSub(t5, t5, Z1, curve->p, num_words); /* t5 = A - x3 */
 10161d8:	a90a      	add	r1, sp, #40	; 0x28
 10161da:	4608      	mov	r0, r1
 10161dc:	4643      	mov	r3, r8
 10161de:	462a      	mov	r2, r5
 10161e0:	9600      	str	r6, [sp, #0]
 10161e2:	f7ff feb8 	bl	1015f56 <uECC_vli_modSub>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = B * (A - x3) */
 10161e6:	463b      	mov	r3, r7
 10161e8:	4621      	mov	r1, r4
 10161ea:	4620      	mov	r0, r4
 10161ec:	aa0a      	add	r2, sp, #40	; 0x28
 10161ee:	f7ff ff5f 	bl	10160b0 <uECC_vli_modMult_fast>
	uECC_vli_modSub(t4, X1, t4, curve->p, num_words);
 10161f2:	aa02      	add	r2, sp, #8
 10161f4:	4643      	mov	r3, r8
 10161f6:	4610      	mov	r0, r2
 10161f8:	4621      	mov	r1, r4
 10161fa:	9600      	str	r6, [sp, #0]
 10161fc:	f7ff feab 	bl	1015f56 <uECC_vli_modSub>
	uECC_vli_set(X1, Z1, num_words);
 1016200:	4632      	mov	r2, r6
 1016202:	4629      	mov	r1, r5
 1016204:	4620      	mov	r0, r4
 1016206:	f7ff fe3e 	bl	1015e86 <uECC_vli_set>
	uECC_vli_set(Z1, Y1, num_words);
 101620a:	4649      	mov	r1, r9
 101620c:	4628      	mov	r0, r5
 101620e:	f7ff fe3a 	bl	1015e86 <uECC_vli_set>
	uECC_vli_set(Y1, t4, num_words);
 1016212:	4648      	mov	r0, r9
 1016214:	a902      	add	r1, sp, #8
 1016216:	f7ff fe36 	bl	1015e86 <uECC_vli_set>
}
 101621a:	b012      	add	sp, #72	; 0x48
 101621c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uECC_vli_rshift1(X1, num_words);
 1016220:	4631      	mov	r1, r6
 1016222:	4620      	mov	r0, r4
 1016224:	f7ff fd4e 	bl	1015cc4 <uECC_vli_rshift1>
 1016228:	e7c3      	b.n	10161b2 <double_jacobian_default+0xda>

0101622a <x_side_default>:
{
 101622a:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 101622e:	4615      	mov	r5, r2
 1016230:	b08a      	sub	sp, #40	; 0x28
 1016232:	4604      	mov	r4, r0
 1016234:	460e      	mov	r6, r1
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
 1016236:	221c      	movs	r2, #28
 1016238:	2100      	movs	r1, #0
 101623a:	a803      	add	r0, sp, #12
 101623c:	f000 fc17 	bl	1016a6e <memset>
 1016240:	2303      	movs	r3, #3
	wordcount_t num_words = curve->num_words;
 1016242:	f995 8000 	ldrsb.w	r8, [r5]
	uECC_vli_modSquare_fast(result, x, curve); /* r = x^2 */
 1016246:	462a      	mov	r2, r5
 1016248:	4631      	mov	r1, r6
 101624a:	4620      	mov	r0, r4
	uECC_vli_modSub(result, result, _3, curve->p, num_words); /* r = x^2 - 3 */
 101624c:	1d2f      	adds	r7, r5, #4
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
 101624e:	9302      	str	r3, [sp, #8]
	uECC_vli_modSquare_fast(result, x, curve); /* r = x^2 */
 1016250:	f7ff ff3e 	bl	10160d0 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(result, result, _3, curve->p, num_words); /* r = x^2 - 3 */
 1016254:	463b      	mov	r3, r7
 1016256:	4621      	mov	r1, r4
 1016258:	4620      	mov	r0, r4
 101625a:	aa02      	add	r2, sp, #8
 101625c:	f8cd 8000 	str.w	r8, [sp]
 1016260:	f7ff fe79 	bl	1015f56 <uECC_vli_modSub>
	uECC_vli_modMult_fast(result, result, x, curve); /* r = x^3 - 3x */
 1016264:	462b      	mov	r3, r5
 1016266:	4632      	mov	r2, r6
 1016268:	4621      	mov	r1, r4
 101626a:	4620      	mov	r0, r4
 101626c:	f7ff ff20 	bl	10160b0 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(result, result, curve->b, curve->p, num_words);
 1016270:	463b      	mov	r3, r7
 1016272:	4621      	mov	r1, r4
 1016274:	4620      	mov	r0, r4
 1016276:	f8cd 8000 	str.w	r8, [sp]
 101627a:	f105 0284 	add.w	r2, r5, #132	; 0x84
 101627e:	f7ff fe51 	bl	1015f24 <uECC_vli_modAdd>
}
 1016282:	b00a      	add	sp, #40	; 0x28
 1016284:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

01016288 <XYcZ_addC>:
   or P => P - Q, Q => P + Q
 */
static void XYcZ_addC(uECC_word_t * X1, uECC_word_t * Y1,
		      uECC_word_t * X2, uECC_word_t * Y2,
		      uECC_Curve curve)
{
 1016288:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 101628c:	b09a      	sub	sp, #104	; 0x68
 101628e:	f8dd 8088 	ldr.w	r8, [sp, #136]	; 0x88
 1016292:	4616      	mov	r6, r2
	/* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
	uECC_word_t t5[NUM_ECC_WORDS];
	uECC_word_t t6[NUM_ECC_WORDS];
	uECC_word_t t7[NUM_ECC_WORDS];
	wordcount_t num_words = curve->num_words;
 1016294:	4644      	mov	r4, r8
{
 1016296:	4607      	mov	r7, r0
 1016298:	4699      	mov	r9, r3
 101629a:	468a      	mov	sl, r1
	wordcount_t num_words = curve->num_words;
 101629c:	f914 5b04 	ldrsb.w	r5, [r4], #4

	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
 10162a0:	4602      	mov	r2, r0
 10162a2:	4623      	mov	r3, r4
 10162a4:	4631      	mov	r1, r6
 10162a6:	a802      	add	r0, sp, #8
 10162a8:	9500      	str	r5, [sp, #0]
 10162aa:	f7ff fe54 	bl	1015f56 <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, t5, curve); /* t5 = (x2 - x1)^2 = A */
 10162ae:	a902      	add	r1, sp, #8
 10162b0:	4642      	mov	r2, r8
 10162b2:	4608      	mov	r0, r1
 10162b4:	f7ff ff0c 	bl	10160d0 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = x1*A = B */
 10162b8:	4643      	mov	r3, r8
 10162ba:	4639      	mov	r1, r7
 10162bc:	4638      	mov	r0, r7
 10162be:	aa02      	add	r2, sp, #8
 10162c0:	f7ff fef6 	bl	10160b0 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(X2, X2, t5, curve); /* t3 = x2*A = C */
 10162c4:	4643      	mov	r3, r8
 10162c6:	4631      	mov	r1, r6
 10162c8:	4630      	mov	r0, r6
 10162ca:	aa02      	add	r2, sp, #8
 10162cc:	f7ff fef0 	bl	10160b0 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(t5, Y2, Y1, curve->p, num_words); /* t5 = y2 + y1 */
 10162d0:	4623      	mov	r3, r4
 10162d2:	4652      	mov	r2, sl
 10162d4:	4649      	mov	r1, r9
 10162d6:	a802      	add	r0, sp, #8
 10162d8:	9500      	str	r5, [sp, #0]
 10162da:	f7ff fe23 	bl	1015f24 <uECC_vli_modAdd>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
 10162de:	4623      	mov	r3, r4
 10162e0:	4652      	mov	r2, sl
 10162e2:	4649      	mov	r1, r9
 10162e4:	4648      	mov	r0, r9
 10162e6:	9500      	str	r5, [sp, #0]
 10162e8:	f7ff fe35 	bl	1015f56 <uECC_vli_modSub>

	uECC_vli_modSub(t6, X2, X1, curve->p, num_words); /* t6 = C - B */
 10162ec:	4623      	mov	r3, r4
 10162ee:	463a      	mov	r2, r7
 10162f0:	4631      	mov	r1, r6
 10162f2:	a80a      	add	r0, sp, #40	; 0x28
 10162f4:	9500      	str	r5, [sp, #0]
 10162f6:	f7ff fe2e 	bl	1015f56 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y1, Y1, t6, curve); /* t2 = y1 * (C - B) = E */
 10162fa:	4643      	mov	r3, r8
 10162fc:	4651      	mov	r1, sl
 10162fe:	4650      	mov	r0, sl
 1016300:	aa0a      	add	r2, sp, #40	; 0x28
 1016302:	f7ff fed5 	bl	10160b0 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(t6, X1, X2, curve->p, num_words); /* t6 = B + C */
 1016306:	4623      	mov	r3, r4
 1016308:	4632      	mov	r2, r6
 101630a:	4639      	mov	r1, r7
 101630c:	a80a      	add	r0, sp, #40	; 0x28
 101630e:	9500      	str	r5, [sp, #0]
 1016310:	f7ff fe08 	bl	1015f24 <uECC_vli_modAdd>
	uECC_vli_modSquare_fast(X2, Y2, curve); /* t3 = (y2 - y1)^2 = D */
 1016314:	4642      	mov	r2, r8
 1016316:	4649      	mov	r1, r9
 1016318:	4630      	mov	r0, r6
 101631a:	f7ff fed9 	bl	10160d0 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(X2, X2, t6, curve->p, num_words); /* t3 = D - (B + C) = x3 */
 101631e:	4623      	mov	r3, r4
 1016320:	4631      	mov	r1, r6
 1016322:	4630      	mov	r0, r6
 1016324:	aa0a      	add	r2, sp, #40	; 0x28
 1016326:	9500      	str	r5, [sp, #0]
 1016328:	f7ff fe15 	bl	1015f56 <uECC_vli_modSub>

	uECC_vli_modSub(t7, X1, X2, curve->p, num_words); /* t7 = B - x3 */
 101632c:	4623      	mov	r3, r4
 101632e:	4632      	mov	r2, r6
 1016330:	4639      	mov	r1, r7
 1016332:	a812      	add	r0, sp, #72	; 0x48
 1016334:	9500      	str	r5, [sp, #0]
 1016336:	f7ff fe0e 	bl	1015f56 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y2, Y2, t7, curve); /* t4 = (y2 - y1)*(B - x3) */
 101633a:	4643      	mov	r3, r8
 101633c:	4649      	mov	r1, r9
 101633e:	4648      	mov	r0, r9
 1016340:	aa12      	add	r2, sp, #72	; 0x48
 1016342:	f7ff feb5 	bl	10160b0 <uECC_vli_modMult_fast>
	/* t4 = (y2 - y1)*(B - x3) - E = y3: */
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words);
 1016346:	4623      	mov	r3, r4
 1016348:	4652      	mov	r2, sl
 101634a:	4649      	mov	r1, r9
 101634c:	4648      	mov	r0, r9
 101634e:	9500      	str	r5, [sp, #0]
 1016350:	f7ff fe01 	bl	1015f56 <uECC_vli_modSub>

	uECC_vli_modSquare_fast(t7, t5, curve); /* t7 = (y2 + y1)^2 = F */
 1016354:	4642      	mov	r2, r8
 1016356:	a902      	add	r1, sp, #8
 1016358:	a812      	add	r0, sp, #72	; 0x48
 101635a:	f7ff feb9 	bl	10160d0 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(t7, t7, t6, curve->p, num_words); /* t7 = F - (B + C) = x3' */
 101635e:	a912      	add	r1, sp, #72	; 0x48
 1016360:	4623      	mov	r3, r4
 1016362:	4608      	mov	r0, r1
 1016364:	aa0a      	add	r2, sp, #40	; 0x28
 1016366:	9500      	str	r5, [sp, #0]
 1016368:	f7ff fdf5 	bl	1015f56 <uECC_vli_modSub>
	uECC_vli_modSub(t6, t7, X1, curve->p, num_words); /* t6 = x3' - B */
 101636c:	4623      	mov	r3, r4
 101636e:	463a      	mov	r2, r7
 1016370:	a912      	add	r1, sp, #72	; 0x48
 1016372:	a80a      	add	r0, sp, #40	; 0x28
 1016374:	9500      	str	r5, [sp, #0]
 1016376:	f7ff fdee 	bl	1015f56 <uECC_vli_modSub>
	uECC_vli_modMult_fast(t6, t6, t5, curve); /* t6 = (y2+y1)*(x3' - B) */
 101637a:	a90a      	add	r1, sp, #40	; 0x28
 101637c:	4643      	mov	r3, r8
 101637e:	4608      	mov	r0, r1
 1016380:	aa02      	add	r2, sp, #8
 1016382:	f7ff fe95 	bl	10160b0 <uECC_vli_modMult_fast>
	/* t2 = (y2+y1)*(x3' - B) - E = y3': */
	uECC_vli_modSub(Y1, t6, Y1, curve->p, num_words);
 1016386:	4623      	mov	r3, r4
 1016388:	4652      	mov	r2, sl
 101638a:	4650      	mov	r0, sl
 101638c:	a90a      	add	r1, sp, #40	; 0x28
 101638e:	9500      	str	r5, [sp, #0]
 1016390:	f7ff fde1 	bl	1015f56 <uECC_vli_modSub>

	uECC_vli_set(X1, t7, num_words);
 1016394:	462a      	mov	r2, r5
 1016396:	4638      	mov	r0, r7
 1016398:	a912      	add	r1, sp, #72	; 0x48
 101639a:	f7ff fd74 	bl	1015e86 <uECC_vli_set>
}
 101639e:	b01a      	add	sp, #104	; 0x68
 10163a0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

010163a4 <uECC_vli_modInv>:
{
 10163a4:	b5f0      	push	{r4, r5, r6, r7, lr}
 10163a6:	460f      	mov	r7, r1
 10163a8:	4606      	mov	r6, r0
 10163aa:	b0a1      	sub	sp, #132	; 0x84
	if (uECC_vli_isZero(input, num_words)) {
 10163ac:	4619      	mov	r1, r3
 10163ae:	4638      	mov	r0, r7
{
 10163b0:	4615      	mov	r5, r2
 10163b2:	461c      	mov	r4, r3
	if (uECC_vli_isZero(input, num_words)) {
 10163b4:	f7ff fd2d 	bl	1015e12 <uECC_vli_isZero>
 10163b8:	b120      	cbz	r0, 10163c4 <uECC_vli_modInv+0x20>
		uECC_vli_clear(result, num_words);
 10163ba:	4630      	mov	r0, r6
 10163bc:	f7ff fd1e 	bl	1015dfc <uECC_vli_clear>
}
 10163c0:	b021      	add	sp, #132	; 0x84
 10163c2:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uECC_vli_set(a, input, num_words);
 10163c4:	4622      	mov	r2, r4
 10163c6:	4639      	mov	r1, r7
 10163c8:	4668      	mov	r0, sp
 10163ca:	f7ff fd5c 	bl	1015e86 <uECC_vli_set>
	uECC_vli_set(b, mod, num_words);
 10163ce:	4629      	mov	r1, r5
 10163d0:	a808      	add	r0, sp, #32
 10163d2:	f7ff fd58 	bl	1015e86 <uECC_vli_set>
	uECC_vli_clear(u, num_words);
 10163d6:	a810      	add	r0, sp, #64	; 0x40
 10163d8:	4621      	mov	r1, r4
 10163da:	f7ff fd0f 	bl	1015dfc <uECC_vli_clear>
	u[0] = 1;
 10163de:	2301      	movs	r3, #1
	uECC_vli_clear(v, num_words);
 10163e0:	a818      	add	r0, sp, #96	; 0x60
	u[0] = 1;
 10163e2:	9310      	str	r3, [sp, #64]	; 0x40
	uECC_vli_clear(v, num_words);
 10163e4:	f7ff fd0a 	bl	1015dfc <uECC_vli_clear>
	while ((cmpResult = uECC_vli_cmp_unsafe(a, b, num_words)) != 0) {
 10163e8:	4622      	mov	r2, r4
 10163ea:	4668      	mov	r0, sp
 10163ec:	a908      	add	r1, sp, #32
 10163ee:	f7ff fd56 	bl	1015e9e <uECC_vli_cmp_unsafe>
 10163f2:	b928      	cbnz	r0, 1016400 <uECC_vli_modInv+0x5c>
  	uECC_vli_set(result, u, num_words);
 10163f4:	4622      	mov	r2, r4
 10163f6:	4630      	mov	r0, r6
 10163f8:	a910      	add	r1, sp, #64	; 0x40
 10163fa:	f7ff fd44 	bl	1015e86 <uECC_vli_set>
 10163fe:	e7df      	b.n	10163c0 <uECC_vli_modInv+0x1c>
		if (EVEN(a)) {
 1016400:	9b00      	ldr	r3, [sp, #0]
 1016402:	07da      	lsls	r2, r3, #31
 1016404:	d409      	bmi.n	101641a <uECC_vli_modInv+0x76>
			uECC_vli_rshift1(a, num_words);
 1016406:	4621      	mov	r1, r4
 1016408:	4668      	mov	r0, sp
 101640a:	f7ff fc5b 	bl	1015cc4 <uECC_vli_rshift1>
      			vli_modInv_update(u, mod, num_words);
 101640e:	4622      	mov	r2, r4
 1016410:	4629      	mov	r1, r5
 1016412:	a810      	add	r0, sp, #64	; 0x40
      			vli_modInv_update(v, mod, num_words);
 1016414:	f7ff fc63 	bl	1015cde <vli_modInv_update>
 1016418:	e7e6      	b.n	10163e8 <uECC_vli_modInv+0x44>
    		} else if (EVEN(b)) {
 101641a:	9b08      	ldr	r3, [sp, #32]
 101641c:	07db      	lsls	r3, r3, #31
 101641e:	d407      	bmi.n	1016430 <uECC_vli_modInv+0x8c>
			uECC_vli_rshift1(b, num_words);
 1016420:	4621      	mov	r1, r4
 1016422:	a808      	add	r0, sp, #32
 1016424:	f7ff fc4e 	bl	1015cc4 <uECC_vli_rshift1>
      			vli_modInv_update(v, mod, num_words);
 1016428:	4622      	mov	r2, r4
 101642a:	4629      	mov	r1, r5
 101642c:	a818      	add	r0, sp, #96	; 0x60
 101642e:	e7f1      	b.n	1016414 <uECC_vli_modInv+0x70>
		} else if (cmpResult > 0) {
 1016430:	2800      	cmp	r0, #0
			uECC_vli_sub(a, a, b, num_words);
 1016432:	4623      	mov	r3, r4
		} else if (cmpResult > 0) {
 1016434:	dd1c      	ble.n	1016470 <uECC_vli_modInv+0xcc>
			uECC_vli_sub(a, a, b, num_words);
 1016436:	aa08      	add	r2, sp, #32
 1016438:	4669      	mov	r1, sp
 101643a:	4668      	mov	r0, sp
 101643c:	f7ff fd59 	bl	1015ef2 <uECC_vli_sub>
			uECC_vli_rshift1(a, num_words);
 1016440:	4621      	mov	r1, r4
 1016442:	4668      	mov	r0, sp
 1016444:	f7ff fc3e 	bl	1015cc4 <uECC_vli_rshift1>
			if (uECC_vli_cmp_unsafe(u, v, num_words) < 0) {
 1016448:	4622      	mov	r2, r4
 101644a:	a918      	add	r1, sp, #96	; 0x60
 101644c:	a810      	add	r0, sp, #64	; 0x40
 101644e:	f7ff fd26 	bl	1015e9e <uECC_vli_cmp_unsafe>
 1016452:	2800      	cmp	r0, #0
 1016454:	da05      	bge.n	1016462 <uECC_vli_modInv+0xbe>
        			uECC_vli_add(u, u, mod, num_words);
 1016456:	a910      	add	r1, sp, #64	; 0x40
 1016458:	4623      	mov	r3, r4
 101645a:	462a      	mov	r2, r5
 101645c:	4608      	mov	r0, r1
 101645e:	f7ff fc19 	bl	1015c94 <uECC_vli_add>
      			uECC_vli_sub(u, u, v, num_words);
 1016462:	a910      	add	r1, sp, #64	; 0x40
 1016464:	4623      	mov	r3, r4
 1016466:	4608      	mov	r0, r1
 1016468:	aa18      	add	r2, sp, #96	; 0x60
 101646a:	f7ff fd42 	bl	1015ef2 <uECC_vli_sub>
 101646e:	e7ce      	b.n	101640e <uECC_vli_modInv+0x6a>
      			uECC_vli_sub(b, b, a, num_words);
 1016470:	a908      	add	r1, sp, #32
 1016472:	466a      	mov	r2, sp
 1016474:	4608      	mov	r0, r1
 1016476:	f7ff fd3c 	bl	1015ef2 <uECC_vli_sub>
      			uECC_vli_rshift1(b, num_words);
 101647a:	4621      	mov	r1, r4
 101647c:	a808      	add	r0, sp, #32
 101647e:	f7ff fc21 	bl	1015cc4 <uECC_vli_rshift1>
      			if (uECC_vli_cmp_unsafe(v, u, num_words) < 0) {
 1016482:	4622      	mov	r2, r4
 1016484:	a910      	add	r1, sp, #64	; 0x40
 1016486:	a818      	add	r0, sp, #96	; 0x60
 1016488:	f7ff fd09 	bl	1015e9e <uECC_vli_cmp_unsafe>
 101648c:	2800      	cmp	r0, #0
 101648e:	da05      	bge.n	101649c <uECC_vli_modInv+0xf8>
        			uECC_vli_add(v, v, mod, num_words);
 1016490:	a918      	add	r1, sp, #96	; 0x60
 1016492:	4623      	mov	r3, r4
 1016494:	462a      	mov	r2, r5
 1016496:	4608      	mov	r0, r1
 1016498:	f7ff fbfc 	bl	1015c94 <uECC_vli_add>
      			uECC_vli_sub(v, v, u, num_words);
 101649c:	a918      	add	r1, sp, #96	; 0x60
 101649e:	4623      	mov	r3, r4
 10164a0:	4608      	mov	r0, r1
 10164a2:	aa10      	add	r2, sp, #64	; 0x40
 10164a4:	f7ff fd25 	bl	1015ef2 <uECC_vli_sub>
 10164a8:	e7be      	b.n	1016428 <uECC_vli_modInv+0x84>

010164aa <EccPoint_isZero>:
	return uECC_vli_isZero(point, curve->num_words * 2);
 10164aa:	7809      	ldrb	r1, [r1, #0]
 10164ac:	0049      	lsls	r1, r1, #1
 10164ae:	b249      	sxtb	r1, r1
 10164b0:	f7ff bcaf 	b.w	1015e12 <uECC_vli_isZero>

010164b4 <apply_z>:
{
 10164b4:	b5f0      	push	{r4, r5, r6, r7, lr}
 10164b6:	4615      	mov	r5, r2
 10164b8:	461c      	mov	r4, r3
 10164ba:	4607      	mov	r7, r0
 10164bc:	460e      	mov	r6, r1
 10164be:	b089      	sub	sp, #36	; 0x24
	uECC_vli_modSquare_fast(t1, Z, curve);    /* z^2 */
 10164c0:	461a      	mov	r2, r3
 10164c2:	4629      	mov	r1, r5
 10164c4:	4668      	mov	r0, sp
 10164c6:	f7ff fe03 	bl	10160d0 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t1, curve); /* x1 * z^2 */
 10164ca:	4623      	mov	r3, r4
 10164cc:	466a      	mov	r2, sp
 10164ce:	4639      	mov	r1, r7
 10164d0:	4638      	mov	r0, r7
 10164d2:	f7ff fded 	bl	10160b0 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(t1, t1, Z, curve);  /* z^3 */
 10164d6:	4623      	mov	r3, r4
 10164d8:	462a      	mov	r2, r5
 10164da:	4669      	mov	r1, sp
 10164dc:	4668      	mov	r0, sp
 10164de:	f7ff fde7 	bl	10160b0 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(Y1, Y1, t1, curve); /* y1 * z^3 */
 10164e2:	4623      	mov	r3, r4
 10164e4:	466a      	mov	r2, sp
 10164e6:	4631      	mov	r1, r6
 10164e8:	4630      	mov	r0, r6
 10164ea:	f7ff fde1 	bl	10160b0 <uECC_vli_modMult_fast>
}
 10164ee:	b009      	add	sp, #36	; 0x24
 10164f0:	bdf0      	pop	{r4, r5, r6, r7, pc}

010164f2 <XYcZ_add>:
{
 10164f2:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 10164f6:	b08a      	sub	sp, #40	; 0x28
 10164f8:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
 10164fc:	4614      	mov	r4, r2
	wordcount_t num_words = curve->num_words;
 10164fe:	4655      	mov	r5, sl
{
 1016500:	4680      	mov	r8, r0
 1016502:	461f      	mov	r7, r3
 1016504:	4689      	mov	r9, r1
	wordcount_t num_words = curve->num_words;
 1016506:	f915 6b04 	ldrsb.w	r6, [r5], #4
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
 101650a:	4602      	mov	r2, r0
 101650c:	462b      	mov	r3, r5
 101650e:	4621      	mov	r1, r4
 1016510:	a802      	add	r0, sp, #8
 1016512:	9600      	str	r6, [sp, #0]
 1016514:	f7ff fd1f 	bl	1015f56 <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, t5, curve); /* t5 = (x2 - x1)^2 = A */
 1016518:	a902      	add	r1, sp, #8
 101651a:	4652      	mov	r2, sl
 101651c:	4608      	mov	r0, r1
 101651e:	f7ff fdd7 	bl	10160d0 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = x1*A = B */
 1016522:	4653      	mov	r3, sl
 1016524:	4641      	mov	r1, r8
 1016526:	4640      	mov	r0, r8
 1016528:	aa02      	add	r2, sp, #8
 101652a:	f7ff fdc1 	bl	10160b0 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(X2, X2, t5, curve); /* t3 = x2*A = C */
 101652e:	4653      	mov	r3, sl
 1016530:	4621      	mov	r1, r4
 1016532:	4620      	mov	r0, r4
 1016534:	aa02      	add	r2, sp, #8
 1016536:	f7ff fdbb 	bl	10160b0 <uECC_vli_modMult_fast>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
 101653a:	462b      	mov	r3, r5
 101653c:	464a      	mov	r2, r9
 101653e:	4639      	mov	r1, r7
 1016540:	4638      	mov	r0, r7
 1016542:	9600      	str	r6, [sp, #0]
 1016544:	f7ff fd07 	bl	1015f56 <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, Y2, curve); /* t5 = (y2 - y1)^2 = D */
 1016548:	4652      	mov	r2, sl
 101654a:	4639      	mov	r1, r7
 101654c:	a802      	add	r0, sp, #8
 101654e:	f7ff fdbf 	bl	10160d0 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(t5, t5, X1, curve->p, num_words); /* t5 = D - B */
 1016552:	a902      	add	r1, sp, #8
 1016554:	462b      	mov	r3, r5
 1016556:	4642      	mov	r2, r8
 1016558:	4608      	mov	r0, r1
 101655a:	9600      	str	r6, [sp, #0]
 101655c:	f7ff fcfb 	bl	1015f56 <uECC_vli_modSub>
	uECC_vli_modSub(t5, t5, X2, curve->p, num_words); /* t5 = D - B - C = x3 */
 1016560:	a902      	add	r1, sp, #8
 1016562:	462b      	mov	r3, r5
 1016564:	4622      	mov	r2, r4
 1016566:	4608      	mov	r0, r1
 1016568:	9600      	str	r6, [sp, #0]
 101656a:	f7ff fcf4 	bl	1015f56 <uECC_vli_modSub>
	uECC_vli_modSub(X2, X2, X1, curve->p, num_words); /* t3 = C - B */
 101656e:	462b      	mov	r3, r5
 1016570:	4642      	mov	r2, r8
 1016572:	4621      	mov	r1, r4
 1016574:	4620      	mov	r0, r4
 1016576:	9600      	str	r6, [sp, #0]
 1016578:	f7ff fced 	bl	1015f56 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y1, Y1, X2, curve); /* t2 = y1*(C - B) */
 101657c:	4653      	mov	r3, sl
 101657e:	4622      	mov	r2, r4
 1016580:	4649      	mov	r1, r9
 1016582:	4648      	mov	r0, r9
 1016584:	f7ff fd94 	bl	10160b0 <uECC_vli_modMult_fast>
	uECC_vli_modSub(X2, X1, t5, curve->p, num_words); /* t3 = B - x3 */
 1016588:	462b      	mov	r3, r5
 101658a:	4641      	mov	r1, r8
 101658c:	4620      	mov	r0, r4
 101658e:	aa02      	add	r2, sp, #8
 1016590:	9600      	str	r6, [sp, #0]
 1016592:	f7ff fce0 	bl	1015f56 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y2, Y2, X2, curve); /* t4 = (y2 - y1)*(B - x3) */
 1016596:	4653      	mov	r3, sl
 1016598:	4622      	mov	r2, r4
 101659a:	4639      	mov	r1, r7
 101659c:	4638      	mov	r0, r7
 101659e:	f7ff fd87 	bl	10160b0 <uECC_vli_modMult_fast>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y3 */
 10165a2:	462b      	mov	r3, r5
 10165a4:	464a      	mov	r2, r9
 10165a6:	4639      	mov	r1, r7
 10165a8:	4638      	mov	r0, r7
 10165aa:	9600      	str	r6, [sp, #0]
 10165ac:	f7ff fcd3 	bl	1015f56 <uECC_vli_modSub>
	uECC_vli_set(X2, t5, num_words);
 10165b0:	4632      	mov	r2, r6
 10165b2:	4620      	mov	r0, r4
 10165b4:	a902      	add	r1, sp, #8
 10165b6:	f7ff fc66 	bl	1015e86 <uECC_vli_set>
}
 10165ba:	b00a      	add	sp, #40	; 0x28
 10165bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

010165c0 <EccPoint_mult>:

void EccPoint_mult(uECC_word_t * result, const uECC_word_t * point,
		   const uECC_word_t * scalar,
		   const uECC_word_t * initial_Z,
		   bitcount_t num_bits, uECC_Curve curve) 
{
 10165c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10165c4:	461e      	mov	r6, r3
 10165c6:	b0b1      	sub	sp, #196	; 0xc4
 10165c8:	9c3b      	ldr	r4, [sp, #236]	; 0xec
 10165ca:	e9cd 0103 	strd	r0, r1, [sp, #12]
	uECC_word_t Rx[2][NUM_ECC_WORDS];
	uECC_word_t Ry[2][NUM_ECC_WORDS];
	uECC_word_t z[NUM_ECC_WORDS];
	bitcount_t i;
	uECC_word_t nb;
	wordcount_t num_words = curve->num_words;
 10165ce:	f994 7000 	ldrsb.w	r7, [r4]

	uECC_vli_set(Rx[1], point, num_words);
 10165d2:	a818      	add	r0, sp, #96	; 0x60
{
 10165d4:	4692      	mov	sl, r2
	uECC_vli_set(Rx[1], point, num_words);
 10165d6:	463a      	mov	r2, r7
 10165d8:	f7ff fc55 	bl	1015e86 <uECC_vli_set>
  	uECC_vli_set(Ry[1], point + num_words, num_words);
 10165dc:	00bb      	lsls	r3, r7, #2
 10165de:	9305      	str	r3, [sp, #20]
 10165e0:	9b04      	ldr	r3, [sp, #16]
 10165e2:	a828      	add	r0, sp, #160	; 0xa0
 10165e4:	eb03 0387 	add.w	r3, r3, r7, lsl #2
 10165e8:	4619      	mov	r1, r3
 10165ea:	9302      	str	r3, [sp, #8]
 10165ec:	f7ff fc4b 	bl	1015e86 <uECC_vli_set>
	wordcount_t num_words = curve->num_words;
 10165f0:	f994 5000 	ldrsb.w	r5, [r4]
	if (initial_Z) {
 10165f4:	2e00      	cmp	r6, #0
 10165f6:	f000 8088 	beq.w	101670a <EccPoint_mult+0x14a>
		uECC_vli_set(z, initial_Z, num_words);
 10165fa:	462a      	mov	r2, r5
 10165fc:	4631      	mov	r1, r6
 10165fe:	a808      	add	r0, sp, #32
 1016600:	f7ff fc41 	bl	1015e86 <uECC_vli_set>
	uECC_vli_set(X2, X1, num_words);
 1016604:	f10d 0840 	add.w	r8, sp, #64	; 0x40
 1016608:	462a      	mov	r2, r5
 101660a:	4640      	mov	r0, r8
 101660c:	a918      	add	r1, sp, #96	; 0x60
	uECC_vli_set(Y2, Y1, num_words);
 101660e:	f10d 0980 	add.w	r9, sp, #128	; 0x80
	uECC_vli_set(X2, X1, num_words);
 1016612:	f7ff fc38 	bl	1015e86 <uECC_vli_set>
	uECC_vli_set(Y2, Y1, num_words);
 1016616:	4648      	mov	r0, r9
 1016618:	a928      	add	r1, sp, #160	; 0xa0
 101661a:	f7ff fc34 	bl	1015e86 <uECC_vli_set>
	apply_z(X1, Y1, z, curve);
 101661e:	4623      	mov	r3, r4
 1016620:	aa08      	add	r2, sp, #32
 1016622:	a928      	add	r1, sp, #160	; 0xa0
 1016624:	a818      	add	r0, sp, #96	; 0x60
 1016626:	f7ff ff45 	bl	10164b4 <apply_z>
	curve->double_jacobian(X1, Y1, z, curve);
 101662a:	4623      	mov	r3, r4
 101662c:	f8d4 50a4 	ldr.w	r5, [r4, #164]	; 0xa4
 1016630:	aa08      	add	r2, sp, #32
 1016632:	a928      	add	r1, sp, #160	; 0xa0
 1016634:	a818      	add	r0, sp, #96	; 0x60
 1016636:	47a8      	blx	r5
	apply_z(X2, Y2, z, curve);
 1016638:	4623      	mov	r3, r4
 101663a:	4649      	mov	r1, r9
 101663c:	4640      	mov	r0, r8
 101663e:	aa08      	add	r2, sp, #32
 1016640:	f7ff ff38 	bl	10164b4 <apply_z>

	XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], initial_Z, curve);

	for (i = num_bits - 2; i > 0; --i) {
 1016644:	f9bd 50e8 	ldrsh.w	r5, [sp, #232]	; 0xe8
 1016648:	3d02      	subs	r5, #2
 101664a:	b22d      	sxth	r5, r5
 101664c:	2d00      	cmp	r5, #0
 101664e:	dc63      	bgt.n	1016718 <EccPoint_mult+0x158>
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
 1016650:	f8da 5000 	ldr.w	r5, [sl]
		XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
		XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
	}

	nb = !uECC_vli_testBit(scalar, 0);
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
 1016654:	ab10      	add	r3, sp, #64	; 0x40
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
 1016656:	f005 0601 	and.w	r6, r5, #1
 101665a:	43ed      	mvns	r5, r5
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
 101665c:	eb03 1846 	add.w	r8, r3, r6, lsl #5
 1016660:	ab20      	add	r3, sp, #128	; 0x80
 1016662:	eb03 1646 	add.w	r6, r3, r6, lsl #5
 1016666:	f005 0501 	and.w	r5, r5, #1
 101666a:	ab10      	add	r3, sp, #64	; 0x40
 101666c:	eb03 1945 	add.w	r9, r3, r5, lsl #5
 1016670:	ab20      	add	r3, sp, #128	; 0x80
 1016672:	eb03 1545 	add.w	r5, r3, r5, lsl #5

	/* Find final 1/Z value. */
	uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
 1016676:	f104 0a04 	add.w	sl, r4, #4
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
 101667a:	462b      	mov	r3, r5
 101667c:	464a      	mov	r2, r9
 101667e:	4631      	mov	r1, r6
 1016680:	4640      	mov	r0, r8
 1016682:	9400      	str	r4, [sp, #0]
 1016684:	f7ff fe00 	bl	1016288 <XYcZ_addC>
	uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
 1016688:	4653      	mov	r3, sl
 101668a:	aa10      	add	r2, sp, #64	; 0x40
 101668c:	a918      	add	r1, sp, #96	; 0x60
 101668e:	a808      	add	r0, sp, #32
 1016690:	9700      	str	r7, [sp, #0]
 1016692:	f7ff fc60 	bl	1015f56 <uECC_vli_modSub>
	uECC_vli_modMult_fast(z, z, Ry[1 - nb], curve); /* Yb * (X1 - X0) */
 1016696:	a908      	add	r1, sp, #32
 1016698:	4623      	mov	r3, r4
 101669a:	4632      	mov	r2, r6
 101669c:	4608      	mov	r0, r1
 101669e:	f7ff fd07 	bl	10160b0 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(z, z, point, curve); /* xP * Yb * (X1 - X0) */
 10166a2:	a908      	add	r1, sp, #32
 10166a4:	4623      	mov	r3, r4
 10166a6:	4608      	mov	r0, r1
 10166a8:	9a04      	ldr	r2, [sp, #16]
 10166aa:	f7ff fd01 	bl	10160b0 <uECC_vli_modMult_fast>
	uECC_vli_modInv(z, z, curve->p, num_words); /* 1 / (xP * Yb * (X1 - X0))*/
 10166ae:	a908      	add	r1, sp, #32
 10166b0:	463b      	mov	r3, r7
 10166b2:	4652      	mov	r2, sl
 10166b4:	4608      	mov	r0, r1
 10166b6:	f7ff fe75 	bl	10163a4 <uECC_vli_modInv>
	/* yP / (xP * Yb * (X1 - X0)) */
	uECC_vli_modMult_fast(z, z, point + num_words, curve);
 10166ba:	a908      	add	r1, sp, #32
 10166bc:	4623      	mov	r3, r4
 10166be:	4608      	mov	r0, r1
 10166c0:	9a02      	ldr	r2, [sp, #8]
 10166c2:	f7ff fcf5 	bl	10160b0 <uECC_vli_modMult_fast>
	/* Xb * yP / (xP * Yb * (X1 - X0)) */
	uECC_vli_modMult_fast(z, z, Rx[1 - nb], curve);
 10166c6:	a908      	add	r1, sp, #32
 10166c8:	4623      	mov	r3, r4
 10166ca:	4642      	mov	r2, r8
 10166cc:	4608      	mov	r0, r1
 10166ce:	f7ff fcef 	bl	10160b0 <uECC_vli_modMult_fast>
	/* End 1/Z calculation */

	XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
 10166d2:	4633      	mov	r3, r6
 10166d4:	4642      	mov	r2, r8
 10166d6:	4629      	mov	r1, r5
 10166d8:	4648      	mov	r0, r9
 10166da:	9400      	str	r4, [sp, #0]
 10166dc:	f7ff ff09 	bl	10164f2 <XYcZ_add>
	apply_z(Rx[0], Ry[0], z, curve);
 10166e0:	4623      	mov	r3, r4
 10166e2:	aa08      	add	r2, sp, #32
 10166e4:	a920      	add	r1, sp, #128	; 0x80
 10166e6:	a810      	add	r0, sp, #64	; 0x40
 10166e8:	f7ff fee4 	bl	10164b4 <apply_z>

	uECC_vli_set(result, Rx[0], num_words);
 10166ec:	463a      	mov	r2, r7
 10166ee:	9803      	ldr	r0, [sp, #12]
 10166f0:	a910      	add	r1, sp, #64	; 0x40
 10166f2:	f7ff fbc8 	bl	1015e86 <uECC_vli_set>
	uECC_vli_set(result + num_words, Ry[0], num_words);
 10166f6:	9b03      	ldr	r3, [sp, #12]
 10166f8:	9c05      	ldr	r4, [sp, #20]
 10166fa:	a920      	add	r1, sp, #128	; 0x80
 10166fc:	4423      	add	r3, r4
 10166fe:	4618      	mov	r0, r3
 1016700:	f7ff fbc1 	bl	1015e86 <uECC_vli_set>
}
 1016704:	b031      	add	sp, #196	; 0xc4
 1016706:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uECC_vli_clear(z, num_words);
 101670a:	4629      	mov	r1, r5
 101670c:	a808      	add	r0, sp, #32
 101670e:	f7ff fb75 	bl	1015dfc <uECC_vli_clear>
		z[0] = 1;
 1016712:	2301      	movs	r3, #1
 1016714:	9308      	str	r3, [sp, #32]
 1016716:	e775      	b.n	1016604 <EccPoint_mult+0x44>
		nb = !uECC_vli_testBit(scalar, i);
 1016718:	4629      	mov	r1, r5
 101671a:	4650      	mov	r0, sl
 101671c:	f7ff fb88 	bl	1015e30 <uECC_vli_testBit>
 1016720:	fab0 f680 	clz	r6, r0
 1016724:	0976      	lsrs	r6, r6, #5
		XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
 1016726:	f1c6 0101 	rsb	r1, r6, #1
 101672a:	eb08 1b46 	add.w	fp, r8, r6, lsl #5
 101672e:	eb09 1646 	add.w	r6, r9, r6, lsl #5
 1016732:	eb08 1041 	add.w	r0, r8, r1, lsl #5
 1016736:	4633      	mov	r3, r6
 1016738:	eb09 1141 	add.w	r1, r9, r1, lsl #5
 101673c:	465a      	mov	r2, fp
 101673e:	9400      	str	r4, [sp, #0]
 1016740:	e9cd 0106 	strd	r0, r1, [sp, #24]
 1016744:	f7ff fda0 	bl	1016288 <XYcZ_addC>
		XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
 1016748:	9907      	ldr	r1, [sp, #28]
 101674a:	9806      	ldr	r0, [sp, #24]
 101674c:	460b      	mov	r3, r1
 101674e:	4602      	mov	r2, r0
 1016750:	4631      	mov	r1, r6
 1016752:	4658      	mov	r0, fp
 1016754:	9400      	str	r4, [sp, #0]
 1016756:	f7ff fecc 	bl	10164f2 <XYcZ_add>
	for (i = num_bits - 2; i > 0; --i) {
 101675a:	3d01      	subs	r5, #1
 101675c:	e775      	b.n	101664a <EccPoint_mult+0x8a>

0101675e <regularize_k>:

uECC_word_t regularize_k(const uECC_word_t * const k, uECC_word_t *k0,
			 uECC_word_t *k1, uECC_Curve curve)
{
 101675e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1016762:	461d      	mov	r5, r3
 1016764:	460e      	mov	r6, r1

	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 1016766:	f9b3 9002 	ldrsh.w	r9, [r3, #2]

	bitcount_t num_n_bits = curve->num_n_bits;

	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 101676a:	3524      	adds	r5, #36	; 0x24
	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 101676c:	f119 081f 	adds.w	r8, r9, #31
 1016770:	bf48      	it	mi
 1016772:	f109 083e 	addmi.w	r8, r9, #62	; 0x3e
 1016776:	f348 1847 	sbfx	r8, r8, #5, #8
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 101677a:	4601      	mov	r1, r0
{
 101677c:	4617      	mov	r7, r2
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 101677e:	4643      	mov	r3, r8
 1016780:	462a      	mov	r2, r5
 1016782:	4630      	mov	r0, r6
 1016784:	f7ff fa86 	bl	1015c94 <uECC_vli_add>
 1016788:	4604      	mov	r4, r0
 101678a:	b990      	cbnz	r0, 10167b2 <regularize_k+0x54>
 101678c:	ebb9 1f48 	cmp.w	r9, r8, lsl #5
 1016790:	da06      	bge.n	10167a0 <regularize_k+0x42>
			     (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
			     uECC_vli_testBit(k0, num_n_bits));
 1016792:	4649      	mov	r1, r9
 1016794:	4630      	mov	r0, r6
 1016796:	f7ff fb4b 	bl	1015e30 <uECC_vli_testBit>
			     (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
 101679a:	1e04      	subs	r4, r0, #0
 101679c:	bf18      	it	ne
 101679e:	2401      	movne	r4, #1

	uECC_vli_add(k1, k0, curve->n, num_n_words);
 10167a0:	4643      	mov	r3, r8
 10167a2:	462a      	mov	r2, r5
 10167a4:	4631      	mov	r1, r6
 10167a6:	4638      	mov	r0, r7
 10167a8:	f7ff fa74 	bl	1015c94 <uECC_vli_add>

	return carry;
}
 10167ac:	4620      	mov	r0, r4
 10167ae:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 10167b2:	2401      	movs	r4, #1
 10167b4:	e7f4      	b.n	10167a0 <regularize_k+0x42>

010167b6 <EccPoint_compute_public_key>:

uECC_word_t EccPoint_compute_public_key(uECC_word_t *result,
					uECC_word_t *private_key,
					uECC_Curve curve)
{
 10167b6:	b530      	push	{r4, r5, lr}
 10167b8:	4614      	mov	r4, r2
 10167ba:	b095      	sub	sp, #84	; 0x54
 10167bc:	4605      	mov	r5, r0

	uECC_word_t tmp1[NUM_ECC_WORDS];
 	uECC_word_t tmp2[NUM_ECC_WORDS];
	uECC_word_t *p2[2] = {tmp1, tmp2};
 10167be:	aa0c      	add	r2, sp, #48	; 0x30
	uECC_word_t carry;

	/* Regularize the bitcount for the private key so that attackers cannot
	 * use a side channel attack to learn the number of leading zeros. */
	carry = regularize_k(private_key, tmp1, tmp2, curve);
 10167c0:	4623      	mov	r3, r4
{
 10167c2:	4608      	mov	r0, r1
	uECC_word_t *p2[2] = {tmp1, tmp2};
 10167c4:	a904      	add	r1, sp, #16
 10167c6:	9102      	str	r1, [sp, #8]
 10167c8:	9203      	str	r2, [sp, #12]
	carry = regularize_k(private_key, tmp1, tmp2, curve);
 10167ca:	f7ff ffc8 	bl	101675e <regularize_k>

	EccPoint_mult(result, curve->G, p2[!carry], 0, curve->num_n_bits + 1, curve);
 10167ce:	fab0 f380 	clz	r3, r0
 10167d2:	aa14      	add	r2, sp, #80	; 0x50
 10167d4:	095b      	lsrs	r3, r3, #5
 10167d6:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 10167da:	8863      	ldrh	r3, [r4, #2]
 10167dc:	9401      	str	r4, [sp, #4]
 10167de:	3301      	adds	r3, #1
 10167e0:	b21b      	sxth	r3, r3
 10167e2:	9300      	str	r3, [sp, #0]
 10167e4:	4628      	mov	r0, r5
 10167e6:	2300      	movs	r3, #0
 10167e8:	f852 2c48 	ldr.w	r2, [r2, #-72]
 10167ec:	f104 0144 	add.w	r1, r4, #68	; 0x44
 10167f0:	f7ff fee6 	bl	10165c0 <EccPoint_mult>

	if (EccPoint_isZero(result, curve)) {
 10167f4:	4621      	mov	r1, r4
 10167f6:	4628      	mov	r0, r5
 10167f8:	f7ff fe57 	bl	10164aa <EccPoint_isZero>
		return 0;
	}
	return 1;
}
 10167fc:	fab0 f080 	clz	r0, r0
 1016800:	0940      	lsrs	r0, r0, #5
 1016802:	b015      	add	sp, #84	; 0x54
 1016804:	bd30      	pop	{r4, r5, pc}

01016806 <uECC_vli_nativeToBytes>:

/* Converts an integer in uECC native format to big-endian bytes. */
void uECC_vli_nativeToBytes(uint8_t *bytes, int num_bytes,
			    const unsigned int *native)
{
 1016806:	b5f0      	push	{r4, r5, r6, r7, lr}
	wordcount_t i;
	for (i = 0; i < num_bytes; ++i) {
 1016808:	2500      	movs	r5, #0
		unsigned b = num_bytes - 1 - i;
 101680a:	1e4f      	subs	r7, r1, #1
 101680c:	b26c      	sxtb	r4, r5
	for (i = 0; i < num_bytes; ++i) {
 101680e:	428c      	cmp	r4, r1
 1016810:	f105 0501 	add.w	r5, r5, #1
 1016814:	db00      	blt.n	1016818 <uECC_vli_nativeToBytes+0x12>
		bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
	}
}
 1016816:	bdf0      	pop	{r4, r5, r6, r7, pc}
		unsigned b = num_bytes - 1 - i;
 1016818:	1b3b      	subs	r3, r7, r4
		bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
 101681a:	f023 0603 	bic.w	r6, r3, #3
 101681e:	5996      	ldr	r6, [r2, r6]
 1016820:	f003 0303 	and.w	r3, r3, #3
 1016824:	00db      	lsls	r3, r3, #3
 1016826:	fa26 f303 	lsr.w	r3, r6, r3
 101682a:	5503      	strb	r3, [r0, r4]
	for (i = 0; i < num_bytes; ++i) {
 101682c:	e7ee      	b.n	101680c <uECC_vli_nativeToBytes+0x6>

0101682e <uECC_vli_bytesToNative>:

/* Converts big-endian bytes to an integer in uECC native format. */
void uECC_vli_bytesToNative(unsigned int *native, const uint8_t *bytes,
			    int num_bytes)
{
 101682e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1016830:	460e      	mov	r6, r1
	wordcount_t i;
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
 1016832:	1cd1      	adds	r1, r2, #3
 1016834:	bf48      	it	mi
 1016836:	1d91      	addmi	r1, r2, #6
{
 1016838:	4614      	mov	r4, r2
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
 101683a:	f341 0187 	sbfx	r1, r1, #2, #8
 101683e:	f7ff fadd 	bl	1015dfc <uECC_vli_clear>
	for (i = 0; i < num_bytes; ++i) {
 1016842:	2500      	movs	r5, #0
		unsigned b = num_bytes - 1 - i;
 1016844:	1e67      	subs	r7, r4, #1
 1016846:	b26a      	sxtb	r2, r5
	for (i = 0; i < num_bytes; ++i) {
 1016848:	42a2      	cmp	r2, r4
 101684a:	f105 0501 	add.w	r5, r5, #1
 101684e:	db00      	blt.n	1016852 <uECC_vli_bytesToNative+0x24>
		native[b / uECC_WORD_SIZE] |=
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
  	}
}
 1016850:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		unsigned b = num_bytes - 1 - i;
 1016852:	1abb      	subs	r3, r7, r2
		native[b / uECC_WORD_SIZE] |=
 1016854:	f023 0103 	bic.w	r1, r3, #3
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
 1016858:	5cb2      	ldrb	r2, [r6, r2]
 101685a:	f003 0303 	and.w	r3, r3, #3
 101685e:	00db      	lsls	r3, r3, #3
 1016860:	fa02 f303 	lsl.w	r3, r2, r3
		native[b / uECC_WORD_SIZE] |=
 1016864:	5842      	ldr	r2, [r0, r1]
 1016866:	431a      	orrs	r2, r3
 1016868:	5042      	str	r2, [r0, r1]
	for (i = 0; i < num_bytes; ++i) {
 101686a:	e7ec      	b.n	1016846 <uECC_vli_bytesToNative+0x18>

0101686c <uECC_valid_point>:
	return 0;
}


int uECC_valid_point(const uECC_word_t *point, uECC_Curve curve)
{
 101686c:	b5f0      	push	{r4, r5, r6, r7, lr}
 101686e:	b091      	sub	sp, #68	; 0x44
 1016870:	4605      	mov	r5, r0
 1016872:	460c      	mov	r4, r1
	uECC_word_t tmp1[NUM_ECC_WORDS];
	uECC_word_t tmp2[NUM_ECC_WORDS];
	wordcount_t num_words = curve->num_words;
 1016874:	f991 6000 	ldrsb.w	r6, [r1]

	/* The point at infinity is invalid. */
	if (EccPoint_isZero(point, curve)) {
 1016878:	f7ff fe17 	bl	10164aa <EccPoint_isZero>
 101687c:	bb28      	cbnz	r0, 10168ca <uECC_valid_point+0x5e>
		return -1;
	}

	/* x and y must be smaller than p. */
	if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||
 101687e:	1d27      	adds	r7, r4, #4
 1016880:	4632      	mov	r2, r6
 1016882:	4629      	mov	r1, r5
 1016884:	4638      	mov	r0, r7
 1016886:	f7ff fb0a 	bl	1015e9e <uECC_vli_cmp_unsafe>
 101688a:	2801      	cmp	r0, #1
 101688c:	d120      	bne.n	10168d0 <uECC_valid_point+0x64>
		uECC_vli_cmp_unsafe(curve->p, point + num_words, num_words) != 1) {
 101688e:	4632      	mov	r2, r6
 1016890:	4638      	mov	r0, r7
 1016892:	eb05 0186 	add.w	r1, r5, r6, lsl #2
 1016896:	f7ff fb02 	bl	1015e9e <uECC_vli_cmp_unsafe>
	if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||
 101689a:	2801      	cmp	r0, #1
 101689c:	d118      	bne.n	10168d0 <uECC_valid_point+0x64>
		return -2;
	}

	uECC_vli_modSquare_fast(tmp1, point + num_words, curve);
 101689e:	4622      	mov	r2, r4
 10168a0:	4668      	mov	r0, sp
 10168a2:	f7ff fc15 	bl	10160d0 <uECC_vli_modSquare_fast>
	curve->x_side(tmp2, point, curve); /* tmp2 = x^3 + ax + b */
 10168a6:	4622      	mov	r2, r4
 10168a8:	4629      	mov	r1, r5
 10168aa:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 10168ae:	a808      	add	r0, sp, #32
 10168b0:	4798      	blx	r3

	/* Make sure that y^2 == x^3 + ax + b */
	if (uECC_vli_equal(tmp1, tmp2, num_words) != 0)
 10168b2:	4632      	mov	r2, r6
 10168b4:	4668      	mov	r0, sp
 10168b6:	a908      	add	r1, sp, #32
 10168b8:	f7ff fb08 	bl	1015ecc <uECC_vli_equal>
 10168bc:	2800      	cmp	r0, #0
		return -3;
 10168be:	bf0c      	ite	eq
 10168c0:	2000      	moveq	r0, #0
 10168c2:	f06f 0002 	mvnne.w	r0, #2

	return 0;
}
 10168c6:	b011      	add	sp, #68	; 0x44
 10168c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -1;
 10168ca:	f04f 30ff 	mov.w	r0, #4294967295
 10168ce:	e7fa      	b.n	10168c6 <uECC_valid_point+0x5a>
		return -2;
 10168d0:	f06f 0001 	mvn.w	r0, #1
 10168d4:	e7f7      	b.n	10168c6 <uECC_valid_point+0x5a>

010168d6 <uECC_valid_public_key>:

int uECC_valid_public_key(const uint8_t *public_key, uECC_Curve curve)
{
 10168d6:	b570      	push	{r4, r5, r6, lr}
 10168d8:	460c      	mov	r4, r1

	uECC_word_t _public[NUM_ECC_WORDS * 2];

	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
	uECC_vli_bytesToNative(
	_public + curve->num_words,
 10168da:	4626      	mov	r6, r4
{
 10168dc:	4605      	mov	r5, r0
 10168de:	b090      	sub	sp, #64	; 0x40
	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
 10168e0:	f991 2001 	ldrsb.w	r2, [r1, #1]
 10168e4:	4601      	mov	r1, r0
 10168e6:	4668      	mov	r0, sp
 10168e8:	f7ff ffa1 	bl	101682e <uECC_vli_bytesToNative>
	public_key + curve->num_bytes,
 10168ec:	f994 2001 	ldrsb.w	r2, [r4, #1]
	_public + curve->num_words,
 10168f0:	f916 0b44 	ldrsb.w	r0, [r6], #68
	uECC_vli_bytesToNative(
 10168f4:	18a9      	adds	r1, r5, r2
 10168f6:	eb0d 0080 	add.w	r0, sp, r0, lsl #2
 10168fa:	f7ff ff98 	bl	101682e <uECC_vli_bytesToNative>
	curve->num_bytes);

	if (uECC_vli_cmp_unsafe(_public, curve->G, NUM_ECC_WORDS * 2) == 0) {
 10168fe:	2210      	movs	r2, #16
 1016900:	4631      	mov	r1, r6
 1016902:	4668      	mov	r0, sp
 1016904:	f7ff facb 	bl	1015e9e <uECC_vli_cmp_unsafe>
 1016908:	b128      	cbz	r0, 1016916 <uECC_valid_public_key+0x40>
		return -4;
	}

	return uECC_valid_point(_public, curve);
 101690a:	4621      	mov	r1, r4
 101690c:	4668      	mov	r0, sp
 101690e:	f7ff ffad 	bl	101686c <uECC_valid_point>
}
 1016912:	b010      	add	sp, #64	; 0x40
 1016914:	bd70      	pop	{r4, r5, r6, pc}
		return -4;
 1016916:	f06f 0003 	mvn.w	r0, #3
 101691a:	e7fa      	b.n	1016912 <uECC_valid_public_key+0x3c>

0101691c <z_irq_spurious>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
 101691c:	2100      	movs	r1, #0
 101691e:	2001      	movs	r0, #1
 1016920:	f7ee bb14 	b.w	1004f4c <z_arm_fatal_error>

01016924 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
 1016924:	4601      	mov	r1, r0
			reason = K_ERR_KERNEL_OOPS;
		}
	}

#endif /* CONFIG_USERSPACE */
	z_arm_fatal_error(reason, esf);
 1016926:	6800      	ldr	r0, [r0, #0]
 1016928:	f7ee bb10 	b.w	1004f4c <z_arm_fatal_error>

0101692c <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
 101692c:	b508      	push	{r3, lr}
	handler();
 101692e:	f7ee fb45 	bl	1004fbc <z_SysNmiOnReset>
	z_arm_int_exit();
}
 1016932:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
 1016936:	f7ee bd95 	b.w	1005464 <z_arm_exc_exit>

0101693a <mpu_configure_region>:
{
 101693a:	b530      	push	{r4, r5, lr}
	p_attr->rbar = attr->rbar &
 101693c:	890a      	ldrh	r2, [r1, #8]
 101693e:	7a8d      	ldrb	r5, [r1, #10]
	region_conf.base = new_region->start;
 1016940:	680b      	ldr	r3, [r1, #0]
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
 1016942:	684c      	ldr	r4, [r1, #4]
 1016944:	f002 021f 	and.w	r2, r2, #31
{
 1016948:	b085      	sub	sp, #20
 101694a:	ea42 1245 	orr.w	r2, r2, r5, lsl #5
	region_conf.base = new_region->start;
 101694e:	9300      	str	r3, [sp, #0]
 1016950:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
 1016954:	f023 031f 	bic.w	r3, r3, #31
 1016958:	1e62      	subs	r2, r4, #1
 101695a:	4413      	add	r3, r2
 101695c:	f023 031f 	bic.w	r3, r3, #31
	if (index > (get_num_regions() - 1)) {
 1016960:	280f      	cmp	r0, #15
 1016962:	4604      	mov	r4, r0
 1016964:	9303      	str	r3, [sp, #12]
 1016966:	d905      	bls.n	1016974 <mpu_configure_region+0x3a>
 1016968:	f7ee fe10 	bl	100558c <region_allocate_and_init.part.0>
 101696c:	4604      	mov	r4, r0
}
 101696e:	4620      	mov	r0, r4
 1016970:	b005      	add	sp, #20
 1016972:	bd30      	pop	{r4, r5, pc}
	region_init(index, region_conf);
 1016974:	4669      	mov	r1, sp
 1016976:	f7ee fdf1 	bl	100555c <region_init>
	return region_allocate_and_init(index,
 101697a:	e7f8      	b.n	101696e <mpu_configure_region+0x34>

0101697c <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
 101697c:	e840 f300 	tt	r3, r0

int arm_cmse_mpu_region_get(u32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
 1016980:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 1016984:	b2d8      	uxtb	r0, r3
		return addr_info.flags.mpu_region;
	}

	return -EINVAL;
}
 1016986:	bf08      	it	eq
 1016988:	f06f 0015 	mvneq.w	r0, #21
 101698c:	4770      	bx	lr

0101698e <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s, size_t n)
{
 101698e:	b570      	push	{r4, r5, r6, lr}
 1016990:	4605      	mov	r5, r0
 1016992:	3901      	subs	r1, #1
 1016994:	462c      	mov	r4, r5
	char *dest = d;

	while ((n > 0) && *s != '\0') {
 1016996:	b142      	cbz	r2, 10169aa <strncpy+0x1c>
 1016998:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 101699c:	1e56      	subs	r6, r2, #1
 101699e:	b92b      	cbnz	r3, 10169ac <strncpy+0x1e>
 10169a0:	442a      	add	r2, r5
		d++;
		n--;
	}

	while (n > 0) {
		*d = '\0';
 10169a2:	f804 3b01 	strb.w	r3, [r4], #1
	while (n > 0) {
 10169a6:	42a2      	cmp	r2, r4
 10169a8:	d1fb      	bne.n	10169a2 <strncpy+0x14>
		d++;
		n--;
	}

	return dest;
}
 10169aa:	bd70      	pop	{r4, r5, r6, pc}
		n--;
 10169ac:	4632      	mov	r2, r6
		*d = *s;
 10169ae:	f805 3b01 	strb.w	r3, [r5], #1
		n--;
 10169b2:	e7ef      	b.n	1016994 <strncpy+0x6>

010169b4 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
 10169b4:	4603      	mov	r3, r0
	size_t n = 0;
 10169b6:	2000      	movs	r0, #0

	while (*s != '\0') {
 10169b8:	5c1a      	ldrb	r2, [r3, r0]
 10169ba:	b902      	cbnz	r2, 10169be <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
 10169bc:	4770      	bx	lr
		n++;
 10169be:	3001      	adds	r0, #1
 10169c0:	e7fa      	b.n	10169b8 <strlen+0x4>

010169c2 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
 10169c2:	1e43      	subs	r3, r0, #1
 10169c4:	3901      	subs	r1, #1
 10169c6:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 10169ca:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 10169ce:	4282      	cmp	r2, r0
 10169d0:	d101      	bne.n	10169d6 <strcmp+0x14>
 10169d2:	2a00      	cmp	r2, #0
 10169d4:	d1f7      	bne.n	10169c6 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
 10169d6:	1a10      	subs	r0, r2, r0
 10169d8:	4770      	bx	lr

010169da <strncmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
 10169da:	b530      	push	{r4, r5, lr}
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
 10169dc:	2400      	movs	r4, #0
 10169de:	42a2      	cmp	r2, r4
 10169e0:	d008      	beq.n	10169f4 <strncmp+0x1a>
 10169e2:	5d03      	ldrb	r3, [r0, r4]
 10169e4:	5d0d      	ldrb	r5, [r1, r4]
 10169e6:	42ab      	cmp	r3, r5
 10169e8:	d102      	bne.n	10169f0 <strncmp+0x16>
 10169ea:	3401      	adds	r4, #1
 10169ec:	2b00      	cmp	r3, #0
 10169ee:	d1f6      	bne.n	10169de <strncmp+0x4>
		s1++;
		s2++;
		n--;
	}

	return (n == 0) ? 0 : (*s1 - *s2);
 10169f0:	1b58      	subs	r0, r3, r5
 10169f2:	e000      	b.n	10169f6 <strncmp+0x1c>
 10169f4:	2000      	movs	r0, #0
}
 10169f6:	bd30      	pop	{r4, r5, pc}

010169f8 <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
 10169f8:	b510      	push	{r4, lr}
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
 10169fa:	b15a      	cbz	r2, 1016a14 <memcmp+0x1c>
 10169fc:	3901      	subs	r1, #1
 10169fe:	1884      	adds	r4, r0, r2
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
 1016a00:	f810 2b01 	ldrb.w	r2, [r0], #1
 1016a04:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 1016a08:	42a0      	cmp	r0, r4
 1016a0a:	d001      	beq.n	1016a10 <memcmp+0x18>
 1016a0c:	429a      	cmp	r2, r3
 1016a0e:	d0f7      	beq.n	1016a00 <memcmp+0x8>
		c1++;
		c2++;
	}

	return *c1 - *c2;
 1016a10:	1ad0      	subs	r0, r2, r3
}
 1016a12:	bd10      	pop	{r4, pc}
		return 0;
 1016a14:	4610      	mov	r0, r2
 1016a16:	e7fc      	b.n	1016a12 <memcmp+0x1a>

01016a18 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
 1016a18:	b5f0      	push	{r4, r5, r6, r7, lr}

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
 1016a1a:	ea81 0400 	eor.w	r4, r1, r0
 1016a1e:	07a5      	lsls	r5, r4, #30
 1016a20:	4603      	mov	r3, r0
 1016a22:	d00b      	beq.n	1016a3c <memcpy+0x24>
 1016a24:	3b01      	subs	r3, #1
 1016a26:	440a      	add	r2, r1
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
 1016a28:	4291      	cmp	r1, r2
 1016a2a:	d11b      	bne.n	1016a64 <memcpy+0x4c>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
 1016a2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (n == 0) {
 1016a2e:	2a00      	cmp	r2, #0
 1016a30:	d0fc      	beq.n	1016a2c <memcpy+0x14>
			*(d_byte++) = *(s_byte++);
 1016a32:	f811 4b01 	ldrb.w	r4, [r1], #1
			n--;
 1016a36:	3a01      	subs	r2, #1
			*(d_byte++) = *(s_byte++);
 1016a38:	f803 4b01 	strb.w	r4, [r3], #1
		while (((uintptr_t)d_byte) & mask) {
 1016a3c:	079c      	lsls	r4, r3, #30
 1016a3e:	d1f6      	bne.n	1016a2e <memcpy+0x16>
 1016a40:	f022 0403 	bic.w	r4, r2, #3
 1016a44:	1f1d      	subs	r5, r3, #4
 1016a46:	0896      	lsrs	r6, r2, #2
 1016a48:	190f      	adds	r7, r1, r4
		while (n >= sizeof(mem_word_t)) {
 1016a4a:	42b9      	cmp	r1, r7
 1016a4c:	d105      	bne.n	1016a5a <memcpy+0x42>
 1016a4e:	f06f 0503 	mvn.w	r5, #3
 1016a52:	4423      	add	r3, r4
 1016a54:	fb05 2206 	mla	r2, r5, r6, r2
 1016a58:	e7e4      	b.n	1016a24 <memcpy+0xc>
			*(d_word++) = *(s_word++);
 1016a5a:	f851 cb04 	ldr.w	ip, [r1], #4
 1016a5e:	f845 cf04 	str.w	ip, [r5, #4]!
			n -= sizeof(mem_word_t);
 1016a62:	e7f2      	b.n	1016a4a <memcpy+0x32>
		*(d_byte++) = *(s_byte++);
 1016a64:	f811 4b01 	ldrb.w	r4, [r1], #1
 1016a68:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
 1016a6c:	e7dc      	b.n	1016a28 <memcpy+0x10>

01016a6e <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
 1016a6e:	4603      	mov	r3, r0
{
 1016a70:	b570      	push	{r4, r5, r6, lr}
	unsigned char c_byte = (unsigned char)c;
 1016a72:	b2c9      	uxtb	r1, r1

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
 1016a74:	079c      	lsls	r4, r3, #30
 1016a76:	d111      	bne.n	1016a9c <memset+0x2e>
	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;

	c_word |= c_word << 8;
 1016a78:	ea41 2401 	orr.w	r4, r1, r1, lsl #8
	c_word |= c_word << 16;
 1016a7c:	f022 0603 	bic.w	r6, r2, #3
 1016a80:	ea44 4504 	orr.w	r5, r4, r4, lsl #16
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
 1016a84:	441e      	add	r6, r3
 1016a86:	0894      	lsrs	r4, r2, #2
 1016a88:	42b3      	cmp	r3, r6
 1016a8a:	d10d      	bne.n	1016aa8 <memset+0x3a>
 1016a8c:	f06f 0503 	mvn.w	r5, #3
 1016a90:	fb05 2204 	mla	r2, r5, r4, r2
 1016a94:	441a      	add	r2, r3

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
 1016a96:	4293      	cmp	r3, r2
 1016a98:	d109      	bne.n	1016aae <memset+0x40>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
 1016a9a:	bd70      	pop	{r4, r5, r6, pc}
		if (n == 0) {
 1016a9c:	2a00      	cmp	r2, #0
 1016a9e:	d0fc      	beq.n	1016a9a <memset+0x2c>
		*(d_byte++) = c_byte;
 1016aa0:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
 1016aa4:	3a01      	subs	r2, #1
 1016aa6:	e7e5      	b.n	1016a74 <memset+0x6>
		*(d_word++) = c_word;
 1016aa8:	f843 5b04 	str.w	r5, [r3], #4
		n -= sizeof(mem_word_t);
 1016aac:	e7ec      	b.n	1016a88 <memset+0x1a>
		*(d_byte++) = c_byte;
 1016aae:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
 1016ab2:	e7f0      	b.n	1016a96 <memset+0x28>

01016ab4 <_stdout_hook_default>:
}
 1016ab4:	f04f 30ff 	mov.w	r0, #4294967295
 1016ab8:	4770      	bx	lr

01016aba <ah>:
	return bt_encrypt_le(key, plaintext, enc_data);
#endif
}

static int ah(const u8_t irk[16], const u8_t r[3], u8_t out[3])
{
 1016aba:	b530      	push	{r4, r5, lr}
 1016abc:	4604      	mov	r4, r0
 1016abe:	b085      	sub	sp, #20
 1016ac0:	4615      	mov	r5, r2

	BT_DBG("irk %s", bt_hex(irk, 16));
	BT_DBG("r %s", bt_hex(r, 3));

	/* r' = padding || r */
	memcpy(res, r, 3);
 1016ac2:	4668      	mov	r0, sp
 1016ac4:	2203      	movs	r2, #3
 1016ac6:	f7ff ffa7 	bl	1016a18 <memcpy>
	(void)memset(res + 3, 0, 13);
 1016aca:	220d      	movs	r2, #13
 1016acc:	2100      	movs	r1, #0
 1016ace:	f10d 0003 	add.w	r0, sp, #3
 1016ad2:	f7ff ffcc 	bl	1016a6e <memset>
	return bt_encrypt_le(key, plaintext, enc_data);
 1016ad6:	4620      	mov	r0, r4
 1016ad8:	466a      	mov	r2, sp
 1016ada:	4669      	mov	r1, sp
 1016adc:	f7f2 fbda 	bl	1009294 <bt_encrypt_le>

	err = internal_encrypt_le(irk, res, res);
	if (err) {
 1016ae0:	4604      	mov	r4, r0
 1016ae2:	b920      	cbnz	r0, 1016aee <ah+0x34>
	 *      ah(h, r) = e(k, r') mod 2^24
	 * The output of the security function e is then truncated to 24 bits
	 * by taking the least significant 24 bits of the output of e as the
	 * result of ah.
	 */
	memcpy(out, res, 3);
 1016ae4:	2203      	movs	r2, #3
 1016ae6:	4669      	mov	r1, sp
 1016ae8:	4628      	mov	r0, r5
 1016aea:	f7ff ff95 	bl	1016a18 <memcpy>

	return 0;
}
 1016aee:	4620      	mov	r0, r4
 1016af0:	b005      	add	sp, #20
 1016af2:	bd30      	pop	{r4, r5, pc}

01016af4 <bt_rpa_irk_matches>:

#if defined(CONFIG_BT_SMP) || defined(CONFIG_BT_CTLR_PRIVACY)
bool bt_rpa_irk_matches(const u8_t irk[16], const bt_addr_t *addr)
{
 1016af4:	b513      	push	{r0, r1, r4, lr}
 1016af6:	460c      	mov	r4, r1
	u8_t hash[3];
	int err;

	BT_DBG("IRK %s bdaddr %s", bt_hex(irk, 16), bt_addr_str(addr));

	err = ah(irk, addr->val + 3, hash);
 1016af8:	aa01      	add	r2, sp, #4
 1016afa:	3103      	adds	r1, #3
 1016afc:	f7ff ffdd 	bl	1016aba <ah>
	if (err) {
 1016b00:	b948      	cbnz	r0, 1016b16 <bt_rpa_irk_matches+0x22>
		return false;
	}

	return !memcmp(addr->val, hash, 3);
 1016b02:	2203      	movs	r2, #3
 1016b04:	4620      	mov	r0, r4
 1016b06:	a901      	add	r1, sp, #4
 1016b08:	f7ff ff76 	bl	10169f8 <memcmp>
 1016b0c:	fab0 f080 	clz	r0, r0
 1016b10:	0940      	lsrs	r0, r0, #5
}
 1016b12:	b002      	add	sp, #8
 1016b14:	bd10      	pop	{r4, pc}
		return false;
 1016b16:	2000      	movs	r0, #0
 1016b18:	e7fb      	b.n	1016b12 <bt_rpa_irk_matches+0x1e>

01016b1a <bt_rpa_create>:
#endif

#if defined(CONFIG_BT_PRIVACY) || defined(CONFIG_BT_CTLR_PRIVACY)
int bt_rpa_create(const u8_t irk[16], bt_addr_t *rpa)
{
 1016b1a:	b570      	push	{r4, r5, r6, lr}
	int err;

	err = internal_rand(rpa->val + 3, 3);
 1016b1c:	1cce      	adds	r6, r1, #3
{
 1016b1e:	4605      	mov	r5, r0
 1016b20:	460c      	mov	r4, r1
	return bt_rand(buf, len);
 1016b22:	4630      	mov	r0, r6
 1016b24:	2103      	movs	r1, #3
 1016b26:	f7f2 fbb3 	bl	1009290 <bt_rand>
	if (err) {
 1016b2a:	b960      	cbnz	r0, 1016b46 <bt_rpa_create+0x2c>
		return err;
	}

	BT_ADDR_SET_RPA(rpa);
 1016b2c:	7963      	ldrb	r3, [r4, #5]

	err = ah(irk, rpa->val + 3, rpa->val);
 1016b2e:	4622      	mov	r2, r4
	BT_ADDR_SET_RPA(rpa);
 1016b30:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 1016b34:	f043 0340 	orr.w	r3, r3, #64	; 0x40
	err = ah(irk, rpa->val + 3, rpa->val);
 1016b38:	4631      	mov	r1, r6
 1016b3a:	4628      	mov	r0, r5
	BT_ADDR_SET_RPA(rpa);
 1016b3c:	7163      	strb	r3, [r4, #5]
	}

	BT_DBG("Created RPA %s", bt_addr_str((bt_addr_t *)rpa->val));

	return 0;
}
 1016b3e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	err = ah(irk, rpa->val + 3, rpa->val);
 1016b42:	f7ff bfba 	b.w	1016aba <ah>
}
 1016b46:	bd70      	pop	{r4, r5, r6, pc}

01016b48 <bt_buf_get_evt>:
	return bt_buf_get_rx(BT_BUF_EVT, timeout);
 1016b48:	2001      	movs	r0, #1
 1016b4a:	f7ee bea3 	b.w	1005894 <bt_buf_get_rx>

01016b4e <bt_recv_prio>:
	if (bt_buf_get_type(buf) == BT_BUF_EVT) {
 1016b4e:	7d03      	ldrb	r3, [r0, #20]
 1016b50:	2b01      	cmp	r3, #1
 1016b52:	d103      	bne.n	1016b5c <bt_recv_prio+0xe>
		u8_t evt_flags = bt_hci_evt_get_flags(hdr->evt);
 1016b54:	6883      	ldr	r3, [r0, #8]
 *
 * @return HCI event flags for the specified event.
 */
static inline u8_t bt_hci_evt_get_flags(u8_t evt)
{
	switch (evt) {
 1016b56:	781b      	ldrb	r3, [r3, #0]
 1016b58:	2b05      	cmp	r3, #5
 1016b5a:	d001      	beq.n	1016b60 <bt_recv_prio+0x12>
	return bt_recv(buf);
 1016b5c:	f7ee befe 	b.w	100595c <bt_recv>
}
 1016b60:	2000      	movs	r0, #0
 1016b62:	4770      	bx	lr

01016b64 <bt_send>:
		return bt_hci_ecc_send(buf);
 1016b64:	f7ef b80c 	b.w	1005b80 <bt_hci_ecc_send>

01016b68 <send_cmd_status>:
{
 1016b68:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
 1016b6c:	f04f 32ff 	mov.w	r2, #4294967295
{
 1016b70:	4606      	mov	r6, r0
 1016b72:	460d      	mov	r5, r1
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
 1016b74:	f04f 33ff 	mov.w	r3, #4294967295
 1016b78:	2100      	movs	r1, #0
 1016b7a:	200f      	movs	r0, #15
 1016b7c:	f7ff ffe4 	bl	1016b48 <bt_buf_get_evt>
	*(u8_t *)net_buf_user_data(buf) = type;
 1016b80:	2701      	movs	r7, #1
	hdr = net_buf_add(buf, sizeof(*hdr));
 1016b82:	f100 0808 	add.w	r8, r0, #8
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
 1016b86:	4604      	mov	r4, r0
 1016b88:	7507      	strb	r7, [r0, #20]
	hdr = net_buf_add(buf, sizeof(*hdr));
 1016b8a:	2102      	movs	r1, #2
 1016b8c:	4640      	mov	r0, r8
 1016b8e:	f000 f851 	bl	1016c34 <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_CMD_STATUS;
 1016b92:	230f      	movs	r3, #15
	hdr->len = sizeof(*evt);
 1016b94:	2104      	movs	r1, #4
	hdr->evt = BT_HCI_EVT_CMD_STATUS;
 1016b96:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*evt);
 1016b98:	7041      	strb	r1, [r0, #1]
	evt = net_buf_add(buf, sizeof(*evt));
 1016b9a:	4640      	mov	r0, r8
 1016b9c:	f000 f84a 	bl	1016c34 <net_buf_simple_add>
	evt->ncmd = 1U;
 1016ba0:	7047      	strb	r7, [r0, #1]
	evt->status = status;
 1016ba2:	7005      	strb	r5, [r0, #0]
	evt->opcode = sys_cpu_to_le16(opcode);
 1016ba4:	8046      	strh	r6, [r0, #2]
		bt_recv_prio(buf);
 1016ba6:	4620      	mov	r0, r4
}
 1016ba8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		bt_recv_prio(buf);
 1016bac:	f7ff bfcf 	b.w	1016b4e <bt_recv_prio>

01016bb0 <sys_memcpy_swap.constprop.0>:
	for (; length > 0; length--) {
 1016bb0:	f101 0320 	add.w	r3, r1, #32
 1016bb4:	3801      	subs	r0, #1
		*pdst++ = *psrc--;
 1016bb6:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
	for (; length > 0; length--) {
 1016bba:	428b      	cmp	r3, r1
		*pdst++ = *psrc--;
 1016bbc:	f800 2f01 	strb.w	r2, [r0, #1]!
	for (; length > 0; length--) {
 1016bc0:	d1f9      	bne.n	1016bb6 <sys_memcpy_swap.constprop.0+0x6>
	}
}
 1016bc2:	4770      	bx	lr

01016bc4 <default_CSPRNG>:
{
 1016bc4:	b508      	push	{r3, lr}
	return !bt_rand(dst, len);
 1016bc6:	f7f2 fb63 	bl	1009290 <bt_rand>
}
 1016bca:	fab0 f080 	clz	r0, r0
 1016bce:	0940      	lsrs	r0, r0, #5
 1016bd0:	bd08      	pop	{r3, pc}

01016bd2 <fixed_data_unref>:
}
 1016bd2:	4770      	bx	lr

01016bd4 <net_buf_alloc_fixed>:
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
 1016bd4:	6a01      	ldr	r1, [r0, #32]
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
 1016bd6:	6849      	ldr	r1, [r1, #4]
 1016bd8:	6809      	ldr	r1, [r1, #0]
 1016bda:	f7fb bedd 	b.w	1012998 <net_buf_alloc_len>

01016bde <net_buf_get>:
{
 1016bde:	b570      	push	{r4, r5, r6, lr}
 1016be0:	4606      	mov	r6, r0
	return z_impl_k_queue_get(queue, timeout);
 1016be2:	f7fd faab 	bl	101413c <z_impl_k_queue_get>
	if (!buf) {
 1016be6:	4605      	mov	r5, r0
 1016be8:	b128      	cbz	r0, 1016bf6 <net_buf_get+0x18>
 1016bea:	4604      	mov	r4, r0
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
 1016bec:	7963      	ldrb	r3, [r4, #5]
 1016bee:	f013 0301 	ands.w	r3, r3, #1
 1016bf2:	d102      	bne.n	1016bfa <net_buf_get+0x1c>
	frag->frags = NULL;
 1016bf4:	6023      	str	r3, [r4, #0]
}
 1016bf6:	4628      	mov	r0, r5
 1016bf8:	bd70      	pop	{r4, r5, r6, pc}
 1016bfa:	2300      	movs	r3, #0
 1016bfc:	2200      	movs	r2, #0
 1016bfe:	4630      	mov	r0, r6
 1016c00:	f7fd fa9c 	bl	101413c <z_impl_k_queue_get>
		frag->flags &= ~NET_BUF_FRAGS;
 1016c04:	7963      	ldrb	r3, [r4, #5]
		frag->frags = k_fifo_get(fifo, K_NO_WAIT);
 1016c06:	6020      	str	r0, [r4, #0]
		frag->flags &= ~NET_BUF_FRAGS;
 1016c08:	f023 0301 	bic.w	r3, r3, #1
 1016c0c:	7163      	strb	r3, [r4, #5]
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
 1016c0e:	4604      	mov	r4, r0
 1016c10:	e7ec      	b.n	1016bec <net_buf_get+0xe>

01016c12 <net_buf_simple_reserve>:
	buf->data = buf->__buf + reserve;
 1016c12:	6883      	ldr	r3, [r0, #8]
 1016c14:	440b      	add	r3, r1
 1016c16:	6003      	str	r3, [r0, #0]
}
 1016c18:	4770      	bx	lr

01016c1a <net_buf_put>:
	for (tail = buf; tail->frags; tail = tail->frags) {
 1016c1a:	460a      	mov	r2, r1
{
 1016c1c:	b410      	push	{r4}
	for (tail = buf; tail->frags; tail = tail->frags) {
 1016c1e:	6814      	ldr	r4, [r2, #0]
 1016c20:	b914      	cbnz	r4, 1016c28 <net_buf_put+0xe>
}
 1016c22:	bc10      	pop	{r4}
	k_fifo_put_list(fifo, buf, tail);
 1016c24:	f000 be99 	b.w	101795a <k_queue_append_list>
		tail->flags |= NET_BUF_FRAGS;
 1016c28:	7953      	ldrb	r3, [r2, #5]
 1016c2a:	f043 0301 	orr.w	r3, r3, #1
 1016c2e:	7153      	strb	r3, [r2, #5]
 1016c30:	4622      	mov	r2, r4
 1016c32:	e7f4      	b.n	1016c1e <net_buf_put+0x4>

01016c34 <net_buf_simple_add>:
	return buf->data + buf->len;
 1016c34:	8883      	ldrh	r3, [r0, #4]
 1016c36:	6802      	ldr	r2, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
 1016c38:	4419      	add	r1, r3
 1016c3a:	8081      	strh	r1, [r0, #4]
	return tail;
}
 1016c3c:	18d0      	adds	r0, r2, r3
 1016c3e:	4770      	bx	lr

01016c40 <net_buf_simple_add_mem>:

void *net_buf_simple_add_mem(struct net_buf_simple *buf, const void *mem,
			     size_t len)
{
 1016c40:	b430      	push	{r4, r5}
 1016c42:	8884      	ldrh	r4, [r0, #4]
 1016c44:	6805      	ldr	r5, [r0, #0]
	buf->len += len;
 1016c46:	18a3      	adds	r3, r4, r2
 1016c48:	8083      	strh	r3, [r0, #4]
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	return memcpy(net_buf_simple_add(buf, len), mem, len);
 1016c4a:	1928      	adds	r0, r5, r4
}
 1016c4c:	bc30      	pop	{r4, r5}
	return memcpy(net_buf_simple_add(buf, len), mem, len);
 1016c4e:	f7ff bee3 	b.w	1016a18 <memcpy>

01016c52 <net_buf_simple_push_u8>:
{
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_headroom(buf) >= len);

	buf->data -= len;
 1016c52:	6802      	ldr	r2, [r0, #0]
 1016c54:	1e53      	subs	r3, r2, #1
 1016c56:	6003      	str	r3, [r0, #0]
	buf->len += len;
 1016c58:	8883      	ldrh	r3, [r0, #4]
 1016c5a:	3301      	adds	r3, #1
 1016c5c:	8083      	strh	r3, [r0, #4]

void net_buf_simple_push_u8(struct net_buf_simple *buf, u8_t val)
{
	u8_t *data = net_buf_simple_push(buf, 1);

	*data = val;
 1016c5e:	f802 1c01 	strb.w	r1, [r2, #-1]
}
 1016c62:	4770      	bx	lr

01016c64 <net_buf_simple_pull>:

	sys_put_be64(val, net_buf_simple_push(buf, sizeof(val)));
}

void *net_buf_simple_pull(struct net_buf_simple *buf, size_t len)
{
 1016c64:	4603      	mov	r3, r0
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
 1016c66:	8882      	ldrh	r2, [r0, #4]
 1016c68:	1a52      	subs	r2, r2, r1
 1016c6a:	8082      	strh	r2, [r0, #4]
	return buf->data += len;
 1016c6c:	6800      	ldr	r0, [r0, #0]
 1016c6e:	4408      	add	r0, r1
 1016c70:	6018      	str	r0, [r3, #0]
}
 1016c72:	4770      	bx	lr

01016c74 <net_buf_simple_pull_mem>:

void *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)
{
 1016c74:	4603      	mov	r3, r0
	void *data = buf->data;
 1016c76:	6800      	ldr	r0, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
 1016c78:	889a      	ldrh	r2, [r3, #4]
 1016c7a:	1a52      	subs	r2, r2, r1
	buf->data += len;
 1016c7c:	4401      	add	r1, r0
	buf->len -= len;
 1016c7e:	809a      	strh	r2, [r3, #4]
	buf->data += len;
 1016c80:	6019      	str	r1, [r3, #0]

	return data;
}
 1016c82:	4770      	bx	lr

01016c84 <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1016c84:	6843      	ldr	r3, [r0, #4]
}
 1016c86:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1016c88:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
 1016c8a:	691b      	ldr	r3, [r3, #16]
	*value = nrf_gpio_port_in_read(reg);
 1016c8c:	600b      	str	r3, [r1, #0]
}
 1016c8e:	4770      	bx	lr

01016c90 <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1016c90:	6843      	ldr	r3, [r0, #4]
 1016c92:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
 1016c94:	6858      	ldr	r0, [r3, #4]
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
 1016c96:	4042      	eors	r2, r0
 1016c98:	400a      	ands	r2, r1
 1016c9a:	4042      	eors	r2, r0
    p_reg->OUT = value;
 1016c9c:	605a      	str	r2, [r3, #4]
}
 1016c9e:	2000      	movs	r0, #0
 1016ca0:	4770      	bx	lr

01016ca2 <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1016ca2:	6843      	ldr	r3, [r0, #4]
}
 1016ca4:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1016ca6:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
 1016ca8:	6099      	str	r1, [r3, #8]
}
 1016caa:	4770      	bx	lr

01016cac <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1016cac:	6843      	ldr	r3, [r0, #4]
}
 1016cae:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1016cb0:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
 1016cb2:	60d9      	str	r1, [r3, #12]
}
 1016cb4:	4770      	bx	lr

01016cb6 <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1016cb6:	6843      	ldr	r3, [r0, #4]
}
 1016cb8:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1016cba:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
 1016cbc:	6853      	ldr	r3, [r2, #4]
	nrf_gpio_port_out_write(reg, value ^ mask);
 1016cbe:	404b      	eors	r3, r1
    p_reg->OUT = value;
 1016cc0:	6053      	str	r3, [r2, #4]
}
 1016cc2:	4770      	bx	lr

01016cc4 <gpio_nrfx_manage_callback>:
	return gpio_manage_callback(&get_port_data(port)->callbacks,
 1016cc4:	68c3      	ldr	r3, [r0, #12]
{
 1016cc6:	b530      	push	{r4, r5, lr}
Z_GENLIST_IS_EMPTY(slist)
 1016cc8:	6858      	ldr	r0, [r3, #4]
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
 1016cca:	b158      	cbz	r0, 1016ce4 <gpio_nrfx_manage_callback+0x20>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 1016ccc:	2400      	movs	r4, #0
 1016cce:	4281      	cmp	r1, r0
 1016cd0:	d113      	bne.n	1016cfa <gpio_nrfx_manage_callback+0x36>
Z_GENLIST_REMOVE(slist, snode)
 1016cd2:	6808      	ldr	r0, [r1, #0]
 1016cd4:	b95c      	cbnz	r4, 1016cee <gpio_nrfx_manage_callback+0x2a>
 1016cd6:	689c      	ldr	r4, [r3, #8]
	list->head = node;
 1016cd8:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
 1016cda:	42a1      	cmp	r1, r4
 1016cdc:	d100      	bne.n	1016ce0 <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
 1016cde:	6098      	str	r0, [r3, #8]
	parent->next = child;
 1016ce0:	2000      	movs	r0, #0
 1016ce2:	6008      	str	r0, [r1, #0]
				return -EINVAL;
			}
		}
	}

	if (set) {
 1016ce4:	b972      	cbnz	r2, 1016d04 <gpio_nrfx_manage_callback+0x40>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
 1016ce6:	2000      	movs	r0, #0
}
 1016ce8:	bd30      	pop	{r4, r5, pc}
 1016cea:	4628      	mov	r0, r5
 1016cec:	e7ef      	b.n	1016cce <gpio_nrfx_manage_callback+0xa>
 1016cee:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
 1016cf0:	6898      	ldr	r0, [r3, #8]
 1016cf2:	4281      	cmp	r1, r0
	list->tail = node;
 1016cf4:	bf08      	it	eq
 1016cf6:	609c      	streq	r4, [r3, #8]
}
 1016cf8:	e7f2      	b.n	1016ce0 <gpio_nrfx_manage_callback+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 1016cfa:	6805      	ldr	r5, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 1016cfc:	4604      	mov	r4, r0
 1016cfe:	2d00      	cmp	r5, #0
 1016d00:	d1f3      	bne.n	1016cea <gpio_nrfx_manage_callback+0x26>
			if (!set) {
 1016d02:	b13a      	cbz	r2, 1016d14 <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_PREPEND(slist, snode)
 1016d04:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
 1016d06:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
 1016d08:	6898      	ldr	r0, [r3, #8]
	list->head = node;
 1016d0a:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
 1016d0c:	2800      	cmp	r0, #0
 1016d0e:	d1ea      	bne.n	1016ce6 <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
 1016d10:	6099      	str	r1, [r3, #8]
}
 1016d12:	e7e9      	b.n	1016ce8 <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
 1016d14:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
 1016d18:	e7e6      	b.n	1016ce8 <gpio_nrfx_manage_callback+0x24>

01016d1a <fire_callbacks>:
{
 1016d1a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct gpio_nrfx_data *data = get_port_data(port);
 1016d1c:	68c7      	ldr	r7, [r0, #12]
{
 1016d1e:	460e      	mov	r6, r1
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 1016d20:	6879      	ldr	r1, [r7, #4]
{
 1016d22:	4605      	mov	r5, r0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 1016d24:	b161      	cbz	r1, 1016d40 <fire_callbacks+0x26>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 1016d26:	680c      	ldr	r4, [r1, #0]
		if ((cb->pin_mask & pins) & data->int_en) {
 1016d28:	688a      	ldr	r2, [r1, #8]
 1016d2a:	693b      	ldr	r3, [r7, #16]
 1016d2c:	4032      	ands	r2, r6
 1016d2e:	421a      	tst	r2, r3
 1016d30:	d002      	beq.n	1016d38 <fire_callbacks+0x1e>
			cb->handler(port, cb, cb->pin_mask & pins);
 1016d32:	4628      	mov	r0, r5
 1016d34:	684b      	ldr	r3, [r1, #4]
 1016d36:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 1016d38:	b114      	cbz	r4, 1016d40 <fire_callbacks+0x26>
 1016d3a:	4621      	mov	r1, r4
 1016d3c:	6824      	ldr	r4, [r4, #0]
 1016d3e:	e7f3      	b.n	1016d28 <fire_callbacks+0xe>
}
 1016d40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

01016d42 <gpio_nrfx_pin_disable_callback>:
	WRITE_BIT(data->int_en, pin, enable);
 1016d42:	2301      	movs	r3, #1
{
 1016d44:	b410      	push	{r4}
	struct gpio_nrfx_data *data = get_port_data(port);
 1016d46:	68c4      	ldr	r4, [r0, #12]
	WRITE_BIT(data->int_en, pin, enable);
 1016d48:	fa03 f201 	lsl.w	r2, r3, r1
 1016d4c:	6923      	ldr	r3, [r4, #16]
 1016d4e:	ea23 0302 	bic.w	r3, r3, r2
 1016d52:	6123      	str	r3, [r4, #16]
}
 1016d54:	bc10      	pop	{r4}
	return gpiote_pin_int_cfg(port, pin);
 1016d56:	f7fb bf69 	b.w	1012c2c <gpiote_pin_int_cfg>

01016d5a <check_level_trigger_pins>:
{
 1016d5a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t bit = 1U << pin;
 1016d5c:	2501      	movs	r5, #1
	u32_t pin = 0U;
 1016d5e:	2600      	movs	r6, #0
	struct gpio_nrfx_data *data = get_port_data(port);
 1016d60:	68c3      	ldr	r3, [r0, #12]
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
 1016d62:	6847      	ldr	r7, [r0, #4]
	u32_t out = data->int_en & data->pin_int_en;
 1016d64:	e9d3 1203 	ldrd	r1, r2, [r3, #12]
 1016d68:	400a      	ands	r2, r1
	out &= ~data->trig_edge & ~data->double_edge;
 1016d6a:	e9d3 1006 	ldrd	r1, r0, [r3, #24]
 1016d6e:	4301      	orrs	r1, r0
 1016d70:	ea22 0201 	bic.w	r2, r2, r1
	u32_t port_in = nrf_gpio_port_in_read(cfg->port);
 1016d74:	6879      	ldr	r1, [r7, #4]
	u32_t pin_states = ~(port_in ^ data->int_active_level);
 1016d76:	695b      	ldr	r3, [r3, #20]
    return p_reg->IN;
 1016d78:	690c      	ldr	r4, [r1, #16]
 1016d7a:	405c      	eors	r4, r3
	u32_t out = pin_states & level_pins;
 1016d7c:	ea22 0404 	bic.w	r4, r2, r4
	while (level_pins) {
 1016d80:	b90a      	cbnz	r2, 1016d86 <check_level_trigger_pins+0x2c>
}
 1016d82:	4620      	mov	r0, r4
 1016d84:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (level_pins & bit) {
 1016d86:	422a      	tst	r2, r5
 1016d88:	d009      	beq.n	1016d9e <check_level_trigger_pins+0x44>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
 1016d8a:	7a3b      	ldrb	r3, [r7, #8]
 1016d8c:	f006 001f 	and.w	r0, r6, #31
			nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
 1016d90:	2100      	movs	r1, #0
 1016d92:	ea40 1043 	orr.w	r0, r0, r3, lsl #5
 1016d96:	f7fb ff33 	bl	1012c00 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
 1016d9a:	ea22 0205 	bic.w	r2, r2, r5
		++pin;
 1016d9e:	3601      	adds	r6, #1
		bit <<= 1;
 1016da0:	006d      	lsls	r5, r5, #1
 1016da2:	e7ed      	b.n	1016d80 <check_level_trigger_pins+0x26>

01016da4 <cfg_level_pins>:
{
 1016da4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t bit = 1U << pin;
 1016da6:	2601      	movs	r6, #1
	u32_t pin = 0U;
 1016da8:	2500      	movs	r5, #0
	const struct gpio_nrfx_data *data = get_port_data(port);
 1016daa:	68c4      	ldr	r4, [r0, #12]
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
 1016dac:	6847      	ldr	r7, [r0, #4]
	u32_t out = data->int_en & data->pin_int_en;
 1016dae:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
 1016db2:	401a      	ands	r2, r3
	out &= ~data->trig_edge & ~data->double_edge;
 1016db4:	e9d4 3106 	ldrd	r3, r1, [r4, #24]
 1016db8:	430b      	orrs	r3, r1
 1016dba:	ea22 0203 	bic.w	r2, r2, r3
	while (level_pins) {
 1016dbe:	b902      	cbnz	r2, 1016dc2 <cfg_level_pins+0x1e>
}
 1016dc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (level_pins & bit) {
 1016dc2:	4216      	tst	r6, r2
 1016dc4:	d00f      	beq.n	1016de6 <cfg_level_pins+0x42>
	if ((BIT(pin) & data->int_active_level) != 0U) {
 1016dc6:	6961      	ldr	r1, [r4, #20]
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
 1016dc8:	7a3b      	ldrb	r3, [r7, #8]
	if ((BIT(pin) & data->int_active_level) != 0U) {
 1016dca:	40e9      	lsrs	r1, r5
 1016dcc:	f001 0101 	and.w	r1, r1, #1
 1016dd0:	f1c1 0103 	rsb	r1, r1, #3
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
 1016dd4:	f005 001f 	and.w	r0, r5, #31
			nrf_gpio_cfg_sense_set(abs_pin, sense);
 1016dd8:	b2c9      	uxtb	r1, r1
 1016dda:	ea40 1043 	orr.w	r0, r0, r3, lsl #5
 1016dde:	f7fb ff0f 	bl	1012c00 <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
 1016de2:	ea22 0206 	bic.w	r2, r2, r6
		++pin;
 1016de6:	3501      	adds	r5, #1
		bit <<= 1;
 1016de8:	0076      	lsls	r6, r6, #1
 1016dea:	e7e8      	b.n	1016dbe <cfg_level_pins+0x1a>

01016dec <gpio_nrfx_pin_enable_callback>:
	WRITE_BIT(data->int_en, pin, enable);
 1016dec:	2301      	movs	r3, #1
{
 1016dee:	b410      	push	{r4}
	struct gpio_nrfx_data *data = get_port_data(port);
 1016df0:	68c4      	ldr	r4, [r0, #12]
	WRITE_BIT(data->int_en, pin, enable);
 1016df2:	fa03 f201 	lsl.w	r2, r3, r1
 1016df6:	6923      	ldr	r3, [r4, #16]
 1016df8:	4313      	orrs	r3, r2
 1016dfa:	6123      	str	r3, [r4, #16]
}
 1016dfc:	bc10      	pop	{r4}
	return gpiote_pin_int_cfg(port, pin);
 1016dfe:	f7fb bf15 	b.w	1012c2c <gpiote_pin_int_cfg>

01016e02 <vipm_nrf_max_data_size_get>:
static inline int z_impl_ipm_max_data_size_get(struct device *ipmdev)
{
	const struct ipm_driver_api *api =
		(const struct ipm_driver_api *)ipmdev->driver_api;

	return api->max_data_size_get(ipmdev);
 1016e02:	6883      	ldr	r3, [r0, #8]
 1016e04:	689b      	ldr	r3, [r3, #8]
 1016e06:	4718      	bx	r3

01016e08 <vipm_nrf_max_id_val_get>:
}
 1016e08:	2000      	movs	r0, #0
 1016e0a:	4770      	bx	lr

01016e0c <vipm_nrf_0_set_enabled>:
UTIL_LISTIFY(NRFX_IPC_ID_MAX_VALUE, VIPM_DEVICE, _);
 1016e0c:	4608      	mov	r0, r1
 1016e0e:	b508      	push	{r3, lr}
 1016e10:	b139      	cbz	r1, 1016e22 <vipm_nrf_0_set_enabled+0x16>
 1016e12:	2012      	movs	r0, #18
 1016e14:	f7ed fffa 	bl	1004e0c <arch_irq_enable>
 1016e18:	2000      	movs	r0, #0
 1016e1a:	f7fc fbc7 	bl	10135ac <nrfx_ipc_receive_event_enable>
 1016e1e:	2000      	movs	r0, #0
 1016e20:	bd08      	pop	{r3, pc}
 1016e22:	f7fc fbcb 	bl	10135bc <nrfx_ipc_receive_event_disable>
 1016e26:	e7fa      	b.n	1016e1e <vipm_nrf_0_set_enabled+0x12>

01016e28 <uarte_nrfx_config_get>:
{
 1016e28:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
 1016e2a:	68c2      	ldr	r2, [r0, #12]
 1016e2c:	e892 0003 	ldmia.w	r2, {r0, r1}
 1016e30:	e883 0003 	stmia.w	r3, {r0, r1}
}
 1016e34:	2000      	movs	r0, #0
 1016e36:	4770      	bx	lr

01016e38 <uarte_nrfx_err_check>:
	return config->uarte_regs;
 1016e38:	6843      	ldr	r3, [r0, #4]
 1016e3a:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
 1016e3c:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
 1016e40:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
 1016e44:	4770      	bx	lr

01016e46 <uarte_nrfx_poll_in>:
	return config->uarte_regs;
 1016e46:	6843      	ldr	r3, [r0, #4]
	const struct uarte_nrfx_data *data = get_dev_data(dev);
 1016e48:	68c2      	ldr	r2, [r0, #12]
	return config->uarte_regs;
 1016e4a:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 1016e4c:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
 1016e50:	b138      	cbz	r0, 1016e62 <uarte_nrfx_poll_in+0x1c>
	*c = data->rx_data;
 1016e52:	7b12      	ldrb	r2, [r2, #12]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 1016e54:	2000      	movs	r0, #0
 1016e56:	700a      	strb	r2, [r1, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1016e58:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 1016e5a:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1016e5e:	601a      	str	r2, [r3, #0]
	return 0;
 1016e60:	4770      	bx	lr
		return -1;
 1016e62:	f04f 30ff 	mov.w	r0, #4294967295
}
 1016e66:	4770      	bx	lr

01016e68 <uarte_nrfx_poll_out>:
{
 1016e68:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	return config->uarte_regs;
 1016e6c:	6843      	ldr	r3, [r0, #4]
{
 1016e6e:	f88d 1007 	strb.w	r1, [sp, #7]
	return config->uarte_regs;
 1016e72:	681c      	ldr	r4, [r3, #0]
	struct uarte_nrfx_data *data = get_dev_data(dev);
 1016e74:	68c6      	ldr	r6, [r0, #12]
	if (!k_is_in_isr()) {
 1016e76:	f000 fee2 	bl	1017c3e <k_is_in_isr>
 1016e7a:	b9c0      	cbnz	r0, 1016eae <uarte_nrfx_poll_out+0x46>
		lock = &data->poll_out_lock;
 1016e7c:	2564      	movs	r5, #100	; 0x64
	return __atomic_compare_exchange_n(target, &old_value, new_value,
 1016e7e:	f04f 0801 	mov.w	r8, #1
 1016e82:	f106 0708 	add.w	r7, r6, #8
 1016e86:	e8d7 3fef 	ldaex	r3, [r7]
 1016e8a:	2b00      	cmp	r3, #0
 1016e8c:	d103      	bne.n	1016e96 <uarte_nrfx_poll_out+0x2e>
 1016e8e:	e8c7 8fe2 	stlex	r2, r8, [r7]
 1016e92:	2a00      	cmp	r2, #0
 1016e94:	d1f7      	bne.n	1016e86 <uarte_nrfx_poll_out+0x1e>
		while (atomic_cas((atomic_t *) lock,
 1016e96:	d00c      	beq.n	1016eb2 <uarte_nrfx_poll_out+0x4a>
	return z_impl_k_sleep(timeout);
 1016e98:	2021      	movs	r0, #33	; 0x21
 1016e9a:	2100      	movs	r1, #0
 1016e9c:	3d01      	subs	r5, #1
 1016e9e:	f7fd fc5d 	bl	101475c <z_impl_k_sleep>
			if (--safety_cnt == 0) {
 1016ea2:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
 1016ea6:	d1ee      	bne.n	1016e86 <uarte_nrfx_poll_out+0x1e>
}
 1016ea8:	b002      	add	sp, #8
 1016eaa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		*lock = 1;
 1016eae:	2301      	movs	r3, #1
 1016eb0:	60b3      	str	r3, [r6, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 1016eb2:	2300      	movs	r3, #0
 1016eb4:	f8c4 3120 	str.w	r3, [r4, #288]	; 0x120
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
 1016eb8:	f10d 0307 	add.w	r3, sp, #7
 1016ebc:	f8c4 3544 	str.w	r3, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
 1016ec0:	2301      	movs	r3, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1016ec2:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    p_reg->TXD.MAXCNT = length;
 1016ec6:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1016eca:	60a3      	str	r3, [r4, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 1016ecc:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
	NRFX_WAIT_FOR(nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX),
 1016ed0:	b923      	cbnz	r3, 1016edc <uarte_nrfx_poll_out+0x74>
 1016ed2:	2001      	movs	r0, #1
 1016ed4:	f000 f808 	bl	1016ee8 <nrfx_busy_wait>
 1016ed8:	3d01      	subs	r5, #1
 1016eda:	d1f7      	bne.n	1016ecc <uarte_nrfx_poll_out+0x64>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1016edc:	2301      	movs	r3, #1
 1016ede:	60e3      	str	r3, [r4, #12]
	*lock = 0;
 1016ee0:	2300      	movs	r3, #0
 1016ee2:	60b3      	str	r3, [r6, #8]
 1016ee4:	e7e0      	b.n	1016ea8 <uarte_nrfx_poll_out+0x40>

01016ee6 <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
 1016ee6:	4700      	bx	r0

01016ee8 <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
 1016ee8:	f000 beaf 	b.w	1017c4a <z_impl_k_busy_wait>

01016eec <metal_device_open>:
{
 1016eec:	b573      	push	{r0, r1, r4, r5, r6, lr}
 1016eee:	460c      	mov	r4, r1
 1016ef0:	4615      	mov	r5, r2
	if (!bus_name || !strlen(bus_name) ||
 1016ef2:	4606      	mov	r6, r0
 1016ef4:	b918      	cbnz	r0, 1016efe <metal_device_open+0x12>
		return -EINVAL;
 1016ef6:	f06f 0015 	mvn.w	r0, #21
}
 1016efa:	b002      	add	sp, #8
 1016efc:	bd70      	pop	{r4, r5, r6, pc}
	if (!bus_name || !strlen(bus_name) ||
 1016efe:	f7ff fd59 	bl	10169b4 <strlen>
 1016f02:	2800      	cmp	r0, #0
 1016f04:	d0f7      	beq.n	1016ef6 <metal_device_open+0xa>
 1016f06:	2c00      	cmp	r4, #0
 1016f08:	d0f5      	beq.n	1016ef6 <metal_device_open+0xa>
	    !dev_name || !strlen(dev_name) ||
 1016f0a:	4620      	mov	r0, r4
 1016f0c:	f7ff fd52 	bl	10169b4 <strlen>
 1016f10:	2800      	cmp	r0, #0
 1016f12:	d0f0      	beq.n	1016ef6 <metal_device_open+0xa>
 1016f14:	2d00      	cmp	r5, #0
 1016f16:	d0ee      	beq.n	1016ef6 <metal_device_open+0xa>
	error = metal_bus_find(bus_name, &bus);
 1016f18:	4630      	mov	r0, r6
 1016f1a:	a901      	add	r1, sp, #4
 1016f1c:	f7fc fb96 	bl	101364c <metal_bus_find>
	if (error)
 1016f20:	2800      	cmp	r0, #0
 1016f22:	d1ea      	bne.n	1016efa <metal_device_open+0xe>
	if (!bus->ops.dev_open)
 1016f24:	9801      	ldr	r0, [sp, #4]
 1016f26:	6883      	ldr	r3, [r0, #8]
 1016f28:	b11b      	cbz	r3, 1016f32 <metal_device_open+0x46>
	error = (*bus->ops.dev_open)(bus, dev_name, device);
 1016f2a:	462a      	mov	r2, r5
 1016f2c:	4621      	mov	r1, r4
 1016f2e:	4798      	blx	r3
	if (error)
 1016f30:	e7e3      	b.n	1016efa <metal_device_open+0xe>
		return -ENODEV;
 1016f32:	f06f 0012 	mvn.w	r0, #18
 1016f36:	e7e0      	b.n	1016efa <metal_device_open+0xe>

01016f38 <metal_io_block_read>:
	metal_sys_io_mem_map(io);
}

int metal_io_block_read(struct metal_io_region *io, unsigned long offset,
	       void *restrict dst, int len)
{
 1016f38:	b573      	push	{r0, r1, r4, r5, r6, lr}
	return (io->virt != METAL_BAD_VA && offset < io->size
 1016f3a:	6804      	ldr	r4, [r0, #0]
 1016f3c:	6885      	ldr	r5, [r0, #8]
		: NULL);
 1016f3e:	1c66      	adds	r6, r4, #1
 1016f40:	d00f      	beq.n	1016f62 <metal_io_block_read+0x2a>
	return (io->virt != METAL_BAD_VA && offset < io->size
 1016f42:	42a9      	cmp	r1, r5
 1016f44:	d232      	bcs.n	1016fac <metal_io_block_read+0x74>
		: NULL);
 1016f46:	440c      	add	r4, r1
	unsigned char *dest = dst;
	int retlen;

	if (offset >= io->size)
		return -ERANGE;
	if ((offset + len) > io->size)
 1016f48:	185e      	adds	r6, r3, r1
 1016f4a:	42ae      	cmp	r6, r5
		len = io->size - offset;
 1016f4c:	bf88      	it	hi
 1016f4e:	1a6b      	subhi	r3, r5, r1
	retlen = len;
	if (io->ops.block_read) {
 1016f50:	6a05      	ldr	r5, [r0, #32]
 1016f52:	b155      	cbz	r5, 1016f6a <metal_io_block_read+0x32>
		retlen = (*io->ops.block_read)(
 1016f54:	9300      	str	r3, [sp, #0]
 1016f56:	2305      	movs	r3, #5
 1016f58:	47a8      	blx	r5
 1016f5a:	4603      	mov	r3, r0
		for (; len != 0; dest++, ptr++, len--)
			*(unsigned char *)dest =
				*(const unsigned char *)ptr;
	}
	return retlen;
}
 1016f5c:	4618      	mov	r0, r3
 1016f5e:	b002      	add	sp, #8
 1016f60:	bd70      	pop	{r4, r5, r6, pc}
	if (offset >= io->size)
 1016f62:	42a9      	cmp	r1, r5
 1016f64:	d222      	bcs.n	1016fac <metal_io_block_read+0x74>
 1016f66:	2400      	movs	r4, #0
 1016f68:	e7ee      	b.n	1016f48 <metal_io_block_read+0x10>
		atomic_thread_fence(memory_order_seq_cst);
 1016f6a:	f3bf 8f5b 	dmb	ish
		while ( len && (
 1016f6e:	4621      	mov	r1, r4
 1016f70:	4618      	mov	r0, r3
 1016f72:	2800      	cmp	r0, #0
 1016f74:	d0f2      	beq.n	1016f5c <metal_io_block_read+0x24>
			((uintptr_t)dest % sizeof(int)) ||
 1016f76:	ea42 0401 	orr.w	r4, r2, r1
 1016f7a:	07a4      	lsls	r4, r4, #30
 1016f7c:	d10a      	bne.n	1016f94 <metal_io_block_read+0x5c>
		for (; len >= (int)sizeof(int); dest += sizeof(int),
 1016f7e:	2803      	cmp	r0, #3
 1016f80:	dc0e      	bgt.n	1016fa0 <metal_io_block_read+0x68>
 1016f82:	3901      	subs	r1, #1
 1016f84:	4410      	add	r0, r2
		for (; len != 0; dest++, ptr++, len--)
 1016f86:	4282      	cmp	r2, r0
 1016f88:	d0e8      	beq.n	1016f5c <metal_io_block_read+0x24>
				*(const unsigned char *)ptr;
 1016f8a:	f811 4f01 	ldrb.w	r4, [r1, #1]!
			*(unsigned char *)dest =
 1016f8e:	f802 4b01 	strb.w	r4, [r2], #1
		for (; len != 0; dest++, ptr++, len--)
 1016f92:	e7f8      	b.n	1016f86 <metal_io_block_read+0x4e>
				*(const unsigned char *)ptr;
 1016f94:	f811 4b01 	ldrb.w	r4, [r1], #1
			len--;
 1016f98:	3801      	subs	r0, #1
			*(unsigned char *)dest =
 1016f9a:	f802 4b01 	strb.w	r4, [r2], #1
			len--;
 1016f9e:	e7e8      	b.n	1016f72 <metal_io_block_read+0x3a>
			*(unsigned int *)dest = *(const unsigned int *)ptr;
 1016fa0:	f851 4b04 	ldr.w	r4, [r1], #4
 1016fa4:	3804      	subs	r0, #4
 1016fa6:	f842 4b04 	str.w	r4, [r2], #4
		for (; len >= (int)sizeof(int); dest += sizeof(int),
 1016faa:	e7e8      	b.n	1016f7e <metal_io_block_read+0x46>
		return -ERANGE;
 1016fac:	f06f 0325 	mvn.w	r3, #37	; 0x25
 1016fb0:	e7d4      	b.n	1016f5c <metal_io_block_read+0x24>

01016fb2 <metal_io_block_write>:

int metal_io_block_write(struct metal_io_region *io, unsigned long offset,
	       const void *restrict src, int len)
{
 1016fb2:	b573      	push	{r0, r1, r4, r5, r6, lr}
	return (io->virt != METAL_BAD_VA && offset < io->size
 1016fb4:	6804      	ldr	r4, [r0, #0]
 1016fb6:	6885      	ldr	r5, [r0, #8]
		: NULL);
 1016fb8:	1c66      	adds	r6, r4, #1
 1016fba:	d00e      	beq.n	1016fda <metal_io_block_write+0x28>
	return (io->virt != METAL_BAD_VA && offset < io->size
 1016fbc:	42a9      	cmp	r1, r5
 1016fbe:	d230      	bcs.n	1017022 <metal_io_block_write+0x70>
		: NULL);
 1016fc0:	440c      	add	r4, r1
	const unsigned char *source = src;
	int retlen;

	if (offset >= io->size)
		return -ERANGE;
	if ((offset + len) > io->size)
 1016fc2:	185e      	adds	r6, r3, r1
 1016fc4:	42ae      	cmp	r6, r5
		len = io->size - offset;
 1016fc6:	bf88      	it	hi
 1016fc8:	1a6b      	subhi	r3, r5, r1
	retlen = len;
	if (io->ops.block_write) {
 1016fca:	6a45      	ldr	r5, [r0, #36]	; 0x24
 1016fcc:	b94d      	cbnz	r5, 1016fe2 <metal_io_block_write+0x30>
 1016fce:	4619      	mov	r1, r3
		retlen = (*io->ops.block_write)(
			io, offset, src, memory_order_seq_cst, len);
	} else {
		while ( len && (
 1016fd0:	b991      	cbnz	r1, 1016ff8 <metal_io_block_write+0x46>
					len -= sizeof(int))
			*(unsigned int *)ptr = *(const unsigned int *)source;
		for (; len != 0; ptr++, source++, len--)
			*(unsigned char *)ptr =
				*(const unsigned char *)source;
		atomic_thread_fence(memory_order_seq_cst);
 1016fd2:	f3bf 8f5b 	dmb	ish
	retlen = len;
 1016fd6:	4618      	mov	r0, r3
 1016fd8:	e006      	b.n	1016fe8 <metal_io_block_write+0x36>
	if (offset >= io->size)
 1016fda:	42a9      	cmp	r1, r5
 1016fdc:	d221      	bcs.n	1017022 <metal_io_block_write+0x70>
 1016fde:	2400      	movs	r4, #0
 1016fe0:	e7ef      	b.n	1016fc2 <metal_io_block_write+0x10>
		retlen = (*io->ops.block_write)(
 1016fe2:	9300      	str	r3, [sp, #0]
 1016fe4:	2305      	movs	r3, #5
 1016fe6:	47a8      	blx	r5
	}
	return retlen;
}
 1016fe8:	b002      	add	sp, #8
 1016fea:	bd70      	pop	{r4, r5, r6, pc}
				*(const unsigned char *)source;
 1016fec:	f812 0b01 	ldrb.w	r0, [r2], #1
			len--;
 1016ff0:	3901      	subs	r1, #1
			*(unsigned char *)ptr =
 1016ff2:	f804 0b01 	strb.w	r0, [r4], #1
			len--;
 1016ff6:	e7eb      	b.n	1016fd0 <metal_io_block_write+0x1e>
			((uintptr_t)ptr % sizeof(int)) ||
 1016ff8:	ea44 0002 	orr.w	r0, r4, r2
 1016ffc:	0780      	lsls	r0, r0, #30
 1016ffe:	d1f5      	bne.n	1016fec <metal_io_block_write+0x3a>
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
 1017000:	2903      	cmp	r1, #3
 1017002:	dc08      	bgt.n	1017016 <metal_io_block_write+0x64>
 1017004:	3a01      	subs	r2, #1
 1017006:	4421      	add	r1, r4
		for (; len != 0; ptr++, source++, len--)
 1017008:	428c      	cmp	r4, r1
 101700a:	d0e2      	beq.n	1016fd2 <metal_io_block_write+0x20>
				*(const unsigned char *)source;
 101700c:	f812 0f01 	ldrb.w	r0, [r2, #1]!
			*(unsigned char *)ptr =
 1017010:	f804 0b01 	strb.w	r0, [r4], #1
		for (; len != 0; ptr++, source++, len--)
 1017014:	e7f8      	b.n	1017008 <metal_io_block_write+0x56>
			*(unsigned int *)ptr = *(const unsigned int *)source;
 1017016:	f852 0b04 	ldr.w	r0, [r2], #4
 101701a:	3904      	subs	r1, #4
 101701c:	f844 0b04 	str.w	r0, [r4], #4
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
 1017020:	e7ee      	b.n	1017000 <metal_io_block_write+0x4e>
		return -ERANGE;
 1017022:	f06f 0025 	mvn.w	r0, #37	; 0x25
 1017026:	e7df      	b.n	1016fe8 <metal_io_block_write+0x36>

01017028 <metal_io_block_set>:

int metal_io_block_set(struct metal_io_region *io, unsigned long offset,
	       unsigned char value, int len)
{
 1017028:	b573      	push	{r0, r1, r4, r5, r6, lr}
	return (io->virt != METAL_BAD_VA && offset < io->size
 101702a:	6804      	ldr	r4, [r0, #0]
 101702c:	461d      	mov	r5, r3
		: NULL);
 101702e:	1c66      	adds	r6, r4, #1
 1017030:	6883      	ldr	r3, [r0, #8]
 1017032:	d00e      	beq.n	1017052 <metal_io_block_set+0x2a>
	return (io->virt != METAL_BAD_VA && offset < io->size
 1017034:	4299      	cmp	r1, r3
 1017036:	d22d      	bcs.n	1017094 <metal_io_block_set+0x6c>
		: NULL);
 1017038:	440c      	add	r4, r1
	unsigned char *ptr = metal_io_virt(io, offset);
	int retlen = len;

	if (offset >= io->size)
		return -ERANGE;
	if ((offset + len) > io->size)
 101703a:	186e      	adds	r6, r5, r1
 101703c:	429e      	cmp	r6, r3
		len = io->size - offset;
	retlen = len;
	if (io->ops.block_set) {
 101703e:	6a86      	ldr	r6, [r0, #40]	; 0x28
		len = io->size - offset;
 1017040:	bf88      	it	hi
 1017042:	1a5d      	subhi	r5, r3, r1
	if (io->ops.block_set) {
 1017044:	b186      	cbz	r6, 1017068 <metal_io_block_set+0x40>
		(*io->ops.block_set)(
 1017046:	2305      	movs	r3, #5
 1017048:	9500      	str	r5, [sp, #0]
 101704a:	47b0      	blx	r6
		for (; len != 0; ptr++, len--)
			*(unsigned char *)ptr = (unsigned char) value;
		atomic_thread_fence(memory_order_seq_cst);
	}
	return retlen;
}
 101704c:	4628      	mov	r0, r5
 101704e:	b002      	add	sp, #8
 1017050:	bd70      	pop	{r4, r5, r6, pc}
	if (offset >= io->size)
 1017052:	4299      	cmp	r1, r3
 1017054:	d21e      	bcs.n	1017094 <metal_io_block_set+0x6c>
 1017056:	2400      	movs	r4, #0
 1017058:	e7ef      	b.n	101703a <metal_io_block_set+0x12>
			*(unsigned char *)ptr = (unsigned char) value;
 101705a:	f804 2b01 	strb.w	r2, [r4], #1
		for (; len && ((uintptr_t)ptr % sizeof(int)); ptr++, len--)
 101705e:	3b01      	subs	r3, #1
 1017060:	b923      	cbnz	r3, 101706c <metal_io_block_set+0x44>
		atomic_thread_fence(memory_order_seq_cst);
 1017062:	f3bf 8f5b 	dmb	ish
 1017066:	e7f1      	b.n	101704c <metal_io_block_set+0x24>
 1017068:	462b      	mov	r3, r5
 101706a:	e7f9      	b.n	1017060 <metal_io_block_set+0x38>
		for (; len && ((uintptr_t)ptr % sizeof(int)); ptr++, len--)
 101706c:	07a1      	lsls	r1, r4, #30
 101706e:	d1f4      	bne.n	101705a <metal_io_block_set+0x32>
			cint |= ((unsigned int)value << (CHAR_BIT * i));
 1017070:	0611      	lsls	r1, r2, #24
 1017072:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 1017076:	4311      	orrs	r1, r2
 1017078:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
 101707c:	2b03      	cmp	r3, #3
 101707e:	dc05      	bgt.n	101708c <metal_io_block_set+0x64>
 1017080:	4423      	add	r3, r4
		for (; len != 0; ptr++, len--)
 1017082:	429c      	cmp	r4, r3
 1017084:	d0ed      	beq.n	1017062 <metal_io_block_set+0x3a>
			*(unsigned char *)ptr = (unsigned char) value;
 1017086:	f804 2b01 	strb.w	r2, [r4], #1
		for (; len != 0; ptr++, len--)
 101708a:	e7fa      	b.n	1017082 <metal_io_block_set+0x5a>
			*(unsigned int *)ptr = cint;
 101708c:	f844 1b04 	str.w	r1, [r4], #4
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
 1017090:	3b04      	subs	r3, #4
 1017092:	e7f3      	b.n	101707c <metal_io_block_set+0x54>
		return -ERANGE;
 1017094:	f06f 0525 	mvn.w	r5, #37	; 0x25
 1017098:	e7d8      	b.n	101704c <metal_io_block_set+0x24>

0101709a <metal_generic_dev_sys_open>:

	/* Since Zephyr runs bare-metal there is no mapping that needs to be
	 * done of IO regions
	 */
	return 0;
}
 101709a:	2000      	movs	r0, #0
 101709c:	4770      	bx	lr

0101709e <metal_io_phys>:
 * @return	METAL_BAD_PHYS if offset is out of range, or physical address
 *		of offset.
 */
static inline metal_phys_addr_t
metal_io_phys(struct metal_io_region *io, unsigned long offset)
{
 101709e:	b430      	push	{r4, r5}
	if (!io->ops.offset_to_phys) {
 10170a0:	6b04      	ldr	r4, [r0, #48]	; 0x30
{
 10170a2:	460b      	mov	r3, r1
	if (!io->ops.offset_to_phys) {
 10170a4:	b984      	cbnz	r4, 10170c8 <metal_io_phys+0x2a>
		unsigned long page = (io->page_shift >=
 10170a6:	68c1      	ldr	r1, [r0, #12]
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
		return (io->physmap && offset < io->size
 10170a8:	6845      	ldr	r5, [r0, #4]
				     0 : offset >> io->page_shift);
 10170aa:	291f      	cmp	r1, #31
 10170ac:	bf98      	it	ls
 10170ae:	fa23 f401 	lsrls.w	r4, r3, r1
			? io->physmap[page] + (offset & io->page_mask)
			: METAL_BAD_PHYS);
 10170b2:	b165      	cbz	r5, 10170ce <metal_io_phys+0x30>
		return (io->physmap && offset < io->size
 10170b4:	6881      	ldr	r1, [r0, #8]
 10170b6:	428b      	cmp	r3, r1
 10170b8:	d209      	bcs.n	10170ce <metal_io_phys+0x30>
			? io->physmap[page] + (offset & io->page_mask)
 10170ba:	6900      	ldr	r0, [r0, #16]
 10170bc:	4003      	ands	r3, r0
			: METAL_BAD_PHYS);
 10170be:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
 10170c2:	4418      	add	r0, r3
	}

	return io->ops.offset_to_phys(io, offset);
}
 10170c4:	bc30      	pop	{r4, r5}
 10170c6:	4770      	bx	lr
	return io->ops.offset_to_phys(io, offset);
 10170c8:	4623      	mov	r3, r4
}
 10170ca:	bc30      	pop	{r4, r5}
	return io->ops.offset_to_phys(io, offset);
 10170cc:	4718      	bx	r3
			: METAL_BAD_PHYS);
 10170ce:	f04f 30ff 	mov.w	r0, #4294967295
 10170d2:	e7f7      	b.n	10170c4 <metal_io_phys+0x26>

010170d4 <virtqueue_create>:
{
 10170d4:	b570      	push	{r4, r5, r6, lr}
 10170d6:	9c06      	ldr	r4, [sp, #24]
		vq->vq_queue_index = id;
 10170d8:	8121      	strh	r1, [r4, #8]
		vq->callback = callback;
 10170da:	9904      	ldr	r1, [sp, #16]
		vq->vq_name = name;
 10170dc:	e9c4 0200 	strd	r0, r2, [r4]
		vq->vq_nentries = ring->num_descs;
 10170e0:	891a      	ldrh	r2, [r3, #8]
		vq->callback = callback;
 10170e2:	60e1      	str	r1, [r4, #12]
		vq->notify = notify;
 10170e4:	9905      	ldr	r1, [sp, #20]
{
	vr->num = num;
	vr->desc = (struct vring_desc *)p;
	vr->avail = (struct vring_avail *)(p + num * sizeof(struct vring_desc));
	vr->used = (struct vring_used *)
	    (((unsigned long)&vr->avail->ring[num] + sizeof(uint16_t) +
 10170e6:	1c96      	adds	r6, r2, #2
 10170e8:	6121      	str	r1, [r4, #16]
		vq_ring_init(vq, ring->vaddr, ring->align);
 10170ea:	e9d3 1500 	ldrd	r1, r5, [r3]
	vr->avail = (struct vring_avail *)(p + num * sizeof(struct vring_desc));
 10170ee:	eb01 1302 	add.w	r3, r1, r2, lsl #4
 10170f2:	61e3      	str	r3, [r4, #28]
	    (((unsigned long)&vr->avail->ring[num] + sizeof(uint16_t) +
 10170f4:	eb03 0346 	add.w	r3, r3, r6, lsl #1
	      align - 1) & ~(align - 1));
 10170f8:	1c6e      	adds	r6, r5, #1
 10170fa:	4433      	add	r3, r6
 10170fc:	426d      	negs	r5, r5
 10170fe:	402b      	ands	r3, r5
	vr->used = (struct vring_used *)
 1017100:	6223      	str	r3, [r4, #32]
	vr = &vq->vq_ring;

	vring_init(vr, size, ring_mem, alignment);

#ifndef VIRTIO_SLAVE_ONLY
	if (vq->vq_dev->role == VIRTIO_DEV_MASTER) {
 1017102:	6983      	ldr	r3, [r0, #24]
	vr->desc = (struct vring_desc *)p;
 1017104:	e9c4 2105 	strd	r2, r1, [r4, #20]
		vq->vq_nentries = ring->num_descs;
 1017108:	8162      	strh	r2, [r4, #10]
		vq->vq_free_cnt = vq->vq_nentries;
 101710a:	84a2      	strh	r2, [r4, #36]	; 0x24
	if (vq->vq_dev->role == VIRTIO_DEV_MASTER) {
 101710c:	b96b      	cbnz	r3, 101712a <virtqueue_create+0x56>
		int i;

		for (i = 0; i < size - 1; i++)
 101710e:	3a01      	subs	r2, #1
 1017110:	4293      	cmp	r3, r2
 1017112:	eb01 1003 	add.w	r0, r1, r3, lsl #4
 1017116:	db0a      	blt.n	101712e <virtqueue_create+0x5a>
			vr->desc[i].next = i + 1;
		vr->desc[i].next = VQ_RING_DESC_CHAIN_END;
 1017118:	2300      	movs	r3, #0
 101711a:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
 101711e:	eb01 1202 	add.w	r2, r1, r2, lsl #4
 1017122:	7393      	strb	r3, [r2, #14]
 1017124:	f06f 037f 	mvn.w	r3, #127	; 0x7f
 1017128:	73d3      	strb	r3, [r2, #15]
}
 101712a:	2000      	movs	r0, #0
 101712c:	bd70      	pop	{r4, r5, r6, pc}
			vr->desc[i].next = i + 1;
 101712e:	3301      	adds	r3, #1
 1017130:	81c3      	strh	r3, [r0, #14]
		for (i = 0; i < size - 1; i++)
 1017132:	e7ed      	b.n	1017110 <virtqueue_create+0x3c>

01017134 <virtqueue_add_buffer>:
{
 1017134:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
 1017138:	2700      	movs	r7, #0
		head_idx = vq->vq_desc_head_idx;
 101713a:	f8b0 b02c 	ldrh.w	fp, [r0, #44]	; 0x2c
{
 101713e:	4604      	mov	r4, r0
	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
 1017140:	465d      	mov	r5, fp
		dp->addr = virtqueue_virt_to_phys(vq, buf_list[i].buf);
 1017142:	46ba      	mov	sl, r7
{
 1017144:	b085      	sub	sp, #20
	needed = readable + writable;
 1017146:	18d6      	adds	r6, r2, r3
{
 1017148:	4691      	mov	r9, r2
		dxp->cookie = cookie;
 101714a:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 101714c:	eb00 03cb 	add.w	r3, r0, fp, lsl #3
 1017150:	635a      	str	r2, [r3, #52]	; 0x34
		dxp->ndescs = needed;
 1017152:	871e      	strh	r6, [r3, #56]	; 0x38
		if (i < needed - 1)
 1017154:	1e72      	subs	r2, r6, #1
		idx = vq_ring_add_buffer(vq, vq->vq_ring.desc, head_idx,
 1017156:	6983      	ldr	r3, [r0, #24]
	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
 1017158:	f101 0804 	add.w	r8, r1, #4
		if (i < needed - 1)
 101715c:	9201      	str	r2, [sp, #4]
	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
 101715e:	42be      	cmp	r6, r7
 1017160:	dc19      	bgt.n	1017196 <virtqueue_add_buffer+0x62>
		vq->vq_free_cnt -= needed;
 1017162:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
	 * it usable to the host. The chain is made available now rather than
	 * deferring to virtqueue_notify() in the hopes that if the host is
	 * currently running on another CPU, we can keep it processing the new
	 * descriptor.
	 */
	avail_idx = vq->vq_ring.avail->idx & (vq->vq_nentries - 1);
 1017164:	8962      	ldrh	r2, [r4, #10]
		vq->vq_free_cnt -= needed;
 1017166:	1b9e      	subs	r6, r3, r6
	avail_idx = vq->vq_ring.avail->idx & (vq->vq_nentries - 1);
 1017168:	69e3      	ldr	r3, [r4, #28]
		vq->vq_desc_head_idx = idx;
 101716a:	85a5      	strh	r5, [r4, #44]	; 0x2c
		vq->vq_free_cnt -= needed;
 101716c:	84a6      	strh	r6, [r4, #36]	; 0x24
	avail_idx = vq->vq_ring.avail->idx & (vq->vq_nentries - 1);
 101716e:	1e51      	subs	r1, r2, #1
 1017170:	885a      	ldrh	r2, [r3, #2]
}
 1017172:	2000      	movs	r0, #0
	vq->vq_ring.avail->ring[avail_idx] = desc_idx;
 1017174:	400a      	ands	r2, r1
 1017176:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 101717a:	f8a3 b004 	strh.w	fp, [r3, #4]

	atomic_thread_fence(memory_order_seq_cst);
 101717e:	f3bf 8f5b 	dmb	ish

	vq->vq_ring.avail->idx++;
 1017182:	69e2      	ldr	r2, [r4, #28]
 1017184:	8853      	ldrh	r3, [r2, #2]
 1017186:	3301      	adds	r3, #1
 1017188:	8053      	strh	r3, [r2, #2]

	/* Keep pending count until virtqueue_notify(). */
	vq->vq_queued_cnt++;
 101718a:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 101718c:	3301      	adds	r3, #1
 101718e:	84e3      	strh	r3, [r4, #38]	; 0x26
}
 1017190:	b005      	add	sp, #20
 1017192:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dp->addr = virtqueue_virt_to_phys(vq, buf_list[i].buf);
 1017196:	6aa0      	ldr	r0, [r4, #40]	; 0x28
		dp = &desc[idx];
 1017198:	012a      	lsls	r2, r5, #4
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
 101719a:	f858 1c04 	ldr.w	r1, [r8, #-4]
 101719e:	eb03 1505 	add.w	r5, r3, r5, lsl #4
 10171a2:	9302      	str	r3, [sp, #8]
 10171a4:	6803      	ldr	r3, [r0, #0]
 10171a6:	9203      	str	r2, [sp, #12]
 10171a8:	1ac9      	subs	r1, r1, r3
 *		physical address.
 */
static inline metal_phys_addr_t
metal_io_virt_to_phys(struct metal_io_region *io, void *virt)
{
	return metal_io_phys(io, metal_io_virt_to_offset(io, virt));
 10171aa:	6883      	ldr	r3, [r0, #8]
 10171ac:	f108 0808 	add.w	r8, r8, #8
 10171b0:	4299      	cmp	r1, r3
 10171b2:	bf28      	it	cs
 10171b4:	f04f 31ff 	movcs.w	r1, #4294967295
 10171b8:	f7ff ff71 	bl	101709e <metal_io_phys>
		dp->addr = virtqueue_virt_to_phys(vq, buf_list[i].buf);
 10171bc:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
 10171c0:	5098      	str	r0, [r3, r2]
		dp->len = buf_list[i].len;
 10171c2:	f858 2c08 	ldr.w	r2, [r8, #-8]
			dp->flags |= VRING_DESC_F_NEXT;
 10171c6:	f885 a00d 	strb.w	sl, [r5, #13]
		dp->len = buf_list[i].len;
 10171ca:	60aa      	str	r2, [r5, #8]
		if (i < needed - 1)
 10171cc:	9a01      	ldr	r2, [sp, #4]
		dp->addr = virtqueue_virt_to_phys(vq, buf_list[i].buf);
 10171ce:	f8c5 a004 	str.w	sl, [r5, #4]
		if (i < needed - 1)
 10171d2:	4297      	cmp	r7, r2
			dp->flags |= VRING_DESC_F_NEXT;
 10171d4:	bfb6      	itet	lt
 10171d6:	2201      	movlt	r2, #1
		dp->flags = 0;
 10171d8:	f885 a00c 	strbge.w	sl, [r5, #12]
			dp->flags |= VRING_DESC_F_NEXT;
 10171dc:	732a      	strblt	r2, [r5, #12]
		if (i >= readable)
 10171de:	45b9      	cmp	r9, r7
			dp->flags |= VRING_DESC_F_WRITE;
 10171e0:	bfd8      	it	le
 10171e2:	89aa      	ldrhle	r2, [r5, #12]
	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
 10171e4:	f107 0701 	add.w	r7, r7, #1
			dp->flags |= VRING_DESC_F_WRITE;
 10171e8:	bfdc      	itt	le
 10171ea:	f042 0202 	orrle.w	r2, r2, #2
 10171ee:	81aa      	strhle	r2, [r5, #12]
	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
 10171f0:	89ed      	ldrh	r5, [r5, #14]
 10171f2:	e7b4      	b.n	101715e <virtqueue_add_buffer+0x2a>

010171f4 <virtqueue_get_buffer>:
{
 10171f4:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (!vq || vq->vq_used_cons_idx == vq->vq_ring.used->idx)
 10171f6:	b350      	cbz	r0, 101724e <virtqueue_get_buffer+0x5a>
 10171f8:	6a05      	ldr	r5, [r0, #32]
 10171fa:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
 10171fc:	886c      	ldrh	r4, [r5, #2]
 10171fe:	429c      	cmp	r4, r3
 1017200:	d030      	beq.n	1017264 <virtqueue_get_buffer+0x70>
	used_idx = vq->vq_used_cons_idx++ & (vq->vq_nentries - 1);
 1017202:	1c5c      	adds	r4, r3, #1
 1017204:	85c4      	strh	r4, [r0, #46]	; 0x2e
 1017206:	8944      	ldrh	r4, [r0, #10]
	atomic_thread_fence(memory_order_seq_cst);
 1017208:	f3bf 8f5b 	dmb	ish
	used_idx = vq->vq_used_cons_idx++ & (vq->vq_nentries - 1);
 101720c:	3c01      	subs	r4, #1
 101720e:	401c      	ands	r4, r3
	desc_idx = (uint16_t)uep->id;
 1017210:	eb05 05c4 	add.w	r5, r5, r4, lsl #3
 1017214:	686b      	ldr	r3, [r5, #4]
 1017216:	b29e      	uxth	r6, r3
	if (len)
 1017218:	b109      	cbz	r1, 101721e <virtqueue_get_buffer+0x2a>
		*len = uep->len;
 101721a:	68ad      	ldr	r5, [r5, #8]
 101721c:	600d      	str	r5, [r1, #0]
	dp = &vq->vq_ring.desc[desc_idx];
 101721e:	f8d0 c018 	ldr.w	ip, [r0, #24]
 1017222:	b29b      	uxth	r3, r3
 1017224:	eb0c 1103 	add.w	r1, ip, r3, lsl #4
	vq->vq_free_cnt += dxp->ndescs;
 1017228:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
 101722c:	8f1d      	ldrh	r5, [r3, #56]	; 0x38
 101722e:	8c87      	ldrh	r7, [r0, #36]	; 0x24
 1017230:	442f      	add	r7, r5
	dxp->ndescs--;
 1017232:	3d01      	subs	r5, #1
	vq->vq_free_cnt += dxp->ndescs;
 1017234:	8487      	strh	r7, [r0, #36]	; 0x24
	dxp->ndescs--;
 1017236:	871d      	strh	r5, [r3, #56]	; 0x38
	if ((dp->flags & VRING_DESC_F_INDIRECT) == 0) {
 1017238:	898d      	ldrh	r5, [r1, #12]
 101723a:	076f      	lsls	r7, r5, #29
 101723c:	d50e      	bpl.n	101725c <virtqueue_get_buffer+0x68>
	dp->next = vq->vq_desc_head_idx;
 101723e:	8d85      	ldrh	r5, [r0, #44]	; 0x2c
 1017240:	81cd      	strh	r5, [r1, #14]
	vq->vq_descx[desc_idx].cookie = NULL;
 1017242:	2100      	movs	r1, #0
	vq->vq_desc_head_idx = desc_idx;
 1017244:	8586      	strh	r6, [r0, #44]	; 0x2c
	cookie = vq->vq_descx[desc_idx].cookie;
 1017246:	6b58      	ldr	r0, [r3, #52]	; 0x34
	vq->vq_descx[desc_idx].cookie = NULL;
 1017248:	6359      	str	r1, [r3, #52]	; 0x34
	if (idx)
 101724a:	b102      	cbz	r2, 101724e <virtqueue_get_buffer+0x5a>
		*idx = used_idx;
 101724c:	8014      	strh	r4, [r2, #0]
}
 101724e:	bdf0      	pop	{r4, r5, r6, r7, pc}
			dxp->ndescs--;
 1017250:	8f1d      	ldrh	r5, [r3, #56]	; 0x38
			dp = &vq->vq_ring.desc[dp->next];
 1017252:	89c9      	ldrh	r1, [r1, #14]
			dxp->ndescs--;
 1017254:	3d01      	subs	r5, #1
			dp = &vq->vq_ring.desc[dp->next];
 1017256:	eb0c 1101 	add.w	r1, ip, r1, lsl #4
			dxp->ndescs--;
 101725a:	871d      	strh	r5, [r3, #56]	; 0x38
		while (dp->flags & VRING_DESC_F_NEXT) {
 101725c:	898d      	ldrh	r5, [r1, #12]
 101725e:	07ed      	lsls	r5, r5, #31
 1017260:	d4f6      	bmi.n	1017250 <virtqueue_get_buffer+0x5c>
 1017262:	e7ec      	b.n	101723e <virtqueue_get_buffer+0x4a>
		return NULL;
 1017264:	2000      	movs	r0, #0
 1017266:	e7f2      	b.n	101724e <virtqueue_get_buffer+0x5a>

01017268 <virtqueue_get_available_buffer>:
{
 1017268:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	atomic_thread_fence(memory_order_seq_cst);
 101726c:	f3bf 8f5b 	dmb	ish
{
 1017270:	4617      	mov	r7, r2
	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
 1017272:	69c2      	ldr	r2, [r0, #28]
{
 1017274:	460e      	mov	r6, r1
	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
 1017276:	8853      	ldrh	r3, [r2, #2]
 1017278:	8e01      	ldrh	r1, [r0, #48]	; 0x30
{
 101727a:	4605      	mov	r5, r0
	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
 101727c:	428b      	cmp	r3, r1
 101727e:	d046      	beq.n	101730e <virtqueue_get_available_buffer+0xa6>
	head_idx = vq->vq_available_idx++ & (vq->vq_nentries - 1);
 1017280:	1c4b      	adds	r3, r1, #1
 1017282:	8603      	strh	r3, [r0, #48]	; 0x30
 1017284:	8943      	ldrh	r3, [r0, #10]
	buffer = virtqueue_phys_to_virt(vq, vq->vq_ring.desc[*avail_idx].addr);
 1017286:	f8d0 8028 	ldr.w	r8, [r0, #40]	; 0x28
	head_idx = vq->vq_available_idx++ & (vq->vq_nentries - 1);
 101728a:	3b01      	subs	r3, #1
	*avail_idx = vq->vq_ring.avail->ring[head_idx];
 101728c:	400b      	ands	r3, r1
 101728e:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 1017292:	889a      	ldrh	r2, [r3, #4]
	buffer = virtqueue_phys_to_virt(vq, vq->vq_ring.desc[*avail_idx].addr);
 1017294:	6983      	ldr	r3, [r0, #24]
	*avail_idx = vq->vq_ring.avail->ring[head_idx];
 1017296:	b291      	uxth	r1, r2
	buffer = virtqueue_phys_to_virt(vq, vq->vq_ring.desc[*avail_idx].addr);
 1017298:	eb03 1301 	add.w	r3, r3, r1, lsl #4
	*avail_idx = vq->vq_ring.avail->ring[head_idx];
 101729c:	8032      	strh	r2, [r6, #0]
	buffer = virtqueue_phys_to_virt(vq, vq->vq_ring.desc[*avail_idx].addr);
 101729e:	f8d3 9000 	ldr.w	r9, [r3]
	if (!io->ops.phys_to_offset) {
 10172a2:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
 10172a6:	bb5b      	cbnz	r3, 1017300 <virtqueue_get_available_buffer+0x98>
			(io->page_mask == (metal_phys_addr_t)(-1) ?
 10172a8:	f8d8 4010 	ldr.w	r4, [r8, #16]
			phys - io->physmap[0] :  phys & io->page_mask);
 10172ac:	1c62      	adds	r2, r4, #1
 10172ae:	bf09      	itett	eq
 10172b0:	f8d8 3004 	ldreq.w	r3, [r8, #4]
 10172b4:	ea09 0404 	andne.w	r4, r9, r4
 10172b8:	681c      	ldreq	r4, [r3, #0]
 10172ba:	eba9 0404 	subeq.w	r4, r9, r4
			if (metal_io_phys(io, offset) == phys)
 10172be:	4621      	mov	r1, r4
 10172c0:	4640      	mov	r0, r8
 10172c2:	f7ff feec 	bl	101709e <metal_io_phys>
 10172c6:	4581      	cmp	r9, r0
 10172c8:	d009      	beq.n	10172de <virtqueue_get_available_buffer+0x76>
			offset += io->page_mask + 1;
 10172ca:	f8d8 3010 	ldr.w	r3, [r8, #16]
 10172ce:	3301      	adds	r3, #1
 10172d0:	441c      	add	r4, r3
		} while (offset < io->size);
 10172d2:	f8d8 3008 	ldr.w	r3, [r8, #8]
 10172d6:	429c      	cmp	r4, r3
 10172d8:	d3f1      	bcc.n	10172be <virtqueue_get_available_buffer+0x56>
		return METAL_BAD_OFFSET;
 10172da:	f04f 34ff 	mov.w	r4, #4294967295
	return (io->virt != METAL_BAD_VA && offset < io->size
 10172de:	f8d8 0000 	ldr.w	r0, [r8]
		: NULL);
 10172e2:	1c43      	adds	r3, r0, #1
 10172e4:	d011      	beq.n	101730a <virtqueue_get_available_buffer+0xa2>
	return (io->virt != METAL_BAD_VA && offset < io->size
 10172e6:	f8d8 3008 	ldr.w	r3, [r8, #8]
 10172ea:	42a3      	cmp	r3, r4
 10172ec:	d90d      	bls.n	101730a <virtqueue_get_available_buffer+0xa2>
		: NULL);
 10172ee:	4420      	add	r0, r4
	*len = vq->vq_ring.desc[*avail_idx].len;
 10172f0:	8832      	ldrh	r2, [r6, #0]
 10172f2:	69ab      	ldr	r3, [r5, #24]
 10172f4:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 10172f8:	689b      	ldr	r3, [r3, #8]
 10172fa:	603b      	str	r3, [r7, #0]
}
 10172fc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return (*io->ops.phys_to_offset)(io, phys);
 1017300:	4649      	mov	r1, r9
 1017302:	4640      	mov	r0, r8
 1017304:	4798      	blx	r3
 1017306:	4604      	mov	r4, r0
 1017308:	e7e9      	b.n	10172de <virtqueue_get_available_buffer+0x76>
		: NULL);
 101730a:	2000      	movs	r0, #0
 101730c:	e7f0      	b.n	10172f0 <virtqueue_get_available_buffer+0x88>
		return NULL;
 101730e:	2000      	movs	r0, #0
 1017310:	e7f4      	b.n	10172fc <virtqueue_get_available_buffer+0x94>

01017312 <virtqueue_disable_cb>:
{
 1017312:	b530      	push	{r4, r5, lr}
	if (vq->vq_dev->features & VIRTIO_RING_F_EVENT_IDX) {
 1017314:	2500      	movs	r5, #0
 1017316:	6802      	ldr	r2, [r0, #0]
 1017318:	6993      	ldr	r3, [r2, #24]
 101731a:	6912      	ldr	r2, [r2, #16]
 101731c:	f002 5400 	and.w	r4, r2, #536870912	; 0x20000000
 1017320:	ea54 0205 	orrs.w	r2, r4, r5
 1017324:	d014      	beq.n	1017350 <virtqueue_disable_cb+0x3e>
		if (vq->vq_dev->role == VIRTIO_DEV_MASTER) {
 1017326:	b94b      	cbnz	r3, 101733c <virtqueue_disable_cb+0x2a>
			vring_used_event(&vq->vq_ring) =
 1017328:	69c2      	ldr	r2, [r0, #28]
 101732a:	6941      	ldr	r1, [r0, #20]
			    vq->vq_used_cons_idx - vq->vq_nentries - 1;
 101732c:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
 101732e:	8940      	ldrh	r0, [r0, #10]
			vring_used_event(&vq->vq_ring) =
 1017330:	eb02 0241 	add.w	r2, r2, r1, lsl #1
			    vq->vq_used_cons_idx - vq->vq_nentries - 1;
 1017334:	1a1b      	subs	r3, r3, r0
			vring_avail_event(&vq->vq_ring) =
 1017336:	3b01      	subs	r3, #1
 1017338:	8093      	strh	r3, [r2, #4]
}
 101733a:	bd30      	pop	{r4, r5, pc}
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE) {
 101733c:	2b01      	cmp	r3, #1
 101733e:	d1fc      	bne.n	101733a <virtqueue_disable_cb+0x28>
			vring_avail_event(&vq->vq_ring) =
 1017340:	6a02      	ldr	r2, [r0, #32]
 1017342:	6941      	ldr	r1, [r0, #20]
			    vq->vq_available_idx - vq->vq_nentries - 1;
 1017344:	8e03      	ldrh	r3, [r0, #48]	; 0x30
 1017346:	8940      	ldrh	r0, [r0, #10]
			vring_avail_event(&vq->vq_ring) =
 1017348:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
			    vq->vq_available_idx - vq->vq_nentries - 1;
 101734c:	1a1b      	subs	r3, r3, r0
 101734e:	e7f2      	b.n	1017336 <virtqueue_disable_cb+0x24>
		if (vq->vq_dev->role == VIRTIO_DEV_MASTER)
 1017350:	b92b      	cbnz	r3, 101735e <virtqueue_disable_cb+0x4c>
			vq->vq_ring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
 1017352:	69c2      	ldr	r2, [r0, #28]
			vq->vq_ring.used->flags |= VRING_USED_F_NO_NOTIFY;
 1017354:	8813      	ldrh	r3, [r2, #0]
 1017356:	f043 0301 	orr.w	r3, r3, #1
 101735a:	8013      	strh	r3, [r2, #0]
}
 101735c:	e7ed      	b.n	101733a <virtqueue_disable_cb+0x28>
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE)
 101735e:	2b01      	cmp	r3, #1
 1017360:	d1eb      	bne.n	101733a <virtqueue_disable_cb+0x28>
			vq->vq_ring.used->flags |= VRING_USED_F_NO_NOTIFY;
 1017362:	6a02      	ldr	r2, [r0, #32]
 1017364:	e7f6      	b.n	1017354 <virtqueue_disable_cb+0x42>

01017366 <virtqueue_kick>:
{
 1017366:	b510      	push	{r4, lr}
	atomic_thread_fence(memory_order_seq_cst);
 1017368:	f3bf 8f5b 	dmb	ish
 */
static int vq_ring_must_notify(struct virtqueue *vq)
{
	uint16_t new_idx, prev_idx, event_idx;

	if (vq->vq_dev->features & VIRTIO_RING_F_EVENT_IDX) {
 101736c:	2300      	movs	r3, #0
 101736e:	6801      	ldr	r1, [r0, #0]
{
 1017370:	4604      	mov	r4, r0
	if (vq->vq_dev->features & VIRTIO_RING_F_EVENT_IDX) {
 1017372:	6908      	ldr	r0, [r1, #16]
 1017374:	f000 5200 	and.w	r2, r0, #536870912	; 0x20000000
 1017378:	4313      	orrs	r3, r2
 101737a:	698b      	ldr	r3, [r1, #24]
 101737c:	d020      	beq.n	10173c0 <virtqueue_kick+0x5a>
#ifndef VIRTIO_SLAVE_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_MASTER) {
 101737e:	b9b3      	cbnz	r3, 10173ae <virtqueue_kick+0x48>
			new_idx = vq->vq_ring.avail->idx;
 1017380:	69e3      	ldr	r3, [r4, #28]
			prev_idx = new_idx - vq->vq_queued_cnt;
			event_idx = vring_avail_event(&vq->vq_ring);
 1017382:	6961      	ldr	r1, [r4, #20]
			new_idx = vq->vq_ring.avail->idx;
 1017384:	885a      	ldrh	r2, [r3, #2]
			event_idx = vring_avail_event(&vq->vq_ring);
 1017386:	6a23      	ldr	r3, [r4, #32]
 1017388:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
#endif /*VIRTIO_SLAVE_ONLY*/
#ifndef VIRTIO_MASTER_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE) {
			new_idx = vq->vq_ring.used->idx;
			prev_idx = new_idx - vq->vq_queued_cnt;
			event_idx = vring_used_event(&vq->vq_ring);
 101738c:	889b      	ldrh	r3, [r3, #4]
 * event?
 */
static inline int
vring_need_event(uint16_t event_idx, uint16_t new_idx, uint16_t old)
{
	return (uint16_t)(new_idx - event_idx - 1) <
 101738e:	1ad2      	subs	r2, r2, r3
 1017390:	3a01      	subs	r2, #1
 1017392:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 1017394:	b292      	uxth	r2, r2
 1017396:	4293      	cmp	r3, r2
 1017398:	bf94      	ite	ls
 101739a:	2300      	movls	r3, #0
 101739c:	2301      	movhi	r3, #1
	if (vq_ring_must_notify(vq))
 101739e:	b11b      	cbz	r3, 10173a8 <virtqueue_kick+0x42>
 * vq_ring_notify
 *
 */
static void vq_ring_notify(struct virtqueue *vq)
{
	if (vq->notify)
 10173a0:	6923      	ldr	r3, [r4, #16]
 10173a2:	b10b      	cbz	r3, 10173a8 <virtqueue_kick+0x42>
		vq->notify(vq);
 10173a4:	4620      	mov	r0, r4
 10173a6:	4798      	blx	r3
	vq->vq_queued_cnt = 0;
 10173a8:	2300      	movs	r3, #0
 10173aa:	84e3      	strh	r3, [r4, #38]	; 0x26
}
 10173ac:	bd10      	pop	{r4, pc}
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE) {
 10173ae:	2b01      	cmp	r3, #1
 10173b0:	d1fa      	bne.n	10173a8 <virtqueue_kick+0x42>
			new_idx = vq->vq_ring.used->idx;
 10173b2:	6a23      	ldr	r3, [r4, #32]
			event_idx = vring_used_event(&vq->vq_ring);
 10173b4:	6961      	ldr	r1, [r4, #20]
			new_idx = vq->vq_ring.used->idx;
 10173b6:	885a      	ldrh	r2, [r3, #2]
			event_idx = vring_used_event(&vq->vq_ring);
 10173b8:	69e3      	ldr	r3, [r4, #28]
 10173ba:	eb03 0341 	add.w	r3, r3, r1, lsl #1
 10173be:	e7e5      	b.n	101738c <virtqueue_kick+0x26>
		if (vq->vq_dev->role == VIRTIO_DEV_MASTER)
 10173c0:	b92b      	cbnz	r3, 10173ce <virtqueue_kick+0x68>
			return (vq->vq_ring.used->flags &
 10173c2:	6a23      	ldr	r3, [r4, #32]
			return (vq->vq_ring.avail->flags &
 10173c4:	881b      	ldrh	r3, [r3, #0]
				VRING_AVAIL_F_NO_INTERRUPT) == 0;
 10173c6:	43db      	mvns	r3, r3
 10173c8:	f003 0301 	and.w	r3, r3, #1
 10173cc:	e7e7      	b.n	101739e <virtqueue_kick+0x38>
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE)
 10173ce:	2b01      	cmp	r3, #1
 10173d0:	d1ea      	bne.n	10173a8 <virtqueue_kick+0x42>
			return (vq->vq_ring.avail->flags &
 10173d2:	69e3      	ldr	r3, [r4, #28]
 10173d4:	e7f6      	b.n	10173c4 <virtqueue_kick+0x5e>

010173d6 <virtqueue_get_desc_size>:
	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
 10173d6:	69c2      	ldr	r2, [r0, #28]
 10173d8:	8e01      	ldrh	r1, [r0, #48]	; 0x30
 10173da:	8853      	ldrh	r3, [r2, #2]
 10173dc:	428b      	cmp	r3, r1
 10173de:	d00a      	beq.n	10173f6 <virtqueue_get_desc_size+0x20>
	head_idx = vq->vq_available_idx & (vq->vq_nentries - 1);
 10173e0:	8943      	ldrh	r3, [r0, #10]
 10173e2:	3b01      	subs	r3, #1
	avail_idx = vq->vq_ring.avail->ring[head_idx];
 10173e4:	400b      	ands	r3, r1
 10173e6:	eb02 0343 	add.w	r3, r2, r3, lsl #1
	len = vq->vq_ring.desc[avail_idx].len;
 10173ea:	889a      	ldrh	r2, [r3, #4]
 10173ec:	6983      	ldr	r3, [r0, #24]
 10173ee:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 10173f2:	6898      	ldr	r0, [r3, #8]
	return len;
 10173f4:	4770      	bx	lr
		return 0;
 10173f6:	2000      	movs	r0, #0
}
 10173f8:	4770      	bx	lr

010173fa <virtqueue_notification>:
	atomic_thread_fence(memory_order_seq_cst);
 10173fa:	f3bf 8f5b 	dmb	ish
	if (vq->callback)
 10173fe:	68c3      	ldr	r3, [r0, #12]
 1017400:	b103      	cbz	r3, 1017404 <virtqueue_notification+0xa>
		vq->callback(vq);
 1017402:	4718      	bx	r3
}
 1017404:	4770      	bx	lr

01017406 <rpmsg_unregister_endpoint>:
{
 1017406:	b510      	push	{r4, lr}
	if (!ept)
 1017408:	b1d0      	cbz	r0, 1017440 <rpmsg_unregister_endpoint+0x3a>
	if (ept->addr != RPMSG_ADDR_ANY)
 101740a:	6a43      	ldr	r3, [r0, #36]	; 0x24
 101740c:	1c5a      	adds	r2, r3, #1
 101740e:	d00f      	beq.n	1017430 <rpmsg_unregister_endpoint+0x2a>
	if (addr < size)
 1017410:	2b7f      	cmp	r3, #127	; 0x7f
 1017412:	dc0d      	bgt.n	1017430 <rpmsg_unregister_endpoint+0x2a>
		~metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
 1017414:	2101      	movs	r1, #1
		rpmsg_release_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE,
 1017416:	6a02      	ldr	r2, [r0, #32]
	bitmap[bit / METAL_BITS_PER_ULONG] &=
 1017418:	095c      	lsrs	r4, r3, #5
 101741a:	3248      	adds	r2, #72	; 0x48
		~metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
 101741c:	f003 031f 	and.w	r3, r3, #31
 1017420:	fa01 f303 	lsl.w	r3, r1, r3
	bitmap[bit / METAL_BITS_PER_ULONG] &=
 1017424:	f852 1024 	ldr.w	r1, [r2, r4, lsl #2]
 1017428:	ea21 0103 	bic.w	r1, r1, r3
 101742c:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
	metal_list_del(&ept->node);
 1017430:	f100 0334 	add.w	r3, r0, #52	; 0x34
	return list->next == list;
}

static inline void metal_list_del(struct metal_list *node)
{
	node->next->prev = node->prev;
 1017434:	e9d0 120d 	ldrd	r1, r2, [r0, #52]	; 0x34
 1017438:	604a      	str	r2, [r1, #4]
	node->prev->next = node->next;
 101743a:	6011      	str	r1, [r2, #0]
	node->prev = node;
	node->next = node;
 101743c:	e9c0 330d 	strd	r3, r3, [r0, #52]	; 0x34
}
 1017440:	bd10      	pop	{r4, pc}

01017442 <__metal_mutex_acquire>:
	return z_impl_k_sem_take(sem, timeout);
 1017442:	f04f 32ff 	mov.w	r2, #4294967295
 1017446:	f04f 33ff 	mov.w	r3, #4294967295
 101744a:	f7fd b9d3 	b.w	10147f4 <z_impl_k_sem_take>

0101744e <rpmsg_send_ns_message>:
{
 101744e:	b510      	push	{r4, lr}
	ns_msg.addr = ept->addr;
 1017450:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
 1017452:	b08c      	sub	sp, #48	; 0x30
 1017454:	4604      	mov	r4, r0
	ns_msg.flags = flags;
 1017456:	910b      	str	r1, [sp, #44]	; 0x2c
	strncpy(ns_msg.name, ept->name, sizeof(ns_msg.name));
 1017458:	2220      	movs	r2, #32
 101745a:	4601      	mov	r1, r0
 101745c:	a802      	add	r0, sp, #8
	ns_msg.addr = ept->addr;
 101745e:	930a      	str	r3, [sp, #40]	; 0x28
	strncpy(ns_msg.name, ept->name, sizeof(ns_msg.name));
 1017460:	f7ff fa95 	bl	101698e <strncpy>
	ret = rpmsg_send_offchannel_raw(ept, ept->addr,
 1017464:	2328      	movs	r3, #40	; 0x28
 1017466:	2201      	movs	r2, #1
 1017468:	4620      	mov	r0, r4
 101746a:	e9cd 3200 	strd	r3, r2, [sp]
 101746e:	6a61      	ldr	r1, [r4, #36]	; 0x24
 1017470:	2235      	movs	r2, #53	; 0x35
 1017472:	ab02      	add	r3, sp, #8
 1017474:	f7fc fa0e 	bl	1013894 <rpmsg_send_offchannel_raw>
}
 1017478:	ea00 70e0 	and.w	r0, r0, r0, asr #31
 101747c:	b00c      	add	sp, #48	; 0x30
 101747e:	bd10      	pop	{r4, pc}

01017480 <rpmsg_get_endpoint>:
{
 1017480:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1017484:	4680      	mov	r8, r0
 1017486:	4689      	mov	r9, r1
 1017488:	4615      	mov	r5, r2
 101748a:	461e      	mov	r6, r3
	metal_list_for_each(&rdev->endpoints, node) {
 101748c:	6807      	ldr	r7, [r0, #0]
 101748e:	45b8      	cmp	r8, r7
 1017490:	d101      	bne.n	1017496 <rpmsg_get_endpoint+0x16>
	return NULL;
 1017492:	2400      	movs	r4, #0
 1017494:	e021      	b.n	10174da <rpmsg_get_endpoint+0x5a>
		if (addr != RPMSG_ADDR_ANY && ept->addr == addr)
 1017496:	1c69      	adds	r1, r5, #1
		ept = metal_container_of(node, struct rpmsg_endpoint, node);
 1017498:	f1a7 0434 	sub.w	r4, r7, #52	; 0x34
		if (addr != RPMSG_ADDR_ANY && ept->addr == addr)
 101749c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 101749e:	d006      	beq.n	10174ae <rpmsg_get_endpoint+0x2e>
 10174a0:	429d      	cmp	r5, r3
		if (addr == ept->addr && dest_addr == ept->dest_addr)
 10174a2:	d01a      	beq.n	10174da <rpmsg_get_endpoint+0x5a>
		if (name)
 10174a4:	f1b9 0f00 	cmp.w	r9, #0
 10174a8:	d106      	bne.n	10174b8 <rpmsg_get_endpoint+0x38>
	metal_list_for_each(&rdev->endpoints, node) {
 10174aa:	683f      	ldr	r7, [r7, #0]
 10174ac:	e7ef      	b.n	101748e <rpmsg_get_endpoint+0xe>
		if (addr == ept->addr && dest_addr == ept->dest_addr)
 10174ae:	3301      	adds	r3, #1
 10174b0:	d1f8      	bne.n	10174a4 <rpmsg_get_endpoint+0x24>
 10174b2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 10174b4:	42b3      	cmp	r3, r6
 10174b6:	e7f4      	b.n	10174a2 <rpmsg_get_endpoint+0x22>
			name_match = !strncmp(ept->name, name,
 10174b8:	2220      	movs	r2, #32
 10174ba:	4649      	mov	r1, r9
 10174bc:	4620      	mov	r0, r4
 10174be:	f7ff fa8c 	bl	10169da <strncmp>
		if (!name || !name_match)
 10174c2:	2800      	cmp	r0, #0
 10174c4:	d1f1      	bne.n	10174aa <rpmsg_get_endpoint+0x2a>
		if (dest_addr != RPMSG_ADDR_ANY && ept->dest_addr == dest_addr)
 10174c6:	1c72      	adds	r2, r6, #1
 10174c8:	d002      	beq.n	10174d0 <rpmsg_get_endpoint+0x50>
 10174ca:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 10174cc:	42b3      	cmp	r3, r6
 10174ce:	d004      	beq.n	10174da <rpmsg_get_endpoint+0x5a>
		if (addr == RPMSG_ADDR_ANY && ept->dest_addr == RPMSG_ADDR_ANY)
 10174d0:	1c6b      	adds	r3, r5, #1
 10174d2:	d1ea      	bne.n	10174aa <rpmsg_get_endpoint+0x2a>
 10174d4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 10174d6:	3301      	adds	r3, #1
 10174d8:	d1e7      	bne.n	10174aa <rpmsg_get_endpoint+0x2a>
}
 10174da:	4620      	mov	r0, r4
 10174dc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

010174e0 <rpmsg_register_endpoint>:
	new_node->prev = node->prev;
 10174e0:	6842      	ldr	r2, [r0, #4]
	metal_list_add_tail(&rdev->endpoints, &ept->node);
 10174e2:	f101 0334 	add.w	r3, r1, #52	; 0x34
	new_node->next = node;
 10174e6:	e9c1 020d 	strd	r0, r2, [r1, #52]	; 0x34
	ept->rdev = rdev;
 10174ea:	6208      	str	r0, [r1, #32]
	new_node->next->prev = new_node;
 10174ec:	6043      	str	r3, [r0, #4]
	new_node->prev->next = new_node;
 10174ee:	6b8a      	ldr	r2, [r1, #56]	; 0x38
 10174f0:	6013      	str	r3, [r2, #0]
}
 10174f2:	4770      	bx	lr

010174f4 <rpmsg_destroy_ept>:
 *
 * @param ept - pointer to endpoint to destroy
 *
 */
void rpmsg_destroy_ept(struct rpmsg_endpoint *ept)
{
 10174f4:	b538      	push	{r3, r4, r5, lr}
	struct rpmsg_device *rdev;

	if (!ept)
 10174f6:	4604      	mov	r4, r0
 10174f8:	b1b8      	cbz	r0, 101752a <rpmsg_destroy_ept+0x36>
		return;

	rdev = ept->rdev;
	if (ept->name[0] && rdev->support_ns && ept->addr != RPMSG_NS_EPT_ADDR)
 10174fa:	7803      	ldrb	r3, [r0, #0]
	rdev = ept->rdev;
 10174fc:	6a05      	ldr	r5, [r0, #32]
	if (ept->name[0] && rdev->support_ns && ept->addr != RPMSG_NS_EPT_ADDR)
 10174fe:	b143      	cbz	r3, 1017512 <rpmsg_destroy_ept+0x1e>
 1017500:	f895 3078 	ldrb.w	r3, [r5, #120]	; 0x78
 1017504:	b12b      	cbz	r3, 1017512 <rpmsg_destroy_ept+0x1e>
 1017506:	6a43      	ldr	r3, [r0, #36]	; 0x24
 1017508:	2b35      	cmp	r3, #53	; 0x35
 101750a:	d002      	beq.n	1017512 <rpmsg_destroy_ept+0x1e>
		(void)rpmsg_send_ns_message(ept, RPMSG_NS_DESTROY);
 101750c:	2101      	movs	r1, #1
 101750e:	f7ff ff9e 	bl	101744e <rpmsg_send_ns_message>
	metal_mutex_acquire(&rdev->lock);
 1017512:	3558      	adds	r5, #88	; 0x58
 1017514:	4628      	mov	r0, r5
 1017516:	f7ff ff94 	bl	1017442 <__metal_mutex_acquire>
	rpmsg_unregister_endpoint(ept);
 101751a:	4620      	mov	r0, r4
 101751c:	f7ff ff73 	bl	1017406 <rpmsg_unregister_endpoint>
	z_impl_k_sem_give(sem);
 1017520:	4628      	mov	r0, r5
	metal_mutex_release(&rdev->lock);
}
 1017522:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 1017526:	f7fd b93f 	b.w	10147a8 <z_impl_k_sem_give>
 101752a:	bd38      	pop	{r3, r4, r5, pc}

0101752c <rpmsg_virtio_tx_callback>:
}
 101752c:	4770      	bx	lr

0101752e <k_sem_give>:
 101752e:	f7fd b93b 	b.w	10147a8 <z_impl_k_sem_give>

01017532 <rpmsg_virtio_get_rx_buffer>:
{
 1017532:	b430      	push	{r4, r5}
	return rvdev->vdev->role;
 1017534:	6fc5      	ldr	r5, [r0, #124]	; 0x7c
 1017536:	4613      	mov	r3, r2
 1017538:	69ad      	ldr	r5, [r5, #24]
	if (role == RPMSG_MASTER) {
 101753a:	b925      	cbnz	r5, 1017546 <rpmsg_virtio_get_rx_buffer+0x14>
}
 101753c:	bc30      	pop	{r4, r5}
		data = virtqueue_get_buffer(rvdev->rvq, len, idx);
 101753e:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 1017542:	f7ff be57 	b.w	10171f4 <virtqueue_get_buffer>
	if (role == RPMSG_REMOTE) {
 1017546:	2d01      	cmp	r5, #1
 1017548:	d106      	bne.n	1017558 <rpmsg_virtio_get_rx_buffer+0x26>
}
 101754a:	bc30      	pop	{r4, r5}
		    virtqueue_get_available_buffer(rvdev->rvq, idx, len);
 101754c:	460a      	mov	r2, r1
 101754e:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 1017552:	4619      	mov	r1, r3
 1017554:	f7ff be88 	b.w	1017268 <virtqueue_get_available_buffer>
}
 1017558:	2000      	movs	r0, #0
 101755a:	bc30      	pop	{r4, r5}
 101755c:	4770      	bx	lr

0101755e <__metal_mutex_acquire>:
	return z_impl_k_sem_take(sem, timeout);
 101755e:	f04f 32ff 	mov.w	r2, #4294967295
 1017562:	f04f 33ff 	mov.w	r3, #4294967295
 1017566:	f7fd b945 	b.w	10147f4 <z_impl_k_sem_take>

0101756a <rpmsg_virtio_ns_callback>:
{
 101756a:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (len != sizeof(*ns_msg))
 101756e:	2a28      	cmp	r2, #40	; 0x28
{
 1017570:	4680      	mov	r8, r0
 1017572:	460e      	mov	r6, r1
 1017574:	b089      	sub	sp, #36	; 0x24
	if (len != sizeof(*ns_msg))
 1017576:	d12b      	bne.n	10175d0 <rpmsg_virtio_ns_callback+0x66>
	struct rpmsg_device *rdev = ept->rdev;
 1017578:	6a05      	ldr	r5, [r0, #32]
	metal_io_block_read(io,
 101757a:	2320      	movs	r3, #32
	struct metal_io_region *io = rvdev->shbuf_io;
 101757c:	f8d5 0088 	ldr.w	r0, [r5, #136]	; 0x88
	metal_io_block_read(io,
 1017580:	466a      	mov	r2, sp
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
 1017582:	6801      	ldr	r1, [r0, #0]
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
 1017584:	6884      	ldr	r4, [r0, #8]
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
 1017586:	1a71      	subs	r1, r6, r1
 1017588:	42a1      	cmp	r1, r4
 101758a:	bf28      	it	cs
 101758c:	f04f 31ff 	movcs.w	r1, #4294967295
 1017590:	f7ff fcd2 	bl	1016f38 <metal_io_block_read>
	metal_mutex_acquire(&rdev->lock);
 1017594:	f105 0758 	add.w	r7, r5, #88	; 0x58
	dest = ns_msg->addr;
 1017598:	f8d6 9020 	ldr.w	r9, [r6, #32]
 101759c:	4638      	mov	r0, r7
 101759e:	f7ff ffde 	bl	101755e <__metal_mutex_acquire>
	_ept = rpmsg_get_endpoint(rdev, name, RPMSG_ADDR_ANY, dest);
 10175a2:	464b      	mov	r3, r9
 10175a4:	f04f 32ff 	mov.w	r2, #4294967295
 10175a8:	4669      	mov	r1, sp
 10175aa:	4628      	mov	r0, r5
 10175ac:	f7ff ff68 	bl	1017480 <rpmsg_get_endpoint>
	if (ns_msg->flags & RPMSG_NS_DESTROY) {
 10175b0:	6a73      	ldr	r3, [r6, #36]	; 0x24
	_ept = rpmsg_get_endpoint(rdev, name, RPMSG_ADDR_ANY, dest);
 10175b2:	4604      	mov	r4, r0
	if (ns_msg->flags & RPMSG_NS_DESTROY) {
 10175b4:	07db      	lsls	r3, r3, #31
 10175b6:	d50f      	bpl.n	10175d8 <rpmsg_virtio_ns_callback+0x6e>
		if (_ept)
 10175b8:	b110      	cbz	r0, 10175c0 <rpmsg_virtio_ns_callback+0x56>
			_ept->dest_addr = RPMSG_ADDR_ANY;
 10175ba:	f04f 33ff 	mov.w	r3, #4294967295
 10175be:	6283      	str	r3, [r0, #40]	; 0x28
 10175c0:	4638      	mov	r0, r7
 10175c2:	f7ff ffb4 	bl	101752e <k_sem_give>
		if (_ept && _ept->ns_unbind_cb)
 10175c6:	b11c      	cbz	r4, 10175d0 <rpmsg_virtio_ns_callback+0x66>
 10175c8:	6b23      	ldr	r3, [r4, #48]	; 0x30
 10175ca:	b10b      	cbz	r3, 10175d0 <rpmsg_virtio_ns_callback+0x66>
			_ept->ns_unbind_cb(ept);
 10175cc:	4640      	mov	r0, r8
 10175ce:	4798      	blx	r3
}
 10175d0:	2000      	movs	r0, #0
 10175d2:	b009      	add	sp, #36	; 0x24
 10175d4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (!_ept) {
 10175d8:	b950      	cbnz	r0, 10175f0 <rpmsg_virtio_ns_callback+0x86>
 10175da:	4638      	mov	r0, r7
 10175dc:	f7ff ffa7 	bl	101752e <k_sem_give>
			if (rdev->ns_bind_cb)
 10175e0:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 10175e2:	2b00      	cmp	r3, #0
 10175e4:	d0f4      	beq.n	10175d0 <rpmsg_virtio_ns_callback+0x66>
				rdev->ns_bind_cb(rdev, name, dest);
 10175e6:	464a      	mov	r2, r9
 10175e8:	4669      	mov	r1, sp
 10175ea:	4628      	mov	r0, r5
 10175ec:	4798      	blx	r3
 10175ee:	e7ef      	b.n	10175d0 <rpmsg_virtio_ns_callback+0x66>
			_ept->dest_addr = dest;
 10175f0:	f8c0 9028 	str.w	r9, [r0, #40]	; 0x28
 10175f4:	4638      	mov	r0, r7
 10175f6:	f7ff ff9a 	bl	101752e <k_sem_give>
 * @see metal_mutex_try_acquire, metal_mutex_acquire
 */
static inline void metal_mutex_release(metal_mutex_t *mutex)
{
	__metal_mutex_release(mutex);
}
 10175fa:	e7e9      	b.n	10175d0 <rpmsg_virtio_ns_callback+0x66>

010175fc <rpmsg_virtio_rx_callback>:
{
 10175fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct rpmsg_virtio_device *rvdev = vdev->priv;
 1017600:	6803      	ldr	r3, [r0, #0]
{
 1017602:	b086      	sub	sp, #24
	struct rpmsg_virtio_device *rvdev = vdev->priv;
 1017604:	6a5e      	ldr	r6, [r3, #36]	; 0x24
	metal_mutex_acquire(&rdev->lock);
 1017606:	f106 0758 	add.w	r7, r6, #88	; 0x58
	__metal_mutex_acquire(mutex);
 101760a:	4638      	mov	r0, r7
 101760c:	f7ff ffa7 	bl	101755e <__metal_mutex_acquire>
	rp_hdr = rpmsg_virtio_get_rx_buffer(rvdev, &len, &idx);
 1017610:	4630      	mov	r0, r6
 1017612:	f10d 020a 	add.w	r2, sp, #10
 1017616:	a903      	add	r1, sp, #12
 1017618:	f7ff ff8b 	bl	1017532 <rpmsg_virtio_get_rx_buffer>
 101761c:	4604      	mov	r4, r0
 101761e:	4638      	mov	r0, r7
 1017620:	f7ff ff85 	bl	101752e <k_sem_give>
	while (rp_hdr) {
 1017624:	b914      	cbnz	r4, 101762c <rpmsg_virtio_rx_callback+0x30>
}
 1017626:	b006      	add	sp, #24
 1017628:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 101762c:	4638      	mov	r0, r7
 101762e:	f7ff ff96 	bl	101755e <__metal_mutex_acquire>
			     struct rpmsg_endpoint *ept);

static inline struct rpmsg_endpoint *
rpmsg_get_ept_from_addr(struct rpmsg_device *rdev, uint32_t addr)
{
	return rpmsg_get_endpoint(rdev, NULL, addr, RPMSG_ADDR_ANY);
 1017632:	f04f 33ff 	mov.w	r3, #4294967295
 1017636:	2100      	movs	r1, #0
 1017638:	4630      	mov	r0, r6
 101763a:	6862      	ldr	r2, [r4, #4]
 101763c:	f7ff ff20 	bl	1017480 <rpmsg_get_endpoint>
 1017640:	4605      	mov	r5, r0
 1017642:	4638      	mov	r0, r7
 1017644:	f7ff ff73 	bl	101752e <k_sem_give>
		if (ept) {
 1017648:	b185      	cbz	r5, 101766c <rpmsg_virtio_rx_callback+0x70>
			if (ept->dest_addr == RPMSG_ADDR_ANY) {
 101764a:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 101764c:	6823      	ldr	r3, [r4, #0]
 101764e:	3201      	adds	r2, #1
			status = ept->cb(ept, RPMSG_LOCATE_DATA(rp_hdr),
 1017650:	6be9      	ldr	r1, [r5, #60]	; 0x3c
				ept->dest_addr = rp_hdr->src;
 1017652:	bf08      	it	eq
 1017654:	62ab      	streq	r3, [r5, #40]	; 0x28
			status = ept->cb(ept, RPMSG_LOCATE_DATA(rp_hdr),
 1017656:	89a2      	ldrh	r2, [r4, #12]
 1017658:	9100      	str	r1, [sp, #0]
 101765a:	4628      	mov	r0, r5
 101765c:	f8d5 802c 	ldr.w	r8, [r5, #44]	; 0x2c
 1017660:	f104 0110 	add.w	r1, r4, #16
 1017664:	47c0      	blx	r8
			RPMSG_ASSERT(status >= 0,
 1017666:	2800      	cmp	r0, #0
 1017668:	da00      	bge.n	101766c <rpmsg_virtio_rx_callback+0x70>
 101766a:	e7fe      	b.n	101766a <rpmsg_virtio_rx_callback+0x6e>
 101766c:	4638      	mov	r0, r7
 101766e:	f7ff ff76 	bl	101755e <__metal_mutex_acquire>
 1017672:	6ff2      	ldr	r2, [r6, #124]	; 0x7c
		rpmsg_virtio_return_buffer(rvdev, rp_hdr, len, idx);
 1017674:	9b03      	ldr	r3, [sp, #12]
 1017676:	6992      	ldr	r2, [r2, #24]
	if (role == RPMSG_MASTER) {
 1017678:	b9b2      	cbnz	r2, 10176a8 <rpmsg_virtio_rx_callback+0xac>
		virtqueue_add_buffer(rvdev->rvq, &vqbuf, 0, 1, buffer);
 101767a:	9400      	str	r4, [sp, #0]
		vqbuf.len = len;
 101767c:	e9cd 4304 	strd	r4, r3, [sp, #16]
		virtqueue_add_buffer(rvdev->rvq, &vqbuf, 0, 1, buffer);
 1017680:	f8d6 0080 	ldr.w	r0, [r6, #128]	; 0x80
 1017684:	2301      	movs	r3, #1
 1017686:	a904      	add	r1, sp, #16
 1017688:	f7ff fd54 	bl	1017134 <virtqueue_add_buffer>
		rp_hdr = rpmsg_virtio_get_rx_buffer(rvdev, &len, &idx);
 101768c:	4630      	mov	r0, r6
 101768e:	f10d 020a 	add.w	r2, sp, #10
 1017692:	a903      	add	r1, sp, #12
 1017694:	f7ff ff4d 	bl	1017532 <rpmsg_virtio_get_rx_buffer>
		if (!rp_hdr) {
 1017698:	4604      	mov	r4, r0
 101769a:	2800      	cmp	r0, #0
 101769c:	d1bf      	bne.n	101761e <rpmsg_virtio_rx_callback+0x22>
			virtqueue_kick(rvdev->rvq);
 101769e:	f8d6 0080 	ldr.w	r0, [r6, #128]	; 0x80
 10176a2:	f7ff fe60 	bl	1017366 <virtqueue_kick>
 10176a6:	e7ba      	b.n	101761e <rpmsg_virtio_rx_callback+0x22>
	if (role == RPMSG_REMOTE) {
 10176a8:	2a01      	cmp	r2, #1
 10176aa:	d1ef      	bne.n	101768c <rpmsg_virtio_rx_callback+0x90>
		virtqueue_add_consumed_buffer(rvdev->rvq, idx, len);
 10176ac:	461a      	mov	r2, r3
 10176ae:	f8bd 100a 	ldrh.w	r1, [sp, #10]
 10176b2:	f8d6 0080 	ldr.w	r0, [r6, #128]	; 0x80
 10176b6:	f7fc f8d1 	bl	101385c <virtqueue_add_consumed_buffer>
 10176ba:	e7e7      	b.n	101768c <rpmsg_virtio_rx_callback+0x90>

010176bc <rpmsg_virtio_shm_pool_get_buffer>:
{
 10176bc:	4603      	mov	r3, r0
	if (shpool->avail < size)
 10176be:	6842      	ldr	r2, [r0, #4]
{
 10176c0:	b510      	push	{r4, lr}
	if (shpool->avail < size)
 10176c2:	428a      	cmp	r2, r1
	buffer = (char *)shpool->base + shpool->size - shpool->avail;
 10176c4:	bf29      	itett	cs
 10176c6:	6880      	ldrcs	r0, [r0, #8]
		return NULL;
 10176c8:	2000      	movcc	r0, #0
	buffer = (char *)shpool->base + shpool->size - shpool->avail;
 10176ca:	1a84      	subcs	r4, r0, r2
 10176cc:	6818      	ldrcs	r0, [r3, #0]
	shpool->avail -= size;
 10176ce:	bf22      	ittt	cs
 10176d0:	1a52      	subcs	r2, r2, r1
	buffer = (char *)shpool->base + shpool->size - shpool->avail;
 10176d2:	1900      	addcs	r0, r0, r4
	shpool->avail -= size;
 10176d4:	605a      	strcs	r2, [r3, #4]
}
 10176d6:	bd10      	pop	{r4, pc}

010176d8 <z_sys_power_save_idle_exit>:
	z_clock_idle_exit();
 10176d8:	f7fe ba2f 	b.w	1015b3a <z_clock_idle_exit>

010176dc <k_heap_init>:
{
 10176dc:	b410      	push	{r4}
 10176de:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
 10176e2:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
 10176e6:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
 10176e8:	f7fd be77 	b.w	10153da <sys_heap_init>

010176ec <k_heap_alloc>:

SYS_INIT(statics_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

void *k_heap_alloc(struct k_heap *h, size_t bytes, k_timeout_t timeout)
{
 10176ec:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10176f0:	4604      	mov	r4, r0
 10176f2:	460e      	mov	r6, r1
	s64_t now, end = z_timeout_end_calc(timeout);
 10176f4:	4610      	mov	r0, r2
 10176f6:	4619      	mov	r1, r3
{
 10176f8:	b085      	sub	sp, #20
	s64_t now, end = z_timeout_end_calc(timeout);
 10176fa:	f000 fb6c 	bl	1017dd6 <z_timeout_end_calc>
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
 10176fe:	f104 0a14 	add.w	sl, r4, #20
	s64_t now, end = z_timeout_end_calc(timeout);
 1017702:	4605      	mov	r5, r0
 1017704:	460f      	mov	r7, r1
	__asm__ volatile(
 1017706:	f04f 0220 	mov.w	r2, #32
 101770a:	f3ef 8311 	mrs	r3, BASEPRI
 101770e:	f382 8811 	msr	BASEPRI, r2
 1017712:	f3bf 8f6f 	isb	sy
		now = z_tick_get();
		if ((ret != NULL) || ((end - now) <= 0)) {
			break;
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
 1017716:	f104 0b0c 	add.w	fp, r4, #12
		ret = sys_heap_alloc(&h->heap, bytes);
 101771a:	4631      	mov	r1, r6
 101771c:	4620      	mov	r0, r4
 101771e:	9303      	str	r3, [sp, #12]
 1017720:	f7fd fe03 	bl	101532a <sys_heap_alloc>
 1017724:	9002      	str	r0, [sp, #8]
		now = z_tick_get();
 1017726:	f7fd fac9 	bl	1014cbc <z_tick_get>
		if ((ret != NULL) || ((end - now) <= 0)) {
 101772a:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 101772e:	b13a      	cbz	r2, 1017740 <k_heap_alloc+0x54>
	__asm__ volatile(
 1017730:	f383 8811 	msr	BASEPRI, r3
 1017734:	f3bf 8f6f 	isb	sy
		key = k_spin_lock(&h->lock);
	}

	k_spin_unlock(&h->lock, key);
	return ret;
}
 1017738:	4610      	mov	r0, r2
 101773a:	b005      	add	sp, #20
 101773c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((ret != NULL) || ((end - now) <= 0)) {
 1017740:	ebb5 0800 	subs.w	r8, r5, r0
 1017744:	eb67 0901 	sbc.w	r9, r7, r1
 1017748:	f1b8 0f01 	cmp.w	r8, #1
 101774c:	f179 0100 	sbcs.w	r1, r9, #0
 1017750:	dbee      	blt.n	1017730 <k_heap_alloc+0x44>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
 1017752:	465a      	mov	r2, fp
 1017754:	4619      	mov	r1, r3
 1017756:	4650      	mov	r0, sl
 1017758:	e9cd 8900 	strd	r8, r9, [sp]
 101775c:	f7fc ff92 	bl	1014684 <z_pend_curr>
	__asm__ volatile(
 1017760:	f04f 0220 	mov.w	r2, #32
 1017764:	f3ef 8311 	mrs	r3, BASEPRI
 1017768:	f382 8811 	msr	BASEPRI, r2
 101776c:	f3bf 8f6f 	isb	sy
 1017770:	e7d3      	b.n	101771a <k_heap_alloc+0x2e>

01017772 <k_heap_free>:

void k_heap_free(struct k_heap *h, void *mem)
{
 1017772:	b538      	push	{r3, r4, r5, lr}
 1017774:	4604      	mov	r4, r0
 1017776:	f04f 0320 	mov.w	r3, #32
 101777a:	f3ef 8511 	mrs	r5, BASEPRI
 101777e:	f383 8811 	msr	BASEPRI, r3
 1017782:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
 1017786:	f7fd fd1d 	bl	10151c4 <sys_heap_free>

	if (z_unpend_all(&h->wait_q) != 0) {
 101778a:	f104 000c 	add.w	r0, r4, #12
 101778e:	f000 fa36 	bl	1017bfe <z_unpend_all>
 1017792:	b130      	cbz	r0, 10177a2 <k_heap_free+0x30>
		z_reschedule(&h->lock, key);
 1017794:	4629      	mov	r1, r5
 1017796:	f104 0014 	add.w	r0, r4, #20
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
 101779a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&h->lock, key);
 101779e:	f000 b94a 	b.w	1017a36 <z_reschedule>
	__asm__ volatile(
 10177a2:	f385 8811 	msr	BASEPRI, r5
 10177a6:	f3bf 8f6f 	isb	sy
}
 10177aa:	bd38      	pop	{r3, r4, r5, pc}

010177ac <k_mem_pool_alloc>:
 * backend.
 */

int k_mem_pool_alloc(struct k_mem_pool *p, struct k_mem_block *block,
		     size_t size, k_timeout_t timeout)
{
 10177ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 10177ae:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
 10177b2:	4614      	mov	r4, r2
	block->id.heap = p->heap;
 10177b4:	6800      	ldr	r0, [r0, #0]
{
 10177b6:	460d      	mov	r5, r1
	block->id.heap = p->heap;
 10177b8:	6048      	str	r0, [r1, #4]
	block->data = k_heap_alloc(p->heap, size, timeout);
 10177ba:	4632      	mov	r2, r6
 10177bc:	463b      	mov	r3, r7
 10177be:	4621      	mov	r1, r4
 10177c0:	f7ff ff94 	bl	10176ec <k_heap_alloc>
 10177c4:	6028      	str	r0, [r5, #0]

	/* The legacy API returns -EAGAIN on timeout expiration, but
	 * -ENOMEM if the timeout was K_NO_WAIT. Don't ask.
	 */
	if (size != 0 && block->data == NULL) {
 10177c6:	b144      	cbz	r4, 10177da <k_mem_pool_alloc+0x2e>
 10177c8:	b938      	cbnz	r0, 10177da <k_mem_pool_alloc+0x2e>
		return K_TIMEOUT_EQ(timeout, K_NO_WAIT) ? -ENOMEM : -EAGAIN;
 10177ca:	ea56 0307 	orrs.w	r3, r6, r7
 10177ce:	bf0c      	ite	eq
 10177d0:	f06f 000b 	mvneq.w	r0, #11
 10177d4:	f06f 000a 	mvnne.w	r0, #10
	} else {
		return 0;
	}
}
 10177d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return 0;
 10177da:	2000      	movs	r0, #0
 10177dc:	e7fc      	b.n	10177d8 <k_mem_pool_alloc+0x2c>

010177de <k_mem_pool_free_id>:

void k_mem_pool_free_id(struct k_mem_block_id *id)
{
	k_heap_free(id->heap, id->data);
 10177de:	e9d0 1000 	ldrd	r1, r0, [r0]
 10177e2:	f7ff bfc6 	b.w	1017772 <k_heap_free>

010177e6 <k_mem_slab_init>:
{
 10177e6:	b530      	push	{r4, r5, lr}
	slab->num_used = 0U;
 10177e8:	2400      	movs	r4, #0
 10177ea:	6184      	str	r4, [r0, #24]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
 10177ec:	ea41 0402 	orr.w	r4, r1, r2
 10177f0:	f014 0403 	ands.w	r4, r4, #3
	slab->block_size = block_size;
 10177f4:	e9c0 3202 	strd	r3, r2, [r0, #8]
	slab->buffer = buffer;
 10177f8:	6101      	str	r1, [r0, #16]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
 10177fa:	d10c      	bne.n	1017816 <k_mem_slab_init+0x30>
	slab->free_list = NULL;
 10177fc:	6144      	str	r4, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
 10177fe:	42a3      	cmp	r3, r4
 1017800:	d103      	bne.n	101780a <k_mem_slab_init+0x24>
 1017802:	e9c0 0000 	strd	r0, r0, [r0]
}
 1017806:	2000      	movs	r0, #0
}
 1017808:	bd30      	pop	{r4, r5, pc}
		*(char **)p = slab->free_list;
 101780a:	6945      	ldr	r5, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
 101780c:	3401      	adds	r4, #1
		*(char **)p = slab->free_list;
 101780e:	600d      	str	r5, [r1, #0]
		slab->free_list = p;
 1017810:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
 1017812:	4411      	add	r1, r2
	for (j = 0U; j < slab->num_blocks; j++) {
 1017814:	e7f3      	b.n	10177fe <k_mem_slab_init+0x18>
		return -EINVAL;
 1017816:	f06f 0015 	mvn.w	r0, #21
	return rc;
 101781a:	e7f5      	b.n	1017808 <k_mem_slab_init+0x22>

0101781c <k_mem_pool_malloc>:
{
 101781c:	b5df      	push	{r0, r1, r2, r3, r4, r6, r7, lr}
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
 101781e:	2408      	movs	r4, #8
 1017820:	190a      	adds	r2, r1, r4
 1017822:	d208      	bcs.n	1017836 <k_mem_pool_malloc+0x1a>
	if (k_mem_pool_alloc(pool, &block, size, K_NO_WAIT) != 0) {
 1017824:	2600      	movs	r6, #0
 1017826:	2700      	movs	r7, #0
 1017828:	eb0d 0104 	add.w	r1, sp, r4
 101782c:	e9cd 6700 	strd	r6, r7, [sp]
 1017830:	f7ff ffbc 	bl	10177ac <k_mem_pool_alloc>
 1017834:	b110      	cbz	r0, 101783c <k_mem_pool_malloc+0x20>
		return NULL;
 1017836:	2000      	movs	r0, #0
}
 1017838:	b004      	add	sp, #16
 101783a:	bdd0      	pop	{r4, r6, r7, pc}
	(void)memcpy(block.data, &block.id, sizeof(struct k_mem_block_id));
 101783c:	4622      	mov	r2, r4
 101783e:	9802      	ldr	r0, [sp, #8]
 1017840:	a902      	add	r1, sp, #8
 1017842:	f7ff f8e9 	bl	1016a18 <memcpy>
	return (char *)block.data + WB_UP(sizeof(struct k_mem_block_id));
 1017846:	9802      	ldr	r0, [sp, #8]
 1017848:	3008      	adds	r0, #8
 101784a:	e7f5      	b.n	1017838 <k_mem_pool_malloc+0x1c>

0101784c <k_free>:
	if (ptr != NULL) {
 101784c:	b110      	cbz	r0, 1017854 <k_free+0x8>
		k_mem_pool_free_id(ptr);
 101784e:	3808      	subs	r0, #8
 1017850:	f7ff bfc5 	b.w	10177de <k_mem_pool_free_id>
}
 1017854:	4770      	bx	lr

01017856 <queue_insert>:
{
 1017856:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 101785a:	4604      	mov	r4, r0
 101785c:	460d      	mov	r5, r1
 101785e:	4690      	mov	r8, r2
 1017860:	4699      	mov	r9, r3
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
 1017862:	f100 0608 	add.w	r6, r0, #8
	__asm__ volatile(
 1017866:	f04f 0320 	mov.w	r3, #32
 101786a:	f3ef 8711 	mrs	r7, BASEPRI
 101786e:	f383 8811 	msr	BASEPRI, r3
 1017872:	f3bf 8f6f 	isb	sy
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
 1017876:	4630      	mov	r0, r6
 1017878:	f000 f994 	bl	1017ba4 <z_unpend_first_thread>
	if (first_pending_thread != NULL) {
 101787c:	b158      	cbz	r0, 1017896 <queue_insert+0x40>
 101787e:	2400      	movs	r4, #0
 1017880:	f8c0 8014 	str.w	r8, [r0, #20]
 1017884:	6704      	str	r4, [r0, #112]	; 0x70
	z_ready_thread(thread);
 1017886:	f000 f91a 	bl	1017abe <z_ready_thread>
	z_reschedule(&queue->lock, key);
 101788a:	4630      	mov	r0, r6
 101788c:	4639      	mov	r1, r7
 101788e:	f000 f8d2 	bl	1017a36 <z_reschedule>
	return 0;
 1017892:	2000      	movs	r0, #0
 1017894:	e00c      	b.n	10178b0 <queue_insert+0x5a>
	if (alloc) {
 1017896:	f1b9 0f00 	cmp.w	r9, #0
 101789a:	d01b      	beq.n	10178d4 <queue_insert+0x7e>
		anode = z_thread_malloc(sizeof(*anode));
 101789c:	2008      	movs	r0, #8
 101789e:	f7fc fc37 	bl	1014110 <z_thread_malloc>
		if (anode == NULL) {
 10178a2:	b938      	cbnz	r0, 10178b4 <queue_insert+0x5e>
	__asm__ volatile(
 10178a4:	f387 8811 	msr	BASEPRI, r7
 10178a8:	f3bf 8f6f 	isb	sy
			return -ENOMEM;
 10178ac:	f06f 000b 	mvn.w	r0, #11
}
 10178b0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	node->next_and_flags = flags;
 10178b4:	2301      	movs	r3, #1
		anode->data = data;
 10178b6:	f8c0 8004 	str.w	r8, [r0, #4]
 10178ba:	6003      	str	r3, [r0, #0]
Z_GENLIST_INSERT(sflist, sfnode)
 10178bc:	6803      	ldr	r3, [r0, #0]
 10178be:	f003 0203 	and.w	r2, r3, #3
 10178c2:	b95d      	cbnz	r5, 10178dc <queue_insert+0x86>
	parent->next_and_flags = cur_flags | (unative_t)child;
 10178c4:	6823      	ldr	r3, [r4, #0]
 10178c6:	4313      	orrs	r3, r2
 10178c8:	6003      	str	r3, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
 10178ca:	6863      	ldr	r3, [r4, #4]
	list->head = node;
 10178cc:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
 10178ce:	b973      	cbnz	r3, 10178ee <queue_insert+0x98>
	list->tail = node;
 10178d0:	6060      	str	r0, [r4, #4]
}
 10178d2:	e00c      	b.n	10178ee <queue_insert+0x98>
}
 10178d4:	4640      	mov	r0, r8
	node->next_and_flags = flags;
 10178d6:	f8c8 9000 	str.w	r9, [r8]
}
 10178da:	e7ef      	b.n	10178bc <queue_insert+0x66>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
 10178dc:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_INSERT(sflist, sfnode)
 10178de:	f033 0303 	bics.w	r3, r3, #3
 10178e2:	d110      	bne.n	1017906 <queue_insert+0xb0>
	parent->next_and_flags = cur_flags | (unative_t)child;
 10178e4:	6002      	str	r2, [r0, #0]
Z_GENLIST_APPEND(sflist, sfnode)
 10178e6:	6862      	ldr	r2, [r4, #4]
 10178e8:	b93a      	cbnz	r2, 10178fa <queue_insert+0xa4>
	list->head = node;
 10178ea:	e9c4 0000 	strd	r0, r0, [r4]
	z_handle_obj_poll_events(&queue->poll_events, state);
 10178ee:	2104      	movs	r1, #4
 10178f0:	f104 0010 	add.w	r0, r4, #16
 10178f4:	f000 fbbd 	bl	1018072 <z_handle_obj_poll_events>
 10178f8:	e7c7      	b.n	101788a <queue_insert+0x34>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
 10178fa:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
 10178fc:	f003 0303 	and.w	r3, r3, #3
 1017900:	4303      	orrs	r3, r0
 1017902:	6013      	str	r3, [r2, #0]
 1017904:	e7e4      	b.n	10178d0 <queue_insert+0x7a>
 1017906:	4313      	orrs	r3, r2
 1017908:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
 101790a:	682b      	ldr	r3, [r5, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
 101790c:	f003 0303 	and.w	r3, r3, #3
 1017910:	4303      	orrs	r3, r0
 1017912:	602b      	str	r3, [r5, #0]
}
 1017914:	e7eb      	b.n	10178ee <queue_insert+0x98>

01017916 <z_queue_node_peek>:
{
 1017916:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (u8_t)0)) {
 1017918:	4604      	mov	r4, r0
 101791a:	b130      	cbz	r0, 101792a <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
 101791c:	6802      	ldr	r2, [r0, #0]
 101791e:	0793      	lsls	r3, r2, #30
 1017920:	d003      	beq.n	101792a <z_queue_node_peek+0x14>
		ret = anode->data;
 1017922:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
 1017924:	b109      	cbz	r1, 101792a <z_queue_node_peek+0x14>
			k_free(anode);
 1017926:	f7ff ff91 	bl	101784c <k_free>
}
 101792a:	4620      	mov	r0, r4
 101792c:	bd10      	pop	{r4, pc}

0101792e <z_impl_k_queue_init>:
	list->head = NULL;
 101792e:	2300      	movs	r3, #0
	list->tail = NULL;
 1017930:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dlist_init(&w->waitq);
 1017934:	f100 0308 	add.w	r3, r0, #8
 1017938:	e9c0 3302 	strd	r3, r3, [r0, #8]
	sys_dlist_init(&queue->poll_events);
 101793c:	f100 0310 	add.w	r3, r0, #16
 1017940:	e9c0 3304 	strd	r3, r3, [r0, #16]
}
 1017944:	4770      	bx	lr

01017946 <k_queue_append>:
{
 1017946:	460a      	mov	r2, r1
	(void)queue_insert(queue, sys_sflist_peek_tail(&queue->data_q),
 1017948:	2300      	movs	r3, #0
 101794a:	6841      	ldr	r1, [r0, #4]
 101794c:	f7ff bf83 	b.w	1017856 <queue_insert>

01017950 <k_queue_prepend>:
	(void)queue_insert(queue, NULL, data, false);
 1017950:	2300      	movs	r3, #0
{
 1017952:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false);
 1017954:	4619      	mov	r1, r3
 1017956:	f7ff bf7e 	b.w	1017856 <queue_insert>

0101795a <k_queue_append_list>:
{
 101795a:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 101795e:	4605      	mov	r5, r0
 1017960:	4616      	mov	r6, r2
	CHECKIF(head == NULL || tail == NULL) {
 1017962:	460c      	mov	r4, r1
 1017964:	b391      	cbz	r1, 10179cc <k_queue_append_list+0x72>
 1017966:	b38a      	cbz	r2, 10179cc <k_queue_append_list+0x72>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
 1017968:	f100 0708 	add.w	r7, r0, #8
	__asm__ volatile(
 101796c:	f04f 0320 	mov.w	r3, #32
 1017970:	f3ef 8811 	mrs	r8, BASEPRI
 1017974:	f383 8811 	msr	BASEPRI, r3
 1017978:	f3bf 8f6f 	isb	sy
		thread = z_unpend_first_thread(&queue->wait_q);
 101797c:	4638      	mov	r0, r7
 101797e:	f000 f911 	bl	1017ba4 <z_unpend_first_thread>
 1017982:	f04f 0900 	mov.w	r9, #0
	while ((head != NULL) && (thread != NULL)) {
 1017986:	b920      	cbnz	r0, 1017992 <k_queue_append_list+0x38>
Z_GENLIST_APPEND_LIST(sflist, sfnode)
 1017988:	686b      	ldr	r3, [r5, #4]
 101798a:	b9cb      	cbnz	r3, 10179c0 <k_queue_append_list+0x66>
	list->head = node;
 101798c:	602c      	str	r4, [r5, #0]
	list->tail = node;
 101798e:	606e      	str	r6, [r5, #4]
Z_GENLIST_APPEND_LIST(sflist, sfnode)
 1017990:	e00a      	b.n	10179a8 <k_queue_append_list+0x4e>
 1017992:	6144      	str	r4, [r0, #20]
 1017994:	f8c0 9070 	str.w	r9, [r0, #112]	; 0x70
	z_ready_thread(thread);
 1017998:	f000 f891 	bl	1017abe <z_ready_thread>
		head = *(void **)head;
 101799c:	6824      	ldr	r4, [r4, #0]
		thread = z_unpend_first_thread(&queue->wait_q);
 101799e:	4638      	mov	r0, r7
 10179a0:	f000 f900 	bl	1017ba4 <z_unpend_first_thread>
	while ((head != NULL) && (thread != NULL)) {
 10179a4:	2c00      	cmp	r4, #0
 10179a6:	d1ee      	bne.n	1017986 <k_queue_append_list+0x2c>
	z_handle_obj_poll_events(&queue->poll_events, state);
 10179a8:	2104      	movs	r1, #4
 10179aa:	f105 0010 	add.w	r0, r5, #16
 10179ae:	f000 fb60 	bl	1018072 <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
 10179b2:	4638      	mov	r0, r7
 10179b4:	4641      	mov	r1, r8
 10179b6:	f000 f83e 	bl	1017a36 <z_reschedule>
	return 0;
 10179ba:	2000      	movs	r0, #0
}
 10179bc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
 10179c0:	6819      	ldr	r1, [r3, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
 10179c2:	f001 0103 	and.w	r1, r1, #3
 10179c6:	430c      	orrs	r4, r1
 10179c8:	601c      	str	r4, [r3, #0]
}
 10179ca:	e7e0      	b.n	101798e <k_queue_append_list+0x34>
		return -EINVAL;
 10179cc:	f06f 0015 	mvn.w	r0, #21
 10179d0:	e7f4      	b.n	10179bc <k_queue_append_list+0x62>

010179d2 <z_is_t1_higher_prio_than_t2>:
	if (thread_1->base.prio < thread_2->base.prio) {
 10179d2:	f990 000e 	ldrsb.w	r0, [r0, #14]
 10179d6:	f991 300e 	ldrsb.w	r3, [r1, #14]
}
 10179da:	4298      	cmp	r0, r3
 10179dc:	bfac      	ite	ge
 10179de:	2000      	movge	r0, #0
 10179e0:	2001      	movlt	r0, #1
 10179e2:	4770      	bx	lr

010179e4 <z_find_first_thread_to_unpend>:
{
 10179e4:	b510      	push	{r4, lr}
 10179e6:	f04f 0320 	mov.w	r3, #32
 10179ea:	f3ef 8411 	mrs	r4, BASEPRI
 10179ee:	f383 8811 	msr	BASEPRI, r3
 10179f2:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
 10179f6:	f000 f85c 	bl	1017ab2 <z_priq_dumb_best>
	__asm__ volatile(
 10179fa:	f384 8811 	msr	BASEPRI, r4
 10179fe:	f3bf 8f6f 	isb	sy
}
 1017a02:	bd10      	pop	{r4, pc}

01017a04 <z_unpend_thread_no_timeout>:
{
 1017a04:	b538      	push	{r3, r4, r5, lr}
 1017a06:	4604      	mov	r4, r0
	__asm__ volatile(
 1017a08:	f04f 0320 	mov.w	r3, #32
 1017a0c:	f3ef 8511 	mrs	r5, BASEPRI
 1017a10:	f383 8811 	msr	BASEPRI, r3
 1017a14:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
 1017a18:	4601      	mov	r1, r0
 1017a1a:	6880      	ldr	r0, [r0, #8]
 1017a1c:	f7fc fc18 	bl	1014250 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
 1017a20:	7b63      	ldrb	r3, [r4, #13]
 1017a22:	f023 0302 	bic.w	r3, r3, #2
 1017a26:	7363      	strb	r3, [r4, #13]
		thread->base.pended_on = NULL;
 1017a28:	2300      	movs	r3, #0
 1017a2a:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
 1017a2c:	f385 8811 	msr	BASEPRI, r5
 1017a30:	f3bf 8f6f 	isb	sy
}
 1017a34:	bd38      	pop	{r3, r4, r5, pc}

01017a36 <z_reschedule>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
 1017a36:	b921      	cbnz	r1, 1017a42 <z_reschedule+0xc>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 1017a38:	f3ef 8005 	mrs	r0, IPSR
 1017a3c:	b908      	cbnz	r0, 1017a42 <z_reschedule+0xc>
 1017a3e:	f7ed b997 	b.w	1004d70 <arch_swap>
 1017a42:	f381 8811 	msr	BASEPRI, r1
 1017a46:	f3bf 8f6f 	isb	sy
}
 1017a4a:	4770      	bx	lr

01017a4c <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
 1017a4c:	4603      	mov	r3, r0
 1017a4e:	b920      	cbnz	r0, 1017a5a <z_reschedule_irqlock+0xe>
 1017a50:	f3ef 8205 	mrs	r2, IPSR
 1017a54:	b90a      	cbnz	r2, 1017a5a <z_reschedule_irqlock+0xe>
 1017a56:	f7ed b98b 	b.w	1004d70 <arch_swap>
 1017a5a:	f383 8811 	msr	BASEPRI, r3
 1017a5e:	f3bf 8f6f 	isb	sy
}
 1017a62:	4770      	bx	lr

01017a64 <z_reschedule_unlocked>:
	__asm__ volatile(
 1017a64:	f04f 0320 	mov.w	r3, #32
 1017a68:	f3ef 8011 	mrs	r0, BASEPRI
 1017a6c:	f383 8811 	msr	BASEPRI, r3
 1017a70:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
 1017a74:	f7ff bfea 	b.w	1017a4c <z_reschedule_irqlock>

01017a78 <z_unpend_thread>:
{
 1017a78:	b510      	push	{r4, lr}
 1017a7a:	4601      	mov	r1, r0
 1017a7c:	f04f 0320 	mov.w	r3, #32
 1017a80:	f3ef 8411 	mrs	r4, BASEPRI
 1017a84:	f383 8811 	msr	BASEPRI, r3
 1017a88:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
 1017a8c:	6880      	ldr	r0, [r0, #8]
 1017a8e:	f7fc fbdf 	bl	1014250 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
 1017a92:	7b4b      	ldrb	r3, [r1, #13]
 1017a94:	f023 0302 	bic.w	r3, r3, #2
 1017a98:	734b      	strb	r3, [r1, #13]
		thread->base.pended_on = NULL;
 1017a9a:	2300      	movs	r3, #0
 1017a9c:	608b      	str	r3, [r1, #8]
	__asm__ volatile(
 1017a9e:	f384 8811 	msr	BASEPRI, r4
 1017aa2:	f3bf 8f6f 	isb	sy
	return z_abort_timeout(&thread->base.timeout);
 1017aa6:	f101 0018 	add.w	r0, r1, #24
}
 1017aaa:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 1017aae:	f000 b94c 	b.w	1017d4a <z_abort_timeout>

01017ab2 <z_priq_dumb_best>:
	return list->head == list;
 1017ab2:	6803      	ldr	r3, [r0, #0]
}
 1017ab4:	4298      	cmp	r0, r3
 1017ab6:	bf14      	ite	ne
 1017ab8:	4618      	movne	r0, r3
 1017aba:	2000      	moveq	r0, #0
 1017abc:	4770      	bx	lr

01017abe <z_ready_thread>:
{
 1017abe:	b510      	push	{r4, lr}
	__asm__ volatile(
 1017ac0:	f04f 0320 	mov.w	r3, #32
 1017ac4:	f3ef 8411 	mrs	r4, BASEPRI
 1017ac8:	f383 8811 	msr	BASEPRI, r3
 1017acc:	f3bf 8f6f 	isb	sy
		ready_thread(thread);
 1017ad0:	f7fc fc14 	bl	10142fc <ready_thread>
	__asm__ volatile(
 1017ad4:	f384 8811 	msr	BASEPRI, r4
 1017ad8:	f3bf 8f6f 	isb	sy
}
 1017adc:	bd10      	pop	{r4, pc}

01017ade <z_thread_timeout>:
{
 1017ade:	b538      	push	{r3, r4, r5, lr}
	if (thread->base.pended_on != NULL) {
 1017ae0:	f850 3c10 	ldr.w	r3, [r0, #-16]
{
 1017ae4:	4604      	mov	r4, r0
	struct k_thread *thread = CONTAINER_OF(timeout,
 1017ae6:	f1a0 0118 	sub.w	r1, r0, #24
	if (thread->base.pended_on != NULL) {
 1017aea:	b1c3      	cbz	r3, 1017b1e <z_thread_timeout+0x40>
	__asm__ volatile(
 1017aec:	f04f 0320 	mov.w	r3, #32
 1017af0:	f3ef 8511 	mrs	r5, BASEPRI
 1017af4:	f383 8811 	msr	BASEPRI, r3
 1017af8:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
 1017afc:	f850 0c10 	ldr.w	r0, [r0, #-16]
 1017b00:	f7fc fba6 	bl	1014250 <z_priq_dumb_remove>
 1017b04:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
 1017b08:	f023 0302 	bic.w	r3, r3, #2
 1017b0c:	f804 3c0b 	strb.w	r3, [r4, #-11]
		thread->base.pended_on = NULL;
 1017b10:	2300      	movs	r3, #0
 1017b12:	f844 3c10 	str.w	r3, [r4, #-16]
	__asm__ volatile(
 1017b16:	f385 8811 	msr	BASEPRI, r5
 1017b1a:	f3bf 8f6f 	isb	sy
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 1017b1e:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
	z_ready_thread(thread);
 1017b22:	4608      	mov	r0, r1
 1017b24:	f023 0314 	bic.w	r3, r3, #20
 1017b28:	f804 3c0b 	strb.w	r3, [r4, #-11]
}
 1017b2c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_ready_thread(thread);
 1017b30:	f7ff bfc5 	b.w	1017abe <z_ready_thread>

01017b34 <z_remove_thread_from_ready_q>:
{
 1017b34:	b510      	push	{r4, lr}
	__asm__ volatile(
 1017b36:	f04f 0320 	mov.w	r3, #32
 1017b3a:	f3ef 8411 	mrs	r4, BASEPRI
 1017b3e:	f383 8811 	msr	BASEPRI, r3
 1017b42:	f3bf 8f6f 	isb	sy
		unready_thread(thread);
 1017b46:	f7fc fd2f 	bl	10145a8 <unready_thread>
	__asm__ volatile(
 1017b4a:	f384 8811 	msr	BASEPRI, r4
 1017b4e:	f3bf 8f6f 	isb	sy
}
 1017b52:	bd10      	pop	{r4, pc}

01017b54 <add_to_waitq_locked>:
{
 1017b54:	b538      	push	{r3, r4, r5, lr}
 1017b56:	4604      	mov	r4, r0
 1017b58:	460d      	mov	r5, r1
	unready_thread(thread);
 1017b5a:	f7fc fd25 	bl	10145a8 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
 1017b5e:	7b63      	ldrb	r3, [r4, #13]
 1017b60:	f043 0302 	orr.w	r3, r3, #2
 1017b64:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
 1017b66:	b17d      	cbz	r5, 1017b88 <add_to_waitq_locked+0x34>
 1017b68:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
 1017b6a:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1017b6c:	429d      	cmp	r5, r3
 1017b6e:	d012      	beq.n	1017b96 <add_to_waitq_locked+0x42>
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 1017b70:	b18b      	cbz	r3, 1017b96 <add_to_waitq_locked+0x42>
	if (thread_1->base.prio < thread_2->base.prio) {
 1017b72:	f994 200e 	ldrsb.w	r2, [r4, #14]
 1017b76:	f993 100e 	ldrsb.w	r1, [r3, #14]
 1017b7a:	4291      	cmp	r1, r2
 1017b7c:	dd05      	ble.n	1017b8a <add_to_waitq_locked+0x36>
	node->prev = successor->prev;
 1017b7e:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
 1017b80:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
 1017b84:	6014      	str	r4, [r2, #0]
	successor->prev = node;
 1017b86:	605c      	str	r4, [r3, #4]
}
 1017b88:	bd38      	pop	{r3, r4, r5, pc}
	return (node == list->tail) ? NULL : node->next;
 1017b8a:	6869      	ldr	r1, [r5, #4]
 1017b8c:	428b      	cmp	r3, r1
 1017b8e:	d002      	beq.n	1017b96 <add_to_waitq_locked+0x42>
 1017b90:	681b      	ldr	r3, [r3, #0]
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 1017b92:	2b00      	cmp	r3, #0
 1017b94:	d1ef      	bne.n	1017b76 <add_to_waitq_locked+0x22>
	node->prev = list->tail;
 1017b96:	686b      	ldr	r3, [r5, #4]
	node->next = list;
 1017b98:	6025      	str	r5, [r4, #0]
	node->prev = list->tail;
 1017b9a:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
 1017b9c:	686b      	ldr	r3, [r5, #4]
 1017b9e:	601c      	str	r4, [r3, #0]
	list->tail = node;
 1017ba0:	606c      	str	r4, [r5, #4]
}
 1017ba2:	e7f1      	b.n	1017b88 <add_to_waitq_locked+0x34>

01017ba4 <z_unpend_first_thread>:
{
 1017ba4:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
 1017ba6:	f04f 0320 	mov.w	r3, #32
 1017baa:	f3ef 8211 	mrs	r2, BASEPRI
 1017bae:	f383 8811 	msr	BASEPRI, r3
 1017bb2:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
 1017bb6:	f7ff ff7c 	bl	1017ab2 <z_priq_dumb_best>
 1017bba:	4604      	mov	r4, r0
	__asm__ volatile(
 1017bbc:	f382 8811 	msr	BASEPRI, r2
 1017bc0:	f3bf 8f6f 	isb	sy

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
 1017bc4:	b1c8      	cbz	r0, 1017bfa <z_unpend_first_thread+0x56>
	__asm__ volatile(
 1017bc6:	f04f 0320 	mov.w	r3, #32
 1017bca:	f3ef 8511 	mrs	r5, BASEPRI
 1017bce:	f383 8811 	msr	BASEPRI, r3
 1017bd2:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
 1017bd6:	4601      	mov	r1, r0
 1017bd8:	6880      	ldr	r0, [r0, #8]
 1017bda:	f7fc fb39 	bl	1014250 <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
 1017bde:	7b63      	ldrb	r3, [r4, #13]
 1017be0:	f023 0302 	bic.w	r3, r3, #2
 1017be4:	7363      	strb	r3, [r4, #13]
		thread->base.pended_on = NULL;
 1017be6:	2300      	movs	r3, #0
 1017be8:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
 1017bea:	f385 8811 	msr	BASEPRI, r5
 1017bee:	f3bf 8f6f 	isb	sy
 1017bf2:	f104 0018 	add.w	r0, r4, #24
 1017bf6:	f000 f8a8 	bl	1017d4a <z_abort_timeout>
}
 1017bfa:	4620      	mov	r0, r4
 1017bfc:	bd38      	pop	{r3, r4, r5, pc}

01017bfe <z_unpend_all>:
{
 1017bfe:	b538      	push	{r3, r4, r5, lr}
 1017c00:	4605      	mov	r5, r0
	int need_sched = 0;
 1017c02:	2000      	movs	r0, #0
	return list->head == list;
 1017c04:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1017c06:	42a5      	cmp	r5, r4
 1017c08:	d000      	beq.n	1017c0c <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
 1017c0a:	b904      	cbnz	r4, 1017c0e <z_unpend_all+0x10>
}
 1017c0c:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
 1017c0e:	4620      	mov	r0, r4
 1017c10:	f7ff ff32 	bl	1017a78 <z_unpend_thread>
		z_ready_thread(thread);
 1017c14:	4620      	mov	r0, r4
 1017c16:	f7ff ff52 	bl	1017abe <z_ready_thread>
		need_sched = 1;
 1017c1a:	2001      	movs	r0, #1
 1017c1c:	e7f2      	b.n	1017c04 <z_unpend_all+0x6>

01017c1e <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || initial_count > limit) {
 1017c1e:	b15a      	cbz	r2, 1017c38 <z_impl_k_sem_init+0x1a>
 1017c20:	428a      	cmp	r2, r1
 1017c22:	d309      	bcc.n	1017c38 <z_impl_k_sem_init+0x1a>
	sys_dlist_init(&sem->poll_events);
 1017c24:	f100 0310 	add.w	r3, r0, #16
	sem->limit = limit;
 1017c28:	e9c0 1202 	strd	r1, r2, [r0, #8]
	list->tail = (sys_dnode_t *)list;
 1017c2c:	e9c0 0000 	strd	r0, r0, [r0]
 1017c30:	e9c0 3304 	strd	r3, r3, [r0, #16]
	return 0;
 1017c34:	2000      	movs	r0, #0
 1017c36:	4770      	bx	lr
		return -EINVAL;
 1017c38:	f06f 0015 	mvn.w	r0, #21
}
 1017c3c:	4770      	bx	lr

01017c3e <k_is_in_isr>:
 1017c3e:	f3ef 8005 	mrs	r0, IPSR
}
 1017c42:	3800      	subs	r0, #0
 1017c44:	bf18      	it	ne
 1017c46:	2001      	movne	r0, #1
 1017c48:	4770      	bx	lr

01017c4a <z_impl_k_busy_wait>:
	arch_busy_wait(usec_to_wait);
 1017c4a:	f7ec b8b7 	b.w	1003dbc <arch_busy_wait>

01017c4e <z_impl_k_thread_name_set>:
}
 1017c4e:	f06f 0046 	mvn.w	r0, #70	; 0x46
 1017c52:	4770      	bx	lr

01017c54 <k_thread_name_get>:
}
 1017c54:	2000      	movs	r0, #0
 1017c56:	4770      	bx	lr

01017c58 <k_work_submit_to_queue>:
{
 1017c58:	b500      	push	{lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 1017c5a:	f101 0308 	add.w	r3, r1, #8
 1017c5e:	e8d3 2fef 	ldaex	r2, [r3]
 1017c62:	f042 0c01 	orr.w	ip, r2, #1
 1017c66:	e8c3 cfee 	stlex	lr, ip, [r3]
 1017c6a:	f1be 0f00 	cmp.w	lr, #0
 1017c6e:	d1f6      	bne.n	1017c5e <k_work_submit_to_queue+0x6>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
 1017c70:	07d3      	lsls	r3, r2, #31
 1017c72:	d403      	bmi.n	1017c7c <k_work_submit_to_queue+0x24>
}
 1017c74:	f85d eb04 	ldr.w	lr, [sp], #4
		k_queue_append(&work_q->queue, work);
 1017c78:	f7ff be65 	b.w	1017946 <k_queue_append>
}
 1017c7c:	f85d fb04 	ldr.w	pc, [sp], #4

01017c80 <work_timeout>:
	k_work_submit_to_queue(w->work_q, &w->work);
 1017c80:	f1a0 010c 	sub.w	r1, r0, #12
 1017c84:	6900      	ldr	r0, [r0, #16]
 1017c86:	f7ff bfe7 	b.w	1017c58 <k_work_submit_to_queue>

01017c8a <work_cancel>:
	CHECKIF(work->work_q == NULL) {
 1017c8a:	69c3      	ldr	r3, [r0, #28]
{
 1017c8c:	b570      	push	{r4, r5, r6, lr}
 1017c8e:	4604      	mov	r4, r0
	CHECKIF(work->work_q == NULL) {
 1017c90:	b913      	cbnz	r3, 1017c98 <work_cancel+0xe>
		return -EALREADY;
 1017c92:	f06f 0044 	mvn.w	r0, #68	; 0x44
}
 1017c96:	bd70      	pop	{r4, r5, r6, pc}
	return atomic_test_bit(work->flags, K_WORK_STATE_PENDING);
 1017c98:	f100 0508 	add.w	r5, r0, #8
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 1017c9c:	e8d5 3faf 	lda	r3, [r5]
	if (k_work_pending(&work->work)) {
 1017ca0:	07db      	lsls	r3, r3, #31
 1017ca2:	d52f      	bpl.n	1017d04 <work_cancel+0x7a>
 * @return true if node was removed
 */
static inline bool sys_sflist_find_and_remove(sys_sflist_t *list,
					      sys_sfnode_t *node);

Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
 1017ca4:	2100      	movs	r1, #0
		if (!k_queue_remove(&work->work_q->queue, &work->work)) {
 1017ca6:	69c2      	ldr	r2, [r0, #28]
 1017ca8:	6813      	ldr	r3, [r2, #0]
 1017caa:	b913      	cbnz	r3, 1017cb2 <work_cancel+0x28>
			return -EINVAL;
 1017cac:	f06f 0015 	mvn.w	r0, #21
 1017cb0:	e7f1      	b.n	1017c96 <work_cancel+0xc>
 1017cb2:	429c      	cmp	r4, r3
 1017cb4:	d121      	bne.n	1017cfa <work_cancel+0x70>
Z_GENLIST_REMOVE(sflist, sfnode)
 1017cb6:	6823      	ldr	r3, [r4, #0]
 1017cb8:	6856      	ldr	r6, [r2, #4]
 1017cba:	f023 0003 	bic.w	r0, r3, #3
 1017cbe:	b991      	cbnz	r1, 1017ce6 <work_cancel+0x5c>
 1017cc0:	42b4      	cmp	r4, r6
	list->head = node;
 1017cc2:	6010      	str	r0, [r2, #0]
Z_GENLIST_REMOVE(sflist, sfnode)
 1017cc4:	d100      	bne.n	1017cc8 <work_cancel+0x3e>
	list->tail = node;
 1017cc6:	6050      	str	r0, [r2, #4]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
 1017cc8:	6823      	ldr	r3, [r4, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
 1017cca:	f003 0303 	and.w	r3, r3, #3
 1017cce:	6023      	str	r3, [r4, #0]
	work->work_q = NULL;
 1017cd0:	2000      	movs	r0, #0
 1017cd2:	61e0      	str	r0, [r4, #28]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 1017cd4:	e8d5 3fef 	ldaex	r3, [r5]
 1017cd8:	f023 0301 	bic.w	r3, r3, #1
 1017cdc:	e8c5 3fe2 	stlex	r2, r3, [r5]
 1017ce0:	2a00      	cmp	r2, #0
 1017ce2:	d0d8      	beq.n	1017c96 <work_cancel+0xc>
 1017ce4:	e7f6      	b.n	1017cd4 <work_cancel+0x4a>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
 1017ce6:	680b      	ldr	r3, [r1, #0]
Z_GENLIST_REMOVE(sflist, sfnode)
 1017ce8:	42b4      	cmp	r4, r6
	parent->next_and_flags = cur_flags | (unative_t)child;
 1017cea:	f003 0303 	and.w	r3, r3, #3
 1017cee:	ea43 0300 	orr.w	r3, r3, r0
 1017cf2:	600b      	str	r3, [r1, #0]
	list->tail = node;
 1017cf4:	bf08      	it	eq
 1017cf6:	6051      	streq	r1, [r2, #4]
}
 1017cf8:	e7e6      	b.n	1017cc8 <work_cancel+0x3e>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
 1017cfa:	6818      	ldr	r0, [r3, #0]
 1017cfc:	4619      	mov	r1, r3
Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
 1017cfe:	f020 0303 	bic.w	r3, r0, #3
 1017d02:	e7d2      	b.n	1017caa <work_cancel+0x20>
		int err = z_abort_timeout(&work->timeout);
 1017d04:	300c      	adds	r0, #12
 1017d06:	f000 f820 	bl	1017d4a <z_abort_timeout>
		if (err) {
 1017d0a:	2800      	cmp	r0, #0
 1017d0c:	d0e0      	beq.n	1017cd0 <work_cancel+0x46>
 1017d0e:	e7c0      	b.n	1017c92 <work_cancel+0x8>

01017d10 <k_delayed_work_init>:
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
 1017d10:	2300      	movs	r3, #0
 1017d12:	e9c0 3100 	strd	r3, r1, [r0]
	node->next = NULL;
 1017d16:	e9c0 3302 	strd	r3, r3, [r0, #8]
	node->prev = NULL;
 1017d1a:	6103      	str	r3, [r0, #16]
	work->work_q = NULL;
 1017d1c:	61c3      	str	r3, [r0, #28]
}
 1017d1e:	4770      	bx	lr

01017d20 <k_delayed_work_cancel>:

int k_delayed_work_cancel(struct k_delayed_work *work)
{
	if (!work->work_q) {
 1017d20:	69c3      	ldr	r3, [r0, #28]
{
 1017d22:	b510      	push	{r4, lr}
	if (!work->work_q) {
 1017d24:	b173      	cbz	r3, 1017d44 <k_delayed_work_cancel+0x24>
	__asm__ volatile(
 1017d26:	f04f 0320 	mov.w	r3, #32
 1017d2a:	f3ef 8411 	mrs	r4, BASEPRI
 1017d2e:	f383 8811 	msr	BASEPRI, r3
 1017d32:	f3bf 8f6f 	isb	sy
		return -EINVAL;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	int ret = work_cancel(work);
 1017d36:	f7ff ffa8 	bl	1017c8a <work_cancel>
	__asm__ volatile(
 1017d3a:	f384 8811 	msr	BASEPRI, r4
 1017d3e:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
 1017d42:	bd10      	pop	{r4, pc}
		return -EINVAL;
 1017d44:	f06f 0015 	mvn.w	r0, #21
 1017d48:	e7fb      	b.n	1017d42 <k_delayed_work_cancel+0x22>

01017d4a <z_abort_timeout>:
{
 1017d4a:	b510      	push	{r4, lr}
	__asm__ volatile(
 1017d4c:	f04f 0220 	mov.w	r2, #32
 1017d50:	f3ef 8411 	mrs	r4, BASEPRI
 1017d54:	f382 8811 	msr	BASEPRI, r2
 1017d58:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
 1017d5c:	6803      	ldr	r3, [r0, #0]
 1017d5e:	b13b      	cbz	r3, 1017d70 <z_abort_timeout+0x26>
			remove_timeout(to);
 1017d60:	f7fc feae 	bl	1014ac0 <remove_timeout>
			ret = 0;
 1017d64:	2000      	movs	r0, #0
	__asm__ volatile(
 1017d66:	f384 8811 	msr	BASEPRI, r4
 1017d6a:	f3bf 8f6f 	isb	sy
}
 1017d6e:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
 1017d70:	f06f 0015 	mvn.w	r0, #21
 1017d74:	e7f7      	b.n	1017d66 <z_abort_timeout+0x1c>

01017d76 <z_get_next_timeout_expiry>:
{
 1017d76:	b510      	push	{r4, lr}
	__asm__ volatile(
 1017d78:	f04f 0320 	mov.w	r3, #32
 1017d7c:	f3ef 8411 	mrs	r4, BASEPRI
 1017d80:	f383 8811 	msr	BASEPRI, r3
 1017d84:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
 1017d88:	f7fc feae 	bl	1014ae8 <next_timeout>
	__asm__ volatile(
 1017d8c:	f384 8811 	msr	BASEPRI, r4
 1017d90:	f3bf 8f6f 	isb	sy
}
 1017d94:	bd10      	pop	{r4, pc}

01017d96 <z_set_timeout_expiry>:
{
 1017d96:	b570      	push	{r4, r5, r6, lr}
 1017d98:	4604      	mov	r4, r0
 1017d9a:	460d      	mov	r5, r1
	__asm__ volatile(
 1017d9c:	f04f 0320 	mov.w	r3, #32
 1017da0:	f3ef 8611 	mrs	r6, BASEPRI
 1017da4:	f383 8811 	msr	BASEPRI, r3
 1017da8:	f3bf 8f6f 	isb	sy
		int next = next_timeout();
 1017dac:	f7fc fe9c 	bl	1014ae8 <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
 1017db0:	2801      	cmp	r0, #1
 1017db2:	dd05      	ble.n	1017dc0 <z_set_timeout_expiry+0x2a>
 1017db4:	42a0      	cmp	r0, r4
 1017db6:	dd03      	ble.n	1017dc0 <z_set_timeout_expiry+0x2a>
			z_clock_set_timeout(ticks, idle);
 1017db8:	4629      	mov	r1, r5
 1017dba:	4620      	mov	r0, r4
 1017dbc:	f7ec fe6a 	bl	1004a94 <z_clock_set_timeout>
	__asm__ volatile(
 1017dc0:	f386 8811 	msr	BASEPRI, r6
 1017dc4:	f3bf 8f6f 	isb	sy
}
 1017dc8:	bd70      	pop	{r4, r5, r6, pc}

01017dca <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
 1017dca:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
 1017dcc:	f7fc ff76 	bl	1014cbc <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
 1017dd0:	bd08      	pop	{r3, pc}

01017dd2 <z_impl_k_uptime_ticks>:

s64_t z_impl_k_uptime_ticks(void)
{
	return z_tick_get();
 1017dd2:	f7fc bf73 	b.w	1014cbc <z_tick_get>

01017dd6 <z_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
u64_t z_timeout_end_calc(k_timeout_t timeout)
{
 1017dd6:	b538      	push	{r3, r4, r5, lr}
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 1017dd8:	1c4b      	adds	r3, r1, #1
 1017dda:	bf08      	it	eq
 1017ddc:	f1b0 3fff 	cmpeq.w	r0, #4294967295
{
 1017de0:	4604      	mov	r4, r0
 1017de2:	460d      	mov	r5, r1
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 1017de4:	d013      	beq.n	1017e0e <z_timeout_end_calc+0x38>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 1017de6:	ea54 0105 	orrs.w	r1, r4, r5
 1017dea:	d103      	bne.n	1017df4 <z_timeout_end_calc+0x1e>
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
		return Z_TICK_ABS(dt);
	}
#endif
	return z_tick_get() + MAX(1, dt);
}
 1017dec:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return z_tick_get();
 1017df0:	f7fc bf64 	b.w	1014cbc <z_tick_get>
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
 1017df4:	f06f 0101 	mvn.w	r1, #1
 1017df8:	1a0a      	subs	r2, r1, r0
 1017dfa:	f04f 31ff 	mov.w	r1, #4294967295
 1017dfe:	eb61 0305 	sbc.w	r3, r1, r5
 1017e02:	2a00      	cmp	r2, #0
 1017e04:	f173 0100 	sbcs.w	r1, r3, #0
 1017e08:	db02      	blt.n	1017e10 <z_timeout_end_calc+0x3a>
		return Z_TICK_ABS(dt);
 1017e0a:	4610      	mov	r0, r2
 1017e0c:	4619      	mov	r1, r3
}
 1017e0e:	bd38      	pop	{r3, r4, r5, pc}
	return z_tick_get() + MAX(1, dt);
 1017e10:	f7fc ff54 	bl	1014cbc <z_tick_get>
 1017e14:	2c01      	cmp	r4, #1
 1017e16:	f175 0300 	sbcs.w	r3, r5, #0
 1017e1a:	bfbc      	itt	lt
 1017e1c:	2401      	movlt	r4, #1
 1017e1e:	2500      	movlt	r5, #0
 1017e20:	1820      	adds	r0, r4, r0
 1017e22:	eb45 0101 	adc.w	r1, r5, r1
 1017e26:	e7f2      	b.n	1017e0e <z_timeout_end_calc+0x38>

01017e28 <k_timer_init>:
	timer->status = 0U;
 1017e28:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
 1017e2a:	e9c0 1206 	strd	r1, r2, [r0, #24]
 1017e2e:	f100 0210 	add.w	r2, r0, #16
	list->tail = (sys_dnode_t *)list;
 1017e32:	e9c0 2204 	strd	r2, r2, [r0, #16]
	node->prev = NULL;
 1017e36:	e9c0 3300 	strd	r3, r3, [r0]
	timer->status = 0U;
 1017e3a:	6283      	str	r3, [r0, #40]	; 0x28
	timer->user_data = NULL;
 1017e3c:	62c3      	str	r3, [r0, #44]	; 0x2c
}
 1017e3e:	4770      	bx	lr

01017e40 <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
 1017e40:	b510      	push	{r4, lr}
 1017e42:	4604      	mov	r4, r0
	int inactive = z_abort_timeout(&timer->timeout) != 0;
 1017e44:	f7ff ff81 	bl	1017d4a <z_abort_timeout>

	if (inactive) {
 1017e48:	b9d8      	cbnz	r0, 1017e82 <z_impl_k_timer_stop+0x42>
		return;
	}

	if (timer->stop_fn != NULL) {
 1017e4a:	69e3      	ldr	r3, [r4, #28]
 1017e4c:	b10b      	cbz	r3, 1017e52 <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
 1017e4e:	4620      	mov	r0, r4
 1017e50:	4798      	blx	r3
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
 1017e52:	f104 0010 	add.w	r0, r4, #16
 1017e56:	2100      	movs	r1, #0
 1017e58:	f7ff fdc4 	bl	10179e4 <z_find_first_thread_to_unpend>
	if (thread != NULL) {
 1017e5c:	4604      	mov	r4, r0
 1017e5e:	b180      	cbz	r0, 1017e82 <z_impl_k_timer_stop+0x42>
		z_unpend_thread_no_timeout(thread);
 1017e60:	f7ff fdd0 	bl	1017a04 <z_unpend_thread_no_timeout>
	}

	struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);

	if (pending_thread != NULL) {
		z_ready_thread(pending_thread);
 1017e64:	4620      	mov	r0, r4
 1017e66:	f7ff fe2a 	bl	1017abe <z_ready_thread>
	__asm__ volatile(
 1017e6a:	f04f 0320 	mov.w	r3, #32
 1017e6e:	f3ef 8011 	mrs	r0, BASEPRI
 1017e72:	f383 8811 	msr	BASEPRI, r3
 1017e76:	f3bf 8f6f 	isb	sy
		z_reschedule_unlocked();
	}
}
 1017e7a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
 1017e7e:	f7ff bde5 	b.w	1017a4c <z_reschedule_irqlock>
 1017e82:	bd10      	pop	{r4, pc}

01017e84 <clear_event_registrations>:
	while (num_events--) {
 1017e84:	2314      	movs	r3, #20
{
 1017e86:	b530      	push	{r4, r5, lr}
	event->poller = NULL;
 1017e88:	2400      	movs	r4, #0
 1017e8a:	fb03 0101 	mla	r1, r3, r1, r0
	while (num_events--) {
 1017e8e:	4281      	cmp	r1, r0
 1017e90:	d100      	bne.n	1017e94 <clear_event_registrations+0x10>
}
 1017e92:	bd30      	pop	{r4, r5, pc}
	switch (event->type) {
 1017e94:	f811 3c07 	ldrb.w	r3, [r1, #-7]
	event->poller = NULL;
 1017e98:	f841 4c0c 	str.w	r4, [r1, #-12]
	switch (event->type) {
 1017e9c:	f003 030f 	and.w	r3, r3, #15
 1017ea0:	2b02      	cmp	r3, #2
 1017ea2:	d80a      	bhi.n	1017eba <clear_event_registrations+0x36>
 1017ea4:	b15b      	cbz	r3, 1017ebe <clear_event_registrations+0x3a>
	if (remove && sys_dnode_is_linked(&event->_node)) {
 1017ea6:	f851 3c14 	ldr.w	r3, [r1, #-20]
 1017eaa:	b143      	cbz	r3, 1017ebe <clear_event_registrations+0x3a>
	node->prev->next = node->next;
 1017eac:	f851 5c10 	ldr.w	r5, [r1, #-16]
 1017eb0:	602b      	str	r3, [r5, #0]
	node->next->prev = node->prev;
 1017eb2:	605d      	str	r5, [r3, #4]
	node->prev = NULL;
 1017eb4:	e941 4405 	strd	r4, r4, [r1, #-20]
}
 1017eb8:	e001      	b.n	1017ebe <clear_event_registrations+0x3a>
	switch (event->type) {
 1017eba:	2b04      	cmp	r3, #4
 1017ebc:	d0f3      	beq.n	1017ea6 <clear_event_registrations+0x22>
	__asm__ volatile(
 1017ebe:	f382 8811 	msr	BASEPRI, r2
 1017ec2:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
 1017ec6:	f04f 0320 	mov.w	r3, #32
 1017eca:	f3ef 8211 	mrs	r2, BASEPRI
 1017ece:	f383 8811 	msr	BASEPRI, r3
 1017ed2:	f3bf 8f6f 	isb	sy
 1017ed6:	3914      	subs	r1, #20
 1017ed8:	e7d9      	b.n	1017e8e <clear_event_registrations+0xa>

01017eda <signal_poll_event>:
{
 1017eda:	b570      	push	{r4, r5, r6, lr}
	struct _poller *poller = event->poller;
 1017edc:	6884      	ldr	r4, [r0, #8]
{
 1017ede:	4605      	mov	r5, r0
 1017ee0:	460e      	mov	r6, r1
	if (poller) {
 1017ee2:	b19c      	cbz	r4, 1017f0c <signal_poll_event+0x32>
		if (poller->cb != NULL) {
 1017ee4:	68a3      	ldr	r3, [r4, #8]
 1017ee6:	b95b      	cbnz	r3, 1017f00 <signal_poll_event+0x26>
	int retcode = 0;
 1017ee8:	4618      	mov	r0, r3
		poller->is_polling = false;
 1017eea:	7023      	strb	r3, [r4, #0]
	event->poller = NULL;
 1017eec:	2300      	movs	r3, #0
 1017eee:	60ab      	str	r3, [r5, #8]
	event->state |= state;
 1017ef0:	68eb      	ldr	r3, [r5, #12]
 1017ef2:	f3c3 3104 	ubfx	r1, r3, #12, #5
 1017ef6:	430e      	orrs	r6, r1
 1017ef8:	f366 3310 	bfi	r3, r6, #12, #5
 1017efc:	60eb      	str	r3, [r5, #12]
	return retcode;
 1017efe:	e004      	b.n	1017f0a <signal_poll_event+0x30>
			retcode = poller->cb(event, state);
 1017f00:	4798      	blx	r3
		poller->is_polling = false;
 1017f02:	2300      	movs	r3, #0
		if (retcode < 0) {
 1017f04:	2800      	cmp	r0, #0
		poller->is_polling = false;
 1017f06:	7023      	strb	r3, [r4, #0]
		if (retcode < 0) {
 1017f08:	daf0      	bge.n	1017eec <signal_poll_event+0x12>
}
 1017f0a:	bd70      	pop	{r4, r5, r6, pc}
	int retcode = 0;
 1017f0c:	4620      	mov	r0, r4
 1017f0e:	e7ed      	b.n	1017eec <signal_poll_event+0x12>

01017f10 <k_poll_poller_cb>:
{
 1017f10:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = event->poller->thread;
 1017f12:	6883      	ldr	r3, [r0, #8]
{
 1017f14:	460d      	mov	r5, r1
	struct k_thread *thread = event->poller->thread;
 1017f16:	685c      	ldr	r4, [r3, #4]
	if (!z_is_thread_pending(thread)) {
 1017f18:	7b63      	ldrb	r3, [r4, #13]
 1017f1a:	079a      	lsls	r2, r3, #30
 1017f1c:	d50e      	bpl.n	1017f3c <k_poll_poller_cb+0x2c>
	if (z_is_thread_timeout_expired(thread)) {
 1017f1e:	6a23      	ldr	r3, [r4, #32]
 1017f20:	3302      	adds	r3, #2
 1017f22:	d014      	beq.n	1017f4e <k_poll_poller_cb+0x3e>
	z_unpend_thread(thread);
 1017f24:	4620      	mov	r0, r4
 1017f26:	f7ff fda7 	bl	1017a78 <z_unpend_thread>
	arch_thread_return_value_set(thread,
 1017f2a:	2d08      	cmp	r5, #8
 1017f2c:	bf0c      	ite	eq
 1017f2e:	f06f 0303 	mvneq.w	r3, #3
 1017f32:	2300      	movne	r3, #0
 1017f34:	6723      	str	r3, [r4, #112]	; 0x70
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
 1017f36:	7b63      	ldrb	r3, [r4, #13]
 1017f38:	06db      	lsls	r3, r3, #27
 1017f3a:	d001      	beq.n	1017f40 <k_poll_poller_cb+0x30>
		return 0;
 1017f3c:	2000      	movs	r0, #0
}
 1017f3e:	bd38      	pop	{r3, r4, r5, pc}
	if (!z_is_thread_ready(thread)) {
 1017f40:	69a5      	ldr	r5, [r4, #24]
 1017f42:	2d00      	cmp	r5, #0
 1017f44:	d1fa      	bne.n	1017f3c <k_poll_poller_cb+0x2c>
	z_ready_thread(thread);
 1017f46:	4620      	mov	r0, r4
 1017f48:	f7ff fdb9 	bl	1017abe <z_ready_thread>
	return 0;
 1017f4c:	e7f6      	b.n	1017f3c <k_poll_poller_cb+0x2c>
		return -EAGAIN;
 1017f4e:	f06f 000a 	mvn.w	r0, #10
 1017f52:	e7f4      	b.n	1017f3e <k_poll_poller_cb+0x2e>

01017f54 <add_event>:
{
 1017f54:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1017f56:	4617      	mov	r7, r2
	return sys_dlist_is_empty(list) ? NULL : list->tail;
 1017f58:	e9d0 2300 	ldrd	r2, r3, [r0]
 1017f5c:	4290      	cmp	r0, r2
 1017f5e:	4604      	mov	r4, r0
 1017f60:	460d      	mov	r5, r1
 1017f62:	d106      	bne.n	1017f72 <add_event+0x1e>
	node->prev = list->tail;
 1017f64:	6863      	ldr	r3, [r4, #4]
	node->next = list;
 1017f66:	602c      	str	r4, [r5, #0]
	node->prev = list->tail;
 1017f68:	606b      	str	r3, [r5, #4]
	list->tail->next = node;
 1017f6a:	6863      	ldr	r3, [r4, #4]
 1017f6c:	601d      	str	r5, [r3, #0]
	list->tail = node;
 1017f6e:	6065      	str	r5, [r4, #4]
}
 1017f70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if ((pending == NULL) ||
 1017f72:	2b00      	cmp	r3, #0
 1017f74:	d0f6      	beq.n	1017f64 <add_event+0x10>
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
 1017f76:	689b      	ldr	r3, [r3, #8]
 1017f78:	6879      	ldr	r1, [r7, #4]
 1017f7a:	6858      	ldr	r0, [r3, #4]
 1017f7c:	f7ff fd29 	bl	10179d2 <z_is_t1_higher_prio_than_t2>
	if ((pending == NULL) ||
 1017f80:	2800      	cmp	r0, #0
 1017f82:	d1ef      	bne.n	1017f64 <add_event+0x10>
	return list->head == list;
 1017f84:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1017f86:	42b4      	cmp	r4, r6
 1017f88:	d0ec      	beq.n	1017f64 <add_event+0x10>
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
 1017f8a:	2e00      	cmp	r6, #0
 1017f8c:	d0ea      	beq.n	1017f64 <add_event+0x10>
		if (z_is_t1_higher_prio_than_t2(poller->thread,
 1017f8e:	68b3      	ldr	r3, [r6, #8]
 1017f90:	6878      	ldr	r0, [r7, #4]
 1017f92:	6859      	ldr	r1, [r3, #4]
 1017f94:	f7ff fd1d 	bl	10179d2 <z_is_t1_higher_prio_than_t2>
 1017f98:	b128      	cbz	r0, 1017fa6 <add_event+0x52>
	node->prev = successor->prev;
 1017f9a:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
 1017f9c:	e9c5 6300 	strd	r6, r3, [r5]
	successor->prev->next = node;
 1017fa0:	601d      	str	r5, [r3, #0]
	successor->prev = node;
 1017fa2:	6075      	str	r5, [r6, #4]
			return;
 1017fa4:	e7e4      	b.n	1017f70 <add_event+0x1c>
	return (node == list->tail) ? NULL : node->next;
 1017fa6:	6863      	ldr	r3, [r4, #4]
 1017fa8:	429e      	cmp	r6, r3
 1017faa:	d0db      	beq.n	1017f64 <add_event+0x10>
 1017fac:	6836      	ldr	r6, [r6, #0]
 1017fae:	e7ec      	b.n	1017f8a <add_event+0x36>

01017fb0 <register_events>:
{
 1017fb0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int ii = 0; ii < num_events; ii++) {
 1017fb4:	f04f 0a00 	mov.w	sl, #0
{
 1017fb8:	460e      	mov	r6, r1
 1017fba:	4614      	mov	r4, r2
 1017fbc:	461f      	mov	r7, r3
 1017fbe:	4683      	mov	fp, r0
	int events_registered = 0;
 1017fc0:	4655      	mov	r5, sl
	event->poller = NULL;
 1017fc2:	46d0      	mov	r8, sl
	for (int ii = 0; ii < num_events; ii++) {
 1017fc4:	45b2      	cmp	sl, r6
 1017fc6:	db02      	blt.n	1017fce <register_events+0x1e>
}
 1017fc8:	4628      	mov	r0, r5
 1017fca:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1017fce:	f04f 0320 	mov.w	r3, #32
 1017fd2:	f3ef 8911 	mrs	r9, BASEPRI
 1017fd6:	f383 8811 	msr	BASEPRI, r3
 1017fda:	f3bf 8f6f 	isb	sy
	switch (event->type) {
 1017fde:	f89b 200d 	ldrb.w	r2, [fp, #13]
 1017fe2:	f002 020f 	and.w	r2, r2, #15
 1017fe6:	2a02      	cmp	r2, #2
 1017fe8:	d006      	beq.n	1017ff8 <register_events+0x48>
 1017fea:	2a04      	cmp	r2, #4
 1017fec:	d008      	beq.n	1018000 <register_events+0x50>
 1017fee:	2a01      	cmp	r2, #1
 1017ff0:	d120      	bne.n	1018034 <register_events+0x84>
		if (event->signal->signaled != 0U) {
 1017ff2:	f8db 3010 	ldr.w	r3, [fp, #16]
 1017ff6:	e001      	b.n	1017ffc <register_events+0x4c>
		if (k_sem_count_get(event->sem) > 0) {
 1017ff8:	f8db 3010 	ldr.w	r3, [fp, #16]
		if (event->signal->signaled != 0U) {
 1017ffc:	689b      	ldr	r3, [r3, #8]
 1017ffe:	e002      	b.n	1018006 <register_events+0x56>
		if (!k_queue_is_empty(event->queue)) {
 1018000:	f8db 3010 	ldr.w	r3, [fp, #16]
 1018004:	681b      	ldr	r3, [r3, #0]
		if (event->signal->signaled != 0U) {
 1018006:	b1ab      	cbz	r3, 1018034 <register_events+0x84>
	event->state |= state;
 1018008:	f8db 300c 	ldr.w	r3, [fp, #12]
	event->poller = NULL;
 101800c:	f8cb 8008 	str.w	r8, [fp, #8]
	event->state |= state;
 1018010:	f3c3 3104 	ubfx	r1, r3, #12, #5
 1018014:	430a      	orrs	r2, r1
 1018016:	f362 3310 	bfi	r3, r2, #12, #5
 101801a:	f8cb 300c 	str.w	r3, [fp, #12]
			poller->is_polling = false;
 101801e:	f884 8000 	strb.w	r8, [r4]
	__asm__ volatile(
 1018022:	f389 8811 	msr	BASEPRI, r9
 1018026:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
 101802a:	f10a 0a01 	add.w	sl, sl, #1
 101802e:	f10b 0b14 	add.w	fp, fp, #20
 1018032:	e7c7      	b.n	1017fc4 <register_events+0x14>
		} else if (!just_check && poller->is_polling) {
 1018034:	2f00      	cmp	r7, #0
 1018036:	d1f4      	bne.n	1018022 <register_events+0x72>
 1018038:	7823      	ldrb	r3, [r4, #0]
 101803a:	2b00      	cmp	r3, #0
 101803c:	d0f1      	beq.n	1018022 <register_events+0x72>
	switch (event->type) {
 101803e:	f89b 300d 	ldrb.w	r3, [fp, #13]
 1018042:	f003 030f 	and.w	r3, r3, #15
 1018046:	2b02      	cmp	r3, #2
 1018048:	d008      	beq.n	101805c <register_events+0xac>
 101804a:	2b04      	cmp	r3, #4
 101804c:	d006      	beq.n	101805c <register_events+0xac>
 101804e:	2b01      	cmp	r3, #1
 1018050:	d10b      	bne.n	101806a <register_events+0xba>
		add_event(&event->signal->poll_events, event, poller);
 1018052:	4622      	mov	r2, r4
 1018054:	4659      	mov	r1, fp
 1018056:	f8db 0010 	ldr.w	r0, [fp, #16]
 101805a:	e004      	b.n	1018066 <register_events+0xb6>
		add_event(&event->queue->poll_events, event, poller);
 101805c:	4622      	mov	r2, r4
 101805e:	4659      	mov	r1, fp
 1018060:	f8db 0010 	ldr.w	r0, [fp, #16]
 1018064:	3010      	adds	r0, #16
		add_event(&event->signal->poll_events, event, poller);
 1018066:	f7ff ff75 	bl	1017f54 <add_event>
	event->poller = poller;
 101806a:	f8cb 4008 	str.w	r4, [fp, #8]
				events_registered += 1;
 101806e:	3501      	adds	r5, #1
 1018070:	e7d7      	b.n	1018022 <register_events+0x72>

01018072 <z_handle_obj_poll_events>:
{
 1018072:	4603      	mov	r3, r0
	return list->head == list;
 1018074:	6800      	ldr	r0, [r0, #0]
	if (!sys_dlist_is_empty(list)) {
 1018076:	4283      	cmp	r3, r0
 1018078:	d008      	beq.n	101808c <z_handle_obj_poll_events+0x1a>
	node->prev->next = node->next;
 101807a:	e9d0 3200 	ldrd	r3, r2, [r0]
 101807e:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
 1018080:	605a      	str	r2, [r3, #4]
	node->next = NULL;
 1018082:	2300      	movs	r3, #0
	node->prev = NULL;
 1018084:	e9c0 3300 	strd	r3, r3, [r0]
		(void) signal_poll_event(poll_event, state);
 1018088:	f7ff bf27 	b.w	1017eda <signal_poll_event>
}
 101808c:	4770      	bx	lr

0101808e <_OffsetAbsSyms>:
#include "offsets_aarch64.c"
#else
#include "offsets_aarch32.c"
#endif

GEN_ABS_SYM_END
 101808e:	4770      	bx	lr
