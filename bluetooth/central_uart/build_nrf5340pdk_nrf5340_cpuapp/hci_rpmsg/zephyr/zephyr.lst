
zephyr.elf:     file format elf32-littlearm


Disassembly of section rom_start:

01000000 <_vector_table>:
 1000000:	21007810 	.word	0x21007810
 1000004:	01004f39 	.word	0x01004f39
 1000008:	010167cd 	.word	0x010167cd
 100000c:	01004f69 	.word	0x01004f69
 1000010:	01004f69 	.word	0x01004f69
 1000014:	01004f69 	.word	0x01004f69
 1000018:	01004f69 	.word	0x01004f69
	...
 100002c:	01004cf5 	.word	0x01004cf5
 1000030:	01004f69 	.word	0x01004f69
 1000034:	00000000 	.word	0x00000000
 1000038:	01004cad 	.word	0x01004cad
 100003c:	010159d9 	.word	0x010159d9

01000040 <_irq_vector_table>:
 1000040:	01004ef9 01004ef9 01004ef9 01004ef9     .N...N...N...N..
 1000050:	01004ef9 01004ef9 01004ef9 01004ef9     .N...N...N...N..
 1000060:	0100fa31 01004ef9 01004ef9 01004ef9     1....N...N...N..
 1000070:	01004ef9 01004ef9 01004ef9 01004ef9     .N...N...N...N..
 1000080:	01004ef9 01004ef9 01004ef9 01004ef9     .N...N...N...N..
 1000090:	01004ef9 01004ef9 01004ef9 01004ef9     .N...N...N...N..
 10000a0:	01004ef9 01004ef9 01004ef9 01004ef9     .N...N...N...N..
 10000b0:	01004ef9 01004ef9                       .N...N..

Disassembly of section text:

010000b8 <__aeabi_uldivmod>:
 10000b8:	b953      	cbnz	r3, 10000d0 <__aeabi_uldivmod+0x18>
 10000ba:	b94a      	cbnz	r2, 10000d0 <__aeabi_uldivmod+0x18>
 10000bc:	2900      	cmp	r1, #0
 10000be:	bf08      	it	eq
 10000c0:	2800      	cmpeq	r0, #0
 10000c2:	bf1c      	itt	ne
 10000c4:	f04f 31ff 	movne.w	r1, #4294967295
 10000c8:	f04f 30ff 	movne.w	r0, #4294967295
 10000cc:	f000 b970 	b.w	10003b0 <__aeabi_idiv0>
 10000d0:	f1ad 0c08 	sub.w	ip, sp, #8
 10000d4:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 10000d8:	f000 f806 	bl	10000e8 <__udivmoddi4>
 10000dc:	f8dd e004 	ldr.w	lr, [sp, #4]
 10000e0:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 10000e4:	b004      	add	sp, #16
 10000e6:	4770      	bx	lr

010000e8 <__udivmoddi4>:
 10000e8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 10000ec:	9e08      	ldr	r6, [sp, #32]
 10000ee:	460d      	mov	r5, r1
 10000f0:	4604      	mov	r4, r0
 10000f2:	468a      	mov	sl, r1
 10000f4:	2b00      	cmp	r3, #0
 10000f6:	d17f      	bne.n	10001f8 <__udivmoddi4+0x110>
 10000f8:	428a      	cmp	r2, r1
 10000fa:	4617      	mov	r7, r2
 10000fc:	d941      	bls.n	1000182 <__udivmoddi4+0x9a>
 10000fe:	fab2 f282 	clz	r2, r2
 1000102:	b14a      	cbz	r2, 1000118 <__udivmoddi4+0x30>
 1000104:	f1c2 0120 	rsb	r1, r2, #32
 1000108:	fa05 f302 	lsl.w	r3, r5, r2
 100010c:	4097      	lsls	r7, r2
 100010e:	4094      	lsls	r4, r2
 1000110:	fa20 f101 	lsr.w	r1, r0, r1
 1000114:	ea41 0a03 	orr.w	sl, r1, r3
 1000118:	ea4f 4817 	mov.w	r8, r7, lsr #16
 100011c:	ea4f 4c14 	mov.w	ip, r4, lsr #16
 1000120:	fa1f f987 	uxth.w	r9, r7
 1000124:	fbba fef8 	udiv	lr, sl, r8
 1000128:	fb08 a31e 	mls	r3, r8, lr, sl
 100012c:	fb0e f109 	mul.w	r1, lr, r9
 1000130:	ea4c 4303 	orr.w	r3, ip, r3, lsl #16
 1000134:	4299      	cmp	r1, r3
 1000136:	d906      	bls.n	1000146 <__udivmoddi4+0x5e>
 1000138:	18fb      	adds	r3, r7, r3
 100013a:	d202      	bcs.n	1000142 <__udivmoddi4+0x5a>
 100013c:	4299      	cmp	r1, r3
 100013e:	f200 8124 	bhi.w	100038a <__udivmoddi4+0x2a2>
 1000142:	f10e 3eff 	add.w	lr, lr, #4294967295
 1000146:	1a59      	subs	r1, r3, r1
 1000148:	b2a3      	uxth	r3, r4
 100014a:	fbb1 f0f8 	udiv	r0, r1, r8
 100014e:	fb08 1110 	mls	r1, r8, r0, r1
 1000152:	fb00 f909 	mul.w	r9, r0, r9
 1000156:	ea43 4401 	orr.w	r4, r3, r1, lsl #16
 100015a:	45a1      	cmp	r9, r4
 100015c:	d905      	bls.n	100016a <__udivmoddi4+0x82>
 100015e:	193c      	adds	r4, r7, r4
 1000160:	d202      	bcs.n	1000168 <__udivmoddi4+0x80>
 1000162:	45a1      	cmp	r9, r4
 1000164:	f200 810e 	bhi.w	1000384 <__udivmoddi4+0x29c>
 1000168:	3801      	subs	r0, #1
 100016a:	eba4 0409 	sub.w	r4, r4, r9
 100016e:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
 1000172:	2100      	movs	r1, #0
 1000174:	b11e      	cbz	r6, 100017e <__udivmoddi4+0x96>
 1000176:	40d4      	lsrs	r4, r2
 1000178:	2300      	movs	r3, #0
 100017a:	e9c6 4300 	strd	r4, r3, [r6]
 100017e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 1000182:	b902      	cbnz	r2, 1000186 <__udivmoddi4+0x9e>
 1000184:	deff      	udf	#255	; 0xff
 1000186:	fab2 f282 	clz	r2, r2
 100018a:	2a00      	cmp	r2, #0
 100018c:	d14f      	bne.n	100022e <__udivmoddi4+0x146>
 100018e:	1bcb      	subs	r3, r1, r7
 1000190:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 1000194:	fa1f f887 	uxth.w	r8, r7
 1000198:	2101      	movs	r1, #1
 100019a:	0c25      	lsrs	r5, r4, #16
 100019c:	fbb3 fcfe 	udiv	ip, r3, lr
 10001a0:	fb0e 301c 	mls	r0, lr, ip, r3
 10001a4:	462b      	mov	r3, r5
 10001a6:	fb08 f90c 	mul.w	r9, r8, ip
 10001aa:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
 10001ae:	45a9      	cmp	r9, r5
 10001b0:	d90a      	bls.n	10001c8 <__udivmoddi4+0xe0>
 10001b2:	197d      	adds	r5, r7, r5
 10001b4:	bf2c      	ite	cs
 10001b6:	2301      	movcs	r3, #1
 10001b8:	2300      	movcc	r3, #0
 10001ba:	45a9      	cmp	r9, r5
 10001bc:	d902      	bls.n	10001c4 <__udivmoddi4+0xdc>
 10001be:	2b00      	cmp	r3, #0
 10001c0:	f000 80d9 	beq.w	1000376 <__udivmoddi4+0x28e>
 10001c4:	f10c 3cff 	add.w	ip, ip, #4294967295
 10001c8:	eba5 0509 	sub.w	r5, r5, r9
 10001cc:	b2a3      	uxth	r3, r4
 10001ce:	fbb5 f0fe 	udiv	r0, r5, lr
 10001d2:	fb0e 5510 	mls	r5, lr, r0, r5
 10001d6:	fb08 f800 	mul.w	r8, r8, r0
 10001da:	ea43 4405 	orr.w	r4, r3, r5, lsl #16
 10001de:	45a0      	cmp	r8, r4
 10001e0:	d905      	bls.n	10001ee <__udivmoddi4+0x106>
 10001e2:	193c      	adds	r4, r7, r4
 10001e4:	d202      	bcs.n	10001ec <__udivmoddi4+0x104>
 10001e6:	45a0      	cmp	r8, r4
 10001e8:	f200 80c9 	bhi.w	100037e <__udivmoddi4+0x296>
 10001ec:	3801      	subs	r0, #1
 10001ee:	eba4 0408 	sub.w	r4, r4, r8
 10001f2:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 10001f6:	e7bd      	b.n	1000174 <__udivmoddi4+0x8c>
 10001f8:	428b      	cmp	r3, r1
 10001fa:	d908      	bls.n	100020e <__udivmoddi4+0x126>
 10001fc:	2e00      	cmp	r6, #0
 10001fe:	f000 80b1 	beq.w	1000364 <__udivmoddi4+0x27c>
 1000202:	2100      	movs	r1, #0
 1000204:	e9c6 0500 	strd	r0, r5, [r6]
 1000208:	4608      	mov	r0, r1
 100020a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 100020e:	fab3 f183 	clz	r1, r3
 1000212:	2900      	cmp	r1, #0
 1000214:	d146      	bne.n	10002a4 <__udivmoddi4+0x1bc>
 1000216:	42ab      	cmp	r3, r5
 1000218:	f0c0 80a7 	bcc.w	100036a <__udivmoddi4+0x282>
 100021c:	4282      	cmp	r2, r0
 100021e:	f240 80a4 	bls.w	100036a <__udivmoddi4+0x282>
 1000222:	4608      	mov	r0, r1
 1000224:	2e00      	cmp	r6, #0
 1000226:	d0aa      	beq.n	100017e <__udivmoddi4+0x96>
 1000228:	e9c6 4a00 	strd	r4, sl, [r6]
 100022c:	e7a7      	b.n	100017e <__udivmoddi4+0x96>
 100022e:	f1c2 0020 	rsb	r0, r2, #32
 1000232:	4097      	lsls	r7, r2
 1000234:	fa01 f302 	lsl.w	r3, r1, r2
 1000238:	ea4f 4e17 	mov.w	lr, r7, lsr #16
 100023c:	40c1      	lsrs	r1, r0
 100023e:	fa24 f500 	lsr.w	r5, r4, r0
 1000242:	fa1f f887 	uxth.w	r8, r7
 1000246:	4094      	lsls	r4, r2
 1000248:	431d      	orrs	r5, r3
 100024a:	fbb1 f0fe 	udiv	r0, r1, lr
 100024e:	0c2b      	lsrs	r3, r5, #16
 1000250:	fb0e 1110 	mls	r1, lr, r0, r1
 1000254:	fb00 fc08 	mul.w	ip, r0, r8
 1000258:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 100025c:	459c      	cmp	ip, r3
 100025e:	d909      	bls.n	1000274 <__udivmoddi4+0x18c>
 1000260:	18fb      	adds	r3, r7, r3
 1000262:	bf2c      	ite	cs
 1000264:	2101      	movcs	r1, #1
 1000266:	2100      	movcc	r1, #0
 1000268:	459c      	cmp	ip, r3
 100026a:	d902      	bls.n	1000272 <__udivmoddi4+0x18a>
 100026c:	2900      	cmp	r1, #0
 100026e:	f000 8095 	beq.w	100039c <__udivmoddi4+0x2b4>
 1000272:	3801      	subs	r0, #1
 1000274:	eba3 030c 	sub.w	r3, r3, ip
 1000278:	b2ad      	uxth	r5, r5
 100027a:	fbb3 f1fe 	udiv	r1, r3, lr
 100027e:	fb0e 3311 	mls	r3, lr, r1, r3
 1000282:	fb01 fc08 	mul.w	ip, r1, r8
 1000286:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
 100028a:	45ac      	cmp	ip, r5
 100028c:	d905      	bls.n	100029a <__udivmoddi4+0x1b2>
 100028e:	197d      	adds	r5, r7, r5
 1000290:	d202      	bcs.n	1000298 <__udivmoddi4+0x1b0>
 1000292:	45ac      	cmp	ip, r5
 1000294:	f200 8089 	bhi.w	10003aa <__udivmoddi4+0x2c2>
 1000298:	3901      	subs	r1, #1
 100029a:	eba5 030c 	sub.w	r3, r5, ip
 100029e:	ea41 4100 	orr.w	r1, r1, r0, lsl #16
 10002a2:	e77a      	b.n	100019a <__udivmoddi4+0xb2>
 10002a4:	f1c1 0420 	rsb	r4, r1, #32
 10002a8:	408b      	lsls	r3, r1
 10002aa:	fa02 f701 	lsl.w	r7, r2, r1
 10002ae:	fa05 fc01 	lsl.w	ip, r5, r1
 10002b2:	40e2      	lsrs	r2, r4
 10002b4:	fa20 f804 	lsr.w	r8, r0, r4
 10002b8:	40e5      	lsrs	r5, r4
 10002ba:	fa00 fe01 	lsl.w	lr, r0, r1
 10002be:	4313      	orrs	r3, r2
 10002c0:	ea48 020c 	orr.w	r2, r8, ip
 10002c4:	ea4f 4813 	mov.w	r8, r3, lsr #16
 10002c8:	ea4f 4c12 	mov.w	ip, r2, lsr #16
 10002cc:	fa1f f983 	uxth.w	r9, r3
 10002d0:	fbb5 faf8 	udiv	sl, r5, r8
 10002d4:	fb08 551a 	mls	r5, r8, sl, r5
 10002d8:	fb0a f009 	mul.w	r0, sl, r9
 10002dc:	ea4c 4c05 	orr.w	ip, ip, r5, lsl #16
 10002e0:	4560      	cmp	r0, ip
 10002e2:	d90a      	bls.n	10002fa <__udivmoddi4+0x212>
 10002e4:	eb13 0c0c 	adds.w	ip, r3, ip
 10002e8:	bf2c      	ite	cs
 10002ea:	2501      	movcs	r5, #1
 10002ec:	2500      	movcc	r5, #0
 10002ee:	4560      	cmp	r0, ip
 10002f0:	d901      	bls.n	10002f6 <__udivmoddi4+0x20e>
 10002f2:	2d00      	cmp	r5, #0
 10002f4:	d055      	beq.n	10003a2 <__udivmoddi4+0x2ba>
 10002f6:	f10a 3aff 	add.w	sl, sl, #4294967295
 10002fa:	ebac 0c00 	sub.w	ip, ip, r0
 10002fe:	b292      	uxth	r2, r2
 1000300:	fbbc f0f8 	udiv	r0, ip, r8
 1000304:	fb08 cc10 	mls	ip, r8, r0, ip
 1000308:	fb00 f909 	mul.w	r9, r0, r9
 100030c:	ea42 4c0c 	orr.w	ip, r2, ip, lsl #16
 1000310:	45e1      	cmp	r9, ip
 1000312:	d905      	bls.n	1000320 <__udivmoddi4+0x238>
 1000314:	eb13 0c0c 	adds.w	ip, r3, ip
 1000318:	d201      	bcs.n	100031e <__udivmoddi4+0x236>
 100031a:	45e1      	cmp	r9, ip
 100031c:	d83b      	bhi.n	1000396 <__udivmoddi4+0x2ae>
 100031e:	3801      	subs	r0, #1
 1000320:	ea40 400a 	orr.w	r0, r0, sl, lsl #16
 1000324:	ebac 0c09 	sub.w	ip, ip, r9
 1000328:	fba0 8907 	umull	r8, r9, r0, r7
 100032c:	45cc      	cmp	ip, r9
 100032e:	4645      	mov	r5, r8
 1000330:	464a      	mov	r2, r9
 1000332:	d302      	bcc.n	100033a <__udivmoddi4+0x252>
 1000334:	d106      	bne.n	1000344 <__udivmoddi4+0x25c>
 1000336:	45c6      	cmp	lr, r8
 1000338:	d204      	bcs.n	1000344 <__udivmoddi4+0x25c>
 100033a:	3801      	subs	r0, #1
 100033c:	ebb8 0507 	subs.w	r5, r8, r7
 1000340:	eb69 0203 	sbc.w	r2, r9, r3
 1000344:	b32e      	cbz	r6, 1000392 <__udivmoddi4+0x2aa>
 1000346:	ebbe 0305 	subs.w	r3, lr, r5
 100034a:	eb6c 0c02 	sbc.w	ip, ip, r2
 100034e:	fa23 f201 	lsr.w	r2, r3, r1
 1000352:	fa0c f404 	lsl.w	r4, ip, r4
 1000356:	fa2c f301 	lsr.w	r3, ip, r1
 100035a:	2100      	movs	r1, #0
 100035c:	4314      	orrs	r4, r2
 100035e:	e9c6 4300 	strd	r4, r3, [r6]
 1000362:	e70c      	b.n	100017e <__udivmoddi4+0x96>
 1000364:	4631      	mov	r1, r6
 1000366:	4630      	mov	r0, r6
 1000368:	e709      	b.n	100017e <__udivmoddi4+0x96>
 100036a:	1a84      	subs	r4, r0, r2
 100036c:	eb65 0303 	sbc.w	r3, r5, r3
 1000370:	2001      	movs	r0, #1
 1000372:	469a      	mov	sl, r3
 1000374:	e756      	b.n	1000224 <__udivmoddi4+0x13c>
 1000376:	f1ac 0c02 	sub.w	ip, ip, #2
 100037a:	443d      	add	r5, r7
 100037c:	e724      	b.n	10001c8 <__udivmoddi4+0xe0>
 100037e:	3802      	subs	r0, #2
 1000380:	443c      	add	r4, r7
 1000382:	e734      	b.n	10001ee <__udivmoddi4+0x106>
 1000384:	3802      	subs	r0, #2
 1000386:	443c      	add	r4, r7
 1000388:	e6ef      	b.n	100016a <__udivmoddi4+0x82>
 100038a:	f1ae 0e02 	sub.w	lr, lr, #2
 100038e:	443b      	add	r3, r7
 1000390:	e6d9      	b.n	1000146 <__udivmoddi4+0x5e>
 1000392:	4631      	mov	r1, r6
 1000394:	e6f3      	b.n	100017e <__udivmoddi4+0x96>
 1000396:	3802      	subs	r0, #2
 1000398:	449c      	add	ip, r3
 100039a:	e7c1      	b.n	1000320 <__udivmoddi4+0x238>
 100039c:	3802      	subs	r0, #2
 100039e:	443b      	add	r3, r7
 10003a0:	e768      	b.n	1000274 <__udivmoddi4+0x18c>
 10003a2:	f1aa 0a02 	sub.w	sl, sl, #2
 10003a6:	449c      	add	ip, r3
 10003a8:	e7a7      	b.n	10002fa <__udivmoddi4+0x212>
 10003aa:	3902      	subs	r1, #2
 10003ac:	443d      	add	r5, r7
 10003ae:	e774      	b.n	100029a <__udivmoddi4+0x1b2>

010003b0 <__aeabi_idiv0>:
 10003b0:	4770      	bx	lr
 10003b2:	bf00      	nop
 10003b4:	0000      	movs	r0, r0
	...

010003b8 <ll_adv_enable>:
u8_t ll_adv_enable(u8_t enable)
{
	u16_t const handle = 0;
	u32_t ticks_anchor;
#endif /* !CONFIG_BT_CTLR_ADV_EXT || !CONFIG_BT_HCI_MESH_EXT */
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 10003b8:	2302      	movs	r3, #2
{
 10003ba:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10003be:	b08f      	sub	sp, #60	; 0x3c
inline struct ll_adv_set *ull_adv_is_enabled_get(u16_t handle)
{
	struct ll_adv_set *adv;

	adv = ull_adv_set_get(handle);
	if (!adv || !adv->is_enabled) {
 10003c0:	4ca5      	ldr	r4, [pc, #660]	; (1000658 <ll_adv_enable+0x2a0>)
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 10003c2:	930c      	str	r3, [sp, #48]	; 0x30
	if (!enable) {
 10003c4:	2800      	cmp	r0, #0
 10003c6:	f000 80ea 	beq.w	100059e <ll_adv_enable+0x1e6>
static inline struct ll_adv_set *is_disabled_get(u16_t handle)
{
	struct ll_adv_set *adv;

	adv = ull_adv_set_get(handle);
	if (!adv || adv->is_enabled) {
 10003ca:	f894 80cc 	ldrb.w	r8, [r4, #204]	; 0xcc
 10003ce:	f018 0801 	ands.w	r8, r8, #1
 10003d2:	d139      	bne.n	1000448 <ll_adv_enable+0x90>
		lll->rl_idx = FILTER_IDX_NONE;
 10003d4:	23ff      	movs	r3, #255	; 0xff
	lll_adv_pdu_enqueue(&lll->scan_rsp, idx);
}

static inline struct pdu_adv *lll_adv_scan_rsp_peek(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 10003d6:	f894 607c 	ldrb.w	r6, [r4, #124]	; 0x7c
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 10003da:	f894 702c 	ldrb.w	r7, [r4, #44]	; 0x2c
		ull_filter_adv_update(lll->filter_policy);
 10003de:	f894 0029 	ldrb.w	r0, [r4, #41]	; 0x29
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 10003e2:	eb06 0286 	add.w	r2, r6, r6, lsl #2
 10003e6:	ebc6 06c2 	rsb	r6, r6, r2, lsl #3
 10003ea:	f000 0003 	and.w	r0, r0, #3
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 10003ee:	eb07 0287 	add.w	r2, r7, r7, lsl #2
 10003f2:	ebc7 07c2 	rsb	r7, r7, r2, lsl #3
		lll->rl_idx = FILTER_IDX_NONE;
 10003f6:	f884 302a 	strb.w	r3, [r4, #42]	; 0x2a
		ull_filter_adv_update(lll->filter_policy);
 10003fa:	f00e fce5 	bl	100edc8 <ull_filter_adv_update>
		if (adv->own_addr_type == BT_ADDR_LE_PUBLIC_ID ||
 10003fe:	f894 00da 	ldrb.w	r0, [r4, #218]	; 0xda
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 1000402:	367d      	adds	r6, #125	; 0x7d
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 1000404:	372d      	adds	r7, #45	; 0x2d
 1000406:	0781      	lsls	r1, r0, #30
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 1000408:	4426      	add	r6, r4
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 100040a:	eb04 0907 	add.w	r9, r4, r7
 100040e:	d421      	bmi.n	1000454 <ll_adv_enable+0x9c>
			u8_t *tx_addr = ll_addr_get(pdu_adv->tx_addr, NULL);
 1000410:	5de0      	ldrb	r0, [r4, r7]
 1000412:	4641      	mov	r1, r8
 1000414:	f3c0 1080 	ubfx	r0, r0, #6, #1
 1000418:	f006 ff4c 	bl	10072b4 <ll_addr_get>
 100041c:	4605      	mov	r5, r0
			memcpy(&pdu_adv->adv_ind.addr[0], tx_addr,
 100041e:	4601      	mov	r1, r0
 1000420:	2206      	movs	r2, #6
 1000422:	f109 0002 	add.w	r0, r9, #2
 1000426:	f016 fa47 	bl	10168b8 <memcpy>
			memcpy(&pdu_scan->scan_rsp.addr[0], tx_addr,
 100042a:	2206      	movs	r2, #6
 100042c:	4629      	mov	r1, r5
 100042e:	1cb0      	adds	r0, r6, #2
 1000430:	f016 fa42 	bl	10168b8 <memcpy>
		if (pdu_adv->tx_addr &&
 1000434:	5de3      	ldrb	r3, [r4, r7]
 1000436:	065a      	lsls	r2, r3, #25
 1000438:	d423      	bmi.n	1000482 <ll_adv_enable+0xca>
	if ((pdu_adv->type == PDU_ADV_TYPE_ADV_IND) ||
 100043a:	f013 0f0e 	tst.w	r3, #14
 100043e:	d12c      	bne.n	100049a <ll_adv_enable+0xe2>
		if (lll->conn) {
 1000440:	6a63      	ldr	r3, [r4, #36]	; 0x24
 1000442:	2b00      	cmp	r3, #0
 1000444:	f000 8114 	beq.w	1000670 <ll_adv_enable+0x2b8>
	return BT_HCI_ERR_CMD_DISALLOWED;
 1000448:	f04f 080c 	mov.w	r8, #12
}
 100044c:	4640      	mov	r0, r8
 100044e:	b00f      	add	sp, #60	; 0x3c
 1000450:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			lll->rl_idx = ull_filter_rl_find(adv->id_addr_type,
 1000454:	4642      	mov	r2, r8
 1000456:	f3c0 0080 	ubfx	r0, r0, #2, #1
 100045a:	f104 01db 	add.w	r1, r4, #219	; 0xdb
 100045e:	f00e fe9f 	bl	100f1a0 <ull_filter_rl_find>
			if (lll->rl_idx != FILTER_IDX_NONE) {
 1000462:	28ff      	cmp	r0, #255	; 0xff
			lll->rl_idx = ull_filter_rl_find(adv->id_addr_type,
 1000464:	f884 002a 	strb.w	r0, [r4, #42]	; 0x2a
			if (lll->rl_idx != FILTER_IDX_NONE) {
 1000468:	f040 81d9 	bne.w	100081e <ll_adv_enable+0x466>
			ull_filter_adv_pdu_update(adv, pdu_adv);
 100046c:	4649      	mov	r1, r9
 100046e:	487a      	ldr	r0, [pc, #488]	; (1000658 <ll_adv_enable+0x2a0>)
 1000470:	f00e fcf0 	bl	100ee54 <ull_filter_adv_pdu_update>
			ull_filter_adv_pdu_update(adv, pdu_scan);
 1000474:	4631      	mov	r1, r6
 1000476:	4878      	ldr	r0, [pc, #480]	; (1000658 <ll_adv_enable+0x2a0>)
 1000478:	f00e fcec 	bl	100ee54 <ull_filter_adv_pdu_update>
		if (pdu_adv->tx_addr &&
 100047c:	5de3      	ldrb	r3, [r4, r7]
 100047e:	065a      	lsls	r2, r3, #25
 1000480:	d5db      	bpl.n	100043a <ll_adv_enable+0x82>
		    !mem_nz(pdu_adv->adv_ind.addr, BDADDR_SIZE)) {
 1000482:	2106      	movs	r1, #6
 1000484:	f109 0002 	add.w	r0, r9, #2
 1000488:	f005 fc14 	bl	1005cb4 <mem_nz>
		if (pdu_adv->tx_addr &&
 100048c:	2800      	cmp	r0, #0
 100048e:	f000 8220 	beq.w	10008d2 <ll_adv_enable+0x51a>
 1000492:	5de3      	ldrb	r3, [r4, r7]
	if ((pdu_adv->type == PDU_ADV_TYPE_ADV_IND) ||
 1000494:	f013 0f0e 	tst.w	r3, #14
 1000498:	d0d2      	beq.n	1000440 <ll_adv_enable+0x88>
	u8_t ch_map = lll->chan_map;
 100049a:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
	const u8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
 100049e:	2101      	movs	r1, #1
	u8_t ch_map = lll->chan_map;
 10004a0:	f3c3 0342 	ubfx	r3, r3, #1, #3
	const u8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
 10004a4:	a80d      	add	r0, sp, #52	; 0x34
	u8_t ch_map = lll->chan_map;
 10004a6:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
	const u8_t adv_chn_cnt = util_ones_count_get(&ch_map, sizeof(ch_map));
 10004aa:	f005 fd85 	bl	1005fb8 <util_ones_count_get>
	if (adv_chn_cnt == 0) {
 10004ae:	2800      	cmp	r0, #0
 10004b0:	d06e      	beq.n	1000590 <ll_adv_enable+0x1d8>
		if (pdu_adv->type == PDU_ADV_TYPE_NONCONN_IND) {
 10004b2:	5de2      	ldrb	r2, [r4, r7]
		const u8_t adv_data_len = pdu_adv->len;
 10004b4:	f899 3001 	ldrb.w	r3, [r9, #1]
		if (pdu_adv->type == PDU_ADV_TYPE_NONCONN_IND) {
 10004b8:	f002 020f 	and.w	r2, r2, #15
 10004bc:	2a02      	cmp	r2, #2
		const u8_t rsp_data_len = pdu_scan->len;
 10004be:	7871      	ldrb	r1, [r6, #1]
		if (pdu_adv->type == PDU_ADV_TYPE_NONCONN_IND) {
 10004c0:	d012      	beq.n	10004e8 <ll_adv_enable+0x130>
			if (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND) {
 10004c2:	2a01      	cmp	r2, #1
 10004c4:	f000 8210 	beq.w	10008e8 <ll_adv_enable+0x530>
					  BYTES2US(ADVA_SIZE + rsp_data_len,
 10004c8:	00c9      	lsls	r1, r1, #3
		const u16_t scan_rsp_us  = ll_hdr_us +
 10004ca:	3180      	adds	r1, #128	; 0x80
			} else if (pdu_adv->type == PDU_ADV_TYPE_ADV_IND) {
 10004cc:	2a00      	cmp	r2, #0
 10004ce:	f040 8203 	bne.w	10008d8 <ll_adv_enable+0x520>
				adv_size += adv_data_len;
 10004d2:	3310      	adds	r3, #16
 10004d4:	00db      	lsls	r3, r3, #3
 10004d6:	f503 724d 	add.w	r2, r3, #820	; 0x334
 10004da:	440a      	add	r2, r1
 10004dc:	f503 739a 	add.w	r3, r3, #308	; 0x134
				  + rx_to_us + rxtx_turn_us) * (adv_chn_cnt-1)
 10004e0:	3801      	subs	r0, #1
			slot_us += (BYTES2US(adv_size, phy) + EVENT_IFS_MAX_US
 10004e2:	fb03 2000 	mla	r0, r3, r0, r2
 10004e6:	e009      	b.n	10004fc <ll_adv_enable+0x144>
				   rxtx_turn_us * (adv_chn_cnt - 1);
 10004e8:	2264      	movs	r2, #100	; 0x64
			adv_size += adv_data_len;
 10004ea:	3310      	adds	r3, #16
			slot_us += BYTES2US(adv_size, phy) * adv_chn_cnt +
 10004ec:	00db      	lsls	r3, r3, #3
 10004ee:	fb00 f303 	mul.w	r3, r0, r3
				   rxtx_turn_us * (adv_chn_cnt - 1);
 10004f2:	3801      	subs	r0, #1
			slot_us += BYTES2US(adv_size, phy) * adv_chn_cnt +
 10004f4:	f503 73aa 	add.w	r3, r3, #340	; 0x154
 10004f8:	fb02 3000 	mla	r0, r2, r0, r3
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
 10004fc:	a354      	add	r3, pc, #336	; (adr r3, 1000650 <ll_adv_enable+0x298>)
 10004fe:	e9d3 2300 	ldrd	r2, r3, [r3]
	return hdr->ref--;
}

static inline void ull_hdr_init(struct ull_hdr *hdr)
{
	hdr->disabled_cb = hdr->disabled_param = NULL;
 1000502:	2500      	movs	r5, #0
	adv->evt.ticks_xtal_to_start =
 1000504:	2631      	movs	r6, #49	; 0x31
static inline void lll_hdr_init(void *lll, void *parent)
{
	struct lll_hdr *hdr = lll;

	hdr->parent = parent;
	hdr->is_stop = 0U;
 1000506:	f894 1020 	ldrb.w	r1, [r4, #32]
 100050a:	6026      	str	r6, [r4, #0]
 100050c:	f365 0100 	bfi	r1, r5, #0, #1
 1000510:	f884 1020 	strb.w	r1, [r4, #32]
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
 1000514:	4951      	ldr	r1, [pc, #324]	; (100065c <ll_adv_enable+0x2a4>)
 1000516:	e9c4 5505 	strd	r5, r5, [r4, #20]
 100051a:	fba0 0101 	umull	r0, r1, r0, r1
	adv->evt.ticks_preempt_to_start =
 100051e:	e9c4 5501 	strd	r5, r5, [r4, #4]
	hdr->parent = parent;
 1000522:	61e4      	str	r4, [r4, #28]
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
 1000524:	f7ff fdc8 	bl	10000b8 <__aeabi_uldivmod>
	u16_t interval = adv->interval;
 1000528:	f8b4 90d8 	ldrh.w	r9, [r4, #216]	; 0xd8
	adv->evt.ticks_slot = HAL_TICKER_US_TO_TICKS(slot_us);
 100052c:	60e0      	str	r0, [r4, #12]
	ticks_anchor = ticker_ticks_now_get();
 100052e:	f006 febb 	bl	10072a8 <ticker_ticks_now_get>
 1000532:	4606      	mov	r6, r0
	lll->is_hdcd = !interval && (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND);
 1000534:	f1b9 0f00 	cmp.w	r9, #0
 1000538:	d107      	bne.n	100054a <ll_adv_enable+0x192>
 100053a:	5de5      	ldrb	r5, [r4, r7]
 100053c:	f005 050f 	and.w	r5, r5, #15
 1000540:	f1a5 0501 	sub.w	r5, r5, #1
 1000544:	fab5 f585 	clz	r5, r5
 1000548:	096d      	lsrs	r5, r5, #5
 100054a:	f894 0028 	ldrb.w	r0, [r4, #40]	; 0x28
 100054e:	f365 0000 	bfi	r0, r5, #0, #1
	if (lll->is_hdcd) {
 1000552:	f010 0501 	ands.w	r5, r0, #1
	lll->is_hdcd = !interval && (pdu_adv->type == PDU_ADV_TYPE_DIRECT_IND);
 1000556:	f884 0028 	strb.w	r0, [r4, #40]	; 0x28
	if (lll->is_hdcd) {
 100055a:	f000 8164 	beq.w	1000826 <ll_adv_enable+0x46e>
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 100055e:	2000      	movs	r0, #0
				   (adv->evt.ticks_slot + ticks_slot_overhead),
 1000560:	68e3      	ldr	r3, [r4, #12]
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000562:	4a3f      	ldr	r2, [pc, #252]	; (1000660 <ll_adv_enable+0x2a8>)
 1000564:	4d3f      	ldr	r5, [pc, #252]	; (1000664 <ll_adv_enable+0x2ac>)
 1000566:	af0c      	add	r7, sp, #48	; 0x30
 1000568:	2103      	movs	r1, #3
 100056a:	9304      	str	r3, [sp, #16]
 100056c:	9301      	str	r3, [sp, #4]
 100056e:	9205      	str	r2, [sp, #20]
 1000570:	4633      	mov	r3, r6
 1000572:	2202      	movs	r2, #2
 1000574:	e9cd 0002 	strd	r0, r0, [sp, #8]
 1000578:	9406      	str	r4, [sp, #24]
 100057a:	9000      	str	r0, [sp, #0]
 100057c:	9507      	str	r5, [sp, #28]
 100057e:	9708      	str	r7, [sp, #32]
 1000580:	f006 fdf2 	bl	1007168 <ticker_start>
		ret = ull_ticker_status_take(ret, &ret_cb);
 1000584:	4639      	mov	r1, r7
 1000586:	f009 fdb1 	bl	100a0ec <ull_ticker_status_take>
		if (ret != TICKER_STATUS_SUCCESS) {
 100058a:	2800      	cmp	r0, #0
 100058c:	f000 818b 	beq.w	10008a6 <ll_adv_enable+0x4ee>
	if (adv->lll.conn) {
 1000590:	6a63      	ldr	r3, [r4, #36]	; 0x24
 1000592:	2b00      	cmp	r3, #0
 1000594:	f43f af58 	beq.w	1000448 <ll_adv_enable+0x90>
		conn_release(adv);
 1000598:	f00a f8ee 	bl	100a778 <conn_release.constprop.0>
 100059c:	e754      	b.n	1000448 <ll_adv_enable+0x90>
}
#endif /* CONFIG_BT_PERIPHERAL */

static inline u8_t disable(u16_t handle)
{
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 100059e:	930d      	str	r3, [sp, #52]	; 0x34
	if (!adv || !adv->is_enabled) {
 10005a0:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
 10005a4:	07dd      	lsls	r5, r3, #31
 10005a6:	f57f af4f 	bpl.w	1000448 <ll_adv_enable+0x90>
	adv = ull_adv_is_enabled_get(handle);
	if (!adv) {
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	mark = ull_disable_mark(adv);
 10005aa:	4620      	mov	r0, r4
 10005ac:	f009 fdac 	bl	100a108 <ull_disable_mark>
	LL_ASSERT(mark == adv);
 10005b0:	4284      	cmp	r4, r0
 10005b2:	d004      	beq.n	10005be <ll_adv_enable+0x206>
 10005b4:	f240 41e9 	movw	r1, #1257	; 0x4e9
 10005b8:	482b      	ldr	r0, [pc, #172]	; (1000668 <ll_adv_enable+0x2b0>)
 10005ba:	f002 ffe5 	bl	1003588 <bt_ctlr_assert_handle>

#if defined(CONFIG_BT_PERIPHERAL)
	if (adv->lll.is_hdcd) {
 10005be:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 10005c2:	ad0d      	add	r5, sp, #52	; 0x34
	if (adv->lll.is_hdcd) {
 10005c4:	07d8      	lsls	r0, r3, #31
 10005c6:	d50e      	bpl.n	10005e6 <ll_adv_enable+0x22e>
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 10005c8:	2103      	movs	r1, #3
 10005ca:	2201      	movs	r2, #1
 10005cc:	2000      	movs	r0, #0
 10005ce:	4b25      	ldr	r3, [pc, #148]	; (1000664 <ll_adv_enable+0x2ac>)
 10005d0:	9500      	str	r5, [sp, #0]
 10005d2:	f006 fe2f 	bl	1007234 <ticker_stop>
				  TICKER_USER_ID_THREAD, TICKER_ID_ADV_STOP,
				  ull_ticker_status_give, (void *)&ret_cb);
		ret = ull_ticker_status_take(ret, &ret_cb);
 10005d6:	4629      	mov	r1, r5
 10005d8:	f009 fd88 	bl	100a0ec <ull_ticker_status_take>
		if (ret) {
 10005dc:	2800      	cmp	r0, #0
 10005de:	f040 81ac 	bne.w	100093a <ll_adv_enable+0x582>
			mark = ull_disable_mark(adv);
			LL_ASSERT(mark == adv);

			return BT_HCI_ERR_CMD_DISALLOWED;
		}
		ret_cb = TICKER_STATUS_BUSY;
 10005e2:	2302      	movs	r3, #2
 10005e4:	930d      	str	r3, [sp, #52]	; 0x34
	}
#endif

	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
 10005e6:	2103      	movs	r1, #3
 10005e8:	2202      	movs	r2, #2
 10005ea:	2000      	movs	r0, #0
 10005ec:	4b1d      	ldr	r3, [pc, #116]	; (1000664 <ll_adv_enable+0x2ac>)
 10005ee:	9500      	str	r5, [sp, #0]
 10005f0:	f006 fe20 	bl	1007234 <ticker_stop>
			  TICKER_ID_ADV_BASE + handle,
			  ull_ticker_status_give, (void *)&ret_cb);

	ret = ull_ticker_status_take(ret, &ret_cb);
 10005f4:	4629      	mov	r1, r5
 10005f6:	f009 fd79 	bl	100a0ec <ull_ticker_status_take>
	if (ret) {
 10005fa:	2800      	cmp	r0, #0
 10005fc:	f040 8186 	bne.w	100090c <ll_adv_enable+0x554>
		LL_ASSERT(mark == adv);

		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	ret = ull_disable(&adv->lll);
 1000600:	481a      	ldr	r0, [pc, #104]	; (100066c <ll_adv_enable+0x2b4>)
 1000602:	f009 fdbd 	bl	100a180 <ull_disable>
	LL_ASSERT(!ret);
 1000606:	2800      	cmp	r0, #0
 1000608:	f040 8173 	bne.w	10008f2 <ll_adv_enable+0x53a>

	mark = ull_disable_unmark(adv);
 100060c:	4812      	ldr	r0, [pc, #72]	; (1000658 <ll_adv_enable+0x2a0>)
 100060e:	f009 fd85 	bl	100a11c <ull_disable_unmark>
	LL_ASSERT(mark == adv);
 1000612:	4284      	cmp	r4, r0
 1000614:	d004      	beq.n	1000620 <ll_adv_enable+0x268>
 1000616:	f240 510b 	movw	r1, #1291	; 0x50b
 100061a:	4813      	ldr	r0, [pc, #76]	; (1000668 <ll_adv_enable+0x2b0>)
 100061c:	f002 ffb4 	bl	1003588 <bt_ctlr_assert_handle>

#if defined(CONFIG_BT_PERIPHERAL)
	if (adv->lll.conn) {
 1000620:	6a63      	ldr	r3, [r4, #36]	; 0x24
 1000622:	b10b      	cbz	r3, 1000628 <ll_adv_enable+0x270>
		conn_release(adv);
 1000624:	f00a f8a8 	bl	100a778 <conn_release.constprop.0>
	}
#endif /* CONFIG_BT_PERIPHERAL */

	adv->is_enabled = 0U;
 1000628:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc

#if defined(CONFIG_BT_CTLR_PRIVACY)
	if (IS_ENABLED(CONFIG_BT_OBSERVER) && !ull_scan_is_enabled_get(0)) {
 100062c:	2000      	movs	r0, #0
	adv->is_enabled = 0U;
 100062e:	f36f 0300 	bfc	r3, #0, #1
 1000632:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
	if (IS_ENABLED(CONFIG_BT_OBSERVER) && !ull_scan_is_enabled_get(0)) {
 1000636:	f00a fbd1 	bl	100addc <ull_scan_is_enabled_get>
 100063a:	4680      	mov	r8, r0
 100063c:	2800      	cmp	r0, #0
 100063e:	f000 812f 	beq.w	10008a0 <ll_adv_enable+0x4e8>
		ull_filter_adv_scan_state_cb(0);
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */

	return 0;
 1000642:	f04f 0800 	mov.w	r8, #0
}
 1000646:	4640      	mov	r0, r8
 1000648:	b00f      	add	sp, #60	; 0x3c
 100064a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 100064e:	bf00      	nop
 1000650:	1afd498d 	.word	0x1afd498d
 1000654:	00000007 	.word	0x00000007
 1000658:	210019d0 	.word	0x210019d0
 100065c:	3b9aca00 	.word	0x3b9aca00
 1000660:	0100a689 	.word	0x0100a689
 1000664:	0100a0e1 	.word	0x0100a0e1
 1000668:	01018740 	.word	0x01018740
 100066c:	210019ec 	.word	0x210019ec
		link = ll_rx_link_alloc();
 1000670:	f009 fcb4 	bl	1009fdc <ll_rx_link_alloc>
		if (!link) {
 1000674:	4682      	mov	sl, r0
 1000676:	2800      	cmp	r0, #0
 1000678:	f000 8145 	beq.w	1000906 <ll_adv_enable+0x54e>
		node_rx = ll_rx_alloc();
 100067c:	f009 fcba 	bl	1009ff4 <ll_rx_alloc>
		if (!node_rx) {
 1000680:	4683      	mov	fp, r0
 1000682:	2800      	cmp	r0, #0
 1000684:	f000 8153 	beq.w	100092e <ll_adv_enable+0x576>
		conn = ll_conn_acquire();
 1000688:	f00a ff4e 	bl	100b528 <ll_conn_acquire>
		if (!conn) {
 100068c:	4605      	mov	r5, r0
 100068e:	2800      	cmp	r0, #0
 1000690:	f000 814a 	beq.w	1000928 <ll_adv_enable+0x570>
		conn_lll->handle = 0xFFFF;
 1000694:	f64f 73ff 	movw	r3, #65535	; 0xffff
		if (!conn_lll->link_tx_free) {
 1000698:	6f80      	ldr	r0, [r0, #120]	; 0x78
		conn_lll->handle = 0xFFFF;
 100069a:	85ab      	strh	r3, [r5, #44]	; 0x2c
		conn_lll = &conn->lll;
 100069c:	f105 031c 	add.w	r3, r5, #28
 10006a0:	930b      	str	r3, [sp, #44]	; 0x2c
		if (!conn_lll->link_tx_free) {
 10006a2:	2800      	cmp	r0, #0
 10006a4:	f000 812b 	beq.w	10008fe <ll_adv_enable+0x546>
		memq_init(conn_lll->link_tx_free, &conn_lll->memq_tx.head,
 10006a8:	f105 026c 	add.w	r2, r5, #108	; 0x6c
 10006ac:	f105 0168 	add.w	r1, r5, #104	; 0x68
 10006b0:	f005 fb0c 	bl	1005ccc <memq_init>
		conn_lll->data_chan_use = 0;
 10006b4:	2300      	movs	r3, #0
		conn_lll->max_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
 10006b6:	f04f 1e1b 	mov.w	lr, #1769499	; 0x1b001b
		conn_lll->rssi_latest = 0x7F;
 10006ba:	f04f 0c7f 	mov.w	ip, #127	; 0x7f
		conn->connect_expire = 6;
 10006be:	2006      	movs	r0, #6
		conn_lll->phy_tx = BIT(0);
 10006c0:	f8b5 2064 	ldrh.w	r2, [r5, #100]	; 0x64
		conn_lll->data_chan_sel = 0;
 10006c4:	f895 103d 	ldrb.w	r1, [r5, #61]	; 0x3d
		conn_lll->phy_tx = BIT(0);
 10006c8:	f422 62ef 	bic.w	r2, r2, #1912	; 0x778
 10006cc:	f022 0207 	bic.w	r2, r2, #7
 10006d0:	f442 7288 	orr.w	r2, r2, #272	; 0x110
 10006d4:	f042 0201 	orr.w	r2, r2, #1
 10006d8:	f8a5 2064 	strh.w	r2, [r5, #100]	; 0x64
		conn_lll->slave.latency_enabled = 0;
 10006dc:	f895 2040 	ldrb.w	r2, [r5, #64]	; 0x40
		conn_lll->data_chan_sel = 0;
 10006e0:	f001 013f 	and.w	r1, r1, #63	; 0x3f
		conn_lll->slave.latency_enabled = 0;
 10006e4:	f363 0200 	bfi	r2, r3, #0, #1
		conn_lll->data_chan_sel = 0;
 10006e8:	f061 017f 	orn	r1, r1, #127	; 0x7f
 10006ec:	f885 103d 	strb.w	r1, [r5, #61]	; 0x3d
		conn_lll->slave.latency_enabled = 0;
 10006f0:	f885 2040 	strb.w	r2, [r5, #64]	; 0x40
		conn->common.fex_valid = 0;
 10006f4:	f895 10dc 	ldrb.w	r1, [r5, #220]	; 0xdc
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
 10006f8:	f895 2122 	ldrb.w	r2, [r5, #290]	; 0x122
		conn->common.fex_valid = 0;
 10006fc:	f021 0103 	bic.w	r1, r1, #3
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
 1000700:	f022 0203 	bic.w	r2, r2, #3
		conn->common.fex_valid = 0;
 1000704:	f885 10dc 	strb.w	r1, [r5, #220]	; 0xdc
		conn->llcp_version.tx = conn->llcp_version.rx = 0;
 1000708:	f885 2122 	strb.w	r2, [r5, #290]	; 0x122
		conn_lll->max_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M);
 100070c:	4994      	ldr	r1, [pc, #592]	; (1000960 <ll_adv_enable+0x5a8>)
		conn->llcp_feature.features = LL_FEAT;
 100070e:	4a95      	ldr	r2, [pc, #596]	; (1000964 <ll_adv_enable+0x5ac>)
		conn_lll->slave.window_widening_event_us = 0;
 1000710:	e9c5 3313 	strd	r3, r3, [r5, #76]	; 0x4c
		conn_lll->data_chan_use = 0;
 1000714:	f885 303f 	strb.w	r3, [r5, #63]	; 0x3f
		conn_lll->latency_prepare = 0;
 1000718:	866b      	strh	r3, [r5, #50]	; 0x32
		conn_lll->latency_event = 0;
 100071a:	636b      	str	r3, [r5, #52]	; 0x34
		conn_lll->slave.window_size_prepare_us = 0;
 100071c:	656b      	str	r3, [r5, #84]	; 0x54
		conn->supervision_expire = 0;
 100071e:	f8a5 30c8 	strh.w	r3, [r5, #200]	; 0xc8
		conn->procedure_expire = 0;
 1000722:	f8a5 30cc 	strh.w	r3, [r5, #204]	; 0xcc
		conn->llcp_req = conn->llcp_ack = conn->llcp_type = 0;
 1000726:	f8a5 30e8 	strh.w	r3, [r5, #232]	; 0xe8
 100072a:	f885 30ea 	strb.w	r3, [r5, #234]	; 0xea
		conn->llcp_rx = NULL;
 100072e:	f8c5 3100 	str.w	r3, [r5, #256]	; 0x100
		conn->llcp_cu.req = conn->llcp_cu.ack = 0;
 1000732:	f8a5 3104 	strh.w	r3, [r5, #260]	; 0x104
		conn->llcp_feature.req = conn->llcp_feature.ack = 0;
 1000736:	f8a5 3118 	strh.w	r3, [r5, #280]	; 0x118
		conn->llcp_version.req = conn->llcp_version.ack = 0;
 100073a:	f8a5 3120 	strh.w	r3, [r5, #288]	; 0x120
		conn->llcp_terminate.reason_peer = 0;
 100073e:	f885 312b 	strb.w	r3, [r5, #299]	; 0x12b
		conn_lll->link_tx_free = NULL;
 1000742:	67ab      	str	r3, [r5, #120]	; 0x78
		conn_lll->max_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
 1000744:	f8c5 e05c 	str.w	lr, [r5, #92]	; 0x5c
		conn_lll->rssi_latest = 0x7F;
 1000748:	f885 c0c1 	strb.w	ip, [r5, #193]	; 0xc1
		conn->connect_expire = 6;
 100074c:	f8a5 00c4 	strh.w	r0, [r5, #196]	; 0xc4
		conn_lll->max_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M);
 1000750:	6629      	str	r1, [r5, #96]	; 0x60
		conn->llcp_feature.features = LL_FEAT;
 1000752:	f8c5 211c 	str.w	r2, [r5, #284]	; 0x11c
		conn->llcp_terminate.node_rx.hdr.link = link;
 1000756:	f8c5 a12c 	str.w	sl, [r5, #300]	; 0x12c
		conn_lll->packet_tx_head_len = 0;
 100075a:	f8a5 307c 	strh.w	r3, [r5, #124]	; 0x7c
		conn->llcp_conn_param.disabled = 0;
 100075e:	f895 c172 	ldrb.w	ip, [r5, #370]	; 0x172
		conn->llcp_length.disabled = 0U;
 1000762:	f895 019a 	ldrb.w	r0, [r5, #410]	; 0x19a
		conn_lll->sn = 0;
 1000766:	f895 107e 	ldrb.w	r1, [r5, #126]	; 0x7e
		conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
 100076a:	f895 2152 	ldrb.w	r2, [r5, #338]	; 0x152
		conn->llcp_conn_param.disabled = 0;
 100076e:	f363 1c04 	bfi	ip, r3, #4, #1
		conn->llcp_length.disabled = 0U;
 1000772:	f363 00c3 	bfi	r0, r3, #3, #1
		conn_lll->sn = 0;
 1000776:	f021 011f 	bic.w	r1, r1, #31
		conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
 100077a:	f022 0207 	bic.w	r2, r2, #7
		conn->llcp_enc.req = conn->llcp_enc.ack = 0U;
 100077e:	f8a5 3150 	strh.w	r3, [r5, #336]	; 0x150
		conn->llcp_conn_param.req = 0;
 1000782:	f8a5 3170 	strh.w	r3, [r5, #368]	; 0x170
		conn->llcp_length.req = conn->llcp_length.ack = 0U;
 1000786:	f8a5 3198 	strh.w	r3, [r5, #408]	; 0x198
		conn->llcp_length.cache.tx_octets = 0U;
 100078a:	f8a5 31a4 	strh.w	r3, [r5, #420]	; 0x1a4
		conn->llcp_conn_param.disabled = 0;
 100078e:	f885 c172 	strb.w	ip, [r5, #370]	; 0x172
		conn_lll->sn = 0;
 1000792:	f885 107e 	strb.w	r1, [r5, #126]	; 0x7e
		conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
 1000796:	f885 2152 	strb.w	r2, [r5, #338]	; 0x152
		conn->llcp_length.disabled = 0U;
 100079a:	f885 019a 	strb.w	r0, [r5, #410]	; 0x19a
		conn->default_tx_octets = ull_conn_default_tx_octets_get();
 100079e:	f00b fa4b 	bl	100bc38 <ull_conn_default_tx_octets_get>
 10007a2:	f8a5 00d6 	strh.w	r0, [r5, #214]	; 0xd6
		conn->default_tx_time = ull_conn_default_tx_time_get();
 10007a6:	f00b fa4d 	bl	100bc44 <ull_conn_default_tx_time_get>
		conn->llcp_phy.req = conn->llcp_phy.ack = 0;
 10007aa:	f8d5 11a8 	ldr.w	r1, [r5, #424]	; 0x1a8
 10007ae:	4a6e      	ldr	r2, [pc, #440]	; (1000968 <ll_adv_enable+0x5b0>)
		conn->default_tx_time = ull_conn_default_tx_time_get();
 10007b0:	f8a5 00d8 	strh.w	r0, [r5, #216]	; 0xd8
		conn->llcp_phy.req = conn->llcp_phy.ack = 0;
 10007b4:	400a      	ands	r2, r1
 10007b6:	f8c5 21a8 	str.w	r2, [r5, #424]	; 0x1a8
		conn->phy_pref_tx = ull_conn_default_phy_tx_get();
 10007ba:	f00b fa49 	bl	100bc50 <ull_conn_default_phy_tx_get>
 10007be:	f895 21ac 	ldrb.w	r2, [r5, #428]	; 0x1ac
 10007c2:	f360 0202 	bfi	r2, r0, #0, #3
 10007c6:	f885 21ac 	strb.w	r2, [r5, #428]	; 0x1ac
		conn->phy_pref_rx = ull_conn_default_phy_rx_get();
 10007ca:	f00b fa47 	bl	100bc5c <ull_conn_default_phy_rx_get>
		lll->conn = conn_lll;
 10007ce:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		adv->node_rx_cc_free = node_rx;
 10007d0:	e9c4 ab34 	strd	sl, fp, [r4, #208]	; 0xd0
		lll->conn = conn_lll;
 10007d4:	6263      	str	r3, [r4, #36]	; 0x24
	hdr->is_stop = 0U;
 10007d6:	2300      	movs	r3, #0
		conn->phy_pref_flags = 0;
 10007d8:	f895 11ac 	ldrb.w	r1, [r5, #428]	; 0x1ac
 10007dc:	0102      	lsls	r2, r0, #4
 10007de:	f895 0020 	ldrb.w	r0, [r5, #32]
 10007e2:	f002 0270 	and.w	r2, r2, #112	; 0x70
 10007e6:	f021 0178 	bic.w	r1, r1, #120	; 0x78
 10007ea:	430a      	orrs	r2, r1
 10007ec:	f363 0000 	bfi	r0, r3, #0, #1
		conn->tx_data = conn->tx_data_last = 0;
 10007f0:	e9c5 336f 	strd	r3, r3, [r5, #444]	; 0x1bc
		conn->tx_head = conn->tx_ctrl = conn->tx_ctrl_last =
 10007f4:	e9c5 336d 	strd	r3, r3, [r5, #436]	; 0x1b4
 10007f8:	e9c5 3305 	strd	r3, r3, [r5, #20]
 10007fc:	f8c5 31b0 	str.w	r3, [r5, #432]	; 0x1b0
	hdr->parent = parent;
 1000800:	61ed      	str	r5, [r5, #28]
		conn->phy_pref_flags = 0;
 1000802:	f885 21ac 	strb.w	r2, [r5, #428]	; 0x1ac
	hdr->is_stop = 0U;
 1000806:	f885 0020 	strb.w	r0, [r5, #32]
		err = lll_clock_wait();
 100080a:	f00f fbe3 	bl	100ffd4 <lll_clock_wait>
		if (err) {
 100080e:	2800      	cmp	r0, #0
 1000810:	f43f ae43 	beq.w	100049a <ll_adv_enable+0xe2>
			conn_release(adv);
 1000814:	f009 ffb0 	bl	100a778 <conn_release.constprop.0>
			return BT_HCI_ERR_HW_FAILURE;
 1000818:	f04f 0803 	mov.w	r8, #3
 100081c:	e616      	b.n	100044c <ll_adv_enable+0x94>
				ull_filter_rpa_update(false);
 100081e:	4640      	mov	r0, r8
 1000820:	f00e fb98 	bl	100ef54 <ull_filter_rpa_update>
 1000824:	e622      	b.n	100046c <ll_adv_enable+0xb4>
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
 1000826:	2791      	movs	r7, #145	; 0x91
 1000828:	a34b      	add	r3, pc, #300	; (adr r3, 1000958 <ll_adv_enable+0x5a0>)
 100082a:	e9d3 2300 	ldrd	r2, r3, [r3]
		ret = ticker_start_ext(
 100082e:	f64f 7cff 	movw	ip, #65535	; 0xffff
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
 1000832:	484e      	ldr	r0, [pc, #312]	; (100096c <ll_adv_enable+0x5b4>)
		ll_adv_ticker_ext[handle].ticks_slot_window =
 1000834:	f8df e148 	ldr.w	lr, [pc, #328]	; 1000980 <ll_adv_enable+0x5c8>
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
 1000838:	fba9 0100 	umull	r0, r1, r9, r0
 100083c:	fb07 1109 	mla	r1, r7, r9, r1
		const u32_t ticks_slot = adv->evt.ticks_slot +
 1000840:	68e7      	ldr	r7, [r4, #12]
		ret = ticker_start_ext(
 1000842:	9406      	str	r4, [sp, #24]
 1000844:	9704      	str	r7, [sp, #16]
			ULL_ADV_RANDOM_DELAY + ticks_slot;
 1000846:	f207 1747 	addw	r7, r7, #327	; 0x147
		ret = ticker_start_ext(
 100084a:	9502      	str	r5, [sp, #8]
		ll_adv_ticker_ext[handle].ticks_slot_window =
 100084c:	f8ce 7000 	str.w	r7, [lr]
		ret = ticker_start_ext(
 1000850:	4f47      	ldr	r7, [pc, #284]	; (1000970 <ll_adv_enable+0x5b8>)
 1000852:	f8cd c00c 	str.w	ip, [sp, #12]
 1000856:	f8df c12c 	ldr.w	ip, [pc, #300]	; 1000984 <ll_adv_enable+0x5cc>
 100085a:	9707      	str	r7, [sp, #28]
 100085c:	af0c      	add	r7, sp, #48	; 0x30
 100085e:	f8cd e024 	str.w	lr, [sp, #36]	; 0x24
 1000862:	f8cd c014 	str.w	ip, [sp, #20]
 1000866:	9708      	str	r7, [sp, #32]
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
 1000868:	f7ff fc26 	bl	10000b8 <__aeabi_uldivmod>
		ret = ticker_start_ext(
 100086c:	4633      	mov	r3, r6
				   HAL_TICKER_US_TO_TICKS((u64_t)interval *
 100086e:	e9cd 5000 	strd	r5, r0, [sp]
		ret = ticker_start_ext(
 1000872:	2202      	movs	r2, #2
 1000874:	4628      	mov	r0, r5
 1000876:	2103      	movs	r1, #3
 1000878:	f006 fc28 	bl	10070cc <ticker_start_ext>
	ret = ull_ticker_status_take(ret, &ret_cb);
 100087c:	4639      	mov	r1, r7
 100087e:	f009 fc35 	bl	100a0ec <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
 1000882:	2800      	cmp	r0, #0
 1000884:	f47f ae84 	bne.w	1000590 <ll_adv_enable+0x1d8>
	adv->is_enabled = 1;
 1000888:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
 100088c:	f043 0301 	orr.w	r3, r3, #1
 1000890:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
	if (IS_ENABLED(CONFIG_BT_OBSERVER) && !ull_scan_is_enabled_get(0)) {
 1000894:	f00a faa2 	bl	100addc <ull_scan_is_enabled_get>
 1000898:	2800      	cmp	r0, #0
 100089a:	f47f aed2 	bne.w	1000642 <ll_adv_enable+0x28a>
		ull_filter_adv_scan_state_cb(BIT(0));
 100089e:	2001      	movs	r0, #1
 10008a0:	f00e fa70 	bl	100ed84 <ull_filter_adv_scan_state_cb>
 10008a4:	e5d2      	b.n	100044c <ll_adv_enable+0x94>
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 10008a6:	f24a 31d8 	movw	r1, #41944	; 0xa3d8
		ret_cb = TICKER_STATUS_BUSY;
 10008aa:	f04f 0c02 	mov.w	ip, #2
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 10008ae:	4a31      	ldr	r2, [pc, #196]	; (1000974 <ll_adv_enable+0x5bc>)
 10008b0:	9100      	str	r1, [sp, #0]
 10008b2:	9205      	str	r2, [sp, #20]
 10008b4:	4633      	mov	r3, r6
 10008b6:	2201      	movs	r2, #1
 10008b8:	2103      	movs	r1, #3
 10008ba:	e9cd 5707 	strd	r5, r7, [sp, #28]
 10008be:	e9cd 0003 	strd	r0, r0, [sp, #12]
 10008c2:	e9cd 0001 	strd	r0, r0, [sp, #4]
 10008c6:	9406      	str	r4, [sp, #24]
		ret_cb = TICKER_STATUS_BUSY;
 10008c8:	f8cd c030 	str.w	ip, [sp, #48]	; 0x30
		ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 10008cc:	f006 fc4c 	bl	1007168 <ticker_start>
 10008d0:	e7d4      	b.n	100087c <ll_adv_enable+0x4c4>
			return BT_HCI_ERR_INVALID_PARAM;
 10008d2:	f04f 0812 	mov.w	r8, #18
 10008d6:	e5b9      	b.n	100044c <ll_adv_enable+0x94>
			} else if (pdu_adv->type == PDU_ADV_TYPE_SCAN_IND) {
 10008d8:	2a06      	cmp	r2, #6
 10008da:	f43f adfa 	beq.w	10004d2 <ll_adv_enable+0x11a>
 10008de:	f44f 73da 	mov.w	r3, #436	; 0x1b4
 10008e2:	f44f 721b 	mov.w	r2, #620	; 0x26c
 10008e6:	e5fb      	b.n	10004e0 <ll_adv_enable+0x128>
 10008e8:	f44f 73f2 	mov.w	r3, #484	; 0x1e4
 10008ec:	f44f 727f 	mov.w	r2, #1020	; 0x3fc
 10008f0:	e5f6      	b.n	10004e0 <ll_adv_enable+0x128>
	LL_ASSERT(!ret);
 10008f2:	f44f 61a1 	mov.w	r1, #1288	; 0x508
 10008f6:	4820      	ldr	r0, [pc, #128]	; (1000978 <ll_adv_enable+0x5c0>)
 10008f8:	f002 fe46 	bl	1003588 <bt_ctlr_assert_handle>
 10008fc:	e686      	b.n	100060c <ll_adv_enable+0x254>
			conn_lll->link_tx_free = &conn_lll->link_tx;
 10008fe:	f105 0070 	add.w	r0, r5, #112	; 0x70
 1000902:	67a8      	str	r0, [r5, #120]	; 0x78
 1000904:	e6d0      	b.n	10006a8 <ll_adv_enable+0x2f0>
			return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
 1000906:	f04f 0807 	mov.w	r8, #7
 100090a:	e59f      	b.n	100044c <ll_adv_enable+0x94>
		mark = ull_disable_mark(adv);
 100090c:	481b      	ldr	r0, [pc, #108]	; (100097c <ll_adv_enable+0x5c4>)
 100090e:	f009 fbfb 	bl	100a108 <ull_disable_mark>
		LL_ASSERT(mark == adv);
 1000912:	4284      	cmp	r4, r0
 1000914:	f43f ad98 	beq.w	1000448 <ll_adv_enable+0x90>
 1000918:	f240 5102 	movw	r1, #1282	; 0x502
 100091c:	4816      	ldr	r0, [pc, #88]	; (1000978 <ll_adv_enable+0x5c0>)
 100091e:	f002 fe33 	bl	1003588 <bt_ctlr_assert_handle>
		return BT_HCI_ERR_CMD_DISALLOWED;
 1000922:	f04f 080c 	mov.w	r8, #12
 1000926:	e591      	b.n	100044c <ll_adv_enable+0x94>
			ll_rx_release(node_rx);
 1000928:	4658      	mov	r0, fp
 100092a:	f009 fb69 	bl	100a000 <ll_rx_release>
			ll_rx_link_release(link);
 100092e:	4650      	mov	r0, sl
 1000930:	f009 fb5a 	bl	1009fe8 <ll_rx_link_release>
			return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
 1000934:	f04f 0807 	mov.w	r8, #7
 1000938:	e588      	b.n	100044c <ll_adv_enable+0x94>
			mark = ull_disable_mark(adv);
 100093a:	4810      	ldr	r0, [pc, #64]	; (100097c <ll_adv_enable+0x5c4>)
 100093c:	f009 fbe4 	bl	100a108 <ull_disable_mark>
			LL_ASSERT(mark == adv);
 1000940:	4284      	cmp	r4, r0
 1000942:	f43f ad81 	beq.w	1000448 <ll_adv_enable+0x90>
 1000946:	f240 41f3 	movw	r1, #1267	; 0x4f3
 100094a:	480b      	ldr	r0, [pc, #44]	; (1000978 <ll_adv_enable+0x5c0>)
 100094c:	f002 fe1c 	bl	1003588 <bt_ctlr_assert_handle>
 1000950:	f04f 080c 	mov.w	r8, #12
 1000954:	e57a      	b.n	100044c <ll_adv_enable+0x94>
 1000956:	bf00      	nop
 1000958:	1afd498d 	.word	0x1afd498d
 100095c:	00000007 	.word	0x00000007
 1000960:	01480148 	.word	0x01480148
 1000964:	000149ff 	.word	0x000149ff
 1000968:	f6ff0000 	.word	0xf6ff0000
 100096c:	84e72a00 	.word	0x84e72a00
 1000970:	0100a0e1 	.word	0x0100a0e1
 1000974:	0100a629 	.word	0x0100a629
 1000978:	01018740 	.word	0x01018740
 100097c:	210019d0 	.word	0x210019d0
 1000980:	21001ab4 	.word	0x21001ab4
 1000984:	0100a689 	.word	0x0100a689

01000988 <ll_scan_params_set>:
#define BT_CTLR_SCAN_MAX 1
static struct ll_scan_set ll_scan[BT_CTLR_SCAN_MAX];

u8_t ll_scan_params_set(u8_t type, u16_t interval, u16_t window,
			u8_t own_addr_type, u8_t filter_policy)
{
 1000988:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
struct ll_scan_set *ull_scan_is_disabled_get(u16_t handle)
{
	struct ll_scan_set *scan;

	scan = ull_scan_set_get(handle);
	if (!scan || scan->is_enabled) {
 100098c:	4d1a      	ldr	r5, [pc, #104]	; (10009f8 <ll_scan_params_set+0x70>)
{
 100098e:	f89d 4018 	ldrb.w	r4, [sp, #24]
	if (!scan || scan->is_enabled) {
 1000992:	f895 7048 	ldrb.w	r7, [r5, #72]	; 0x48
 1000996:	f017 0601 	ands.w	r6, r7, #1
 100099a:	d123      	bne.n	10009e4 <ll_scan_params_set+0x5c>
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
 100099c:	f04f 0891 	mov.w	r8, #145	; 0x91
 10009a0:	4686      	mov	lr, r0
 10009a2:	468c      	mov	ip, r1
 10009a4:	4815      	ldr	r0, [pc, #84]	; (10009fc <ll_scan_params_set+0x74>)
	lll->filter_policy = filter_policy;
 10009a6:	00e4      	lsls	r4, r4, #3
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
 10009a8:	fba2 0100 	umull	r0, r1, r2, r0
 10009ac:	fb08 1102 	mla	r1, r8, r2, r1
	lll->filter_policy = filter_policy;
 10009b0:	f895 2032 	ldrb.w	r2, [r5, #50]	; 0x32
 10009b4:	f004 0418 	and.w	r4, r4, #24
 10009b8:	ea44 14ce 	orr.w	r4, r4, lr, lsl #7
	scan->own_addr_type = own_addr_type;
 10009bc:	f363 0742 	bfi	r7, r3, #1, #2
	lll->filter_policy = filter_policy;
 10009c0:	f002 0367 	and.w	r3, r2, #103	; 0x67
 10009c4:	431c      	orrs	r4, r3
	scan->own_addr_type = own_addr_type;
 10009c6:	f885 7048 	strb.w	r7, [r5, #72]	; 0x48
	lll->interval = interval;
 10009ca:	f8a5 c042 	strh.w	ip, [r5, #66]	; 0x42
	lll->filter_policy = filter_policy;
 10009ce:	f885 4032 	strb.w	r4, [r5, #50]	; 0x32
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
 10009d2:	a307      	add	r3, pc, #28	; (adr r3, 10009f0 <ll_scan_params_set+0x68>)
 10009d4:	e9d3 2300 	ldrd	r2, r3, [r3]
 10009d8:	f7ff fb6e 	bl	10000b8 <__aeabi_uldivmod>
 10009dc:	6468      	str	r0, [r5, #68]	; 0x44
}
 10009de:	4630      	mov	r0, r6
 10009e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 10009e4:	260c      	movs	r6, #12
}
 10009e6:	4630      	mov	r0, r6
 10009e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 10009ec:	f3af 8000 	nop.w
 10009f0:	1afd498d 	.word	0x1afd498d
 10009f4:	00000007 	.word	0x00000007
 10009f8:	21001ad8 	.word	0x21001ad8
 10009fc:	84e72a00 	.word	0x84e72a00

01000a00 <ull_scan_params_set>:
{
 1000a00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1000a02:	461e      	mov	r6, r3
 1000a04:	4605      	mov	r5, r0
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
 1000a06:	f04f 0e91 	mov.w	lr, #145	; 0x91
{
 1000a0a:	468c      	mov	ip, r1
 1000a0c:	4617      	mov	r7, r2
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
 1000a0e:	a30d      	add	r3, pc, #52	; (adr r3, 1000a44 <ull_scan_params_set+0x44>)
 1000a10:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000a14:	480a      	ldr	r0, [pc, #40]	; (1000a40 <ull_scan_params_set+0x40>)
{
 1000a16:	f89d 4018 	ldrb.w	r4, [sp, #24]
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
 1000a1a:	fba6 0100 	umull	r0, r1, r6, r0
	lll->filter_policy = filter_policy;
 1000a1e:	00e4      	lsls	r4, r4, #3
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
 1000a20:	fb0e 1106 	mla	r1, lr, r6, r1
	lll->filter_policy = filter_policy;
 1000a24:	7dae      	ldrb	r6, [r5, #22]
 1000a26:	f004 0418 	and.w	r4, r4, #24
 1000a2a:	ea44 14cc 	orr.w	r4, r4, ip, lsl #7
 1000a2e:	f006 0667 	and.w	r6, r6, #103	; 0x67
 1000a32:	4334      	orrs	r4, r6
	lll->interval = interval;
 1000a34:	84ef      	strh	r7, [r5, #38]	; 0x26
	lll->filter_policy = filter_policy;
 1000a36:	75ac      	strb	r4, [r5, #22]
	lll->ticks_window = HAL_TICKER_US_TO_TICKS((u64_t)window * 625U);
 1000a38:	f7ff fb3e 	bl	10000b8 <__aeabi_uldivmod>
 1000a3c:	62a8      	str	r0, [r5, #40]	; 0x28
}
 1000a3e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 1000a40:	84e72a00 	.word	0x84e72a00
 1000a44:	1afd498d 	.word	0x1afd498d
 1000a48:	00000007 	.word	0x00000007
 1000a4c:	00000000 	.word	0x00000000

01000a50 <ull_scan_enable>:
{
 1000a50:	e92d 4df0 	stmdb	sp!, {r4, r5, r6, r7, r8, sl, fp, lr}
 1000a54:	4604      	mov	r4, r0
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 1000a56:	2202      	movs	r2, #2
	lll->chan = 0;
 1000a58:	f890 3032 	ldrb.w	r3, [r0, #50]	; 0x32
	lll->init_addr_type = scan->own_addr_type;
 1000a5c:	f890 0048 	ldrb.w	r0, [r0, #72]	; 0x48
 1000a60:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 1000a64:	f3c0 0040 	ubfx	r0, r0, #1, #1
 1000a68:	f360 1386 	bfi	r3, r0, #6, #1
 1000a6c:	2500      	movs	r5, #0
{
 1000a6e:	b08e      	sub	sp, #56	; 0x38
	lll->init_addr_type = scan->own_addr_type;
 1000a70:	f884 3032 	strb.w	r3, [r4, #50]	; 0x32
	ll_addr_get(lll->init_addr_type, lll->init_addr);
 1000a74:	f104 0135 	add.w	r1, r4, #53	; 0x35
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 1000a78:	920b      	str	r2, [sp, #44]	; 0x2c
	ll_addr_get(lll->init_addr_type, lll->init_addr);
 1000a7a:	f006 fc1b 	bl	10072b4 <ll_addr_get>
	ticks_interval = HAL_TICKER_US_TO_TICKS((u64_t)lll->interval * 625U);
 1000a7e:	2391      	movs	r3, #145	; 0x91
 1000a80:	f8b4 7042 	ldrh.w	r7, [r4, #66]	; 0x42
 1000a84:	4848      	ldr	r0, [pc, #288]	; (1000ba8 <ull_scan_enable+0x158>)
 1000a86:	f894 6020 	ldrb.w	r6, [r4, #32]
 1000a8a:	fba7 0100 	umull	r0, r1, r7, r0
 1000a8e:	f365 0600 	bfi	r6, r5, #0, #1
 1000a92:	fb03 1107 	mla	r1, r3, r7, r1
 1000a96:	a342      	add	r3, pc, #264	; (adr r3, 1000ba0 <ull_scan_enable+0x150>)
 1000a98:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000a9c:	e9c4 5505 	strd	r5, r5, [r4, #20]
 1000aa0:	f884 6020 	strb.w	r6, [r4, #32]
	hdr->parent = parent;
 1000aa4:	61e4      	str	r4, [r4, #28]
 1000aa6:	f7ff fb07 	bl	10000b8 <__aeabi_uldivmod>
 1000aaa:	4606      	mov	r6, r0
	scan->evt.ticks_xtal_to_start =
 1000aac:	2131      	movs	r1, #49	; 0x31
	if ((lll->ticks_window +
 1000aae:	6c63      	ldr	r3, [r4, #68]	; 0x44
	    (ticks_interval -
 1000ab0:	f1a6 0231 	sub.w	r2, r6, #49	; 0x31
	if ((lll->ticks_window +
 1000ab4:	3309      	adds	r3, #9
 1000ab6:	4293      	cmp	r3, r2
	scan->evt.ticks_preempt_to_start =
 1000ab8:	e9c4 5501 	strd	r5, r5, [r4, #4]
		lll->ticks_window = 0;
 1000abc:	bf28      	it	cs
 1000abe:	6465      	strcs	r5, [r4, #68]	; 0x44
	scan->evt.ticks_xtal_to_start =
 1000ac0:	6021      	str	r1, [r4, #0]
		scan->evt.ticks_slot =
 1000ac2:	bf34      	ite	cc
 1000ac4:	60e3      	strcc	r3, [r4, #12]
		scan->evt.ticks_slot =
 1000ac6:	60e2      	strcs	r2, [r4, #12]
	ticks_anchor = ticker_ticks_now_get();
 1000ac8:	f006 fbee 	bl	10072a8 <ticker_ticks_now_get>
	if (!lll->conn) {
 1000acc:	6a67      	ldr	r7, [r4, #36]	; 0x24
	ticks_anchor = ticker_ticks_now_get();
 1000ace:	4605      	mov	r5, r0
	if (!lll->conn) {
 1000ad0:	2f00      	cmp	r7, #0
 1000ad2:	d042      	beq.n	1000b5a <ull_scan_enable+0x10a>
			   HAL_TICKER_REMAINDER((u64_t)lll->interval * 625U),
 1000ad4:	a332      	add	r3, pc, #200	; (adr r3, 1000ba0 <ull_scan_enable+0x150>)
 1000ad6:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000ada:	2791      	movs	r7, #145	; 0x91
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000adc:	f04f 0800 	mov.w	r8, #0
			   HAL_TICKER_REMAINDER((u64_t)lll->interval * 625U),
 1000ae0:	f8b4 a042 	ldrh.w	sl, [r4, #66]	; 0x42
 1000ae4:	4830      	ldr	r0, [pc, #192]	; (1000ba8 <ull_scan_enable+0x158>)
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000ae6:	9406      	str	r4, [sp, #24]
			   HAL_TICKER_REMAINDER((u64_t)lll->interval * 625U),
 1000ae8:	fbaa 0100 	umull	r0, r1, sl, r0
 1000aec:	fb07 110a 	mla	r1, r7, sl, r1
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000af0:	4f2e      	ldr	r7, [pc, #184]	; (1000bac <ull_scan_enable+0x15c>)
 1000af2:	f8cd 800c 	str.w	r8, [sp, #12]
 1000af6:	9707      	str	r7, [sp, #28]
 1000af8:	68e7      	ldr	r7, [r4, #12]
 1000afa:	f8df c0b8 	ldr.w	ip, [pc, #184]	; 1000bb4 <ull_scan_enable+0x164>
 1000afe:	e9cd 7c04 	strd	r7, ip, [sp, #16]
 1000b02:	af0b      	add	r7, sp, #44	; 0x2c
 1000b04:	9708      	str	r7, [sp, #32]
			   HAL_TICKER_REMAINDER((u64_t)lll->interval * 625U),
 1000b06:	f7ff fad7 	bl	10000b8 <__aeabi_uldivmod>
 1000b0a:	4610      	mov	r0, r2
 1000b0c:	4619      	mov	r1, r3
 1000b0e:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 1000b12:	2300      	movs	r3, #0
 1000b14:	f7ff fad0 	bl	10000b8 <__aeabi_uldivmod>
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000b18:	462b      	mov	r3, r5
 1000b1a:	2204      	movs	r2, #4
 1000b1c:	2103      	movs	r1, #3
 1000b1e:	9002      	str	r0, [sp, #8]
 1000b20:	f8cd 8000 	str.w	r8, [sp]
 1000b24:	4640      	mov	r0, r8
 1000b26:	9601      	str	r6, [sp, #4]
 1000b28:	f006 fb1e 	bl	1007168 <ticker_start>
	ret = ull_ticker_status_take(ret, &ret_cb);
 1000b2c:	4639      	mov	r1, r7
 1000b2e:	f009 fadd 	bl	100a0ec <ull_ticker_status_take>
	if (ret != TICKER_STATUS_SUCCESS) {
 1000b32:	4605      	mov	r5, r0
 1000b34:	b968      	cbnz	r0, 1000b52 <ull_scan_enable+0x102>
	scan->is_enabled = 1U;
 1000b36:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 1000b3a:	f043 0301 	orr.w	r3, r3, #1
 1000b3e:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
	if (!ull_adv_is_enabled_get(0))
 1000b42:	f00a f80b 	bl	100ab5c <ull_adv_is_enabled_get>
 1000b46:	4604      	mov	r4, r0
 1000b48:	b300      	cbz	r0, 1000b8c <ull_scan_enable+0x13c>
	return 0;
 1000b4a:	4628      	mov	r0, r5
}
 1000b4c:	b00e      	add	sp, #56	; 0x38
 1000b4e:	e8bd 8df0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, fp, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 1000b52:	200c      	movs	r0, #12
}
 1000b54:	b00e      	add	sp, #56	; 0x38
 1000b56:	e8bd 8df0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, fp, pc}
		ull_sched_after_mstr_slot_get(TICKER_USER_ID_THREAD,
 1000b5a:	68e1      	ldr	r1, [r4, #12]
 1000b5c:	2003      	movs	r0, #3
 1000b5e:	3131      	adds	r1, #49	; 0x31
 1000b60:	ab0d      	add	r3, sp, #52	; 0x34
 1000b62:	aa0c      	add	r2, sp, #48	; 0x30
		u32_t offset_us = 0U;
 1000b64:	e9cd 770c 	strd	r7, r7, [sp, #48]	; 0x30
		ull_sched_after_mstr_slot_get(TICKER_USER_ID_THREAD,
 1000b68:	f00d ff42 	bl	100e9f0 <ull_sched_after_mstr_slot_get>
		if (offset_us) {
 1000b6c:	990d      	ldr	r1, [sp, #52]	; 0x34
 1000b6e:	2900      	cmp	r1, #0
 1000b70:	d0b0      	beq.n	1000ad4 <ull_scan_enable+0x84>
				       HAL_TICKER_US_TO_TICKS(offset_us);
 1000b72:	a30b      	add	r3, pc, #44	; (adr r3, 1000ba0 <ull_scan_enable+0x150>)
 1000b74:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000b78:	480d      	ldr	r0, [pc, #52]	; (1000bb0 <ull_scan_enable+0x160>)
 1000b7a:	fba1 0100 	umull	r0, r1, r1, r0
 1000b7e:	f7ff fa9b 	bl	10000b8 <__aeabi_uldivmod>
			ticks_anchor = ticks_ref +
 1000b82:	9d0c      	ldr	r5, [sp, #48]	; 0x30
				       HAL_TICKER_US_TO_TICKS(offset_us);
 1000b84:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			ticks_anchor = ticks_ref +
 1000b88:	4405      	add	r5, r0
 1000b8a:	e7a3      	b.n	1000ad4 <ull_scan_enable+0x84>
		ull_filter_adv_scan_state_cb(BIT(1));
 1000b8c:	2002      	movs	r0, #2
 1000b8e:	f00e f8f9 	bl	100ed84 <ull_filter_adv_scan_state_cb>
	return 0;
 1000b92:	4620      	mov	r0, r4
}
 1000b94:	b00e      	add	sp, #56	; 0x38
 1000b96:	e8bd 8df0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, fp, pc}
 1000b9a:	bf00      	nop
 1000b9c:	f3af 8000 	nop.w
 1000ba0:	1afd498d 	.word	0x1afd498d
 1000ba4:	00000007 	.word	0x00000007
 1000ba8:	84e72a00 	.word	0x84e72a00
 1000bac:	0100a0e1 	.word	0x0100a0e1
 1000bb0:	3b9aca00 	.word	0x3b9aca00
 1000bb4:	0100abb1 	.word	0x0100abb1

01000bb8 <ull_conn_llcp>:
	return 0;
}

int ull_conn_llcp(struct ll_conn *conn, u32_t ticks_at_expire, u16_t lazy)
{
	LL_ASSERT(conn->lll.handle != 0xFFFF);
 1000bb8:	f64f 73ff 	movw	r3, #65535	; 0xffff
{
 1000bbc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	LL_ASSERT(conn->lll.handle != 0xFFFF);
 1000bc0:	8d87      	ldrh	r7, [r0, #44]	; 0x2c
{
 1000bc2:	4604      	mov	r4, r0
	LL_ASSERT(conn->lll.handle != 0xFFFF);
 1000bc4:	429f      	cmp	r7, r3
{
 1000bc6:	460e      	mov	r6, r1
 1000bc8:	4615      	mov	r5, r2
 1000bca:	b08d      	sub	sp, #52	; 0x34
	LL_ASSERT(conn->lll.handle != 0xFFFF);
 1000bcc:	f000 8089 	beq.w	1000ce2 <ull_conn_llcp+0x12a>

	/* Check if no other procedure with instant is requested and not in
	 * Encryption setup.
	 */
	if ((conn->llcp_ack == conn->llcp_req) &&
 1000bd0:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
 1000bd4:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 1000bd8:	429a      	cmp	r2, r3
 1000bda:	d00e      	beq.n	1000bfa <ull_conn_llcp+0x42>
	}

	/* Check if procedures with instant or encryption setup is requested or
	 * active.
	 */
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
 1000bdc:	1a9b      	subs	r3, r3, r2
 1000bde:	f003 0303 	and.w	r3, r3, #3
 1000be2:	2b02      	cmp	r3, #2
 1000be4:	d01b      	beq.n	1000c1e <ull_conn_llcp+0x66>
			break;
		}
	}

	/* Terminate Procedure Request */
	if (conn->llcp_terminate.ack != conn->llcp_terminate.req) {
 1000be6:	f894 2129 	ldrb.w	r2, [r4, #297]	; 0x129
 1000bea:	f894 3128 	ldrb.w	r3, [r4, #296]	; 0x128
 1000bee:	429a      	cmp	r2, r3
 1000bf0:	d130      	bne.n	1000c54 <ull_conn_llcp+0x9c>
				conn->procedure_expire++;
			}
		}
	}

	return 0;
 1000bf2:	2000      	movs	r0, #0
}
 1000bf4:	b00d      	add	sp, #52	; 0x34
 1000bf6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	    !conn->llcp_enc.pause_rx) {
 1000bfa:	f894 0152 	ldrb.w	r0, [r4, #338]	; 0x152
	if ((conn->llcp_ack == conn->llcp_req) &&
 1000bfe:	f010 0801 	ands.w	r8, r0, #1
 1000c02:	d1f0      	bne.n	1000be6 <ull_conn_llcp+0x2e>
		if (conn->llcp_cu.ack != conn->llcp_cu.req) {
 1000c04:	f894 1105 	ldrb.w	r1, [r4, #261]	; 0x105
 1000c08:	f894 7104 	ldrb.w	r7, [r4, #260]	; 0x104
 1000c0c:	428f      	cmp	r7, r1
 1000c0e:	f000 836b 	beq.w	10012e8 <ull_conn_llcp+0x730>
			conn->llcp_type = LLCP_CONN_UPD;
 1000c12:	2101      	movs	r1, #1
			conn->llcp_ack -= 2U;
 1000c14:	1e93      	subs	r3, r2, #2
 1000c16:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
			conn->llcp_type = LLCP_CONN_UPD;
 1000c1a:	f884 10ea 	strb.w	r1, [r4, #234]	; 0xea
		} else if (conn->llcp_length.ack != conn->llcp_length.req) {
 1000c1e:	f894 3198 	ldrb.w	r3, [r4, #408]	; 0x198
 1000c22:	f894 2199 	ldrb.w	r2, [r4, #409]	; 0x199
 1000c26:	429a      	cmp	r2, r3
 1000c28:	d006      	beq.n	1000c38 <ull_conn_llcp+0x80>
			if ((conn->llcp_length.state ==
 1000c2a:	f894 019a 	ldrb.w	r0, [r4, #410]	; 0x19a
 1000c2e:	f000 0206 	and.w	r2, r0, #6
 1000c32:	2a04      	cmp	r2, #4
 1000c34:	f000 83a2 	beq.w	100137c <ull_conn_llcp+0x7c4>
		switch (conn->llcp_type) {
 1000c38:	f894 70ea 	ldrb.w	r7, [r4, #234]	; 0xea
 1000c3c:	1e7b      	subs	r3, r7, #1
 1000c3e:	2b05      	cmp	r3, #5
 1000c40:	f200 834c 	bhi.w	10012dc <ull_conn_llcp+0x724>
 1000c44:	e8df f013 	tbh	[pc, r3, lsl #1]
 1000c48:	02e30064 	.word	0x02e30064
 1000c4c:	034a028a 	.word	0x034a028a
 1000c50:	01ad030d 	.word	0x01ad030d
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1000c54:	482c      	ldr	r0, [pc, #176]	; (1000d08 <ull_conn_llcp+0x150>)
 1000c56:	f004 ffe3 	bl	1005c20 <mem_acquire>
		if (tx) {
 1000c5a:	b358      	cbz	r0, 1000cb4 <ull_conn_llcp+0xfc>
			pdu_tx->len = offsetof(struct pdu_data_llctrl,
 1000c5c:	2202      	movs	r2, #2
			conn->llcp_terminate.ack = conn->llcp_terminate.req;
 1000c5e:	f894 3128 	ldrb.w	r3, [r4, #296]	; 0x128
 1000c62:	f884 3129 	strb.w	r3, [r4, #297]	; 0x129
			pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 1000c66:	7903      	ldrb	r3, [r0, #4]
			pdu_tx->len = offsetof(struct pdu_data_llctrl,
 1000c68:	7142      	strb	r2, [r0, #5]
			pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 1000c6a:	f043 0303 	orr.w	r3, r3, #3
 1000c6e:	7103      	strb	r3, [r0, #4]
			pdu_tx->llctrl.opcode =
 1000c70:	71c2      	strb	r2, [r0, #7]
			pdu_tx->llctrl.terminate_ind.error_code =
 1000c72:	f894 212a 	ldrb.w	r2, [r4, #298]	; 0x12a
					 struct node_tx *tx, bool pause)
{
	/* check if a packet was tx-ed and not acked by peer */
	if (
	    /* data/ctrl packet is in the head */
	    conn->tx_head &&
 1000c76:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
			pdu_tx->llctrl.terminate_ind.error_code =
 1000c7a:	7202      	strb	r2, [r0, #8]
	if (
 1000c7c:	b32b      	cbz	r3, 1000cca <ull_conn_llcp+0x112>
#if defined(CONFIG_BT_CTLR_LE_ENC)
	    !conn->llcp_enc.pause_tx &&
 1000c7e:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
	    conn->tx_head &&
 1000c82:	0791      	lsls	r1, r2, #30
 1000c84:	d421      	bmi.n	1000cca <ull_conn_llcp+0x112>
#endif /* CONFIG_BT_CTLR_LE_ENC */
#if defined(CONFIG_BT_CTLR_PHY)
	    !conn->llcp_phy.pause_tx &&
 1000c86:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
 1000c8a:	07d2      	lsls	r2, r2, #31
 1000c8c:	d41d      	bmi.n	1000cca <ull_conn_llcp+0x112>

		/* if data transmitted once, keep it at head of the tx list,
		 * as we will insert a ctrl after it, hence advance the
		 * data pointer
		 */
		if (conn->tx_head == conn->tx_data) {
 1000c8e:	f8d4 21bc 	ldr.w	r2, [r4, #444]	; 0x1bc
 1000c92:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 1000c94:	bf04      	itt	eq
 1000c96:	681a      	ldreq	r2, [r3, #0]
 1000c98:	f8c4 21bc 	streq.w	r2, [r4, #444]	; 0x1bc
		}

		/* if no ctrl packet already queued, new ctrl added will be
		 * the ctrl pointer and is inserted after head.
		 */
		if (!conn->tx_ctrl) {
 1000c9c:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 1000ca0:	b9b2      	cbnz	r2, 1000cd0 <ull_conn_llcp+0x118>
			tx->next = conn->tx_head->next;
 1000ca2:	681a      	ldr	r2, [r3, #0]
 1000ca4:	6002      	str	r2, [r0, #0]
			conn->tx_head->next = tx;
 1000ca6:	6018      	str	r0, [r3, #0]
			 * control PDU in Encryption Procedure that is not
			 * implicitly paused, will set the control and control
			 * last marker.
			 */
			if (!pause) {
				conn->tx_ctrl = tx;
 1000ca8:	6803      	ldr	r3, [r0, #0]
				conn->tx_ctrl_last = tx;
 1000caa:	e9c4 006d 	strd	r0, r0, [r4, #436]	; 0x1b4
			ctrl_tx_last_enqueue(conn, tx);
		}
	}

	/* Update last pointer if ctrl added at end of tx list */
	if (!tx->next) {
 1000cae:	b90b      	cbnz	r3, 1000cb4 <ull_conn_llcp+0xfc>
		conn->tx_data_last = tx;
 1000cb0:	f8c4 01c0 	str.w	r0, [r4, #448]	; 0x1c0
		if (!conn->procedure_expire) {
 1000cb4:	f8b4 00cc 	ldrh.w	r0, [r4, #204]	; 0xcc
 1000cb8:	2800      	cmp	r0, #0
 1000cba:	d19a      	bne.n	1000bf2 <ull_conn_llcp+0x3a>
			conn->procedure_expire = conn->supervision_reload;
 1000cbc:	f8b4 30c6 	ldrh.w	r3, [r4, #198]	; 0xc6
			if (conn->procedure_expire <= 1U) {
 1000cc0:	2b01      	cmp	r3, #1
 1000cc2:	d914      	bls.n	1000cee <ull_conn_llcp+0x136>
			conn->procedure_expire = conn->supervision_reload;
 1000cc4:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
 1000cc8:	e793      	b.n	1000bf2 <ull_conn_llcp+0x3a>
		if (!conn->tx_ctrl) {
 1000cca:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 1000cce:	b1a2      	cbz	r2, 1000cfa <ull_conn_llcp+0x142>
	tx->next = conn->tx_ctrl_last->next;
 1000cd0:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 1000cd4:	681a      	ldr	r2, [r3, #0]
 1000cd6:	6002      	str	r2, [r0, #0]
	conn->tx_ctrl_last->next = tx;
 1000cd8:	6018      	str	r0, [r3, #0]
	conn->tx_ctrl_last = tx;
 1000cda:	f8c4 01b8 	str.w	r0, [r4, #440]	; 0x1b8
 1000cde:	6803      	ldr	r3, [r0, #0]
}
 1000ce0:	e7e5      	b.n	1000cae <ull_conn_llcp+0xf6>
	LL_ASSERT(conn->lll.handle != 0xFFFF);
 1000ce2:	f44f 7142 	mov.w	r1, #776	; 0x308
 1000ce6:	4809      	ldr	r0, [pc, #36]	; (1000d0c <ull_conn_llcp+0x154>)
 1000ce8:	f002 fc4e 	bl	1003588 <bt_ctlr_assert_handle>
 1000cec:	e770      	b.n	1000bd0 <ull_conn_llcp+0x18>
				conn->procedure_expire++;
 1000cee:	3301      	adds	r3, #1
 1000cf0:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
}
 1000cf4:	b00d      	add	sp, #52	; 0x34
 1000cf6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			tx->next = conn->tx_head;
 1000cfa:	6003      	str	r3, [r0, #0]
				conn->tx_ctrl = tx;
 1000cfc:	e9c4 006c 	strd	r0, r0, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 1000d00:	f8c4 01b8 	str.w	r0, [r4, #440]	; 0x1b8
 1000d04:	e7d3      	b.n	1000cae <ull_conn_llcp+0xf6>
 1000d06:	bf00      	nop
 1000d08:	210038cc 	.word	0x210038cc
 1000d0c:	010187e4 	.word	0x010187e4
	struct ll_conn *conn_upd;
	u16_t instant_latency;
	u16_t event_counter;


	conn_upd = conn_upd_curr;
 1000d10:	f8df 9440 	ldr.w	r9, [pc, #1088]	; 1001154 <ull_conn_llcp+0x59c>

	/* set mutex */
	if (!conn_upd) {
 1000d14:	f8d9 3000 	ldr.w	r3, [r9]
 1000d18:	2b00      	cmp	r3, #0
 1000d1a:	f000 84b4 	beq.w	1001686 <ull_conn_llcp+0xace>
		conn_upd_curr = conn;
	}

	/* Calculate current event counter */
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
 1000d1e:	8ee7      	ldrh	r7, [r4, #54]	; 0x36
 1000d20:	8e62      	ldrh	r2, [r4, #50]	; 0x32

	instant_latency = (event_counter - conn->llcp.conn_upd.instant) &
			  0xffff;
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
 1000d22:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
 1000d26:	4417      	add	r7, r2
 1000d28:	442f      	add	r7, r5
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
 1000d2a:	f013 0303 	ands.w	r3, r3, #3
	event_counter = lll->event_counter + lll->latency_prepare + lazy;
 1000d2e:	b2bf      	uxth	r7, r7
	if (conn->llcp_cu.state != LLCP_CUI_STATE_INPROG) {
 1000d30:	f040 83d3 	bne.w	10014da <ull_conn_llcp+0x922>
	instant_latency = (event_counter - conn->llcp.conn_upd.instant) &
 1000d34:	f8b4 80ec 	ldrh.w	r8, [r4, #236]	; 0xec
 1000d38:	eba7 0208 	sub.w	r2, r7, r8
 1000d3c:	fa1f fb82 	uxth.w	fp, r2
				    pdu_ctrl_tx, NULL, NULL);
#endif /* !CONFIG_BT_CTLR_SCHED_ADVANCED */

		ctrl_tx_enqueue(conn, tx);

	} else if (instant_latency <= 0x7FFF) {
 1000d40:	0412      	lsls	r2, r2, #16
 1000d42:	f53f af50 	bmi.w	1000be6 <ull_conn_llcp+0x2e>
		u32_t ticker_status;
		u32_t periodic_us;
		u16_t latency;

		/* procedure request acked */
		conn->llcp_cu.ack = conn->llcp_cu.req;
 1000d46:	f894 2104 	ldrb.w	r2, [r4, #260]	; 0x104
		conn->llcp_ack = conn->llcp_req;

#if defined(CONFIG_BT_CTLR_CONN_PARAM_REQ)
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
 1000d4a:	f894 1170 	ldrb.w	r1, [r4, #368]	; 0x170
		conn->llcp_cu.ack = conn->llcp_cu.req;
 1000d4e:	f884 2105 	strb.w	r2, [r4, #261]	; 0x105
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
 1000d52:	f894 2171 	ldrb.w	r2, [r4, #369]	; 0x171
		conn->llcp_ack = conn->llcp_req;
 1000d56:	f894 00e8 	ldrb.w	r0, [r4, #232]	; 0xe8
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
 1000d5a:	428a      	cmp	r2, r1
		conn->llcp_ack = conn->llcp_req;
 1000d5c:	f884 00e9 	strb.w	r0, [r4, #233]	; 0xe9
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
 1000d60:	d009      	beq.n	1000d76 <ull_conn_llcp+0x1be>
		    (conn->llcp_conn_param.state == LLCP_CPR_STATE_UPD)) {
 1000d62:	f894 2172 	ldrb.w	r2, [r4, #370]	; 0x172
		if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
 1000d66:	f002 0207 	and.w	r2, r2, #7
 1000d6a:	2a05      	cmp	r2, #5
			conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
 1000d6c:	bf04      	itt	eq
 1000d6e:	f884 1171 	strbeq.w	r1, [r4, #369]	; 0x171

			/* Stop procedure timeout */
			conn->procedure_expire = 0U;
 1000d72:	f8a4 30cc 	strheq.w	r3, [r4, #204]	; 0xcc
		}
#endif /* CONFIG_BT_CTLR_CONN_PARAM_REQ */

		/* reset mutex */
		if (conn_upd_curr == conn) {
 1000d76:	f8d9 3000 	ldr.w	r3, [r9]
 1000d7a:	429c      	cmp	r4, r3
			conn_upd_curr = NULL;
 1000d7c:	bf04      	itt	eq
 1000d7e:	2300      	moveq	r3, #0
 1000d80:	f8c9 3000 	streq.w	r3, [r9]
		}

		lll = &conn->lll;

		/* Acquire Rx node */
		rx = conn->llcp_rx;
 1000d84:	f8d4 9100 	ldr.w	r9, [r4, #256]	; 0x100
		LL_ASSERT(rx && rx->hdr.link);
 1000d88:	f1b9 0f00 	cmp.w	r9, #0
 1000d8c:	f000 85aa 	beq.w	10018e4 <ull_conn_llcp+0xd2c>
 1000d90:	f8d9 0000 	ldr.w	r0, [r9]
 1000d94:	2800      	cmp	r0, #0
 1000d96:	f000 85a5 	beq.w	10018e4 <ull_conn_llcp+0xd2c>
		conn->llcp_rx = rx->hdr.link->mem;

		/* Prepare the rx packet structure */
		if ((conn->llcp_cu.interval != lll->interval) ||
 1000d9a:	f8b4 c108 	ldrh.w	ip, [r4, #264]	; 0x108
 1000d9e:	8de3      	ldrh	r3, [r4, #46]	; 0x2e
		conn->llcp_rx = rx->hdr.link->mem;
 1000da0:	6842      	ldr	r2, [r0, #4]
		if ((conn->llcp_cu.interval != lll->interval) ||
 1000da2:	459c      	cmp	ip, r3
 1000da4:	f8b4 e10a 	ldrh.w	lr, [r4, #266]	; 0x10a
		conn->llcp_rx = rx->hdr.link->mem;
 1000da8:	f8c4 2100 	str.w	r2, [r4, #256]	; 0x100
		if ((conn->llcp_cu.interval != lll->interval) ||
 1000dac:	f000 86b5 	beq.w	1001b1a <ull_conn_llcp+0xf62>
 1000db0:	f8b4 a10c 	ldrh.w	sl, [r4, #268]	; 0x10c
				       lll->interval * 1250) !=
		     conn->supervision_reload)) {
			struct node_rx_cu *cu;

			rx->hdr.handle = lll->handle;
			rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
 1000db4:	210a      	movs	r1, #10

			/* prepare connection update complete structure */
			cu = (void *)rx->pdu;
			cu->status = 0x00;
 1000db6:	2300      	movs	r3, #0
			rx->hdr.handle = lll->handle;
 1000db8:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
			rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
 1000dba:	f889 1004 	strb.w	r1, [r9, #4]
			rx->hdr.handle = lll->handle;
 1000dbe:	f8a9 2006 	strh.w	r2, [r9, #6]
			cu->interval = conn->llcp_cu.interval;
 1000dc2:	f8a9 c022 	strh.w	ip, [r9, #34]	; 0x22
			cu->latency = conn->llcp_cu.latency;
 1000dc6:	f8a9 e024 	strh.w	lr, [r9, #36]	; 0x24
			cu->timeout = conn->llcp_cu.timeout;
 1000dca:	f8a9 a026 	strh.w	sl, [r9, #38]	; 0x26
			cu->status = 0x00;
 1000dce:	f889 3020 	strb.w	r3, [r9, #32]
			/* Mark for buffer for release */
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
		}

		/* enqueue rx node towards Thread */
		ll_rx_put(rx->hdr.link, rx);
 1000dd2:	4649      	mov	r1, r9
 1000dd4:	f009 f91a 	bl	100a00c <ll_rx_put>
		ll_rx_sched();
 1000dd8:	f009 f922 	bl	100a020 <ll_rx_sched>

#if defined(CONFIG_BT_CTLR_XTAL_ADVANCED)
		/* restore to normal prepare */
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
 1000ddc:	6823      	ldr	r3, [r4, #0]
 1000dde:	2b00      	cmp	r3, #0
 1000de0:	da09      	bge.n	1000df6 <ull_conn_llcp+0x23e>
			u32_t ticks_prepare_to_start =
 1000de2:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
				MAX(conn->evt.ticks_active_to_start,
				    conn->evt.ticks_preempt_to_start);

			conn->evt.ticks_xtal_to_start &= ~XON_BITMASK;
			ticks_at_expire -= (conn->evt.ticks_xtal_to_start -
 1000de6:	428a      	cmp	r2, r1
 1000de8:	bf2c      	ite	cs
 1000dea:	18b6      	addcs	r6, r6, r2
 1000dec:	1876      	addcc	r6, r6, r1
			conn->evt.ticks_xtal_to_start &= ~XON_BITMASK;
 1000dee:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
 1000df2:	6023      	str	r3, [r4, #0]
			ticks_at_expire -= (conn->evt.ticks_xtal_to_start -
 1000df4:	1af6      	subs	r6, r6, r3
					    ticks_prepare_to_start);
		}
#endif /* CONFIG_BT_CTLR_XTAL_ADVANCED */

		/* compensate for instant_latency due to laziness */
		conn_interval_old = instant_latency * lll->interval;
 1000df6:	8de1      	ldrh	r1, [r4, #46]	; 0x2e
		latency = conn_interval_old / conn->llcp_cu.interval;
 1000df8:	f8b4 9108 	ldrh.w	r9, [r4, #264]	; 0x108
		conn_interval_old = instant_latency * lll->interval;
 1000dfc:	fb01 f10b 	mul.w	r1, r1, fp
 1000e00:	b289      	uxth	r1, r1
		latency = conn_interval_old / conn->llcp_cu.interval;
 1000e02:	fbb1 fcf9 	udiv	ip, r1, r9
		conn_interval_new = latency * conn->llcp_cu.interval;
 1000e06:	fb0c f009 	mul.w	r0, ip, r9
 1000e0a:	b280      	uxth	r0, r0
		latency = conn_interval_old / conn->llcp_cu.interval;
 1000e0c:	fa1f f38c 	uxth.w	r3, ip
		if (conn_interval_new > conn_interval_old) {
 1000e10:	4281      	cmp	r1, r0
		latency = conn_interval_old / conn->llcp_cu.interval;
 1000e12:	930b      	str	r3, [sp, #44]	; 0x2c
		if (conn_interval_new > conn_interval_old) {
 1000e14:	f080 8554 	bcs.w	10018c0 <ull_conn_llcp+0xd08>
			ticks_at_expire += HAL_TICKER_US_TO_TICKS(
 1000e18:	a3c3      	add	r3, pc, #780	; (adr r3, 1001128 <ull_conn_llcp+0x570>)
 1000e1a:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000e1e:	f240 4ce2 	movw	ip, #1250	; 0x4e2
 1000e22:	1a41      	subs	r1, r0, r1
 1000e24:	fb0c f101 	mul.w	r1, ip, r1
 1000e28:	48c1      	ldr	r0, [pc, #772]	; (1001130 <ull_conn_llcp+0x578>)
 1000e2a:	fba1 0100 	umull	r0, r1, r1, r0
 1000e2e:	f7ff f943 	bl	10000b8 <__aeabi_uldivmod>
 1000e32:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 1000e36:	4406      	add	r6, r0
		} else {
			ticks_slot_overhead = 0U;
		}

		/* calculate the window widening and interval */
		conn_interval_us = conn->llcp_cu.interval * 1250U;
 1000e38:	f240 4ae2 	movw	sl, #1250	; 0x4e2
		lll->latency_prepare += lazy;
 1000e3c:	8e63      	ldrh	r3, [r4, #50]	; 0x32
		lll->latency_prepare -= (instant_latency - latency);
 1000e3e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
		lll->latency_prepare += lazy;
 1000e40:	441d      	add	r5, r3
		lll->latency_prepare -= (instant_latency - latency);
 1000e42:	eba8 0707 	sub.w	r7, r8, r7
		periodic_us = conn_interval_us;

		if (0) {
#if defined(CONFIG_BT_PERIPHERAL)
		} else if (lll->role) {
 1000e46:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
		lll->latency_prepare -= (instant_latency - latency);
 1000e4a:	4417      	add	r7, r2
 1000e4c:	442f      	add	r7, r5
		} else if (lll->role) {
 1000e4e:	2b00      	cmp	r3, #0
		conn_interval_us = conn->llcp_cu.interval * 1250U;
 1000e50:	fb0a f509 	mul.w	r5, sl, r9
		lll->latency_prepare -= (instant_latency - latency);
 1000e54:	8667      	strh	r7, [r4, #50]	; 0x32
		} else if (lll->role) {
 1000e56:	f2c0 8696 	blt.w	1001b86 <ull_conn_llcp+0xfce>
			periodic_us -= lll->slave.window_widening_periodic_us;
#endif /* CONFIG_BT_PERIPHERAL */

#if defined(CONFIG_BT_CENTRAL)
		} else if (!lll->role) {
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
 1000e5a:	a3b3      	add	r3, pc, #716	; (adr r3, 1001128 <ull_conn_llcp+0x570>)
 1000e5c:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000e60:	f8d4 0110 	ldr.w	r0, [r4, #272]	; 0x110
 1000e64:	49b2      	ldr	r1, [pc, #712]	; (1001130 <ull_conn_llcp+0x578>)
		periodic_us = conn_interval_us;
 1000e66:	46aa      	mov	sl, r5
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
 1000e68:	fba0 0101 	umull	r0, r1, r0, r1
 1000e6c:	f7ff f924 	bl	10000b8 <__aeabi_uldivmod>
 1000e70:	f020 487f 	bic.w	r8, r0, #4278190080	; 0xff000000

			/* Workaround: Due to the missing remainder param in
			 * ticker_start function for first interval; add a
			 * tick so as to use the ceiled value.
			 */
			ticks_win_offset += 1U;
 1000e74:	f108 0801 	add.w	r8, r8, #1

		lll->interval = conn->llcp_cu.interval;
		lll->latency = conn->llcp_cu.latency;

		conn->supervision_reload =
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
 1000e78:	f242 7310 	movw	r3, #10000	; 0x2710
 1000e7c:	f8b4 210c 	ldrh.w	r2, [r4, #268]	; 0x10c
					  conn_interval_us);
		conn->procedure_reload =
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
 1000e80:	49ac      	ldr	r1, [pc, #688]	; (1001134 <ull_conn_llcp+0x57c>)
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
 1000e82:	fb03 5202 	mla	r2, r3, r2, r5

#if defined(CONFIG_BT_CTLR_LE_PING)
		/* APTO in no. of connection events */
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 1000e86:	4bac      	ldr	r3, [pc, #688]	; (1001138 <ull_conn_llcp+0x580>)
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
 1000e88:	3a01      	subs	r2, #1
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 1000e8a:	442b      	add	r3, r5
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
 1000e8c:	fbb2 f2f5 	udiv	r2, r2, r5
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 1000e90:	fbb3 f3f5 	udiv	r3, r3, r5
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
 1000e94:	4429      	add	r1, r5
 1000e96:	fbb1 f5f5 	udiv	r5, r1, r5
		lll->latency = conn->llcp_cu.latency;
 1000e9a:	f8b4 010a 	ldrh.w	r0, [r4, #266]	; 0x10a
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 1000e9e:	b299      	uxth	r1, r3
			RADIO_CONN_EVENTS((conn->llcp_cu.timeout * 10U * 1000U),
 1000ea0:	f8a4 20c6 	strh.w	r2, [r4, #198]	; 0xc6
						      conn_interval_us);
		/* Dispatch LE Ping PDU 6 connection events (that peer would
		 * listen to) before 30s timeout
		 * TODO: "peer listens to" is greater than 30s due to latency
		 */
		conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
 1000ea4:	1d82      	adds	r2, r0, #6
 1000ea6:	4291      	cmp	r1, r2
		lll->interval = conn->llcp_cu.interval;
 1000ea8:	f8a4 902e 	strh.w	r9, [r4, #46]	; 0x2e
		conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 1000eac:	f8a4 10d2 	strh.w	r1, [r4, #210]	; 0xd2
			RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
 1000eb0:	f8a4 50ca 	strh.w	r5, [r4, #202]	; 0xca
		lll->latency = conn->llcp_cu.latency;
 1000eb4:	8620      	strh	r0, [r4, #48]	; 0x30
		conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
 1000eb6:	dd02      	ble.n	1000ebe <ull_conn_llcp+0x306>
				     (conn->apto_reload - (lll->latency + 6)) :
 1000eb8:	1a09      	subs	r1, r1, r0
 1000eba:	3906      	subs	r1, #6
		conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
 1000ebc:	b289      	uxth	r1, r1
				     conn->apto_reload;
#endif /* CONFIG_BT_CTLR_LE_PING */

		if (conn->llcp_cu.cmd) {
 1000ebe:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
		conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
 1000ec2:	f8a4 10ce 	strh.w	r1, [r4, #206]	; 0xce
		if (conn->llcp_cu.cmd) {
 1000ec6:	075d      	lsls	r5, r3, #29
			conn->supervision_expire = 0U;
 1000ec8:	bf48      	it	mi
 1000eca:	2300      	movmi	r3, #0
#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
		/* disable ticker job, in order to chain stop and start
		 * to avoid RTC being stopped if no tickers active.
		 */
		u32_t mayfly_was_enabled =
			mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH,
 1000ecc:	f04f 0102 	mov.w	r1, #2
			conn->supervision_expire = 0U;
 1000ed0:	bf48      	it	mi
 1000ed2:	f8a4 30c8 	strhmi.w	r3, [r4, #200]	; 0xc8
			mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH,
 1000ed6:	2001      	movs	r0, #1
 1000ed8:	f011 faee 	bl	10124b8 <mayfly_is_enabled>
					  TICKER_USER_ID_ULL_LOW);
		mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW,
 1000edc:	2200      	movs	r2, #0
 1000ede:	2102      	movs	r1, #2
			mayfly_is_enabled(TICKER_USER_ID_ULL_HIGH,
 1000ee0:	4681      	mov	r9, r0
		mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW,
 1000ee2:	2001      	movs	r0, #1
 1000ee4:	f004 ff40 	bl	1005d68 <mayfly_enable>
	return mem_index_get(conn, conn_pool, sizeof(struct ll_conn));
 1000ee8:	f44f 72e4 	mov.w	r2, #456	; 0x1c8
 1000eec:	4993      	ldr	r1, [pc, #588]	; (100113c <ull_conn_llcp+0x584>)
 1000eee:	4620      	mov	r0, r4
 1000ef0:	f004 fecc 	bl	1005c8c <mem_index_get>
			      0);
#endif

		/* start slave/master with new timings */
		ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
 1000ef4:	1d45      	adds	r5, r0, #5
 1000ef6:	b2ed      	uxtb	r5, r5
		ticker_status =	ticker_stop(TICKER_INSTANCE_ID_CTLR,
 1000ef8:	4b91      	ldr	r3, [pc, #580]	; (1001140 <ull_conn_llcp+0x588>)
 1000efa:	462a      	mov	r2, r5
 1000efc:	2101      	movs	r1, #1
 1000efe:	2000      	movs	r0, #0
 1000f00:	9400      	str	r4, [sp, #0]
 1000f02:	f006 f997 	bl	1007234 <ticker_stop>
					    TICKER_USER_ID_ULL_HIGH,
					    ticker_id_conn,
					    ticker_stop_conn_op_cb,
					    (void *)conn);
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 1000f06:	f030 0302 	bics.w	r3, r0, #2
 1000f0a:	d004      	beq.n	1000f16 <ull_conn_llcp+0x35e>
 1000f0c:	f640 1164 	movw	r1, #2404	; 0x964
 1000f10:	488c      	ldr	r0, [pc, #560]	; (1001144 <ull_conn_llcp+0x58c>)
 1000f12:	f002 fb39 	bl	1003588 <bt_ctlr_assert_handle>
		ticker_status =
			ticker_start(TICKER_INSTANCE_ID_CTLR,
				     TICKER_USER_ID_ULL_HIGH,
				     ticker_id_conn,
				     ticks_at_expire, ticks_win_offset,
				     HAL_TICKER_US_TO_TICKS(periodic_us),
 1000f16:	a384      	add	r3, pc, #528	; (adr r3, 1001128 <ull_conn_llcp+0x570>)
 1000f18:	e9d3 2300 	ldrd	r2, r3, [r3]
 1000f1c:	4984      	ldr	r1, [pc, #528]	; (1001130 <ull_conn_llcp+0x578>)
 1000f1e:	fbaa ab01 	umull	sl, fp, sl, r1
 1000f22:	4650      	mov	r0, sl
 1000f24:	4659      	mov	r1, fp
 1000f26:	f7ff f8c7 	bl	10000b8 <__aeabi_uldivmod>
				     HAL_TICKER_REMAINDER(periodic_us),
 1000f2a:	2107      	movs	r1, #7
 1000f2c:	4a86      	ldr	r2, [pc, #536]	; (1001148 <ull_conn_llcp+0x590>)
			ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000f2e:	f020 477f 	bic.w	r7, r0, #4278190080	; 0xff000000
				     HAL_TICKER_REMAINDER(periodic_us),
 1000f32:	fba7 2302 	umull	r2, r3, r7, r2
 1000f36:	fb01 3307 	mla	r3, r1, r7, r3
 1000f3a:	ebba 0002 	subs.w	r0, sl, r2
 1000f3e:	eb6b 0103 	sbc.w	r1, fp, r3
 1000f42:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 1000f46:	2300      	movs	r3, #0
 1000f48:	f7ff f8b6 	bl	10000b8 <__aeabi_uldivmod>
 1000f4c:	4603      	mov	r3, r0
			ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000f4e:	2000      	movs	r0, #0
 1000f50:	f994 c03d 	ldrsb.w	ip, [r4, #61]	; 0x3d
 1000f54:	4a7d      	ldr	r2, [pc, #500]	; (100114c <ull_conn_llcp+0x594>)
 1000f56:	497e      	ldr	r1, [pc, #504]	; (1001150 <ull_conn_llcp+0x598>)
 1000f58:	4584      	cmp	ip, r0
 1000f5a:	bfa8      	it	ge
 1000f5c:	4611      	movge	r1, r2
				     TICKER_LAZY_MUST_EXPIRE,
#else
				     TICKER_NULL_LAZY,
#endif /* CONFIG_BT_CTLR_CONN_META */
				     (ticks_slot_overhead +
				      conn->evt.ticks_slot),
 1000f5e:	68e2      	ldr	r2, [r4, #12]
			ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000f60:	f8df c1f4 	ldr.w	ip, [pc, #500]	; 1001158 <ull_conn_llcp+0x5a0>
 1000f64:	e9cd 7301 	strd	r7, r3, [sp, #4]
				      conn->evt.ticks_slot),
 1000f68:	9204      	str	r2, [sp, #16]
			ticker_start(TICKER_INSTANCE_ID_CTLR,
 1000f6a:	4633      	mov	r3, r6
 1000f6c:	9105      	str	r1, [sp, #20]
 1000f6e:	462a      	mov	r2, r5
 1000f70:	2101      	movs	r1, #1
 1000f72:	9408      	str	r4, [sp, #32]
 1000f74:	9406      	str	r4, [sp, #24]
 1000f76:	f8cd 8000 	str.w	r8, [sp]
 1000f7a:	9003      	str	r0, [sp, #12]
 1000f7c:	f8cd c01c 	str.w	ip, [sp, #28]
 1000f80:	f006 f8f2 	bl	1007168 <ticker_start>
#else
				     ull_master_ticker_cb,
#endif
				     conn, ticker_start_conn_op_cb,
				     (void *)conn);
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 1000f84:	f030 0302 	bics.w	r3, r0, #2
 1000f88:	d004      	beq.n	1000f94 <ull_conn_llcp+0x3dc>
 1000f8a:	f640 117e 	movw	r1, #2430	; 0x97e
 1000f8e:	486d      	ldr	r0, [pc, #436]	; (1001144 <ull_conn_llcp+0x58c>)
 1000f90:	f002 fafa 	bl	1003588 <bt_ctlr_assert_handle>
			  (ticker_status == TICKER_STATUS_BUSY));

#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
		/* enable ticker job, if disabled in this function */
		if (mayfly_was_enabled) {
 1000f94:	f1b9 0f00 	cmp.w	r9, #0
 1000f98:	f040 85db 	bne.w	1001b52 <ull_conn_llcp+0xf9a>
				return -ECANCELED;
 1000f9c:	f06f 0047 	mvn.w	r0, #71	; 0x47
 1000fa0:	e628      	b.n	1000bf4 <ull_conn_llcp+0x3c>
			event_counter = lll->event_counter +
 1000fa2:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 1000fa4:	8e62      	ldrh	r2, [r4, #50]	; 0x32
static inline void event_phy_upd_ind_prep(struct ll_conn *conn,
					  u16_t event_counter)
{
	struct node_rx_pu *upd;

	if (conn->llcp.phy_upd_ind.initiate) {
 1000fa6:	f894 60ec 	ldrb.w	r6, [r4, #236]	; 0xec
			event_counter = lll->event_counter +
 1000faa:	4413      	add	r3, r2
					lll->latency_prepare + lazy;
 1000fac:	441d      	add	r5, r3
	if (conn->llcp.phy_upd_ind.initiate) {
 1000fae:	07f7      	lsls	r7, r6, #31
 1000fb0:	46b3      	mov	fp, r6
			event_counter = lll->event_counter +
 1000fb2:	b2ad      	uxth	r5, r5
	if (conn->llcp.phy_upd_ind.initiate) {
 1000fb4:	f100 8234 	bmi.w	1001420 <ull_conn_llcp+0x868>
		ind->m_to_s_phy = conn->llcp.phy_upd_ind.tx;
		ind->s_to_m_phy = conn->llcp.phy_upd_ind.rx;
		ind->instant = sys_cpu_to_le16(conn->llcp.phy_upd_ind.instant);

		ctrl_tx_enqueue(conn, tx);
	} else if (((event_counter - conn->llcp.phy_upd_ind.instant) &
 1000fb8:	f8b4 20ee 	ldrh.w	r2, [r4, #238]	; 0xee
 1000fbc:	1aad      	subs	r5, r5, r2
 1000fbe:	042f      	lsls	r7, r5, #16
 1000fc0:	f53f ae11 	bmi.w	1000be6 <ull_conn_llcp+0x2e>
	if (!conn->common.fex_valid ||
 1000fc4:	f894 20dc 	ldrb.w	r2, [r4, #220]	; 0xdc
		struct lll_conn *lll = &conn->lll;
		struct node_rx_pdu *rx;
		u8_t old_tx, old_rx;

		/* procedure request acked */
		conn->llcp_ack = conn->llcp_req;
 1000fc8:	f894 10e8 	ldrb.w	r1, [r4, #232]	; 0xe8

		/* apply new phy */
		old_tx = lll->phy_tx;
 1000fcc:	f894 8064 	ldrb.w	r8, [r4, #100]	; 0x64
		old_rx = lll->phy_rx;
 1000fd0:	f894 a065 	ldrb.w	sl, [r4, #101]	; 0x65
	if (!conn->common.fex_valid ||
 1000fd4:	07d5      	lsls	r5, r2, #31

#if defined(CONFIG_BT_CTLR_DATA_LENGTH)
		u16_t eff_tx_time = lll->max_tx_time;
		u16_t eff_rx_time = lll->max_rx_time;
 1000fd6:	f8b4 7062 	ldrh.w	r7, [r4, #98]	; 0x62
		conn->llcp_ack = conn->llcp_req;
 1000fda:	f884 10e9 	strb.w	r1, [r4, #233]	; 0xe9
		old_tx = lll->phy_tx;
 1000fde:	f008 0807 	and.w	r8, r8, #7
		old_rx = lll->phy_rx;
 1000fe2:	f00a 0a07 	and.w	sl, sl, #7
	if (!conn->common.fex_valid ||
 1000fe6:	f140 85bd 	bpl.w	1001b64 <ull_conn_llcp+0xfac>
	feature_coded_phy = (conn->llcp_feature.features &
 1000fea:	f8d4 211c 	ldr.w	r2, [r4, #284]	; 0x11c
	if (!conn->common.fex_valid ||
 1000fee:	0510      	lsls	r0, r2, #20
 1000ff0:	f140 85b8 	bpl.w	1001b64 <ull_conn_llcp+0xfac>
		tx_time = MAX(PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M), tx_time);
 1000ff4:	f44f 6329 	mov.w	r3, #2704	; 0xa90
		tx_time = MIN(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_CODED),
 1000ff8:	f8b4 90d8 	ldrh.w	r9, [r4, #216]	; 0xd8
 1000ffc:	930b      	str	r3, [sp, #44]	; 0x2c
 1000ffe:	4599      	cmp	r9, r3
 1001000:	bf28      	it	cs
 1001002:	4699      	movcs	r9, r3
 1001004:	f5b9 7fa4 	cmp.w	r9, #328	; 0x148
 1001008:	bf38      	it	cc
 100100a:	f44f 79a4 	movcc.w	r9, #328	; 0x148
		u16_t max_rx_time, max_tx_time;

		dle_max_time_get(conn, &max_rx_time, &max_tx_time);
#endif /* CONFIG_BT_CTLR_DATA_LENGTH */

		if (conn->llcp.phy_upd_ind.tx) {
 100100e:	f016 0f1c 	tst.w	r6, #28
 1001012:	f040 86b5 	bne.w	1001d80 <ull_conn_llcp+0x11c8>
		u16_t eff_tx_time = lll->max_tx_time;
 1001016:	f8b4 5060 	ldrh.w	r5, [r4, #96]	; 0x60
						    lll->phy_tx,
						    max_tx_time);

#endif /* CONFIG_BT_CTLR_DATA_LENGTH */
		}
		if (conn->llcp.phy_upd_ind.rx) {
 100101a:	f016 0fe0 	tst.w	r6, #224	; 0xe0
 100101e:	d00c      	beq.n	100103a <ull_conn_llcp+0x482>
			lll->phy_rx = conn->llcp.phy_upd_ind.rx;
 1001020:	f894 2065 	ldrb.w	r2, [r4, #101]	; 0x65
 1001024:	0971      	lsrs	r1, r6, #5
 1001026:	f361 0202 	bfi	r2, r1, #0, #3
 100102a:	f884 2065 	strb.w	r2, [r4, #101]	; 0x65

#if defined(CONFIG_BT_CTLR_DATA_LENGTH)
			eff_rx_time =
				calc_eff_time(lll->max_rx_octets, lll->phy_rx,
 100102e:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 1001030:	f894 005e 	ldrb.w	r0, [r4, #94]	; 0x5e
 1001034:	f009 ff5e 	bl	100aef4 <calc_eff_time>
 1001038:	4607      	mov	r7, r0
					      max_rx_time);

#endif /* CONFIG_BT_CTLR_DATA_LENGTH */
		}
		lll->phy_flags = conn->phy_pref_flags;
 100103a:	f894 21ac 	ldrb.w	r2, [r4, #428]	; 0x1ac
 100103e:	f894 1064 	ldrb.w	r1, [r4, #100]	; 0x64
 1001042:	f3c2 02c0 	ubfx	r2, r2, #3, #1

		/* Acquire Rx node */
		rx = conn->llcp_rx;
 1001046:	f8d4 6100 	ldr.w	r6, [r4, #256]	; 0x100
		lll->phy_flags = conn->phy_pref_flags;
 100104a:	f362 01c3 	bfi	r1, r2, #3, #1
 100104e:	f884 1064 	strb.w	r1, [r4, #100]	; 0x64
		LL_ASSERT(rx && rx->hdr.link);
 1001052:	2e00      	cmp	r6, #0
 1001054:	f000 879b 	beq.w	1001f8e <ull_conn_llcp+0x13d6>
 1001058:	6830      	ldr	r0, [r6, #0]
 100105a:	2800      	cmp	r0, #0
 100105c:	f000 8797 	beq.w	1001f8e <ull_conn_llcp+0x13d6>
		conn->llcp_rx = rx->hdr.link->mem;
 1001060:	6842      	ldr	r2, [r0, #4]

		/* generate event if phy changed or initiated by cmd */
		if (!conn->llcp.phy_upd_ind.cmd && (lll->phy_tx == old_tx) &&
 1001062:	f01b 0f02 	tst.w	fp, #2
 1001066:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
		conn->llcp_rx = rx->hdr.link->mem;
 100106a:	f8c4 2100 	str.w	r2, [r4, #256]	; 0x100
		if (!conn->llcp.phy_upd_ind.cmd && (lll->phy_tx == old_tx) &&
 100106e:	f040 87bf 	bne.w	1001ff0 <ull_conn_llcp+0x1438>
		    (lll->phy_rx == old_rx)) {
 1001072:	f894 2065 	ldrb.w	r2, [r4, #101]	; 0x65
		if (!conn->llcp.phy_upd_ind.cmd && (lll->phy_tx == old_tx) &&
 1001076:	f003 0307 	and.w	r3, r3, #7
 100107a:	4598      	cmp	r8, r3
		    (lll->phy_rx == old_rx)) {
 100107c:	f002 0207 	and.w	r2, r2, #7
		if (!conn->llcp.phy_upd_ind.cmd && (lll->phy_tx == old_tx) &&
 1001080:	f001 8026 	beq.w	10020d0 <ull_conn_llcp+0x1518>

			return;
		}

		rx->hdr.handle = lll->handle;
		rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
 1001084:	f04f 0e0e 	mov.w	lr, #14

		upd = (void *)rx->pdu;
		upd->status = 0U;
 1001088:	2100      	movs	r1, #0
		rx->hdr.handle = lll->handle;
 100108a:	f8b4 c02c 	ldrh.w	ip, [r4, #44]	; 0x2c
		upd->status = 0U;
 100108e:	f886 1020 	strb.w	r1, [r6, #32]
		rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
 1001092:	f886 e004 	strb.w	lr, [r6, #4]
		upd->tx = lll->phy_tx;
		upd->rx = lll->phy_rx;

		/* enqueue rx node towards Thread */
		ll_rx_put(rx->hdr.link, rx);
 1001096:	4631      	mov	r1, r6
		rx->hdr.handle = lll->handle;
 1001098:	f8a6 c006 	strh.w	ip, [r6, #6]
		upd->tx = lll->phy_tx;
 100109c:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
		upd->rx = lll->phy_rx;
 10010a0:	f886 2022 	strb.w	r2, [r6, #34]	; 0x22
		ll_rx_put(rx->hdr.link, rx);
 10010a4:	f008 ffb2 	bl	100a00c <ll_rx_put>

#if defined(CONFIG_BT_CTLR_DATA_LENGTH)
		/* get a rx node for ULL->LL */
		rx = conn->llcp_rx;
 10010a8:	f8d4 6100 	ldr.w	r6, [r4, #256]	; 0x100
		LL_ASSERT(rx && rx->hdr.link);
 10010ac:	2e00      	cmp	r6, #0
 10010ae:	f000 8778 	beq.w	1001fa2 <ull_conn_llcp+0x13ea>
 10010b2:	6830      	ldr	r0, [r6, #0]
 10010b4:	2800      	cmp	r0, #0
 10010b6:	f000 8774 	beq.w	1001fa2 <ull_conn_llcp+0x13ea>
		conn->llcp_rx = rx->hdr.link->mem;

		/* Update max tx and/or max rx if changed */
		if ((eff_tx_time <= lll->max_tx_time) &&
 10010ba:	f8b4 3060 	ldrh.w	r3, [r4, #96]	; 0x60
		conn->llcp_rx = rx->hdr.link->mem;
 10010be:	6842      	ldr	r2, [r0, #4]
		if ((eff_tx_time <= lll->max_tx_time) &&
 10010c0:	42ab      	cmp	r3, r5
		conn->llcp_rx = rx->hdr.link->mem;
 10010c2:	f8c4 2100 	str.w	r2, [r4, #256]	; 0x100
		if ((eff_tx_time <= lll->max_tx_time) &&
 10010c6:	d309      	bcc.n	10010dc <ull_conn_llcp+0x524>
 10010c8:	454b      	cmp	r3, r9
 10010ca:	d807      	bhi.n	10010dc <ull_conn_llcp+0x524>
		    (lll->max_tx_time <= max_tx_time) &&
		    (eff_rx_time <= lll->max_rx_time) &&
 10010cc:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
		    (lll->max_tx_time <= max_tx_time) &&
 10010d0:	42bb      	cmp	r3, r7
 10010d2:	d303      	bcc.n	10010dc <ull_conn_llcp+0x524>
		    (eff_rx_time <= lll->max_rx_time) &&
 10010d4:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 10010d6:	4293      	cmp	r3, r2
 10010d8:	f241 811a 	bls.w	1002310 <ull_conn_llcp+0x1758>
		lll->max_tx_time = eff_tx_time;
		lll->max_rx_time = eff_rx_time;

		/* prepare length rsp structure */
		rx->hdr.handle = lll->handle;
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 10010dc:	f04f 0e02 	mov.w	lr, #2

		struct pdu_data *pdu_rx = (void *)rx->pdu;

		pdu_rx->ll_id = PDU_DATA_LLID_CTRL;
		pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
 10010e0:	2109      	movs	r1, #9
			      sizeof(struct pdu_data_llctrl_length_rsp);
		pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 10010e2:	2215      	movs	r2, #21
		lll->max_tx_time = eff_tx_time;
 10010e4:	f8a4 5060 	strh.w	r5, [r4, #96]	; 0x60
		lll->max_rx_time = eff_rx_time;
 10010e8:	f8a4 7062 	strh.w	r7, [r4, #98]	; 0x62
		pdu_rx->ll_id = PDU_DATA_LLID_CTRL;
 10010ec:	f896 3020 	ldrb.w	r3, [r6, #32]
		rx->hdr.handle = lll->handle;
 10010f0:	f8b4 c02c 	ldrh.w	ip, [r4, #44]	; 0x2c
		pdu_rx->ll_id = PDU_DATA_LLID_CTRL;
 10010f4:	f043 0303 	orr.w	r3, r3, #3
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 10010f8:	f886 e004 	strb.w	lr, [r6, #4]
		pdu_rx->ll_id = PDU_DATA_LLID_CTRL;
 10010fc:	f886 3020 	strb.w	r3, [r6, #32]
		pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
 1001100:	f886 1021 	strb.w	r1, [r6, #33]	; 0x21

		struct pdu_data_llctrl_length_req *lr =
			(void *)&pdu_rx->llctrl.length_rsp;

		lr->max_rx_octets = sys_cpu_to_le16(lll->max_rx_octets);
 1001104:	f8b4 105e 	ldrh.w	r1, [r4, #94]	; 0x5e
		lr->max_tx_octets = sys_cpu_to_le16(lll->max_tx_octets);
 1001108:	f8b4 305c 	ldrh.w	r3, [r4, #92]	; 0x5c
		rx->hdr.handle = lll->handle;
 100110c:	f8a6 c006 	strh.w	ip, [r6, #6]
		lr->max_rx_octets = sys_cpu_to_le16(lll->max_rx_octets);
 1001110:	84b1      	strh	r1, [r6, #36]	; 0x24
		lr->max_tx_octets = sys_cpu_to_le16(lll->max_tx_octets);
 1001112:	8533      	strh	r3, [r6, #40]	; 0x28
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
		lr->max_tx_time = sys_cpu_to_le16(lll->max_tx_time);

		/* enqueue rx node towards Thread */
		ll_rx_put(rx->hdr.link, rx);
 1001114:	4631      	mov	r1, r6
		pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 1001116:	f886 2023 	strb.w	r2, [r6, #35]	; 0x23
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
 100111a:	84f7      	strh	r7, [r6, #38]	; 0x26
		lr->max_tx_time = sys_cpu_to_le16(lll->max_tx_time);
 100111c:	8575      	strh	r5, [r6, #42]	; 0x2a
		ll_rx_put(rx->hdr.link, rx);
 100111e:	f008 ff75 	bl	100a00c <ll_rx_put>
#endif /* CONFIG_BT_CTLR_DATA_LENGTH */

		ll_rx_sched();
 1001122:	f008 ff7d 	bl	100a020 <ll_rx_sched>
 1001126:	e55e      	b.n	1000be6 <ull_conn_llcp+0x2e>
 1001128:	1afd498d 	.word	0x1afd498d
 100112c:	00000007 	.word	0x00000007
 1001130:	3b9aca00 	.word	0x3b9aca00
 1001134:	026259ff 	.word	0x026259ff
 1001138:	01c9c37f 	.word	0x01c9c37f
 100113c:	21001b40 	.word	0x21001b40
 1001140:	0100b1c9 	.word	0x0100b1c9
 1001144:	010187e4 	.word	0x010187e4
 1001148:	1afd498d 	.word	0x1afd498d
 100114c:	0100e185 	.word	0x0100e185
 1001150:	0100e035 	.word	0x0100e035
 1001154:	210037c0 	.word	0x210037c0
 1001158:	0100b199 	.word	0x0100b199
	if (conn->llcp.encryption.state) {
 100115c:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
 1001160:	f013 0503 	ands.w	r5, r3, #3
 1001164:	f47f ad3f 	bne.w	1000be6 <ull_conn_llcp+0x2e>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1001168:	48ab      	ldr	r0, [pc, #684]	; (1001418 <ull_conn_llcp+0x860>)
 100116a:	f004 fd59 	bl	1005c20 <mem_acquire>
	if (!tx) {
 100116e:	4606      	mov	r6, r0
 1001170:	2800      	cmp	r0, #0
 1001172:	f43f ad38 	beq.w	1000be6 <ull_conn_llcp+0x2e>
	if (!lll->role) {
 1001176:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
 100117a:	2b00      	cmp	r3, #0
 100117c:	f280 8558 	bge.w	1001c30 <ull_conn_llcp+0x1078>
		if (conn->llcp.encryption.error_code) {
 1001180:	f894 50ed 	ldrb.w	r5, [r4, #237]	; 0xed
 1001184:	2d00      	cmp	r5, #0
 1001186:	f000 8349 	beq.w	100181c <ull_conn_llcp+0xc64>
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 100118a:	7903      	ldrb	r3, [r0, #4]
	if (conn->common.fex_valid &&
 100118c:	f894 20dc 	ldrb.w	r2, [r4, #220]	; 0xdc
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1001190:	f043 0303 	orr.w	r3, r3, #3
	if (conn->common.fex_valid &&
 1001194:	07d2      	lsls	r2, r2, #31
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1001196:	7103      	strb	r3, [r0, #4]
	if (conn->common.fex_valid &&
 1001198:	f140 86f3 	bpl.w	1001f82 <ull_conn_llcp+0x13ca>
	    (conn->llcp_feature.features & BIT(BT_LE_FEAT_BIT_EXT_REJ_IND))) {
 100119c:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
	if (conn->common.fex_valid &&
 10011a0:	075b      	lsls	r3, r3, #29
 10011a2:	f140 86ee 	bpl.w	1001f82 <ull_conn_llcp+0x13ca>
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
 10011a6:	2211      	movs	r2, #17
		p->reject_opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
 10011a8:	2303      	movs	r3, #3
		p->error_code = conn->llcp.encryption.error_code;
 10011aa:	7245      	strb	r5, [r0, #9]
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
 10011ac:	71c2      	strb	r2, [r0, #7]
		p->reject_opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
 10011ae:	7203      	strb	r3, [r0, #8]
	conn->llcp.encryption.error_code = 0U;
 10011b0:	2200      	movs	r2, #0
	pdu->len += offsetof(struct pdu_data_llctrl, reject_ind);
 10011b2:	7177      	strb	r7, [r6, #5]
	    conn->tx_head &&
 10011b4:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
	conn->llcp.encryption.error_code = 0U;
 10011b8:	f884 20ed 	strb.w	r2, [r4, #237]	; 0xed
	if (
 10011bc:	2b00      	cmp	r3, #0
 10011be:	f000 8374 	beq.w	10018aa <ull_conn_llcp+0xcf2>
	    !conn->llcp_enc.pause_tx &&
 10011c2:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
	    conn->tx_head &&
 10011c6:	0795      	lsls	r5, r2, #30
 10011c8:	f100 836f 	bmi.w	10018aa <ull_conn_llcp+0xcf2>
	    !conn->llcp_phy.pause_tx &&
 10011cc:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
 10011d0:	07d0      	lsls	r0, r2, #31
 10011d2:	f100 836a 	bmi.w	10018aa <ull_conn_llcp+0xcf2>
		if (conn->tx_head == conn->tx_data) {
 10011d6:	f8d4 21bc 	ldr.w	r2, [r4, #444]	; 0x1bc
 10011da:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 10011dc:	bf04      	itt	eq
 10011de:	681a      	ldreq	r2, [r3, #0]
 10011e0:	f8c4 21bc 	streq.w	r2, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 10011e4:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 10011e8:	2a00      	cmp	r2, #0
 10011ea:	f001 8079 	beq.w	10022e0 <ull_conn_llcp+0x1728>
	tx->next = conn->tx_ctrl_last->next;
 10011ee:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 10011f2:	681a      	ldr	r2, [r3, #0]
 10011f4:	6032      	str	r2, [r6, #0]
	conn->tx_ctrl_last->next = tx;
 10011f6:	601e      	str	r6, [r3, #0]
	conn->tx_ctrl_last = tx;
 10011f8:	f8c4 61b8 	str.w	r6, [r4, #440]	; 0x1b8
 10011fc:	6833      	ldr	r3, [r6, #0]
	if (!tx->next) {
 10011fe:	2b00      	cmp	r3, #0
 1001200:	f000 86bb 	beq.w	1001f7a <ull_conn_llcp+0x13c2>
	conn->llcp_ack = conn->llcp_req;
 1001204:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 1001208:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
 100120c:	e4eb      	b.n	1000be6 <ull_conn_llcp+0x2e>
			event_counter = lll->event_counter +
 100120e:	8ee3      	ldrh	r3, [r4, #54]	; 0x36
 1001210:	8e61      	ldrh	r1, [r4, #50]	; 0x32
	if (conn->llcp.chan_map.initiate) {
 1001212:	f894 20ec 	ldrb.w	r2, [r4, #236]	; 0xec
			event_counter = lll->event_counter +
 1001216:	440b      	add	r3, r1
					lll->latency_prepare + lazy;
 1001218:	441d      	add	r5, r3
	if (conn->llcp.chan_map.initiate) {
 100121a:	07d0      	lsls	r0, r2, #31
			event_counter = lll->event_counter +
 100121c:	b2ad      	uxth	r5, r5
	if (conn->llcp.chan_map.initiate) {
 100121e:	f100 81fe 	bmi.w	100161e <ull_conn_llcp+0xa66>
	} else if (((event_counter - conn->llcp.chan_map.instant) & 0xFFFF)
 1001222:	f8b4 30f2 	ldrh.w	r3, [r4, #242]	; 0xf2
 1001226:	1aed      	subs	r5, r5, r3
 1001228:	0429      	lsls	r1, r5, #16
 100122a:	f53f acdc 	bmi.w	1000be6 <ull_conn_llcp+0x2e>
		conn->llcp_ack = conn->llcp_req;
 100122e:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
		memcpy(&lll->data_chan_map[0],
 1001232:	f104 0538 	add.w	r5, r4, #56	; 0x38
 1001236:	2205      	movs	r2, #5
		conn->llcp_ack = conn->llcp_req;
 1001238:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
		memcpy(&lll->data_chan_map[0],
 100123c:	f104 01ed 	add.w	r1, r4, #237	; 0xed
 1001240:	4628      	mov	r0, r5
 1001242:	f015 fb39 	bl	10168b8 <memcpy>
			util_ones_count_get(&lll->data_chan_map[0],
 1001246:	4628      	mov	r0, r5
 1001248:	2105      	movs	r1, #5
 100124a:	f004 feb5 	bl	1005fb8 <util_ones_count_get>
		conn->chm_updated = 1U;
 100124e:	2201      	movs	r2, #1
		lll->data_chan_count =
 1001250:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
		conn->chm_updated = 1U;
 1001254:	f884 21c4 	strb.w	r2, [r4, #452]	; 0x1c4
		lll->data_chan_count =
 1001258:	f360 0305 	bfi	r3, r0, #0, #6
 100125c:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
		conn->chm_updated = 1U;
 1001260:	e4c1      	b.n	1000be6 <ull_conn_llcp+0x2e>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1001262:	486d      	ldr	r0, [pc, #436]	; (1001418 <ull_conn_llcp+0x860>)
 1001264:	f004 fcdc 	bl	1005c20 <mem_acquire>
	if (tx) {
 1001268:	2800      	cmp	r0, #0
 100126a:	f43f acbc 	beq.w	1000be6 <ull_conn_llcp+0x2e>
		pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, ping_req) +
 100126e:	2301      	movs	r3, #1
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_REQ;
 1001270:	2112      	movs	r1, #18
		conn->llcp_ack = conn->llcp_req;
 1001272:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
 1001276:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100127a:	7902      	ldrb	r2, [r0, #4]
		pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, ping_req) +
 100127c:	7143      	strb	r3, [r0, #5]
	    conn->tx_head &&
 100127e:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001282:	f042 0203 	orr.w	r2, r2, #3
 1001286:	7102      	strb	r2, [r0, #4]
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_REQ;
 1001288:	71c1      	strb	r1, [r0, #7]
	if (
 100128a:	2b00      	cmp	r3, #0
 100128c:	f000 82bb 	beq.w	1001806 <ull_conn_llcp+0xc4e>
	    !conn->llcp_enc.pause_tx &&
 1001290:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
	    conn->tx_head &&
 1001294:	0791      	lsls	r1, r2, #30
 1001296:	f100 82b6 	bmi.w	1001806 <ull_conn_llcp+0xc4e>
	    !conn->llcp_phy.pause_tx &&
 100129a:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
 100129e:	07d2      	lsls	r2, r2, #31
 10012a0:	f100 82b1 	bmi.w	1001806 <ull_conn_llcp+0xc4e>
		if (conn->tx_head == conn->tx_data) {
 10012a4:	f8d4 21bc 	ldr.w	r2, [r4, #444]	; 0x1bc
 10012a8:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 10012aa:	bf04      	itt	eq
 10012ac:	681a      	ldreq	r2, [r3, #0]
 10012ae:	f8c4 21bc 	streq.w	r2, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 10012b2:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 10012b6:	2a00      	cmp	r2, #0
 10012b8:	f001 8000 	beq.w	10022bc <ull_conn_llcp+0x1704>
	tx->next = conn->tx_ctrl_last->next;
 10012bc:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 10012c0:	681a      	ldr	r2, [r3, #0]
 10012c2:	6002      	str	r2, [r0, #0]
	conn->tx_ctrl_last->next = tx;
 10012c4:	6018      	str	r0, [r3, #0]
	conn->tx_ctrl_last = tx;
 10012c6:	f8c4 01b8 	str.w	r0, [r4, #440]	; 0x1b8
 10012ca:	6803      	ldr	r3, [r0, #0]
	if (!tx->next) {
 10012cc:	2b00      	cmp	r3, #0
 10012ce:	f000 8553 	beq.w	1001d78 <ull_conn_llcp+0x11c0>
		conn->procedure_expire = conn->procedure_reload;
 10012d2:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
 10012d6:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
 10012da:	e484      	b.n	1000be6 <ull_conn_llcp+0x2e>
			LL_ASSERT(0);
 10012dc:	f240 318e 	movw	r1, #910	; 0x38e
 10012e0:	484e      	ldr	r0, [pc, #312]	; (100141c <ull_conn_llcp+0x864>)
 10012e2:	f002 f951 	bl	1003588 <bt_ctlr_assert_handle>
			break;
 10012e6:	e47e      	b.n	1000be6 <ull_conn_llcp+0x2e>
		} else if (conn->llcp_feature.ack != conn->llcp_feature.req) {
 10012e8:	f894 7119 	ldrb.w	r7, [r4, #281]	; 0x119
 10012ec:	f894 c118 	ldrb.w	ip, [r4, #280]	; 0x118
 10012f0:	4567      	cmp	r7, ip
 10012f2:	d159      	bne.n	10013a8 <ull_conn_llcp+0x7f0>
		} else if (conn->llcp_version.ack != conn->llcp_version.req) {
 10012f4:	f894 7121 	ldrb.w	r7, [r4, #289]	; 0x121
 10012f8:	f894 c120 	ldrb.w	ip, [r4, #288]	; 0x120
 10012fc:	4567      	cmp	r7, ip
 10012fe:	f000 82fa 	beq.w	10018f6 <ull_conn_llcp+0xd3e>
	if (!((conn->llcp_version.ack - conn->llcp_version.req) & 0x01)) {
 1001302:	eba7 070c 	sub.w	r7, r7, ip
 1001306:	07f9      	lsls	r1, r7, #31
 1001308:	f57f ac6d 	bpl.w	1000be6 <ull_conn_llcp+0x2e>
	if (conn->llcp_version.tx == 0U) {
 100130c:	f894 3122 	ldrb.w	r3, [r4, #290]	; 0x122
 1001310:	07da      	lsls	r2, r3, #31
 1001312:	f140 8724 	bpl.w	100215e <ull_conn_llcp+0x15a6>
	} else if (conn->llcp_version.rx) {
 1001316:	079a      	lsls	r2, r3, #30
 1001318:	f140 8716 	bpl.w	1002148 <ull_conn_llcp+0x1590>
		rx = ll_pdu_rx_alloc();
 100131c:	f008 fea4 	bl	100a068 <ll_pdu_rx_alloc>
		if (!rx) {
 1001320:	4601      	mov	r1, r0
 1001322:	b330      	cbz	r0, 1001372 <ull_conn_llcp+0x7ba>
		pdu->len = offsetof(struct pdu_data_llctrl, version_ind) +
 1001324:	2006      	movs	r0, #6
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
 1001326:	220c      	movs	r2, #12
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 1001328:	2702      	movs	r7, #2
		conn->llcp_version.ack = conn->llcp_version.req;
 100132a:	f894 3120 	ldrb.w	r3, [r4, #288]	; 0x120
		rx->hdr.handle = conn->lll.handle;
 100132e:	f8b4 c02c 	ldrh.w	ip, [r4, #44]	; 0x2c
		conn->llcp_version.ack = conn->llcp_version.req;
 1001332:	f884 3121 	strb.w	r3, [r4, #289]	; 0x121
		pdu->ll_id = PDU_DATA_LLID_CTRL;
 1001336:	f891 3020 	ldrb.w	r3, [r1, #32]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 100133a:	710f      	strb	r7, [r1, #4]
		pdu->ll_id = PDU_DATA_LLID_CTRL;
 100133c:	f043 0303 	orr.w	r3, r3, #3
 1001340:	f881 3020 	strb.w	r3, [r1, #32]
		pdu->len = offsetof(struct pdu_data_llctrl, version_ind) +
 1001344:	f881 0021 	strb.w	r0, [r1, #33]	; 0x21
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
 1001348:	f881 2023 	strb.w	r2, [r1, #35]	; 0x23
		rx->hdr.handle = conn->lll.handle;
 100134c:	f8a1 c006 	strh.w	ip, [r1, #6]
		pdu->llctrl.version_ind.version_number =
 1001350:	f894 0123 	ldrb.w	r0, [r4, #291]	; 0x123
		pdu->llctrl.version_ind.company_id =
 1001354:	f8b4 2124 	ldrh.w	r2, [r4, #292]	; 0x124
		pdu->llctrl.version_ind.sub_version_number =
 1001358:	f8b4 3126 	ldrh.w	r3, [r4, #294]	; 0x126
		pdu->llctrl.version_ind.version_number =
 100135c:	f881 0024 	strb.w	r0, [r1, #36]	; 0x24
		pdu->llctrl.version_ind.company_id =
 1001360:	f8a1 2025 	strh.w	r2, [r1, #37]	; 0x25
		pdu->llctrl.version_ind.sub_version_number =
 1001364:	f8a1 3027 	strh.w	r3, [r1, #39]	; 0x27
		ll_rx_put(rx->hdr.link, rx);
 1001368:	6808      	ldr	r0, [r1, #0]
 100136a:	f008 fe4f 	bl	100a00c <ll_rx_put>
		ll_rx_sched();
 100136e:	f008 fe57 	bl	100a020 <ll_rx_sched>
 1001372:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 1001376:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
 100137a:	e42f      	b.n	1000bdc <ull_conn_llcp+0x24>
	switch (conn->llcp_length.state) {
 100137c:	f000 0207 	and.w	r2, r0, #7
 1001380:	2a06      	cmp	r2, #6
 1001382:	f201 8120 	bhi.w	10025c6 <ull_conn_llcp+0x1a0e>
 1001386:	a101      	add	r1, pc, #4	; (adr r1, 100138c <ull_conn_llcp+0x7d4>)
 1001388:	f851 f022 	ldr.w	pc, [r1, r2, lsl #2]
 100138c:	01001731 	.word	0x01001731
 1001390:	01000c39 	.word	0x01000c39
 1001394:	01000c39 	.word	0x01000c39
 1001398:	01000c39 	.word	0x01000c39
 100139c:	0100168f 	.word	0x0100168f
 10013a0:	0100168f 	.word	0x0100168f
 10013a4:	01000c39 	.word	0x01000c39
	if (!((conn->llcp_feature.ack - conn->llcp_feature.req) & 0x01)) {
 10013a8:	eba7 070c 	sub.w	r7, r7, ip
 10013ac:	07fb      	lsls	r3, r7, #31
 10013ae:	f57f ac1a 	bpl.w	1000be6 <ull_conn_llcp+0x2e>
	if (conn->common.fex_valid) {
 10013b2:	f894 10dc 	ldrb.w	r1, [r4, #220]	; 0xdc
 10013b6:	f011 0701 	ands.w	r7, r1, #1
 10013ba:	f000 847e 	beq.w	1001cba <ull_conn_llcp+0x1102>
		rx = ll_pdu_rx_alloc();
 10013be:	f008 fe53 	bl	100a068 <ll_pdu_rx_alloc>
		if (!rx) {
 10013c2:	4607      	mov	r7, r0
 10013c4:	2800      	cmp	r0, #0
 10013c6:	d0d4      	beq.n	1001372 <ull_conn_llcp+0x7ba>
		pdu->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
 10013c8:	2209      	movs	r2, #9
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 10013ca:	2002      	movs	r0, #2
		conn->llcp_feature.ack = conn->llcp_feature.req;
 10013cc:	f894 3118 	ldrb.w	r3, [r4, #280]	; 0x118
		rx->hdr.handle = conn->lll.handle;
 10013d0:	f8b4 c02c 	ldrh.w	ip, [r4, #44]	; 0x2c
		conn->llcp_feature.ack = conn->llcp_feature.req;
 10013d4:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119
		pdu->ll_id = PDU_DATA_LLID_CTRL;
 10013d8:	f897 3020 	ldrb.w	r3, [r7, #32]
		(void)memset(&pdu->llctrl.feature_rsp.features[0], 0x00,
 10013dc:	4641      	mov	r1, r8
		pdu->ll_id = PDU_DATA_LLID_CTRL;
 10013de:	f043 0303 	orr.w	r3, r3, #3
 10013e2:	f887 3020 	strb.w	r3, [r7, #32]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 10013e6:	7138      	strb	r0, [r7, #4]
		pdu->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
 10013e8:	f887 2021 	strb.w	r2, [r7, #33]	; 0x21
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_RSP;
 10013ec:	f887 2023 	strb.w	r2, [r7, #35]	; 0x23
		rx->hdr.handle = conn->lll.handle;
 10013f0:	f8a7 c006 	strh.w	ip, [r7, #6]
		(void)memset(&pdu->llctrl.feature_rsp.features[0], 0x00,
 10013f4:	2208      	movs	r2, #8
 10013f6:	f107 0024 	add.w	r0, r7, #36	; 0x24
 10013fa:	f015 fa88 	bl	101690e <memset>
		sys_put_le24(conn->llcp_feature.features,
 10013fe:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
		ll_rx_put(rx->hdr.link, rx);
 1001402:	4639      	mov	r1, r7
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le16(u16_t val, u8_t dst[2])
{
	dst[0] = val;
	dst[1] = val >> 8;
 1001404:	f3c3 2007 	ubfx	r0, r3, #8, #8
 *  @param dst Destination memory address to store the result.
 */
static inline void sys_put_le24(u32_t val, u8_t dst[3])
{
	sys_put_le16(val, dst);
	dst[2] = val >> 16;
 1001408:	0c1a      	lsrs	r2, r3, #16
	dst[0] = val;
 100140a:	f887 3024 	strb.w	r3, [r7, #36]	; 0x24
	dst[1] = val >> 8;
 100140e:	f887 0025 	strb.w	r0, [r7, #37]	; 0x25
	dst[2] = val >> 16;
 1001412:	f887 2026 	strb.w	r2, [r7, #38]	; 0x26
 1001416:	e7a7      	b.n	1001368 <ull_conn_llcp+0x7b0>
 1001418:	210038cc 	.word	0x210038cc
 100141c:	010187e4 	.word	0x010187e4
		rx = ll_pdu_rx_alloc_peek(2);
 1001420:	2002      	movs	r0, #2
 1001422:	f008 fe03 	bl	100a02c <ll_pdu_rx_alloc_peek>
		if (!rx) {
 1001426:	4680      	mov	r8, r0
 1001428:	2800      	cmp	r0, #0
 100142a:	f43f abdc 	beq.w	1000be6 <ull_conn_llcp+0x2e>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100142e:	48bc      	ldr	r0, [pc, #752]	; (1001720 <ull_conn_llcp+0xb68>)
 1001430:	f004 fbf6 	bl	1005c20 <mem_acquire>
		if (!tx) {
 1001434:	4606      	mov	r6, r0
 1001436:	2800      	cmp	r0, #0
 1001438:	f43f abd5 	beq.w	1000be6 <ull_conn_llcp+0x2e>
		conn->llcp.phy_upd_ind.initiate = 0U;
 100143c:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
 1001440:	f36f 0300 	bfc	r3, #0, #1
		       conn->llcp.phy_upd_ind.rx) & 0x07)) {
 1001444:	f3c3 1242 	ubfx	r2, r3, #5, #3
		if (!((conn->llcp.phy_upd_ind.tx |
 1001448:	ea42 0293 	orr.w	r2, r2, r3, lsr #2
 100144c:	f012 0707 	ands.w	r7, r2, #7
		conn->llcp.phy_upd_ind.initiate = 0U;
 1001450:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
		if (!((conn->llcp.phy_upd_ind.tx |
 1001454:	b2db      	uxtb	r3, r3
 1001456:	f040 8658 	bne.w	100210a <ull_conn_llcp+0x1552>
			conn->llcp_ack = conn->llcp_req;
 100145a:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
			if (conn->llcp.phy_upd_ind.cmd) {
 100145e:	0798      	lsls	r0, r3, #30
			conn->llcp.phy_upd_ind.instant = 0U;
 1001460:	f8a4 70ee 	strh.w	r7, [r4, #238]	; 0xee
			conn->llcp_ack = conn->llcp_req;
 1001464:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
			if (conn->llcp.phy_upd_ind.cmd) {
 1001468:	f100 86d8 	bmi.w	100221c <ull_conn_llcp+0x1664>
 100146c:	463b      	mov	r3, r7
 100146e:	4638      	mov	r0, r7
		pdu_ctrl_tx->len =
 1001470:	2205      	movs	r2, #5
		pdu_ctrl_tx->llctrl.opcode =
 1001472:	2118      	movs	r1, #24
		pdu_ctrl_tx->len =
 1001474:	7172      	strb	r2, [r6, #5]
		ind->m_to_s_phy = conn->llcp.phy_upd_ind.tx;
 1001476:	7237      	strb	r7, [r6, #8]
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001478:	7932      	ldrb	r2, [r6, #4]
		ind->s_to_m_phy = conn->llcp.phy_upd_ind.rx;
 100147a:	7273      	strb	r3, [r6, #9]
	    conn->tx_head &&
 100147c:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001480:	f042 0203 	orr.w	r2, r2, #3
		ind->instant = sys_cpu_to_le16(conn->llcp.phy_upd_ind.instant);
 1001484:	8170      	strh	r0, [r6, #10]
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001486:	7132      	strb	r2, [r6, #4]
		pdu_ctrl_tx->llctrl.opcode =
 1001488:	71f1      	strb	r1, [r6, #7]
	if (
 100148a:	2b00      	cmp	r3, #0
 100148c:	f000 80f0 	beq.w	1001670 <ull_conn_llcp+0xab8>
	    !conn->llcp_enc.pause_tx &&
 1001490:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
	    conn->tx_head &&
 1001494:	0791      	lsls	r1, r2, #30
 1001496:	f100 80eb 	bmi.w	1001670 <ull_conn_llcp+0xab8>
	    !conn->llcp_phy.pause_tx &&
 100149a:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
 100149e:	07d2      	lsls	r2, r2, #31
 10014a0:	f100 80e6 	bmi.w	1001670 <ull_conn_llcp+0xab8>
		if (conn->tx_head == conn->tx_data) {
 10014a4:	f8d4 21bc 	ldr.w	r2, [r4, #444]	; 0x1bc
 10014a8:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 10014aa:	bf04      	itt	eq
 10014ac:	681a      	ldreq	r2, [r3, #0]
 10014ae:	f8c4 21bc 	streq.w	r2, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 10014b2:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 10014b6:	2a00      	cmp	r2, #0
 10014b8:	f000 871a 	beq.w	10022f0 <ull_conn_llcp+0x1738>
	tx->next = conn->tx_ctrl_last->next;
 10014bc:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 10014c0:	681a      	ldr	r2, [r3, #0]
 10014c2:	6032      	str	r2, [r6, #0]
	conn->tx_ctrl_last->next = tx;
 10014c4:	601e      	str	r6, [r3, #0]
	conn->tx_ctrl_last = tx;
 10014c6:	f8c4 61b8 	str.w	r6, [r4, #440]	; 0x1b8
 10014ca:	6833      	ldr	r3, [r6, #0]
	if (!tx->next) {
 10014cc:	2b00      	cmp	r3, #0
 10014ce:	f47f ab8a 	bne.w	1000be6 <ull_conn_llcp+0x2e>
		conn->tx_data_last = tx;
 10014d2:	f8c4 61c0 	str.w	r6, [r4, #448]	; 0x1c0
 10014d6:	f7ff bb86 	b.w	1000be6 <ull_conn_llcp+0x2e>
		rx = ll_pdu_rx_alloc_peek(1);
 10014da:	2001      	movs	r0, #1
 10014dc:	f008 fda6 	bl	100a02c <ll_pdu_rx_alloc_peek>
		if (!rx) {
 10014e0:	4680      	mov	r8, r0
 10014e2:	2800      	cmp	r0, #0
 10014e4:	f43f ab7f 	beq.w	1000be6 <ull_conn_llcp+0x2e>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 10014e8:	488d      	ldr	r0, [pc, #564]	; (1001720 <ull_conn_llcp+0xb68>)
 10014ea:	f004 fb99 	bl	1005c20 <mem_acquire>
		if (!tx) {
 10014ee:	4605      	mov	r5, r0
 10014f0:	2800      	cmp	r0, #0
 10014f2:	f43f ab78 	beq.w	1000be6 <ull_conn_llcp+0x2e>
		(void)ll_pdu_rx_alloc();
 10014f6:	f008 fdb7 	bl	100a068 <ll_pdu_rx_alloc>
		rx->hdr.link->mem = conn->llcp_rx;
 10014fa:	f8d8 3000 	ldr.w	r3, [r8]
 10014fe:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
 1001502:	605a      	str	r2, [r3, #4]
		switch (conn->llcp_cu.state) {
 1001504:	f894 3106 	ldrb.w	r3, [r4, #262]	; 0x106
		conn->llcp_rx = rx;
 1001508:	f8c4 8100 	str.w	r8, [r4, #256]	; 0x100
		switch (conn->llcp_cu.state) {
 100150c:	f003 0303 	and.w	r3, r3, #3
 1001510:	2b01      	cmp	r3, #1
 1001512:	f000 8581 	beq.w	1002018 <ull_conn_llcp+0x1460>
 1001516:	2b02      	cmp	r3, #2
 1001518:	f000 8556 	beq.w	1001fc8 <ull_conn_llcp+0x1410>
			LL_ASSERT(0);
 100151c:	f640 018f 	movw	r1, #2191	; 0x88f
 1001520:	4880      	ldr	r0, [pc, #512]	; (1001724 <ull_conn_llcp+0xb6c>)
 1001522:	f002 f831 	bl	1003588 <bt_ctlr_assert_handle>
		void (*fp_mfy_select_or_use)(void *) = NULL;
 1001526:	2100      	movs	r1, #0
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, conn_update_ind) +
 1001528:	f04f 0e0c 	mov.w	lr, #12
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND;
 100152c:	f04f 0c00 	mov.w	ip, #0
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
 1001530:	f894 2106 	ldrb.w	r2, [r4, #262]	; 0x106
	conn->llcp.conn_upd.instant = event_counter + conn->lll.latency + 6;
 1001534:	8e23      	ldrh	r3, [r4, #48]	; 0x30
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
 1001536:	f36f 0201 	bfc	r2, #0, #2
	conn->llcp.conn_upd.instant = event_counter + conn->lll.latency + 6;
 100153a:	443b      	add	r3, r7
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
 100153c:	f884 2106 	strb.w	r2, [r4, #262]	; 0x106
	conn->llcp.conn_upd.instant = event_counter + conn->lll.latency + 6;
 1001540:	3306      	adds	r3, #6
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001542:	792a      	ldrb	r2, [r5, #4]
	conn->llcp.conn_upd.instant = event_counter + conn->lll.latency + 6;
 1001544:	b298      	uxth	r0, r3
 1001546:	f8a4 00ec 	strh.w	r0, [r4, #236]	; 0xec
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100154a:	f042 0203 	orr.w	r2, r2, #3
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, conn_update_ind) +
 100154e:	f885 e005 	strb.w	lr, [r5, #5]
		sys_cpu_to_le16(conn->llcp_cu.win_offset_us / 1250U);
 1001552:	f8d4 3110 	ldr.w	r3, [r4, #272]	; 0x110
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001556:	712a      	strb	r2, [r5, #4]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_UPDATE_IND;
 1001558:	f885 c007 	strb.w	ip, [r5, #7]
	pdu_ctrl_tx->llctrl.conn_update_ind.win_size = conn->llcp_cu.win_size;
 100155c:	f894 2114 	ldrb.w	r2, [r4, #276]	; 0x114
		sys_cpu_to_le16(conn->llcp_cu.win_offset_us / 1250U);
 1001560:	4f71      	ldr	r7, [pc, #452]	; (1001728 <ull_conn_llcp+0xb70>)
 1001562:	fba7 7303 	umull	r7, r3, r7, r3
	pdu_ctrl_tx->llctrl.conn_update_ind.interval =
 1001566:	f8b4 7108 	ldrh.w	r7, [r4, #264]	; 0x108
	pdu_ctrl_tx->llctrl.conn_update_ind.win_size = conn->llcp_cu.win_size;
 100156a:	722a      	strb	r2, [r5, #8]
	pdu_ctrl_tx->llctrl.conn_update_ind.latency =
 100156c:	f8b4 210a 	ldrh.w	r2, [r4, #266]	; 0x10a
	pdu_ctrl_tx->llctrl.conn_update_ind.interval =
 1001570:	f8a5 700b 	strh.w	r7, [r5, #11]
	pdu_ctrl_tx->llctrl.conn_update_ind.timeout =
 1001574:	f8b4 710c 	ldrh.w	r7, [r4, #268]	; 0x10c
	pdu_ctrl_tx->llctrl.conn_update_ind.latency =
 1001578:	f8a5 200d 	strh.w	r2, [r5, #13]
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
 100157c:	6822      	ldr	r2, [r4, #0]
	pdu_ctrl_tx->llctrl.conn_update_ind.win_offset =
 100157e:	f3c3 238f 	ubfx	r3, r3, #10, #16
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
 1001582:	4562      	cmp	r2, ip
	pdu_ctrl_tx->llctrl.conn_update_ind.instant =
 1001584:	f8a5 0011 	strh.w	r0, [r5, #17]
	pdu_ctrl_tx->llctrl.conn_update_ind.timeout =
 1001588:	f8a5 700f 	strh.w	r7, [r5, #15]
	pdu_ctrl_tx->llctrl.conn_update_ind.win_offset =
 100158c:	f8a5 3009 	strh.w	r3, [r5, #9]
		conn->llcp.conn_upd.ticks_anchor = ticks_at_expire;
 1001590:	f8c4 60f4 	str.w	r6, [r4, #244]	; 0xf4
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
 1001594:	da0a      	bge.n	10015ac <ull_conn_llcp+0x9f4>
			u32_t ticks_prepare_to_start =
 1001596:	e9d4 0301 	ldrd	r0, r3, [r4, #4]
			conn->llcp.conn_upd.ticks_anchor -=
 100159a:	4283      	cmp	r3, r0
 100159c:	bf2c      	ite	cs
 100159e:	18f6      	addcs	r6, r6, r3
 10015a0:	1836      	addcc	r6, r6, r0
				(conn->evt.ticks_xtal_to_start &
 10015a2:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
			conn->llcp.conn_upd.ticks_anchor -=
 10015a6:	1ab2      	subs	r2, r6, r2
 10015a8:	f8c4 20f4 	str.w	r2, [r4, #244]	; 0xf4
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 10015ac:	2201      	movs	r2, #1
		mfy_sched_offset->fp = fp_mfy_select_or_use;
 10015ae:	4b5f      	ldr	r3, [pc, #380]	; (100172c <ull_conn_llcp+0xb74>)
		conn->llcp.conn_upd.pdu_win_offset = (u16_t *)
 10015b0:	f105 0609 	add.w	r6, r5, #9
		mfy_sched_offset->fp = fp_mfy_select_or_use;
 10015b4:	60d9      	str	r1, [r3, #12]
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 10015b6:	4610      	mov	r0, r2
 10015b8:	2102      	movs	r1, #2
		conn->llcp.conn_upd.pdu_win_offset = (u16_t *)
 10015ba:	f8c4 60f0 	str.w	r6, [r4, #240]	; 0xf0
		mfy_sched_offset->param = (void *)conn;
 10015be:	609c      	str	r4, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 10015c0:	f004 fc06 	bl	1005dd0 <mayfly_enqueue>
		LL_ASSERT(!retval);
 10015c4:	2800      	cmp	r0, #0
 10015c6:	f040 852a 	bne.w	100201e <ull_conn_llcp+0x1466>
	    conn->tx_head &&
 10015ca:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
	if (
 10015ce:	2b00      	cmp	r3, #0
 10015d0:	f000 82ce 	beq.w	1001b70 <ull_conn_llcp+0xfb8>
	    !conn->llcp_enc.pause_tx &&
 10015d4:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
	    conn->tx_head &&
 10015d8:	0790      	lsls	r0, r2, #30
 10015da:	f100 82c9 	bmi.w	1001b70 <ull_conn_llcp+0xfb8>
	    !conn->llcp_phy.pause_tx &&
 10015de:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
 10015e2:	07d1      	lsls	r1, r2, #31
 10015e4:	f100 82c4 	bmi.w	1001b70 <ull_conn_llcp+0xfb8>
		if (conn->tx_head == conn->tx_data) {
 10015e8:	f8d4 21bc 	ldr.w	r2, [r4, #444]	; 0x1bc
 10015ec:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 10015ee:	bf04      	itt	eq
 10015f0:	681a      	ldreq	r2, [r3, #0]
 10015f2:	f8c4 21bc 	streq.w	r2, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 10015f6:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 10015fa:	2a00      	cmp	r2, #0
 10015fc:	f000 8680 	beq.w	1002300 <ull_conn_llcp+0x1748>
	tx->next = conn->tx_ctrl_last->next;
 1001600:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 1001604:	681a      	ldr	r2, [r3, #0]
 1001606:	602a      	str	r2, [r5, #0]
	conn->tx_ctrl_last->next = tx;
 1001608:	601d      	str	r5, [r3, #0]
	conn->tx_ctrl_last = tx;
 100160a:	f8c4 51b8 	str.w	r5, [r4, #440]	; 0x1b8
 100160e:	682b      	ldr	r3, [r5, #0]
	if (!tx->next) {
 1001610:	2b00      	cmp	r3, #0
 1001612:	f47f aae8 	bne.w	1000be6 <ull_conn_llcp+0x2e>
		conn->tx_data_last = tx;
 1001616:	f8c4 51c0 	str.w	r5, [r4, #448]	; 0x1c0
 100161a:	f7ff bae4 	b.w	1000be6 <ull_conn_llcp+0x2e>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100161e:	4840      	ldr	r0, [pc, #256]	; (1001720 <ull_conn_llcp+0xb68>)
 1001620:	f004 fafe 	bl	1005c20 <mem_acquire>
		if (tx) {
 1001624:	4606      	mov	r6, r0
 1001626:	2800      	cmp	r0, #0
 1001628:	f43f aadd 	beq.w	1000be6 <ull_conn_llcp+0x2e>
			pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl,
 100162c:	2708      	movs	r7, #8
			pdu_ctrl_tx->llctrl.opcode =
 100162e:	2001      	movs	r0, #1
			conn->llcp.chan_map.instant = event_counter +
 1001630:	8e23      	ldrh	r3, [r4, #48]	; 0x30
			conn->llcp.chan_map.initiate = 0U;
 1001632:	f894 10ec 	ldrb.w	r1, [r4, #236]	; 0xec
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001636:	7932      	ldrb	r2, [r6, #4]
			conn->llcp.chan_map.instant = event_counter +
 1001638:	441d      	add	r5, r3
						      conn->lll.latency + 6;
 100163a:	1dab      	adds	r3, r5, #6
			conn->llcp.chan_map.initiate = 0U;
 100163c:	f36f 0100 	bfc	r1, #0, #1
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001640:	f042 0203 	orr.w	r2, r2, #3
			conn->llcp.chan_map.instant = event_counter +
 1001644:	f8a4 30f2 	strh.w	r3, [r4, #242]	; 0xf2
			conn->llcp.chan_map.initiate = 0U;
 1001648:	f884 10ec 	strb.w	r1, [r4, #236]	; 0xec
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100164c:	7132      	strb	r2, [r6, #4]
			pdu_ctrl_tx->llctrl.opcode =
 100164e:	71f0      	strb	r0, [r6, #7]
			memcpy(&pdu_ctrl_tx->llctrl.chan_map_ind.chm[0],
 1001650:	2205      	movs	r2, #5
			pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl,
 1001652:	7177      	strb	r7, [r6, #5]
			memcpy(&pdu_ctrl_tx->llctrl.chan_map_ind.chm[0],
 1001654:	f104 01ed 	add.w	r1, r4, #237	; 0xed
 1001658:	19f0      	adds	r0, r6, r7
 100165a:	f015 f92d 	bl	10168b8 <memcpy>
			pdu_ctrl_tx->llctrl.chan_map_ind.instant =
 100165e:	f8b4 20f2 	ldrh.w	r2, [r4, #242]	; 0xf2
	    conn->tx_head &&
 1001662:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
			pdu_ctrl_tx->llctrl.chan_map_ind.instant =
 1001666:	f8a6 200d 	strh.w	r2, [r6, #13]
	if (
 100166a:	2b00      	cmp	r3, #0
 100166c:	f47f af10 	bne.w	1001490 <ull_conn_llcp+0x8d8>
		if (!conn->tx_ctrl) {
 1001670:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 1001674:	2a00      	cmp	r2, #0
 1001676:	f47f af21 	bne.w	10014bc <ull_conn_llcp+0x904>
			tx->next = conn->tx_head;
 100167a:	6033      	str	r3, [r6, #0]
				conn->tx_ctrl = tx;
 100167c:	e9c4 666c 	strd	r6, r6, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 1001680:	f8c4 61b8 	str.w	r6, [r4, #440]	; 0x1b8
 1001684:	e722      	b.n	10014cc <ull_conn_llcp+0x914>
		conn_upd_curr = conn;
 1001686:	f8c9 4000 	str.w	r4, [r9]
 100168a:	f7ff bb48 	b.w	1000d1e <ull_conn_llcp+0x166>
		lll->max_rx_octets = conn->llcp_length.rx_octets;
 100168e:	f8b4 119c 	ldrh.w	r1, [r4, #412]	; 0x19c
		lll->max_rx_time = conn->llcp_length.rx_time;
 1001692:	f8b4 21a0 	ldrh.w	r2, [r4, #416]	; 0x1a0
		if (conn->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {
 1001696:	f000 0007 	and.w	r0, r0, #7
 100169a:	2804      	cmp	r0, #4
		tx_octets = conn->llcp_length.tx_octets;
 100169c:	f8b4 919e 	ldrh.w	r9, [r4, #414]	; 0x19e
		u16_t tx_time = conn->llcp_length.tx_time;
 10016a0:	f8b4 81a2 	ldrh.w	r8, [r4, #418]	; 0x1a2
		lll->max_rx_octets = conn->llcp_length.rx_octets;
 10016a4:	f8a4 105e 	strh.w	r1, [r4, #94]	; 0x5e
		lll->max_rx_time = conn->llcp_length.rx_time;
 10016a8:	f8a4 2062 	strh.w	r2, [r4, #98]	; 0x62
		if (conn->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {
 10016ac:	f000 84be 	beq.w	100202c <ull_conn_llcp+0x1474>
			conn->llcp_length.state =
 10016b0:	2006      	movs	r0, #6
 10016b2:	f894 319a 	ldrb.w	r3, [r4, #410]	; 0x19a
 10016b6:	f360 0302 	bfi	r3, r0, #0, #3
 10016ba:	f884 319a 	strb.w	r3, [r4, #410]	; 0x19a
		rx = conn->llcp_rx;
 10016be:	f8d4 7100 	ldr.w	r7, [r4, #256]	; 0x100
		LL_ASSERT(rx && rx->hdr.link);
 10016c2:	2f00      	cmp	r7, #0
 10016c4:	f000 849c 	beq.w	1002000 <ull_conn_llcp+0x1448>
 10016c8:	6838      	ldr	r0, [r7, #0]
 10016ca:	2800      	cmp	r0, #0
 10016cc:	f000 8498 	beq.w	1002000 <ull_conn_llcp+0x1448>
		pdu_ctrl_rx->len =
 10016d0:	f04f 0e09 	mov.w	lr, #9
		pdu_ctrl_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 10016d4:	f04f 0c15 	mov.w	ip, #21
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 10016d8:	f04f 0a02 	mov.w	sl, #2
		pdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;
 10016dc:	f897 3020 	ldrb.w	r3, [r7, #32]
		rx->hdr.handle = conn->lll.handle;
 10016e0:	f8b4 b02c 	ldrh.w	fp, [r4, #44]	; 0x2c
		pdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;
 10016e4:	f043 0303 	orr.w	r3, r3, #3
 10016e8:	930b      	str	r3, [sp, #44]	; 0x2c
		conn->llcp_rx = rx->hdr.link->mem;
 10016ea:	6843      	ldr	r3, [r0, #4]
 10016ec:	f8c4 3100 	str.w	r3, [r4, #256]	; 0x100
		pdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;
 10016f0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		lr->max_rx_octets = sys_cpu_to_le16(lll->max_rx_octets);
 10016f2:	84b9      	strh	r1, [r7, #36]	; 0x24
		pdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;
 10016f4:	f887 3020 	strb.w	r3, [r7, #32]
		ll_rx_put(rx->hdr.link, rx);
 10016f8:	4639      	mov	r1, r7
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
 10016fa:	84fa      	strh	r2, [r7, #38]	; 0x26
		pdu_ctrl_rx->len =
 10016fc:	f887 e021 	strb.w	lr, [r7, #33]	; 0x21
		pdu_ctrl_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 1001700:	f887 c023 	strb.w	ip, [r7, #35]	; 0x23
		rx->hdr.handle = conn->lll.handle;
 1001704:	f8a7 b006 	strh.w	fp, [r7, #6]
		lr->max_tx_octets = sys_cpu_to_le16(tx_octets);
 1001708:	f8a7 9028 	strh.w	r9, [r7, #40]	; 0x28
		lr->max_tx_time = sys_cpu_to_le16(tx_time);
 100170c:	f8a7 802a 	strh.w	r8, [r7, #42]	; 0x2a
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 1001710:	f887 a004 	strb.w	sl, [r7, #4]
		ll_rx_put(rx->hdr.link, rx);
 1001714:	f008 fc7a 	bl	100a00c <ll_rx_put>
		ll_rx_sched();
 1001718:	f008 fc82 	bl	100a020 <ll_rx_sched>
	break;
 100171c:	f7ff ba8c 	b.w	1000c38 <ull_conn_llcp+0x80>
 1001720:	210038cc 	.word	0x210038cc
 1001724:	010187e4 	.word	0x010187e4
 1001728:	d1b71759 	.word	0xd1b71759
 100172c:	210003ac 	.word	0x210003ac
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1001730:	48bf      	ldr	r0, [pc, #764]	; (1001a30 <ull_conn_llcp+0xe78>)
 1001732:	f004 fa75 	bl	1005c20 <mem_acquire>
		if (!tx) {
 1001736:	2800      	cmp	r0, #0
 1001738:	f43f aa7e 	beq.w	1000c38 <ull_conn_llcp+0x80>
		conn->llcp_length.state = LLCP_LENGTH_STATE_REQ_ACK_WAIT;
 100173c:	f04f 0801 	mov.w	r8, #1
		pdu_ctrl_tx->len =
 1001740:	2209      	movs	r2, #9
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_REQ;
 1001742:	f04f 0e14 	mov.w	lr, #20
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
 1001746:	f04f 0c00 	mov.w	ip, #0
 100174a:	271b      	movs	r7, #27
		conn->llcp_length.state = LLCP_LENGTH_STATE_REQ_ACK_WAIT;
 100174c:	f894 319a 	ldrb.w	r3, [r4, #410]	; 0x19a
		conn->default_tx_octets = conn->llcp_length.tx_octets;
 1001750:	f8b4 119e 	ldrh.w	r1, [r4, #414]	; 0x19e
		conn->llcp_length.state = LLCP_LENGTH_STATE_REQ_ACK_WAIT;
 1001754:	f368 0302 	bfi	r3, r8, #0, #3
 1001758:	f884 319a 	strb.w	r3, [r4, #410]	; 0x19a
		conn->default_tx_time = conn->llcp_length.tx_time;
 100175c:	f8b4 31a2 	ldrh.w	r3, [r4, #418]	; 0x1a2
		conn->default_tx_octets = conn->llcp_length.tx_octets;
 1001760:	f8a4 10d6 	strh.w	r1, [r4, #214]	; 0xd6
		conn->default_tx_time = conn->llcp_length.tx_time;
 1001764:	f8a4 30d8 	strh.w	r3, [r4, #216]	; 0xd8
		pdu_ctrl_tx->len =
 1001768:	7142      	strb	r2, [r0, #5]
		lr->max_tx_octets = sys_cpu_to_le16(conn->default_tx_octets);
 100176a:	8181      	strh	r1, [r0, #12]
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100176c:	7902      	ldrb	r2, [r0, #4]
	if (!conn->common.fex_valid ||
 100176e:	f894 10dc 	ldrb.w	r1, [r4, #220]	; 0xdc
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001772:	f042 0203 	orr.w	r2, r2, #3
	if (!conn->common.fex_valid ||
 1001776:	07c9      	lsls	r1, r1, #31
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001778:	7102      	strb	r2, [r0, #4]
	feature_coded_phy = (conn->llcp_feature.features &
 100177a:	f8d4 211c 	ldr.w	r2, [r4, #284]	; 0x11c
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_REQ;
 100177e:	f880 e007 	strb.w	lr, [r0, #7]
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
 1001782:	f880 c009 	strb.w	ip, [r0, #9]
 1001786:	7207      	strb	r7, [r0, #8]
	if (!conn->common.fex_valid ||
 1001788:	f140 8421 	bpl.w	1001fce <ull_conn_llcp+0x1416>
 100178c:	0512      	lsls	r2, r2, #20
 100178e:	f140 841e 	bpl.w	1001fce <ull_conn_llcp+0x1416>
		tx_time = MAX(PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M), tx_time);
 1001792:	f5b3 6f29 	cmp.w	r3, #2704	; 0xa90
 1001796:	bf28      	it	cs
 1001798:	f44f 6329 	movcs.w	r3, #2704	; 0xa90
 100179c:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
 10017a0:	f44f 6129 	mov.w	r1, #2704	; 0xa90
 10017a4:	bf38      	it	cc
 10017a6:	f44f 73a4 	movcc.w	r3, #328	; 0x148
	    conn->tx_head &&
 10017aa:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
		lr->max_rx_time = sys_cpu_to_le16(rx_time);
 10017ae:	8141      	strh	r1, [r0, #10]
		lr->max_tx_time = sys_cpu_to_le16(tx_time);
 10017b0:	81c3      	strh	r3, [r0, #14]
	if (
 10017b2:	2a00      	cmp	r2, #0
 10017b4:	f000 83fd 	beq.w	1001fb2 <ull_conn_llcp+0x13fa>
	    !conn->llcp_enc.pause_tx &&
 10017b8:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
	    conn->tx_head &&
 10017bc:	079b      	lsls	r3, r3, #30
 10017be:	f100 83f8 	bmi.w	1001fb2 <ull_conn_llcp+0x13fa>
	    !conn->llcp_phy.pause_tx &&
 10017c2:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
 10017c6:	07df      	lsls	r7, r3, #31
 10017c8:	f100 83f3 	bmi.w	1001fb2 <ull_conn_llcp+0x13fa>
		if (conn->tx_head == conn->tx_data) {
 10017cc:	f8d4 31bc 	ldr.w	r3, [r4, #444]	; 0x1bc
 10017d0:	429a      	cmp	r2, r3
			conn->tx_data = conn->tx_data->next;
 10017d2:	bf04      	itt	eq
 10017d4:	6813      	ldreq	r3, [r2, #0]
 10017d6:	f8c4 31bc 	streq.w	r3, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 10017da:	f8d4 31b4 	ldr.w	r3, [r4, #436]	; 0x1b4
 10017de:	2b00      	cmp	r3, #0
 10017e0:	f000 85aa 	beq.w	1002338 <ull_conn_llcp+0x1780>
	tx->next = conn->tx_ctrl_last->next;
 10017e4:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 10017e8:	681a      	ldr	r2, [r3, #0]
 10017ea:	6002      	str	r2, [r0, #0]
	conn->tx_ctrl_last->next = tx;
 10017ec:	6018      	str	r0, [r3, #0]
	conn->tx_ctrl_last = tx;
 10017ee:	f8c4 01b8 	str.w	r0, [r4, #440]	; 0x1b8
 10017f2:	6802      	ldr	r2, [r0, #0]
	if (!tx->next) {
 10017f4:	2a00      	cmp	r2, #0
 10017f6:	f000 8505 	beq.w	1002204 <ull_conn_llcp+0x164c>
		conn->procedure_expire = conn->procedure_reload;
 10017fa:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
 10017fe:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	break;
 1001802:	f7ff ba19 	b.w	1000c38 <ull_conn_llcp+0x80>
		if (!conn->tx_ctrl) {
 1001806:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 100180a:	2a00      	cmp	r2, #0
 100180c:	f47f ad56 	bne.w	10012bc <ull_conn_llcp+0x704>
			tx->next = conn->tx_head;
 1001810:	6003      	str	r3, [r0, #0]
				conn->tx_ctrl = tx;
 1001812:	e9c4 006c 	strd	r0, r0, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 1001816:	f8c4 01b8 	str.w	r0, [r4, #440]	; 0x1b8
 100181a:	e557      	b.n	10012cc <ull_conn_llcp+0x714>
			ecb_encrypt(&conn->llcp_enc.ltk[0],
 100181c:	f104 077f 	add.w	r7, r4, #127	; 0x7f
 1001820:	463b      	mov	r3, r7
 1001822:	462a      	mov	r2, r5
 1001824:	f104 01ee 	add.w	r1, r4, #238	; 0xee
 1001828:	f204 105d 	addw	r0, r4, #349	; 0x15d
 100182c:	f010 f8c8 	bl	10119c0 <ecb_encrypt>
			memcpy(&lll->ccm_tx.key[0],
 1001830:	4639      	mov	r1, r7
			pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl,
 1001832:	2701      	movs	r7, #1
			memcpy(&lll->ccm_tx.key[0],
 1001834:	2210      	movs	r2, #16
 1001836:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
 100183a:	f015 f83d 	bl	10168b8 <memcpy>
			memcpy(&lll->ccm_tx.iv[0], &lll->ccm_rx.iv[0],
 100183e:	2208      	movs	r2, #8
 1001840:	f104 0198 	add.w	r1, r4, #152	; 0x98
 1001844:	f104 00b9 	add.w	r0, r4, #185	; 0xb9
 1001848:	f015 f836 	bl	10168b8 <memcpy>
			pdu_ctrl_tx->llctrl.opcode =
 100184c:	2005      	movs	r0, #5
			lll->ccm_rx.direction = 1U;
 100184e:	f894 2097 	ldrb.w	r2, [r4, #151]	; 0x97
			lll->ccm_tx.direction = 0U;
 1001852:	f894 10b8 	ldrb.w	r1, [r4, #184]	; 0xb8
			lll->enc_rx = 1U;
 1001856:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
			lll->ccm_rx.direction = 1U;
 100185a:	433a      	orrs	r2, r7
			lll->enc_rx = 1U;
 100185c:	f043 0308 	orr.w	r3, r3, #8
			lll->ccm_tx.direction = 0U;
 1001860:	f365 0100 	bfi	r1, r5, #0, #1
			lll->ccm_rx.direction = 1U;
 1001864:	f884 2097 	strb.w	r2, [r4, #151]	; 0x97
			lll->enc_rx = 1U;
 1001868:	f884 307e 	strb.w	r3, [r4, #126]	; 0x7e
			lll->ccm_tx.counter = 0U;
 100186c:	e9c4 552c 	strd	r5, r5, [r4, #176]	; 0xb0
			lll->ccm_rx.counter = 0U;
 1001870:	f884 508f 	strb.w	r5, [r4, #143]	; 0x8f
 1001874:	f884 5090 	strb.w	r5, [r4, #144]	; 0x90
 1001878:	f884 5091 	strb.w	r5, [r4, #145]	; 0x91
 100187c:	f884 5092 	strb.w	r5, [r4, #146]	; 0x92
 1001880:	f884 5093 	strb.w	r5, [r4, #147]	; 0x93
 1001884:	f884 5094 	strb.w	r5, [r4, #148]	; 0x94
 1001888:	f884 5095 	strb.w	r5, [r4, #149]	; 0x95
 100188c:	f884 5096 	strb.w	r5, [r4, #150]	; 0x96
			lll->ccm_tx.direction = 0U;
 1001890:	f884 10b8 	strb.w	r1, [r4, #184]	; 0xb8
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001894:	7932      	ldrb	r2, [r6, #4]
			pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl,
 1001896:	7177      	strb	r7, [r6, #5]
	    conn->tx_head &&
 1001898:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
			pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100189c:	f042 0203 	orr.w	r2, r2, #3
 10018a0:	7132      	strb	r2, [r6, #4]
			pdu_ctrl_tx->llctrl.opcode =
 10018a2:	71f0      	strb	r0, [r6, #7]
	if (
 10018a4:	2b00      	cmp	r3, #0
 10018a6:	f47f ac8c 	bne.w	10011c2 <ull_conn_llcp+0x60a>
		if (!conn->tx_ctrl) {
 10018aa:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 10018ae:	2a00      	cmp	r2, #0
 10018b0:	f47f ac9d 	bne.w	10011ee <ull_conn_llcp+0x636>
			tx->next = conn->tx_head;
 10018b4:	6033      	str	r3, [r6, #0]
				conn->tx_ctrl = tx;
 10018b6:	e9c4 666c 	strd	r6, r6, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 10018ba:	f8c4 61b8 	str.w	r6, [r4, #440]	; 0x1b8
 10018be:	e49e      	b.n	10011fe <ull_conn_llcp+0x646>
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
 10018c0:	f240 40e2 	movw	r0, #1250	; 0x4e2
 10018c4:	a358      	add	r3, pc, #352	; (adr r3, 1001a28 <ull_conn_llcp+0xe70>)
 10018c6:	e9d3 2300 	ldrd	r2, r3, [r3]
 10018ca:	fb09 111c 	mls	r1, r9, ip, r1
 10018ce:	b289      	uxth	r1, r1
 10018d0:	fb00 f101 	mul.w	r1, r0, r1
 10018d4:	4857      	ldr	r0, [pc, #348]	; (1001a34 <ull_conn_llcp+0xe7c>)
 10018d6:	fba1 0100 	umull	r0, r1, r1, r0
 10018da:	f7fe fbed 	bl	10000b8 <__aeabi_uldivmod>
 10018de:	1a36      	subs	r6, r6, r0
 10018e0:	f7ff baaa 	b.w	1000e38 <ull_conn_llcp+0x280>
		LL_ASSERT(rx && rx->hdr.link);
 10018e4:	4854      	ldr	r0, [pc, #336]	; (1001a38 <ull_conn_llcp+0xe80>)
 10018e6:	f44f 610c 	mov.w	r1, #2240	; 0x8c0
 10018ea:	f001 fe4d 	bl	1003588 <bt_ctlr_assert_handle>
 10018ee:	f8d9 0000 	ldr.w	r0, [r9]
 10018f2:	f7ff ba52 	b.w	1000d9a <ull_conn_llcp+0x1e2>
		} else if (conn->llcp_conn_param.ack !=
 10018f6:	f894 c171 	ldrb.w	ip, [r4, #369]	; 0x171
 10018fa:	f894 7170 	ldrb.w	r7, [r4, #368]	; 0x170
 10018fe:	45bc      	cmp	ip, r7
 1001900:	f000 8260 	beq.w	1001dc4 <ull_conn_llcp+0x120c>
	conn_upd = conn_upd_curr;
 1001904:	f8df 9134 	ldr.w	r9, [pc, #308]	; 1001a3c <ull_conn_llcp+0xe84>
 1001908:	f8d9 7000 	ldr.w	r7, [r9]
	if (conn_upd && (conn_upd != conn)) {
 100190c:	2f00      	cmp	r7, #0
 100190e:	f000 84ab 	beq.w	1002268 <ull_conn_llcp+0x16b0>
 1001912:	42bc      	cmp	r4, r7
 1001914:	f47f a967 	bne.w	1000be6 <ull_conn_llcp+0x2e>
	switch (conn->llcp_conn_param.state) {
 1001918:	f894 7172 	ldrb.w	r7, [r4, #370]	; 0x172
 100191c:	f007 0707 	and.w	r7, r7, #7
 1001920:	2f05      	cmp	r7, #5
 1001922:	f200 8645 	bhi.w	10025b0 <ull_conn_llcp+0x19f8>
 1001926:	f20f 0c08 	addw	ip, pc, #8
 100192a:	f85c f027 	ldr.w	pc, [ip, r7, lsl #2]
 100192e:	bf00      	nop
 1001930:	01001a41 	.word	0x01001a41
 1001934:	010019a9 	.word	0x010019a9
 1001938:	01001949 	.word	0x01001949
 100193c:	01000bdd 	.word	0x01000bdd
 1001940:	01000bdd 	.word	0x01000bdd
 1001944:	01000bdd 	.word	0x01000bdd
	if (conn->llcp_enc.pause_tx) {
 1001948:	0783      	lsls	r3, r0, #30
 100194a:	f53f a94c 	bmi.w	1000be6 <ull_conn_llcp+0x2e>
	rx = ll_pdu_rx_alloc();
 100194e:	f008 fb8b 	bl	100a068 <ll_pdu_rx_alloc>
	if (!rx) {
 1001952:	4601      	mov	r1, r0
 1001954:	2800      	cmp	r0, #0
 1001956:	f43f ad0c 	beq.w	1001372 <ull_conn_llcp+0x7ba>
	conn->llcp_conn_param.state = LLCP_CPR_STATE_APP_WAIT;
 100195a:	2303      	movs	r3, #3
	rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 100195c:	f04f 0e02 	mov.w	lr, #2
	pdu->len = offsetof(struct pdu_data_llctrl, conn_param_req) +
 1001960:	f04f 0c18 	mov.w	ip, #24
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
 1001964:	200f      	movs	r0, #15
	conn->llcp_conn_param.state = LLCP_CPR_STATE_APP_WAIT;
 1001966:	f894 2172 	ldrb.w	r2, [r4, #370]	; 0x172
	rx->hdr.handle = conn->lll.handle;
 100196a:	8da7      	ldrh	r7, [r4, #44]	; 0x2c
	conn->llcp_conn_param.state = LLCP_CPR_STATE_APP_WAIT;
 100196c:	f363 0202 	bfi	r2, r3, #0, #3
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1001970:	f891 3020 	ldrb.w	r3, [r1, #32]
	conn->llcp_conn_param.state = LLCP_CPR_STATE_APP_WAIT;
 1001974:	f884 2172 	strb.w	r2, [r4, #370]	; 0x172
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1001978:	f043 0303 	orr.w	r3, r3, #3
 100197c:	f881 3020 	strb.w	r3, [r1, #32]
	rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 1001980:	f881 e004 	strb.w	lr, [r1, #4]
	pdu->len = offsetof(struct pdu_data_llctrl, conn_param_req) +
 1001984:	f881 c021 	strb.w	ip, [r1, #33]	; 0x21
	p->interval_min = sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
 1001988:	f8b4 2174 	ldrh.w	r2, [r4, #372]	; 0x174
	p->interval_max = sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
 100198c:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
	p->interval_min = sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
 1001990:	848a      	strh	r2, [r1, #36]	; 0x24
	p->latency = sys_cpu_to_le16(conn->llcp_conn_param.latency);
 1001992:	f8b4 2178 	ldrh.w	r2, [r4, #376]	; 0x178
	p->interval_max = sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
 1001996:	84cb      	strh	r3, [r1, #38]	; 0x26
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
 1001998:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
	rx->hdr.handle = conn->lll.handle;
 100199c:	80cf      	strh	r7, [r1, #6]
	p->latency = sys_cpu_to_le16(conn->llcp_conn_param.latency);
 100199e:	850a      	strh	r2, [r1, #40]	; 0x28
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
 10019a0:	854b      	strh	r3, [r1, #42]	; 0x2a
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
 10019a2:	f881 0023 	strb.w	r0, [r1, #35]	; 0x23
	ll_rx_put(rx->hdr.link, rx);
 10019a6:	e4df      	b.n	1001368 <ull_conn_llcp+0x7b0>
	if (conn->llcp_conn_param.status) {
 10019a8:	f894 7173 	ldrb.w	r7, [r4, #371]	; 0x173
 10019ac:	2f00      	cmp	r7, #0
 10019ae:	f040 84ea 	bne.w	1002386 <ull_conn_llcp+0x17ce>
	if (!conn->lll.role) {
 10019b2:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
 10019b6:	2b00      	cmp	r3, #0
 10019b8:	f2c0 855c 	blt.w	1002474 <ull_conn_llcp+0x18bc>
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
 10019bc:	2505      	movs	r5, #5
		conn->llcp_cu.win_size = 1U;
 10019be:	2001      	movs	r0, #1
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
 10019c0:	f894 2172 	ldrb.w	r2, [r4, #370]	; 0x172
		if (conn->llcp_conn_param.preferred_periodicity) {
 10019c4:	f894 317c 	ldrb.w	r3, [r4, #380]	; 0x17c
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
 10019c8:	f365 0202 	bfi	r2, r5, #0, #3
		conn->llcp_cu.win_offset_us = 0U;
 10019cc:	f8c4 7110 	str.w	r7, [r4, #272]	; 0x110
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
 10019d0:	f884 2172 	strb.w	r2, [r4, #370]	; 0x172
		conn->llcp_cu.win_size = 1U;
 10019d4:	f884 0114 	strb.w	r0, [r4, #276]	; 0x114
		if (conn->llcp_conn_param.preferred_periodicity) {
 10019d8:	2b00      	cmp	r3, #0
 10019da:	f000 85a9 	beq.w	1002530 <ull_conn_llcp+0x1978>
				((conn->llcp_conn_param.interval_min /
 10019de:	f8b4 2174 	ldrh.w	r2, [r4, #372]	; 0x174
 10019e2:	fbb2 f2f3 	udiv	r2, r2, r3
			conn->llcp_cu.interval =
 10019e6:	fb02 3303 	mla	r3, r2, r3, r3
 10019ea:	b29a      	uxth	r2, r3
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
 10019ec:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
		conn->llcp_cu.state = LLCP_CUI_STATE_SELECT;
 10019f0:	f894 0106 	ldrb.w	r0, [r4, #262]	; 0x106
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
 10019f4:	f3c3 03c0 	ubfx	r3, r3, #3, #1
		conn->llcp_cu.state = LLCP_CUI_STATE_SELECT;
 10019f8:	009b      	lsls	r3, r3, #2
 10019fa:	f020 0007 	bic.w	r0, r0, #7
 10019fe:	f043 0302 	orr.w	r3, r3, #2
 1001a02:	4303      	orrs	r3, r0
		conn->llcp_cu.latency = conn->llcp_conn_param.latency;
 1001a04:	f8b4 5178 	ldrh.w	r5, [r4, #376]	; 0x178
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
 1001a08:	f8b4 017a 	ldrh.w	r0, [r4, #378]	; 0x17a
		conn->llcp_cu.ack--;
 1001a0c:	3901      	subs	r1, #1
 1001a0e:	f884 1105 	strb.w	r1, [r4, #261]	; 0x105
 1001a12:	f8a4 2108 	strh.w	r2, [r4, #264]	; 0x108
		conn->llcp_cu.state = LLCP_CUI_STATE_SELECT;
 1001a16:	f884 3106 	strb.w	r3, [r4, #262]	; 0x106
		conn->llcp_cu.latency = conn->llcp_conn_param.latency;
 1001a1a:	f8a4 510a 	strh.w	r5, [r4, #266]	; 0x10a
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
 1001a1e:	f8a4 010c 	strh.w	r0, [r4, #268]	; 0x10c
		return;
 1001a22:	f7ff b8e0 	b.w	1000be6 <ull_conn_llcp+0x2e>
 1001a26:	bf00      	nop
 1001a28:	1afd498d 	.word	0x1afd498d
 1001a2c:	00000007 	.word	0x00000007
 1001a30:	210038cc 	.word	0x210038cc
 1001a34:	3b9aca00 	.word	0x3b9aca00
 1001a38:	010187e4 	.word	0x010187e4
 1001a3c:	210037c0 	.word	0x210037c0
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1001a40:	48d9      	ldr	r0, [pc, #868]	; (1001da8 <ull_conn_llcp+0x11f0>)
			event_counter = lll->event_counter +
 1001a42:	f8b4 8036 	ldrh.w	r8, [r4, #54]	; 0x36
					lll->latency_prepare + lazy;
 1001a46:	f8b4 a032 	ldrh.w	sl, [r4, #50]	; 0x32
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1001a4a:	f004 f8e9 	bl	1005c20 <mem_acquire>
	if (!tx) {
 1001a4e:	4607      	mov	r7, r0
 1001a50:	2800      	cmp	r0, #0
 1001a52:	f43f ac8e 	beq.w	1001372 <ull_conn_llcp+0x7ba>
	conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP_WAIT;
 1001a56:	2104      	movs	r1, #4
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, conn_param_req) +
 1001a58:	f04f 0e18 	mov.w	lr, #24
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
 1001a5c:	f04f 0c0f 	mov.w	ip, #15
	p->offset1 = sys_cpu_to_le16(0xffff);
 1001a60:	f04f 30ff 	mov.w	r0, #4294967295
	p->preferred_periodicity = 0U;
 1001a64:	2200      	movs	r2, #0
			event_counter = lll->event_counter +
 1001a66:	eb08 030a 	add.w	r3, r8, sl
	conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP_WAIT;
 1001a6a:	f894 8172 	ldrb.w	r8, [r4, #370]	; 0x172
	p->reference_conn_event_count = sys_cpu_to_le16(event_counter);
 1001a6e:	442b      	add	r3, r5
	conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP_WAIT;
 1001a70:	f361 0802 	bfi	r8, r1, #0, #3
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001a74:	7939      	ldrb	r1, [r7, #4]
	conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP_WAIT;
 1001a76:	f884 8172 	strb.w	r8, [r4, #370]	; 0x172
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001a7a:	f041 0103 	orr.w	r1, r1, #3
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, conn_param_req) +
 1001a7e:	f887 e005 	strb.w	lr, [r7, #5]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001a82:	7139      	strb	r1, [r7, #4]
	p->interval_min = sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
 1001a84:	f8b4 1174 	ldrh.w	r1, [r4, #372]	; 0x174
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
 1001a88:	f887 c007 	strb.w	ip, [r7, #7]
	p->interval_min = sys_cpu_to_le16(conn->llcp_conn_param.interval_min);
 1001a8c:	8139      	strh	r1, [r7, #8]
	p->latency = sys_cpu_to_le16(conn->llcp_conn_param.latency);
 1001a8e:	f8b4 1178 	ldrh.w	r1, [r4, #376]	; 0x178
	p->interval_max = sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
 1001a92:	f8b4 c176 	ldrh.w	ip, [r4, #374]	; 0x176
	p->latency = sys_cpu_to_le16(conn->llcp_conn_param.latency);
 1001a96:	81b9      	strh	r1, [r7, #12]
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
 1001a98:	f8b4 117a 	ldrh.w	r1, [r4, #378]	; 0x17a
	p->interval_max = sys_cpu_to_le16(conn->llcp_conn_param.interval_max);
 1001a9c:	f8a7 c00a 	strh.w	ip, [r7, #10]
	p->reference_conn_event_count = sys_cpu_to_le16(event_counter);
 1001aa0:	f8a7 3011 	strh.w	r3, [r7, #17]
	p->timeout = sys_cpu_to_le16(conn->llcp_conn_param.timeout);
 1001aa4:	81f9      	strh	r1, [r7, #14]
	p->preferred_periodicity = 0U;
 1001aa6:	743a      	strb	r2, [r7, #16]
	p->offset0 = sys_cpu_to_le16(0x0000);
 1001aa8:	74fa      	strb	r2, [r7, #19]
 1001aaa:	753a      	strb	r2, [r7, #20]
	p->offset1 = sys_cpu_to_le16(0xffff);
 1001aac:	7578      	strb	r0, [r7, #21]
 1001aae:	75b8      	strb	r0, [r7, #22]
	p->offset2 = sys_cpu_to_le16(0xffff);
 1001ab0:	75f8      	strb	r0, [r7, #23]
 1001ab2:	7638      	strb	r0, [r7, #24]
	p->offset3 = sys_cpu_to_le16(0xffff);
 1001ab4:	7678      	strb	r0, [r7, #25]
 1001ab6:	76b8      	strb	r0, [r7, #26]
	p->offset4 = sys_cpu_to_le16(0xffff);
 1001ab8:	76f8      	strb	r0, [r7, #27]
 1001aba:	7738      	strb	r0, [r7, #28]
	p->offset5 = sys_cpu_to_le16(0xffff);
 1001abc:	7778      	strb	r0, [r7, #29]
 1001abe:	77b8      	strb	r0, [r7, #30]
	ctrl_tx_pause_enqueue(conn, tx, false);
 1001ac0:	4639      	mov	r1, r7
 1001ac2:	4620      	mov	r0, r4
 1001ac4:	f009 fa5c 	bl	100af80 <ctrl_tx_pause_enqueue>
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
 1001ac8:	6822      	ldr	r2, [r4, #0]
	conn->procedure_expire = conn->procedure_reload;
 1001aca:	f8b4 30ca 	ldrh.w	r3, [r4, #202]	; 0xca
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
 1001ace:	2a00      	cmp	r2, #0
	conn_upd_curr = conn;
 1001ad0:	f8c9 4000 	str.w	r4, [r9]
		conn->llcp_conn_param.ticks_ref = ticks_at_expire;
 1001ad4:	f8c4 6190 	str.w	r6, [r4, #400]	; 0x190
	conn->procedure_expire = conn->procedure_reload;
 1001ad8:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
		if (conn->evt.ticks_xtal_to_start & XON_BITMASK) {
 1001adc:	da0a      	bge.n	1001af4 <ull_conn_llcp+0xf3c>
			u32_t ticks_prepare_to_start =
 1001ade:	e9d4 1301 	ldrd	r1, r3, [r4, #4]
			conn->llcp_conn_param.ticks_ref -=
 1001ae2:	428b      	cmp	r3, r1
 1001ae4:	bf2c      	ite	cs
 1001ae6:	18f3      	addcs	r3, r6, r3
 1001ae8:	1873      	addcc	r3, r6, r1
				(conn->evt.ticks_xtal_to_start &
 1001aea:	f022 4200 	bic.w	r2, r2, #2147483648	; 0x80000000
			conn->llcp_conn_param.ticks_ref -=
 1001aee:	1a9b      	subs	r3, r3, r2
 1001af0:	f8c4 3190 	str.w	r3, [r4, #400]	; 0x190
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 1001af4:	2201      	movs	r2, #1
		s_mfy_sched_offset.param = (void *)conn;
 1001af6:	4bad      	ldr	r3, [pc, #692]	; (1001dac <ull_conn_llcp+0x11f4>)
		conn->llcp_conn_param.pdu_win_offset0 = (u16_t *)&p->offset0;
 1001af8:	3713      	adds	r7, #19
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 1001afa:	4610      	mov	r0, r2
 1001afc:	2102      	movs	r1, #2
		conn->llcp_conn_param.pdu_win_offset0 = (u16_t *)&p->offset0;
 1001afe:	f8c4 718c 	str.w	r7, [r4, #396]	; 0x18c
		s_mfy_sched_offset.param = (void *)conn;
 1001b02:	609c      	str	r4, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 1001b04:	f004 f964 	bl	1005dd0 <mayfly_enqueue>
		LL_ASSERT(!retval);
 1001b08:	2800      	cmp	r0, #0
 1001b0a:	f43f ac32 	beq.w	1001372 <ull_conn_llcp+0x7ba>
 1001b0e:	f640 3176 	movw	r1, #2934	; 0xb76
 1001b12:	48a7      	ldr	r0, [pc, #668]	; (1001db0 <ull_conn_llcp+0x11f8>)
 1001b14:	f001 fd38 	bl	1003588 <bt_ctlr_assert_handle>
 1001b18:	e42b      	b.n	1001372 <ull_conn_llcp+0x7ba>
		if ((conn->llcp_cu.interval != lll->interval) ||
 1001b1a:	8e23      	ldrh	r3, [r4, #48]	; 0x30
 1001b1c:	4573      	cmp	r3, lr
 1001b1e:	f47f a947 	bne.w	1000db0 <ull_conn_llcp+0x1f8>
		    (RADIO_CONN_EVENTS(conn->llcp_cu.timeout * 10000U,
 1001b22:	f240 41e2 	movw	r1, #1250	; 0x4e2
 1001b26:	f242 7310 	movw	r3, #10000	; 0x2710
 1001b2a:	fb01 f10c 	mul.w	r1, r1, ip
 1001b2e:	f8b4 a10c 	ldrh.w	sl, [r4, #268]	; 0x10c
		    (conn->llcp_cu.latency != lll->latency) ||
 1001b32:	f8b4 20c6 	ldrh.w	r2, [r4, #198]	; 0xc6
		    (RADIO_CONN_EVENTS(conn->llcp_cu.timeout * 10000U,
 1001b36:	fb03 130a 	mla	r3, r3, sl, r1
 1001b3a:	3b01      	subs	r3, #1
 1001b3c:	fbb3 f3f1 	udiv	r3, r3, r1
		    (conn->llcp_cu.latency != lll->latency) ||
 1001b40:	b29b      	uxth	r3, r3
 1001b42:	429a      	cmp	r2, r3
 1001b44:	f47f a936 	bne.w	1000db4 <ull_conn_llcp+0x1fc>
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 1001b48:	2303      	movs	r3, #3
 1001b4a:	f889 3004 	strb.w	r3, [r9, #4]
 1001b4e:	f7ff b940 	b.w	1000dd2 <ull_conn_llcp+0x21a>
			mayfly_enable(TICKER_USER_ID_ULL_HIGH,
 1001b52:	2201      	movs	r2, #1
 1001b54:	2102      	movs	r1, #2
 1001b56:	4610      	mov	r0, r2
 1001b58:	f004 f906 	bl	1005d68 <mayfly_enable>
				return -ECANCELED;
 1001b5c:	f06f 0047 	mvn.w	r0, #71	; 0x47
 1001b60:	f7ff b848 	b.w	1000bf4 <ull_conn_llcp+0x3c>
 1001b64:	f44f 79a4 	mov.w	r9, #328	; 0x148
 1001b68:	f8cd 902c 	str.w	r9, [sp, #44]	; 0x2c
 1001b6c:	f7ff ba4f 	b.w	100100e <ull_conn_llcp+0x456>
		if (!conn->tx_ctrl) {
 1001b70:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 1001b74:	2a00      	cmp	r2, #0
 1001b76:	f47f ad43 	bne.w	1001600 <ull_conn_llcp+0xa48>
			tx->next = conn->tx_head;
 1001b7a:	602b      	str	r3, [r5, #0]
				conn->tx_ctrl = tx;
 1001b7c:	e9c4 556c 	strd	r5, r5, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 1001b80:	f8c4 51b8 	str.w	r5, [r4, #440]	; 0x1b8
 1001b84:	e544      	b.n	1001610 <ull_conn_llcp+0xa58>
			lll->slave.window_widening_prepare_us -=
 1001b86:	6ce2      	ldr	r2, [r4, #76]	; 0x4c
				lll->slave.window_widening_periodic_us *
 1001b88:	6c63      	ldr	r3, [r4, #68]	; 0x44
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
 1001b8a:	4f8a      	ldr	r7, [pc, #552]	; (1001db4 <ull_conn_llcp+0x11fc>)
			lll->slave.window_widening_prepare_us -=
 1001b8c:	fb03 231b 	mls	r3, r3, fp, r2
 1001b90:	64e3      	str	r3, [r4, #76]	; 0x4c
				(((lll_conn_ppm_local_get() +
 1001b92:	f00f f9ab 	bl	1010eec <lll_conn_ppm_local_get>
				   lll_conn_ppm_get(conn->slave.sca)) *
 1001b96:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
				(((lll_conn_ppm_local_get() +
 1001b9a:	4680      	mov	r8, r0
				   lll_conn_ppm_get(conn->slave.sca)) *
 1001b9c:	f3c3 0082 	ubfx	r0, r3, #2, #3
 1001ba0:	f00f f9a6 	bl	1010ef0 <lll_conn_ppm_get>
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
 1001ba4:	a37e      	add	r3, pc, #504	; (adr r3, 1001da0 <ull_conn_llcp+0x11e8>)
 1001ba6:	e9d3 2300 	ldrd	r2, r3, [r3]
				(((lll_conn_ppm_local_get() +
 1001baa:	eb08 0100 	add.w	r1, r8, r0
				   lll_conn_ppm_get(conn->slave.sca)) *
 1001bae:	fb05 f101 	mul.w	r1, r5, r1
				  conn_interval_us) + (1000000 - 1)) / 1000000U;
 1001bb2:	4881      	ldr	r0, [pc, #516]	; (1001db8 <ull_conn_llcp+0x1200>)
 1001bb4:	f501 2174 	add.w	r1, r1, #999424	; 0xf4000
 1001bb8:	f201 213f 	addw	r1, r1, #575	; 0x23f
 1001bbc:	fba0 0101 	umull	r0, r1, r0, r1
 1001bc0:	ea4f 4991 	mov.w	r9, r1, lsr #18
				lll->slave.window_widening_periodic_us *
 1001bc4:	990b      	ldr	r1, [sp, #44]	; 0x2c
				(conn_interval_us >> 1) - EVENT_IFS_US;
 1001bc6:	ea4f 0c55 	mov.w	ip, r5, lsr #1
				lll->slave.window_widening_periodic_us *
 1001bca:	fb09 f001 	mul.w	r0, r9, r1
			lll->slave.window_widening_prepare_us +=
 1001bce:	6ce1      	ldr	r1, [r4, #76]	; 0x4c
				(conn_interval_us >> 1) - EVENT_IFS_US;
 1001bd0:	f1ac 0c96 	sub.w	ip, ip, #150	; 0x96
			lll->slave.window_widening_prepare_us +=
 1001bd4:	4401      	add	r1, r0
 1001bd6:	4561      	cmp	r1, ip
 1001bd8:	bf28      	it	cs
 1001bda:	4661      	movcs	r1, ip
			conn->slave.ticks_to_offset = 0U;
 1001bdc:	f04f 0800 	mov.w	r8, #0
				conn->llcp_cu.win_size * 1250U;
 1001be0:	f894 e114 	ldrb.w	lr, [r4, #276]	; 0x114
			lll->slave.window_widening_max_us =
 1001be4:	e9c4 c112 	strd	ip, r1, [r4, #72]	; 0x48
				conn->llcp_cu.win_size * 1250U;
 1001be8:	fb0a fe0e 	mul.w	lr, sl, lr
			lll->slave.window_widening_periodic_us =
 1001bec:	f8c4 9044 	str.w	r9, [r4, #68]	; 0x44
			lll->slave.window_size_prepare_us =
 1001bf0:	f8c4 e054 	str.w	lr, [r4, #84]	; 0x54
			conn->slave.ticks_to_offset = 0U;
 1001bf4:	f8c4 80e4 	str.w	r8, [r4, #228]	; 0xe4
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
 1001bf8:	fba0 0107 	umull	r0, r1, r0, r7
 1001bfc:	f7fe fa5c 	bl	10000b8 <__aeabi_uldivmod>
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
 1001c00:	a367      	add	r3, pc, #412	; (adr r3, 1001da0 <ull_conn_llcp+0x11e8>)
 1001c02:	e9d3 2300 	ldrd	r2, r3, [r3]
 1001c06:	496d      	ldr	r1, [pc, #436]	; (1001dbc <ull_conn_llcp+0x1204>)
			ticks_at_expire -= HAL_TICKER_US_TO_TICKS(
 1001c08:	1a36      	subs	r6, r6, r0
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
 1001c0a:	f8d4 0110 	ldr.w	r0, [r4, #272]	; 0x110
 1001c0e:	fba1 1000 	umull	r1, r0, r1, r0
 1001c12:	0a80      	lsrs	r0, r0, #10
 1001c14:	fb0a f000 	mul.w	r0, sl, r0
 1001c18:	fba0 0107 	umull	r0, r1, r0, r7
 1001c1c:	f7fe fa4c 	bl	10000b8 <__aeabi_uldivmod>
			periodic_us -= lll->slave.window_widening_periodic_us;
 1001c20:	eba5 0a09 	sub.w	sl, r5, r9
			ticks_win_offset = HAL_TICKER_US_TO_TICKS(
 1001c24:	f020 487f 	bic.w	r8, r0, #4278190080	; 0xff000000
			periodic_us -= lll->slave.window_widening_periodic_us;
 1001c28:	f8b4 9108 	ldrh.w	r9, [r4, #264]	; 0x108
 1001c2c:	f7ff b924 	b.w	1000e78 <ull_conn_llcp+0x2c0>
		ecb_encrypt(&conn->llcp_enc.ltk[0],
 1001c30:	f104 077f 	add.w	r7, r4, #127	; 0x7f
 1001c34:	463b      	mov	r3, r7
 1001c36:	462a      	mov	r2, r5
 1001c38:	f104 01ee 	add.w	r1, r4, #238	; 0xee
 1001c3c:	f204 105d 	addw	r0, r4, #349	; 0x15d
 1001c40:	f00f febe 	bl	10119c0 <ecb_encrypt>
		memcpy(&lll->ccm_tx.key[0], &lll->ccm_rx.key[0],
 1001c44:	4639      	mov	r1, r7
 1001c46:	2210      	movs	r2, #16
 1001c48:	f104 00a0 	add.w	r0, r4, #160	; 0xa0
 1001c4c:	f014 fe34 	bl	10168b8 <memcpy>
		memcpy(&lll->ccm_tx.iv[0], &lll->ccm_rx.iv[0],
 1001c50:	2208      	movs	r2, #8
 1001c52:	f104 0198 	add.w	r1, r4, #152	; 0x98
 1001c56:	f104 00b9 	add.w	r0, r4, #185	; 0xb9
 1001c5a:	f014 fe2d 	bl	10168b8 <memcpy>
		lll->ccm_rx.direction = 0;
 1001c5e:	f894 1097 	ldrb.w	r1, [r4, #151]	; 0x97
		lll->ccm_tx.direction = 1;
 1001c62:	f894 20b8 	ldrb.w	r2, [r4, #184]	; 0xb8
		lll->enc_rx = 1;
 1001c66:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
		lll->ccm_rx.direction = 0;
 1001c6a:	f365 0100 	bfi	r1, r5, #0, #1
		lll->enc_rx = 1;
 1001c6e:	f043 0308 	orr.w	r3, r3, #8
		lll->ccm_tx.direction = 1;
 1001c72:	f042 0201 	orr.w	r2, r2, #1
		lll->ccm_rx.direction = 0;
 1001c76:	f884 1097 	strb.w	r1, [r4, #151]	; 0x97
		lll->enc_rx = 1;
 1001c7a:	f884 307e 	strb.w	r3, [r4, #126]	; 0x7e
		start_enc_rsp_send(conn, pdu_ctrl_tx);
 1001c7e:	4620      	mov	r0, r4
		lll->ccm_tx.counter = 0;
 1001c80:	e9c4 552c 	strd	r5, r5, [r4, #176]	; 0xb0
		lll->ccm_rx.counter = 0;
 1001c84:	f884 508f 	strb.w	r5, [r4, #143]	; 0x8f
 1001c88:	f884 5090 	strb.w	r5, [r4, #144]	; 0x90
 1001c8c:	f884 5091 	strb.w	r5, [r4, #145]	; 0x91
 1001c90:	f884 5092 	strb.w	r5, [r4, #146]	; 0x92
 1001c94:	f884 5093 	strb.w	r5, [r4, #147]	; 0x93
 1001c98:	f884 5094 	strb.w	r5, [r4, #148]	; 0x94
 1001c9c:	f884 5095 	strb.w	r5, [r4, #149]	; 0x95
 1001ca0:	f884 5096 	strb.w	r5, [r4, #150]	; 0x96
		lll->ccm_tx.direction = 1;
 1001ca4:	f884 20b8 	strb.w	r2, [r4, #184]	; 0xb8
		start_enc_rsp_send(conn, pdu_ctrl_tx);
 1001ca8:	1d31      	adds	r1, r6, #4
 1001caa:	f009 fb0f 	bl	100b2cc <start_enc_rsp_send>
	    conn->tx_head &&
 1001cae:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
	if (
 1001cb2:	2b00      	cmp	r3, #0
 1001cb4:	f47f aa85 	bne.w	10011c2 <ull_conn_llcp+0x60a>
 1001cb8:	e5f7      	b.n	10018aa <ull_conn_llcp+0xcf2>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1001cba:	483b      	ldr	r0, [pc, #236]	; (1001da8 <ull_conn_llcp+0x11f0>)
 1001cbc:	f003 ffb0 	bl	1005c20 <mem_acquire>
	if (tx) {
 1001cc0:	4680      	mov	r8, r0
 1001cc2:	2800      	cmp	r0, #0
 1001cc4:	f43f ab55 	beq.w	1001372 <ull_conn_llcp+0x7ba>
		pdu->len = offsetof(struct pdu_data_llctrl, feature_req) +
 1001cc8:	2209      	movs	r2, #9
		conn->llcp_feature.ack--;
 1001cca:	f894 3119 	ldrb.w	r3, [r4, #281]	; 0x119
		conn->llcp_feature.features = LL_FEAT;
 1001cce:	493c      	ldr	r1, [pc, #240]	; (1001dc0 <ull_conn_llcp+0x1208>)
		conn->llcp_feature.ack--;
 1001cd0:	3b01      	subs	r3, #1
 1001cd2:	f884 3119 	strb.w	r3, [r4, #281]	; 0x119
		conn->llcp_feature.features = LL_FEAT;
 1001cd6:	f8c4 111c 	str.w	r1, [r4, #284]	; 0x11c
		pdu->len = offsetof(struct pdu_data_llctrl, feature_req) +
 1001cda:	7142      	strb	r2, [r0, #5]
		pdu->llctrl.opcode = !conn->lll.role ?
 1001cdc:	f994 203d 	ldrsb.w	r2, [r4, #61]	; 0x3d
		pdu->ll_id = PDU_DATA_LLID_CTRL;
 1001ce0:	7903      	ldrb	r3, [r0, #4]
		pdu->llctrl.opcode = !conn->lll.role ?
 1001ce2:	2a00      	cmp	r2, #0
 1001ce4:	bfac      	ite	ge
 1001ce6:	2208      	movge	r2, #8
 1001ce8:	220e      	movlt	r2, #14
 1001cea:	71c2      	strb	r2, [r0, #7]
		(void)memset(&pdu->llctrl.feature_req.features[0],
 1001cec:	2208      	movs	r2, #8
		pdu->ll_id = PDU_DATA_LLID_CTRL;
 1001cee:	f043 0303 	orr.w	r3, r3, #3
 1001cf2:	7103      	strb	r3, [r0, #4]
		(void)memset(&pdu->llctrl.feature_req.features[0],
 1001cf4:	4639      	mov	r1, r7
 1001cf6:	4410      	add	r0, r2
 1001cf8:	f014 fe09 	bl	101690e <memset>
		sys_put_le24(conn->llcp_feature.features,
 1001cfc:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
	dst[1] = val >> 8;
 1001d00:	f3c3 2107 	ubfx	r1, r3, #8, #8
	dst[2] = val >> 16;
 1001d04:	0c1a      	lsrs	r2, r3, #16
	dst[0] = val;
 1001d06:	f888 3008 	strb.w	r3, [r8, #8]
	dst[1] = val >> 8;
 1001d0a:	f888 1009 	strb.w	r1, [r8, #9]
	dst[2] = val >> 16;
 1001d0e:	f888 200a 	strb.w	r2, [r8, #10]
	    conn->tx_head &&
 1001d12:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
	if (
 1001d16:	2b00      	cmp	r3, #0
 1001d18:	f000 815e 	beq.w	1001fd8 <ull_conn_llcp+0x1420>
	    !conn->llcp_enc.pause_tx &&
 1001d1c:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
	    conn->tx_head &&
 1001d20:	0797      	lsls	r7, r2, #30
 1001d22:	f100 8159 	bmi.w	1001fd8 <ull_conn_llcp+0x1420>
	    !conn->llcp_phy.pause_tx &&
 1001d26:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
 1001d2a:	07d0      	lsls	r0, r2, #31
 1001d2c:	f100 8154 	bmi.w	1001fd8 <ull_conn_llcp+0x1420>
		if (conn->tx_head == conn->tx_data) {
 1001d30:	f8d4 21bc 	ldr.w	r2, [r4, #444]	; 0x1bc
 1001d34:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 1001d36:	bf04      	itt	eq
 1001d38:	681a      	ldreq	r2, [r3, #0]
 1001d3a:	f8c4 21bc 	streq.w	r2, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 1001d3e:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 1001d42:	2a00      	cmp	r2, #0
 1001d44:	f000 830b 	beq.w	100235e <ull_conn_llcp+0x17a6>
	tx->next = conn->tx_ctrl_last->next;
 1001d48:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 1001d4c:	681a      	ldr	r2, [r3, #0]
 1001d4e:	f8c8 2000 	str.w	r2, [r8]
	conn->tx_ctrl_last->next = tx;
 1001d52:	f8c3 8000 	str.w	r8, [r3]
	conn->tx_ctrl_last = tx;
 1001d56:	f8c4 81b8 	str.w	r8, [r4, #440]	; 0x1b8
 1001d5a:	f8d8 3000 	ldr.w	r3, [r8]
	if (!tx->next) {
 1001d5e:	2b00      	cmp	r3, #0
 1001d60:	f000 8298 	beq.w	1002294 <ull_conn_llcp+0x16dc>
		conn->procedure_expire = conn->procedure_reload;
 1001d64:	f8b4 20ca 	ldrh.w	r2, [r4, #202]	; 0xca
 1001d68:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 1001d6c:	f8a4 20cc 	strh.w	r2, [r4, #204]	; 0xcc
	break;
 1001d70:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
 1001d74:	f7fe bf32 	b.w	1000bdc <ull_conn_llcp+0x24>
		conn->tx_data_last = tx;
 1001d78:	f8c4 01c0 	str.w	r0, [r4, #448]	; 0x1c0
 1001d7c:	f7ff baa9 	b.w	10012d2 <ull_conn_llcp+0x71a>
			lll->phy_tx = conn->llcp.phy_upd_ind.tx;
 1001d80:	f894 2064 	ldrb.w	r2, [r4, #100]	; 0x64
 1001d84:	f3c6 0182 	ubfx	r1, r6, #2, #3
 1001d88:	f361 0202 	bfi	r2, r1, #0, #3
 1001d8c:	f884 2064 	strb.w	r2, [r4, #100]	; 0x64
			eff_tx_time = calc_eff_time(lll->max_tx_octets,
 1001d90:	f894 005c 	ldrb.w	r0, [r4, #92]	; 0x5c
 1001d94:	464a      	mov	r2, r9
 1001d96:	f009 f8ad 	bl	100aef4 <calc_eff_time>
 1001d9a:	4605      	mov	r5, r0
 1001d9c:	f7ff b93d 	b.w	100101a <ull_conn_llcp+0x462>
 1001da0:	1afd498d 	.word	0x1afd498d
 1001da4:	00000007 	.word	0x00000007
 1001da8:	210038cc 	.word	0x210038cc
 1001dac:	210003bc 	.word	0x210003bc
 1001db0:	010187e4 	.word	0x010187e4
 1001db4:	3b9aca00 	.word	0x3b9aca00
 1001db8:	431bde83 	.word	0x431bde83
 1001dbc:	d1b71759 	.word	0xd1b71759
 1001dc0:	000149ff 	.word	0x000149ff
		} else if (conn->llcp_length.ack != conn->llcp_length.req) {
 1001dc4:	f894 7198 	ldrb.w	r7, [r4, #408]	; 0x198
 1001dc8:	f894 1199 	ldrb.w	r1, [r4, #409]	; 0x199
 1001dcc:	42b9      	cmp	r1, r7
 1001dce:	f000 8138 	beq.w	1002042 <ull_conn_llcp+0x148a>
	switch (conn->llcp_length.state) {
 1001dd2:	f894 119a 	ldrb.w	r1, [r4, #410]	; 0x19a
 1001dd6:	f001 0007 	and.w	r0, r1, #7
 1001dda:	2806      	cmp	r0, #6
 1001ddc:	f200 83e1 	bhi.w	10025a2 <ull_conn_llcp+0x19ea>
 1001de0:	f20f 0c04 	addw	ip, pc, #4
 1001de4:	f85c f020 	ldr.w	pc, [ip, r0, lsl #2]
 1001de8:	01001e9d 	.word	0x01001e9d
 1001dec:	01000bdd 	.word	0x01000bdd
 1001df0:	01000bdd 	.word	0x01000bdd
 1001df4:	01000bdd 	.word	0x01000bdd
 1001df8:	01001e05 	.word	0x01001e05
 1001dfc:	01001e05 	.word	0x01001e05
 1001e00:	01000bdd 	.word	0x01000bdd
		lll->max_rx_octets = conn->llcp_length.rx_octets;
 1001e04:	f8b4 019c 	ldrh.w	r0, [r4, #412]	; 0x19c
		lll->max_rx_time = conn->llcp_length.rx_time;
 1001e08:	f8b4 21a0 	ldrh.w	r2, [r4, #416]	; 0x1a0
		if (conn->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {
 1001e0c:	f001 0307 	and.w	r3, r1, #7
 1001e10:	2b04      	cmp	r3, #4
		tx_octets = conn->llcp_length.tx_octets;
 1001e12:	f8b4 919e 	ldrh.w	r9, [r4, #414]	; 0x19e
		u16_t tx_time = conn->llcp_length.tx_time;
 1001e16:	f8b4 81a2 	ldrh.w	r8, [r4, #418]	; 0x1a2
		lll->max_rx_octets = conn->llcp_length.rx_octets;
 1001e1a:	f8a4 005e 	strh.w	r0, [r4, #94]	; 0x5e
		lll->max_rx_time = conn->llcp_length.rx_time;
 1001e1e:	f8a4 2062 	strh.w	r2, [r4, #98]	; 0x62
		if (conn->llcp_length.state == LLCP_LENGTH_STATE_RESIZE) {
 1001e22:	f000 82a6 	beq.w	1002372 <ull_conn_llcp+0x17ba>
			conn->llcp_length.state =
 1001e26:	2306      	movs	r3, #6
 1001e28:	f363 0102 	bfi	r1, r3, #0, #3
 1001e2c:	f884 119a 	strb.w	r1, [r4, #410]	; 0x19a
		rx = conn->llcp_rx;
 1001e30:	f8d4 7100 	ldr.w	r7, [r4, #256]	; 0x100
		LL_ASSERT(rx && rx->hdr.link);
 1001e34:	2f00      	cmp	r7, #0
 1001e36:	f000 8287 	beq.w	1002348 <ull_conn_llcp+0x1790>
 1001e3a:	6838      	ldr	r0, [r7, #0]
 1001e3c:	2800      	cmp	r0, #0
 1001e3e:	f000 8283 	beq.w	1002348 <ull_conn_llcp+0x1790>
		pdu_ctrl_rx->len =
 1001e42:	f04f 0e09 	mov.w	lr, #9
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 1001e46:	f04f 0a02 	mov.w	sl, #2
		pdu_ctrl_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 1001e4a:	2115      	movs	r1, #21
		pdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;
 1001e4c:	f897 3020 	ldrb.w	r3, [r7, #32]
		conn->llcp_rx = rx->hdr.link->mem;
 1001e50:	6842      	ldr	r2, [r0, #4]
		pdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;
 1001e52:	f043 0303 	orr.w	r3, r3, #3
		rx->hdr.handle = conn->lll.handle;
 1001e56:	f8b4 c02c 	ldrh.w	ip, [r4, #44]	; 0x2c
		conn->llcp_rx = rx->hdr.link->mem;
 1001e5a:	f8c4 2100 	str.w	r2, [r4, #256]	; 0x100
		pdu_ctrl_rx->len =
 1001e5e:	f887 e021 	strb.w	lr, [r7, #33]	; 0x21
		pdu_ctrl_rx->ll_id = PDU_DATA_LLID_CTRL;
 1001e62:	f887 3020 	strb.w	r3, [r7, #32]
		rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 1001e66:	f887 a004 	strb.w	sl, [r7, #4]
		lr->max_rx_octets = sys_cpu_to_le16(lll->max_rx_octets);
 1001e6a:	f8b4 205e 	ldrh.w	r2, [r4, #94]	; 0x5e
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
 1001e6e:	f8b4 3062 	ldrh.w	r3, [r4, #98]	; 0x62
		rx->hdr.handle = conn->lll.handle;
 1001e72:	f8a7 c006 	strh.w	ip, [r7, #6]
		lr->max_rx_octets = sys_cpu_to_le16(lll->max_rx_octets);
 1001e76:	84ba      	strh	r2, [r7, #36]	; 0x24
		lr->max_rx_time = sys_cpu_to_le16(lll->max_rx_time);
 1001e78:	84fb      	strh	r3, [r7, #38]	; 0x26
		pdu_ctrl_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 1001e7a:	f887 1023 	strb.w	r1, [r7, #35]	; 0x23
		lr->max_tx_octets = sys_cpu_to_le16(tx_octets);
 1001e7e:	f8a7 9028 	strh.w	r9, [r7, #40]	; 0x28
		ll_rx_put(rx->hdr.link, rx);
 1001e82:	4639      	mov	r1, r7
		lr->max_tx_time = sys_cpu_to_le16(tx_time);
 1001e84:	f8a7 802a 	strh.w	r8, [r7, #42]	; 0x2a
		ll_rx_put(rx->hdr.link, rx);
 1001e88:	f008 f8c0 	bl	100a00c <ll_rx_put>
		ll_rx_sched();
 1001e8c:	f008 f8c8 	bl	100a020 <ll_rx_sched>
	break;
 1001e90:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 1001e94:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
 1001e98:	f7fe bea0 	b.w	1000bdc <ull_conn_llcp+0x24>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1001e9c:	48db      	ldr	r0, [pc, #876]	; (100220c <ull_conn_llcp+0x1654>)
 1001e9e:	f003 febf 	bl	1005c20 <mem_acquire>
		if (!tx) {
 1001ea2:	4603      	mov	r3, r0
 1001ea4:	2800      	cmp	r0, #0
 1001ea6:	f43f aa64 	beq.w	1001372 <ull_conn_llcp+0x7ba>
		conn->llcp_length.state = LLCP_LENGTH_STATE_REQ_ACK_WAIT;
 1001eaa:	f04f 0801 	mov.w	r8, #1
		pdu_ctrl_tx->len =
 1001eae:	2109      	movs	r1, #9
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
 1001eb0:	271b      	movs	r7, #27
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_REQ;
 1001eb2:	f04f 0e14 	mov.w	lr, #20
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
 1001eb6:	f04f 0c00 	mov.w	ip, #0
		conn->llcp_length.state = LLCP_LENGTH_STATE_REQ_ACK_WAIT;
 1001eba:	f894 219a 	ldrb.w	r2, [r4, #410]	; 0x19a
		conn->default_tx_octets = conn->llcp_length.tx_octets;
 1001ebe:	f8b4 019e 	ldrh.w	r0, [r4, #414]	; 0x19e
		conn->llcp_length.state = LLCP_LENGTH_STATE_REQ_ACK_WAIT;
 1001ec2:	f368 0202 	bfi	r2, r8, #0, #3
 1001ec6:	f884 219a 	strb.w	r2, [r4, #410]	; 0x19a
		conn->default_tx_time = conn->llcp_length.tx_time;
 1001eca:	f8b4 21a2 	ldrh.w	r2, [r4, #418]	; 0x1a2
		conn->default_tx_octets = conn->llcp_length.tx_octets;
 1001ece:	f8a4 00d6 	strh.w	r0, [r4, #214]	; 0xd6
		conn->default_tx_time = conn->llcp_length.tx_time;
 1001ed2:	f8a4 20d8 	strh.w	r2, [r4, #216]	; 0xd8
		pdu_ctrl_tx->len =
 1001ed6:	7159      	strb	r1, [r3, #5]
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001ed8:	7919      	ldrb	r1, [r3, #4]
		lr->max_tx_octets = sys_cpu_to_le16(conn->default_tx_octets);
 1001eda:	8198      	strh	r0, [r3, #12]
	if (!conn->common.fex_valid ||
 1001edc:	f894 00dc 	ldrb.w	r0, [r4, #220]	; 0xdc
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 1001ee0:	f041 0103 	orr.w	r1, r1, #3
 1001ee4:	7119      	strb	r1, [r3, #4]
	feature_coded_phy = (conn->llcp_feature.features &
 1001ee6:	f8d4 111c 	ldr.w	r1, [r4, #284]	; 0x11c
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
 1001eea:	721f      	strb	r7, [r3, #8]
	if (!conn->common.fex_valid ||
 1001eec:	07c7      	lsls	r7, r0, #31
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_REQ;
 1001eee:	f883 e007 	strb.w	lr, [r3, #7]
		lr->max_rx_octets = sys_cpu_to_le16(LL_LENGTH_OCTETS_RX_MAX);
 1001ef2:	f883 c009 	strb.w	ip, [r3, #9]
	if (!conn->common.fex_valid ||
 1001ef6:	f140 822e 	bpl.w	1002356 <ull_conn_llcp+0x179e>
 1001efa:	0508      	lsls	r0, r1, #20
 1001efc:	f140 826e 	bpl.w	10023dc <ull_conn_llcp+0x1824>
		tx_time = MIN(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_CODED),
 1001f00:	f5b2 6f29 	cmp.w	r2, #2704	; 0xa90
 1001f04:	bf28      	it	cs
 1001f06:	f44f 6229 	movcs.w	r2, #2704	; 0xa90
		tx_time = MAX(PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M), tx_time);
 1001f0a:	f5b2 7fa4 	cmp.w	r2, #328	; 0x148
		rx_time = MAX(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_CODED),
 1001f0e:	f44f 6129 	mov.w	r1, #2704	; 0xa90
		tx_time = MAX(PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M), tx_time);
 1001f12:	bf38      	it	cc
 1001f14:	f44f 72a4 	movcc.w	r2, #328	; 0x148
		lr->max_rx_time = sys_cpu_to_le16(rx_time);
 1001f18:	f5b1 7fa4 	cmp.w	r1, #328	; 0x148
 1001f1c:	bf38      	it	cc
 1001f1e:	f44f 71a4 	movcc.w	r1, #328	; 0x148
 1001f22:	4608      	mov	r0, r1
	    conn->tx_head &&
 1001f24:	f8d4 11b0 	ldr.w	r1, [r4, #432]	; 0x1b0
		lr->max_rx_time = sys_cpu_to_le16(rx_time);
 1001f28:	8158      	strh	r0, [r3, #10]
		lr->max_tx_time = sys_cpu_to_le16(tx_time);
 1001f2a:	81da      	strh	r2, [r3, #14]
	if (
 1001f2c:	2900      	cmp	r1, #0
 1001f2e:	f000 81f8 	beq.w	1002322 <ull_conn_llcp+0x176a>
	    !conn->llcp_enc.pause_tx &&
 1001f32:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
	    conn->tx_head &&
 1001f36:	0792      	lsls	r2, r2, #30
 1001f38:	f100 81f3 	bmi.w	1002322 <ull_conn_llcp+0x176a>
	    !conn->llcp_phy.pause_tx &&
 1001f3c:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
 1001f40:	07d7      	lsls	r7, r2, #31
 1001f42:	f100 81ee 	bmi.w	1002322 <ull_conn_llcp+0x176a>
		if (conn->tx_head == conn->tx_data) {
 1001f46:	f8d4 21bc 	ldr.w	r2, [r4, #444]	; 0x1bc
 1001f4a:	4291      	cmp	r1, r2
			conn->tx_data = conn->tx_data->next;
 1001f4c:	bf04      	itt	eq
 1001f4e:	680a      	ldreq	r2, [r1, #0]
 1001f50:	f8c4 21bc 	streq.w	r2, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 1001f54:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 1001f58:	2a00      	cmp	r2, #0
 1001f5a:	f000 8315 	beq.w	1002588 <ull_conn_llcp+0x19d0>
	tx->next = conn->tx_ctrl_last->next;
 1001f5e:	f8d4 21b8 	ldr.w	r2, [r4, #440]	; 0x1b8
 1001f62:	6811      	ldr	r1, [r2, #0]
 1001f64:	6019      	str	r1, [r3, #0]
	conn->tx_ctrl_last->next = tx;
 1001f66:	6013      	str	r3, [r2, #0]
	conn->tx_ctrl_last = tx;
 1001f68:	f8c4 31b8 	str.w	r3, [r4, #440]	; 0x1b8
	if (!tx->next) {
 1001f6c:	681a      	ldr	r2, [r3, #0]
 1001f6e:	2a00      	cmp	r2, #0
 1001f70:	f47f aef8 	bne.w	1001d64 <ull_conn_llcp+0x11ac>
		conn->tx_data_last = tx;
 1001f74:	f8c4 31c0 	str.w	r3, [r4, #448]	; 0x1c0
		conn->procedure_expire = conn->procedure_reload;
 1001f78:	e6f4      	b.n	1001d64 <ull_conn_llcp+0x11ac>
		conn->tx_data_last = tx;
 1001f7a:	f8c4 61c0 	str.w	r6, [r4, #448]	; 0x1c0
 1001f7e:	f7ff b941 	b.w	1001204 <ull_conn_llcp+0x64c>
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_IND;
 1001f82:	230d      	movs	r3, #13
		p->error_code =	conn->llcp.encryption.error_code;
 1001f84:	2702      	movs	r7, #2
 1001f86:	7235      	strb	r5, [r6, #8]
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_IND;
 1001f88:	71f3      	strb	r3, [r6, #7]
		pdu->len = sizeof(struct pdu_data_llctrl_reject_ind);
 1001f8a:	f7ff b911 	b.w	10011b0 <ull_conn_llcp+0x5f8>
		LL_ASSERT(rx && rx->hdr.link);
 1001f8e:	48a0      	ldr	r0, [pc, #640]	; (1002210 <ull_conn_llcp+0x1658>)
 1001f90:	f640 6138 	movw	r1, #3640	; 0xe38
 1001f94:	f001 faf8 	bl	1003588 <bt_ctlr_assert_handle>
 1001f98:	6830      	ldr	r0, [r6, #0]
 1001f9a:	f894 b0ec 	ldrb.w	fp, [r4, #236]	; 0xec
 1001f9e:	f7ff b85f 	b.w	1001060 <ull_conn_llcp+0x4a8>
		LL_ASSERT(rx && rx->hdr.link);
 1001fa2:	489b      	ldr	r0, [pc, #620]	; (1002210 <ull_conn_llcp+0x1658>)
 1001fa4:	f640 6164 	movw	r1, #3684	; 0xe64
 1001fa8:	f001 faee 	bl	1003588 <bt_ctlr_assert_handle>
 1001fac:	6830      	ldr	r0, [r6, #0]
 1001fae:	f7ff b884 	b.w	10010ba <ull_conn_llcp+0x502>
		if (!conn->tx_ctrl) {
 1001fb2:	f8d4 31b4 	ldr.w	r3, [r4, #436]	; 0x1b4
 1001fb6:	2b00      	cmp	r3, #0
 1001fb8:	f47f ac14 	bne.w	10017e4 <ull_conn_llcp+0xc2c>
			tx->next = conn->tx_head;
 1001fbc:	6002      	str	r2, [r0, #0]
				conn->tx_ctrl = tx;
 1001fbe:	e9c4 006c 	strd	r0, r0, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 1001fc2:	f8c4 01b8 	str.w	r0, [r4, #440]	; 0x1b8
 1001fc6:	e415      	b.n	10017f4 <ull_conn_llcp+0xc3c>
		switch (conn->llcp_cu.state) {
 1001fc8:	4992      	ldr	r1, [pc, #584]	; (1002214 <ull_conn_llcp+0x165c>)
 1001fca:	f7ff baad 	b.w	1001528 <ull_conn_llcp+0x970>
 1001fce:	f44f 73a4 	mov.w	r3, #328	; 0x148
 1001fd2:	4619      	mov	r1, r3
 1001fd4:	f7ff bbe9 	b.w	10017aa <ull_conn_llcp+0xbf2>
		if (!conn->tx_ctrl) {
 1001fd8:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 1001fdc:	2a00      	cmp	r2, #0
 1001fde:	f47f aeb3 	bne.w	1001d48 <ull_conn_llcp+0x1190>
			tx->next = conn->tx_head;
 1001fe2:	f8c8 3000 	str.w	r3, [r8]
				conn->tx_ctrl = tx;
 1001fe6:	e9c4 886c 	strd	r8, r8, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 1001fea:	f8c4 81b8 	str.w	r8, [r4, #440]	; 0x1b8
 1001fee:	e6b6      	b.n	1001d5e <ull_conn_llcp+0x11a6>
 1001ff0:	f894 2065 	ldrb.w	r2, [r4, #101]	; 0x65
 1001ff4:	f003 0307 	and.w	r3, r3, #7
 1001ff8:	f002 0207 	and.w	r2, r2, #7
 1001ffc:	f7ff b842 	b.w	1001084 <ull_conn_llcp+0x4cc>
		LL_ASSERT(rx && rx->hdr.link);
 1002000:	f640 5108 	movw	r1, #3336	; 0xd08
 1002004:	4882      	ldr	r0, [pc, #520]	; (1002210 <ull_conn_llcp+0x1658>)
 1002006:	f001 fabf 	bl	1003588 <bt_ctlr_assert_handle>
 100200a:	6838      	ldr	r0, [r7, #0]
 100200c:	f8b4 105e 	ldrh.w	r1, [r4, #94]	; 0x5e
 1002010:	f8b4 2062 	ldrh.w	r2, [r4, #98]	; 0x62
 1002014:	f7ff bb5c 	b.w	10016d0 <ull_conn_llcp+0xb18>
			fp_mfy_select_or_use = ull_sched_mfy_win_offset_use;
 1002018:	497f      	ldr	r1, [pc, #508]	; (1002218 <ull_conn_llcp+0x1660>)
 100201a:	f7ff ba85 	b.w	1001528 <ull_conn_llcp+0x970>
		LL_ASSERT(!retval);
 100201e:	f640 0149 	movw	r1, #2121	; 0x849
 1002022:	487b      	ldr	r0, [pc, #492]	; (1002210 <ull_conn_llcp+0x1658>)
 1002024:	f001 fab0 	bl	1003588 <bt_ctlr_assert_handle>
 1002028:	f7ff bacf 	b.w	10015ca <ull_conn_llcp+0xa12>
			if (!conn->llcp_length.cache.tx_octets) {
 100202c:	f8b4 01a4 	ldrh.w	r0, [r4, #420]	; 0x1a4
 1002030:	2800      	cmp	r0, #0
 1002032:	f040 8132 	bne.w	100229a <ull_conn_llcp+0x16e2>
				conn->llcp_length.ack = conn->llcp_length.req;
 1002036:	f884 3199 	strb.w	r3, [r4, #409]	; 0x199
				conn->procedure_expire = 0U;
 100203a:	f8a4 00cc 	strh.w	r0, [r4, #204]	; 0xcc
 100203e:	f7ff bb3e 	b.w	10016be <ull_conn_llcp+0xb06>
		} else if (conn->llcp_phy.ack != conn->llcp_phy.req) {
 1002042:	f894 31a8 	ldrb.w	r3, [r4, #424]	; 0x1a8
 1002046:	f894 11a9 	ldrb.w	r1, [r4, #425]	; 0x1a9
 100204a:	4299      	cmp	r1, r3
 100204c:	f43e adcb 	beq.w	1000be6 <ull_conn_llcp+0x2e>
	switch (conn->llcp_phy.state) {
 1002050:	f894 11aa 	ldrb.w	r1, [r4, #426]	; 0x1aa
 1002054:	f001 0003 	and.w	r0, r1, #3
 1002058:	2803      	cmp	r0, #3
 100205a:	f000 81c6 	beq.w	10023ea <ull_conn_llcp+0x1832>
 100205e:	2800      	cmp	r0, #0
 1002060:	f47e adc1 	bne.w	1000be6 <ull_conn_llcp+0x2e>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1002064:	4869      	ldr	r0, [pc, #420]	; (100220c <ull_conn_llcp+0x1654>)
 1002066:	f003 fddb 	bl	1005c20 <mem_acquire>
		if (!tx) {
 100206a:	4601      	mov	r1, r0
 100206c:	2800      	cmp	r0, #0
 100206e:	f43f a980 	beq.w	1001372 <ull_conn_llcp+0x7ba>
		conn->llcp_phy.state = LLCP_PHY_STATE_ACK_WAIT;
 1002072:	2001      	movs	r0, #1
		pdu_ctrl_tx->len =
 1002074:	f04f 0c03 	mov.w	ip, #3
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_REQ;
 1002078:	2716      	movs	r7, #22
		conn->llcp_phy.state = LLCP_PHY_STATE_ACK_WAIT;
 100207a:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
		conn->phy_pref_tx = conn->llcp_phy.tx;
 100207e:	f894 21ac 	ldrb.w	r2, [r4, #428]	; 0x1ac
		conn->llcp_phy.state = LLCP_PHY_STATE_ACK_WAIT;
 1002082:	f360 0301 	bfi	r3, r0, #0, #2
		conn->phy_pref_tx = conn->llcp_phy.tx;
 1002086:	f3c3 0082 	ubfx	r0, r3, #2, #3
 100208a:	f360 0202 	bfi	r2, r0, #0, #3
		conn->phy_pref_rx = conn->llcp_phy.rx;
 100208e:	f3c3 1042 	ubfx	r0, r3, #5, #3
 1002092:	f360 1206 	bfi	r2, r0, #4, #3
		conn->phy_pref_flags = conn->llcp_phy.flags;
 1002096:	f894 01ab 	ldrb.w	r0, [r4, #427]	; 0x1ab
		conn->llcp_phy.state = LLCP_PHY_STATE_ACK_WAIT;
 100209a:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
		conn->phy_pref_flags = conn->llcp_phy.flags;
 100209e:	f3c0 0040 	ubfx	r0, r0, #1, #1
 10020a2:	f360 02c3 	bfi	r2, r0, #3, #1
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 10020a6:	7908      	ldrb	r0, [r1, #4]
		conn->phy_pref_tx = conn->llcp_phy.tx;
 10020a8:	f3c3 0e82 	ubfx	lr, r3, #2, #3
		conn->phy_pref_flags = conn->llcp_phy.flags;
 10020ac:	f884 21ac 	strb.w	r2, [r4, #428]	; 0x1ac
		conn->phy_pref_rx = conn->llcp_phy.rx;
 10020b0:	f3c3 1342 	ubfx	r3, r3, #5, #3
		pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 10020b4:	ea40 020c 	orr.w	r2, r0, ip
 10020b8:	710a      	strb	r2, [r1, #4]
	ctrl_tx_pause_enqueue(conn, tx, false);
 10020ba:	4620      	mov	r0, r4
 10020bc:	2200      	movs	r2, #0
		pr->tx_phys = conn->llcp_phy.tx;
 10020be:	f881 e008 	strb.w	lr, [r1, #8]
		pr->rx_phys = conn->llcp_phy.rx;
 10020c2:	724b      	strb	r3, [r1, #9]
		pdu_ctrl_tx->len =
 10020c4:	f881 c005 	strb.w	ip, [r1, #5]
		pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_REQ;
 10020c8:	71cf      	strb	r7, [r1, #7]
	ctrl_tx_pause_enqueue(conn, tx, false);
 10020ca:	f008 ff59 	bl	100af80 <ctrl_tx_pause_enqueue>
 10020ce:	e649      	b.n	1001d64 <ull_conn_llcp+0x11ac>
		if (!conn->llcp.phy_upd_ind.cmd && (lll->phy_tx == old_tx) &&
 10020d0:	4592      	cmp	sl, r2
 10020d2:	f47e afd7 	bne.w	1001084 <ull_conn_llcp+0x4cc>
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 10020d6:	2303      	movs	r3, #3
			ll_rx_put(rx->hdr.link, rx);
 10020d8:	4631      	mov	r1, r6
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 10020da:	7133      	strb	r3, [r6, #4]
			ll_rx_put(rx->hdr.link, rx);
 10020dc:	f007 ff96 	bl	100a00c <ll_rx_put>
				rx = conn->llcp_rx;
 10020e0:	f8d4 5100 	ldr.w	r5, [r4, #256]	; 0x100
				LL_ASSERT(rx && rx->hdr.link);
 10020e4:	2d00      	cmp	r5, #0
 10020e6:	f000 8172 	beq.w	10023ce <ull_conn_llcp+0x1816>
 10020ea:	6828      	ldr	r0, [r5, #0]
 10020ec:	2800      	cmp	r0, #0
 10020ee:	f000 816e 	beq.w	10023ce <ull_conn_llcp+0x1816>
				rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 10020f2:	2303      	movs	r3, #3
				conn->llcp_rx = rx->hdr.link->mem;
 10020f4:	6842      	ldr	r2, [r0, #4]
				ll_rx_put(rx->hdr.link, rx);
 10020f6:	4629      	mov	r1, r5
				conn->llcp_rx = rx->hdr.link->mem;
 10020f8:	f8c4 2100 	str.w	r2, [r4, #256]	; 0x100
				rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 10020fc:	712b      	strb	r3, [r5, #4]
				ll_rx_put(rx->hdr.link, rx);
 10020fe:	f007 ff85 	bl	100a00c <ll_rx_put>
			ll_rx_sched();
 1002102:	f007 ff8d 	bl	100a020 <ll_rx_sched>
			return;
 1002106:	f7fe bd6e 	b.w	1000be6 <ull_conn_llcp+0x2e>
			conn->llcp.phy_upd_ind.instant = event_counter +
 100210a:	8e23      	ldrh	r3, [r4, #48]	; 0x30
 100210c:	441d      	add	r5, r3
							 lll->latency +
 100210e:	1dab      	adds	r3, r5, #6
			conn->llcp.phy_upd_ind.instant = event_counter +
 1002110:	f8a4 30ee 	strh.w	r3, [r4, #238]	; 0xee
			(void)ll_pdu_rx_alloc();
 1002114:	f007 ffa8 	bl	100a068 <ll_pdu_rx_alloc>
			rx->hdr.link->mem = conn->llcp_rx;
 1002118:	f8d8 3000 	ldr.w	r3, [r8]
 100211c:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
 1002120:	605a      	str	r2, [r3, #4]
			conn->llcp_rx = rx;
 1002122:	f8c4 8100 	str.w	r8, [r4, #256]	; 0x100
			rx = ll_pdu_rx_alloc();
 1002126:	f007 ff9f 	bl	100a068 <ll_pdu_rx_alloc>
			rx->hdr.link->mem = conn->llcp_rx;
 100212a:	f8d4 2100 	ldr.w	r2, [r4, #256]	; 0x100
 100212e:	6803      	ldr	r3, [r0, #0]
 1002130:	605a      	str	r2, [r3, #4]
			conn->llcp_rx = rx;
 1002132:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
 1002136:	f8c4 0100 	str.w	r0, [r4, #256]	; 0x100
 100213a:	f3c3 0782 	ubfx	r7, r3, #2, #3
 100213e:	f8b4 00ee 	ldrh.w	r0, [r4, #238]	; 0xee
 1002142:	095b      	lsrs	r3, r3, #5
 1002144:	f7ff b994 	b.w	1001470 <ull_conn_llcp+0x8b8>
		LL_ASSERT(0);
 1002148:	f640 3127 	movw	r1, #2855	; 0xb27
 100214c:	4830      	ldr	r0, [pc, #192]	; (1002210 <ull_conn_llcp+0x1658>)
 100214e:	f001 fa1b 	bl	1003588 <bt_ctlr_assert_handle>
 1002152:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 1002156:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
 100215a:	f7fe bd3f 	b.w	1000bdc <ull_conn_llcp+0x24>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100215e:	482b      	ldr	r0, [pc, #172]	; (100220c <ull_conn_llcp+0x1654>)
 1002160:	f003 fd5e 	bl	1005c20 <mem_acquire>
		if (tx) {
 1002164:	2800      	cmp	r0, #0
 1002166:	f43f a904 	beq.w	1001372 <ull_conn_llcp+0x7ba>
			pdu->llctrl.version_ind.sub_version_number = svn;
 100216a:	f04f 31ff 	mov.w	r1, #4294967295
			pdu->len =
 100216e:	f04f 0906 	mov.w	r9, #6
			pdu->llctrl.opcode =
 1002172:	f04f 080c 	mov.w	r8, #12
			pdu->llctrl.version_ind.version_number =
 1002176:	f04f 0e0b 	mov.w	lr, #11
			pdu->llctrl.version_ind.company_id = cid;
 100217a:	f06f 0c0e 	mvn.w	ip, #14
 100217e:	2705      	movs	r7, #5
			conn->llcp_version.ack--;
 1002180:	f894 3121 	ldrb.w	r3, [r4, #289]	; 0x121
			conn->llcp_version.tx = 1U;
 1002184:	f894 2122 	ldrb.w	r2, [r4, #290]	; 0x122
			conn->llcp_version.ack--;
 1002188:	440b      	add	r3, r1
 100218a:	f884 3121 	strb.w	r3, [r4, #289]	; 0x121
			pdu->ll_id = PDU_DATA_LLID_CTRL;
 100218e:	7903      	ldrb	r3, [r0, #4]
			conn->llcp_version.tx = 1U;
 1002190:	f042 0201 	orr.w	r2, r2, #1
 1002194:	f884 2122 	strb.w	r2, [r4, #290]	; 0x122
			pdu->ll_id = PDU_DATA_LLID_CTRL;
 1002198:	f043 0303 	orr.w	r3, r3, #3
			pdu->len =
 100219c:	f880 9005 	strb.w	r9, [r0, #5]
			pdu->ll_id = PDU_DATA_LLID_CTRL;
 10021a0:	7103      	strb	r3, [r0, #4]
	    conn->tx_head &&
 10021a2:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
			pdu->llctrl.opcode =
 10021a6:	f880 8007 	strb.w	r8, [r0, #7]
			pdu->llctrl.version_ind.version_number =
 10021aa:	f880 e008 	strb.w	lr, [r0, #8]
			pdu->llctrl.version_ind.company_id = cid;
 10021ae:	f880 c009 	strb.w	ip, [r0, #9]
 10021b2:	7287      	strb	r7, [r0, #10]
			pdu->llctrl.version_ind.sub_version_number = svn;
 10021b4:	72c1      	strb	r1, [r0, #11]
 10021b6:	7301      	strb	r1, [r0, #12]
	if (
 10021b8:	2b00      	cmp	r3, #0
 10021ba:	f000 8087 	beq.w	10022cc <ull_conn_llcp+0x1714>
	    !conn->llcp_enc.pause_tx &&
 10021be:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
	    conn->tx_head &&
 10021c2:	0797      	lsls	r7, r2, #30
 10021c4:	f100 8082 	bmi.w	10022cc <ull_conn_llcp+0x1714>
	    !conn->llcp_phy.pause_tx &&
 10021c8:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
 10021cc:	07d1      	lsls	r1, r2, #31
 10021ce:	d47d      	bmi.n	10022cc <ull_conn_llcp+0x1714>
		if (conn->tx_head == conn->tx_data) {
 10021d0:	f8d4 21bc 	ldr.w	r2, [r4, #444]	; 0x1bc
 10021d4:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 10021d6:	bf04      	itt	eq
 10021d8:	681a      	ldreq	r2, [r3, #0]
 10021da:	f8c4 21bc 	streq.w	r2, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 10021de:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 10021e2:	2a00      	cmp	r2, #0
 10021e4:	f000 819e 	beq.w	1002524 <ull_conn_llcp+0x196c>
	tx->next = conn->tx_ctrl_last->next;
 10021e8:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 10021ec:	681a      	ldr	r2, [r3, #0]
 10021ee:	6002      	str	r2, [r0, #0]
	conn->tx_ctrl_last->next = tx;
 10021f0:	6018      	str	r0, [r3, #0]
	conn->tx_ctrl_last = tx;
 10021f2:	f8c4 01b8 	str.w	r0, [r4, #440]	; 0x1b8
	if (!tx->next) {
 10021f6:	6803      	ldr	r3, [r0, #0]
 10021f8:	2b00      	cmp	r3, #0
 10021fa:	f47f adb3 	bne.w	1001d64 <ull_conn_llcp+0x11ac>
		conn->tx_data_last = tx;
 10021fe:	f8c4 01c0 	str.w	r0, [r4, #448]	; 0x1c0
			conn->procedure_expire = conn->procedure_reload;
 1002202:	e5af      	b.n	1001d64 <ull_conn_llcp+0x11ac>
		conn->tx_data_last = tx;
 1002204:	f8c4 01c0 	str.w	r0, [r4, #448]	; 0x1c0
 1002208:	f7ff baf7 	b.w	10017fa <ull_conn_llcp+0xc42>
 100220c:	210038cc 	.word	0x210038cc
 1002210:	010187e4 	.word	0x010187e4
 1002214:	0100ea05 	.word	0x0100ea05
 1002218:	0100ea01 	.word	0x0100ea01
				(void)ll_pdu_rx_alloc();
 100221c:	f007 ff24 	bl	100a068 <ll_pdu_rx_alloc>
				rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
 1002220:	230e      	movs	r3, #14
				rx->hdr.handle = lll->handle;
 1002222:	8da2      	ldrh	r2, [r4, #44]	; 0x2c
				upd->status = 0U;
 1002224:	f888 7020 	strb.w	r7, [r8, #32]
				rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
 1002228:	f888 3004 	strb.w	r3, [r8, #4]
				upd->tx = lll->phy_tx;
 100222c:	f894 3064 	ldrb.w	r3, [r4, #100]	; 0x64
				ll_rx_put(rx->hdr.link, rx);
 1002230:	f8d8 0000 	ldr.w	r0, [r8]
				upd->tx = lll->phy_tx;
 1002234:	f3c3 0302 	ubfx	r3, r3, #0, #3
 1002238:	f888 3021 	strb.w	r3, [r8, #33]	; 0x21
				upd->rx = lll->phy_rx;
 100223c:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
				ll_rx_put(rx->hdr.link, rx);
 1002240:	4641      	mov	r1, r8
				upd->rx = lll->phy_rx;
 1002242:	f3c3 0302 	ubfx	r3, r3, #0, #3
 1002246:	f888 3022 	strb.w	r3, [r8, #34]	; 0x22
				rx->hdr.handle = lll->handle;
 100224a:	f8a8 2006 	strh.w	r2, [r8, #6]
				ll_rx_put(rx->hdr.link, rx);
 100224e:	f007 fedd 	bl	100a00c <ll_rx_put>
				ll_rx_sched();
 1002252:	f007 fee5 	bl	100a020 <ll_rx_sched>
 1002256:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
 100225a:	f8b4 00ee 	ldrh.w	r0, [r4, #238]	; 0xee
 100225e:	f3c3 0782 	ubfx	r7, r3, #2, #3
 1002262:	095b      	lsrs	r3, r3, #5
 1002264:	f7ff b904 	b.w	1001470 <ull_conn_llcp+0x8b8>
	switch (conn->llcp_conn_param.state) {
 1002268:	f894 3172 	ldrb.w	r3, [r4, #370]	; 0x172
 100226c:	f003 0307 	and.w	r3, r3, #7
 1002270:	2b05      	cmp	r3, #5
 1002272:	f200 819d 	bhi.w	10025b0 <ull_conn_llcp+0x19f8>
 1002276:	a201      	add	r2, pc, #4	; (adr r2, 100227c <ull_conn_llcp+0x16c4>)
 1002278:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 100227c:	01001a41 	.word	0x01001a41
 1002280:	010019a9 	.word	0x010019a9
 1002284:	01001949 	.word	0x01001949
 1002288:	01000be7 	.word	0x01000be7
 100228c:	01000be7 	.word	0x01000be7
 1002290:	01000be7 	.word	0x01000be7
		conn->tx_data_last = tx;
 1002294:	f8c4 81c0 	str.w	r8, [r4, #448]	; 0x1c0
		conn->procedure_expire = conn->procedure_reload;
 1002298:	e564      	b.n	1001d64 <ull_conn_llcp+0x11ac>
				conn->llcp_length.cache.tx_octets = 0;
 100229a:	2700      	movs	r7, #0
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
 100229c:	f894 319a 	ldrb.w	r3, [r4, #410]	; 0x19a
				conn->llcp_length.tx_octets =
 10022a0:	f8a4 019e 	strh.w	r0, [r4, #414]	; 0x19e
				conn->llcp_length.tx_time =
 10022a4:	f8b4 01a6 	ldrh.w	r0, [r4, #422]	; 0x1a6
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
 10022a8:	f367 0302 	bfi	r3, r7, #0, #3
				conn->llcp_length.cache.tx_octets = 0;
 10022ac:	f8a4 71a4 	strh.w	r7, [r4, #420]	; 0x1a4
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
 10022b0:	f884 319a 	strb.w	r3, [r4, #410]	; 0x19a
				conn->llcp_length.tx_time =
 10022b4:	f8a4 01a2 	strh.w	r0, [r4, #418]	; 0x1a2
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
 10022b8:	f7ff ba01 	b.w	10016be <ull_conn_llcp+0xb06>
			tx->next = conn->tx_head->next;
 10022bc:	681a      	ldr	r2, [r3, #0]
 10022be:	6002      	str	r2, [r0, #0]
			conn->tx_head->next = tx;
 10022c0:	6018      	str	r0, [r3, #0]
				conn->tx_ctrl = tx;
 10022c2:	6803      	ldr	r3, [r0, #0]
				conn->tx_ctrl_last = tx;
 10022c4:	e9c4 006d 	strd	r0, r0, [r4, #436]	; 0x1b4
 10022c8:	f7ff b800 	b.w	10012cc <ull_conn_llcp+0x714>
		if (!conn->tx_ctrl) {
 10022cc:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 10022d0:	2a00      	cmp	r2, #0
 10022d2:	d189      	bne.n	10021e8 <ull_conn_llcp+0x1630>
			tx->next = conn->tx_head;
 10022d4:	6003      	str	r3, [r0, #0]
				conn->tx_ctrl = tx;
 10022d6:	e9c4 006c 	strd	r0, r0, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 10022da:	f8c4 01b8 	str.w	r0, [r4, #440]	; 0x1b8
 10022de:	e78a      	b.n	10021f6 <ull_conn_llcp+0x163e>
			tx->next = conn->tx_head->next;
 10022e0:	681a      	ldr	r2, [r3, #0]
 10022e2:	6032      	str	r2, [r6, #0]
			conn->tx_head->next = tx;
 10022e4:	601e      	str	r6, [r3, #0]
				conn->tx_ctrl = tx;
 10022e6:	6833      	ldr	r3, [r6, #0]
				conn->tx_ctrl_last = tx;
 10022e8:	e9c4 666d 	strd	r6, r6, [r4, #436]	; 0x1b4
 10022ec:	f7fe bf87 	b.w	10011fe <ull_conn_llcp+0x646>
			tx->next = conn->tx_head->next;
 10022f0:	681a      	ldr	r2, [r3, #0]
 10022f2:	6032      	str	r2, [r6, #0]
			conn->tx_head->next = tx;
 10022f4:	601e      	str	r6, [r3, #0]
				conn->tx_ctrl = tx;
 10022f6:	6833      	ldr	r3, [r6, #0]
				conn->tx_ctrl_last = tx;
 10022f8:	e9c4 666d 	strd	r6, r6, [r4, #436]	; 0x1b4
 10022fc:	f7ff b8e6 	b.w	10014cc <ull_conn_llcp+0x914>
			tx->next = conn->tx_head->next;
 1002300:	681a      	ldr	r2, [r3, #0]
 1002302:	602a      	str	r2, [r5, #0]
			conn->tx_head->next = tx;
 1002304:	601d      	str	r5, [r3, #0]
				conn->tx_ctrl = tx;
 1002306:	682b      	ldr	r3, [r5, #0]
				conn->tx_ctrl_last = tx;
 1002308:	e9c4 556d 	strd	r5, r5, [r4, #436]	; 0x1b4
 100230c:	f7ff b980 	b.w	1001610 <ull_conn_llcp+0xa58>
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 1002310:	2303      	movs	r3, #3
			ll_rx_put(rx->hdr.link, rx);
 1002312:	4631      	mov	r1, r6
			rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 1002314:	7133      	strb	r3, [r6, #4]
			ll_rx_put(rx->hdr.link, rx);
 1002316:	f007 fe79 	bl	100a00c <ll_rx_put>
			ll_rx_sched();
 100231a:	f007 fe81 	bl	100a020 <ll_rx_sched>
			return;
 100231e:	f7fe bc62 	b.w	1000be6 <ull_conn_llcp+0x2e>
		if (!conn->tx_ctrl) {
 1002322:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 1002326:	2a00      	cmp	r2, #0
 1002328:	f47f ae19 	bne.w	1001f5e <ull_conn_llcp+0x13a6>
			tx->next = conn->tx_head;
 100232c:	6019      	str	r1, [r3, #0]
				conn->tx_ctrl = tx;
 100232e:	e9c4 336c 	strd	r3, r3, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 1002332:	f8c4 31b8 	str.w	r3, [r4, #440]	; 0x1b8
 1002336:	e619      	b.n	1001f6c <ull_conn_llcp+0x13b4>
			tx->next = conn->tx_head->next;
 1002338:	6813      	ldr	r3, [r2, #0]
 100233a:	6003      	str	r3, [r0, #0]
			conn->tx_head->next = tx;
 100233c:	6010      	str	r0, [r2, #0]
				conn->tx_ctrl = tx;
 100233e:	6802      	ldr	r2, [r0, #0]
				conn->tx_ctrl_last = tx;
 1002340:	e9c4 006d 	strd	r0, r0, [r4, #436]	; 0x1b4
 1002344:	f7ff ba56 	b.w	10017f4 <ull_conn_llcp+0xc3c>
		LL_ASSERT(rx && rx->hdr.link);
 1002348:	48a2      	ldr	r0, [pc, #648]	; (10025d4 <ull_conn_llcp+0x1a1c>)
 100234a:	f640 5108 	movw	r1, #3336	; 0xd08
 100234e:	f001 f91b 	bl	1003588 <bt_ctlr_assert_handle>
 1002352:	6838      	ldr	r0, [r7, #0]
 1002354:	e575      	b.n	1001e42 <ull_conn_llcp+0x128a>
		tx_time = MAX(MIN(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_1M),
 1002356:	f44f 72a4 	mov.w	r2, #328	; 0x148
		rx_time = PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_1M);
 100235a:	4611      	mov	r1, r2
 100235c:	e5dc      	b.n	1001f18 <ull_conn_llcp+0x1360>
			tx->next = conn->tx_head->next;
 100235e:	681a      	ldr	r2, [r3, #0]
 1002360:	f8c8 2000 	str.w	r2, [r8]
			conn->tx_head->next = tx;
 1002364:	f8c3 8000 	str.w	r8, [r3]
				conn->tx_ctrl = tx;
 1002368:	f8d8 3000 	ldr.w	r3, [r8]
				conn->tx_ctrl_last = tx;
 100236c:	e9c4 886d 	strd	r8, r8, [r4, #436]	; 0x1b4
 1002370:	e4f5      	b.n	1001d5e <ull_conn_llcp+0x11a6>
			if (!conn->llcp_length.cache.tx_octets) {
 1002372:	f8b4 31a4 	ldrh.w	r3, [r4, #420]	; 0x1a4
 1002376:	2b00      	cmp	r3, #0
 1002378:	f040 80c6 	bne.w	1002508 <ull_conn_llcp+0x1950>
				conn->llcp_length.ack = conn->llcp_length.req;
 100237c:	f884 7199 	strb.w	r7, [r4, #409]	; 0x199
				conn->procedure_expire = 0U;
 1002380:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
 1002384:	e554      	b.n	1001e30 <ull_conn_llcp+0x1278>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1002386:	4894      	ldr	r0, [pc, #592]	; (10025d8 <ull_conn_llcp+0x1a20>)
 1002388:	f003 fc4a 	bl	1005c20 <mem_acquire>
		if (!tx) {
 100238c:	4601      	mov	r1, r0
 100238e:	2800      	cmp	r0, #0
 1002390:	f43e afef 	beq.w	1001372 <ull_conn_llcp+0x7ba>
		pdu->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
 1002394:	2003      	movs	r0, #3
		rej->reject_opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
 1002396:	220f      	movs	r2, #15
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
 1002398:	2711      	movs	r7, #17
		pdu->ll_id = PDU_DATA_LLID_CTRL;
 100239a:	790b      	ldrb	r3, [r1, #4]
		pdu->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
 100239c:	7148      	strb	r0, [r1, #5]
		pdu->ll_id = PDU_DATA_LLID_CTRL;
 100239e:	4303      	orrs	r3, r0
		rej->reject_opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ;
 10023a0:	720a      	strb	r2, [r1, #8]
		pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
 10023a2:	71cf      	strb	r7, [r1, #7]
		pdu->ll_id = PDU_DATA_LLID_CTRL;
 10023a4:	710b      	strb	r3, [r1, #4]
		rej->error_code = conn->llcp_conn_param.status;
 10023a6:	f894 3173 	ldrb.w	r3, [r4, #371]	; 0x173
	ctrl_tx_pause_enqueue(conn, tx, false);
 10023aa:	2200      	movs	r2, #0
		rej->error_code = conn->llcp_conn_param.status;
 10023ac:	724b      	strb	r3, [r1, #9]
	ctrl_tx_pause_enqueue(conn, tx, false);
 10023ae:	4620      	mov	r0, r4
 10023b0:	f008 fde6 	bl	100af80 <ctrl_tx_pause_enqueue>
		conn_upd_curr = NULL;
 10023b4:	2200      	movs	r2, #0
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
 10023b6:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
		conn_upd_curr = NULL;
 10023ba:	f8c9 2000 	str.w	r2, [r9]
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
 10023be:	f884 3171 	strb.w	r3, [r4, #369]	; 0x171
		return;
 10023c2:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
 10023c6:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 10023ca:	f7fe bc07 	b.w	1000bdc <ull_conn_llcp+0x24>
				LL_ASSERT(rx && rx->hdr.link);
 10023ce:	4881      	ldr	r0, [pc, #516]	; (10025d4 <ull_conn_llcp+0x1a1c>)
 10023d0:	f640 6147 	movw	r1, #3655	; 0xe47
 10023d4:	f001 f8d8 	bl	1003588 <bt_ctlr_assert_handle>
 10023d8:	6828      	ldr	r0, [r5, #0]
 10023da:	e68a      	b.n	10020f2 <ull_conn_llcp+0x153a>
	    (!feature_coded_phy && !feature_phy_2m)) {
 10023dc:	05c9      	lsls	r1, r1, #23
		tx_time = MAX(MIN(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_1M),
 10023de:	f44f 72a4 	mov.w	r2, #328	; 0x148
	    (!feature_coded_phy && !feature_phy_2m)) {
 10023e2:	f140 80a9 	bpl.w	1002538 <ull_conn_llcp+0x1980>
		rx_time = MAX(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_2M),
 10023e6:	21a8      	movs	r1, #168	; 0xa8
 10023e8:	e596      	b.n	1001f18 <ull_conn_llcp+0x1360>
		if (conn->llcp_phy.tx & BIT(1)) {
 10023ea:	0708      	lsls	r0, r1, #28
		conn->llcp_phy.ack = conn->llcp_phy.req;
 10023ec:	f884 31a9 	strb.w	r3, [r4, #425]	; 0x1a9
		if (conn->llcp_phy.tx & BIT(1)) {
 10023f0:	f3c1 0382 	ubfx	r3, r1, #2, #3
 10023f4:	f140 80aa 	bpl.w	100254c <ull_conn_llcp+0x1994>
			conn->llcp_phy.tx = BIT(1);
 10023f8:	2102      	movs	r1, #2
 10023fa:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
 10023fe:	f361 0384 	bfi	r3, r1, #2, #3
 1002402:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
		if (conn->llcp_phy.rx & BIT(1)) {
 1002406:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
 100240a:	065f      	lsls	r7, r3, #25
 100240c:	ea4f 1153 	mov.w	r1, r3, lsr #5
 1002410:	f140 8094 	bpl.w	100253c <ull_conn_llcp+0x1984>
			conn->llcp_phy.rx = BIT(1);
 1002414:	2102      	movs	r1, #2
 1002416:	f361 1347 	bfi	r3, r1, #5, #3
 100241a:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
		if (conn->llcp_phy.tx != conn->lll.phy_tx) {
 100241e:	f894 11aa 	ldrb.w	r1, [r4, #426]	; 0x1aa
 1002422:	f894 0064 	ldrb.w	r0, [r4, #100]	; 0x64
		if (conn->llcp_phy.rx != conn->lll.phy_rx) {
 1002426:	f894 3065 	ldrb.w	r3, [r4, #101]	; 0x65
		if (conn->llcp_phy.tx != conn->lll.phy_tx) {
 100242a:	f000 0007 	and.w	r0, r0, #7
		if (conn->llcp_phy.rx != conn->lll.phy_rx) {
 100242e:	f003 0307 	and.w	r3, r3, #7
		if (conn->llcp_phy.tx != conn->lll.phy_tx) {
 1002432:	f3c1 0782 	ubfx	r7, r1, #2, #3
			conn->llcp.phy_upd_ind.tx = 0U;
 1002436:	42b8      	cmp	r0, r7
 1002438:	bf08      	it	eq
 100243a:	2700      	moveq	r7, #0
			conn->llcp.phy_upd_ind.rx = 0U;
 100243c:	ebb3 1f51 	cmp.w	r3, r1, lsr #5
		if (conn->llcp_phy.rx != conn->lll.phy_rx) {
 1002440:	ea4f 1051 	mov.w	r0, r1, lsr #5
			conn->llcp.phy_upd_ind.rx = 0U;
 1002444:	bf08      	it	eq
 1002446:	2000      	moveq	r0, #0
		conn->llcp_type = LLCP_PHY_UPD;
 1002448:	f04f 0c06 	mov.w	ip, #6
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
 100244c:	f894 11ab 	ldrb.w	r1, [r4, #427]	; 0x1ab
		conn->llcp_ack -= 2U;
 1002450:	1e93      	subs	r3, r2, #2
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
 1002452:	f3c1 0180 	ubfx	r1, r1, #2, #1
		conn->llcp.phy_upd_ind.initiate = 1U;
 1002456:	0049      	lsls	r1, r1, #1
 1002458:	f041 0101 	orr.w	r1, r1, #1
 100245c:	ea41 1140 	orr.w	r1, r1, r0, lsl #5
 1002460:	ea41 0187 	orr.w	r1, r1, r7, lsl #2
		conn->llcp_ack -= 2U;
 1002464:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
		conn->llcp.phy_upd_ind.initiate = 1U;
 1002468:	f884 10ec 	strb.w	r1, [r4, #236]	; 0xec
		conn->llcp_type = LLCP_PHY_UPD;
 100246c:	f884 c0ea 	strb.w	ip, [r4, #234]	; 0xea
		} else if (conn->llcp_length.ack != conn->llcp_length.req) {
 1002470:	f7fe bbe2 	b.w	1000c38 <ull_conn_llcp+0x80>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 1002474:	4858      	ldr	r0, [pc, #352]	; (10025d8 <ull_conn_llcp+0x1a20>)
 1002476:	f003 fbd3 	bl	1005c20 <mem_acquire>
	if (!tx) {
 100247a:	4601      	mov	r1, r0
 100247c:	2800      	cmp	r0, #0
 100247e:	f43e af78 	beq.w	1001372 <ull_conn_llcp+0x7ba>
	pdu->len = offsetof(struct pdu_data_llctrl, conn_param_rsp) +
 1002482:	2018      	movs	r0, #24
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_RSP;
 1002484:	2210      	movs	r2, #16
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 1002486:	790b      	ldrb	r3, [r1, #4]
	pdu->len = offsetof(struct pdu_data_llctrl, conn_param_rsp) +
 1002488:	7148      	strb	r0, [r1, #5]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 100248a:	f043 0303 	orr.w	r3, r3, #3
 100248e:	710b      	strb	r3, [r1, #4]
	rsp->interval_min =
 1002490:	f8b4 0174 	ldrh.w	r0, [r4, #372]	; 0x174
	rsp->interval_max =
 1002494:	f8b4 3176 	ldrh.w	r3, [r4, #374]	; 0x176
	rsp->interval_min =
 1002498:	8108      	strh	r0, [r1, #8]
	rsp->latency =
 100249a:	f8b4 0178 	ldrh.w	r0, [r4, #376]	; 0x178
	rsp->interval_max =
 100249e:	814b      	strh	r3, [r1, #10]
	rsp->timeout =
 10024a0:	f8b4 317a 	ldrh.w	r3, [r4, #378]	; 0x17a
	rsp->latency =
 10024a4:	8188      	strh	r0, [r1, #12]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_CONN_PARAM_RSP;
 10024a6:	71ca      	strb	r2, [r1, #7]
	rsp->timeout =
 10024a8:	81cb      	strh	r3, [r1, #14]
	rsp->preferred_periodicity =
 10024aa:	f894 317c 	ldrb.w	r3, [r4, #380]	; 0x17c
	ctrl_tx_pause_enqueue(conn, tx, false);
 10024ae:	4620      	mov	r0, r4
	rsp->preferred_periodicity =
 10024b0:	740b      	strb	r3, [r1, #16]
	rsp->reference_conn_event_count =
 10024b2:	f8b4 317e 	ldrh.w	r3, [r4, #382]	; 0x17e
	rsp->offset0 = sys_cpu_to_le16(conn->llcp_conn_param.offset0);
 10024b6:	f8b4 2180 	ldrh.w	r2, [r4, #384]	; 0x180
	rsp->reference_conn_event_count =
 10024ba:	f8a1 3011 	strh.w	r3, [r1, #17]
	rsp->offset1 = sys_cpu_to_le16(conn->llcp_conn_param.offset1);
 10024be:	f8b4 3182 	ldrh.w	r3, [r4, #386]	; 0x182
	rsp->offset0 = sys_cpu_to_le16(conn->llcp_conn_param.offset0);
 10024c2:	f8a1 2013 	strh.w	r2, [r1, #19]
	rsp->offset2 = sys_cpu_to_le16(conn->llcp_conn_param.offset2);
 10024c6:	f8b4 2184 	ldrh.w	r2, [r4, #388]	; 0x184
	rsp->offset1 = sys_cpu_to_le16(conn->llcp_conn_param.offset1);
 10024ca:	f8a1 3015 	strh.w	r3, [r1, #21]
	rsp->offset3 = sys_cpu_to_le16(conn->llcp_conn_param.offset3);
 10024ce:	f8b4 3186 	ldrh.w	r3, [r4, #390]	; 0x186
	rsp->offset2 = sys_cpu_to_le16(conn->llcp_conn_param.offset2);
 10024d2:	f8a1 2017 	strh.w	r2, [r1, #23]
	rsp->offset4 = sys_cpu_to_le16(conn->llcp_conn_param.offset4);
 10024d6:	f8b4 2188 	ldrh.w	r2, [r4, #392]	; 0x188
	rsp->offset3 = sys_cpu_to_le16(conn->llcp_conn_param.offset3);
 10024da:	f8a1 3019 	strh.w	r3, [r1, #25]
	rsp->offset5 = sys_cpu_to_le16(conn->llcp_conn_param.offset5);
 10024de:	f8b4 318a 	ldrh.w	r3, [r4, #394]	; 0x18a
	rsp->offset4 = sys_cpu_to_le16(conn->llcp_conn_param.offset4);
 10024e2:	f8a1 201b 	strh.w	r2, [r1, #27]
	rsp->offset5 = sys_cpu_to_le16(conn->llcp_conn_param.offset5);
 10024e6:	f8a1 301d 	strh.w	r3, [r1, #29]
	ctrl_tx_pause_enqueue(conn, tx, false);
 10024ea:	463a      	mov	r2, r7
 10024ec:	f008 fd48 	bl	100af80 <ctrl_tx_pause_enqueue>
	conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
 10024f0:	f894 3170 	ldrb.w	r3, [r4, #368]	; 0x170
 10024f4:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
 10024f8:	f884 3171 	strb.w	r3, [r4, #369]	; 0x171
	conn_upd_curr = NULL;
 10024fc:	f8c9 7000 	str.w	r7, [r9]
 1002500:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 1002504:	f7fe bb6a 	b.w	1000bdc <ull_conn_llcp+0x24>
				conn->llcp_length.cache.tx_octets = 0;
 1002508:	2200      	movs	r2, #0
				conn->llcp_length.tx_octets =
 100250a:	f8a4 319e 	strh.w	r3, [r4, #414]	; 0x19e
				conn->llcp_length.tx_time =
 100250e:	f8b4 31a6 	ldrh.w	r3, [r4, #422]	; 0x1a6
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
 1002512:	f362 0102 	bfi	r1, r2, #0, #3
 1002516:	f884 119a 	strb.w	r1, [r4, #410]	; 0x19a
				conn->llcp_length.cache.tx_octets = 0;
 100251a:	f8a4 21a4 	strh.w	r2, [r4, #420]	; 0x1a4
				conn->llcp_length.tx_time =
 100251e:	f8a4 31a2 	strh.w	r3, [r4, #418]	; 0x1a2
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
 1002522:	e485      	b.n	1001e30 <ull_conn_llcp+0x1278>
			tx->next = conn->tx_head->next;
 1002524:	681a      	ldr	r2, [r3, #0]
 1002526:	6002      	str	r2, [r0, #0]
			conn->tx_head->next = tx;
 1002528:	6018      	str	r0, [r3, #0]
				conn->tx_ctrl_last = tx;
 100252a:	e9c4 006d 	strd	r0, r0, [r4, #436]	; 0x1b4
 100252e:	e662      	b.n	10021f6 <ull_conn_llcp+0x163e>
				conn->llcp_conn_param.interval_max;
 1002530:	f8b4 2176 	ldrh.w	r2, [r4, #374]	; 0x176
 1002534:	f7ff ba5a 	b.w	10019ec <ull_conn_llcp+0xe34>
		rx_time = PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_1M);
 1002538:	4611      	mov	r1, r2
 100253a:	e4ed      	b.n	1001f18 <ull_conn_llcp+0x1360>
		} else if (conn->llcp_phy.rx & BIT(0)) {
 100253c:	07c8      	lsls	r0, r1, #31
 100253e:	d50f      	bpl.n	1002560 <ull_conn_llcp+0x19a8>
			conn->llcp_phy.rx = BIT(0);
 1002540:	2101      	movs	r1, #1
 1002542:	f361 1347 	bfi	r3, r1, #5, #3
 1002546:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
 100254a:	e768      	b.n	100241e <ull_conn_llcp+0x1866>
		} else if (conn->llcp_phy.tx & BIT(0)) {
 100254c:	07d9      	lsls	r1, r3, #31
 100254e:	d510      	bpl.n	1002572 <ull_conn_llcp+0x19ba>
			conn->llcp_phy.tx = BIT(0);
 1002550:	2101      	movs	r1, #1
 1002552:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
 1002556:	f361 0384 	bfi	r3, r1, #2, #3
 100255a:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
 100255e:	e752      	b.n	1002406 <ull_conn_llcp+0x184e>
		} else if (conn->llcp_phy.rx & BIT(2)) {
 1002560:	f011 0104 	ands.w	r1, r1, #4
			conn->llcp_phy.rx = BIT(2);
 1002564:	bf18      	it	ne
 1002566:	2104      	movne	r1, #4
			conn->llcp_phy.rx = 0U;
 1002568:	f361 1347 	bfi	r3, r1, #5, #3
 100256c:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
 1002570:	e755      	b.n	100241e <ull_conn_llcp+0x1866>
		} else if (conn->llcp_phy.tx & BIT(2)) {
 1002572:	f013 0304 	ands.w	r3, r3, #4
 1002576:	d00d      	beq.n	1002594 <ull_conn_llcp+0x19dc>
			conn->llcp_phy.tx = BIT(2);
 1002578:	2104      	movs	r1, #4
 100257a:	f894 31aa 	ldrb.w	r3, [r4, #426]	; 0x1aa
 100257e:	f361 0384 	bfi	r3, r1, #2, #3
 1002582:	f884 31aa 	strb.w	r3, [r4, #426]	; 0x1aa
 1002586:	e73e      	b.n	1002406 <ull_conn_llcp+0x184e>
			tx->next = conn->tx_head->next;
 1002588:	680a      	ldr	r2, [r1, #0]
 100258a:	601a      	str	r2, [r3, #0]
			conn->tx_head->next = tx;
 100258c:	600b      	str	r3, [r1, #0]
				conn->tx_ctrl_last = tx;
 100258e:	e9c4 336d 	strd	r3, r3, [r4, #436]	; 0x1b4
 1002592:	e4eb      	b.n	1001f6c <ull_conn_llcp+0x13b4>
			conn->llcp_phy.tx = 0U;
 1002594:	f894 11aa 	ldrb.w	r1, [r4, #426]	; 0x1aa
 1002598:	f363 0184 	bfi	r1, r3, #2, #3
 100259c:	f884 11aa 	strb.w	r1, [r4, #426]	; 0x1aa
 10025a0:	e731      	b.n	1002406 <ull_conn_llcp+0x184e>
		LL_ASSERT(0);
 10025a2:	f44f 6153 	mov.w	r1, #3376	; 0xd30
 10025a6:	480b      	ldr	r0, [pc, #44]	; (10025d4 <ull_conn_llcp+0x1a1c>)
 10025a8:	f000 ffee 	bl	1003588 <bt_ctlr_assert_handle>
		break;
 10025ac:	f7fe bee1 	b.w	1001372 <ull_conn_llcp+0x7ba>
		LL_ASSERT(0);
 10025b0:	f640 4134 	movw	r1, #3124	; 0xc34
 10025b4:	4807      	ldr	r0, [pc, #28]	; (10025d4 <ull_conn_llcp+0x1a1c>)
 10025b6:	f000 ffe7 	bl	1003588 <bt_ctlr_assert_handle>
		break;
 10025ba:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 10025be:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
 10025c2:	f7fe bb0b 	b.w	1000bdc <ull_conn_llcp+0x24>
		LL_ASSERT(0);
 10025c6:	f44f 6153 	mov.w	r1, #3376	; 0xd30
 10025ca:	4802      	ldr	r0, [pc, #8]	; (10025d4 <ull_conn_llcp+0x1a1c>)
 10025cc:	f000 ffdc 	bl	1003588 <bt_ctlr_assert_handle>
		break;
 10025d0:	f7fe bb32 	b.w	1000c38 <ull_conn_llcp+0x80>
 10025d4:	010187e4 	.word	0x010187e4
 10025d8:	210038cc 	.word	0x210038cc
 10025dc:	00000000 	.word	0x00000000

010025e0 <ull_slave_setup>:
static void ticker_op_stop_adv_cb(u32_t status, void *param);
static void ticker_op_cb(u32_t status, void *param);

void ull_slave_setup(memq_link_t *link, struct node_rx_hdr *rx,
		     struct node_rx_ftr *ftr, struct lll_conn *lll)
{
 10025e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10025e4:	4693      	mov	fp, r2
	u8_t chan_sel;

	((struct lll_adv *)ftr->param)->conn = NULL;

	adv = ((struct lll_adv *)ftr->param)->hdr.parent;
	conn = lll->hdr.parent;
 10025e6:	461a      	mov	r2, r3
{
 10025e8:	4689      	mov	r9, r1
	((struct lll_adv *)ftr->param)->conn = NULL;
 10025ea:	2100      	movs	r1, #0
{
 10025ec:	461d      	mov	r5, r3
	((struct lll_adv *)ftr->param)->conn = NULL;
 10025ee:	f8db 6000 	ldr.w	r6, [fp]
	conn = lll->hdr.parent;
 10025f2:	f852 4b0c 	ldr.w	r4, [r2], #12

	/* Populate the slave context */
	pdu_adv = (void *)((struct node_rx_pdu *)rx)->pdu;
	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
	memcpy(&lll->access_addr[0], &pdu_adv->connect_ind.access_addr[0], 4);
 10025f6:	f103 0808 	add.w	r8, r3, #8
	adv = ((struct lll_adv *)ftr->param)->hdr.parent;
 10025fa:	6833      	ldr	r3, [r6, #0]
{
 10025fc:	b093      	sub	sp, #76	; 0x4c
	((struct lll_adv *)ftr->param)->conn = NULL;
 10025fe:	60b1      	str	r1, [r6, #8]
{
 1002600:	4607      	mov	r7, r0
	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
 1002602:	f109 0132 	add.w	r1, r9, #50	; 0x32
 1002606:	4610      	mov	r0, r2
 1002608:	2203      	movs	r2, #3
	adv = ((struct lll_adv *)ftr->param)->hdr.parent;
 100260a:	930a      	str	r3, [sp, #40]	; 0x28
	memcpy(&lll->data_chan_map[0], &pdu_adv->connect_ind.chan_map[0],
 100260c:	f105 061c 	add.w	r6, r5, #28
	memcpy(&lll->crc_init[0], &pdu_adv->connect_ind.crc_init[0], 3);
 1002610:	f014 f952 	bl	10168b8 <memcpy>
	memcpy(&lll->access_addr[0], &pdu_adv->connect_ind.access_addr[0], 4);
 1002614:	2204      	movs	r2, #4
 1002616:	f109 012e 	add.w	r1, r9, #46	; 0x2e
 100261a:	4640      	mov	r0, r8
 100261c:	f014 f94c 	bl	10168b8 <memcpy>
	memcpy(&lll->data_chan_map[0], &pdu_adv->connect_ind.chan_map[0],
 1002620:	2205      	movs	r2, #5
 1002622:	f109 013e 	add.w	r1, r9, #62	; 0x3e
 1002626:	4630      	mov	r0, r6
 1002628:	f014 f946 	bl	10168b8 <memcpy>
	       sizeof(lll->data_chan_map));
	lll->data_chan_count = util_ones_count_get(&lll->data_chan_map[0],
 100262c:	4630      	mov	r0, r6
 100262e:	2105      	movs	r1, #5
 1002630:	f003 fcc2 	bl	1005fb8 <util_ones_count_get>
 1002634:	f895 2021 	ldrb.w	r2, [r5, #33]	; 0x21
 1002638:	f000 003f 	and.w	r0, r0, #63	; 0x3f
 100263c:	f360 0205 	bfi	r2, r0, #0, #6
			       sizeof(lll->data_chan_map));
	if (lll->data_chan_count < 2) {
 1002640:	2801      	cmp	r0, #1
	lll->data_chan_count = util_ones_count_get(&lll->data_chan_map[0],
 1002642:	f885 2021 	strb.w	r2, [r5, #33]	; 0x21
	if (lll->data_chan_count < 2) {
 1002646:	d90a      	bls.n	100265e <ull_slave_setup+0x7e>
		return;
	}
	lll->data_chan_hop = pdu_adv->connect_ind.hop;
 1002648:	f899 2043 	ldrb.w	r2, [r9, #67]	; 0x43
 100264c:	f002 011f 	and.w	r1, r2, #31
	if ((lll->data_chan_hop < 5) || (lll->data_chan_hop > 16)) {
 1002650:	3905      	subs	r1, #5
	lll->data_chan_hop = pdu_adv->connect_ind.hop;
 1002652:	f3c2 0004 	ubfx	r0, r2, #0, #5
	if ((lll->data_chan_hop < 5) || (lll->data_chan_hop > 16)) {
 1002656:	290b      	cmp	r1, #11
	lll->data_chan_hop = pdu_adv->connect_ind.hop;
 1002658:	f885 0022 	strb.w	r0, [r5, #34]	; 0x22
	if ((lll->data_chan_hop < 5) || (lll->data_chan_hop > 16)) {
 100265c:	d902      	bls.n	1002664 <ull_slave_setup+0x84>
	/* enable ticker job, irrespective of disabled in this function so
	 * first connection event can be scheduled as soon as possible.
	 */
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1);
#endif
}
 100265e:	b013      	add	sp, #76	; 0x4c
 1002660:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	interval = sys_le16_to_cpu(pdu_adv->connect_ind.interval);
 1002664:	f8b9 6038 	ldrh.w	r6, [r9, #56]	; 0x38
	conn->slave.sca = pdu_adv->connect_ind.sca;
 1002668:	f894 10dc 	ldrb.w	r1, [r4, #220]	; 0xdc
	lll->interval = interval;
 100266c:	826e      	strh	r6, [r5, #18]
	lll->latency = sys_le16_to_cpu(pdu_adv->connect_ind.latency);
 100266e:	f899 c03b 	ldrb.w	ip, [r9, #59]	; 0x3b
 1002672:	f899 003a 	ldrb.w	r0, [r9, #58]	; 0x3a
	conn->slave.sca = pdu_adv->connect_ind.sca;
 1002676:	0952      	lsrs	r2, r2, #5
	lll->latency = sys_le16_to_cpu(pdu_adv->connect_ind.latency);
 1002678:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
 100267c:	82a8      	strh	r0, [r5, #20]
	win_offset = sys_le16_to_cpu(pdu_adv->connect_ind.win_offset);
 100267e:	f8b9 3036 	ldrh.w	r3, [r9, #54]	; 0x36
	conn->slave.sca = pdu_adv->connect_ind.sca;
 1002682:	f362 0184 	bfi	r1, r2, #2, #3
 1002686:	f884 10dc 	strb.w	r1, [r4, #220]	; 0xdc
	win_offset = sys_le16_to_cpu(pdu_adv->connect_ind.win_offset);
 100268a:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
		(((lll_conn_ppm_local_get() +
 100268e:	f00e fc2d 	bl	1010eec <lll_conn_ppm_local_get>
	conn_interval_us = interval * 1250U;
 1002692:	f240 4ae2 	movw	sl, #1250	; 0x4e2
		   lll_conn_ppm_get(conn->slave.sca)) *
 1002696:	f894 20dc 	ldrb.w	r2, [r4, #220]	; 0xdc
		(((lll_conn_ppm_local_get() +
 100269a:	900b      	str	r0, [sp, #44]	; 0x2c
		   lll_conn_ppm_get(conn->slave.sca)) *
 100269c:	f3c2 0082 	ubfx	r0, r2, #2, #3
 10026a0:	f00e fc26 	bl	1010ef0 <lll_conn_ppm_get>
		RADIO_CONN_EVENTS((timeout * 10U * 1000U), conn_interval_us);
 10026a4:	f242 7210 	movw	r2, #10000	; 0x2710
	interval = sys_le16_to_cpu(pdu_adv->connect_ind.interval);
 10026a8:	b2b6      	uxth	r6, r6
	conn_interval_us = interval * 1250U;
 10026aa:	fb0a f606 	mul.w	r6, sl, r6
		(((lll_conn_ppm_local_get() +
 10026ae:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
	lll->slave.window_size_event_us = pdu_adv->connect_ind.win_size * 1250U;
 10026b0:	f899 1035 	ldrb.w	r1, [r9, #53]	; 0x35
		(((lll_conn_ppm_local_get() +
 10026b4:	4418      	add	r0, r3
		   lll_conn_ppm_get(conn->slave.sca)) *
 10026b6:	fb06 f000 	mul.w	r0, r6, r0
		  conn_interval_us) + (1000000 - 1)) / 1000000U;
 10026ba:	4bc5      	ldr	r3, [pc, #788]	; (10029d0 <ull_slave_setup+0x3f0>)
 10026bc:	f500 2074 	add.w	r0, r0, #999424	; 0xf4000
 10026c0:	f200 203f 	addw	r0, r0, #575	; 0x23f
 10026c4:	fba3 3000 	umull	r3, r0, r3, r0
	lll->slave.window_size_event_us = pdu_adv->connect_ind.win_size * 1250U;
 10026c8:	fb0a f301 	mul.w	r3, sl, r1
	lll->slave.window_widening_max_us = (conn_interval_us >> 1) -
 10026cc:	0871      	lsrs	r1, r6, #1
		  conn_interval_us) + (1000000 - 1)) / 1000000U;
 10026ce:	0c80      	lsrs	r0, r0, #18
	lll->slave.window_widening_max_us = (conn_interval_us >> 1) -
 10026d0:	3996      	subs	r1, #150	; 0x96
	lll->slave.window_widening_periodic_us =
 10026d2:	62a8      	str	r0, [r5, #40]	; 0x28
	lll->slave.window_widening_max_us = (conn_interval_us >> 1) -
 10026d4:	62e9      	str	r1, [r5, #44]	; 0x2c
	lll->slave.window_size_event_us = pdu_adv->connect_ind.win_size * 1250U;
 10026d6:	63eb      	str	r3, [r5, #60]	; 0x3c
	timeout = sys_le16_to_cpu(pdu_adv->connect_ind.timeout);
 10026d8:	f8b9 303c 	ldrh.w	r3, [r9, #60]	; 0x3c
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 10026dc:	49bd      	ldr	r1, [pc, #756]	; (10029d4 <ull_slave_setup+0x3f4>)
	timeout = sys_le16_to_cpu(pdu_adv->connect_ind.timeout);
 10026de:	b298      	uxth	r0, r3
		RADIO_CONN_EVENTS((timeout * 10U * 1000U), conn_interval_us);
 10026e0:	fb02 6200 	mla	r2, r2, r0, r6
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 10026e4:	4431      	add	r1, r6
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
 10026e6:	48bc      	ldr	r0, [pc, #752]	; (10029d8 <ull_slave_setup+0x3f8>)
		RADIO_CONN_EVENTS((timeout * 10U * 1000U), conn_interval_us);
 10026e8:	3a01      	subs	r2, #1
 10026ea:	fbb2 f2f6 	udiv	r2, r2, r6
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 10026ee:	fbb1 f1f6 	udiv	r1, r1, r6
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
 10026f2:	4430      	add	r0, r6
 10026f4:	fbb0 f0f6 	udiv	r0, r0, r6
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
 10026f8:	f8b5 c014 	ldrh.w	ip, [r5, #20]
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 10026fc:	fa1f fe81 	uxth.w	lr, r1
		RADIO_CONN_EVENTS((timeout * 10U * 1000U), conn_interval_us);
 1002700:	f8a4 20c6 	strh.w	r2, [r4, #198]	; 0xc6
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
 1002704:	f10c 0206 	add.w	r2, ip, #6
 1002708:	4596      	cmp	lr, r2
	timeout = sys_le16_to_cpu(pdu_adv->connect_ind.timeout);
 100270a:	f8ad 3036 	strh.w	r3, [sp, #54]	; 0x36
	conn->apto_reload = RADIO_CONN_EVENTS((30 * 1000 * 1000),
 100270e:	f8a4 e0d2 	strh.w	lr, [r4, #210]	; 0xd2
		RADIO_CONN_EVENTS((40 * 1000 * 1000), conn_interval_us);
 1002712:	f8a4 00ca 	strh.w	r0, [r4, #202]	; 0xca
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
 1002716:	dd05      	ble.n	1002724 <ull_slave_setup+0x144>
			     (conn->apto_reload - (lll->latency + 6)) :
 1002718:	ebae 0c0c 	sub.w	ip, lr, ip
 100271c:	f1ac 0c06 	sub.w	ip, ip, #6
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
 1002720:	fa1f fe8c 	uxth.w	lr, ip
	memcpy((void *)&conn->slave.force, &lll->access_addr[0],
 1002724:	4641      	mov	r1, r8
	conn->appto_reload = (conn->apto_reload > (lll->latency + 6)) ?
 1002726:	f8a4 e0ce 	strh.w	lr, [r4, #206]	; 0xce
	memcpy((void *)&conn->slave.force, &lll->access_addr[0],
 100272a:	2204      	movs	r2, #4
 100272c:	f104 00e0 	add.w	r0, r4, #224	; 0xe0
 1002730:	f014 f8c2 	bl	10168b8 <memcpy>
	peer_addr_type = pdu_adv->tx_addr;
 1002734:	f899 c020 	ldrb.w	ip, [r9, #32]
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
 1002738:	f109 0a22 	add.w	sl, r9, #34	; 0x22
	peer_addr_type = pdu_adv->tx_addr;
 100273c:	f3cc 1380 	ubfx	r3, ip, #6, #1
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
 1002740:	4651      	mov	r1, sl
 1002742:	2206      	movs	r2, #6
 1002744:	a810      	add	r0, sp, #64	; 0x40
	peer_addr_type = pdu_adv->tx_addr;
 1002746:	f88d 303c 	strb.w	r3, [sp, #60]	; 0x3c
	memcpy(peer_addr, pdu_adv->connect_ind.init_addr, BDADDR_SIZE);
 100274a:	f014 f8b5 	bl	10168b8 <memcpy>
	cc->status = 0U;
 100274e:	f44f 7180 	mov.w	r1, #256	; 0x100
	chan_sel = pdu_adv->chan_sel;
 1002752:	f899 2020 	ldrb.w	r2, [r9, #32]
	if (ull_filter_lll_lrpa_used(adv->lll.rl_idx)) {
 1002756:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	cc->status = 0U;
 1002758:	f8a9 1020 	strh.w	r1, [r9, #32]
	if (ull_filter_lll_lrpa_used(adv->lll.rl_idx)) {
 100275c:	f893 002a 	ldrb.w	r0, [r3, #42]	; 0x2a
	chan_sel = pdu_adv->chan_sel;
 1002760:	f3c2 1340 	ubfx	r3, r2, #5, #1
	u8_t rl_idx = ftr->rl_idx;
 1002764:	f89b 8016 	ldrb.w	r8, [fp, #22]
	chan_sel = pdu_adv->chan_sel;
 1002768:	f88d 3038 	strb.w	r3, [sp, #56]	; 0x38
 100276c:	930b      	str	r3, [sp, #44]	; 0x2c
	if (ull_filter_lll_lrpa_used(adv->lll.rl_idx)) {
 100276e:	f00d f803 	bl	100f778 <ull_filter_lll_lrpa_used>
		memcpy(&cc->local_rpa[0], &pdu_adv->connect_ind.adv_addr[0],
 1002772:	2206      	movs	r2, #6
	if (ull_filter_lll_lrpa_used(adv->lll.rl_idx)) {
 1002774:	4601      	mov	r1, r0
 1002776:	2800      	cmp	r0, #0
 1002778:	f040 80ef 	bne.w	100295a <ull_slave_setup+0x37a>
		memset(&cc->local_rpa[0], 0x0, BDADDR_SIZE);
 100277c:	f109 002f 	add.w	r0, r9, #47	; 0x2f
 1002780:	f014 f8c5 	bl	101690e <memset>
	if (rl_idx != FILTER_IDX_NONE) {
 1002784:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
 1002788:	f000 80f1 	beq.w	100296e <ull_slave_setup+0x38e>
		ll_rl_id_addr_get(rl_idx, &cc->peer_addr_type,
 100278c:	4651      	mov	r1, sl
 100278e:	4640      	mov	r0, r8
 1002790:	f109 0223 	add.w	r2, r9, #35	; 0x23
 1002794:	f00c fa5e 	bl	100ec54 <ll_rl_id_addr_get>
		cc->peer_addr_type += 2;
 1002798:	f899 2022 	ldrb.w	r2, [r9, #34]	; 0x22
		memcpy(&cc->peer_rpa[0], &peer_addr[0], BDADDR_SIZE);
 100279c:	a910      	add	r1, sp, #64	; 0x40
		cc->peer_addr_type += 2;
 100279e:	3202      	adds	r2, #2
 10027a0:	f889 2022 	strb.w	r2, [r9, #34]	; 0x22
		memcpy(&cc->peer_rpa[0], &peer_addr[0], BDADDR_SIZE);
 10027a4:	f109 0029 	add.w	r0, r9, #41	; 0x29
 10027a8:	2206      	movs	r2, #6
 10027aa:	f014 f885 	bl	10168b8 <memcpy>
	cc->sca = conn->slave.sca;
 10027ae:	f894 20dc 	ldrb.w	r2, [r4, #220]	; 0xdc
	cc->interval = lll->interval;
 10027b2:	8a68      	ldrh	r0, [r5, #18]
	cc->latency = lll->latency;
 10027b4:	8aa9      	ldrh	r1, [r5, #20]
	cc->timeout = timeout;
 10027b6:	f8bd 3036 	ldrh.w	r3, [sp, #54]	; 0x36
	cc->sca = conn->slave.sca;
 10027ba:	f3c2 0282 	ubfx	r2, r2, #2, #3
	cc->timeout = timeout;
 10027be:	f8a9 303a 	strh.w	r3, [r9, #58]	; 0x3a
	cc->interval = lll->interval;
 10027c2:	f8a9 0036 	strh.w	r0, [r9, #54]	; 0x36
	cc->sca = conn->slave.sca;
 10027c6:	f889 203c 	strb.w	r2, [r9, #60]	; 0x3c
	cc->latency = lll->latency;
 10027ca:	f8a9 1038 	strh.w	r1, [r9, #56]	; 0x38
	lll->handle = ll_conn_handle_get(conn);
 10027ce:	4620      	mov	r0, r4
 10027d0:	f008 feb6 	bl	100b540 <ll_conn_handle_get>
 10027d4:	4602      	mov	r2, r0
 10027d6:	8228      	strh	r0, [r5, #16]
		ll_rx_put(link, rx);
 10027d8:	4649      	mov	r1, r9
 10027da:	4638      	mov	r0, r7
	rx->handle = lll->handle;
 10027dc:	f8a9 2006 	strh.w	r2, [r9, #6]
		rx_csa = (void *)ftr->extra;
 10027e0:	f8db 7004 	ldr.w	r7, [fp, #4]
		ll_rx_put(link, rx);
 10027e4:	f007 fc12 	bl	100a00c <ll_rx_put>
		rx->type = NODE_RX_TYPE_CHAN_SEL_ALGO;
 10027e8:	230d      	movs	r3, #13
		rx->handle = lll->handle;
 10027ea:	8a2a      	ldrh	r2, [r5, #16]
		rx->type = NODE_RX_TYPE_CHAN_SEL_ALGO;
 10027ec:	713b      	strb	r3, [r7, #4]
		if (chan_sel) {
 10027ee:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
		link = rx->link;
 10027f0:	6838      	ldr	r0, [r7, #0]
		rx->handle = lll->handle;
 10027f2:	80fa      	strh	r2, [r7, #6]
		if (chan_sel) {
 10027f4:	2b00      	cmp	r3, #0
 10027f6:	f000 80cb 	beq.w	1002990 <ull_slave_setup+0x3b0>
			cs->csa = 0x01;
 10027fa:	2101      	movs	r1, #1
			u16_t aa_ls = ((u16_t)lll->access_addr[1] << 8) |
 10027fc:	7a6a      	ldrb	r2, [r5, #9]
				      lll->access_addr[0];
 10027fe:	7a2b      	ldrb	r3, [r5, #8]
			u16_t aa_ms = ((u16_t)lll->access_addr[3] << 8) |
 1002800:	f895 e00b 	ldrb.w	lr, [r5, #11]
				      lll->access_addr[2];
 1002804:	f895 c00a 	ldrb.w	ip, [r5, #10]
			u16_t aa_ls = ((u16_t)lll->access_addr[1] << 8) |
 1002808:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			lll->data_chan_sel = 1;
 100280c:	f895 2021 	ldrb.w	r2, [r5, #33]	; 0x21
			u16_t aa_ms = ((u16_t)lll->access_addr[3] << 8) |
 1002810:	ea4c 2c0e 	orr.w	ip, ip, lr, lsl #8
			lll->data_chan_id = aa_ms ^ aa_ls;
 1002814:	ea83 030c 	eor.w	r3, r3, ip
			lll->data_chan_sel = 1;
 1002818:	f042 0240 	orr.w	r2, r2, #64	; 0x40
			lll->data_chan_id = aa_ms ^ aa_ls;
 100281c:	846b      	strh	r3, [r5, #34]	; 0x22
			lll->data_chan_sel = 1;
 100281e:	f885 2021 	strb.w	r2, [r5, #33]	; 0x21
			cs->csa = 0x01;
 1002822:	f887 1020 	strb.w	r1, [r7, #32]
	ll_rx_put(link, rx);
 1002826:	4639      	mov	r1, r7
 1002828:	f007 fbf0 	bl	100a00c <ll_rx_put>
	conn->evt.ticks_active_to_start = 0U;
 100282c:	2700      	movs	r7, #0
	ll_rx_sched();
 100282e:	f007 fbf7 	bl	100a020 <ll_rx_sched>
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 1002832:	a365      	add	r3, pc, #404	; (adr r3, 10029c8 <ull_slave_setup+0x3e8>)
 1002834:	e9d3 2300 	ldrd	r2, r3, [r3]
	conn->evt.ticks_xtal_to_start =
 1002838:	f04f 0c31 	mov.w	ip, #49	; 0x31
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 100283c:	f8db a010 	ldr.w	sl, [fp, #16]
 1002840:	4966      	ldr	r1, [pc, #408]	; (10029dc <ull_slave_setup+0x3fc>)
	conn_offset_us += ((u64_t)win_offset + 1) * 1250U;
 1002842:	f240 48e2 	movw	r8, #1250	; 0x4e2
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 1002846:	f20a 4052 	addw	r0, sl, #1106	; 0x452
	conn->evt.ticks_xtal_to_start =
 100284a:	f8c4 c000 	str.w	ip, [r4]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 100284e:	fba0 0101 	umull	r0, r1, r0, r1
	conn->evt.ticks_preempt_to_start =
 1002852:	e9c4 7701 	strd	r7, r7, [r4, #4]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 1002856:	f7fd fc2f 	bl	10000b8 <__aeabi_uldivmod>
	conn_offset_us += ((u64_t)win_offset + 1) * 1250U;
 100285a:	f8bd 2030 	ldrh.w	r2, [sp, #48]	; 0x30
 100285e:	f8db 300c 	ldr.w	r3, [fp, #12]
 1002862:	fb08 8c02 	mla	ip, r8, r2, r8
	conn_interval_us -= lll->slave.window_widening_periodic_us;
 1002866:	6aad      	ldr	r5, [r5, #40]	; 0x28
 1002868:	f5a3 78ae 	sub.w	r8, r3, #348	; 0x15c
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 100286c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
 1002870:	463a      	mov	r2, r7
 1002872:	2102      	movs	r1, #2
	conn->evt.ticks_slot =
 1002874:	60e0      	str	r0, [r4, #12]
	conn_interval_us -= lll->slave.window_widening_periodic_us;
 1002876:	eba8 0a0a 	sub.w	sl, r8, sl
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
 100287a:	2001      	movs	r0, #1
	conn_offset_us -= ftr->us_radio_rdy;
 100287c:	eb0c 080a 	add.w	r8, ip, sl
	conn_interval_us -= lll->slave.window_widening_periodic_us;
 1002880:	1b76      	subs	r6, r6, r5
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
 1002882:	f003 fa71 	bl	1005d68 <mayfly_enable>
	ticker_id_adv = TICKER_ID_ADV_BASE + ull_adv_handle_get(adv);
 1002886:	9d0a      	ldr	r5, [sp, #40]	; 0x28
 1002888:	4628      	mov	r0, r5
 100288a:	f008 f94b 	bl	100ab24 <ull_adv_handle_get>
 100288e:	1c82      	adds	r2, r0, #2
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 1002890:	2101      	movs	r1, #1
 1002892:	4638      	mov	r0, r7
 1002894:	4b52      	ldr	r3, [pc, #328]	; (10029e0 <ull_slave_setup+0x400>)
 1002896:	b2d2      	uxtb	r2, r2
 1002898:	9500      	str	r5, [sp, #0]
 100289a:	f004 fccb 	bl	1007234 <ticker_stop>
}
#endif /* CONFIG_BT_CTLR_LE_ENC */

static void ticker_op_stop_adv_cb(u32_t status, void *param)
{
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
 100289e:	2801      	cmp	r0, #1
 10028a0:	f000 8083 	beq.w	10029aa <ull_slave_setup+0x3ca>
	if (adv->lll.is_hdcd) {
 10028a4:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 10028a6:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
 10028aa:	07db      	lsls	r3, r3, #31
 10028ac:	d475      	bmi.n	100299a <ull_slave_setup+0x3ba>
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
 10028ae:	4620      	mov	r0, r4
 10028b0:	f008 fe46 	bl	100b540 <ll_conn_handle_get>
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
 10028b4:	a344      	add	r3, pc, #272	; (adr r3, 10029c8 <ull_slave_setup+0x3e8>)
 10028b6:	e9d3 2300 	ldrd	r2, r3, [r3]
 10028ba:	4948      	ldr	r1, [pc, #288]	; (10029dc <ull_slave_setup+0x3fc>)
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
 10028bc:	4605      	mov	r5, r0
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
 10028be:	fba6 6701 	umull	r6, r7, r6, r1
 10028c2:	4630      	mov	r0, r6
 10028c4:	4639      	mov	r1, r7
 10028c6:	f7fd fbf7 	bl	10000b8 <__aeabi_uldivmod>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 10028ca:	f240 1121 	movw	r1, #289	; 0x121
				     HAL_TICKER_REMAINDER(conn_interval_us),
 10028ce:	f04f 0c07 	mov.w	ip, #7
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 10028d2:	f04f 0a00 	mov.w	sl, #0
				     HAL_TICKER_REMAINDER(conn_interval_us),
 10028d6:	4a43      	ldr	r2, [pc, #268]	; (10029e4 <ull_slave_setup+0x404>)
 10028d8:	f020 497f 	bic.w	r9, r0, #4278190080	; 0xff000000
 10028dc:	fba9 2302 	umull	r2, r3, r9, r2
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 10028e0:	9108      	str	r1, [sp, #32]
 10028e2:	4941      	ldr	r1, [pc, #260]	; (10029e8 <ull_slave_setup+0x408>)
 10028e4:	9406      	str	r4, [sp, #24]
				     HAL_TICKER_REMAINDER(conn_interval_us),
 10028e6:	fb0c 3309 	mla	r3, ip, r9, r3
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 10028ea:	f8db c008 	ldr.w	ip, [fp, #8]
 10028ee:	9107      	str	r1, [sp, #28]
 10028f0:	493e      	ldr	r1, [pc, #248]	; (10029ec <ull_slave_setup+0x40c>)
				     HAL_TICKER_REMAINDER(conn_interval_us),
 10028f2:	1ab0      	subs	r0, r6, r2
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 10028f4:	9105      	str	r1, [sp, #20]
 10028f6:	68e4      	ldr	r4, [r4, #12]
				     HAL_TICKER_REMAINDER(conn_interval_us),
 10028f8:	eb67 0103 	sbc.w	r1, r7, r3
 10028fc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 1002900:	2300      	movs	r3, #0
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1002902:	f1ac 0631 	sub.w	r6, ip, #49	; 0x31
 1002906:	e9cd a403 	strd	sl, r4, [sp, #12]
				     HAL_TICKER_REMAINDER(conn_interval_us),
 100290a:	f7fd fbd5 	bl	10000b8 <__aeabi_uldivmod>
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
 100290e:	a32e      	add	r3, pc, #184	; (adr r3, 10029c8 <ull_slave_setup+0x3e8>)
 1002910:	e9d3 2300 	ldrd	r2, r3, [r3]
				     HAL_TICKER_REMAINDER(conn_interval_us),
 1002914:	4604      	mov	r4, r0
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
 1002916:	4931      	ldr	r1, [pc, #196]	; (10029dc <ull_slave_setup+0x3fc>)
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1002918:	e9cd 9401 	strd	r9, r4, [sp, #4]
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
 100291c:	fba8 0101 	umull	r0, r1, r8, r1
 1002920:	f7fd fbca 	bl	10000b8 <__aeabi_uldivmod>
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
 1002924:	3505      	adds	r5, #5
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1002926:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 100292a:	b2ed      	uxtb	r5, r5
 100292c:	4633      	mov	r3, r6
 100292e:	9000      	str	r0, [sp, #0]
 1002930:	462a      	mov	r2, r5
 1002932:	4650      	mov	r0, sl
 1002934:	2101      	movs	r1, #1
 1002936:	f004 fc17 	bl	1007168 <ticker_start>
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 100293a:	f030 0302 	bics.w	r3, r0, #2
 100293e:	d004      	beq.n	100294a <ull_slave_setup+0x36a>
 1002940:	f44f 7191 	mov.w	r1, #290	; 0x122
 1002944:	482a      	ldr	r0, [pc, #168]	; (10029f0 <ull_slave_setup+0x410>)
 1002946:	f000 fe1f 	bl	1003588 <bt_ctlr_assert_handle>
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1);
 100294a:	2201      	movs	r2, #1
 100294c:	2102      	movs	r1, #2
 100294e:	4610      	mov	r0, r2
 1002950:	f003 fa0a 	bl	1005d68 <mayfly_enable>
}
 1002954:	b013      	add	sp, #76	; 0x4c
 1002956:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		memcpy(&cc->local_rpa[0], &pdu_adv->connect_ind.adv_addr[0],
 100295a:	f109 0128 	add.w	r1, r9, #40	; 0x28
 100295e:	f109 002f 	add.w	r0, r9, #47	; 0x2f
 1002962:	f013 ffa9 	bl	10168b8 <memcpy>
	if (rl_idx != FILTER_IDX_NONE) {
 1002966:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
 100296a:	f47f af0f 	bne.w	100278c <ull_slave_setup+0x1ac>
		memset(&cc->peer_rpa[0], 0x0, BDADDR_SIZE);
 100296e:	2206      	movs	r2, #6
 1002970:	2100      	movs	r1, #0
 1002972:	f109 0029 	add.w	r0, r9, #41	; 0x29
 1002976:	f013 ffca 	bl	101690e <memset>
		cc->peer_addr_type = peer_addr_type;
 100297a:	f89d 303c 	ldrb.w	r3, [sp, #60]	; 0x3c
		memcpy(cc->peer_addr, peer_addr, BDADDR_SIZE);
 100297e:	2206      	movs	r2, #6
		cc->peer_addr_type = peer_addr_type;
 1002980:	f889 3022 	strb.w	r3, [r9, #34]	; 0x22
		memcpy(cc->peer_addr, peer_addr, BDADDR_SIZE);
 1002984:	a910      	add	r1, sp, #64	; 0x40
 1002986:	f109 0023 	add.w	r0, r9, #35	; 0x23
 100298a:	f013 ff95 	bl	10168b8 <memcpy>
 100298e:	e70e      	b.n	10027ae <ull_slave_setup+0x1ce>
			cs->csa = 0x00;
 1002990:	f89d 3038 	ldrb.w	r3, [sp, #56]	; 0x38
 1002994:	f887 3020 	strb.w	r3, [r7, #32]
 1002998:	e745      	b.n	1002826 <ull_slave_setup+0x246>
		ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
 100299a:	2300      	movs	r3, #0
 100299c:	2201      	movs	r2, #1
 100299e:	4618      	mov	r0, r3
 10029a0:	4611      	mov	r1, r2
 10029a2:	9300      	str	r3, [sp, #0]
 10029a4:	f004 fc46 	bl	1007234 <ticker_stop>
 10029a8:	e781      	b.n	10028ae <ull_slave_setup+0x2ce>
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
 10029aa:	f007 fbc5 	bl	100a138 <ull_disable_mark_get>
 10029ae:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 10029b0:	4283      	cmp	r3, r0
 10029b2:	f43f af77 	beq.w	10028a4 <ull_slave_setup+0x2c4>
 10029b6:	f44f 71de 	mov.w	r1, #444	; 0x1bc
 10029ba:	480d      	ldr	r0, [pc, #52]	; (10029f0 <ull_slave_setup+0x410>)
 10029bc:	f000 fde4 	bl	1003588 <bt_ctlr_assert_handle>
		  param == ull_disable_mark_get());
}
 10029c0:	e770      	b.n	10028a4 <ull_slave_setup+0x2c4>
 10029c2:	bf00      	nop
 10029c4:	f3af 8000 	nop.w
 10029c8:	1afd498d 	.word	0x1afd498d
 10029cc:	00000007 	.word	0x00000007
 10029d0:	431bde83 	.word	0x431bde83
 10029d4:	01c9c37f 	.word	0x01c9c37f
 10029d8:	026259ff 	.word	0x026259ff
 10029dc:	3b9aca00 	.word	0x3b9aca00
 10029e0:	0100e0b1 	.word	0x0100e0b1
 10029e4:	1afd498d 	.word	0x1afd498d
 10029e8:	0100e021 	.word	0x0100e021
 10029ec:	0100e035 	.word	0x0100e035
 10029f0:	01018844 	.word	0x01018844
 10029f4:	00000000 	.word	0x00000000

010029f8 <ull_slave_done>:
{
 10029f8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	preamble_to_addr_us =
 10029fc:	e9d0 c70c 	ldrd	ip, r7, [r0, #48]	; 0x30
	start_to_address_actual_us =
 1002a00:	f8d0 802c 	ldr.w	r8, [r0, #44]	; 0x2c
				       window_widening_event_us +
 1002a04:	eb0c 0407 	add.w	r4, ip, r7
	start_to_address_expected_us = EVENT_JITTER_US +
 1002a08:	3430      	adds	r4, #48	; 0x30
	if (start_to_address_actual_us <= start_to_address_expected_us) {
 1002a0a:	45a0      	cmp	r8, r4
{
 1002a0c:	460e      	mov	r6, r1
 1002a0e:	4615      	mov	r5, r2
	if (start_to_address_actual_us <= start_to_address_expected_us) {
 1002a10:	d818      	bhi.n	1002a44 <ull_slave_done+0x4c>
			HAL_TICKER_US_TO_TICKS(window_widening_event_us);
 1002a12:	a319      	add	r3, pc, #100	; (adr r3, 1002a78 <ull_slave_done+0x80>)
 1002a14:	e9d3 2300 	ldrd	r2, r3, [r3]
 1002a18:	4f19      	ldr	r7, [pc, #100]	; (1002a80 <ull_slave_done+0x88>)
			HAL_TICKER_US_TO_TICKS((start_to_address_expected_us -
 1002a1a:	eba4 0408 	sub.w	r4, r4, r8
			HAL_TICKER_US_TO_TICKS(window_widening_event_us);
 1002a1e:	fbac 0107 	umull	r0, r1, ip, r7
 1002a22:	f7fd fb49 	bl	10000b8 <__aeabi_uldivmod>
			HAL_TICKER_US_TO_TICKS((start_to_address_expected_us -
 1002a26:	a314      	add	r3, pc, #80	; (adr r3, 1002a78 <ull_slave_done+0x80>)
 1002a28:	e9d3 2300 	ldrd	r2, r3, [r3]
			HAL_TICKER_US_TO_TICKS(window_widening_event_us);
 1002a2c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_plus =
 1002a30:	6030      	str	r0, [r6, #0]
			HAL_TICKER_US_TO_TICKS((start_to_address_expected_us -
 1002a32:	fba4 0107 	umull	r0, r1, r4, r7
 1002a36:	f7fd fb3f 	bl	10000b8 <__aeabi_uldivmod>
 1002a3a:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_minus =
 1002a3e:	6028      	str	r0, [r5, #0]
}
 1002a40:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			HAL_TICKER_US_TO_TICKS(start_to_address_actual_us);
 1002a44:	4c0e      	ldr	r4, [pc, #56]	; (1002a80 <ull_slave_done+0x88>)
 1002a46:	a30c      	add	r3, pc, #48	; (adr r3, 1002a78 <ull_slave_done+0x80>)
 1002a48:	e9d3 2300 	ldrd	r2, r3, [r3]
 1002a4c:	fba8 0104 	umull	r0, r1, r8, r4
 1002a50:	f7fd fb32 	bl	10000b8 <__aeabi_uldivmod>
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
 1002a54:	a308      	add	r3, pc, #32	; (adr r3, 1002a78 <ull_slave_done+0x80>)
 1002a56:	e9d3 2300 	ldrd	r2, r3, [r3]
			HAL_TICKER_US_TO_TICKS(start_to_address_actual_us);
 1002a5a:	f020 417f 	bic.w	r1, r0, #4278190080	; 0xff000000
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
 1002a5e:	f107 0030 	add.w	r0, r7, #48	; 0x30
		*ticks_drift_plus =
 1002a62:	6031      	str	r1, [r6, #0]
			HAL_TICKER_US_TO_TICKS(EVENT_JITTER_US +
 1002a64:	fba0 0104 	umull	r0, r1, r0, r4
 1002a68:	f7fd fb26 	bl	10000b8 <__aeabi_uldivmod>
 1002a6c:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
		*ticks_drift_minus =
 1002a70:	6028      	str	r0, [r5, #0]
}
 1002a72:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 1002a76:	bf00      	nop
 1002a78:	1afd498d 	.word	0x1afd498d
 1002a7c:	00000007 	.word	0x00000007
 1002a80:	3b9aca00 	.word	0x3b9aca00
 1002a84:	00000000 	.word	0x00000000

01002a88 <ull_master_setup>:
}
#endif /* CONFIG_BT_CTLR_LE_ENC */

void ull_master_setup(memq_link_t *link, struct node_rx_hdr *rx,
		      struct node_rx_ftr *ftr, struct lll_conn *lll)
{
 1002a88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct pdu_adv *pdu_tx;
	u8_t peer_addr_type;
	u32_t ticker_status;
	u8_t chan_sel;

	((struct lll_scan *)ftr->param)->conn = NULL;
 1002a8c:	f04f 0b00 	mov.w	fp, #0
{
 1002a90:	460c      	mov	r4, r1
 1002a92:	461d      	mov	r5, r3
 1002a94:	4616      	mov	r6, r2
	scan = ((struct lll_scan *)ftr->param)->hdr.parent;
	conn = lll->hdr.parent;

	pdu_tx = (void *)((struct node_rx_pdu *)rx)->pdu;

	peer_addr_type = pdu_tx->rx_addr;
 1002a96:	f891 7020 	ldrb.w	r7, [r1, #32]
	((struct lll_scan *)ftr->param)->conn = NULL;
 1002a9a:	6813      	ldr	r3, [r2, #0]
{
 1002a9c:	b08f      	sub	sp, #60	; 0x3c
	((struct lll_scan *)ftr->param)->conn = NULL;
 1002a9e:	f8c3 b008 	str.w	fp, [r3, #8]
	memcpy(peer_addr, &pdu_tx->connect_ind.adv_addr[0], BDADDR_SIZE);
 1002aa2:	2206      	movs	r2, #6
	scan = ((struct lll_scan *)ftr->param)->hdr.parent;
 1002aa4:	f8d3 a000 	ldr.w	sl, [r3]
	memcpy(peer_addr, &pdu_tx->connect_ind.adv_addr[0], BDADDR_SIZE);
 1002aa8:	3128      	adds	r1, #40	; 0x28
	peer_addr_type = pdu_tx->rx_addr;
 1002aaa:	f3c7 13c0 	ubfx	r3, r7, #7, #1
{
 1002aae:	4681      	mov	r9, r0
	memcpy(peer_addr, &pdu_tx->connect_ind.adv_addr[0], BDADDR_SIZE);
 1002ab0:	a80c      	add	r0, sp, #48	; 0x30
	peer_addr_type = pdu_tx->rx_addr;
 1002ab2:	f88d 302c 	strb.w	r3, [sp, #44]	; 0x2c
	conn = lll->hdr.parent;
 1002ab6:	682f      	ldr	r7, [r5, #0]
	memcpy(peer_addr, &pdu_tx->connect_ind.adv_addr[0], BDADDR_SIZE);
 1002ab8:	f013 fefe 	bl	10168b8 <memcpy>

	/* This is the chan sel bit from the received adv pdu */
	chan_sel = pdu_tx->chan_sel;
 1002abc:	f894 8020 	ldrb.w	r8, [r4, #32]

	cc = (void *)pdu_tx;
	cc->status = 0U;
 1002ac0:	f8a4 b020 	strh.w	fp, [r4, #32]
	cc->role = 0U;

#if defined(CONFIG_BT_CTLR_PRIVACY)
	u8_t rl_idx = ftr->rl_idx;

	if (ftr->lrpa_used) {
 1002ac4:	7d71      	ldrb	r1, [r6, #21]
	chan_sel = pdu_tx->chan_sel;
 1002ac6:	f3c8 1340 	ubfx	r3, r8, #5, #1
	if (ftr->lrpa_used) {
 1002aca:	f011 0101 	ands.w	r1, r1, #1
	chan_sel = pdu_tx->chan_sel;
 1002ace:	4698      	mov	r8, r3
		memcpy(&cc->local_rpa[0], &pdu_tx->connect_ind.init_addr[0],
 1002ad0:	f04f 0206 	mov.w	r2, #6
	u8_t rl_idx = ftr->rl_idx;
 1002ad4:	f896 b016 	ldrb.w	fp, [r6, #22]
	chan_sel = pdu_tx->chan_sel;
 1002ad8:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
	if (ftr->lrpa_used) {
 1002adc:	f000 80e1 	beq.w	1002ca2 <ull_master_setup+0x21a>
		memcpy(&cc->local_rpa[0], &pdu_tx->connect_ind.init_addr[0],
 1002ae0:	f104 0122 	add.w	r1, r4, #34	; 0x22
 1002ae4:	f104 002f 	add.w	r0, r4, #47	; 0x2f
 1002ae8:	f013 fee6 	bl	10168b8 <memcpy>
		       BDADDR_SIZE);
	} else {
		memset(&cc->local_rpa[0], 0x0, BDADDR_SIZE);
	}

	if (rl_idx != FILTER_IDX_NONE) {
 1002aec:	f1bb 0fff 	cmp.w	fp, #255	; 0xff
 1002af0:	f000 80df 	beq.w	1002cb2 <ull_master_setup+0x22a>
		/* Store identity address */
		ll_rl_id_addr_get(rl_idx, &cc->peer_addr_type,
 1002af4:	4658      	mov	r0, fp
 1002af6:	f104 0223 	add.w	r2, r4, #35	; 0x23
 1002afa:	f104 0122 	add.w	r1, r4, #34	; 0x22
 1002afe:	f00c f8a9 	bl	100ec54 <ll_rl_id_addr_get>
				  &cc->peer_addr[0]);
		/* Mark it as identity address from RPA (0x02, 0x03) */
		cc->peer_addr_type += 2;
 1002b02:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22

		/* Store peer RPA */
		memcpy(&cc->peer_rpa[0], &peer_addr[0], BDADDR_SIZE);
 1002b06:	2206      	movs	r2, #6
		cc->peer_addr_type += 2;
 1002b08:	3302      	adds	r3, #2
		memcpy(&cc->peer_rpa[0], &peer_addr[0], BDADDR_SIZE);
 1002b0a:	a90c      	add	r1, sp, #48	; 0x30
		cc->peer_addr_type += 2;
 1002b0c:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
		memcpy(&cc->peer_rpa[0], &peer_addr[0], BDADDR_SIZE);
 1002b10:	f104 0029 	add.w	r0, r4, #41	; 0x29
 1002b14:	f013 fed0 	bl	10168b8 <memcpy>
#endif /* CONFIG_BT_CTLR_PRIVACY */
		cc->peer_addr_type = peer_addr_type;
		memcpy(cc->peer_addr, &peer_addr[0], BDADDR_SIZE);
	}

	cc->interval = lll->interval;
 1002b18:	8a6b      	ldrh	r3, [r5, #18]
	cc->latency = lll->latency;
 1002b1a:	8aaa      	ldrh	r2, [r5, #20]
	cc->interval = lll->interval;
 1002b1c:	86e3      	strh	r3, [r4, #54]	; 0x36
	cc->timeout = scan->lll.conn_timeout;
 1002b1e:	f8ba 3030 	ldrh.w	r3, [sl, #48]	; 0x30
	cc->latency = lll->latency;
 1002b22:	8722      	strh	r2, [r4, #56]	; 0x38
	cc->timeout = scan->lll.conn_timeout;
 1002b24:	8763      	strh	r3, [r4, #58]	; 0x3a
	cc->sca = lll_conn_sca_local_get();
 1002b26:	f00e f9df 	bl	1010ee8 <lll_conn_sca_local_get>
 1002b2a:	f884 003c 	strb.w	r0, [r4, #60]	; 0x3c

	lll->handle = ll_conn_handle_get(conn);
 1002b2e:	4638      	mov	r0, r7
 1002b30:	f008 fd06 	bl	100b540 <ll_conn_handle_get>
 1002b34:	4603      	mov	r3, r0
		 * rx node.
		 */
		rx_csa = (void *)ftr->extra;

		/* Enqueue the connection event */
		ll_rx_put(link, rx);
 1002b36:	4621      	mov	r1, r4
	lll->handle = ll_conn_handle_get(conn);
 1002b38:	822b      	strh	r3, [r5, #16]
		ll_rx_put(link, rx);
 1002b3a:	4648      	mov	r0, r9
	rx->handle = lll->handle;
 1002b3c:	80e3      	strh	r3, [r4, #6]
		rx_csa = (void *)ftr->extra;
 1002b3e:	6874      	ldr	r4, [r6, #4]
		ll_rx_put(link, rx);
 1002b40:	f007 fa64 	bl	100a00c <ll_rx_put>
		/* use the rx node for CSA event */
		rx = (void *)rx_csa;
		link = rx->link;

		rx->handle = lll->handle;
		rx->type = NODE_RX_TYPE_CHAN_SEL_ALGO;
 1002b44:	220d      	movs	r2, #13
		rx->handle = lll->handle;
 1002b46:	8a2b      	ldrh	r3, [r5, #16]
		link = rx->link;
 1002b48:	6820      	ldr	r0, [r4, #0]
		rx->type = NODE_RX_TYPE_CHAN_SEL_ALGO;
 1002b4a:	7122      	strb	r2, [r4, #4]
		rx->handle = lll->handle;
 1002b4c:	80e3      	strh	r3, [r4, #6]

		cs = (void *)rx_csa->pdu;

		if (chan_sel) {
 1002b4e:	f1b8 0f00 	cmp.w	r8, #0
 1002b52:	f000 80a1 	beq.w	1002c98 <ull_master_setup+0x210>
				      lll->access_addr[2];

			lll->data_chan_sel = 1;
			lll->data_chan_id = aa_ms ^ aa_ls;

			cs->csa = 0x01;
 1002b56:	f04f 0c01 	mov.w	ip, #1
			u16_t aa_ls = ((u16_t)lll->access_addr[1] << 8) |
 1002b5a:	7a6a      	ldrb	r2, [r5, #9]
				      lll->access_addr[0];
 1002b5c:	7a2b      	ldrb	r3, [r5, #8]
			u16_t aa_ms = ((u16_t)lll->access_addr[3] << 8) |
 1002b5e:	f895 e00b 	ldrb.w	lr, [r5, #11]
				      lll->access_addr[2];
 1002b62:	7aa9      	ldrb	r1, [r5, #10]
			u16_t aa_ls = ((u16_t)lll->access_addr[1] << 8) |
 1002b64:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
			lll->data_chan_sel = 1;
 1002b68:	f895 2021 	ldrb.w	r2, [r5, #33]	; 0x21
			u16_t aa_ms = ((u16_t)lll->access_addr[3] << 8) |
 1002b6c:	ea41 210e 	orr.w	r1, r1, lr, lsl #8
			lll->data_chan_id = aa_ms ^ aa_ls;
 1002b70:	404b      	eors	r3, r1
			lll->data_chan_sel = 1;
 1002b72:	f042 0240 	orr.w	r2, r2, #64	; 0x40
			lll->data_chan_id = aa_ms ^ aa_ls;
 1002b76:	846b      	strh	r3, [r5, #34]	; 0x22
			lll->data_chan_sel = 1;
 1002b78:	f885 2021 	strb.w	r2, [r5, #33]	; 0x21
			cs->csa = 0x01;
 1002b7c:	f884 c020 	strb.w	ip, [r4, #32]
		} else {
			cs->csa = 0x00;
		}
	}

	ll_rx_put(link, rx);
 1002b80:	4621      	mov	r1, r4
 1002b82:	f007 fa43 	bl	100a00c <ll_rx_put>
	ll_rx_sched();

	/* TODO: active_to_start feature port */
	conn->evt.ticks_active_to_start = 0U;
 1002b86:	2400      	movs	r4, #0
	ll_rx_sched();
 1002b88:	f007 fa4a 	bl	100a020 <ll_rx_sched>
	conn->evt.ticks_xtal_to_start =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_XTAL_US);
	conn->evt.ticks_preempt_to_start =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_PREEMPT_MIN_US);
	conn->evt.ticks_slot =
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 1002b8c:	a352      	add	r3, pc, #328	; (adr r3, 1002cd8 <ull_master_setup+0x250>)
 1002b8e:	e9d3 2300 	ldrd	r2, r3, [r3]
	conn->evt.ticks_xtal_to_start =
 1002b92:	f04f 0c31 	mov.w	ip, #49	; 0x31
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 1002b96:	f8d6 9010 	ldr.w	r9, [r6, #16]
 1002b9a:	f8df b154 	ldr.w	fp, [pc, #340]	; 1002cf0 <ull_master_setup+0x268>
 1002b9e:	f209 4052 	addw	r0, r9, #1106	; 0x452
	conn->evt.ticks_xtal_to_start =
 1002ba2:	f8c7 c000 	str.w	ip, [r7]
	conn->evt.ticks_preempt_to_start =
 1002ba6:	e9c7 4401 	strd	r4, r4, [r7, #4]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 1002baa:	fba0 010b 	umull	r0, r1, r0, fp
 1002bae:	f7fd fa83 	bl	10000b8 <__aeabi_uldivmod>
		ticks_slot_overhead = ticks_slot_offset;
	} else {
		ticks_slot_overhead = 0U;
	}

	conn_interval_us = lll->interval * 1250;
 1002bb2:	f240 48e2 	movw	r8, #1250	; 0x4e2
 1002bb6:	f8b5 c012 	ldrh.w	ip, [r5, #18]
	conn_offset_us = ftr->us_radio_end;
 1002bba:	68f3      	ldr	r3, [r6, #12]
		HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US +
 1002bbc:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	/* disable ticker job, in order to chain stop and start to avoid RTC
	 * being stopped if no tickers active.
	 */
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
 1002bc0:	4622      	mov	r2, r4
 1002bc2:	2102      	movs	r1, #2
	conn->evt.ticks_slot =
 1002bc4:	60f8      	str	r0, [r7, #12]
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
 1002bc6:	2001      	movs	r0, #1
	conn_interval_us = lll->interval * 1250;
 1002bc8:	fb08 f80c 	mul.w	r8, r8, ip
	conn_offset_us -= EVENT_OVERHEAD_START_US;
 1002bcc:	f5a3 7587 	sub.w	r5, r3, #270	; 0x10e
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 0);
 1002bd0:	f003 f8ca 	bl	1005d68 <mayfly_enable>
#endif

	/* Stop Scanner */
	ticker_id_scan = TICKER_ID_SCAN_BASE + ull_scan_handle_get(scan);
 1002bd4:	4650      	mov	r0, sl
 1002bd6:	f008 f8e5 	bl	100ada4 <ull_scan_handle_get>
 1002bda:	1d02      	adds	r2, r0, #4
 1002bdc:	b2d2      	uxtb	r2, r2
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 1002bde:	2101      	movs	r1, #1
 1002be0:	4b3f      	ldr	r3, [pc, #252]	; (1002ce0 <ull_master_setup+0x258>)
				    TICKER_USER_ID_ULL_HIGH,
				    ticker_id_scan, ticker_op_stop_scan_cb,
				    (void *)(u32_t)ticker_id_scan);
 1002be2:	9200      	str	r2, [sp, #0]
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 1002be4:	4620      	mov	r0, r4
 1002be6:	f004 fb25 	bl	1007234 <ticker_stop>

	/* Scanner stop can expire while here in this ISR.
	 * Deferred attempt to stop can fail as it would have
	 * expired, hence ignore failure.
	 */
	ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
 1002bea:	4623      	mov	r3, r4
 1002bec:	2203      	movs	r2, #3
 1002bee:	2101      	movs	r1, #1
 1002bf0:	4620      	mov	r0, r4
 1002bf2:	9400      	str	r4, [sp, #0]
 1002bf4:	f004 fb1e 	bl	1007234 <ticker_stop>
		    TICKER_ID_SCAN_STOP, NULL, NULL);

	/* Start master */
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
 1002bf8:	4638      	mov	r0, r7
 1002bfa:	f008 fca1 	bl	100b540 <ll_conn_handle_get>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1002bfe:	f44f 7119 	mov.w	r1, #612	; 0x264
 1002c02:	4a38      	ldr	r2, [pc, #224]	; (1002ce4 <ull_master_setup+0x25c>)
 1002c04:	4b38      	ldr	r3, [pc, #224]	; (1002ce8 <ull_master_setup+0x260>)
 1002c06:	e9cd 2107 	strd	r2, r1, [sp, #28]
	conn_offset_us -= ftr->us_radio_rdy;
 1002c0a:	eba5 0509 	sub.w	r5, r5, r9
				     TICKER_USER_ID_ULL_HIGH,
				     ticker_id_conn,
				     ftr->ticks_anchor - ticks_slot_offset,
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
 1002c0e:	fb88 890b 	smull	r8, r9, r8, fp
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1002c12:	9706      	str	r7, [sp, #24]
 1002c14:	9305      	str	r3, [sp, #20]
 1002c16:	68fb      	ldr	r3, [r7, #12]
 1002c18:	68b6      	ldr	r6, [r6, #8]
	ticker_id_conn = TICKER_ID_CONN_BASE + ll_conn_handle_get(conn);
 1002c1a:	1d47      	adds	r7, r0, #5
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1002c1c:	9304      	str	r3, [sp, #16]
				     HAL_TICKER_REMAINDER(conn_interval_us),
 1002c1e:	4640      	mov	r0, r8
 1002c20:	a32d      	add	r3, pc, #180	; (adr r3, 1002cd8 <ull_master_setup+0x250>)
 1002c22:	e9d3 2300 	ldrd	r2, r3, [r3]
 1002c26:	4649      	mov	r1, r9
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1002c28:	9403      	str	r4, [sp, #12]
				     HAL_TICKER_REMAINDER(conn_interval_us),
 1002c2a:	f7fd fa45 	bl	10000b8 <__aeabi_uldivmod>
 1002c2e:	4610      	mov	r0, r2
 1002c30:	4619      	mov	r1, r3
 1002c32:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 1002c36:	2300      	movs	r3, #0
 1002c38:	f7fd fa3e 	bl	10000b8 <__aeabi_uldivmod>
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
 1002c3c:	a326      	add	r3, pc, #152	; (adr r3, 1002cd8 <ull_master_setup+0x250>)
 1002c3e:	e9d3 2300 	ldrd	r2, r3, [r3]
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1002c42:	f1a6 0a31 	sub.w	sl, r6, #49	; 0x31
				     HAL_TICKER_REMAINDER(conn_interval_us),
 1002c46:	4606      	mov	r6, r0
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
 1002c48:	4649      	mov	r1, r9
 1002c4a:	4640      	mov	r0, r8
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1002c4c:	9602      	str	r6, [sp, #8]
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
 1002c4e:	f7fd fa33 	bl	10000b8 <__aeabi_uldivmod>
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
 1002c52:	a321      	add	r3, pc, #132	; (adr r3, 1002cd8 <ull_master_setup+0x250>)
 1002c54:	e9d3 2300 	ldrd	r2, r3, [r3]
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
 1002c58:	4606      	mov	r6, r0
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
 1002c5a:	fba5 010b 	umull	r0, r1, r5, fp
				     HAL_TICKER_US_TO_TICKS(conn_interval_us),
 1002c5e:	9601      	str	r6, [sp, #4]
				     HAL_TICKER_US_TO_TICKS(conn_offset_us),
 1002c60:	f7fd fa2a 	bl	10000b8 <__aeabi_uldivmod>
	ticker_status = ticker_start(TICKER_INSTANCE_ID_CTLR,
 1002c64:	b2ff      	uxtb	r7, r7
 1002c66:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 1002c6a:	4653      	mov	r3, sl
 1002c6c:	9000      	str	r0, [sp, #0]
 1002c6e:	463a      	mov	r2, r7
 1002c70:	4620      	mov	r0, r4
 1002c72:	2101      	movs	r1, #1
 1002c74:	f004 fa78 	bl	1007168 <ticker_start>
				     TICKER_NULL_LAZY,
				     (conn->evt.ticks_slot +
				      ticks_slot_overhead),
				     ull_master_ticker_cb, conn, ticker_op_cb,
				     (void *)__LINE__);
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 1002c78:	f030 0302 	bics.w	r3, r0, #2
 1002c7c:	d004      	beq.n	1002c88 <ull_master_setup+0x200>
 1002c7e:	f240 2165 	movw	r1, #613	; 0x265
 1002c82:	481a      	ldr	r0, [pc, #104]	; (1002cec <ull_master_setup+0x264>)
 1002c84:	f000 fc80 	bl	1003588 <bt_ctlr_assert_handle>

#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	/* enable ticker job, irrespective of disabled in this function so
	 * first connection event can be scheduled as soon as possible.
	 */
	mayfly_enable(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_ULL_LOW, 1);
 1002c88:	2201      	movs	r2, #1
 1002c8a:	2102      	movs	r1, #2
 1002c8c:	4610      	mov	r0, r2
 1002c8e:	f003 f86b 	bl	1005d68 <mayfly_enable>
#endif
}
 1002c92:	b00f      	add	sp, #60	; 0x3c
 1002c94:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			cs->csa = 0x00;
 1002c98:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
 1002c9c:	f884 3020 	strb.w	r3, [r4, #32]
 1002ca0:	e76e      	b.n	1002b80 <ull_master_setup+0xf8>
		memset(&cc->local_rpa[0], 0x0, BDADDR_SIZE);
 1002ca2:	f104 002f 	add.w	r0, r4, #47	; 0x2f
 1002ca6:	f013 fe32 	bl	101690e <memset>
	if (rl_idx != FILTER_IDX_NONE) {
 1002caa:	f1bb 0fff 	cmp.w	fp, #255	; 0xff
 1002cae:	f47f af21 	bne.w	1002af4 <ull_master_setup+0x6c>
		memset(&cc->peer_rpa[0], 0x0, BDADDR_SIZE);
 1002cb2:	2206      	movs	r2, #6
 1002cb4:	2100      	movs	r1, #0
 1002cb6:	f104 0029 	add.w	r0, r4, #41	; 0x29
 1002cba:	f013 fe28 	bl	101690e <memset>
		cc->peer_addr_type = peer_addr_type;
 1002cbe:	f89d 302c 	ldrb.w	r3, [sp, #44]	; 0x2c
		memcpy(cc->peer_addr, &peer_addr[0], BDADDR_SIZE);
 1002cc2:	2206      	movs	r2, #6
		cc->peer_addr_type = peer_addr_type;
 1002cc4:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
		memcpy(cc->peer_addr, &peer_addr[0], BDADDR_SIZE);
 1002cc8:	a90c      	add	r1, sp, #48	; 0x30
 1002cca:	f104 0023 	add.w	r0, r4, #35	; 0x23
 1002cce:	f013 fdf3 	bl	10168b8 <memcpy>
 1002cd2:	e721      	b.n	1002b18 <ull_master_setup+0x90>
 1002cd4:	f3af 8000 	nop.w
 1002cd8:	1afd498d 	.word	0x1afd498d
 1002cdc:	00000007 	.word	0x00000007
 1002ce0:	0100e16d 	.word	0x0100e16d
 1002ce4:	0100e171 	.word	0x0100e171
 1002ce8:	0100e185 	.word	0x0100e185
 1002cec:	0101889c 	.word	0x0101889c
 1002cf0:	3b9aca00 	.word	0x3b9aca00
 1002cf4:	00000000 	.word	0x00000000

01002cf8 <isr_rx>:

	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
}

static void isr_rx(void *param)
{
 1002cf8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1002cfc:	b083      	sub	sp, #12
 1002cfe:	4604      	mov	r4, r0
	if (IS_ENABLED(CONFIG_BT_CTLR_PROFILE_ISR)) {
		lll_prof_latency_capture();
	}

	/* Read radio status and events */
	trx_done = radio_is_done();
 1002d00:	f00f f8a0 	bl	1011e44 <radio_is_done>
	if (trx_done) {
 1002d04:	f010 0fff 	tst.w	r0, #255	; 0xff
 1002d08:	d112      	bne.n	1002d30 <isr_rx+0x38>
		crc_ok = devmatch_ok = irkmatch_ok = rssi_ready = 0U;
		devmatch_id = irkmatch_id = 0xFF;
	}

	/* Clear radio status and events */
	radio_status_reset();
 1002d0a:	f00f f885 	bl	1011e18 <radio_status_reset>
	radio_tmr_status_reset();
 1002d0e:	f00f f95b 	bl	1011fc8 <radio_tmr_status_reset>
	radio_filter_status_reset();
 1002d12:	f00f f941 	bl	1011f98 <radio_filter_status_reset>
	radio_ar_status_reset();
 1002d16:	f00f fb9b 	bl	1012450 <radio_ar_status_reset>
	radio_rssi_status_reset();
 1002d1a:	f00f f905 	bl	1011f28 <radio_rssi_status_reset>
			return;
		}
	}

isr_rx_do_close:
	radio_isr_set(isr_done, lll);
 1002d1e:	4621      	mov	r1, r4
 1002d20:	48cb      	ldr	r0, [pc, #812]	; (1003050 <isr_rx+0x358>)
 1002d22:	f00e ff65 	bl	1011bf0 <radio_isr_set>
	radio_disable();
}
 1002d26:	b003      	add	sp, #12
 1002d28:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	radio_disable();
 1002d2c:	f00f b85e 	b.w	1011dec <radio_disable>
		crc_ok = radio_crc_is_valid();
 1002d30:	f00f f8a8 	bl	1011e84 <radio_crc_is_valid>
 1002d34:	fa5f f880 	uxtb.w	r8, r0
		devmatch_ok = radio_filter_has_match();
 1002d38:	f00f f936 	bl	1011fa8 <radio_filter_has_match>
 1002d3c:	b2c6      	uxtb	r6, r0
		devmatch_id = radio_filter_match_get();
 1002d3e:	f00f f93d 	bl	1011fbc <radio_filter_match_get>
 1002d42:	4607      	mov	r7, r0
		irkmatch_ok = radio_ar_has_match();
 1002d44:	f00f fb90 	bl	1012468 <radio_ar_has_match>
 1002d48:	b2c5      	uxtb	r5, r0
		irkmatch_id = radio_ar_match_get();
 1002d4a:	f00f fb7b 	bl	1012444 <radio_ar_match_get>
 1002d4e:	4682      	mov	sl, r0
		rssi_ready = radio_rssi_is_ready();
 1002d50:	f00f f8f2 	bl	1011f38 <radio_rssi_is_ready>
 1002d54:	4681      	mov	r9, r0
	radio_status_reset();
 1002d56:	f00f f85f 	bl	1011e18 <radio_status_reset>
	radio_tmr_status_reset();
 1002d5a:	f00f f935 	bl	1011fc8 <radio_tmr_status_reset>
	radio_filter_status_reset();
 1002d5e:	f00f f91b 	bl	1011f98 <radio_filter_status_reset>
	radio_ar_status_reset();
 1002d62:	f00f fb75 	bl	1012450 <radio_ar_status_reset>
	radio_rssi_status_reset();
 1002d66:	f00f f8df 	bl	1011f28 <radio_rssi_status_reset>
	rl_idx = devmatch_ok ?
 1002d6a:	2e00      	cmp	r6, #0
 1002d6c:	f040 80b1 	bne.w	1002ed2 <isr_rx+0x1da>
 1002d70:	2d00      	cmp	r5, #0
 1002d72:	f040 80c0 	bne.w	1002ef6 <isr_rx+0x1fe>
 1002d76:	27ff      	movs	r7, #255	; 0xff
	if (crc_ok && isr_rx_scan_check(lll, irkmatch_ok, devmatch_ok,
 1002d78:	f1b8 0f00 	cmp.w	r8, #0
 1002d7c:	d0cf      	beq.n	1002d1e <isr_rx+0x26>

static inline bool isr_rx_scan_check(struct lll_scan *lll, u8_t irkmatch_ok,
				     u8_t devmatch_ok, u8_t rl_idx)
{
#if defined(CONFIG_BT_CTLR_PRIVACY)
	return (((lll->filter_policy & 0x01) == 0) &&
 1002d7e:	7da3      	ldrb	r3, [r4, #22]
		 (!devmatch_ok || ull_filter_lll_rl_idx_allowed(irkmatch_ok,
								rl_idx))) ||
 1002d80:	0719      	lsls	r1, r3, #28
 1002d82:	f100 80ae 	bmi.w	1002ee2 <isr_rx+0x1ea>
	return (((lll->filter_policy & 0x01) == 0) &&
 1002d86:	2e00      	cmp	r6, #0
 1002d88:	f040 81f3 	bne.w	1003172 <isr_rx+0x47a>
{
	struct node_rx_pdu *node_rx;
	struct pdu_adv *pdu_adv_rx;
	bool dir_report = false;

	node_rx = ull_pdu_rx_alloc_peek(1);
 1002d8c:	2001      	movs	r0, #1
 1002d8e:	f007 fa29 	bl	100a1e4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
 1002d92:	4680      	mov	r8, r0
 1002d94:	2800      	cmp	r0, #0
 1002d96:	f000 8203 	beq.w	10031a0 <isr_rx+0x4a8>
	pdu_adv_rx = (void *)node_rx->pdu;

	if (0) {
#if defined(CONFIG_BT_CENTRAL)
	/* Initiator */
	} else if ((lll->conn) &&
 1002d9a:	68a3      	ldr	r3, [r4, #8]
		rssi_ready = radio_rssi_is_ready();
 1002d9c:	fa5f f689 	uxtb.w	r6, r9
	} else if ((lll->conn) &&
 1002da0:	2b00      	cmp	r3, #0
 1002da2:	f000 80db 	beq.w	1002f5c <isr_rx+0x264>
}

static inline bool isr_scan_init_check(struct lll_scan *lll,
				       struct pdu_adv *pdu, u8_t rl_idx)
{
	return ((((lll->filter_policy & 0x01) != 0U) ||
 1002da6:	7da3      	ldrb	r3, [r4, #22]
		 isr_scan_init_adva_check(lll, pdu, rl_idx)) &&
 1002da8:	071a      	lsls	r2, r3, #28
 1002daa:	f140 81ee 	bpl.w	100318a <isr_rx+0x492>
		(((pdu->type == PDU_ADV_TYPE_ADV_IND) &&
 1002dae:	f898 0020 	ldrb.w	r0, [r8, #32]
		 isr_scan_init_adva_check(lll, pdu, rl_idx)) &&
 1002db2:	f010 030f 	ands.w	r3, r0, #15
 1002db6:	f040 80a4 	bne.w	1002f02 <isr_rx+0x20a>
		(((pdu->type == PDU_ADV_TYPE_ADV_IND) &&
 1002dba:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 1002dbe:	2b25      	cmp	r3, #37	; 0x25
 1002dc0:	f200 811c 	bhi.w	1002ffc <isr_rx+0x304>
			rx = ull_pdu_rx_alloc_peek(4);
 1002dc4:	2004      	movs	r0, #4
 1002dc6:	f007 fa0d 	bl	100a1e4 <ull_pdu_rx_alloc_peek>
		if (!rx) {
 1002dca:	2800      	cmp	r0, #0
 1002dcc:	d0a7      	beq.n	1002d1e <isr_rx+0x26>
		pdu_end_us = radio_tmr_end_get();
 1002dce:	f00f fa45 	bl	101225c <radio_tmr_end_get>
		if (!lll->ticks_window) {
 1002dd2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
		pdu_end_us = radio_tmr_end_get();
 1002dd4:	4681      	mov	r9, r0
		if (!lll->ticks_window) {
 1002dd6:	b943      	cbnz	r3, 1002dea <isr_rx+0xf2>
			scan_interval_us = lll->interval * 625U;
 1002dd8:	f240 2371 	movw	r3, #625	; 0x271
 1002ddc:	8ce2      	ldrh	r2, [r4, #38]	; 0x26
 1002dde:	fb03 f302 	mul.w	r3, r3, r2
			pdu_end_us %= scan_interval_us;
 1002de2:	fbb0 f2f3 	udiv	r2, r0, r3
 1002de6:	fb03 0912 	mls	r9, r3, r2, r0
		if (pdu_end_us > (HAL_TICKER_TICKS_TO_US(evt->ticks_slot) -
 1002dea:	f04f 0e07 	mov.w	lr, #7
 1002dee:	6823      	ldr	r3, [r4, #0]
 1002df0:	4898      	ldr	r0, [pc, #608]	; (1003054 <isr_rx+0x35c>)
 1002df2:	f8d3 c00c 	ldr.w	ip, [r3, #12]
 1002df6:	a394      	add	r3, pc, #592	; (adr r3, 1003048 <isr_rx+0x350>)
 1002df8:	e9d3 2300 	ldrd	r2, r3, [r3]
 1002dfc:	fbac 0100 	umull	r0, r1, ip, r0
 1002e00:	fb0e 110c 	mla	r1, lr, ip, r1
 1002e04:	f7fd f958 	bl	10000b8 <__aeabi_uldivmod>
				  EVENT_IFS_US - 352 - EVENT_OVERHEAD_START_US -
 1002e08:	f2a0 3342 	subw	r3, r0, #834	; 0x342
		if (pdu_end_us > (HAL_TICKER_TICKS_TO_US(evt->ticks_slot) -
 1002e0c:	454b      	cmp	r3, r9
 1002e0e:	d386      	bcc.n	1002d1e <isr_rx+0x26>
		radio_switch_complete_and_disable();
 1002e10:	f00f f864 	bl	1011edc <radio_switch_complete_and_disable>
		lll_conn = lll->conn;
 1002e14:	f8d4 a008 	ldr.w	sl, [r4, #8]
		pdu_tx = (void *)radio_pkt_scratch_get();
 1002e18:	f00f f842 	bl	1011ea0 <radio_pkt_scratch_get>
 1002e1c:	4683      	mov	fp, r0
		pdu_tx->len = sizeof(struct pdu_adv_connect_ind);
 1002e1e:	2022      	movs	r0, #34	; 0x22
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
 1002e20:	f898 2020 	ldrb.w	r2, [r8, #32]
		pdu_tx->type = PDU_ADV_TYPE_CONNECT_IND;
 1002e24:	f89b 1000 	ldrb.w	r1, [fp]
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
 1002e28:	f3c2 1280 	ubfx	r2, r2, #6, #1
		pdu_tx->type = PDU_ADV_TYPE_CONNECT_IND;
 1002e2c:	01d2      	lsls	r2, r2, #7
 1002e2e:	f001 0150 	and.w	r1, r1, #80	; 0x50
 1002e32:	f042 0225 	orr.w	r2, r2, #37	; 0x25
 1002e36:	430a      	orrs	r2, r1
 1002e38:	f88b 2000 	strb.w	r2, [fp]
		pdu_tx->len = sizeof(struct pdu_adv_connect_ind);
 1002e3c:	f88b 0001 	strb.w	r0, [fp, #1]
		lrpa = ull_filter_lll_lrpa_get(rl_idx);
 1002e40:	4638      	mov	r0, r7
 1002e42:	f00c fca7 	bl	100f794 <ull_filter_lll_lrpa_get>
		if (lll->rpa_gen && lrpa) {
 1002e46:	7de2      	ldrb	r2, [r4, #23]
		lrpa = ull_filter_lll_lrpa_get(rl_idx);
 1002e48:	4603      	mov	r3, r0
		if (lll->rpa_gen && lrpa) {
 1002e4a:	07d2      	lsls	r2, r2, #31
		lrpa = ull_filter_lll_lrpa_get(rl_idx);
 1002e4c:	9000      	str	r0, [sp, #0]
			pdu_tx->tx_addr = 1;
 1002e4e:	4658      	mov	r0, fp
		if (lll->rpa_gen && lrpa) {
 1002e50:	f140 8222 	bpl.w	1003298 <isr_rx+0x5a0>
 1002e54:	2b00      	cmp	r3, #0
 1002e56:	f000 821f 	beq.w	1003298 <isr_rx+0x5a0>
			pdu_tx->tx_addr = 1;
 1002e5a:	f89b 1000 	ldrb.w	r1, [fp]
			memcpy(&pdu_tx->connect_ind.init_addr[0], lrpa->val,
 1002e5e:	2206      	movs	r2, #6
			pdu_tx->tx_addr = 1;
 1002e60:	f041 0140 	orr.w	r1, r1, #64	; 0x40
 1002e64:	f800 1b02 	strb.w	r1, [r0], #2
			memcpy(&pdu_tx->connect_ind.init_addr[0], lrpa->val,
 1002e68:	4619      	mov	r1, r3
 1002e6a:	f013 fd25 	bl	10168b8 <memcpy>
		memcpy(&pdu_tx->connect_ind.adv_addr[0],
 1002e6e:	2206      	movs	r2, #6
 1002e70:	f108 0122 	add.w	r1, r8, #34	; 0x22
 1002e74:	f10b 0008 	add.w	r0, fp, #8
 1002e78:	f013 fd1e 	bl	10168b8 <memcpy>
		memcpy(&pdu_tx->connect_ind.access_addr[0],
 1002e7c:	2204      	movs	r2, #4
 1002e7e:	f10a 0108 	add.w	r1, sl, #8
 1002e82:	f10b 000e 	add.w	r0, fp, #14
 1002e86:	f013 fd17 	bl	10168b8 <memcpy>
		memcpy(&pdu_tx->connect_ind.crc_init[0],
 1002e8a:	2203      	movs	r2, #3
 1002e8c:	f10a 010c 	add.w	r1, sl, #12
 1002e90:	f10b 0012 	add.w	r0, fp, #18
 1002e94:	f013 fd10 	bl	10168b8 <memcpy>
		pdu_tx->connect_ind.win_size = 1;
 1002e98:	2201      	movs	r2, #1
		conn_interval_us = (u32_t)lll_conn->interval * 1250U;
 1002e9a:	f8ba 3012 	ldrh.w	r3, [sl, #18]
		pdu_tx->connect_ind.win_size = 1;
 1002e9e:	f88b 2015 	strb.w	r2, [fp, #21]
		conn_interval_us = (u32_t)lll_conn->interval * 1250U;
 1002ea2:	9301      	str	r3, [sp, #4]
		conn_offset_us = radio_tmr_end_get() + 502 + 1250;
 1002ea4:	f00f f9da 	bl	101225c <radio_tmr_end_get>
		    lll->conn_win_offset_us == 0U) {
 1002ea8:	f8d4 9010 	ldr.w	r9, [r4, #16]
		conn_offset_us = radio_tmr_end_get() + 502 + 1250;
 1002eac:	f500 62db 	add.w	r2, r0, #1752	; 0x6d8
		if (!IS_ENABLED(CONFIG_BT_CTLR_SCHED_ADVANCED) ||
 1002eb0:	f1b9 0f00 	cmp.w	r9, #0
 1002eb4:	f000 8201 	beq.w	10032ba <isr_rx+0x5c2>
		conn_interval_us = (u32_t)lll_conn->interval * 1250U;
 1002eb8:	f240 41e2 	movw	r1, #1250	; 0x4e2
 1002ebc:	9b01      	ldr	r3, [sp, #4]
 1002ebe:	fb01 f103 	mul.w	r1, r1, r3
			while ((conn_space_us & ((u32_t)1 << 31)) ||
 1002ec2:	f1b9 0f00 	cmp.w	r9, #0
 1002ec6:	db02      	blt.n	1002ece <isr_rx+0x1d6>
 1002ec8:	454a      	cmp	r2, r9
 1002eca:	f240 80c5 	bls.w	1003058 <isr_rx+0x360>
				conn_space_us += conn_interval_us;
 1002ece:	4489      	add	r9, r1
 1002ed0:	e7f7      	b.n	1002ec2 <isr_rx+0x1ca>
		 ull_filter_lll_rl_idx(!!(lll->filter_policy & 0x01),
 1002ed2:	7da0      	ldrb	r0, [r4, #22]
 1002ed4:	b2f9      	uxtb	r1, r7
 1002ed6:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 1002eda:	f00c fc79 	bl	100f7d0 <ull_filter_lll_rl_idx>
 1002ede:	4607      	mov	r7, r0
 1002ee0:	e74a      	b.n	1002d78 <isr_rx+0x80>
		(((lll->filter_policy & 0x01) != 0) &&
 1002ee2:	2e00      	cmp	r6, #0
 1002ee4:	f47f af52 	bne.w	1002d8c <isr_rx+0x94>
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(rl_idx)));
 1002ee8:	4638      	mov	r0, r7
 1002eea:	f00c fce3 	bl	100f8b4 <ull_filter_lll_irk_whitelisted>
 1002eee:	2800      	cmp	r0, #0
 1002ef0:	f47f af4c 	bne.w	1002d8c <isr_rx+0x94>
 1002ef4:	e713      	b.n	1002d1e <isr_rx+0x26>
		 irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
 1002ef6:	fa5f f08a 	uxtb.w	r0, sl
 1002efa:	f00c fca9 	bl	100f850 <ull_filter_lll_rl_irk_idx>
 1002efe:	4607      	mov	r7, r0
 1002f00:	e73a      	b.n	1002d78 <isr_rx+0x80>
		  (pdu->len <= sizeof(struct pdu_adv_adv_ind))) ||
 1002f02:	2b01      	cmp	r3, #1
 1002f04:	d14e      	bne.n	1002fa4 <isr_rx+0x2ac>
		 ((pdu->type == PDU_ADV_TYPE_DIRECT_IND) &&
 1002f06:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 1002f0a:	2b0c      	cmp	r3, #12
 1002f0c:	f47f af07 	bne.w	1002d1e <isr_rx+0x26>
				       struct pdu_adv *pdu, u8_t rl_idx,
				       bool *dir_report)
{
#if defined(CONFIG_BT_CTLR_PRIVACY)
	if (ull_filter_lll_rl_addr_resolve(pdu->rx_addr,
					   pdu->direct_ind.tgt_addr, rl_idx)) {
 1002f10:	f108 0928 	add.w	r9, r8, #40	; 0x28
	if (ull_filter_lll_rl_addr_resolve(pdu->rx_addr,
 1002f14:	4649      	mov	r1, r9
 1002f16:	463a      	mov	r2, r7
 1002f18:	09c0      	lsrs	r0, r0, #7
 1002f1a:	f00c fd61 	bl	100f9e0 <ull_filter_lll_rl_addr_resolve>
 1002f1e:	2800      	cmp	r0, #0
 1002f20:	f47f af50 	bne.w	1002dc4 <isr_rx+0xcc>
		return true;
	} else if (init && lll->rpa_gen &&
 1002f24:	7de3      	ldrb	r3, [r4, #23]
 1002f26:	07db      	lsls	r3, r3, #31
 1002f28:	f100 81e3 	bmi.w	10032f2 <isr_rx+0x5fa>
		 */
		return false;
	}
#endif /* CONFIG_BT_CTLR_PRIVACY */

	return (((lll->init_addr_type == pdu->rx_addr) &&
 1002f2c:	7da3      	ldrb	r3, [r4, #22]
 1002f2e:	f898 0020 	ldrb.w	r0, [r8, #32]
		!memcmp(lll->init_addr, pdu->direct_ind.tgt_addr,
			BDADDR_SIZE))) ||
 1002f32:	f3c3 1280 	ubfx	r2, r3, #6, #1
 1002f36:	ebb2 1fd0 	cmp.w	r2, r0, lsr #7
 1002f3a:	f000 8206 	beq.w	100334a <isr_rx+0x652>

static inline bool isr_scan_tgta_rpa_check(struct lll_scan *lll,
					   struct pdu_adv *pdu,
					   bool *dir_report)
{
	if (((lll->filter_policy & 0x02) != 0U) &&
 1002f3e:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 1002f42:	0798      	lsls	r0, r3, #30
 1002f44:	d50a      	bpl.n	1002f5c <isr_rx+0x264>
 1002f46:	f998 3020 	ldrsb.w	r3, [r8, #32]
 1002f4a:	2b00      	cmp	r3, #0
 1002f4c:	da06      	bge.n	1002f5c <isr_rx+0x264>
	    (pdu->rx_addr != 0) &&
 1002f4e:	f898 302d 	ldrb.w	r3, [r8, #45]	; 0x2d
 1002f52:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 1002f56:	2b40      	cmp	r3, #64	; 0x40
 1002f58:	f43f af34 	beq.w	1002dc4 <isr_rx+0xcc>
 1002f5c:	f898 0020 	ldrb.w	r0, [r8, #32]
	} else if (((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
 1002f60:	f010 030f 	ands.w	r3, r0, #15
 1002f64:	d11e      	bne.n	1002fa4 <isr_rx+0x2ac>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
 1002f66:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 1002f6a:	2b25      	cmp	r3, #37	; 0x25
 1002f6c:	f63f aed7 	bhi.w	1002d1e <isr_rx+0x26>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind)) &&
 1002f70:	f994 2016 	ldrsb.w	r2, [r4, #22]
 1002f74:	2a00      	cmp	r2, #0
 1002f76:	f2c0 811f 	blt.w	10031b8 <isr_rx+0x4c0>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
 1002f7a:	2b25      	cmp	r3, #37	; 0x25
	bool dir_report = false;
 1002f7c:	bf98      	it	ls
 1002f7e:	f04f 0900 	movls.w	r9, #0
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
 1002f82:	d83b      	bhi.n	1002ffc <isr_rx+0x304>
		   isr_scan_rsp_adva_matches(pdu_adv_rx))) &&
 1002f84:	2b00      	cmp	r3, #0
 1002f86:	f43f aeca 	beq.w	1002d1e <isr_rx+0x26>
		 (pdu_adv_rx->len != 0) &&
 1002f8a:	68a3      	ldr	r3, [r4, #8]
 1002f8c:	2b00      	cmp	r3, #0
 1002f8e:	f47f aec6 	bne.w	1002d1e <isr_rx+0x26>
		err = isr_rx_scan_report(lll, rssi_ready,
 1002f92:	2d00      	cmp	r5, #0
 1002f94:	bf14      	ite	ne
 1002f96:	4639      	movne	r1, r7
 1002f98:	21ff      	moveq	r1, #255	; 0xff
 1002f9a:	464a      	mov	r2, r9
 1002f9c:	4630      	mov	r0, r6
 1002f9e:	f00d feb3 	bl	1010d08 <isr_rx_scan_report.isra.0>
		if (err) {
 1002fa2:	e6bc      	b.n	1002d1e <isr_rx+0x26>
	} else if (((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
 1002fa4:	2b06      	cmp	r3, #6
 1002fa6:	f000 8101 	beq.w	10031ac <isr_rx+0x4b4>
	else if (((((pdu_adv_rx->type == PDU_ADV_TYPE_ADV_IND) ||
 1002faa:	2b02      	cmp	r3, #2
 1002fac:	f000 815a 	beq.w	1003264 <isr_rx+0x56c>
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_adv_ind))) ||
 1002fb0:	2b01      	cmp	r3, #1
 1002fb2:	d123      	bne.n	1002ffc <isr_rx+0x304>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_DIRECT_IND) &&
 1002fb4:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 1002fb8:	2b0c      	cmp	r3, #12
 1002fba:	f47f aeb0 	bne.w	1002d1e <isr_rx+0x26>
					   pdu->direct_ind.tgt_addr, rl_idx)) {
 1002fbe:	f108 0a28 	add.w	sl, r8, #40	; 0x28
	if (ull_filter_lll_rl_addr_resolve(pdu->rx_addr,
 1002fc2:	4651      	mov	r1, sl
 1002fc4:	463a      	mov	r2, r7
 1002fc6:	09c0      	lsrs	r0, r0, #7
 1002fc8:	f00c fd0a 	bl	100f9e0 <ull_filter_lll_rl_addr_resolve>
 1002fcc:	4681      	mov	r9, r0
 1002fce:	2800      	cmp	r0, #0
 1002fd0:	f040 818a 	bne.w	10032e8 <isr_rx+0x5f0>
	return (((lll->init_addr_type == pdu->rx_addr) &&
 1002fd4:	7da3      	ldrb	r3, [r4, #22]
 1002fd6:	f898 0020 	ldrb.w	r0, [r8, #32]
			BDADDR_SIZE))) ||
 1002fda:	f3c3 1280 	ubfx	r2, r3, #6, #1
 1002fde:	ebb2 1fd0 	cmp.w	r2, r0, lsr #7
 1002fe2:	f000 818d 	beq.w	1003300 <isr_rx+0x608>
	if (((lll->filter_policy & 0x02) != 0U) &&
 1002fe6:	f3c3 03c1 	ubfx	r3, r3, #3, #2
 1002fea:	0798      	lsls	r0, r3, #30
 1002fec:	d504      	bpl.n	1002ff8 <isr_rx+0x300>
 1002fee:	f998 3020 	ldrsb.w	r3, [r8, #32]
 1002ff2:	2b00      	cmp	r3, #0
 1002ff4:	f2c0 818f 	blt.w	1003316 <isr_rx+0x61e>
 1002ff8:	f898 0020 	ldrb.w	r0, [r8, #32]
					&dir_report))) ||
 1002ffc:	f000 000f 	and.w	r0, r0, #15
 1003000:	2804      	cmp	r0, #4
 1003002:	f47f ae8c 	bne.w	1002d1e <isr_rx+0x26>
		  ((pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_RSP) &&
 1003006:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 100300a:	2b25      	cmp	r3, #37	; 0x25
 100300c:	f63f ae87 	bhi.w	1002d1e <isr_rx+0x26>
		   (lll->state != 0U) &&
 1003010:	7da3      	ldrb	r3, [r4, #22]
		   (pdu_adv_rx->len <= sizeof(struct pdu_adv_scan_rsp)) &&
 1003012:	07da      	lsls	r2, r3, #31
 1003014:	f57f ae83 	bpl.w	1002d1e <isr_rx+0x26>
	return false;
}

static inline bool isr_scan_rsp_adva_matches(struct pdu_adv *srsp)
{
	struct pdu_adv *sreq = (void *)radio_pkt_scratch_get();
 1003018:	f00e ff42 	bl	1011ea0 <radio_pkt_scratch_get>

	return ((sreq->rx_addr == srsp->tx_addr) &&
 100301c:	f898 3020 	ldrb.w	r3, [r8, #32]
 1003020:	7802      	ldrb	r2, [r0, #0]
 1003022:	f3c3 1380 	ubfx	r3, r3, #6, #1
 1003026:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
 100302a:	f47f ae78 	bne.w	1002d1e <isr_rx+0x26>
		(memcmp(&sreq->scan_req.adv_addr[0],
 100302e:	2206      	movs	r2, #6
 1003030:	3008      	adds	r0, #8
 1003032:	f108 0122 	add.w	r1, r8, #34	; 0x22
 1003036:	f013 fc2f 	bl	1016898 <memcmp>
	return ((sreq->rx_addr == srsp->tx_addr) &&
 100303a:	4681      	mov	r9, r0
 100303c:	2800      	cmp	r0, #0
 100303e:	f47f ae6e 	bne.w	1002d1e <isr_rx+0x26>
 1003042:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 1003046:	e79d      	b.n	1002f84 <isr_rx+0x28c>
 1003048:	3b9aca00 	.word	0x3b9aca00
 100304c:	00000000 	.word	0x00000000
 1003050:	01010a95 	.word	0x01010a95
 1003054:	1afd498d 	.word	0x1afd498d
				sys_cpu_to_le16((conn_space_us -
 1003058:	49c4      	ldr	r1, [pc, #784]	; (100336c <isr_rx+0x674>)
 100305a:	eba9 0202 	sub.w	r2, r9, r2
 100305e:	fba1 3202 	umull	r3, r2, r1, r2
			pdu_tx->connect_ind.win_size++;
 1003062:	f89b 1015 	ldrb.w	r1, [fp, #21]
			pdu_tx->connect_ind.win_offset =
 1003066:	f3c2 228f 	ubfx	r2, r2, #10, #16
			pdu_tx->connect_ind.win_size++;
 100306a:	3101      	adds	r1, #1
			pdu_tx->connect_ind.win_offset =
 100306c:	f8ab 2016 	strh.w	r2, [fp, #22]
			pdu_tx->connect_ind.win_size++;
 1003070:	f88b 1015 	strb.w	r1, [fp, #21]
		pdu_tx->connect_ind.interval =
 1003074:	f8ba 0012 	ldrh.w	r0, [sl, #18]
		pdu_tx->connect_ind.latency =
 1003078:	f8ba 1014 	ldrh.w	r1, [sl, #20]
		pdu_tx->connect_ind.timeout =
 100307c:	8aa2      	ldrh	r2, [r4, #20]
		pdu_tx->connect_ind.interval =
 100307e:	f8ab 0018 	strh.w	r0, [fp, #24]
		pdu_tx->connect_ind.latency =
 1003082:	f8ab 101a 	strh.w	r1, [fp, #26]
		pdu_tx->connect_ind.timeout =
 1003086:	f8ab 201c 	strh.w	r2, [fp, #28]
		memcpy(&pdu_tx->connect_ind.chan_map[0],
 100308a:	f10a 011c 	add.w	r1, sl, #28
 100308e:	2205      	movs	r2, #5
 1003090:	f10b 001e 	add.w	r0, fp, #30
 1003094:	f013 fc10 	bl	10168b8 <memcpy>
		pdu_tx->connect_ind.hop = lll_conn->data_chan_hop;
 1003098:	f89a 1022 	ldrb.w	r1, [sl, #34]	; 0x22
 100309c:	f89b 2023 	ldrb.w	r2, [fp, #35]	; 0x23
 10030a0:	f361 0204 	bfi	r2, r1, #0, #5
 10030a4:	f88b 2023 	strb.w	r2, [fp, #35]	; 0x23
		pdu_tx->connect_ind.sca = lll_conn_sca_local_get();
 10030a8:	f00d ff1e 	bl	1010ee8 <lll_conn_sca_local_get>
 10030ac:	4601      	mov	r1, r0
 10030ae:	f89b 2023 	ldrb.w	r2, [fp, #35]	; 0x23
		radio_pkt_tx_set(pdu_tx);
 10030b2:	4658      	mov	r0, fp
		pdu_tx->connect_ind.sca = lll_conn_sca_local_get();
 10030b4:	f361 1247 	bfi	r2, r1, #5, #3
 10030b8:	f88b 2023 	strb.w	r2, [fp, #35]	; 0x23
		radio_pkt_tx_set(pdu_tx);
 10030bc:	f00e fe68 	bl	1011d90 <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
 10030c0:	f00e feb6 	bl	1011e30 <radio_is_ready>
 10030c4:	2800      	cmp	r0, #0
 10030c6:	f040 8103 	bne.w	10032d0 <isr_rx+0x5d8>
		radio_isr_set(isr_cleanup, lll);
 10030ca:	4621      	mov	r1, r4
 10030cc:	48a8      	ldr	r0, [pc, #672]	; (1003370 <isr_rx+0x678>)
 10030ce:	f00e fd8f 	bl	1011bf0 <radio_isr_set>
		if (rssi_ready) {
 10030d2:	2e00      	cmp	r6, #0
 10030d4:	f040 80f7 	bne.w	10032c6 <isr_rx+0x5ce>
}

static inline int lll_stop(void *lll)
{
	struct lll_hdr *hdr = lll;
	int ret = !!hdr->is_stop;
 10030d8:	7922      	ldrb	r2, [r4, #4]

	hdr->is_stop = 1U;
 10030da:	f042 0101 	orr.w	r1, r2, #1
		LL_ASSERT(!ret);
 10030de:	07d3      	lsls	r3, r2, #31
 10030e0:	7121      	strb	r1, [r4, #4]
 10030e2:	f100 80fb 	bmi.w	10032dc <isr_rx+0x5e4>
		rx = ull_pdu_rx_alloc();
 10030e6:	f007 f89b 	bl	100a220 <ull_pdu_rx_alloc>
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
 10030ea:	2108      	movs	r1, #8
		rx->hdr.handle = 0xffff;
 10030ec:	f64f 72ff 	movw	r2, #65535	; 0xffff
		rx = ull_pdu_rx_alloc();
 10030f0:	4606      	mov	r6, r0
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
 10030f2:	7101      	strb	r1, [r0, #4]
		u8_t pdu_adv_rx_chan_sel = pdu_adv_rx->chan_sel;
 10030f4:	f898 8020 	ldrb.w	r8, [r8, #32]
		memcpy(rx->pdu, pdu_tx, (offsetof(struct pdu_adv, connect_ind) +
 10030f8:	4659      	mov	r1, fp
		rx->hdr.handle = 0xffff;
 10030fa:	80c2      	strh	r2, [r0, #6]
		memcpy(rx->pdu, pdu_tx, (offsetof(struct pdu_adv, connect_ind) +
 10030fc:	2224      	movs	r2, #36	; 0x24
 10030fe:	3020      	adds	r0, #32
 1003100:	f013 fbda 	bl	10168b8 <memcpy>
		pdu_adv_rx->chan_sel = pdu_adv_rx_chan_sel;
 1003104:	f896 3020 	ldrb.w	r3, [r6, #32]
		u8_t pdu_adv_rx_chan_sel = pdu_adv_rx->chan_sel;
 1003108:	f3c8 1840 	ubfx	r8, r8, #5, #1
		pdu_adv_rx->chan_sel = pdu_adv_rx_chan_sel;
 100310c:	f368 1345 	bfi	r3, r8, #5, #1
 1003110:	f886 3020 	strb.w	r3, [r6, #32]
		ftr->param = lll;
 1003114:	60b4      	str	r4, [r6, #8]
		ftr->ticks_anchor = radio_tmr_start_get();
 1003116:	f00f f81b 	bl	1012150 <radio_tmr_start_get>
				    radio_tx_chain_delay_get(0, 0);
 100311a:	2100      	movs	r1, #0
		ftr->ticks_anchor = radio_tmr_start_get();
 100311c:	6130      	str	r0, [r6, #16]
				    radio_tx_chain_delay_get(0, 0);
 100311e:	4608      	mov	r0, r1
 1003120:	f00e fe46 	bl	1011db0 <radio_tx_chain_delay_get>
		ftr->us_radio_rdy = radio_tx_ready_delay_get(0, 0);
 1003124:	2100      	movs	r1, #0
		ftr->us_radio_end = conn_space_us -
 1003126:	eba9 0000 	sub.w	r0, r9, r0
 100312a:	6170      	str	r0, [r6, #20]
		ftr->us_radio_rdy = radio_tx_ready_delay_get(0, 0);
 100312c:	4608      	mov	r0, r1
 100312e:	f00e fe35 	bl	1011d9c <radio_tx_ready_delay_get>
		ftr->rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
 1003132:	2d00      	cmp	r5, #0
 1003134:	bf08      	it	eq
 1003136:	27ff      	moveq	r7, #255	; 0xff
 1003138:	77b7      	strb	r7, [r6, #30]
		ftr->lrpa_used = lll->rpa_gen && lrpa;
 100313a:	7de3      	ldrb	r3, [r4, #23]
		ftr->us_radio_rdy = radio_tx_ready_delay_get(0, 0);
 100313c:	61b0      	str	r0, [r6, #24]
		ftr->lrpa_used = lll->rpa_gen && lrpa;
 100313e:	f013 0301 	ands.w	r3, r3, #1
 1003142:	f000 80b8 	beq.w	10032b6 <isr_rx+0x5be>
 1003146:	9b00      	ldr	r3, [sp, #0]
 1003148:	f1b3 0b00 	subs.w	fp, r3, #0
 100314c:	bf18      	it	ne
 100314e:	f04f 0b01 	movne.w	fp, #1
 1003152:	7f73      	ldrb	r3, [r6, #29]
 1003154:	f36b 0300 	bfi	r3, fp, #0, #1
 1003158:	7773      	strb	r3, [r6, #29]
			ftr->extra = ull_pdu_rx_alloc();
 100315a:	f007 f861 	bl	100a220 <ull_pdu_rx_alloc>
		ull_rx_put(rx->hdr.link, rx);
 100315e:	4631      	mov	r1, r6
			ftr->extra = ull_pdu_rx_alloc();
 1003160:	60f0      	str	r0, [r6, #12]
		ull_rx_put(rx->hdr.link, rx);
 1003162:	6830      	ldr	r0, [r6, #0]
 1003164:	f007 f874 	bl	100a250 <ull_rx_put>
}
 1003168:	b003      	add	sp, #12
 100316a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		ull_rx_sched();
 100316e:	f007 b87f 	b.w	100a270 <ull_rx_sched>
		 (!devmatch_ok || ull_filter_lll_rl_idx_allowed(irkmatch_ok,
 1003172:	4639      	mov	r1, r7
 1003174:	4628      	mov	r0, r5
 1003176:	f00c fbcd 	bl	100f914 <ull_filter_lll_rl_idx_allowed>
 100317a:	2800      	cmp	r0, #0
 100317c:	f47f ae06 	bne.w	1002d8c <isr_rx+0x94>
		(((lll->filter_policy & 0x01) != 0) &&
 1003180:	7da3      	ldrb	r3, [r4, #22]
								rl_idx))) ||
 1003182:	071b      	lsls	r3, r3, #28
 1003184:	f57f adcb 	bpl.w	1002d1e <isr_rx+0x26>
 1003188:	e600      	b.n	1002d8c <isr_rx+0x94>
	if (rl_idx != FILTER_IDX_NONE) {
 100318a:	2fff      	cmp	r7, #255	; 0xff
 100318c:	d06d      	beq.n	100326a <isr_rx+0x572>
		return (rl_idx == lll->rl_idx);
 100318e:	7e23      	ldrb	r3, [r4, #24]
 1003190:	1bdb      	subs	r3, r3, r7
 1003192:	fab3 f383 	clz	r3, r3
 1003196:	095b      	lsrs	r3, r3, #5
	return ((((lll->filter_policy & 0x01) != 0U) ||
 1003198:	2b00      	cmp	r3, #0
 100319a:	f47f ae08 	bne.w	1002dae <isr_rx+0xb6>
 100319e:	e6dd      	b.n	1002f5c <isr_rx+0x264>
	LL_ASSERT(node_rx);
 10031a0:	f240 21aa 	movw	r1, #682	; 0x2aa
 10031a4:	4873      	ldr	r0, [pc, #460]	; (1003374 <isr_rx+0x67c>)
 10031a6:	f000 f9ef 	bl	1003588 <bt_ctlr_assert_handle>
 10031aa:	e5f6      	b.n	1002d9a <isr_rx+0xa2>
		    (pdu_adv_rx->type == PDU_ADV_TYPE_SCAN_IND)) &&
 10031ac:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 10031b0:	2b25      	cmp	r3, #37	; 0x25
 10031b2:	f67f aedd 	bls.w	1002f70 <isr_rx+0x278>
 10031b6:	e721      	b.n	1002ffc <isr_rx+0x304>
		   lll->type &&
 10031b8:	68a2      	ldr	r2, [r4, #8]
 10031ba:	2a00      	cmp	r2, #0
 10031bc:	f47f aedd 	bne.w	1002f7a <isr_rx+0x282>
		radio_tmr_tifs_set(EVENT_IFS_US);
 10031c0:	2096      	movs	r0, #150	; 0x96
 10031c2:	f00e ff11 	bl	1011fe8 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
 10031c6:	2000      	movs	r0, #0
 10031c8:	f00e fe6e 	bl	1011ea8 <radio_switch_complete_and_rx>
		err = isr_rx_scan_report(lll, rssi_ready,
 10031cc:	2d00      	cmp	r5, #0
 10031ce:	bf14      	ite	ne
 10031d0:	4639      	movne	r1, r7
 10031d2:	21ff      	moveq	r1, #255	; 0xff
 10031d4:	4630      	mov	r0, r6
 10031d6:	2200      	movs	r2, #0
 10031d8:	f00d fd96 	bl	1010d08 <isr_rx_scan_report.isra.0>
		if (err) {
 10031dc:	2800      	cmp	r0, #0
 10031de:	f47f ad9e 	bne.w	1002d1e <isr_rx+0x26>
		pdu_tx = (void *)radio_pkt_scratch_get();
 10031e2:	f00e fe5d 	bl	1011ea0 <radio_pkt_scratch_get>
		pdu_tx->len = sizeof(struct pdu_adv_scan_req);
 10031e6:	210c      	movs	r1, #12
		pdu_tx = (void *)radio_pkt_scratch_get();
 10031e8:	4605      	mov	r5, r0
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
 10031ea:	f898 3020 	ldrb.w	r3, [r8, #32]
		pdu_tx->type = PDU_ADV_TYPE_SCAN_REQ;
 10031ee:	7802      	ldrb	r2, [r0, #0]
		pdu_tx->rx_addr = pdu_adv_rx->tx_addr;
 10031f0:	f3c3 1380 	ubfx	r3, r3, #6, #1
		pdu_tx->type = PDU_ADV_TYPE_SCAN_REQ;
 10031f4:	01db      	lsls	r3, r3, #7
 10031f6:	f002 0270 	and.w	r2, r2, #112	; 0x70
 10031fa:	f043 0303 	orr.w	r3, r3, #3
 10031fe:	4313      	orrs	r3, r2
 1003200:	702b      	strb	r3, [r5, #0]
		pdu_tx->len = sizeof(struct pdu_adv_scan_req);
 1003202:	7069      	strb	r1, [r5, #1]
		lrpa = ull_filter_lll_lrpa_get(rl_idx);
 1003204:	4638      	mov	r0, r7
 1003206:	f00c fac5 	bl	100f794 <ull_filter_lll_lrpa_get>
		if (lll->rpa_gen && lrpa) {
 100320a:	7de3      	ldrb	r3, [r4, #23]
		lrpa = ull_filter_lll_lrpa_get(rl_idx);
 100320c:	4601      	mov	r1, r0
		if (lll->rpa_gen && lrpa) {
 100320e:	07de      	lsls	r6, r3, #31
			pdu_tx->tx_addr = 1;
 1003210:	4628      	mov	r0, r5
		if (lll->rpa_gen && lrpa) {
 1003212:	f140 808c 	bpl.w	100332e <isr_rx+0x636>
 1003216:	2900      	cmp	r1, #0
 1003218:	f000 8089 	beq.w	100332e <isr_rx+0x636>
			pdu_tx->tx_addr = 1;
 100321c:	782b      	ldrb	r3, [r5, #0]
			memcpy(&pdu_tx->scan_req.scan_addr[0], lrpa->val,
 100321e:	2206      	movs	r2, #6
			pdu_tx->tx_addr = 1;
 1003220:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 1003224:	f800 3b02 	strb.w	r3, [r0], #2
			memcpy(&pdu_tx->scan_req.scan_addr[0], lrpa->val,
 1003228:	f013 fb46 	bl	10168b8 <memcpy>
		memcpy(&pdu_tx->scan_req.adv_addr[0],
 100322c:	2206      	movs	r2, #6
 100322e:	f108 0122 	add.w	r1, r8, #34	; 0x22
 1003232:	f105 0008 	add.w	r0, r5, #8
 1003236:	f013 fb3f 	bl	10168b8 <memcpy>
		radio_pkt_tx_set(pdu_tx);
 100323a:	4628      	mov	r0, r5
 100323c:	f00e fda8 	bl	1011d90 <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
 1003240:	f00e fdf6 	bl	1011e30 <radio_is_ready>
 1003244:	2800      	cmp	r0, #0
 1003246:	f040 808b 	bne.w	1003360 <isr_rx+0x668>
		radio_tmr_end_capture();
 100324a:	f00e fff1 	bl	1012230 <radio_tmr_end_capture>
		radio_isr_set(isr_tx, lll);
 100324e:	4621      	mov	r1, r4
		lll->state = 1U;
 1003250:	7da3      	ldrb	r3, [r4, #22]
		radio_isr_set(isr_tx, lll);
 1003252:	4849      	ldr	r0, [pc, #292]	; (1003378 <isr_rx+0x680>)
		lll->state = 1U;
 1003254:	f043 0301 	orr.w	r3, r3, #1
 1003258:	75a3      	strb	r3, [r4, #22]
}
 100325a:	b003      	add	sp, #12
 100325c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		radio_isr_set(isr_tx, lll);
 1003260:	f00e bcc6 	b.w	1011bf0 <radio_isr_set>
 1003264:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 1003268:	e687      	b.n	1002f7a <isr_rx+0x282>
	return ((lll->adv_addr_type == pdu->tx_addr) &&
 100326a:	f898 0020 	ldrb.w	r0, [r8, #32]
 100326e:	f3c3 1340 	ubfx	r3, r3, #5, #1
 1003272:	f3c0 1280 	ubfx	r2, r0, #6, #1
 1003276:	4293      	cmp	r3, r2
 1003278:	f47f ae72 	bne.w	1002f60 <isr_rx+0x268>
		!memcmp(lll->adv_addr, &pdu->adv_ind.addr[0], BDADDR_SIZE));
 100327c:	2206      	movs	r2, #6
 100327e:	f108 0122 	add.w	r1, r8, #34	; 0x22
 1003282:	f104 001f 	add.w	r0, r4, #31
 1003286:	f013 fb07 	bl	1016898 <memcmp>
	return ((lll->adv_addr_type == pdu->tx_addr) &&
 100328a:	fab0 f380 	clz	r3, r0
 100328e:	095b      	lsrs	r3, r3, #5
	return ((((lll->filter_policy & 0x01) != 0U) ||
 1003290:	2b00      	cmp	r3, #0
 1003292:	f47f ad8c 	bne.w	1002dae <isr_rx+0xb6>
 1003296:	e661      	b.n	1002f5c <isr_rx+0x264>
			pdu_tx->tx_addr = lll->init_addr_type;
 1003298:	7da2      	ldrb	r2, [r4, #22]
 100329a:	f89b 1000 	ldrb.w	r1, [fp]
 100329e:	f3c2 1280 	ubfx	r2, r2, #6, #1
 10032a2:	f362 1186 	bfi	r1, r2, #6, #1
 10032a6:	f800 1b02 	strb.w	r1, [r0], #2
			memcpy(&pdu_tx->connect_ind.init_addr[0],
 10032aa:	2206      	movs	r2, #6
 10032ac:	f104 0119 	add.w	r1, r4, #25
 10032b0:	f013 fb02 	bl	10168b8 <memcpy>
 10032b4:	e5db      	b.n	1002e6e <isr_rx+0x176>
 10032b6:	469b      	mov	fp, r3
 10032b8:	e74b      	b.n	1003152 <isr_rx+0x45a>
			pdu_tx->connect_ind.win_offset = sys_cpu_to_le16(0);
 10032ba:	f88b 9016 	strb.w	r9, [fp, #22]
 10032be:	f88b 9017 	strb.w	r9, [fp, #23]
		conn_offset_us = radio_tmr_end_get() + 502 + 1250;
 10032c2:	4691      	mov	r9, r2
 10032c4:	e6d6      	b.n	1003074 <isr_rx+0x37c>
			lll_conn->rssi_latest =  radio_rssi_get();
 10032c6:	f00e fe29 	bl	1011f1c <radio_rssi_get>
 10032ca:	f88a 00a5 	strb.w	r0, [sl, #165]	; 0xa5
 10032ce:	e703      	b.n	10030d8 <isr_rx+0x3e0>
		LL_ASSERT(!radio_is_ready());
 10032d0:	f240 3123 	movw	r1, #803	; 0x323
 10032d4:	4827      	ldr	r0, [pc, #156]	; (1003374 <isr_rx+0x67c>)
 10032d6:	f000 f957 	bl	1003588 <bt_ctlr_assert_handle>
 10032da:	e6f6      	b.n	10030ca <isr_rx+0x3d2>
		LL_ASSERT(!ret);
 10032dc:	f240 3149 	movw	r1, #841	; 0x349
 10032e0:	4824      	ldr	r0, [pc, #144]	; (1003374 <isr_rx+0x67c>)
 10032e2:	f000 f951 	bl	1003588 <bt_ctlr_assert_handle>
 10032e6:	e6fe      	b.n	10030e6 <isr_rx+0x3ee>
	bool dir_report = false;
 10032e8:	f04f 0900 	mov.w	r9, #0
 10032ec:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 10032f0:	e648      	b.n	1002f84 <isr_rx+0x28c>
		   ull_filter_lll_lrpa_get(rl_idx)) {
 10032f2:	4638      	mov	r0, r7
 10032f4:	f00c fa4e 	bl	100f794 <ull_filter_lll_lrpa_get>
	} else if (init && lll->rpa_gen &&
 10032f8:	2800      	cmp	r0, #0
 10032fa:	f47f ae2f 	bne.w	1002f5c <isr_rx+0x264>
 10032fe:	e615      	b.n	1002f2c <isr_rx+0x234>
		!memcmp(lll->init_addr, pdu->direct_ind.tgt_addr,
 1003300:	4651      	mov	r1, sl
 1003302:	2206      	movs	r2, #6
 1003304:	f104 0019 	add.w	r0, r4, #25
 1003308:	f013 fac6 	bl	1016898 <memcmp>
	return (((lll->init_addr_type == pdu->rx_addr) &&
 100330c:	2800      	cmp	r0, #0
 100330e:	f43f ae98 	beq.w	1003042 <isr_rx+0x34a>
 1003312:	7da3      	ldrb	r3, [r4, #22]
 1003314:	e667      	b.n	1002fe6 <isr_rx+0x2ee>
	    (pdu->rx_addr != 0) &&
 1003316:	f898 302d 	ldrb.w	r3, [r8, #45]	; 0x2d
 100331a:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 100331e:	2b40      	cmp	r3, #64	; 0x40
 1003320:	f47f ae6a 	bne.w	1002ff8 <isr_rx+0x300>
			*dir_report = true;
 1003324:	f04f 0901 	mov.w	r9, #1
 1003328:	f898 3021 	ldrb.w	r3, [r8, #33]	; 0x21
 100332c:	e62a      	b.n	1002f84 <isr_rx+0x28c>
			pdu_tx->tx_addr = lll->init_addr_type;
 100332e:	7da3      	ldrb	r3, [r4, #22]
 1003330:	782a      	ldrb	r2, [r5, #0]
 1003332:	f3c3 1380 	ubfx	r3, r3, #6, #1
 1003336:	f363 1286 	bfi	r2, r3, #6, #1
 100333a:	f800 2b02 	strb.w	r2, [r0], #2
			memcpy(&pdu_tx->scan_req.scan_addr[0],
 100333e:	f104 0119 	add.w	r1, r4, #25
 1003342:	2206      	movs	r2, #6
 1003344:	f013 fab8 	bl	10168b8 <memcpy>
 1003348:	e770      	b.n	100322c <isr_rx+0x534>
		!memcmp(lll->init_addr, pdu->direct_ind.tgt_addr,
 100334a:	4649      	mov	r1, r9
 100334c:	2206      	movs	r2, #6
 100334e:	f104 0019 	add.w	r0, r4, #25
 1003352:	f013 faa1 	bl	1016898 <memcmp>
	return (((lll->init_addr_type == pdu->rx_addr) &&
 1003356:	2800      	cmp	r0, #0
 1003358:	f43f ad34 	beq.w	1002dc4 <isr_rx+0xcc>
 100335c:	7da3      	ldrb	r3, [r4, #22]
 100335e:	e5ee      	b.n	1002f3e <isr_rx+0x246>
		LL_ASSERT(!radio_is_ready());
 1003360:	f240 31a5 	movw	r1, #933	; 0x3a5
 1003364:	4803      	ldr	r0, [pc, #12]	; (1003374 <isr_rx+0x67c>)
 1003366:	f000 f90f 	bl	1003588 <bt_ctlr_assert_handle>
 100336a:	e76e      	b.n	100324a <isr_rx+0x552>
 100336c:	d1b71759 	.word	0xd1b71759
 1003370:	01010c5d 	.word	0x01010c5d
 1003374:	01018a1c 	.word	0x01018a1c
 1003378:	01010aa9 	.word	0x01010aa9

0100337c <virtio_get_status>:
extern "C" {
#endif

static ALWAYS_INLINE u8_t sys_read8(mem_addr_t addr)
{
	return *(volatile u8_t *)addr;
 100337c:	4b01      	ldr	r3, [pc, #4]	; (1003384 <virtio_get_status+0x8>)
 100337e:	7818      	ldrb	r0, [r3, #0]
static struct k_work ipm_work;

static unsigned char virtio_get_status(struct virtio_device *vdev)
{
	return sys_read8(VDEV_STATUS_ADDR);
}
 1003380:	4770      	bx	lr
 1003382:	bf00      	nop
 1003384:	20070000 	.word	0x20070000

01003388 <virtio_set_status>:
}

static ALWAYS_INLINE void sys_write8(u8_t data, mem_addr_t addr)
{
	*(volatile u8_t *)addr = data;
 1003388:	4b01      	ldr	r3, [pc, #4]	; (1003390 <virtio_set_status+0x8>)
 100338a:	7019      	strb	r1, [r3, #0]
}

static void virtio_set_status(struct virtio_device *vdev, unsigned char status)
{
	sys_write8(status, VDEV_STATUS_ADDR);
}
 100338c:	4770      	bx	lr
 100338e:	bf00      	nop
 1003390:	20070000 	.word	0x20070000

01003394 <endpoint_cb>:
}
#endif /* CONFIG_BT_CTLR_ASSERT_HANDLER */

int endpoint_cb(struct rpmsg_endpoint *ept, void *data, size_t len, u32_t src,
		void *priv)
{
 1003394:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 1003396:	4617      	mov	r7, r2
 1003398:	460e      	mov	r6, r1
 * @return Source ID.
 */
static inline u32_t log_const_source_id(
				const struct log_source_const_data *data)
{
	return ((u8_t *)data - (u8_t *)__log_const_start)/
 100339a:	4b33      	ldr	r3, [pc, #204]	; (1003468 <endpoint_cb+0xd4>)
 100339c:	4c33      	ldr	r4, [pc, #204]	; (100346c <endpoint_cb+0xd8>)
	LOG_INF("Received message of %u bytes.", len);
 100339e:	4639      	mov	r1, r7
 10033a0:	1ae4      	subs	r4, r4, r3
 10033a2:	08e4      	lsrs	r4, r4, #3
 10033a4:	01a4      	lsls	r4, r4, #6
 10033a6:	f044 0203 	orr.w	r2, r4, #3
 10033aa:	4831      	ldr	r0, [pc, #196]	; (1003470 <endpoint_cb+0xdc>)
 10033ac:	f011 fffc 	bl	10153a8 <log_1>
	pkt_indicator = *data++;
 10033b0:	4633      	mov	r3, r6
 10033b2:	f813 1b01 	ldrb.w	r1, [r3], #1
	remaining -= sizeof(pkt_indicator);
 10033b6:	1e7a      	subs	r2, r7, #1
	switch (pkt_indicator) {
 10033b8:	2901      	cmp	r1, #1
 10033ba:	d007      	beq.n	10033cc <endpoint_cb+0x38>
 10033bc:	2902      	cmp	r1, #2
 10033be:	d034      	beq.n	100342a <endpoint_cb+0x96>
		LOG_ERR("Unknown HCI type %u", pkt_indicator);
 10033c0:	482c      	ldr	r0, [pc, #176]	; (1003474 <endpoint_cb+0xe0>)
 10033c2:	f044 0201 	orr.w	r2, r4, #1
 10033c6:	f011 ffef 	bl	10153a8 <log_1>
 10033ca:	e006      	b.n	10033da <endpoint_cb+0x46>
	if (remaining < sizeof(*hdr)) {
 10033cc:	2a02      	cmp	r2, #2
 10033ce:	d807      	bhi.n	10033e0 <endpoint_cb+0x4c>
		LOG_ERR("Not enought data for command header");
 10033d0:	4829      	ldr	r0, [pc, #164]	; (1003478 <endpoint_cb+0xe4>)
 10033d2:	f044 0101 	orr.w	r1, r4, #1
		LOG_ERR("No available command buffers!");
 10033d6:	f011 ffda 	bl	101538e <log_0>
	hci_rpmsg_rx((u8_t *) data, len);

	return RPMSG_SUCCESS;
}
 10033da:	2000      	movs	r0, #0
 10033dc:	b003      	add	sp, #12
 10033de:	bdf0      	pop	{r4, r5, r6, r7, pc}
	buf = bt_buf_get_tx(BT_BUF_CMD, K_NO_WAIT, hdr, sizeof(*hdr));
 10033e0:	2203      	movs	r2, #3
 10033e2:	2000      	movs	r0, #0
 10033e4:	e9cd 3200 	strd	r3, r2, [sp]
 10033e8:	2200      	movs	r2, #0
 10033ea:	2300      	movs	r3, #0
 10033ec:	f002 f9fe 	bl	10057ec <bt_buf_get_tx>
	if (buf) {
 10033f0:	4605      	mov	r5, r0
 10033f2:	b160      	cbz	r0, 100340e <endpoint_cb+0x7a>
	if (remaining != hdr->param_len) {
 10033f4:	78f3      	ldrb	r3, [r6, #3]
		remaining -= sizeof(*hdr);
 10033f6:	1f3a      	subs	r2, r7, #4
	if (remaining != hdr->param_len) {
 10033f8:	429a      	cmp	r2, r3
 10033fa:	d00c      	beq.n	1003416 <endpoint_cb+0x82>
		LOG_ERR("Command payload length is not correct");
 10033fc:	481f      	ldr	r0, [pc, #124]	; (100347c <endpoint_cb+0xe8>)
 10033fe:	f044 0101 	orr.w	r1, r4, #1
		LOG_ERR("ACL payload length is not correct");
 1003402:	f011 ffc4 	bl	101538e <log_0>
		net_buf_unref(buf);
 1003406:	4628      	mov	r0, r5
 1003408:	f00f fa96 	bl	1012938 <net_buf_unref>
	if (buf) {
 100340c:	e7e5      	b.n	10033da <endpoint_cb+0x46>
		LOG_ERR("No available command buffers!");
 100340e:	481c      	ldr	r0, [pc, #112]	; (1003480 <endpoint_cb+0xec>)
 1003410:	f044 0101 	orr.w	r1, r4, #1
 1003414:	e7df      	b.n	10033d6 <endpoint_cb+0x42>
	net_buf_add_mem(buf, data, remaining);
 1003416:	1d31      	adds	r1, r6, #4
	net_buf_add_mem(buf, data, remaining);
 1003418:	f105 0008 	add.w	r0, r5, #8
 100341c:	f013 fb57 	bl	1016ace <net_buf_simple_add_mem>
		net_buf_put(&tx_queue, buf);
 1003420:	4629      	mov	r1, r5
 1003422:	4818      	ldr	r0, [pc, #96]	; (1003484 <endpoint_cb+0xf0>)
 1003424:	f013 fb40 	bl	1016aa8 <net_buf_put>
	return RPMSG_SUCCESS;
 1003428:	e7d7      	b.n	10033da <endpoint_cb+0x46>
	if (remaining < sizeof(*hdr)) {
 100342a:	2a03      	cmp	r2, #3
 100342c:	d803      	bhi.n	1003436 <endpoint_cb+0xa2>
		LOG_ERR("Not enought data for ACL header");
 100342e:	4816      	ldr	r0, [pc, #88]	; (1003488 <endpoint_cb+0xf4>)
 1003430:	f044 0101 	orr.w	r1, r4, #1
 1003434:	e7cf      	b.n	10033d6 <endpoint_cb+0x42>
	buf = bt_buf_get_tx(BT_BUF_ACL_OUT, K_NO_WAIT, hdr, sizeof(*hdr));
 1003436:	2204      	movs	r2, #4
 1003438:	4608      	mov	r0, r1
 100343a:	e9cd 3200 	strd	r3, r2, [sp]
 100343e:	2200      	movs	r2, #0
 1003440:	2300      	movs	r3, #0
 1003442:	f002 f9d3 	bl	10057ec <bt_buf_get_tx>
	if (buf) {
 1003446:	4605      	mov	r5, r0
 1003448:	b140      	cbz	r0, 100345c <endpoint_cb+0xc8>
	if (remaining != sys_le16_to_cpu(hdr->len)) {
 100344a:	f8b6 3003 	ldrh.w	r3, [r6, #3]
		remaining -= sizeof(*hdr);
 100344e:	1f7a      	subs	r2, r7, #5
	if (remaining != sys_le16_to_cpu(hdr->len)) {
 1003450:	429a      	cmp	r2, r3
 1003452:	d007      	beq.n	1003464 <endpoint_cb+0xd0>
		LOG_ERR("ACL payload length is not correct");
 1003454:	480d      	ldr	r0, [pc, #52]	; (100348c <endpoint_cb+0xf8>)
 1003456:	f044 0101 	orr.w	r1, r4, #1
 100345a:	e7d2      	b.n	1003402 <endpoint_cb+0x6e>
		LOG_ERR("No available ACL buffers!");
 100345c:	480c      	ldr	r0, [pc, #48]	; (1003490 <endpoint_cb+0xfc>)
 100345e:	f044 0101 	orr.w	r1, r4, #1
 1003462:	e7b8      	b.n	10033d6 <endpoint_cb+0x42>
	net_buf_add_mem(buf, data, remaining);
 1003464:	1d71      	adds	r1, r6, #5
 1003466:	e7d7      	b.n	1003418 <endpoint_cb+0x84>
 1003468:	010180b8 	.word	0x010180b8
 100346c:	01018198 	.word	0x01018198
 1003470:	01018e58 	.word	0x01018e58
 1003474:	01018f3a 	.word	0x01018f3a
 1003478:	01018e76 	.word	0x01018e76
 100347c:	01018eb8 	.word	0x01018eb8
 1003480:	01018e9a 	.word	0x01018e9a
 1003484:	210005b4 	.word	0x210005b4
 1003488:	01018ede 	.word	0x01018ede
 100348c:	01018f18 	.word	0x01018f18
 1003490:	01018efe 	.word	0x01018efe

01003494 <tx_thread>:
{
 1003494:	b570      	push	{r4, r5, r6, lr}
 1003496:	4b0f      	ldr	r3, [pc, #60]	; (10034d4 <tx_thread+0x40>)
 1003498:	4c0f      	ldr	r4, [pc, #60]	; (10034d8 <tx_thread+0x44>)
		buf = net_buf_get(&tx_queue, K_FOREVER);
 100349a:	4e10      	ldr	r6, [pc, #64]	; (10034dc <tx_thread+0x48>)
 100349c:	1ae4      	subs	r4, r4, r3
 100349e:	08e4      	lsrs	r4, r4, #3
			LOG_ERR("Unable to send (err %d)", err);
 10034a0:	01a4      	lsls	r4, r4, #6
 10034a2:	f044 0401 	orr.w	r4, r4, #1
		buf = net_buf_get(&tx_queue, K_FOREVER);
 10034a6:	f04f 32ff 	mov.w	r2, #4294967295
 10034aa:	f04f 33ff 	mov.w	r3, #4294967295
 10034ae:	4630      	mov	r0, r6
 10034b0:	f013 fadc 	bl	1016a6c <net_buf_get>
 10034b4:	4605      	mov	r5, r0
		err = bt_send(buf);
 10034b6:	f013 fa9c 	bl	10169f2 <bt_send>
		if (err) {
 10034ba:	4601      	mov	r1, r0
 10034bc:	b130      	cbz	r0, 10034cc <tx_thread+0x38>
			LOG_ERR("Unable to send (err %d)", err);
 10034be:	4808      	ldr	r0, [pc, #32]	; (10034e0 <tx_thread+0x4c>)
 10034c0:	4622      	mov	r2, r4
 10034c2:	f011 ff71 	bl	10153a8 <log_1>
			net_buf_unref(buf);
 10034c6:	4628      	mov	r0, r5
 10034c8:	f00f fa36 	bl	1012938 <net_buf_unref>
		arch_syscall_invoke0(K_SYSCALL_K_YIELD);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_yield();
 10034cc:	f011 f848 	bl	1014560 <z_impl_k_yield>
	while (1) {
 10034d0:	e7e9      	b.n	10034a6 <tx_thread+0x12>
 10034d2:	bf00      	nop
 10034d4:	010180b8 	.word	0x010180b8
 10034d8:	01018198 	.word	0x01018198
 10034dc:	210005b4 	.word	0x210005b4
 10034e0:	01018f4e 	.word	0x01018f4e

010034e4 <ipm_callback_process>:
	virtqueue_notification(vq[1]);
 10034e4:	4b01      	ldr	r3, [pc, #4]	; (10034ec <ipm_callback_process+0x8>)
 10034e6:	6858      	ldr	r0, [r3, #4]
 10034e8:	f013 bed5 	b.w	1017296 <virtqueue_notification>
 10034ec:	21000864 	.word	0x21000864

010034f0 <virtio_notify>:
	status = ipm_send(ipm_tx_handle, 0, 0, NULL, 0);
 10034f0:	4b0d      	ldr	r3, [pc, #52]	; (1003528 <virtio_notify+0x38>)
{
 10034f2:	b513      	push	{r0, r1, r4, lr}
	status = ipm_send(ipm_tx_handle, 0, 0, NULL, 0);
 10034f4:	6818      	ldr	r0, [r3, #0]
			   const void *data, int size)
{
	const struct ipm_driver_api *api =
		(const struct ipm_driver_api *)ipmdev->driver_api;

	return api->send(ipmdev, wait, id, data, size);
 10034f6:	2300      	movs	r3, #0
 10034f8:	6882      	ldr	r2, [r0, #8]
 10034fa:	9300      	str	r3, [sp, #0]
 10034fc:	4619      	mov	r1, r3
 10034fe:	6814      	ldr	r4, [r2, #0]
 1003500:	461a      	mov	r2, r3
 1003502:	47a0      	blx	r4
	if (status != 0) {
 1003504:	4601      	mov	r1, r0
 1003506:	b160      	cbz	r0, 1003522 <virtio_notify+0x32>
 1003508:	4b08      	ldr	r3, [pc, #32]	; (100352c <virtio_notify+0x3c>)
 100350a:	4a09      	ldr	r2, [pc, #36]	; (1003530 <virtio_notify+0x40>)
		LOG_ERR("ipm_send failed to notify: %d", status);
 100350c:	4809      	ldr	r0, [pc, #36]	; (1003534 <virtio_notify+0x44>)
 100350e:	1ad2      	subs	r2, r2, r3
 1003510:	08d2      	lsrs	r2, r2, #3
 1003512:	0192      	lsls	r2, r2, #6
 1003514:	f042 0201 	orr.w	r2, r2, #1
}
 1003518:	b002      	add	sp, #8
 100351a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		LOG_ERR("ipm_send failed to notify: %d", status);
 100351e:	f011 bf43 	b.w	10153a8 <log_1>
}
 1003522:	b002      	add	sp, #8
 1003524:	bd10      	pop	{r4, pc}
 1003526:	bf00      	nop
 1003528:	21000720 	.word	0x21000720
 100352c:	010180b8 	.word	0x010180b8
 1003530:	01018198 	.word	0x01018198
 1003534:	01018f66 	.word	0x01018f66

01003538 <ipm_callback>:
{
 1003538:	b508      	push	{r3, lr}
 100353a:	4a0e      	ldr	r2, [pc, #56]	; (1003574 <ipm_callback+0x3c>)
 100353c:	4b0e      	ldr	r3, [pc, #56]	; (1003578 <ipm_callback+0x40>)
	LOG_INF("Got callback of id %u", id);
 100353e:	480f      	ldr	r0, [pc, #60]	; (100357c <ipm_callback+0x44>)
 1003540:	1ad2      	subs	r2, r2, r3
 1003542:	08d2      	lsrs	r2, r2, #3
 1003544:	0192      	lsls	r2, r2, #6
 1003546:	f042 0203 	orr.w	r2, r2, #3
 100354a:	f011 ff2d 	bl	10153a8 <log_1>
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_or(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 100354e:	490c      	ldr	r1, [pc, #48]	; (1003580 <ipm_callback+0x48>)
 1003550:	e8d1 3fef 	ldaex	r3, [r1]
 1003554:	f043 0201 	orr.w	r2, r3, #1
 1003558:	e8c1 2fe0 	stlex	r0, r2, [r1]
 100355c:	2800      	cmp	r0, #0
 100355e:	d1f7      	bne.n	1003550 <ipm_callback+0x18>
 * @return N/A
 */
static inline void k_work_submit_to_queue(struct k_work_q *work_q,
					  struct k_work *work)
{
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
 1003560:	07db      	lsls	r3, r3, #31
 1003562:	d405      	bmi.n	1003570 <ipm_callback+0x38>
}
 1003564:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		k_queue_append(&work_q->queue, work);
 1003568:	4806      	ldr	r0, [pc, #24]	; (1003584 <ipm_callback+0x4c>)
 100356a:	3908      	subs	r1, #8
 100356c:	f014 b939 	b.w	10177e2 <k_queue_append>
 1003570:	bd08      	pop	{r3, pc}
 1003572:	bf00      	nop
 1003574:	01018198 	.word	0x01018198
 1003578:	010180b8 	.word	0x010180b8
 100357c:	01018f84 	.word	0x01018f84
 1003580:	2100072c 	.word	0x2100072c
 1003584:	210065f4 	.word	0x210065f4

01003588 <bt_ctlr_assert_handle>:
{
 1003588:	460a      	mov	r2, r1
 100358a:	4b05      	ldr	r3, [pc, #20]	; (10035a0 <bt_ctlr_assert_handle+0x18>)
 100358c:	4905      	ldr	r1, [pc, #20]	; (10035a4 <bt_ctlr_assert_handle+0x1c>)
 100358e:	1a5b      	subs	r3, r3, r1
 1003590:	08db      	lsrs	r3, r3, #3
	LOG_ERR("Controller assert in: %s at %d", file, line);
 1003592:	019b      	lsls	r3, r3, #6
 1003594:	4601      	mov	r1, r0
 1003596:	f043 0301 	orr.w	r3, r3, #1
 100359a:	4803      	ldr	r0, [pc, #12]	; (10035a8 <bt_ctlr_assert_handle+0x20>)
 100359c:	f011 bf18 	b.w	10153d0 <log_2>
 10035a0:	01018198 	.word	0x01018198
 10035a4:	010180b8 	.word	0x010180b8
 10035a8:	01018f9a 	.word	0x01018f9a

010035ac <main>:

	return err;
}

void main(void)
{
 10035ac:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	struct metal_init_params metal_params = METAL_INIT_DEFAULTS;
 10035b0:	4b86      	ldr	r3, [pc, #536]	; (10037cc <main+0x220>)
{
 10035b2:	b08b      	sub	sp, #44	; 0x2c
	struct metal_init_params metal_params = METAL_INIT_DEFAULTS;
 10035b4:	9308      	str	r3, [sp, #32]
 10035b6:	2306      	movs	r3, #6
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
 10035b8:	2200      	movs	r2, #0
 10035ba:	4985      	ldr	r1, [pc, #532]	; (10037d0 <main+0x224>)
 10035bc:	f88d 3024 	strb.w	r3, [sp, #36]	; 0x24
 10035c0:	4b84      	ldr	r3, [pc, #528]	; (10037d4 <main+0x228>)
	err = metal_init(&metal_params);
 10035c2:	a808      	add	r0, sp, #32
 10035c4:	e9c3 1201 	strd	r1, r2, [r3, #4]
 10035c8:	601a      	str	r2, [r3, #0]
 10035ca:	f00f fff7 	bl	10135bc <metal_init>
	if (err) {
 10035ce:	4c82      	ldr	r4, [pc, #520]	; (10037d8 <main+0x22c>)
 10035d0:	4a82      	ldr	r2, [pc, #520]	; (10037dc <main+0x230>)
 10035d2:	4601      	mov	r1, r0
 10035d4:	1b12      	subs	r2, r2, r4
 10035d6:	08d4      	lsrs	r4, r2, #3
 10035d8:	b130      	cbz	r0, 10035e8 <main+0x3c>
		LOG_ERR("metal_init: failed - error code %d", err);
 10035da:	01a2      	lsls	r2, r4, #6
 10035dc:	4880      	ldr	r0, [pc, #512]	; (10037e0 <main+0x234>)
 10035de:	f042 0201 	orr.w	r2, r2, #1
		LOG_ERR("rpmsg_create_ept failed %d", err);
 10035e2:	f011 fee1 	bl	10153a8 <log_1>
		return err;
 10035e6:	e024      	b.n	1003632 <main+0x86>
	err = metal_register_generic_device(&shm_device);
 10035e8:	487e      	ldr	r0, [pc, #504]	; (10037e4 <main+0x238>)
 10035ea:	f00f ffc7 	bl	101357c <metal_register_generic_device>
	if (err) {
 10035ee:	4601      	mov	r1, r0
 10035f0:	b120      	cbz	r0, 10035fc <main+0x50>
		LOG_ERR("Couldn't register shared memory device: %d", err);
 10035f2:	01a2      	lsls	r2, r4, #6
 10035f4:	487c      	ldr	r0, [pc, #496]	; (10037e8 <main+0x23c>)
 10035f6:	f042 0201 	orr.w	r2, r2, #1
 10035fa:	e7f2      	b.n	10035e2 <main+0x36>
	err = metal_device_open("generic", SHM_DEVICE_NAME, &device);
 10035fc:	4e7b      	ldr	r6, [pc, #492]	; (10037ec <main+0x240>)
 10035fe:	497c      	ldr	r1, [pc, #496]	; (10037f0 <main+0x244>)
 1003600:	4632      	mov	r2, r6
 1003602:	487c      	ldr	r0, [pc, #496]	; (10037f4 <main+0x248>)
 1003604:	f013 fbc0 	bl	1016d88 <metal_device_open>
	if (err) {
 1003608:	4605      	mov	r5, r0
 100360a:	b128      	cbz	r0, 1003618 <main+0x6c>
		LOG_ERR("metal_device_open failed: %d", err);
 100360c:	01a2      	lsls	r2, r4, #6
 100360e:	4601      	mov	r1, r0
 1003610:	f042 0201 	orr.w	r2, r2, #1
 1003614:	4878      	ldr	r0, [pc, #480]	; (10037f8 <main+0x24c>)
 1003616:	e7e4      	b.n	10035e2 <main+0x36>
	io = metal_device_io_region(device, 0);
 1003618:	6833      	ldr	r3, [r6, #0]
 * @return I/O accessor handle, or NULL on failure.
 */
static inline struct metal_io_region *
metal_device_io_region(struct metal_device *device, unsigned int index)
{
	return (index < device->num_regions
 100361a:	f8df 824c 	ldr.w	r8, [pc, #588]	; 1003868 <main+0x2bc>
		? &device->regions[index]
		: NULL);
 100361e:	689a      	ldr	r2, [r3, #8]
 1003620:	b952      	cbnz	r2, 1003638 <main+0x8c>
 1003622:	f8c8 2000 	str.w	r2, [r8]
		LOG_ERR("metal_device_io_region failed to get region");
 1003626:	01a1      	lsls	r1, r4, #6
 1003628:	4874      	ldr	r0, [pc, #464]	; (10037fc <main+0x250>)
 100362a:	f041 0101 	orr.w	r1, r1, #1
		LOG_ERR("virtqueue_allocate failed to alloc vq[1]");
 100362e:	f011 feae 	bl	101538e <log_0>
		err = hci_rpmsg_send(buf);
		if (err) {
			LOG_ERR("Failed to send (err %d)", err);
		}
	}
}
 1003632:	b00b      	add	sp, #44	; 0x2c
 1003634:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 1003638:	330c      	adds	r3, #12
	io = metal_device_io_region(device, 0);
 100363a:	f8c8 3000 	str.w	r3, [r8]
	if (!io) {
 100363e:	2b00      	cmp	r3, #0
 1003640:	d0f1      	beq.n	1003626 <main+0x7a>
	if (z_syscall_trap()) {
		return (struct device *) arch_syscall_invoke1(*(uintptr_t *)&name, K_SYSCALL_DEVICE_GET_BINDING);
	}
#endif
	compiler_barrier();
	return z_impl_device_get_binding(name);
 1003642:	486f      	ldr	r0, [pc, #444]	; (1003800 <main+0x254>)
 1003644:	f010 faa8 	bl	1013b98 <z_impl_device_get_binding>
	ipm_tx_handle = device_get_binding("IPM_1");
 1003648:	4b6e      	ldr	r3, [pc, #440]	; (1003804 <main+0x258>)
 100364a:	6018      	str	r0, [r3, #0]
	if (!ipm_tx_handle) {
 100364c:	b920      	cbnz	r0, 1003658 <main+0xac>
		LOG_ERR("Could not get TX IPM device handle");
 100364e:	01a1      	lsls	r1, r4, #6
 1003650:	486d      	ldr	r0, [pc, #436]	; (1003808 <main+0x25c>)
 1003652:	f041 0101 	orr.w	r1, r1, #1
 1003656:	e7ea      	b.n	100362e <main+0x82>
 1003658:	486c      	ldr	r0, [pc, #432]	; (100380c <main+0x260>)
 100365a:	f010 fa9d 	bl	1013b98 <z_impl_device_get_binding>
	if (!ipm_rx_handle) {
 100365e:	b920      	cbnz	r0, 100366a <main+0xbe>
		LOG_ERR("Could not get RX IPM device handle");
 1003660:	01a1      	lsls	r1, r4, #6
 1003662:	486b      	ldr	r0, [pc, #428]	; (1003810 <main+0x264>)
 1003664:	f041 0101 	orr.w	r1, r1, #1
 1003668:	e7e1      	b.n	100362e <main+0x82>
					 ipm_callback_t cb, void *context)
{
	const struct ipm_driver_api *api =
		(const struct ipm_driver_api *)ipmdev->driver_api;

	api->register_callback(ipmdev, cb, context);
 100366a:	6883      	ldr	r3, [r0, #8]
 100366c:	462a      	mov	r2, r5
 100366e:	685b      	ldr	r3, [r3, #4]
 1003670:	4968      	ldr	r1, [pc, #416]	; (1003814 <main+0x268>)
 1003672:	4798      	blx	r3
#endif

#if (CONFIG_HEAP_MEM_POOL_SIZE > 0)
static inline void *metal_allocate_memory(unsigned int size)
{
	return k_malloc(size);
 1003674:	20b4      	movs	r0, #180	; 0xb4
 1003676:	f010 fc8b 	bl	1013f90 <k_malloc>
	struct virtqueue *vqs;
	uint32_t vq_size = sizeof(struct virtqueue) +
		 num_desc_extra * sizeof(struct vq_desc_extra);

	vqs = metal_allocate_memory(vq_size);
	if (vqs) {
 100367a:	4607      	mov	r7, r0
 100367c:	b118      	cbz	r0, 1003686 <main+0xda>
		memset(vqs, 0x00, vq_size);
 100367e:	22b4      	movs	r2, #180	; 0xb4
 1003680:	4629      	mov	r1, r5
 1003682:	f013 f944 	bl	101690e <memset>
	vq[0] = virtqueue_allocate(VRING_SIZE);
 1003686:	4e64      	ldr	r6, [pc, #400]	; (1003818 <main+0x26c>)
 1003688:	6037      	str	r7, [r6, #0]
	if (!vq[0]) {
 100368a:	b927      	cbnz	r7, 1003696 <main+0xea>
		LOG_ERR("virtqueue_allocate failed to alloc vq[0]");
 100368c:	01a1      	lsls	r1, r4, #6
 100368e:	4863      	ldr	r0, [pc, #396]	; (100381c <main+0x270>)
 1003690:	f041 0101 	orr.w	r1, r1, #1
 1003694:	e7cb      	b.n	100362e <main+0x82>
 1003696:	20b4      	movs	r0, #180	; 0xb4
 1003698:	f010 fc7a 	bl	1013f90 <k_malloc>
	if (vqs) {
 100369c:	4605      	mov	r5, r0
 100369e:	b118      	cbz	r0, 10036a8 <main+0xfc>
		memset(vqs, 0x00, vq_size);
 10036a0:	22b4      	movs	r2, #180	; 0xb4
 10036a2:	2100      	movs	r1, #0
 10036a4:	f013 f933 	bl	101690e <memset>
	vq[1] = virtqueue_allocate(VRING_SIZE);
 10036a8:	6075      	str	r5, [r6, #4]
	if (!vq[1]) {
 10036aa:	b925      	cbnz	r5, 10036b6 <main+0x10a>
		LOG_ERR("virtqueue_allocate failed to alloc vq[1]");
 10036ac:	01a1      	lsls	r1, r4, #6
 10036ae:	485c      	ldr	r0, [pc, #368]	; (1003820 <main+0x274>)
 10036b0:	f041 0101 	orr.w	r1, r1, #1
 10036b4:	e7bb      	b.n	100362e <main+0x82>
	rvrings[0].info.num_descs = VRING_SIZE;
 10036b6:	2010      	movs	r0, #16
	rvrings[0].io = io;
 10036b8:	4a5a      	ldr	r2, [pc, #360]	; (1003824 <main+0x278>)
	rvrings[0].info.vaddr = (void *)VRING_TX_ADDRESS;
 10036ba:	495b      	ldr	r1, [pc, #364]	; (1003828 <main+0x27c>)
	rvrings[0].info.num_descs = VRING_SIZE;
 10036bc:	8190      	strh	r0, [r2, #12]
	rvrings[0].info.vaddr = (void *)VRING_TX_ADDRESS;
 10036be:	6051      	str	r1, [r2, #4]
	rvrings[0].info.align = VRING_ALIGNMENT;
 10036c0:	2104      	movs	r1, #4
	rvrings[1].info.num_descs = VRING_SIZE;
 10036c2:	8490      	strh	r0, [r2, #36]	; 0x24
	vdev.role = RPMSG_REMOTE;
 10036c4:	2001      	movs	r0, #1
	rvrings[0].vq = vq[0];
 10036c6:	6836      	ldr	r6, [r6, #0]
	rvrings[0].info.align = VRING_ALIGNMENT;
 10036c8:	6091      	str	r1, [r2, #8]
	rvrings[1].info.align = VRING_ALIGNMENT;
 10036ca:	6211      	str	r1, [r2, #32]
	vdev.role = RPMSG_REMOTE;
 10036cc:	4957      	ldr	r1, [pc, #348]	; (100382c <main+0x280>)
	rvrings[0].io = io;
 10036ce:	f8d8 3000 	ldr.w	r3, [r8]
	rvrings[0].vq = vq[0];
 10036d2:	6016      	str	r6, [r2, #0]
	vdev.role = RPMSG_REMOTE;
 10036d4:	6188      	str	r0, [r1, #24]
	rvrings[1].info.vaddr = (void *)VRING_RX_ADDRESS;
 10036d6:	4e56      	ldr	r6, [pc, #344]	; (1003830 <main+0x284>)
	vdev.vrings_num = VRING_COUNT;
 10036d8:	2002      	movs	r0, #2
	vdev.vrings_info = &rvrings[0];
 10036da:	62ca      	str	r2, [r1, #44]	; 0x2c
	rvrings[0].io = io;
 10036dc:	6153      	str	r3, [r2, #20]
	rvrings[1].io = io;
 10036de:	62d3      	str	r3, [r2, #44]	; 0x2c
	rvrings[1].info.vaddr = (void *)VRING_RX_ADDRESS;
 10036e0:	61d6      	str	r6, [r2, #28]
	rvrings[1].vq = vq[1];
 10036e2:	6195      	str	r5, [r2, #24]
	err = rpmsg_init_vdev(&rvdev, &vdev, NULL, io, NULL);
 10036e4:	2200      	movs	r2, #0
	vdev.vrings_num = VRING_COUNT;
 10036e6:	6288      	str	r0, [r1, #40]	; 0x28
	vdev.func = &dispatch;
 10036e8:	4852      	ldr	r0, [pc, #328]	; (1003834 <main+0x288>)
 10036ea:	6208      	str	r0, [r1, #32]
	err = rpmsg_init_vdev(&rvdev, &vdev, NULL, io, NULL);
 10036ec:	4852      	ldr	r0, [pc, #328]	; (1003838 <main+0x28c>)
 10036ee:	9200      	str	r2, [sp, #0]
 10036f0:	f010 f95a 	bl	10139a8 <rpmsg_init_vdev>
	if (err) {
 10036f4:	4601      	mov	r1, r0
 10036f6:	b120      	cbz	r0, 1003702 <main+0x156>
		LOG_ERR("rpmsg_init_vdev failed %d", err);
 10036f8:	01a2      	lsls	r2, r4, #6
 10036fa:	4850      	ldr	r0, [pc, #320]	; (100383c <main+0x290>)
 10036fc:	f042 0201 	orr.w	r2, r2, #1
 1003700:	e76f      	b.n	10035e2 <main+0x36>
	err = rpmsg_create_ept(&ep, rdev, "bt_hci", RPMSG_ADDR_ANY,
 1003702:	4b4f      	ldr	r3, [pc, #316]	; (1003840 <main+0x294>)
 1003704:	4a4f      	ldr	r2, [pc, #316]	; (1003844 <main+0x298>)
 1003706:	9302      	str	r3, [sp, #8]
 1003708:	4b4f      	ldr	r3, [pc, #316]	; (1003848 <main+0x29c>)
 100370a:	494b      	ldr	r1, [pc, #300]	; (1003838 <main+0x28c>)
 100370c:	9301      	str	r3, [sp, #4]
 100370e:	f04f 33ff 	mov.w	r3, #4294967295
 1003712:	484e      	ldr	r0, [pc, #312]	; (100384c <main+0x2a0>)
 1003714:	9300      	str	r3, [sp, #0]
 1003716:	f010 f815 	bl	1013744 <rpmsg_create_ept>
	if (err) {
 100371a:	4605      	mov	r5, r0
 100371c:	2800      	cmp	r0, #0
 100371e:	d039      	beq.n	1003794 <main+0x1e8>
		LOG_ERR("rpmsg_create_ept failed %d", err);
 1003720:	01a2      	lsls	r2, r4, #6
 1003722:	4601      	mov	r1, r0
 1003724:	f042 0201 	orr.w	r2, r2, #1
 1003728:	4849      	ldr	r0, [pc, #292]	; (1003850 <main+0x2a4>)
 100372a:	e75a      	b.n	10035e2 <main+0x36>
	switch (bt_buf_get_type(buf)) {
 100372c:	2104      	movs	r1, #4
	net_buf_push_u8(buf, pkt_indicator);
 100372e:	f105 0008 	add.w	r0, r5, #8
 1003732:	f013 f9d5 	bl	1016ae0 <net_buf_simple_push_u8>
 * Returns number of bytes it has sent or negative error value on failure.
 */
static inline int rpmsg_send(struct rpmsg_endpoint *ept, const void *data,
			     int len)
{
	if (ept->dest_addr == RPMSG_ADDR_ANY)
 1003736:	6aba      	ldr	r2, [r7, #40]	; 0x28
	rpmsg_send(&ep, buf->data, buf->len);
 1003738:	68ab      	ldr	r3, [r5, #8]
 100373a:	1c50      	adds	r0, r2, #1
 100373c:	89a9      	ldrh	r1, [r5, #12]
 100373e:	d006      	beq.n	100374e <main+0x1a2>
		return RPMSG_ERR_ADDR;
	return rpmsg_send_offchannel_raw(ept, ept->addr, ept->dest_addr, data,
 1003740:	2001      	movs	r0, #1
 1003742:	e9cd 1000 	strd	r1, r0, [sp]
 1003746:	4638      	mov	r0, r7
 1003748:	6a79      	ldr	r1, [r7, #36]	; 0x24
 100374a:	f00f ffe9 	bl	1013720 <rpmsg_send_offchannel_raw>
	net_buf_unref(buf);
 100374e:	4628      	mov	r0, r5
 1003750:	f00f f8f2 	bl	1012938 <net_buf_unref>
		buf = net_buf_get(&rx_queue, K_FOREVER);
 1003754:	f04f 32ff 	mov.w	r2, #4294967295
 1003758:	f04f 33ff 	mov.w	r3, #4294967295
 100375c:	4648      	mov	r0, r9
 100375e:	f013 f985 	bl	1016a6c <net_buf_get>
	 * pointer to an enum causes issues on qemu_x86 because the true
	 * size is 8-bit, but the enum is 32-bit on qemu_x86. So we put in
	 * a temporary cast to 8-bit to ensure only 8 bits are read from
	 * the pointer.
	 */
	return (enum bt_buf_type)(*(u8_t *)net_buf_user_data(buf));
 1003762:	7d01      	ldrb	r1, [r0, #20]
 1003764:	4605      	mov	r5, r0
	switch (bt_buf_get_type(buf)) {
 1003766:	2901      	cmp	r1, #1
 1003768:	d0e0      	beq.n	100372c <main+0x180>
 100376a:	2903      	cmp	r1, #3
 100376c:	d010      	beq.n	1003790 <main+0x1e4>
		LOG_ERR("Unknown type %u", bt_buf_get_type(buf));
 100376e:	01a6      	lsls	r6, r4, #6
 1003770:	f046 0601 	orr.w	r6, r6, #1
 1003774:	4632      	mov	r2, r6
 1003776:	4640      	mov	r0, r8
 1003778:	f011 fe16 	bl	10153a8 <log_1>
		net_buf_unref(buf);
 100377c:	4628      	mov	r0, r5
 100377e:	f00f f8db 	bl	1012938 <net_buf_unref>
			LOG_ERR("Failed to send (err %d)", err);
 1003782:	4632      	mov	r2, r6
 1003784:	f06f 0115 	mvn.w	r1, #21
 1003788:	4832      	ldr	r0, [pc, #200]	; (1003854 <main+0x2a8>)
 100378a:	f011 fe0d 	bl	10153a8 <log_1>
 100378e:	e7e1      	b.n	1003754 <main+0x1a8>
		pkt_indicator = HCI_RPMSG_ACL;
 1003790:	2102      	movs	r1, #2
 1003792:	e7cc      	b.n	100372e <main+0x182>
	bt_enable_raw(&rx_queue);
 1003794:	4830      	ldr	r0, [pc, #192]	; (1003858 <main+0x2ac>)
 1003796:	f002 f86f 	bl	1005878 <bt_enable_raw>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 100379a:	2200      	movs	r2, #0
 100379c:	2300      	movs	r3, #0
 100379e:	e9cd 2306 	strd	r2, r3, [sp, #24]
 10037a2:	f06f 0308 	mvn.w	r3, #8
 10037a6:	f44f 6280 	mov.w	r2, #1024	; 0x400
 10037aa:	e9cd 5302 	strd	r5, r3, [sp, #8]
 10037ae:	e9cd 5500 	strd	r5, r5, [sp]
 10037b2:	4b2a      	ldr	r3, [pc, #168]	; (100385c <main+0x2b0>)
 10037b4:	492a      	ldr	r1, [pc, #168]	; (1003860 <main+0x2b4>)
 10037b6:	482b      	ldr	r0, [pc, #172]	; (1003864 <main+0x2b8>)
 10037b8:	9504      	str	r5, [sp, #16]
 10037ba:	f010 ffd3 	bl	1014764 <z_impl_k_thread_create>
		buf = net_buf_get(&rx_queue, K_FOREVER);
 10037be:	f8df 9098 	ldr.w	r9, [pc, #152]	; 1003858 <main+0x2ac>
	if (ept->dest_addr == RPMSG_ADDR_ANY)
 10037c2:	4f22      	ldr	r7, [pc, #136]	; (100384c <main+0x2a0>)
		LOG_ERR("Unknown type %u", bt_buf_get_type(buf));
 10037c4:	f8df 80a4 	ldr.w	r8, [pc, #164]	; 100386c <main+0x2c0>
 10037c8:	e7c4      	b.n	1003754 <main+0x1a8>
 10037ca:	bf00      	nop
 10037cc:	0101360d 	.word	0x0101360d
 10037d0:	010034e5 	.word	0x010034e5
 10037d4:	21000724 	.word	0x21000724
 10037d8:	010180b8 	.word	0x010180b8
 10037dc:	01018198 	.word	0x01018198
 10037e0:	01018fb9 	.word	0x01018fb9
 10037e4:	21000010 	.word	0x21000010
 10037e8:	01018fdc 	.word	0x01018fdc
 10037ec:	210006d8 	.word	0x210006d8
 10037f0:	01019007 	.word	0x01019007
 10037f4:	01019011 	.word	0x01019011
 10037f8:	01019019 	.word	0x01019019
 10037fc:	01019036 	.word	0x01019036
 1003800:	0101983a 	.word	0x0101983a
 1003804:	21000720 	.word	0x21000720
 1003808:	01019062 	.word	0x01019062
 100380c:	01019085 	.word	0x01019085
 1003810:	0101908b 	.word	0x0101908b
 1003814:	01003539 	.word	0x01003539
 1003818:	21000864 	.word	0x21000864
 100381c:	010190ae 	.word	0x010190ae
 1003820:	010190d7 	.word	0x010190d7
 1003824:	210007c0 	.word	0x210007c0
 1003828:	20077c00 	.word	0x20077c00
 100382c:	21000660 	.word	0x21000660
 1003830:	20077800 	.word	0x20077800
 1003834:	01018208 	.word	0x01018208
 1003838:	21000730 	.word	0x21000730
 100383c:	01019100 	.word	0x01019100
 1003840:	01014d8d 	.word	0x01014d8d
 1003844:	0101911a 	.word	0x0101911a
 1003848:	01003395 	.word	0x01003395
 100384c:	210006dc 	.word	0x210006dc
 1003850:	01019121 	.word	0x01019121
 1003854:	0101914c 	.word	0x0101914c
 1003858:	2100059c 	.word	0x2100059c
 100385c:	01003495 	.word	0x01003495
 1003860:	21006700 	.word	0x21006700
 1003864:	210007f0 	.word	0x210007f0
 1003868:	2100071c 	.word	0x2100071c
 100386c:	0101913c 	.word	0x0101913c

01003870 <char_out>:

static int char_out(int c, void *ctx_p)
{
	struct out_context *ctx = ctx_p;

	ctx->count++;
 1003870:	680b      	ldr	r3, [r1, #0]
 1003872:	3301      	adds	r3, #1
 1003874:	600b      	str	r3, [r1, #0]
	return _char_out(c);
 1003876:	4b01      	ldr	r3, [pc, #4]	; (100387c <char_out+0xc>)
 1003878:	681b      	ldr	r3, [r3, #0]
 100387a:	4718      	bx	r3
 100387c:	21000068 	.word	0x21000068

01003880 <_printk_dec_ulong>:
 * @return N/A
 */
static void _printk_dec_ulong(out_func_t out, void *ctx,
			      const unsigned long num, enum pad_type padding,
			      int min_width)
{
 1003880:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1003884:	b085      	sub	sp, #20
 1003886:	9c0e      	ldr	r4, [sp, #56]	; 0x38
 1003888:	469b      	mov	fp, r3
 100388a:	2c01      	cmp	r4, #1
 100388c:	bfb8      	it	lt
 100388e:	2401      	movlt	r4, #1
 1003890:	2b01      	cmp	r3, #1
 1003892:	bf0c      	ite	eq
 1003894:	2330      	moveq	r3, #48	; 0x30
 1003896:	2320      	movne	r3, #32
 1003898:	4615      	mov	r5, r2
 100389a:	4606      	mov	r6, r0
 100389c:	468a      	mov	sl, r1
 100389e:	2701      	movs	r7, #1
 10038a0:	f04f 080a 	mov.w	r8, #10
 10038a4:	2200      	movs	r2, #0
 10038a6:	f8df 9070 	ldr.w	r9, [pc, #112]	; 1003918 <_printk_dec_ulong+0x98>
 10038aa:	9302      	str	r3, [sp, #8]
	if (min_width <= 0) {
		min_width = 1;
	}

	while (pos >= 10) {
		if (found_largest_digit != 0 || remainder >= pos) {
 10038ac:	fbb5 f3f9 	udiv	r3, r5, r9
 10038b0:	9301      	str	r3, [sp, #4]
 10038b2:	b90a      	cbnz	r2, 10038b8 <_printk_dec_ulong+0x38>
 10038b4:	45a9      	cmp	r9, r5
 10038b6:	d81e      	bhi.n	10038f6 <_printk_dec_ulong+0x76>
			found_largest_digit = 1;
			out((int)(remainder / pos + 48), ctx);
 10038b8:	9b01      	ldr	r3, [sp, #4]
 10038ba:	4651      	mov	r1, sl
 10038bc:	f103 0030 	add.w	r0, r3, #48	; 0x30
 10038c0:	47b0      	blx	r6
			found_largest_digit = 1;
 10038c2:	2201      	movs	r2, #1
			digits++;
 10038c4:	3701      	adds	r7, #1
				&& padding < PAD_SPACE_AFTER) {
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
			digits++;
		}
		remaining--;
		remainder %= pos;
 10038c6:	9b01      	ldr	r3, [sp, #4]
		remaining--;
 10038c8:	f108 38ff 	add.w	r8, r8, #4294967295
		remainder %= pos;
 10038cc:	fb09 5513 	mls	r5, r9, r3, r5
		pos /= 10;
 10038d0:	230a      	movs	r3, #10
	while (pos >= 10) {
 10038d2:	f1b8 0f01 	cmp.w	r8, #1
		pos /= 10;
 10038d6:	fbb9 f9f3 	udiv	r9, r9, r3
	while (pos >= 10) {
 10038da:	d1e7      	bne.n	10038ac <_printk_dec_ulong+0x2c>
	}
	out((int)(remainder + 48), ctx);
 10038dc:	4651      	mov	r1, sl
 10038de:	f105 0030 	add.w	r0, r5, #48	; 0x30
 10038e2:	47b0      	blx	r6

	if (padding == PAD_SPACE_AFTER) {
 10038e4:	f1bb 0f03 	cmp.w	fp, #3
 10038e8:	d102      	bne.n	10038f0 <_printk_dec_ulong+0x70>
		remaining = min_width - digits;
 10038ea:	1be4      	subs	r4, r4, r7
		while (remaining-- > 0) {
 10038ec:	2c00      	cmp	r4, #0
 10038ee:	dc0e      	bgt.n	100390e <_printk_dec_ulong+0x8e>
			out(' ', ctx);
		}
	}
}
 10038f0:	b005      	add	sp, #20
 10038f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		} else if (remaining <= min_width
 10038f6:	4544      	cmp	r4, r8
 10038f8:	dbe5      	blt.n	10038c6 <_printk_dec_ulong+0x46>
				&& padding < PAD_SPACE_AFTER) {
 10038fa:	f1bb 0f02 	cmp.w	fp, #2
 10038fe:	d8e2      	bhi.n	10038c6 <_printk_dec_ulong+0x46>
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
 1003900:	4651      	mov	r1, sl
 1003902:	9802      	ldr	r0, [sp, #8]
 1003904:	9203      	str	r2, [sp, #12]
			digits++;
 1003906:	3701      	adds	r7, #1
			out((int)(padding == PAD_ZERO_BEFORE ? '0' : ' '), ctx);
 1003908:	47b0      	blx	r6
			digits++;
 100390a:	9a03      	ldr	r2, [sp, #12]
 100390c:	e7db      	b.n	10038c6 <_printk_dec_ulong+0x46>
			out(' ', ctx);
 100390e:	4651      	mov	r1, sl
 1003910:	2020      	movs	r0, #32
 1003912:	47b0      	blx	r6
 1003914:	3c01      	subs	r4, #1
 1003916:	e7e9      	b.n	10038ec <_printk_dec_ulong+0x6c>
 1003918:	3b9aca00 	.word	0x3b9aca00

0100391c <__printk_hook_install>:
	_char_out = fn;
 100391c:	4b01      	ldr	r3, [pc, #4]	; (1003924 <__printk_hook_install+0x8>)
 100391e:	6018      	str	r0, [r3, #0]
}
 1003920:	4770      	bx	lr
 1003922:	bf00      	nop
 1003924:	21000068 	.word	0x21000068

01003928 <z_vprintk>:
{
 1003928:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	char length_mod = 0;
 100392c:	2700      	movs	r7, #0
{
 100392e:	4605      	mov	r5, r0
 1003930:	468b      	mov	fp, r1
	int min_width = -1;
 1003932:	f04f 39ff 	mov.w	r9, #4294967295
	enum pad_type padding = PAD_NONE;
 1003936:	46b8      	mov	r8, r7
{
 1003938:	461c      	mov	r4, r3
 100393a:	b08d      	sub	sp, #52	; 0x34
 100393c:	1e53      	subs	r3, r2, #1
 100393e:	9303      	str	r3, [sp, #12]
			might_format = 0;
 1003940:	2600      	movs	r6, #0
					break;
 1003942:	e005      	b.n	1003950 <z_vprintk+0x28>
		if (!might_format) {
 1003944:	b96e      	cbnz	r6, 1003962 <z_vprintk+0x3a>
			if (*fmt != '%') {
 1003946:	2825      	cmp	r0, #37	; 0x25
 1003948:	f000 8171 	beq.w	1003c2e <z_vprintk+0x306>
				out((int)*fmt, ctx);
 100394c:	4659      	mov	r1, fp
 100394e:	47a8      	blx	r5
	while (*fmt) {
 1003950:	9b03      	ldr	r3, [sp, #12]
 1003952:	f813 0f01 	ldrb.w	r0, [r3, #1]!
 1003956:	9303      	str	r3, [sp, #12]
 1003958:	2800      	cmp	r0, #0
 100395a:	d1f3      	bne.n	1003944 <z_vprintk+0x1c>
}
 100395c:	b00d      	add	sp, #52	; 0x34
 100395e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			switch (*fmt) {
 1003962:	287a      	cmp	r0, #122	; 0x7a
 1003964:	d80a      	bhi.n	100397c <z_vprintk+0x54>
 1003966:	2862      	cmp	r0, #98	; 0x62
 1003968:	d810      	bhi.n	100398c <z_vprintk+0x64>
 100396a:	2830      	cmp	r0, #48	; 0x30
 100396c:	d054      	beq.n	1003a18 <z_vprintk+0xf0>
 100396e:	d845      	bhi.n	10039fc <z_vprintk+0xd4>
 1003970:	2825      	cmp	r0, #37	; 0x25
 1003972:	f000 815a 	beq.w	1003c2a <z_vprintk+0x302>
 1003976:	282d      	cmp	r0, #45	; 0x2d
 1003978:	f000 815f 	beq.w	1003c3a <z_vprintk+0x312>
					out((int)'%', ctx);
 100397c:	4659      	mov	r1, fp
 100397e:	2025      	movs	r0, #37	; 0x25
 1003980:	47a8      	blx	r5
					out((int)*fmt, ctx);
 1003982:	4659      	mov	r1, fp
 1003984:	9b03      	ldr	r3, [sp, #12]
 1003986:	7818      	ldrb	r0, [r3, #0]
 1003988:	47a8      	blx	r5
 100398a:	e7d9      	b.n	1003940 <z_vprintk+0x18>
 100398c:	f1a0 0363 	sub.w	r3, r0, #99	; 0x63
 1003990:	2b17      	cmp	r3, #23
 1003992:	d8f3      	bhi.n	100397c <z_vprintk+0x54>
 1003994:	a201      	add	r2, pc, #4	; (adr r2, 100399c <z_vprintk+0x74>)
 1003996:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 100399a:	bf00      	nop
 100399c:	01003c23 	.word	0x01003c23
 10039a0:	01003a67 	.word	0x01003a67
 10039a4:	0100397d 	.word	0x0100397d
 10039a8:	0100397d 	.word	0x0100397d
 10039ac:	0100397d 	.word	0x0100397d
 10039b0:	01003a49 	.word	0x01003a49
 10039b4:	01003a67 	.word	0x01003a67
 10039b8:	0100397d 	.word	0x0100397d
 10039bc:	0100397d 	.word	0x0100397d
 10039c0:	01003a49 	.word	0x01003a49
 10039c4:	0100397d 	.word	0x0100397d
 10039c8:	0100397d 	.word	0x0100397d
 10039cc:	0100397d 	.word	0x0100397d
 10039d0:	01003b09 	.word	0x01003b09
 10039d4:	0100397d 	.word	0x0100397d
 10039d8:	0100397d 	.word	0x0100397d
 10039dc:	01003bf3 	.word	0x01003bf3
 10039e0:	0100397d 	.word	0x0100397d
 10039e4:	01003ad7 	.word	0x01003ad7
 10039e8:	0100397d 	.word	0x0100397d
 10039ec:	0100397d 	.word	0x0100397d
 10039f0:	01003a05 	.word	0x01003a05
 10039f4:	0100397d 	.word	0x0100397d
 10039f8:	01003a49 	.word	0x01003a49
			switch (*fmt) {
 10039fc:	2839      	cmp	r0, #57	; 0x39
 10039fe:	d91a      	bls.n	1003a36 <z_vprintk+0x10e>
 1003a00:	2858      	cmp	r0, #88	; 0x58
 1003a02:	d1bb      	bne.n	100397c <z_vprintk+0x54>
				if (*fmt == 'p') {
 1003a04:	9b03      	ldr	r3, [sp, #12]
 1003a06:	781b      	ldrb	r3, [r3, #0]
 1003a08:	2b70      	cmp	r3, #112	; 0x70
 1003a0a:	f040 8088 	bne.w	1003b1e <z_vprintk+0x1f6>
					x = va_arg(ap, unsigned int);
 1003a0e:	f854 3b04 	ldr.w	r3, [r4], #4
 1003a12:	2200      	movs	r2, #0
 1003a14:	9306      	str	r3, [sp, #24]
 1003a16:	e090      	b.n	1003b3a <z_vprintk+0x212>
				if (min_width < 0 && padding == PAD_NONE) {
 1003a18:	f1b9 0f00 	cmp.w	r9, #0
 1003a1c:	da0e      	bge.n	1003a3c <z_vprintk+0x114>
 1003a1e:	f1b8 0f00 	cmp.w	r8, #0
 1003a22:	f000 810d 	beq.w	1003c40 <z_vprintk+0x318>
					min_width = *fmt - '0';
 1003a26:	f1a0 0930 	sub.w	r9, r0, #48	; 0x30
					padding = PAD_SPACE_BEFORE;
 1003a2a:	f1b8 0f00 	cmp.w	r8, #0
 1003a2e:	bf08      	it	eq
 1003a30:	f04f 0802 	moveq.w	r8, #2
 1003a34:	e78c      	b.n	1003950 <z_vprintk+0x28>
				if (min_width < 0) {
 1003a36:	f1b9 0f00 	cmp.w	r9, #0
 1003a3a:	dbf4      	blt.n	1003a26 <z_vprintk+0xfe>
					min_width = 10 * min_width + *fmt - '0';
 1003a3c:	230a      	movs	r3, #10
 1003a3e:	fb03 0909 	mla	r9, r3, r9, r0
 1003a42:	f1a9 0930 	sub.w	r9, r9, #48	; 0x30
 1003a46:	e7f0      	b.n	1003a2a <z_vprintk+0x102>
				if (*fmt == 'h' && length_mod == 'h') {
 1003a48:	2868      	cmp	r0, #104	; 0x68
 1003a4a:	d103      	bne.n	1003a54 <z_vprintk+0x12c>
 1003a4c:	2f68      	cmp	r7, #104	; 0x68
 1003a4e:	d106      	bne.n	1003a5e <z_vprintk+0x136>
					length_mod = 'H';
 1003a50:	2748      	movs	r7, #72	; 0x48
 1003a52:	e77d      	b.n	1003950 <z_vprintk+0x28>
				} else if (*fmt == 'l' && length_mod == 'l') {
 1003a54:	286c      	cmp	r0, #108	; 0x6c
 1003a56:	d102      	bne.n	1003a5e <z_vprintk+0x136>
 1003a58:	2f6c      	cmp	r7, #108	; 0x6c
 1003a5a:	f000 80f4 	beq.w	1003c46 <z_vprintk+0x31e>
				} else if (length_mod == 0) {
 1003a5e:	2f00      	cmp	r7, #0
 1003a60:	d18c      	bne.n	100397c <z_vprintk+0x54>
 1003a62:	4607      	mov	r7, r0
 1003a64:	e774      	b.n	1003950 <z_vprintk+0x28>
				if (length_mod == 'z') {
 1003a66:	2f7a      	cmp	r7, #122	; 0x7a
 1003a68:	d102      	bne.n	1003a70 <z_vprintk+0x148>
					d = va_arg(ap, int);
 1003a6a:	f854 6b04 	ldr.w	r6, [r4], #4
 1003a6e:	e021      	b.n	1003ab4 <z_vprintk+0x18c>
				} else if (length_mod == 'l') {
 1003a70:	2f6c      	cmp	r7, #108	; 0x6c
 1003a72:	d0fa      	beq.n	1003a6a <z_vprintk+0x142>
				} else if (length_mod == 'L') {
 1003a74:	2f4c      	cmp	r7, #76	; 0x4c
 1003a76:	d1f8      	bne.n	1003a6a <z_vprintk+0x142>
					long long lld = va_arg(ap, long long);
 1003a78:	3407      	adds	r4, #7
 1003a7a:	f024 0407 	bic.w	r4, r4, #7
 1003a7e:	e8f4 2302 	ldrd	r2, r3, [r4], #8
 1003a82:	e9cd 2304 	strd	r2, r3, [sp, #16]
					if (lld > __LONG_MAX__ ||
 1003a86:	9b04      	ldr	r3, [sp, #16]
 1003a88:	f04f 30ff 	mov.w	r0, #4294967295
 1003a8c:	f113 4100 	adds.w	r1, r3, #2147483648	; 0x80000000
 1003a90:	9b05      	ldr	r3, [sp, #20]
 1003a92:	9108      	str	r1, [sp, #32]
 1003a94:	f143 0100 	adc.w	r1, r3, #0
 1003a98:	9109      	str	r1, [sp, #36]	; 0x24
 1003a9a:	2100      	movs	r1, #0
 1003a9c:	e9dd 2308 	ldrd	r2, r3, [sp, #32]
 1003aa0:	4299      	cmp	r1, r3
 1003aa2:	bf08      	it	eq
 1003aa4:	4290      	cmpeq	r0, r2
 1003aa6:	d204      	bcs.n	1003ab2 <z_vprintk+0x18a>
						print_err(out, ctx);
 1003aa8:	4659      	mov	r1, fp
 1003aaa:	4628      	mov	r0, r5
 1003aac:	f011 f972 	bl	1014d94 <print_err>
						break;
 1003ab0:	e746      	b.n	1003940 <z_vprintk+0x18>
					d = lld;
 1003ab2:	9e04      	ldr	r6, [sp, #16]
				if (d < 0) {
 1003ab4:	2e00      	cmp	r6, #0
 1003ab6:	da05      	bge.n	1003ac4 <z_vprintk+0x19c>
					out((int)'-', ctx);
 1003ab8:	4659      	mov	r1, fp
 1003aba:	202d      	movs	r0, #45	; 0x2d
 1003abc:	47a8      	blx	r5
					d = -d;
 1003abe:	4276      	negs	r6, r6
					min_width--;
 1003ac0:	f109 39ff 	add.w	r9, r9, #4294967295
				_printk_dec_ulong(out, ctx, d, padding,
 1003ac4:	4643      	mov	r3, r8
 1003ac6:	4632      	mov	r2, r6
 1003ac8:	f8cd 9000 	str.w	r9, [sp]
				_printk_dec_ulong(out, ctx, u, padding,
 1003acc:	4659      	mov	r1, fp
 1003ace:	4628      	mov	r0, r5
 1003ad0:	f7ff fed6 	bl	1003880 <_printk_dec_ulong>
				break;
 1003ad4:	e734      	b.n	1003940 <z_vprintk+0x18>
				if (length_mod == 'z') {
 1003ad6:	2f7a      	cmp	r7, #122	; 0x7a
 1003ad8:	d102      	bne.n	1003ae0 <z_vprintk+0x1b8>
					u = va_arg(ap, unsigned int);
 1003ada:	f854 2b04 	ldr.w	r2, [r4], #4
 1003ade:	e00f      	b.n	1003b00 <z_vprintk+0x1d8>
				} else if (length_mod == 'l') {
 1003ae0:	2f6c      	cmp	r7, #108	; 0x6c
 1003ae2:	d0fa      	beq.n	1003ada <z_vprintk+0x1b2>
				} else if (length_mod == 'L') {
 1003ae4:	2f4c      	cmp	r7, #76	; 0x4c
 1003ae6:	d1f8      	bne.n	1003ada <z_vprintk+0x1b2>
					if (llu > ~0UL) {
 1003ae8:	2100      	movs	r1, #0
 1003aea:	f04f 30ff 	mov.w	r0, #4294967295
					unsigned long long llu =
 1003aee:	3407      	adds	r4, #7
 1003af0:	f024 0407 	bic.w	r4, r4, #7
 1003af4:	e8f4 2302 	ldrd	r2, r3, [r4], #8
					if (llu > ~0UL) {
 1003af8:	4299      	cmp	r1, r3
 1003afa:	bf08      	it	eq
 1003afc:	4290      	cmpeq	r0, r2
 1003afe:	d3d3      	bcc.n	1003aa8 <z_vprintk+0x180>
				_printk_dec_ulong(out, ctx, u, padding,
 1003b00:	4643      	mov	r3, r8
 1003b02:	f8cd 9000 	str.w	r9, [sp]
 1003b06:	e7e1      	b.n	1003acc <z_vprintk+0x1a4>
				out('0', ctx);
 1003b08:	4659      	mov	r1, fp
 1003b0a:	2030      	movs	r0, #48	; 0x30
 1003b0c:	47a8      	blx	r5
				out('x', ctx);
 1003b0e:	4659      	mov	r1, fp
 1003b10:	2078      	movs	r0, #120	; 0x78
 1003b12:	47a8      	blx	r5
					min_width = 8;
 1003b14:	f04f 0908 	mov.w	r9, #8
				padding = PAD_ZERO_BEFORE;
 1003b18:	f04f 0801 	mov.w	r8, #1
 1003b1c:	e772      	b.n	1003a04 <z_vprintk+0xdc>
				} else if (length_mod == 'l') {
 1003b1e:	2f6c      	cmp	r7, #108	; 0x6c
 1003b20:	f43f af75 	beq.w	1003a0e <z_vprintk+0xe6>
				} else if (length_mod == 'L') {
 1003b24:	2f4c      	cmp	r7, #76	; 0x4c
 1003b26:	f47f af72 	bne.w	1003a0e <z_vprintk+0xe6>
					x = va_arg(ap, unsigned long long);
 1003b2a:	1de3      	adds	r3, r4, #7
 1003b2c:	f023 0307 	bic.w	r3, r3, #7
 1003b30:	461c      	mov	r4, r3
 1003b32:	f854 2b08 	ldr.w	r2, [r4], #8
 1003b36:	9206      	str	r2, [sp, #24]
 1003b38:	685a      	ldr	r2, [r3, #4]
	int digits = 0;
 1003b3a:	2100      	movs	r1, #0
	int remaining = 16; /* 16 digits max */
 1003b3c:	2310      	movs	r3, #16
	int shift = sizeof(num) * 8;
 1003b3e:	f04f 0a40 	mov.w	sl, #64	; 0x40
	int digits = 0;
 1003b42:	9104      	str	r1, [sp, #16]
	int found_largest_digit = 0;
 1003b44:	9107      	str	r1, [sp, #28]
		shift -= 4;
 1003b46:	f1aa 0a04 	sub.w	sl, sl, #4
		nibble = (num >> shift) & 0xf;
 1003b4a:	9906      	ldr	r1, [sp, #24]
 1003b4c:	f1ca 0e20 	rsb	lr, sl, #32
 1003b50:	f1aa 0c20 	sub.w	ip, sl, #32
 1003b54:	fa21 f00a 	lsr.w	r0, r1, sl
 1003b58:	fa02 fe0e 	lsl.w	lr, r2, lr
 1003b5c:	ea40 000e 	orr.w	r0, r0, lr
 1003b60:	fa22 fc0c 	lsr.w	ip, r2, ip
 1003b64:	ea40 000c 	orr.w	r0, r0, ip
		if (nibble != 0 || found_largest_digit != 0 || shift == 0) {
 1003b68:	f010 000f 	ands.w	r0, r0, #15
 1003b6c:	d107      	bne.n	1003b7e <z_vprintk+0x256>
 1003b6e:	9907      	ldr	r1, [sp, #28]
 1003b70:	b911      	cbnz	r1, 1003b78 <z_vprintk+0x250>
 1003b72:	f1ba 0f00 	cmp.w	sl, #0
 1003b76:	d125      	bne.n	1003bc4 <z_vprintk+0x29c>
			nibble += nibble > 9 ? 87 : 48;
 1003b78:	f04f 0c30 	mov.w	ip, #48	; 0x30
 1003b7c:	e005      	b.n	1003b8a <z_vprintk+0x262>
 1003b7e:	2809      	cmp	r0, #9
 1003b80:	bf8c      	ite	hi
 1003b82:	f04f 0c57 	movhi.w	ip, #87	; 0x57
 1003b86:	f04f 0c30 	movls.w	ip, #48	; 0x30
 1003b8a:	4460      	add	r0, ip
			out((int)nibble, ctx);
 1003b8c:	4659      	mov	r1, fp
 1003b8e:	b240      	sxtb	r0, r0
 1003b90:	920a      	str	r2, [sp, #40]	; 0x28
 1003b92:	9307      	str	r3, [sp, #28]
 1003b94:	47a8      	blx	r5
			digits++;
 1003b96:	9b04      	ldr	r3, [sp, #16]
	while (shift >= 4) {
 1003b98:	9a0a      	ldr	r2, [sp, #40]	; 0x28
			digits++;
 1003b9a:	3301      	adds	r3, #1
 1003b9c:	9304      	str	r3, [sp, #16]
	while (shift >= 4) {
 1003b9e:	9b07      	ldr	r3, [sp, #28]
 1003ba0:	f1ba 0f00 	cmp.w	sl, #0
 1003ba4:	d123      	bne.n	1003bee <z_vprintk+0x2c6>
	if (padding == PAD_SPACE_AFTER) {
 1003ba6:	f1b8 0f03 	cmp.w	r8, #3
 1003baa:	f47f aec9 	bne.w	1003940 <z_vprintk+0x18>
		remaining = min_width * 2 - digits;
 1003bae:	9b04      	ldr	r3, [sp, #16]
 1003bb0:	ebc3 0649 	rsb	r6, r3, r9, lsl #1
		while (remaining-- > 0) {
 1003bb4:	2e00      	cmp	r6, #0
 1003bb6:	f77f aec3 	ble.w	1003940 <z_vprintk+0x18>
			out(' ', ctx);
 1003bba:	4659      	mov	r1, fp
 1003bbc:	2020      	movs	r0, #32
 1003bbe:	47a8      	blx	r5
 1003bc0:	3e01      	subs	r6, #1
 1003bc2:	e7f7      	b.n	1003bb4 <z_vprintk+0x28c>
		if (remaining-- <= min_width) {
 1003bc4:	1e59      	subs	r1, r3, #1
 1003bc6:	4599      	cmp	r9, r3
 1003bc8:	910a      	str	r1, [sp, #40]	; 0x28
 1003bca:	db07      	blt.n	1003bdc <z_vprintk+0x2b4>
			if (padding == PAD_ZERO_BEFORE) {
 1003bcc:	f1b8 0f01 	cmp.w	r8, #1
 1003bd0:	d106      	bne.n	1003be0 <z_vprintk+0x2b8>
				out('0', ctx);
 1003bd2:	4659      	mov	r1, fp
 1003bd4:	2030      	movs	r0, #48	; 0x30
 1003bd6:	920b      	str	r2, [sp, #44]	; 0x2c
				out(' ', ctx);
 1003bd8:	47a8      	blx	r5
 1003bda:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
			nibble += nibble > 9 ? 87 : 48;
 1003bdc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 1003bde:	e7b2      	b.n	1003b46 <z_vprintk+0x21e>
			} else if (padding == PAD_SPACE_BEFORE) {
 1003be0:	f1b8 0f02 	cmp.w	r8, #2
 1003be4:	d1fa      	bne.n	1003bdc <z_vprintk+0x2b4>
				out(' ', ctx);
 1003be6:	4659      	mov	r1, fp
 1003be8:	2020      	movs	r0, #32
 1003bea:	920b      	str	r2, [sp, #44]	; 0x2c
 1003bec:	e7f4      	b.n	1003bd8 <z_vprintk+0x2b0>
			found_largest_digit = 1;
 1003bee:	9607      	str	r6, [sp, #28]
 1003bf0:	e7a9      	b.n	1003b46 <z_vprintk+0x21e>
				char *s = va_arg(ap, char *);
 1003bf2:	f854 6b04 	ldr.w	r6, [r4], #4
				while (*s) {
 1003bf6:	46b2      	mov	sl, r6
 1003bf8:	4653      	mov	r3, sl
 1003bfa:	f81a 0b01 	ldrb.w	r0, [sl], #1
 1003bfe:	b968      	cbnz	r0, 1003c1c <z_vprintk+0x2f4>
				if (padding == PAD_SPACE_AFTER) {
 1003c00:	f1b8 0f03 	cmp.w	r8, #3
 1003c04:	d121      	bne.n	1003c4a <z_vprintk+0x322>
					int remaining = min_width - (s - start);
 1003c06:	1b9e      	subs	r6, r3, r6
 1003c08:	eba9 0606 	sub.w	r6, r9, r6
					while (remaining-- > 0) {
 1003c0c:	2e00      	cmp	r6, #0
 1003c0e:	f77f ae97 	ble.w	1003940 <z_vprintk+0x18>
						out(' ', ctx);
 1003c12:	4659      	mov	r1, fp
 1003c14:	2020      	movs	r0, #32
 1003c16:	47a8      	blx	r5
 1003c18:	3e01      	subs	r6, #1
 1003c1a:	e7f7      	b.n	1003c0c <z_vprintk+0x2e4>
					out((int)(*s++), ctx);
 1003c1c:	4659      	mov	r1, fp
 1003c1e:	47a8      	blx	r5
 1003c20:	e7ea      	b.n	1003bf8 <z_vprintk+0x2d0>
				out(c, ctx);
 1003c22:	4659      	mov	r1, fp
 1003c24:	f854 0b04 	ldr.w	r0, [r4], #4
 1003c28:	e6ae      	b.n	1003988 <z_vprintk+0x60>
				out((int)'%', ctx);
 1003c2a:	4659      	mov	r1, fp
 1003c2c:	e6ac      	b.n	1003988 <z_vprintk+0x60>
				length_mod = 0;
 1003c2e:	4637      	mov	r7, r6
				padding = PAD_NONE;
 1003c30:	46b0      	mov	r8, r6
				min_width = -1;
 1003c32:	f04f 39ff 	mov.w	r9, #4294967295
				might_format = 1;
 1003c36:	2601      	movs	r6, #1
 1003c38:	e68a      	b.n	1003950 <z_vprintk+0x28>
			switch (*fmt) {
 1003c3a:	f04f 0803 	mov.w	r8, #3
 1003c3e:	e687      	b.n	1003950 <z_vprintk+0x28>
					padding = PAD_ZERO_BEFORE;
 1003c40:	f04f 0801 	mov.w	r8, #1
 1003c44:	e684      	b.n	1003950 <z_vprintk+0x28>
					length_mod = 'L';
 1003c46:	274c      	movs	r7, #76	; 0x4c
 1003c48:	e682      	b.n	1003950 <z_vprintk+0x28>
			might_format = 0;
 1003c4a:	4606      	mov	r6, r0
		++fmt;
 1003c4c:	e680      	b.n	1003950 <z_vprintk+0x28>
 1003c4e:	bf00      	nop

01003c50 <vprintk>:
{
 1003c50:	b507      	push	{r0, r1, r2, lr}
 1003c52:	460b      	mov	r3, r1
	struct out_context ctx = { 0 };
 1003c54:	2100      	movs	r1, #0
{
 1003c56:	4602      	mov	r2, r0
	struct out_context ctx = { 0 };
 1003c58:	9101      	str	r1, [sp, #4]
	z_vprintk(char_out, &ctx, fmt, ap);
 1003c5a:	4803      	ldr	r0, [pc, #12]	; (1003c68 <vprintk+0x18>)
 1003c5c:	a901      	add	r1, sp, #4
 1003c5e:	f7ff fe63 	bl	1003928 <z_vprintk>
}
 1003c62:	b003      	add	sp, #12
 1003c64:	f85d fb04 	ldr.w	pc, [sp], #4
 1003c68:	01003871 	.word	0x01003871

01003c6c <vsnprintk>:

	return ret;
}

int vsnprintk(char *str, size_t size, const char *fmt, va_list ap)
{
 1003c6c:	b530      	push	{r4, r5, lr}
	struct str_context ctx = { str, size, 0 };
 1003c6e:	2500      	movs	r5, #0
{
 1003c70:	b085      	sub	sp, #20
	struct str_context ctx = { str, size, 0 };
 1003c72:	e9cd 0101 	strd	r0, r1, [sp, #4]
{
 1003c76:	4604      	mov	r4, r0

	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
 1003c78:	a901      	add	r1, sp, #4
 1003c7a:	4805      	ldr	r0, [pc, #20]	; (1003c90 <vsnprintk+0x24>)
	struct str_context ctx = { str, size, 0 };
 1003c7c:	9503      	str	r5, [sp, #12]
	z_vprintk((out_func_t)str_out, &ctx, fmt, ap);
 1003c7e:	f7ff fe53 	bl	1003928 <z_vprintk>

	if (ctx.count < ctx.max) {
 1003c82:	e9dd 3002 	ldrd	r3, r0, [sp, #8]
 1003c86:	4298      	cmp	r0, r3
		str[ctx.count] = '\0';
 1003c88:	bfb8      	it	lt
 1003c8a:	5425      	strblt	r5, [r4, r0]
	}

	return ctx.count;
}
 1003c8c:	b005      	add	sp, #20
 1003c8e:	bd30      	pop	{r4, r5, pc}
 1003c90:	01014db1 	.word	0x01014db1

01003c94 <nordicsemi_nrf53_init>:
		:
		: "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	unsigned int tmp;

	__asm__ volatile(
 1003c94:	f04f 0320 	mov.w	r3, #32
 1003c98:	f3ef 8111 	mrs	r1, BASEPRI
 1003c9c:	f383 8811 	msr	BASEPRI, r3
 1003ca0:	f3bf 8f6f 	isb	sy
#ifdef CONFIG_SOC_NRF5340_CPUAPP
	/* Enable the instruction & data cache */
	NRF_CACHE->ENABLE = CACHE_ENABLE_ENABLE_Msk;
#endif /* CONFIG_SOC_NRF5340_CPUAPP */
#ifdef CONFIG_SOC_NRF5340_CPUNET
	NRF_NVMC->ICACHECNF |= NVMC_ICACHECNF_CACHEEN_Enabled;
 1003ca4:	4a06      	ldr	r2, [pc, #24]	; (1003cc0 <nordicsemi_nrf53_init+0x2c>)
 1003ca6:	f8d2 3540 	ldr.w	r3, [r2, #1344]	; 0x540
 1003caa:	f043 0301 	orr.w	r3, r3, #1
 1003cae:	f8c2 3540 	str.w	r3, [r2, #1344]	; 0x540
	__asm__ volatile(
		"cpsie i;"
		"isb"
		: : : "memory");
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile(
 1003cb2:	f381 8811 	msr	BASEPRI, r1
 1003cb6:	f3bf 8f6f 	isb	sy
	NMI_INIT();

	irq_unlock(key);

	return 0;
}
 1003cba:	2000      	movs	r0, #0
 1003cbc:	4770      	bx	lr
 1003cbe:	bf00      	nop
 1003cc0:	41080000 	.word	0x41080000

01003cc4 <arch_busy_wait>:

#else // NRFX_CHECK(NRFX_DELAY_DWT_BASED)

NRF_STATIC_INLINE void nrfx_coredep_delay_us(uint32_t time_us)
{
    if (time_us == 0)
 1003cc4:	b120      	cbz	r0, 1003cd0 <arch_busy_wait+0xc>
    };

    typedef void (* delay_func_t)(uint32_t);
    const delay_func_t delay_cycles =
        // Set LSB to 1 to execute the code in the Thumb mode.
        (delay_func_t)((((uint32_t)delay_machine_code) | 1));
 1003cc6:	4b03      	ldr	r3, [pc, #12]	; (1003cd4 <arch_busy_wait+0x10>)
    uint32_t cycles = time_us * NRFX_DELAY_CPU_FREQ_MHZ;
    delay_cycles(cycles);
 1003cc8:	0180      	lsls	r0, r0, #6
 1003cca:	f043 0301 	orr.w	r3, r3, #1
 1003cce:	4718      	bx	r3

void arch_busy_wait(u32_t time_us)
{
	nrfx_coredep_delay_us(time_us);
}
 1003cd0:	4770      	bx	lr
 1003cd2:	bf00      	nop
 1003cd4:	01018200 	.word	0x01018200

01003cd8 <enable_logger>:

K_THREAD_STACK_DEFINE(logging_stack, CONFIG_LOG_PROCESS_THREAD_STACK_SIZE);
struct k_thread logging_thread;

static int enable_logger(struct device *arg)
{
 1003cd8:	b530      	push	{r4, r5, lr}
	ARG_UNUSED(arg);

	if (IS_ENABLED(CONFIG_LOG_PROCESS_THREAD)) {
		k_timer_init(&log_process_thread_timer,
 1003cda:	2200      	movs	r2, #0
{
 1003cdc:	b089      	sub	sp, #36	; 0x24
		k_timer_init(&log_process_thread_timer,
 1003cde:	490f      	ldr	r1, [pc, #60]	; (1003d1c <enable_logger+0x44>)
 1003ce0:	480f      	ldr	r0, [pc, #60]	; (1003d20 <enable_logger+0x48>)
 1003ce2:	f013 fff6 	bl	1017cd2 <k_timer_init>
 1003ce6:	2200      	movs	r2, #0
 1003ce8:	2300      	movs	r3, #0
 1003cea:	2400      	movs	r4, #0
 1003cec:	e9cd 2306 	strd	r2, r3, [sp, #24]
 1003cf0:	230e      	movs	r3, #14
 1003cf2:	4d0c      	ldr	r5, [pc, #48]	; (1003d24 <enable_logger+0x4c>)
 1003cf4:	e9cd 3403 	strd	r3, r4, [sp, #12]
 1003cf8:	f44f 7240 	mov.w	r2, #768	; 0x300
 1003cfc:	4628      	mov	r0, r5
 1003cfe:	e9cd 4401 	strd	r4, r4, [sp, #4]
 1003d02:	4b09      	ldr	r3, [pc, #36]	; (1003d28 <enable_logger+0x50>)
 1003d04:	4909      	ldr	r1, [pc, #36]	; (1003d2c <enable_logger+0x54>)
 1003d06:	9400      	str	r4, [sp, #0]
 1003d08:	f010 fd2c 	bl	1014764 <z_impl_k_thread_create>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&thread_id, *(uintptr_t *)&value, K_SYSCALL_K_THREAD_NAME_SET);
	}
#endif
	compiler_barrier();
	return z_impl_k_thread_name_set(thread_id, value);
 1003d0c:	4908      	ldr	r1, [pc, #32]	; (1003d30 <enable_logger+0x58>)
 1003d0e:	4628      	mov	r0, r5
 1003d10:	f013 fef2 	bl	1017af8 <z_impl_k_thread_name_set>
	} else {
		log_init();
	}

	return 0;
}
 1003d14:	4620      	mov	r0, r4
 1003d16:	b009      	add	sp, #36	; 0x24
 1003d18:	bd30      	pop	{r4, r5, pc}
 1003d1a:	bf00      	nop
 1003d1c:	01003d35 	.word	0x01003d35
 1003d20:	21000690 	.word	0x21000690
 1003d24:	2100089c 	.word	0x2100089c
 1003d28:	0100411d 	.word	0x0100411d
 1003d2c:	21006b00 	.word	0x21006b00
 1003d30:	01019172 	.word	0x01019172

01003d34 <log_process_thread_timer_expiry_fn>:
		arch_syscall_invoke1(*(uintptr_t *)&sem, K_SYSCALL_K_SEM_GIVE);
		return;
	}
#endif
	compiler_barrier();
	z_impl_k_sem_give(sem);
 1003d34:	4801      	ldr	r0, [pc, #4]	; (1003d3c <log_process_thread_timer_expiry_fn+0x8>)
 1003d36:	f010 bc87 	b.w	1014648 <z_impl_k_sem_give>
 1003d3a:	bf00      	nop
 1003d3c:	21000540 	.word	0x21000540

01003d40 <log_core_init>:
{
 1003d40:	b508      	push	{r3, lr}
		log_msg_pool_init();
 1003d42:	f000 fa49 	bl	10041d8 <log_msg_pool_init>
		log_list_init(&list);
 1003d46:	4809      	ldr	r0, [pc, #36]	; (1003d6c <log_core_init+0x2c>)
 1003d48:	f011 fade 	bl	1015308 <log_list_init>
		k_mem_slab_init(&log_strdup_pool, log_strdup_pool_buf,
 1003d4c:	2304      	movs	r3, #4
 1003d4e:	2228      	movs	r2, #40	; 0x28
 1003d50:	4907      	ldr	r1, [pc, #28]	; (1003d70 <log_core_init+0x30>)
 1003d52:	4808      	ldr	r0, [pc, #32]	; (1003d74 <log_core_init+0x34>)
 1003d54:	f013 fc95 	bl	1017682 <k_mem_slab_init>
		timestamp_func = k_cycle_get_32_wrapper;
 1003d58:	4b07      	ldr	r3, [pc, #28]	; (1003d78 <log_core_init+0x38>)
 1003d5a:	4a08      	ldr	r2, [pc, #32]	; (1003d7c <log_core_init+0x3c>)
	log_output_timestamp_freq_set(freq);
 1003d5c:	f44f 4000 	mov.w	r0, #32768	; 0x8000
		timestamp_func = k_cycle_get_32_wrapper;
 1003d60:	601a      	str	r2, [r3, #0]
}
 1003d62:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	log_output_timestamp_freq_set(freq);
 1003d66:	f000 bc7d 	b.w	1004664 <log_output_timestamp_freq_set>
 1003d6a:	bf00      	nop
 1003d6c:	21000878 	.word	0x21000878
 1003d70:	21008310 	.word	0x21008310
 1003d74:	21000880 	.word	0x21000880
 1003d78:	2100006c 	.word	0x2100006c
 1003d7c:	01015347 	.word	0x01015347

01003d80 <dropped_notify>:
{
 1003d80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
 1003d82:	2500      	movs	r5, #0
 1003d84:	4b0c      	ldr	r3, [pc, #48]	; (1003db8 <dropped_notify+0x38>)
 1003d86:	e8d3 7fef 	ldaex	r7, [r3]
 1003d8a:	e8c3 5fe2 	stlex	r2, r5, [r3]
 1003d8e:	2a00      	cmp	r2, #0
 1003d90:	d1f9      	bne.n	1003d86 <dropped_notify+0x6>
 *
 * @return Number of backends.
 */
static inline int log_backend_count_get(void)
{
	return __log_backends_end - __log_backends_start;
 1003d92:	4c0a      	ldr	r4, [pc, #40]	; (1003dbc <dropped_notify+0x3c>)
 1003d94:	4e0a      	ldr	r6, [pc, #40]	; (1003dc0 <dropped_notify+0x40>)
 1003d96:	1b36      	subs	r6, r6, r4
 1003d98:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
 1003d9a:	42b5      	cmp	r5, r6
 1003d9c:	db00      	blt.n	1003da0 <dropped_notify+0x20>
}
 1003d9e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 */
static inline bool log_backend_is_active(
				const struct log_backend *const backend)
{
	__ASSERT_NO_MSG(backend != NULL);
	return backend->cb->active;
 1003da0:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
 1003da2:	795b      	ldrb	r3, [r3, #5]
 1003da4:	b12b      	cbz	r3, 1003db2 <dropped_notify+0x32>
	if (backend->api->dropped != NULL) {
 1003da6:	6823      	ldr	r3, [r4, #0]
 1003da8:	68db      	ldr	r3, [r3, #12]
 1003daa:	b113      	cbz	r3, 1003db2 <dropped_notify+0x32>
		backend->api->dropped(backend, cnt);
 1003dac:	4639      	mov	r1, r7
 1003dae:	4620      	mov	r0, r4
 1003db0:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
 1003db2:	3501      	adds	r5, #1
 1003db4:	3410      	adds	r4, #16
 1003db6:	e7f0      	b.n	1003d9a <dropped_notify+0x1a>
 1003db8:	21000870 	.word	0x21000870
 1003dbc:	010181e0 	.word	0x010181e0
 1003dc0:	010181f0 	.word	0x010181f0

01003dc4 <log_dropped>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 1003dc4:	4b04      	ldr	r3, [pc, #16]	; (1003dd8 <log_dropped+0x14>)
 1003dc6:	e8d3 2fef 	ldaex	r2, [r3]
 1003dca:	3201      	adds	r2, #1
 1003dcc:	e8c3 2fe1 	stlex	r1, r2, [r3]
 1003dd0:	2900      	cmp	r1, #0
 1003dd2:	d1f8      	bne.n	1003dc6 <log_dropped+0x2>
}
 1003dd4:	4770      	bx	lr
 1003dd6:	bf00      	nop
 1003dd8:	21000870 	.word	0x21000870

01003ddc <log_source_name_get>:
 1003ddc:	4a04      	ldr	r2, [pc, #16]	; (1003df0 <log_source_name_get+0x14>)
 1003dde:	4b05      	ldr	r3, [pc, #20]	; (1003df4 <log_source_name_get+0x18>)
 1003de0:	1a9b      	subs	r3, r3, r2
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
 1003de2:	ebb1 0fd3 	cmp.w	r1, r3, lsr #3
	return __log_const_start[source_id].name;
 1003de6:	bf34      	ite	cc
 1003de8:	f852 0031 	ldrcc.w	r0, [r2, r1, lsl #3]
 1003dec:	2000      	movcs	r0, #0
}
 1003dee:	4770      	bx	lr
 1003df0:	010180b8 	.word	0x010180b8
 1003df4:	010181e0 	.word	0x010181e0

01003df8 <log_backend_enable>:
	id += backend - log_backend_get(0);
 1003df8:	4b09      	ldr	r3, [pc, #36]	; (1003e20 <log_backend_enable+0x28>)
	log_backend_id_set(backend, id);
 1003dfa:	6842      	ldr	r2, [r0, #4]
	id += backend - log_backend_get(0);
 1003dfc:	1ac3      	subs	r3, r0, r3
 1003dfe:	111b      	asrs	r3, r3, #4
 1003e00:	3301      	adds	r3, #1
{
 1003e02:	b510      	push	{r4, lr}
	log_backend_id_set(backend, id);
 1003e04:	7113      	strb	r3, [r2, #4]
	backend->cb->active = true;
 1003e06:	2201      	movs	r2, #1
	log_backend_activate(backend, ctx);
 1003e08:	6843      	ldr	r3, [r0, #4]
	if (!backend_attached) {
 1003e0a:	4c06      	ldr	r4, [pc, #24]	; (1003e24 <log_backend_enable+0x2c>)
 1003e0c:	715a      	strb	r2, [r3, #5]
 1003e0e:	7822      	ldrb	r2, [r4, #0]
	backend->cb->ctx = ctx;
 1003e10:	6019      	str	r1, [r3, #0]
 1003e12:	b912      	cbnz	r2, 1003e1a <log_backend_enable+0x22>
 1003e14:	4804      	ldr	r0, [pc, #16]	; (1003e28 <log_backend_enable+0x30>)
 1003e16:	f010 fc17 	bl	1014648 <z_impl_k_sem_give>
	backend_attached = true;
 1003e1a:	2301      	movs	r3, #1
 1003e1c:	7023      	strb	r3, [r4, #0]
}
 1003e1e:	bd10      	pop	{r4, pc}
 1003e20:	010181e0 	.word	0x010181e0
 1003e24:	2100668c 	.word	0x2100668c
 1003e28:	21000540 	.word	0x21000540

01003e2c <log_init>:
{
 1003e2c:	b570      	push	{r4, r5, r6, lr}
 1003e2e:	4b0f      	ldr	r3, [pc, #60]	; (1003e6c <log_init+0x40>)
 1003e30:	e8d3 5fef 	ldaex	r5, [r3]
 1003e34:	1c6a      	adds	r2, r5, #1
 1003e36:	e8c3 2fe1 	stlex	r1, r2, [r3]
 1003e3a:	2900      	cmp	r1, #0
 1003e3c:	d1f8      	bne.n	1003e30 <log_init+0x4>
	if (atomic_inc(&initialized) != 0) {
 1003e3e:	b92d      	cbnz	r5, 1003e4c <log_init+0x20>
	return __log_backends_end - __log_backends_start;
 1003e40:	4c0b      	ldr	r4, [pc, #44]	; (1003e70 <log_init+0x44>)
 1003e42:	4e0c      	ldr	r6, [pc, #48]	; (1003e74 <log_init+0x48>)
 1003e44:	1b36      	subs	r6, r6, r4
 1003e46:	1136      	asrs	r6, r6, #4
	for (i = 0; i < log_backend_count_get(); i++) {
 1003e48:	42b5      	cmp	r5, r6
 1003e4a:	db00      	blt.n	1003e4e <log_init+0x22>
}
 1003e4c:	bd70      	pop	{r4, r5, r6, pc}
		if (backend->autostart) {
 1003e4e:	7b23      	ldrb	r3, [r4, #12]
 1003e50:	b143      	cbz	r3, 1003e64 <log_init+0x38>
			if (backend->api->init != NULL) {
 1003e52:	6823      	ldr	r3, [r4, #0]
 1003e54:	695b      	ldr	r3, [r3, #20]
 1003e56:	b103      	cbz	r3, 1003e5a <log_init+0x2e>
				backend->api->init();
 1003e58:	4798      	blx	r3
			log_backend_enable(backend, NULL, CONFIG_LOG_MAX_LEVEL);
 1003e5a:	2204      	movs	r2, #4
 1003e5c:	2100      	movs	r1, #0
 1003e5e:	4620      	mov	r0, r4
 1003e60:	f7ff ffca 	bl	1003df8 <log_backend_enable>
	for (i = 0; i < log_backend_count_get(); i++) {
 1003e64:	3501      	adds	r5, #1
 1003e66:	3410      	adds	r4, #16
 1003e68:	e7ee      	b.n	1003e48 <log_init+0x1c>
 1003e6a:	bf00      	nop
 1003e6c:	21000874 	.word	0x21000874
 1003e70:	010181e0 	.word	0x010181e0
 1003e74:	010181f0 	.word	0x010181f0

01003e78 <log_strdup>:
	return (((const char *)addr >= (const char *)RO_START) &&
 1003e78:	4b14      	ldr	r3, [pc, #80]	; (1003ecc <log_strdup+0x54>)
{
 1003e7a:	b537      	push	{r0, r1, r2, r4, r5, lr}
	return (((const char *)addr >= (const char *)RO_START) &&
 1003e7c:	4298      	cmp	r0, r3
{
 1003e7e:	4604      	mov	r4, r0
	return (((const char *)addr >= (const char *)RO_START) &&
 1003e80:	d302      	bcc.n	1003e88 <log_strdup+0x10>
	if (IS_ENABLED(CONFIG_LOG_IMMEDIATE) ||
 1003e82:	4b13      	ldr	r3, [pc, #76]	; (1003ed0 <log_strdup+0x58>)
 1003e84:	4298      	cmp	r0, r3
 1003e86:	d31c      	bcc.n	1003ec2 <log_strdup+0x4a>
	err = k_mem_slab_alloc(&log_strdup_pool, (void **)&dup, K_NO_WAIT);
 1003e88:	2200      	movs	r2, #0
 1003e8a:	2300      	movs	r3, #0
 1003e8c:	4811      	ldr	r0, [pc, #68]	; (1003ed4 <log_strdup+0x5c>)
 1003e8e:	a901      	add	r1, sp, #4
 1003e90:	f010 f822 	bl	1013ed8 <k_mem_slab_alloc>
	if (err != 0) {
 1003e94:	4605      	mov	r5, r0
 1003e96:	b9b8      	cbnz	r0, 1003ec8 <log_strdup+0x50>
	return __atomic_exchange_n(target, value, __ATOMIC_SEQ_CST);
 1003e98:	2201      	movs	r2, #1
 1003e9a:	9b01      	ldr	r3, [sp, #4]
 1003e9c:	e8d3 1fef 	ldaex	r1, [r3]
 1003ea0:	e8c3 2fe0 	stlex	r0, r2, [r3]
 1003ea4:	2800      	cmp	r0, #0
 1003ea6:	d1f9      	bne.n	1003e9c <log_strdup+0x24>
	strncpy(dup->buf, str, sizeof(dup->buf) - 2);
 1003ea8:	9801      	ldr	r0, [sp, #4]
 1003eaa:	4621      	mov	r1, r4
 1003eac:	221f      	movs	r2, #31
 1003eae:	3004      	adds	r0, #4
 1003eb0:	f012 fcbd 	bl	101682e <strncpy>
	dup->buf[sizeof(dup->buf) - 2] = '~';
 1003eb4:	237e      	movs	r3, #126	; 0x7e
 1003eb6:	9c01      	ldr	r4, [sp, #4]
 1003eb8:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
	dup->buf[sizeof(dup->buf) - 1] = '\0';
 1003ebc:	f884 5024 	strb.w	r5, [r4, #36]	; 0x24
	return dup->buf;
 1003ec0:	3404      	adds	r4, #4
}
 1003ec2:	4620      	mov	r0, r4
 1003ec4:	b003      	add	sp, #12
 1003ec6:	bd30      	pop	{r4, r5, pc}
		return (char *)log_strdup_fail_msg;
 1003ec8:	4c03      	ldr	r4, [pc, #12]	; (1003ed8 <log_strdup+0x60>)
 1003eca:	e7fa      	b.n	1003ec2 <log_strdup+0x4a>
 1003ecc:	01017f48 	.word	0x01017f48
 1003ed0:	01019ab0 	.word	0x01019ab0
 1003ed4:	21000880 	.word	0x21000880
 1003ed8:	0101917a 	.word	0x0101917a

01003edc <log_is_strdup>:
	return PART_OF_ARRAY(log_strdup_pool_buf, (u8_t *)buf);
 1003edc:	b148      	cbz	r0, 1003ef2 <log_is_strdup+0x16>
 1003ede:	4b05      	ldr	r3, [pc, #20]	; (1003ef4 <log_is_strdup+0x18>)
 1003ee0:	4298      	cmp	r0, r3
 1003ee2:	d305      	bcc.n	1003ef0 <log_is_strdup+0x14>
 1003ee4:	33a0      	adds	r3, #160	; 0xa0
 1003ee6:	4298      	cmp	r0, r3
 1003ee8:	bf2c      	ite	cs
 1003eea:	2000      	movcs	r0, #0
 1003eec:	2001      	movcc	r0, #1
 1003eee:	4770      	bx	lr
 1003ef0:	2000      	movs	r0, #0
}
 1003ef2:	4770      	bx	lr
 1003ef4:	21008310 	.word	0x21008310

01003ef8 <z_impl_log_process>:
{
 1003ef8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (!backend_attached && !bypass) {
 1003efc:	4b4a      	ldr	r3, [pc, #296]	; (1004028 <z_impl_log_process+0x130>)
{
 1003efe:	4604      	mov	r4, r0
	if (!backend_attached && !bypass) {
 1003f00:	781b      	ldrb	r3, [r3, #0]
{
 1003f02:	b085      	sub	sp, #20
	if (!backend_attached && !bypass) {
 1003f04:	b903      	cbnz	r3, 1003f08 <z_impl_log_process+0x10>
 1003f06:	b340      	cbz	r0, 1003f5a <z_impl_log_process+0x62>
	__asm__ volatile(
 1003f08:	f04f 0320 	mov.w	r3, #32
 1003f0c:	f3ef 8611 	mrs	r6, BASEPRI
 1003f10:	f383 8811 	msr	BASEPRI, r3
 1003f14:	f3bf 8f6f 	isb	sy
	msg = log_list_head_get(&list);
 1003f18:	4844      	ldr	r0, [pc, #272]	; (100402c <z_impl_log_process+0x134>)
 1003f1a:	f011 fa05 	bl	1015328 <log_list_head_get>
 1003f1e:	4605      	mov	r5, r0
	__asm__ volatile(
 1003f20:	f386 8811 	msr	BASEPRI, r6
 1003f24:	f3bf 8f6f 	isb	sy
	if (msg != NULL) {
 1003f28:	b158      	cbz	r0, 1003f42 <z_impl_log_process+0x4a>
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
 1003f2a:	4b41      	ldr	r3, [pc, #260]	; (1004030 <z_impl_log_process+0x138>)
 1003f2c:	e8d3 2fef 	ldaex	r2, [r3]
 1003f30:	3a01      	subs	r2, #1
 1003f32:	e8c3 2fe1 	stlex	r1, r2, [r3]
 1003f36:	2900      	cmp	r1, #0
 1003f38:	d1f8      	bne.n	1003f2c <z_impl_log_process+0x34>
	if (!bypass) {
 1003f3a:	b194      	cbz	r4, 1003f62 <z_impl_log_process+0x6a>
	log_msg_put(msg);
 1003f3c:	4628      	mov	r0, r5
 1003f3e:	f011 fb05 	bl	101554c <log_msg_put>
	if (!bypass && dropped_cnt) {
 1003f42:	b924      	cbnz	r4, 1003f4e <z_impl_log_process+0x56>
 1003f44:	4b3b      	ldr	r3, [pc, #236]	; (1004034 <z_impl_log_process+0x13c>)
 1003f46:	681b      	ldr	r3, [r3, #0]
 1003f48:	b10b      	cbz	r3, 1003f4e <z_impl_log_process+0x56>
		dropped_notify();
 1003f4a:	f7ff ff19 	bl	1003d80 <dropped_notify>
	return (log_list_head_peek(&list) != NULL);
 1003f4e:	4837      	ldr	r0, [pc, #220]	; (100402c <z_impl_log_process+0x134>)
 1003f50:	f011 f9e8 	bl	1015324 <log_list_head_peek>
 1003f54:	1e04      	subs	r4, r0, #0
 1003f56:	bf18      	it	ne
 1003f58:	2401      	movne	r4, #1
}
 1003f5a:	4620      	mov	r0, r4
 1003f5c:	b005      	add	sp, #20
 1003f5e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		    !panic_mode) {
 1003f62:	4b35      	ldr	r3, [pc, #212]	; (1004038 <z_impl_log_process+0x140>)
		if (IS_ENABLED(CONFIG_LOG_DETECT_MISSED_STRDUP) &&
 1003f64:	781b      	ldrb	r3, [r3, #0]
 1003f66:	b9cb      	cbnz	r3, 1003f9c <z_impl_log_process+0xa4>
 * @retval true  Standard message.
 * @retval false Hexdump message.
 */
static inline bool log_msg_is_std(struct log_msg *msg)
{
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
 1003f68:	7a2b      	ldrb	r3, [r5, #8]
	if (!log_msg_is_std(msg)) {
 1003f6a:	07db      	lsls	r3, r3, #31
 1003f6c:	d416      	bmi.n	1003f9c <z_impl_log_process+0xa4>
	msg_str = log_msg_str_get(msg);
 1003f6e:	f011 fafc 	bl	101556a <log_msg_str_get>
 1003f72:	4680      	mov	r8, r0
	mask = z_log_get_s_mask(msg_str, log_msg_nargs_get(msg));
 1003f74:	4628      	mov	r0, r5
 1003f76:	f011 fac7 	bl	1015508 <log_msg_nargs_get>
 1003f7a:	4601      	mov	r1, r0
 1003f7c:	4640      	mov	r0, r8
 1003f7e:	f011 f9e6 	bl	101534e <z_log_get_s_mask>
 1003f82:	4606      	mov	r6, r0
	return ((u8_t *)data - (u8_t *)__log_const_start)/
 1003f84:	4f2d      	ldr	r7, [pc, #180]	; (100403c <z_impl_log_process+0x144>)
 1003f86:	4b2e      	ldr	r3, [pc, #184]	; (1004040 <z_impl_log_process+0x148>)
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
 1003f88:	f8df b0d0 	ldr.w	fp, [pc, #208]	; 100405c <z_impl_log_process+0x164>
 1003f8c:	1bdb      	subs	r3, r3, r7
 1003f8e:	08db      	lsrs	r3, r3, #3
 1003f90:	9303      	str	r3, [sp, #12]
 1003f92:	4b2c      	ldr	r3, [pc, #176]	; (1004044 <z_impl_log_process+0x14c>)
 1003f94:	1bdb      	subs	r3, r3, r7
 1003f96:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
	while (mask) {
 1003f9a:	b936      	cbnz	r6, 1003faa <z_impl_log_process+0xb2>
 1003f9c:	4e2a      	ldr	r6, [pc, #168]	; (1004048 <z_impl_log_process+0x150>)
 1003f9e:	4f2b      	ldr	r7, [pc, #172]	; (100404c <z_impl_log_process+0x154>)
 1003fa0:	f04f 0800 	mov.w	r8, #0
 1003fa4:	1bbf      	subs	r7, r7, r6
 1003fa6:	113f      	asrs	r7, r7, #4
 1003fa8:	e03a      	b.n	1004020 <z_impl_log_process+0x128>
		idx = 31 - __builtin_clz(mask);
 1003faa:	fab6 f186 	clz	r1, r6
 1003fae:	f1c1 091f 	rsb	r9, r1, #31
		str = (const char *)log_msg_arg_get(msg, idx);
 1003fb2:	4649      	mov	r1, r9
 1003fb4:	4628      	mov	r0, r5
 1003fb6:	f011 faaa 	bl	101550e <log_msg_arg_get>
	return (((const char *)addr >= (const char *)RO_START) &&
 1003fba:	4b25      	ldr	r3, [pc, #148]	; (1004050 <z_impl_log_process+0x158>)
		str = (const char *)log_msg_arg_get(msg, idx);
 1003fbc:	4601      	mov	r1, r0
	return (((const char *)addr >= (const char *)RO_START) &&
 1003fbe:	4298      	cmp	r0, r3
 1003fc0:	d302      	bcc.n	1003fc8 <z_impl_log_process+0xd0>
		if (!is_rodata(str) && !log_is_strdup(str) &&
 1003fc2:	4b24      	ldr	r3, [pc, #144]	; (1004054 <z_impl_log_process+0x15c>)
 1003fc4:	4298      	cmp	r0, r3
 1003fc6:	d31a      	bcc.n	1003ffe <z_impl_log_process+0x106>
 1003fc8:	4608      	mov	r0, r1
 1003fca:	f7ff ff87 	bl	1003edc <log_is_strdup>
 1003fce:	4602      	mov	r2, r0
 1003fd0:	b9a8      	cbnz	r0, 1003ffe <z_impl_log_process+0x106>
 1003fd2:	4b21      	ldr	r3, [pc, #132]	; (1004058 <z_impl_log_process+0x160>)
 1003fd4:	4299      	cmp	r1, r3
 1003fd6:	d012      	beq.n	1003ffe <z_impl_log_process+0x106>
	return msg->hdr.ids.source_id;
 1003fd8:	896b      	ldrh	r3, [r5, #10]
	return src_id < log_sources_count() ? log_name_get(src_id) : NULL;
 1003fda:	9903      	ldr	r1, [sp, #12]
 1003fdc:	f3c3 1389 	ubfx	r3, r3, #6, #10
 1003fe0:	428b      	cmp	r3, r1
	return __log_const_start[source_id].name;
 1003fe2:	bf38      	it	cc
 1003fe4:	f857 2033 	ldrcc.w	r2, [r7, r3, lsl #3]
				LOG_ERR(ERR_MSG, idx, src_name, msg_str);
 1003fe8:	ea4f 138a 	mov.w	r3, sl, lsl #6
 1003fec:	f043 0301 	orr.w	r3, r3, #1
 1003ff0:	f8ad 3000 	strh.w	r3, [sp]
 1003ff4:	4649      	mov	r1, r9
 1003ff6:	4643      	mov	r3, r8
 1003ff8:	4658      	mov	r0, fp
 1003ffa:	f011 fa02 	bl	1015402 <log_3>
		mask &= ~BIT(idx);
 1003ffe:	2101      	movs	r1, #1
 1004000:	fa01 f109 	lsl.w	r1, r1, r9
 1004004:	ea26 0601 	bic.w	r6, r6, r1
 1004008:	e7c7      	b.n	1003f9a <z_impl_log_process+0xa2>
	return backend->cb->active;
 100400a:	6873      	ldr	r3, [r6, #4]
			if (log_backend_is_active(backend) &&
 100400c:	795b      	ldrb	r3, [r3, #5]
 100400e:	b123      	cbz	r3, 100401a <z_impl_log_process+0x122>
	backend->api->put(backend, msg);
 1004010:	6833      	ldr	r3, [r6, #0]
 1004012:	4629      	mov	r1, r5
 1004014:	4630      	mov	r0, r6
 1004016:	681b      	ldr	r3, [r3, #0]
 1004018:	4798      	blx	r3
		for (int i = 0; i < log_backend_count_get(); i++) {
 100401a:	f108 0801 	add.w	r8, r8, #1
 100401e:	3610      	adds	r6, #16
 1004020:	45b8      	cmp	r8, r7
 1004022:	dbf2      	blt.n	100400a <z_impl_log_process+0x112>
 1004024:	e78a      	b.n	1003f3c <z_impl_log_process+0x44>
 1004026:	bf00      	nop
 1004028:	2100668c 	.word	0x2100668c
 100402c:	21000878 	.word	0x21000878
 1004030:	2100086c 	.word	0x2100086c
 1004034:	21000870 	.word	0x21000870
 1004038:	2100668d 	.word	0x2100668d
 100403c:	010180b8 	.word	0x010180b8
 1004040:	010181e0 	.word	0x010181e0
 1004044:	010181a8 	.word	0x010181a8
 1004048:	010181e0 	.word	0x010181e0
 100404c:	010181f0 	.word	0x010181f0
 1004050:	01017f48 	.word	0x01017f48
 1004054:	01019ab0 	.word	0x01019ab0
 1004058:	0101917a 	.word	0x0101917a
 100405c:	01019194 	.word	0x01019194

01004060 <msg_finalize>:
	msg->hdr.timestamp = timestamp_func();
 1004060:	4b27      	ldr	r3, [pc, #156]	; (1004100 <msg_finalize+0xa0>)
{
 1004062:	b573      	push	{r0, r1, r4, r5, r6, lr}
	msg->hdr.timestamp = timestamp_func();
 1004064:	681b      	ldr	r3, [r3, #0]
	msg->hdr.ids = src_level;
 1004066:	8141      	strh	r1, [r0, #10]
{
 1004068:	4604      	mov	r4, r0
	msg->hdr.timestamp = timestamp_func();
 100406a:	4798      	blx	r3
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 100406c:	4d25      	ldr	r5, [pc, #148]	; (1004104 <msg_finalize+0xa4>)
 100406e:	60e0      	str	r0, [r4, #12]
 1004070:	e8d5 3fef 	ldaex	r3, [r5]
 1004074:	3301      	adds	r3, #1
 1004076:	e8c5 3fe2 	stlex	r2, r3, [r5]
 100407a:	2a00      	cmp	r2, #0
 100407c:	d1f8      	bne.n	1004070 <msg_finalize+0x10>
	__asm__ volatile(
 100407e:	f04f 0320 	mov.w	r3, #32
 1004082:	f3ef 8611 	mrs	r6, BASEPRI
 1004086:	f383 8811 	msr	BASEPRI, r3
 100408a:	f3bf 8f6f 	isb	sy
	log_list_add_tail(&list, msg);
 100408e:	481e      	ldr	r0, [pc, #120]	; (1004108 <msg_finalize+0xa8>)
 1004090:	4621      	mov	r1, r4
 1004092:	f011 f93d 	bl	1015310 <log_list_add_tail>
	__asm__ volatile(
 1004096:	f386 8811 	msr	BASEPRI, r6
 100409a:	f3bf 8f6f 	isb	sy
	if (panic_mode) {
 100409e:	4b1b      	ldr	r3, [pc, #108]	; (100410c <msg_finalize+0xac>)
 10040a0:	781b      	ldrb	r3, [r3, #0]
 10040a2:	b183      	cbz	r3, 10040c6 <msg_finalize+0x66>
	__asm__ volatile(
 10040a4:	f04f 0320 	mov.w	r3, #32
 10040a8:	f3ef 8411 	mrs	r4, BASEPRI
 10040ac:	f383 8811 	msr	BASEPRI, r3
 10040b0:	f3bf 8f6f 	isb	sy
	if (z_syscall_trap()) {
		return (bool) arch_syscall_invoke1(*(uintptr_t *)&bypass, K_SYSCALL_LOG_PROCESS);
	}
#endif
	compiler_barrier();
	return z_impl_log_process(bypass);
 10040b4:	2000      	movs	r0, #0
 10040b6:	f7ff ff1f 	bl	1003ef8 <z_impl_log_process>
	__asm__ volatile(
 10040ba:	f384 8811 	msr	BASEPRI, r4
 10040be:	f3bf 8f6f 	isb	sy
}
 10040c2:	b002      	add	sp, #8
 10040c4:	bd70      	pop	{r4, r5, r6, pc}
	} else if (proc_tid != NULL && buffered_cnt == 1) {
 10040c6:	4a12      	ldr	r2, [pc, #72]	; (1004110 <msg_finalize+0xb0>)
 10040c8:	682b      	ldr	r3, [r5, #0]
 10040ca:	6812      	ldr	r2, [r2, #0]
 10040cc:	2a00      	cmp	r2, #0
 10040ce:	d0f8      	beq.n	10040c2 <msg_finalize+0x62>
 10040d0:	2b01      	cmp	r3, #1
 10040d2:	d10a      	bne.n	10040ea <msg_finalize+0x8a>
	z_impl_k_timer_start(timer, duration, period);
 10040d4:	2200      	movs	r2, #0
 10040d6:	2300      	movs	r3, #0
 10040d8:	480e      	ldr	r0, [pc, #56]	; (1004114 <msg_finalize+0xb4>)
 10040da:	e9cd 2300 	strd	r2, r3, [sp]
 10040de:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 10040e2:	2300      	movs	r3, #0
 10040e4:	f010 fd7a 	bl	1014bdc <z_impl_k_timer_start>
 10040e8:	e7eb      	b.n	10040c2 <msg_finalize+0x62>
		if ((buffered_cnt == CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) &&
 10040ea:	2b0a      	cmp	r3, #10
 10040ec:	d1e9      	bne.n	10040c2 <msg_finalize+0x62>
	z_impl_k_timer_stop(timer);
 10040ee:	4809      	ldr	r0, [pc, #36]	; (1004114 <msg_finalize+0xb4>)
 10040f0:	f013 fdfb 	bl	1017cea <z_impl_k_timer_stop>
	z_impl_k_sem_give(sem);
 10040f4:	4808      	ldr	r0, [pc, #32]	; (1004118 <msg_finalize+0xb8>)
}
 10040f6:	b002      	add	sp, #8
 10040f8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 10040fc:	f010 baa4 	b.w	1014648 <z_impl_k_sem_give>
 1004100:	2100006c 	.word	0x2100006c
 1004104:	2100086c 	.word	0x2100086c
 1004108:	21000878 	.word	0x21000878
 100410c:	2100668d 	.word	0x2100668d
 1004110:	21000910 	.word	0x21000910
 1004114:	21000690 	.word	0x21000690
 1004118:	21000540 	.word	0x21000540

0100411c <log_process_thread_func>:
{
 100411c:	b510      	push	{r4, lr}
	log_init();
 100411e:	f7ff fe85 	bl	1003e2c <log_init>
	return z_impl_k_current_get();
 1004122:	f010 fa8b 	bl	101463c <z_impl_k_current_get>
	proc_tid = process_tid;
 1004126:	4b0c      	ldr	r3, [pc, #48]	; (1004158 <log_process_thread_func+0x3c>)
 1004128:	6018      	str	r0, [r3, #0]
	if (CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD &&
 100412a:	b130      	cbz	r0, 100413a <log_process_thread_func+0x1e>
	    buffered_cnt >= CONFIG_LOG_PROCESS_TRIGGER_THRESHOLD) {
 100412c:	4b0b      	ldr	r3, [pc, #44]	; (100415c <log_process_thread_func+0x40>)
	    process_tid &&
 100412e:	681b      	ldr	r3, [r3, #0]
 1004130:	2b09      	cmp	r3, #9
 1004132:	dd02      	ble.n	100413a <log_process_thread_func+0x1e>
	z_impl_k_sem_give(sem);
 1004134:	480a      	ldr	r0, [pc, #40]	; (1004160 <log_process_thread_func+0x44>)
 1004136:	f010 fa87 	bl	1014648 <z_impl_k_sem_give>
	return z_impl_k_sem_take(sem, timeout);
 100413a:	4c09      	ldr	r4, [pc, #36]	; (1004160 <log_process_thread_func+0x44>)
 100413c:	2000      	movs	r0, #0
 100413e:	f7ff fedb 	bl	1003ef8 <z_impl_log_process>
		if (log_process(false) == false) {
 1004142:	2800      	cmp	r0, #0
 1004144:	d1fa      	bne.n	100413c <log_process_thread_func+0x20>
 1004146:	f04f 32ff 	mov.w	r2, #4294967295
 100414a:	f04f 33ff 	mov.w	r3, #4294967295
 100414e:	4620      	mov	r0, r4
 1004150:	f010 faa0 	bl	1014694 <z_impl_k_sem_take>
 1004154:	e7f2      	b.n	100413c <log_process_thread_func+0x20>
 1004156:	bf00      	nop
 1004158:	21000910 	.word	0x21000910
 100415c:	2100086c 	.word	0x2100086c
 1004160:	21000540 	.word	0x21000540

01004164 <z_impl_log_panic>:
{
 1004164:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (panic_mode) {
 1004166:	4f0e      	ldr	r7, [pc, #56]	; (10041a0 <z_impl_log_panic+0x3c>)
 1004168:	783d      	ldrb	r5, [r7, #0]
 100416a:	b975      	cbnz	r5, 100418a <z_impl_log_panic+0x26>
	log_init();
 100416c:	f7ff fe5e 	bl	1003e2c <log_init>
	return __log_backends_end - __log_backends_start;
 1004170:	4c0c      	ldr	r4, [pc, #48]	; (10041a4 <z_impl_log_panic+0x40>)
 1004172:	4e0d      	ldr	r6, [pc, #52]	; (10041a8 <z_impl_log_panic+0x44>)
 1004174:	1b36      	subs	r6, r6, r4
 1004176:	1136      	asrs	r6, r6, #4
	for (int i = 0; i < log_backend_count_get(); i++) {
 1004178:	42b5      	cmp	r5, r6
 100417a:	db07      	blt.n	100418c <z_impl_log_panic+0x28>
 100417c:	2000      	movs	r0, #0
 100417e:	f7ff febb 	bl	1003ef8 <z_impl_log_process>
		while (log_process(false) == true) {
 1004182:	2800      	cmp	r0, #0
 1004184:	d1fa      	bne.n	100417c <z_impl_log_panic+0x18>
	panic_mode = true;
 1004186:	2301      	movs	r3, #1
 1004188:	703b      	strb	r3, [r7, #0]
}
 100418a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	return backend->cb->active;
 100418c:	6863      	ldr	r3, [r4, #4]
		if (log_backend_is_active(backend)) {
 100418e:	795b      	ldrb	r3, [r3, #5]
 1004190:	b11b      	cbz	r3, 100419a <z_impl_log_panic+0x36>
	backend->api->panic(backend);
 1004192:	6823      	ldr	r3, [r4, #0]
 1004194:	4620      	mov	r0, r4
 1004196:	691b      	ldr	r3, [r3, #16]
 1004198:	4798      	blx	r3
	for (int i = 0; i < log_backend_count_get(); i++) {
 100419a:	3501      	adds	r5, #1
 100419c:	3410      	adds	r4, #16
 100419e:	e7eb      	b.n	1004178 <z_impl_log_panic+0x14>
 10041a0:	2100668d 	.word	0x2100668d
 10041a4:	010181e0 	.word	0x010181e0
 10041a8:	010181f0 	.word	0x010181f0

010041ac <log_free>:
{
 10041ac:	b507      	push	{r0, r1, r2, lr}
	struct log_strdup_buf *dup = CONTAINER_OF(str, struct log_strdup_buf,
 10041ae:	3804      	subs	r0, #4
 10041b0:	9001      	str	r0, [sp, #4]
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
 10041b2:	e8d0 3fef 	ldaex	r3, [r0]
 10041b6:	1e5a      	subs	r2, r3, #1
 10041b8:	e8c0 2fe1 	stlex	r1, r2, [r0]
 10041bc:	2900      	cmp	r1, #0
 10041be:	d1f8      	bne.n	10041b2 <log_free+0x6>
	if (atomic_dec(&dup->refcount) == 1) {
 10041c0:	2b01      	cmp	r3, #1
 10041c2:	d103      	bne.n	10041cc <log_free+0x20>
		k_mem_slab_free(&log_strdup_pool, (void **)&dup);
 10041c4:	4803      	ldr	r0, [pc, #12]	; (10041d4 <log_free+0x28>)
 10041c6:	a901      	add	r1, sp, #4
 10041c8:	f00f feb8 	bl	1013f3c <k_mem_slab_free>
}
 10041cc:	b003      	add	sp, #12
 10041ce:	f85d fb04 	ldr.w	pc, [sp], #4
 10041d2:	bf00      	nop
 10041d4:	21000880 	.word	0x21000880

010041d8 <log_msg_pool_init>:
static u8_t __noinit __aligned(sizeof(void *))
		log_msg_pool_buf[CONFIG_LOG_BUFFER_SIZE];

void log_msg_pool_init(void)
{
	k_mem_slab_init(&log_msg_pool, log_msg_pool_buf, MSG_SIZE, NUM_OF_MSGS);
 10041d8:	2320      	movs	r3, #32
 10041da:	4902      	ldr	r1, [pc, #8]	; (10041e4 <log_msg_pool_init+0xc>)
 10041dc:	461a      	mov	r2, r3
 10041de:	4802      	ldr	r0, [pc, #8]	; (10041e8 <log_msg_pool_init+0x10>)
 10041e0:	f013 ba4f 	b.w	1017682 <k_mem_slab_init>
 10041e4:	210083b0 	.word	0x210083b0
 10041e8:	21000914 	.word	0x21000914

010041ec <log_msg_no_space_handle>:
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
}

union log_msg_chunk *log_msg_no_space_handle(void)
{
	union log_msg_chunk *msg = NULL;
 10041ec:	2300      	movs	r3, #0
{
 10041ee:	b537      	push	{r0, r1, r2, r4, r5, lr}

	if (IS_ENABLED(CONFIG_LOG_MODE_OVERFLOW)) {
		do {
			more = log_process(true);
			log_dropped();
			err = k_mem_slab_alloc(&log_msg_pool,
 10041f0:	4d09      	ldr	r5, [pc, #36]	; (1004218 <log_msg_no_space_handle+0x2c>)
	union log_msg_chunk *msg = NULL;
 10041f2:	9301      	str	r3, [sp, #4]
 10041f4:	2001      	movs	r0, #1
 10041f6:	f7ff fe7f 	bl	1003ef8 <z_impl_log_process>
 10041fa:	4604      	mov	r4, r0
			log_dropped();
 10041fc:	f7ff fde2 	bl	1003dc4 <log_dropped>
			err = k_mem_slab_alloc(&log_msg_pool,
 1004200:	2200      	movs	r2, #0
 1004202:	2300      	movs	r3, #0
 1004204:	4628      	mov	r0, r5
 1004206:	a901      	add	r1, sp, #4
 1004208:	f00f fe66 	bl	1013ed8 <k_mem_slab_alloc>
					       (void **)&msg,
					       K_NO_WAIT);
		} while ((err != 0) && more);
 100420c:	b108      	cbz	r0, 1004212 <log_msg_no_space_handle+0x26>
 100420e:	2c00      	cmp	r4, #0
 1004210:	d1f0      	bne.n	10041f4 <log_msg_no_space_handle+0x8>
	} else {
		log_dropped();
	}
	return msg;

}
 1004212:	9801      	ldr	r0, [sp, #4]
 1004214:	b003      	add	sp, #12
 1004216:	bd30      	pop	{r4, r5, pc}
 1004218:	21000914 	.word	0x21000914

0100421c <log_msg_chunk_alloc>:
	union log_msg_chunk *msg = NULL;
 100421c:	2300      	movs	r3, #0
{
 100421e:	b507      	push	{r0, r1, r2, lr}
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
 1004220:	2200      	movs	r2, #0
	union log_msg_chunk *msg = NULL;
 1004222:	9301      	str	r3, [sp, #4]
	int err = k_mem_slab_alloc(&log_msg_pool, (void **)&msg,
 1004224:	4806      	ldr	r0, [pc, #24]	; (1004240 <log_msg_chunk_alloc+0x24>)
 1004226:	2300      	movs	r3, #0
 1004228:	a901      	add	r1, sp, #4
 100422a:	f00f fe55 	bl	1013ed8 <k_mem_slab_alloc>
	if (err != 0) {
 100422e:	b110      	cbz	r0, 1004236 <log_msg_chunk_alloc+0x1a>
		msg = log_msg_no_space_handle();
 1004230:	f7ff ffdc 	bl	10041ec <log_msg_no_space_handle>
 1004234:	9001      	str	r0, [sp, #4]
}
 1004236:	9801      	ldr	r0, [sp, #4]
 1004238:	b003      	add	sp, #12
 100423a:	f85d fb04 	ldr.w	pc, [sp], #4
 100423e:	bf00      	nop
 1004240:	21000914 	.word	0x21000914

01004244 <msg_free>:
{
 1004244:	b5f0      	push	{r4, r5, r6, r7, lr}
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
 1004246:	7a03      	ldrb	r3, [r0, #8]
	}
}

u32_t log_msg_nargs_get(struct log_msg *msg)
{
	return msg->hdr.params.std.nargs;
 1004248:	7a45      	ldrb	r5, [r0, #9]
{
 100424a:	b085      	sub	sp, #20
 100424c:	9001      	str	r0, [sp, #4]
	if (log_msg_is_std(msg) && nargs) {
 100424e:	07d8      	lsls	r0, r3, #31
	return msg->hdr.params.std.nargs;
 1004250:	ea4f 1515 	mov.w	r5, r5, lsr #4
	if (log_msg_is_std(msg) && nargs) {
 1004254:	d41c      	bmi.n	1004290 <msg_free+0x4c>
 1004256:	b1dd      	cbz	r5, 1004290 <msg_free+0x4c>
		u32_t smask = 0;
 1004258:	2400      	movs	r4, #0
		for (i = 0; i < nargs; i++) {
 100425a:	4626      	mov	r6, r4
			void *buf = (void *)log_msg_arg_get(msg, i);
 100425c:	4631      	mov	r1, r6
 100425e:	9801      	ldr	r0, [sp, #4]
 1004260:	f011 f955 	bl	101550e <log_msg_arg_get>
 1004264:	4607      	mov	r7, r0
			if (log_is_strdup(buf)) {
 1004266:	f7ff fe39 	bl	1003edc <log_is_strdup>
 100426a:	b170      	cbz	r0, 100428a <msg_free+0x46>
				if (smask == 0) {
 100426c:	b934      	cbnz	r4, 100427c <msg_free+0x38>
					smask = z_log_get_s_mask(
 100426e:	9b01      	ldr	r3, [sp, #4]
 1004270:	4629      	mov	r1, r5
 1004272:	6918      	ldr	r0, [r3, #16]
 1004274:	f011 f86b 	bl	101534e <z_log_get_s_mask>
					if (smask == 0) {
 1004278:	4604      	mov	r4, r0
 100427a:	b148      	cbz	r0, 1004290 <msg_free+0x4c>
				if (smask & BIT(i)) {
 100427c:	fa24 f306 	lsr.w	r3, r4, r6
 1004280:	07d9      	lsls	r1, r3, #31
 1004282:	d502      	bpl.n	100428a <msg_free+0x46>
					log_free(buf);
 1004284:	4638      	mov	r0, r7
 1004286:	f7ff ff91 	bl	10041ac <log_free>
		for (i = 0; i < nargs; i++) {
 100428a:	3601      	adds	r6, #1
 100428c:	42ae      	cmp	r6, r5
 100428e:	d3e5      	bcc.n	100425c <msg_free+0x18>
	if (msg->hdr.params.generic.ext == 1) {
 1004290:	9b01      	ldr	r3, [sp, #4]
 1004292:	7a1a      	ldrb	r2, [r3, #8]
 1004294:	0792      	lsls	r2, r2, #30
 1004296:	d504      	bpl.n	10042a2 <msg_free+0x5e>
		cont_free(msg->payload.ext.next);
 1004298:	695b      	ldr	r3, [r3, #20]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
 100429a:	4c08      	ldr	r4, [pc, #32]	; (10042bc <msg_free+0x78>)
 100429c:	9303      	str	r3, [sp, #12]
	while (cont != NULL) {
 100429e:	9b03      	ldr	r3, [sp, #12]
 10042a0:	b92b      	cbnz	r3, 10042ae <msg_free+0x6a>
	k_mem_slab_free(&log_msg_pool, (void **)&msg);
 10042a2:	4806      	ldr	r0, [pc, #24]	; (10042bc <msg_free+0x78>)
 10042a4:	a901      	add	r1, sp, #4
 10042a6:	f00f fe49 	bl	1013f3c <k_mem_slab_free>
}
 10042aa:	b005      	add	sp, #20
 10042ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
		next = cont->next;
 10042ae:	681d      	ldr	r5, [r3, #0]
		k_mem_slab_free(&log_msg_pool, (void **)&cont);
 10042b0:	4620      	mov	r0, r4
 10042b2:	a903      	add	r1, sp, #12
 10042b4:	f00f fe42 	bl	1013f3c <k_mem_slab_free>
		cont = next;
 10042b8:	9503      	str	r5, [sp, #12]
 10042ba:	e7f0      	b.n	100429e <msg_free+0x5a>
 10042bc:	21000914 	.word	0x21000914

010042c0 <print_formatted>:
	return 0;
}

static int print_formatted(const struct log_output *log_output,
			   const char *fmt, ...)
{
 10042c0:	b40e      	push	{r1, r2, r3}
 10042c2:	b503      	push	{r0, r1, lr}
 10042c4:	ab03      	add	r3, sp, #12
 10042c6:	f853 2b04 	ldr.w	r2, [r3], #4
 10042ca:	4601      	mov	r1, r0
	va_start(args, fmt);
#if !defined(CONFIG_NEWLIB_LIBC) && !defined(CONFIG_ARCH_POSIX) && \
    defined(CONFIG_LOG_ENABLE_FANCY_OUTPUT_FORMATTING)
	length = z_prf(out_func, (void *)log_output, (char *)fmt, args);
#else
	z_vprintk(out_func, (void *)log_output, fmt, args);
 10042cc:	4804      	ldr	r0, [pc, #16]	; (10042e0 <print_formatted+0x20>)
	va_start(args, fmt);
 10042ce:	9301      	str	r3, [sp, #4]
	z_vprintk(out_func, (void *)log_output, fmt, args);
 10042d0:	f7ff fb2a 	bl	1003928 <z_vprintk>
#endif
	va_end(args);

	return length;
}
 10042d4:	2000      	movs	r0, #0
 10042d6:	b002      	add	sp, #8
 10042d8:	f85d eb04 	ldr.w	lr, [sp], #4
 10042dc:	b003      	add	sp, #12
 10042de:	4770      	bx	lr
 10042e0:	01015913 	.word	0x01015913

010042e4 <prefix_print>:
}

static u32_t prefix_print(const struct log_output *log_output,
			 u32_t flags, bool func_on, u32_t timestamp, u8_t level,
			 u8_t domain_id, u16_t source_id)
{
 10042e4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			"<%d>1 ",
			facility * 8 +
			level_to_rfc5424_severity(level));
	}

	if (stamp) {
 10042e8:	f011 0402 	ands.w	r4, r1, #2
{
 10042ec:	b085      	sub	sp, #20
 10042ee:	4690      	mov	r8, r2
 10042f0:	4606      	mov	r6, r0
 10042f2:	461a      	mov	r2, r3
 10042f4:	f89d 7038 	ldrb.w	r7, [sp, #56]	; 0x38
	bool colors_on = flags & LOG_OUTPUT_FLAG_COLORS;
 10042f8:	f001 0901 	and.w	r9, r1, #1
	bool level_on = flags & LOG_OUTPUT_FLAG_LEVEL;
 10042fc:	f001 0508 	and.w	r5, r1, #8
	if (stamp) {
 1004300:	d007      	beq.n	1004312 <prefix_print+0x2e>
	if (!format) {
 1004302:	f011 0f44 	tst.w	r1, #68	; 0x44
 1004306:	d137      	bne.n	1004378 <prefix_print+0x94>
		length = print_formatted(log_output, "[%08lu] ", timestamp);
 1004308:	4932      	ldr	r1, [pc, #200]	; (10043d4 <prefix_print+0xf0>)
 100430a:	f7ff ffd9 	bl	10042c0 <print_formatted>
			length = print_formatted(log_output,
 100430e:	4601      	mov	r1, r0
		length += timestamp_print(log_output, flags, timestamp);
 1004310:	460c      	mov	r4, r1
	if (color) {
 1004312:	f1b9 0f00 	cmp.w	r9, #0
 1004316:	d00a      	beq.n	100432e <prefix_print+0x4a>
		const char *color = start && (colors[level] != NULL) ?
 1004318:	4b2f      	ldr	r3, [pc, #188]	; (10043d8 <prefix_print+0xf4>)
		print_formatted(log_output, "%s", color);
 100431a:	4630      	mov	r0, r6
		const char *color = start && (colors[level] != NULL) ?
 100431c:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
		print_formatted(log_output, "%s", color);
 1004320:	4b2e      	ldr	r3, [pc, #184]	; (10043dc <prefix_print+0xf8>)
 1004322:	492f      	ldr	r1, [pc, #188]	; (10043e0 <prefix_print+0xfc>)
 1004324:	2a00      	cmp	r2, #0
 1004326:	bf08      	it	eq
 1004328:	461a      	moveq	r2, r3
 100432a:	f7ff ffc9 	bl	10042c0 <print_formatted>
	if (level_on) {
 100432e:	b13d      	cbz	r5, 1004340 <prefix_print+0x5c>
		total += print_formatted(log_output, "<%s> ", severity[level]);
 1004330:	4b2c      	ldr	r3, [pc, #176]	; (10043e4 <prefix_print+0x100>)
 1004332:	4630      	mov	r0, r6
 1004334:	f853 2027 	ldr.w	r2, [r3, r7, lsl #2]
 1004338:	492b      	ldr	r1, [pc, #172]	; (10043e8 <prefix_print+0x104>)
 100433a:	f7ff ffc1 	bl	10042c0 <print_formatted>
 100433e:	4605      	mov	r5, r0
	total += print_formatted(log_output,
 1004340:	f1b8 0f00 	cmp.w	r8, #0
 1004344:	d043      	beq.n	10043ce <prefix_print+0xea>
				((1 << level) & LOG_FUNCTION_PREFIX_MASK)) ?
 1004346:	2301      	movs	r3, #1
 1004348:	fa03 f707 	lsl.w	r7, r3, r7
	total += print_formatted(log_output,
 100434c:	4b27      	ldr	r3, [pc, #156]	; (10043ec <prefix_print+0x108>)
 100434e:	f017 0f10 	tst.w	r7, #16
 1004352:	4f27      	ldr	r7, [pc, #156]	; (10043f0 <prefix_print+0x10c>)
 1004354:	bf18      	it	ne
 1004356:	461f      	movne	r7, r3
 1004358:	f8bd 1040 	ldrh.w	r1, [sp, #64]	; 0x40
 100435c:	f89d 003c 	ldrb.w	r0, [sp, #60]	; 0x3c
 1004360:	f7ff fd3c 	bl	1003ddc <log_source_name_get>
 1004364:	4639      	mov	r1, r7
 1004366:	4602      	mov	r2, r0
 1004368:	4630      	mov	r0, r6
 100436a:	f7ff ffa9 	bl	10042c0 <print_formatted>
 100436e:	4428      	add	r0, r5
		length += ids_print(log_output, level_on, func_on,
				    domain_id, source_id, level);
	}

	return length;
}
 1004370:	4420      	add	r0, r4
 1004372:	b005      	add	sp, #20
 1004374:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	} else if (freq != 0U) {
 1004378:	4b1e      	ldr	r3, [pc, #120]	; (10043f4 <prefix_print+0x110>)
 100437a:	6819      	ldr	r1, [r3, #0]
 100437c:	2900      	cmp	r1, #0
 100437e:	d0c7      	beq.n	1004310 <prefix_print+0x2c>
		timestamp /= timestamp_div;
 1004380:	4b1d      	ldr	r3, [pc, #116]	; (10043f8 <prefix_print+0x114>)
 1004382:	f44f 6e61 	mov.w	lr, #3600	; 0xe10
 1004386:	681b      	ldr	r3, [r3, #0]
		ms = (remainder * 1000U) / freq;
 1004388:	f44f 7c7a 	mov.w	ip, #1000	; 0x3e8
		timestamp /= timestamp_div;
 100438c:	fbb2 f3f3 	udiv	r3, r2, r3
		seconds = timestamp / freq;
 1004390:	fbb3 f4f1 	udiv	r4, r3, r1
		seconds -= hours * 3600U;
 1004394:	fbb4 f2fe 	udiv	r2, r4, lr
 1004398:	fb0e 4e12 	mls	lr, lr, r2, r4
		remainder = timestamp % freq;
 100439c:	fb01 3414 	mls	r4, r1, r4, r3
		ms = (remainder * 1000U) / freq;
 10043a0:	fb0c f404 	mul.w	r4, ip, r4
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
 10043a4:	fbb4 fbf1 	udiv	fp, r4, r1
		mins = seconds / 60U;
 10043a8:	f04f 0a3c 	mov.w	sl, #60	; 0x3c
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
 10043ac:	fb01 441b 	mls	r4, r1, fp, r4
 10043b0:	fb0c f404 	mul.w	r4, ip, r4
		mins = seconds / 60U;
 10043b4:	fbbe f3fa 	udiv	r3, lr, sl
		us = (1000 * (remainder * 1000U - (ms * freq))) / freq;
 10043b8:	fbb4 f1f1 	udiv	r1, r4, r1
			length = print_formatted(log_output,
 10043bc:	e9cd b101 	strd	fp, r1, [sp, #4]
 10043c0:	fb0a e113 	mls	r1, sl, r3, lr
 10043c4:	9100      	str	r1, [sp, #0]
 10043c6:	490d      	ldr	r1, [pc, #52]	; (10043fc <prefix_print+0x118>)
 10043c8:	f7ff ff7a 	bl	10042c0 <print_formatted>
 10043cc:	e79f      	b.n	100430e <prefix_print+0x2a>
	total += print_formatted(log_output,
 10043ce:	4f08      	ldr	r7, [pc, #32]	; (10043f0 <prefix_print+0x10c>)
 10043d0:	e7c2      	b.n	1004358 <prefix_print+0x74>
 10043d2:	bf00      	nop
 10043d4:	010191e5 	.word	0x010191e5
 10043d8:	0101822c 	.word	0x0101822c
 10043dc:	010191d7 	.word	0x010191d7
 10043e0:	0101920a 	.word	0x0101920a
 10043e4:	01018240 	.word	0x01018240
 10043e8:	0101920d 	.word	0x0101920d
 10043ec:	010191e1 	.word	0x010191e1
 10043f0:	010191dc 	.word	0x010191dc
 10043f4:	21000930 	.word	0x21000930
 10043f8:	21000934 	.word	0x21000934
 10043fc:	010191ee 	.word	0x010191ee

01004400 <postfix_print>:

static void postfix_print(const struct log_output *log_output,
			  u32_t flags, u8_t level)
{
 1004400:	b538      	push	{r3, r4, r5, lr}
 1004402:	460c      	mov	r4, r1
	if (color) {
 1004404:	07e1      	lsls	r1, r4, #31
{
 1004406:	4605      	mov	r5, r0
	if (color) {
 1004408:	d503      	bpl.n	1004412 <postfix_print+0x12>
		print_formatted(log_output, "%s", color);
 100440a:	4a08      	ldr	r2, [pc, #32]	; (100442c <postfix_print+0x2c>)
 100440c:	4908      	ldr	r1, [pc, #32]	; (1004430 <postfix_print+0x30>)
 100440e:	f7ff ff57 	bl	10042c0 <print_formatted>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
 1004412:	06e2      	lsls	r2, r4, #27
 1004414:	d408      	bmi.n	1004428 <postfix_print+0x28>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
 1004416:	06a3      	lsls	r3, r4, #26
		print_formatted(ctx, "\r\n");
 1004418:	4628      	mov	r0, r5
	color_postfix(log_output, (flags & LOG_OUTPUT_FLAG_COLORS),
			      level);
	newline_print(log_output, flags);
}
 100441a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		print_formatted(ctx, "\n");
 100441e:	bf4c      	ite	mi
 1004420:	4904      	ldrmi	r1, [pc, #16]	; (1004434 <postfix_print+0x34>)
		print_formatted(ctx, "\r\n");
 1004422:	4905      	ldrpl	r1, [pc, #20]	; (1004438 <postfix_print+0x38>)
 1004424:	f7ff bf4c 	b.w	10042c0 <print_formatted>
}
 1004428:	bd38      	pop	{r3, r4, r5, pc}
 100442a:	bf00      	nop
 100442c:	010191d7 	.word	0x010191d7
 1004430:	0101920a 	.word	0x0101920a
 1004434:	01019214 	.word	0x01019214
 1004438:	01019213 	.word	0x01019213

0100443c <hexdump_line_print>:
{
 100443c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1004440:	461d      	mov	r5, r3
 1004442:	9b08      	ldr	r3, [sp, #32]
 1004444:	4617      	mov	r7, r2
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
 1004446:	06da      	lsls	r2, r3, #27
{
 1004448:	4604      	mov	r4, r0
 100444a:	460e      	mov	r6, r1
	if ((flags & LOG_OUTPUT_FLAG_CRLF_NONE) != 0U) {
 100444c:	d405      	bmi.n	100445a <hexdump_line_print+0x1e>
	if ((flags & LOG_OUTPUT_FLAG_CRLF_LFONLY) != 0U) {
 100444e:	0699      	lsls	r1, r3, #26
		print_formatted(ctx, "\n");
 1004450:	bf4c      	ite	mi
 1004452:	492a      	ldrmi	r1, [pc, #168]	; (10044fc <hexdump_line_print+0xc0>)
		print_formatted(ctx, "\r\n");
 1004454:	492a      	ldrpl	r1, [pc, #168]	; (1004500 <hexdump_line_print+0xc4>)
 1004456:	f7ff ff33 	bl	10042c0 <print_formatted>
{
 100445a:	f04f 0800 	mov.w	r8, #0
		print_formatted(log_output, " ");
 100445e:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 1004508 <hexdump_line_print+0xcc>
	for (int i = 0; i < prefix_offset; i++) {
 1004462:	45a8      	cmp	r8, r5
 1004464:	db2a      	blt.n	10044bc <hexdump_line_print+0x80>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 1004466:	2500      	movs	r5, #0
			print_formatted(log_output, "   ");
 1004468:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 100450c <hexdump_line_print+0xd0>
			print_formatted(log_output, "%02x ", data[i]);
 100446c:	f8df 90a0 	ldr.w	r9, [pc, #160]	; 1004510 <hexdump_line_print+0xd4>
			print_formatted(log_output, " ");
 1004470:	f8df a094 	ldr.w	sl, [pc, #148]	; 1004508 <hexdump_line_print+0xcc>
		if (i < length) {
 1004474:	42bd      	cmp	r5, r7
 1004476:	d22f      	bcs.n	10044d8 <hexdump_line_print+0x9c>
			print_formatted(log_output, "%02x ", data[i]);
 1004478:	4649      	mov	r1, r9
 100447a:	4620      	mov	r0, r4
 100447c:	5d72      	ldrb	r2, [r6, r5]
 100447e:	f7ff ff1f 	bl	10042c0 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 1004482:	3501      	adds	r5, #1
 1004484:	2d10      	cmp	r5, #16
 1004486:	d120      	bne.n	10044ca <hexdump_line_print+0x8e>
	print_formatted(log_output, "|");
 1004488:	4620      	mov	r0, r4
 100448a:	491e      	ldr	r1, [pc, #120]	; (1004504 <hexdump_line_print+0xc8>)
 100448c:	f7ff ff18 	bl	10042c0 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 1004490:	2500      	movs	r5, #0
			print_formatted(log_output, " ");
 1004492:	f8df 8074 	ldr.w	r8, [pc, #116]	; 1004508 <hexdump_line_print+0xcc>
			print_formatted(log_output, "%c",
 1004496:	f8df 907c 	ldr.w	r9, [pc, #124]	; 1004514 <hexdump_line_print+0xd8>
		if (i < length) {
 100449a:	42af      	cmp	r7, r5
 100449c:	d928      	bls.n	10044f0 <hexdump_line_print+0xb4>
			char c = (char)data[i];
 100449e:	5d72      	ldrb	r2, [r6, r5]
			print_formatted(log_output, "%c",
 10044a0:	4649      	mov	r1, r9
			(((unsigned)c) <= (unsigned)'~'));
}

static inline int isprint(int c)
{
	return (int)((((unsigned)c) >= ' ') &&
 10044a2:	f1a2 0320 	sub.w	r3, r2, #32
 10044a6:	2b5f      	cmp	r3, #95	; 0x5f
 10044a8:	bf28      	it	cs
 10044aa:	222e      	movcs	r2, #46	; 0x2e
 10044ac:	4620      	mov	r0, r4
 10044ae:	f7ff ff07 	bl	10042c0 <print_formatted>
	for (int i = 0; i < HEXDUMP_BYTES_IN_LINE; i++) {
 10044b2:	3501      	adds	r5, #1
 10044b4:	2d10      	cmp	r5, #16
 10044b6:	d114      	bne.n	10044e2 <hexdump_line_print+0xa6>
}
 10044b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(log_output, " ");
 10044bc:	4649      	mov	r1, r9
 10044be:	4620      	mov	r0, r4
 10044c0:	f7ff fefe 	bl	10042c0 <print_formatted>
	for (int i = 0; i < prefix_offset; i++) {
 10044c4:	f108 0801 	add.w	r8, r8, #1
 10044c8:	e7cb      	b.n	1004462 <hexdump_line_print+0x26>
		if (i > 0 && !(i % 8)) {
 10044ca:	076a      	lsls	r2, r5, #29
 10044cc:	d1d2      	bne.n	1004474 <hexdump_line_print+0x38>
			print_formatted(log_output, " ");
 10044ce:	4651      	mov	r1, sl
 10044d0:	4620      	mov	r0, r4
 10044d2:	f7ff fef5 	bl	10042c0 <print_formatted>
 10044d6:	e7cd      	b.n	1004474 <hexdump_line_print+0x38>
			print_formatted(log_output, "   ");
 10044d8:	4641      	mov	r1, r8
 10044da:	4620      	mov	r0, r4
 10044dc:	f7ff fef0 	bl	10042c0 <print_formatted>
 10044e0:	e7cf      	b.n	1004482 <hexdump_line_print+0x46>
		if (i > 0 && !(i % 8)) {
 10044e2:	076b      	lsls	r3, r5, #29
 10044e4:	d1d9      	bne.n	100449a <hexdump_line_print+0x5e>
			print_formatted(log_output, " ");
 10044e6:	4641      	mov	r1, r8
 10044e8:	4620      	mov	r0, r4
 10044ea:	f7ff fee9 	bl	10042c0 <print_formatted>
 10044ee:	e7d4      	b.n	100449a <hexdump_line_print+0x5e>
			print_formatted(log_output, " ");
 10044f0:	4641      	mov	r1, r8
 10044f2:	4620      	mov	r0, r4
 10044f4:	f7ff fee4 	bl	10042c0 <print_formatted>
 10044f8:	e7db      	b.n	10044b2 <hexdump_line_print+0x76>
 10044fa:	bf00      	nop
 10044fc:	01019214 	.word	0x01019214
 1004500:	01019213 	.word	0x01019213
 1004504:	0101921c 	.word	0x0101921c
 1004508:	01019979 	.word	0x01019979
 100450c:	01019977 	.word	0x01019977
 1004510:	01019216 	.word	0x01019216
 1004514:	0101921e 	.word	0x0101921e

01004518 <log_output_msg_process>:

void log_output_msg_process(const struct log_output *log_output,
			    struct log_msg *msg,
			    u32_t flags)
{
 1004518:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return msg->hdr.ids.level;
 100451c:	7a8b      	ldrb	r3, [r1, #10]
 100451e:	4617      	mov	r7, r2
		log_output_msg_syst_process(log_output, msg, flags);
		return;
	}

	prefix_offset = raw_string ?
			0 : prefix_print(log_output, flags, std_msg, timestamp,
 1004520:	f013 0807 	ands.w	r8, r3, #7
{
 1004524:	4605      	mov	r5, r0
 1004526:	460e      	mov	r6, r1
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
 1004528:	7a0a      	ldrb	r2, [r1, #8]
 100452a:	b08a      	sub	sp, #40	; 0x28
			0 : prefix_print(log_output, flags, std_msg, timestamp,
 100452c:	d021      	beq.n	1004572 <log_output_msg_process+0x5a>
 100452e:	43d2      	mvns	r2, r2
	return msg->hdr.ids.source_id;
 1004530:	8949      	ldrh	r1, [r1, #10]
 1004532:	f3c3 03c2 	ubfx	r3, r3, #3, #3
 1004536:	f3c1 1189 	ubfx	r1, r1, #6, #10
 100453a:	e9cd 8300 	strd	r8, r3, [sp]
 100453e:	9102      	str	r1, [sp, #8]
 1004540:	68f3      	ldr	r3, [r6, #12]
 1004542:	4639      	mov	r1, r7
 1004544:	f002 0201 	and.w	r2, r2, #1
 1004548:	f7ff fecc 	bl	10042e4 <prefix_print>
 100454c:	4681      	mov	r9, r0
	return  (msg->hdr.params.generic.type == LOG_MSG_TYPE_STD);
 100454e:	7a34      	ldrb	r4, [r6, #8]
 1004550:	43e4      	mvns	r4, r4
					 level, domain_id, source_id);

	if (log_msg_is_std(msg)) {
 1004552:	f014 0401 	ands.w	r4, r4, #1
 1004556:	d00e      	beq.n	1004576 <log_output_msg_process+0x5e>
		std_print(msg, log_output);
 1004558:	4629      	mov	r1, r5
 100455a:	4630      	mov	r0, r6
 100455c:	f011 f86f 	bl	101563e <std_print>
		raw_string_print(msg, log_output);
	} else {
		hexdump_print(msg, log_output, prefix_offset, flags);
	}

	if (!raw_string) {
 1004560:	f1b8 0f00 	cmp.w	r8, #0
 1004564:	d02b      	beq.n	10045be <log_output_msg_process+0xa6>
		postfix_print(log_output, flags, level);
 1004566:	4642      	mov	r2, r8
 1004568:	4639      	mov	r1, r7
 100456a:	4628      	mov	r0, r5
 100456c:	f7ff ff48 	bl	1004400 <postfix_print>
 1004570:	e025      	b.n	10045be <log_output_msg_process+0xa6>
			0 : prefix_print(log_output, flags, std_msg, timestamp,
 1004572:	46c1      	mov	r9, r8
 1004574:	e7eb      	b.n	100454e <log_output_msg_process+0x36>
	} else if (raw_string) {
 1004576:	f1b8 0f00 	cmp.w	r8, #0
 100457a:	d126      	bne.n	10045ca <log_output_msg_process+0xb2>
	size_t offset = 0;
 100457c:	4627      	mov	r7, r4
		length = log_output->size;
 100457e:	68eb      	ldr	r3, [r5, #12]
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
 1004580:	aa06      	add	r2, sp, #24
		length = log_output->size;
 1004582:	9306      	str	r3, [sp, #24]
		log_msg_hexdump_data_get(msg, log_output->buf, &length, offset);
 1004584:	4630      	mov	r0, r6
 1004586:	463b      	mov	r3, r7
 1004588:	68a9      	ldr	r1, [r5, #8]
 100458a:	f011 f844 	bl	1015616 <log_msg_hexdump_data_get>
		log_output->control_block->offset = length;
 100458e:	9a06      	ldr	r2, [sp, #24]
 1004590:	686b      	ldr	r3, [r5, #4]
 1004592:	601a      	str	r2, [r3, #0]
		if (length != 0) {
 1004594:	b13a      	cbz	r2, 10045a6 <log_output_msg_process+0x8e>
			eol = (log_output->buf[length - 1] == '\n');
 1004596:	68ab      	ldr	r3, [r5, #8]
 1004598:	4413      	add	r3, r2
 100459a:	f813 4c01 	ldrb.w	r4, [r3, #-1]
 100459e:	f1a4 030a 	sub.w	r3, r4, #10
 10045a2:	425c      	negs	r4, r3
 10045a4:	415c      	adcs	r4, r3
		log_output_flush(log_output);
 10045a6:	4628      	mov	r0, r5
 10045a8:	f011 f9a6 	bl	10158f8 <log_output_flush>
		offset += length;
 10045ac:	9b06      	ldr	r3, [sp, #24]
 10045ae:	441f      	add	r7, r3
	} while (length > 0);
 10045b0:	2b00      	cmp	r3, #0
 10045b2:	d1e4      	bne.n	100457e <log_output_msg_process+0x66>
	if (eol) {
 10045b4:	b11c      	cbz	r4, 10045be <log_output_msg_process+0xa6>
		print_formatted(log_output, "\r");
 10045b6:	4628      	mov	r0, r5
 10045b8:	4913      	ldr	r1, [pc, #76]	; (1004608 <log_output_msg_process+0xf0>)
 10045ba:	f7ff fe81 	bl	10042c0 <print_formatted>
	}

	log_output_flush(log_output);
 10045be:	4628      	mov	r0, r5
 10045c0:	f011 f99a 	bl	10158f8 <log_output_flush>
}
 10045c4:	b00a      	add	sp, #40	; 0x28
 10045c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	print_formatted(log_output, "%s", log_msg_str_get(msg));
 10045ca:	4630      	mov	r0, r6
 10045cc:	f010 ffcd 	bl	101556a <log_msg_str_get>
 10045d0:	490e      	ldr	r1, [pc, #56]	; (100460c <log_output_msg_process+0xf4>)
 10045d2:	4602      	mov	r2, r0
 10045d4:	4628      	mov	r0, r5
 10045d6:	f7ff fe73 	bl	10042c0 <print_formatted>
		length = sizeof(buf);
 10045da:	f04f 0a10 	mov.w	sl, #16
		log_msg_hexdump_data_get(msg, buf, &length, offset);
 10045de:	aa05      	add	r2, sp, #20
 10045e0:	4623      	mov	r3, r4
 10045e2:	4630      	mov	r0, r6
 10045e4:	a906      	add	r1, sp, #24
		length = sizeof(buf);
 10045e6:	f8cd a014 	str.w	sl, [sp, #20]
		log_msg_hexdump_data_get(msg, buf, &length, offset);
 10045ea:	f011 f814 	bl	1015616 <log_msg_hexdump_data_get>
		if (length) {
 10045ee:	9a05      	ldr	r2, [sp, #20]
 10045f0:	2a00      	cmp	r2, #0
 10045f2:	d0b8      	beq.n	1004566 <log_output_msg_process+0x4e>
			hexdump_line_print(log_output, buf, length,
 10045f4:	464b      	mov	r3, r9
 10045f6:	4628      	mov	r0, r5
 10045f8:	9700      	str	r7, [sp, #0]
 10045fa:	a906      	add	r1, sp, #24
 10045fc:	f7ff ff1e 	bl	100443c <hexdump_line_print>
			offset += length;
 1004600:	9b05      	ldr	r3, [sp, #20]
 1004602:	441c      	add	r4, r3
		length = sizeof(buf);
 1004604:	e7eb      	b.n	10045de <log_output_msg_process+0xc6>
 1004606:	bf00      	nop
 1004608:	01019221 	.word	0x01019221
 100460c:	0101920a 	.word	0x0101920a

01004610 <log_output_dropped_process>:
	postfix_print(log_output, flags, level);
	log_output_flush(log_output);
}

void log_output_dropped_process(const struct log_output *log_output, u32_t cnt)
{
 1004610:	b573      	push	{r0, r1, r4, r5, r6, lr}
	int len;
	static const char prefix[] = DROPPED_COLOR_PREFIX "--- ";
	static const char postfix[] =
			" messages dropped ---\r\n" DROPPED_COLOR_POSTFIX;
	log_output_func_t outf = log_output->func;
	struct device *dev = (struct device *)log_output->control_block->ctx;
 1004612:	e9d0 4300 	ldrd	r4, r3, [r0]
 1004616:	685d      	ldr	r5, [r3, #4]

	cnt = MIN(cnt, 9999);
	len = snprintk(buf, sizeof(buf), "%d", cnt);
 1004618:	f242 730f 	movw	r3, #9999	; 0x270f
 100461c:	428b      	cmp	r3, r1
 100461e:	bf28      	it	cs
 1004620:	460b      	movcs	r3, r1
 1004622:	4668      	mov	r0, sp
 1004624:	2105      	movs	r1, #5
 1004626:	4a0c      	ldr	r2, [pc, #48]	; (1004658 <log_output_dropped_process+0x48>)
 1004628:	f010 fbe2 	bl	1014df0 <snprintk>
 100462c:	4606      	mov	r6, r0

	buffer_write(outf, (u8_t *)prefix, sizeof(prefix) - 1, dev);
 100462e:	462b      	mov	r3, r5
 1004630:	4620      	mov	r0, r4
 1004632:	220b      	movs	r2, #11
 1004634:	4909      	ldr	r1, [pc, #36]	; (100465c <log_output_dropped_process+0x4c>)
 1004636:	f010 fff5 	bl	1015624 <buffer_write>
	buffer_write(outf, buf, len, dev);
 100463a:	462b      	mov	r3, r5
 100463c:	4632      	mov	r2, r6
 100463e:	4669      	mov	r1, sp
 1004640:	4620      	mov	r0, r4
 1004642:	f010 ffef 	bl	1015624 <buffer_write>
	buffer_write(outf, (u8_t *)postfix, sizeof(postfix) - 1, dev);
 1004646:	462b      	mov	r3, r5
 1004648:	221b      	movs	r2, #27
 100464a:	4620      	mov	r0, r4
 100464c:	4904      	ldr	r1, [pc, #16]	; (1004660 <log_output_dropped_process+0x50>)
 100464e:	f010 ffe9 	bl	1015624 <buffer_write>
}
 1004652:	b002      	add	sp, #8
 1004654:	bd70      	pop	{r4, r5, r6, pc}
 1004656:	bf00      	nop
 1004658:	01019033 	.word	0x01019033
 100465c:	0101925f 	.word	0x0101925f
 1004660:	01019243 	.word	0x01019243

01004664 <log_output_timestamp_freq_set>:

void log_output_timestamp_freq_set(u32_t frequency)
{
	timestamp_div = 1U;
 1004664:	2301      	movs	r3, #1
	/* There is no point to have frequency higher than 1MHz (ns are not
	 * printed) and too high frequency leads to overflows in calculations.
	 */
	while (frequency > 1000000) {
 1004666:	2100      	movs	r1, #0
	timestamp_div = 1U;
 1004668:	4a07      	ldr	r2, [pc, #28]	; (1004688 <log_output_timestamp_freq_set+0x24>)
{
 100466a:	b510      	push	{r4, lr}
	while (frequency > 1000000) {
 100466c:	4c07      	ldr	r4, [pc, #28]	; (100468c <log_output_timestamp_freq_set+0x28>)
	timestamp_div = 1U;
 100466e:	6013      	str	r3, [r2, #0]
	while (frequency > 1000000) {
 1004670:	42a0      	cmp	r0, r4
 1004672:	d804      	bhi.n	100467e <log_output_timestamp_freq_set+0x1a>
 1004674:	b101      	cbz	r1, 1004678 <log_output_timestamp_freq_set+0x14>
 1004676:	6013      	str	r3, [r2, #0]
		frequency /= 2U;
		timestamp_div *= 2U;
	}

	freq = frequency;
 1004678:	4b05      	ldr	r3, [pc, #20]	; (1004690 <log_output_timestamp_freq_set+0x2c>)
 100467a:	6018      	str	r0, [r3, #0]
}
 100467c:	bd10      	pop	{r4, pc}
		timestamp_div *= 2U;
 100467e:	2101      	movs	r1, #1
		frequency /= 2U;
 1004680:	0840      	lsrs	r0, r0, #1
		timestamp_div *= 2U;
 1004682:	005b      	lsls	r3, r3, #1
 1004684:	e7f4      	b.n	1004670 <log_output_timestamp_freq_set+0xc>
 1004686:	bf00      	nop
 1004688:	21000934 	.word	0x21000934
 100468c:	000f4240 	.word	0x000f4240
 1004690:	21000930 	.word	0x21000930

01004694 <panic>:
 * @param log_output	Log output instance.
 */
static inline void
log_backend_std_panic(const struct log_output *const log_output)
{
	log_output_flush(log_output);
 1004694:	4801      	ldr	r0, [pc, #4]	; (100469c <panic+0x8>)
 1004696:	f011 b92f 	b.w	10158f8 <log_output_flush>
 100469a:	bf00      	nop
 100469c:	0101826c 	.word	0x0101826c

010046a0 <dropped>:
 * @param cnt		Number of dropped messages.
 */
static inline void
log_backend_std_dropped(const struct log_output *const log_output, u32_t cnt)
{
	log_output_dropped_process(log_output, cnt);
 10046a0:	4801      	ldr	r0, [pc, #4]	; (10046a8 <dropped+0x8>)
 10046a2:	f7ff bfb5 	b.w	1004610 <log_output_dropped_process>
 10046a6:	bf00      	nop
 10046a8:	0101826c 	.word	0x0101826c

010046ac <log_backend_uart_init>:

	log_backend_std_put(&log_output, flag, msg);
}

static void log_backend_uart_init(void)
{
 10046ac:	b508      	push	{r3, lr}
 10046ae:	4803      	ldr	r0, [pc, #12]	; (10046bc <log_backend_uart_init+0x10>)
 10046b0:	f00f fa72 	bl	1013b98 <z_impl_device_get_binding>
 * @param ctx		User context.
 */
static inline void log_output_ctx_set(const struct log_output *log_output,
				      void *ctx)
{
	log_output->control_block->ctx = ctx;
 10046b4:	4b02      	ldr	r3, [pc, #8]	; (10046c0 <log_backend_uart_init+0x14>)
 10046b6:	6058      	str	r0, [r3, #4]

	dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
	assert(dev);

	log_output_ctx_set(&log_output, dev);
}
 10046b8:	bd08      	pop	{r3, pc}
 10046ba:	bf00      	nop
 10046bc:	0101926b 	.word	0x0101926b
 10046c0:	21000940 	.word	0x21000940

010046c4 <put>:
{
 10046c4:	b510      	push	{r4, lr}
 10046c6:	460c      	mov	r4, r1
	log_msg_get(msg);
 10046c8:	4608      	mov	r0, r1
 10046ca:	f010 ff14 	bl	10154f6 <log_msg_get>
	log_output_msg_process(log_output, msg, flags);
 10046ce:	4621      	mov	r1, r4
 10046d0:	4804      	ldr	r0, [pc, #16]	; (10046e4 <put+0x20>)
 10046d2:	220f      	movs	r2, #15
 10046d4:	f7ff ff20 	bl	1004518 <log_output_msg_process>
	log_msg_put(msg);
 10046d8:	4620      	mov	r0, r4
}
 10046da:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 10046de:	f010 bf35 	b.w	101554c <log_msg_put>
 10046e2:	bf00      	nop
 10046e4:	0101826c 	.word	0x0101826c

010046e8 <uart_console_init>:
 * @brief Initialize one UART as the console/debug port
 *
 * @return 0 if successful, otherwise failed.
 */
static int uart_console_init(struct device *arg)
{
 10046e8:	b510      	push	{r4, lr}
 10046ea:	4807      	ldr	r0, [pc, #28]	; (1004708 <uart_console_init+0x20>)
 10046ec:	f00f fa54 	bl	1013b98 <z_impl_device_get_binding>
	__stdout_hook_install(console_out);
 10046f0:	4c06      	ldr	r4, [pc, #24]	; (100470c <uart_console_init+0x24>)

	ARG_UNUSED(arg);

	uart_console_dev = device_get_binding(CONFIG_UART_CONSOLE_ON_DEV_NAME);
 10046f2:	4b07      	ldr	r3, [pc, #28]	; (1004710 <uart_console_init+0x28>)
 10046f4:	6018      	str	r0, [r3, #0]
	__stdout_hook_install(console_out);
 10046f6:	4620      	mov	r0, r4
 10046f8:	f001 f838 	bl	100576c <__stdout_hook_install>
	__printk_hook_install(console_out);
 10046fc:	4620      	mov	r0, r4
 10046fe:	f7ff f90d 	bl	100391c <__printk_hook_install>
#endif

	uart_console_hook_install();

	return 0;
}
 1004702:	2000      	movs	r0, #0
 1004704:	bd10      	pop	{r4, pc}
 1004706:	bf00      	nop
 1004708:	0101926b 	.word	0x0101926b
 100470c:	01004715 	.word	0x01004715
 1004710:	2100094c 	.word	0x2100094c

01004714 <console_out>:
	if ('\n' == c) {
 1004714:	280a      	cmp	r0, #10
{
 1004716:	b538      	push	{r3, r4, r5, lr}
 1004718:	4604      	mov	r4, r0
 100471a:	4d07      	ldr	r5, [pc, #28]	; (1004738 <console_out+0x24>)
	if ('\n' == c) {
 100471c:	d104      	bne.n	1004728 <console_out+0x14>
 100471e:	6828      	ldr	r0, [r5, #0]
						unsigned char out_char)
{
	const struct uart_driver_api *api =
		(const struct uart_driver_api *)dev->driver_api;

	api->poll_out(dev, out_char);
 1004720:	6883      	ldr	r3, [r0, #8]
 1004722:	210d      	movs	r1, #13
 1004724:	685b      	ldr	r3, [r3, #4]
 1004726:	4798      	blx	r3
	uart_poll_out(uart_console_dev, c);
 1004728:	6828      	ldr	r0, [r5, #0]
 100472a:	6883      	ldr	r3, [r0, #8]
 100472c:	b2e1      	uxtb	r1, r4
 100472e:	685b      	ldr	r3, [r3, #4]
 1004730:	4798      	blx	r3
}
 1004732:	4620      	mov	r0, r4
 1004734:	bd38      	pop	{r3, r4, r5, pc}
 1004736:	bf00      	nop
 1004738:	2100094c 	.word	0x2100094c

0100473c <clock_async_start>:
}

static int clock_async_start(struct device *dev,
			     clock_control_subsys_t subsys,
			     struct clock_control_async_data *data)
{
 100473c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct nrf_clock_control_sub_data *clk_data;
	int key;
	u8_t ref;

	__ASSERT_NO_MSG(type < CLOCK_CONTROL_NRF_TYPE_COUNT);
	config = get_sub_config(dev, type);
 1004740:	6846      	ldr	r6, [r0, #4]
	clk_data = get_sub_data(dev, type);
 1004742:	f8d0 e00c 	ldr.w	lr, [r0, #12]
 1004746:	b2cf      	uxtb	r7, r1
			((data != NULL) && (data->cb != NULL)));

	/* if node is in the list it means that it is scheduled for
	 * the second time.
	 */
	if ((data != NULL)
 1004748:	b14a      	cbz	r2, 100475e <clock_async_start+0x22>
	sys_snode_t *item = sys_slist_peek_head(list);
 100474a:	230c      	movs	r3, #12
 100474c:	437b      	muls	r3, r7
 100474e:	f85e 3003 	ldr.w	r3, [lr, r3]
		if (item == node) {
 1004752:	429a      	cmp	r2, r3
 1004754:	d053      	beq.n	10047fe <clock_async_start+0xc2>
 *
 * @return a pointer on the next node (or NULL if none)
 */
static inline sys_snode_t *sys_slist_peek_next(sys_snode_t *node);

Z_GENLIST_PEEK_NEXT(slist, snode)
 1004756:	b113      	cbz	r3, 100475e <clock_async_start+0x22>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 1004758:	681b      	ldr	r3, [r3, #0]
	} while (item);
 100475a:	2b00      	cmp	r3, #0
 100475c:	d1f9      	bne.n	1004752 <clock_async_start+0x16>
	__asm__ volatile(
 100475e:	f04f 0320 	mov.w	r3, #32
 1004762:	f3ef 8c11 	mrs	ip, BASEPRI
 1004766:	f383 8811 	msr	BASEPRI, r3
 100476a:	f3bf 8f6f 	isb	sy
	    && is_in_list(&clk_data->list, &data->node)) {
		return -EBUSY;
	}

	key = irq_lock();
	ref = ++clk_data->ref;
 100476e:	250c      	movs	r5, #12
 1004770:	437d      	muls	r5, r7
 1004772:	eb0e 0305 	add.w	r3, lr, r5
 1004776:	7a1c      	ldrb	r4, [r3, #8]
 1004778:	3401      	adds	r4, #1
 100477a:	b2e4      	uxtb	r4, r4
 100477c:	721c      	strb	r4, [r3, #8]
	__asm__ volatile(
 100477e:	f38c 8811 	msr	BASEPRI, ip
 1004782:	f3bf 8f6f 	isb	sy
	__ASSERT_NO_MSG(clk_data->ref > 0);
	irq_unlock(key);

	if (data) {
 1004786:	b352      	cbz	r2, 10047de <clock_async_start+0xa2>
    p_reg->INTENSET = mask;
}

NRF_STATIC_INLINE void nrf_clock_int_disable(NRF_CLOCK_Type * p_reg, uint32_t mask)
{
    p_reg->INTENCLR = mask;
 1004788:	f04f 0803 	mov.w	r8, #3
 100478c:	f8df c078 	ldr.w	ip, [pc, #120]	; 1004808 <clock_async_start+0xcc>
 1004790:	f8cc 8308 	str.w	r8, [ip, #776]	; 0x308
		bool already_started;

		clock_irqs_disable();
		already_started = clk_data->started;
 1004794:	f893 c009 	ldrb.w	ip, [r3, #9]
		if (!already_started) {
 1004798:	f1bc 0f00 	cmp.w	ip, #0
 100479c:	d115      	bne.n	10047ca <clock_async_start+0x8e>
	__asm__ volatile(
 100479e:	f04f 0820 	mov.w	r8, #32
 10047a2:	f3ef 8911 	mrs	r9, BASEPRI
 10047a6:	f388 8811 	msr	BASEPRI, r8
 10047aa:	f3bf 8f6f 	isb	sy
	parent->next = child;
 10047ae:	f8c2 c000 	str.w	ip, [r2]
 * @param node A pointer on the node to append
 */
static inline void sys_slist_append(sys_slist_t *list,
				    sys_snode_t *node);

Z_GENLIST_APPEND(slist, snode)
 10047b2:	f8d3 8004 	ldr.w	r8, [r3, #4]
 10047b6:	f1b8 0f00 	cmp.w	r8, #0
 10047ba:	d11c      	bne.n	10047f6 <clock_async_start+0xba>
	list->tail = node;
 10047bc:	605a      	str	r2, [r3, #4]
	list->head = node;
 10047be:	f84e 2005 	str.w	r2, [lr, r5]
	__asm__ volatile(
 10047c2:	f389 8811 	msr	BASEPRI, r9
 10047c6:	f3bf 8f6f 	isb	sy
    p_reg->INTENSET = mask;
 10047ca:	2503      	movs	r5, #3
 10047cc:	4b0e      	ldr	r3, [pc, #56]	; (1004808 <clock_async_start+0xcc>)
 10047ce:	f8c3 5304 	str.w	r5, [r3, #772]	; 0x304
			list_append(&clk_data->list, &data->node);
		}
		clock_irqs_enable();

		if (already_started) {
 10047d2:	f1bc 0f00 	cmp.w	ip, #0
 10047d6:	d002      	beq.n	10047de <clock_async_start+0xa2>
			data->cb(dev, subsys, data->user_data);
 10047d8:	e9d2 3201 	ldrd	r3, r2, [r2, #4]
 10047dc:	4798      	blx	r3
		}
	}

	if (ref == 1) {
 10047de:	2c01      	cmp	r4, #1
 10047e0:	d107      	bne.n	10047f2 <clock_async_start+0xb6>
		if (IS_ENABLED(CONFIG_NRF52_ANOMALY_132_WORKAROUND) &&
			(subsys == CLOCK_CONTROL_NRF_SUBSYS_LF)) {
			anomaly_132_workaround();
		}

		nrf_clock_task_trigger(NRF_CLOCK, config->start_tsk);
 10047e2:	eb06 06c7 	add.w	r6, r6, r7, lsl #3
    return (uint32_t)((uint8_t *)p_reg + (uint32_t)task);
}

NRF_STATIC_INLINE void nrf_clock_task_trigger(NRF_CLOCK_Type * p_reg, nrf_clock_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 10047e6:	78b3      	ldrb	r3, [r6, #2]
 10047e8:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
 10047ec:	f503 43a0 	add.w	r3, r3, #20480	; 0x5000
 10047f0:	601c      	str	r4, [r3, #0]
	}

	return 0;
 10047f2:	2000      	movs	r0, #0
 10047f4:	e005      	b.n	1004802 <clock_async_start+0xc6>
	parent->next = child;
 10047f6:	f8c8 2000 	str.w	r2, [r8]
	list->tail = node;
 10047fa:	605a      	str	r2, [r3, #4]
}
 10047fc:	e7e1      	b.n	10047c2 <clock_async_start+0x86>
		return -EBUSY;
 10047fe:	f06f 000f 	mvn.w	r0, #15
}
 1004802:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 1004806:	bf00      	nop
 1004808:	41005000 	.word	0x41005000

0100480c <clk_init>:
 * symbol.
 */
void nrf_power_clock_isr(void *arg);

static int clk_init(struct device *dev)
{
 100480c:	b510      	push	{r4, lr}
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
 100480e:	2200      	movs	r2, #0
{
 1004810:	4604      	mov	r4, r0
	IRQ_CONNECT(DT_INST_IRQN(0), DT_INST_IRQ(0, priority),
 1004812:	2101      	movs	r1, #1
 1004814:	2005      	movs	r0, #5
 1004816:	f000 faaf 	bl	1004d78 <z_arm_irq_priority_set>
		    nrf_power_clock_isr, 0, 0);

	irq_enable(DT_INST_IRQN(0));
 100481a:	2005      	movs	r0, #5
 100481c:	f000 fa7a 	bl	1004d14 <arch_irq_enable>
    return false;
}

NRF_STATIC_INLINE void nrf_clock_lf_src_set(NRF_CLOCK_Type * p_reg, nrf_clock_lfclk_t source)
{
    p_reg->LFCLKSRC = (uint32_t)(source);
 1004820:	2202      	movs	r2, #2
 1004822:	4b07      	ldr	r3, [pc, #28]	; (1004840 <clk_init+0x34>)
	list->head = NULL;
 1004824:	2000      	movs	r0, #0
 1004826:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
    p_reg->INTENSET = mask;
 100482a:	2203      	movs	r2, #3
 100482c:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304

	clock_irqs_enable();

	for (enum clock_control_nrf_type i = 0;
		i < CLOCK_CONTROL_NRF_TYPE_COUNT; i++) {
		sys_slist_init(&(get_sub_data(dev, i)->list));
 1004830:	68e3      	ldr	r3, [r4, #12]
	list->tail = NULL;
 1004832:	e9c3 0000 	strd	r0, r0, [r3]
 1004836:	68e3      	ldr	r3, [r4, #12]
 1004838:	e9c3 0003 	strd	r0, r0, [r3, #12]
	}

	return 0;
}
 100483c:	bd10      	pop	{r4, pc}
 100483e:	bf00      	nop
 1004840:	41005000 	.word	0x41005000

01004844 <clkstarted_handle.constprop.0>:
DEVICE_AND_API_INIT(clock_nrf, DT_INST_LABEL(0),
		    clk_init, &data, &config, PRE_KERNEL_1,
		    CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &clock_control_api);

static void clkstarted_handle(struct device *dev,
 1004844:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
{
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
	struct clock_control_async_data *async_data;

	DBG(dev, type, "Clock started");
	sub_data->started = true;
 1004846:	240c      	movs	r4, #12
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
 1004848:	4e11      	ldr	r6, [pc, #68]	; (1004890 <clkstarted_handle.constprop.0+0x4c>)
static void clkstarted_handle(struct device *dev,
 100484a:	4605      	mov	r5, r0
	struct nrf_clock_control_sub_data *sub_data = get_sub_data(dev, type);
 100484c:	68f3      	ldr	r3, [r6, #12]
	sub_data->started = true;
 100484e:	fb04 3400 	mla	r4, r4, r0, r3
 1004852:	2301      	movs	r3, #1
 1004854:	7263      	strb	r3, [r4, #9]
	__asm__ volatile(
 1004856:	f04f 0320 	mov.w	r3, #32
 100485a:	f3ef 8111 	mrs	r1, BASEPRI
 100485e:	f383 8811 	msr	BASEPRI, r3
 1004862:	f3bf 8f6f 	isb	sy
Z_GENLIST_IS_EMPTY(slist)
 1004866:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list (or NULL if empty)
 */
static inline sys_snode_t *sys_slist_get(sys_slist_t *list);

Z_GENLIST_GET(slist, snode)
 1004868:	b12b      	cbz	r3, 1004876 <clkstarted_handle.constprop.0+0x32>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 100486a:	6860      	ldr	r0, [r4, #4]
 100486c:	681a      	ldr	r2, [r3, #0]
 100486e:	4283      	cmp	r3, r0
	list->head = node;
 1004870:	6022      	str	r2, [r4, #0]
	list->tail = node;
 1004872:	bf08      	it	eq
 1004874:	6062      	streq	r2, [r4, #4]
	__asm__ volatile(
 1004876:	f381 8811 	msr	BASEPRI, r1
 100487a:	f3bf 8f6f 	isb	sy

	while ((async_data = list_get(&sub_data->list)) != NULL) {
 100487e:	b903      	cbnz	r3, 1004882 <clkstarted_handle.constprop.0+0x3e>
		async_data->cb(dev, (clock_control_subsys_t)type,
				async_data->user_data);
	}
}
 1004880:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		async_data->cb(dev, (clock_control_subsys_t)type,
 1004882:	4629      	mov	r1, r5
 1004884:	e9d3 7201 	ldrd	r7, r2, [r3, #4]
 1004888:	4630      	mov	r0, r6
 100488a:	47b8      	blx	r7
 100488c:	e7e3      	b.n	1004856 <clkstarted_handle.constprop.0+0x12>
 100488e:	bf00      	nop
 1004890:	210004ac 	.word	0x210004ac

01004894 <nrf_power_clock_isr>:
	}
#endif
}

void nrf_power_clock_isr(void *arg)
{
 1004894:	b508      	push	{r3, lr}
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
 1004896:	4b10      	ldr	r3, [pc, #64]	; (10048d8 <nrf_power_clock_isr+0x44>)
 1004898:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
 100489a:	b162      	cbz	r2, 10048b6 <nrf_power_clock_isr+0x22>
    return p_reg->INTENSET & mask;
 100489c:	4a0f      	ldr	r2, [pc, #60]	; (10048dc <nrf_power_clock_isr+0x48>)
 100489e:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
 10048a2:	07d1      	lsls	r1, r2, #31
 10048a4:	d507      	bpl.n	10048b6 <nrf_power_clock_isr+0x22>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 10048a6:	2200      	movs	r2, #0
 10048a8:	601a      	str	r2, [r3, #0]
	struct device *dev = DEVICE_GET(clock_nrf);

	if (clock_event_check_and_clean(NRF_CLOCK_EVENT_HFCLKSTARTED,
					NRF_CLOCK_INT_HF_STARTED_MASK)) {
		struct nrf_clock_control_sub_data *data =
				get_sub_data(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
 10048aa:	4b0d      	ldr	r3, [pc, #52]	; (10048e0 <nrf_power_clock_isr+0x4c>)

		/* Check needed due to anomaly 201:
		 * HFCLKSTARTED may be generated twice.
		 */
		if (!data->started) {
 10048ac:	68db      	ldr	r3, [r3, #12]
 10048ae:	7a58      	ldrb	r0, [r3, #9]
 10048b0:	b908      	cbnz	r0, 10048b6 <nrf_power_clock_isr+0x22>
			clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_HFCLK);
 10048b2:	f7ff ffc7 	bl	1004844 <clkstarted_handle.constprop.0>
    return (bool)*((volatile uint32_t *)((uint8_t *)p_reg + event));
 10048b6:	4b0b      	ldr	r3, [pc, #44]	; (10048e4 <nrf_power_clock_isr+0x50>)
 10048b8:	681a      	ldr	r2, [r3, #0]
	bool ret = nrf_clock_event_check(NRF_CLOCK, evt) &&
 10048ba:	b15a      	cbz	r2, 10048d4 <nrf_power_clock_isr+0x40>
    return p_reg->INTENSET & mask;
 10048bc:	4a07      	ldr	r2, [pc, #28]	; (10048dc <nrf_power_clock_isr+0x48>)
 10048be:	f8d2 2304 	ldr.w	r2, [r2, #772]	; 0x304
	if (ret) {
 10048c2:	0792      	lsls	r2, r2, #30
 10048c4:	d506      	bpl.n	10048d4 <nrf_power_clock_isr+0x40>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 10048c6:	2200      	movs	r2, #0
					NRF_CLOCK_INT_LF_STARTED_MASK)) {
		if (IS_ENABLED(
			CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
			z_nrf_clock_calibration_lfclk_started();
		}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
 10048c8:	2001      	movs	r0, #1
 10048ca:	601a      	str	r2, [r3, #0]
	usb_power_isr();

	if (IS_ENABLED(CONFIG_CLOCK_CONTROL_NRF_K32SRC_RC_CALIBRATION)) {
		z_nrf_clock_calibration_isr();
	}
}
 10048cc:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		clkstarted_handle(dev, CLOCK_CONTROL_NRF_TYPE_LFCLK);
 10048d0:	f7ff bfb8 	b.w	1004844 <clkstarted_handle.constprop.0>
}
 10048d4:	bd08      	pop	{r3, pc}
 10048d6:	bf00      	nop
 10048d8:	41005100 	.word	0x41005100
 10048dc:	41005000 	.word	0x41005000
 10048e0:	210004ac 	.word	0x210004ac
 10048e4:	41005104 	.word	0x41005104

010048e8 <handle_next_tick_case>:
 * counter progresses during that time it means that 1 tick elapsed and
 * interrupt is set pending.
 */
static void handle_next_tick_case(u32_t t)
{
	set_comparator(t + 2);
 10048e8:	1c82      	adds	r2, r0, #2

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE  void nrf_rtc_cc_set(NRF_RTC_Type * p_reg, uint32_t ch, uint32_t cc_val)
{
    p_reg->CC[ch] = cc_val;
 10048ea:	4b08      	ldr	r3, [pc, #32]	; (100490c <handle_next_tick_case+0x24>)
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
 10048ec:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 10048f0:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
#endif
}

NRF_STATIC_INLINE uint32_t nrf_rtc_counter_get(NRF_RTC_Type const * p_reg)
{
     return p_reg->COUNTER;
 10048f4:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
	while (t != counter()) {
 10048f8:	4290      	cmp	r0, r2
 10048fa:	d100      	bne.n	10048fe <handle_next_tick_case+0x16>
		 * generated. Trigger interrupt.
		 */
		t = counter();
		set_comparator(t + 2);
	}
}
 10048fc:	4770      	bx	lr
 10048fe:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504
		set_comparator(t + 2);
 1004902:	1c82      	adds	r2, r0, #2
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
 1004904:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
 1004908:	e7f2      	b.n	10048f0 <handle_next_tick_case+0x8>
 100490a:	bf00      	nop
 100490c:	41016000 	.word	0x41016000

01004910 <rtc1_nrf_isr>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 1004910:	2200      	movs	r2, #0
 1004912:	4b06      	ldr	r3, [pc, #24]	; (100492c <rtc1_nrf_isr+0x1c>)
 1004914:	601a      	str	r2, [r3, #0]
{
	ARG_UNUSED(arg);
	event_clear();

	u32_t t = get_comparator();
	u32_t dticks = counter_sub(t, last_count) / CYC_PER_TICK;
 1004916:	4a06      	ldr	r2, [pc, #24]	; (1004930 <rtc1_nrf_isr+0x20>)
    return p_reg->CC[ch];
 1004918:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
 100491c:	6813      	ldr	r3, [r2, #0]
	return (a - b) & COUNTER_MAX;
 100491e:	1ac0      	subs	r0, r0, r3
 1004920:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000

	last_count += dticks * CYC_PER_TICK;
 1004924:	4403      	add	r3, r0
 1004926:	6013      	str	r3, [r2, #0]
		 * so it won't get preempted by the interrupt.
		 */
		set_absolute_ticks(last_count + CYC_PER_TICK);
	}

	z_clock_announce(IS_ENABLED(CONFIG_TICKLESS_KERNEL) ? dticks : 1);
 1004928:	f010 b8c4 	b.w	1014ab4 <z_clock_announce>
 100492c:	41016140 	.word	0x41016140
 1004930:	21000968 	.word	0x21000968

01004934 <z_clock_driver_init>:
}

int z_clock_driver_init(struct device *device)
{
 1004934:	b538      	push	{r3, r4, r5, lr}
 1004936:	4814      	ldr	r0, [pc, #80]	; (1004988 <z_clock_driver_init+0x54>)
 1004938:	f00f f92e 	bl	1013b98 <z_impl_device_get_binding>
	struct device *clock;

	ARG_UNUSED(device);

	clock = device_get_binding(DT_LABEL(DT_INST(0, nordic_nrf_clock)));
	if (!clock) {
 100493c:	b300      	cbz	r0, 1004980 <z_clock_driver_init+0x4c>
				   clock_control_subsys_t sys)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	return api->on(dev, sys);
 100493e:	6883      	ldr	r3, [r0, #8]
}

NRF_STATIC_INLINE void nrf_rtc_prescaler_set(NRF_RTC_Type * p_reg, uint32_t val)
{
    NRFX_ASSERT(val <= (RTC_PRESCALER_PRESCALER_Msk >> RTC_PRESCALER_PRESCALER_Pos));
    p_reg->PRESCALER = val;
 1004940:	2400      	movs	r4, #0
 1004942:	2101      	movs	r1, #1
 1004944:	681b      	ldr	r3, [r3, #0]
 1004946:	4798      	blx	r3
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 1004948:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 100494c:	4d0f      	ldr	r5, [pc, #60]	; (100498c <z_clock_driver_init+0x58>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 100494e:	4b10      	ldr	r3, [pc, #64]	; (1004990 <z_clock_driver_init+0x5c>)
    p_reg->PRESCALER = val;
 1004950:	f8c5 4508 	str.w	r4, [r5, #1288]	; 0x508
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 1004954:	601c      	str	r4, [r3, #0]
 1004956:	4b0f      	ldr	r3, [pc, #60]	; (1004994 <z_clock_driver_init+0x60>)
	nrf_rtc_prescaler_set(RTC, 0);
	event_clear();
	NVIC_ClearPendingIRQ(RTC1_IRQn);
	int_enable();

	IRQ_CONNECT(RTC1_IRQn, 1, rtc1_nrf_isr, 0, 0);
 1004958:	2101      	movs	r1, #1
 100495a:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
    p_reg->INTENSET = mask;
 100495e:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 1004962:	4622      	mov	r2, r4
 1004964:	f8c5 3304 	str.w	r3, [r5, #772]	; 0x304
 1004968:	2016      	movs	r0, #22
 100496a:	f000 fa05 	bl	1004d78 <z_arm_irq_priority_set>
	irq_enable(RTC1_IRQn);
 100496e:	2016      	movs	r0, #22
 1004970:	f000 f9d0 	bl	1004d14 <arch_irq_enable>
    return (uint32_t)p_reg + task;
}

NRF_STATIC_INLINE void nrf_rtc_task_trigger(NRF_RTC_Type * p_reg, nrf_rtc_task_t task)
{
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
 1004974:	2301      	movs	r3, #1

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		set_comparator(counter() + CYC_PER_TICK);
	}

	return 0;
 1004976:	4620      	mov	r0, r4
 1004978:	4a07      	ldr	r2, [pc, #28]	; (1004998 <z_clock_driver_init+0x64>)
 100497a:	6013      	str	r3, [r2, #0]
 100497c:	602b      	str	r3, [r5, #0]
}
 100497e:	bd38      	pop	{r3, r4, r5, pc}
		return -1;
 1004980:	f04f 30ff 	mov.w	r0, #4294967295
 1004984:	e7fb      	b.n	100497e <z_clock_driver_init+0x4a>
 1004986:	bf00      	nop
 1004988:	01019289 	.word	0x01019289
 100498c:	41016000 	.word	0x41016000
 1004990:	41016140 	.word	0x41016140
 1004994:	e000e100 	.word	0xe000e100
 1004998:	41016008 	.word	0x41016008

0100499c <z_clock_set_timeout>:

void z_clock_set_timeout(s32_t ticks, bool idle)
{
 100499c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
     return p_reg->COUNTER;
 100499e:	4b2c      	ldr	r3, [pc, #176]	; (1004a50 <z_clock_set_timeout+0xb4>)

	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return;
	}

	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
 10049a0:	4c2c      	ldr	r4, [pc, #176]	; (1004a54 <z_clock_set_timeout+0xb8>)
 10049a2:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);

	u32_t unannounced = counter_sub(counter(), last_count);
 10049a6:	4b2c      	ldr	r3, [pc, #176]	; (1004a58 <z_clock_set_timeout+0xbc>)
	ticks = (ticks == K_TICKS_FOREVER) ? MAX_TICKS : ticks;
 10049a8:	f1b0 3fff 	cmp.w	r0, #4294967295
 10049ac:	bf08      	it	eq
 10049ae:	4620      	moveq	r0, r4
	u32_t unannounced = counter_sub(counter(), last_count);
 10049b0:	6819      	ldr	r1, [r3, #0]
	return (a - b) & COUNTER_MAX;
 10049b2:	1a52      	subs	r2, r2, r1
 10049b4:	f022 437f 	bic.w	r3, r2, #4278190080	; 0xff000000
	/* If we haven't announced for more than half the 24-bit wrap
	 * duration, then force an announce to avoid loss of a wrap
	 * event.  This can happen if new timeouts keep being set
	 * before the existing one triggers the interrupt.
	 */
	if (unannounced >= COUNTER_HALF_SPAN) {
 10049b8:	0212      	lsls	r2, r2, #8
 10049ba:	d436      	bmi.n	1004a2a <z_clock_set_timeout+0x8e>
	ticks = MAX(MIN(ticks - 1, (s32_t)MAX_TICKS), 0);
 10049bc:	3801      	subs	r0, #1
 10049be:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 10049c2:	42a0      	cmp	r0, r4
 10049c4:	bfa8      	it	ge
 10049c6:	4620      	movge	r0, r4
	}

	/* Get the cycles from last_count to the tick boundary after
	 * the requested ticks have passed starting now.
	 */
	cyc = ticks * CYC_PER_TICK + 1 + unannounced;
 10049c8:	3301      	adds	r3, #1
 10049ca:	4418      	add	r0, r3
	 */
	if (cyc > MAX_CYCLES) {
		cyc = MAX_CYCLES;
	}

	cyc += last_count;
 10049cc:	42a0      	cmp	r0, r4
 10049ce:	bf94      	ite	ls
 10049d0:	180c      	addls	r4, r1, r0
 10049d2:	190c      	addhi	r4, r1, r4
    p_reg->INTENCLR = mask;
 10049d4:	f44f 3080 	mov.w	r0, #65536	; 0x10000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 10049d8:	2700      	movs	r7, #0
    p_reg->INTENCLR = mask;
 10049da:	4b1d      	ldr	r3, [pc, #116]	; (1004a50 <z_clock_set_timeout+0xb4>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 10049dc:	4e1f      	ldr	r6, [pc, #124]	; (1004a5c <z_clock_set_timeout+0xc0>)
    p_reg->INTENCLR = mask;
 10049de:	f8c3 0308 	str.w	r0, [r3, #776]	; 0x308
     return p_reg->COUNTER;
 10049e2:	f8d3 1504 	ldr.w	r1, [r3, #1284]	; 0x504
    return p_reg->CC[ch];
 10049e6:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
 10049ea:	f021 457f 	bic.w	r5, r1, #4278190080	; 0xff000000
	return (a - b) & COUNTER_MAX;
 10049ee:	1a52      	subs	r2, r2, r1
 10049f0:	f022 427f 	bic.w	r2, r2, #4278190080	; 0xff000000
	if (counter_sub(prev_val, now) == 1) {
 10049f4:	2a01      	cmp	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 10049f6:	6037      	str	r7, [r6, #0]
    p_reg->CC[ch] = cc_val;
 10049f8:	f8c3 5540 	str.w	r5, [r3, #1344]	; 0x540
}

NRF_STATIC_INLINE void nrf_rtc_event_enable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENSET = mask;
 10049fc:	461d      	mov	r5, r3
 10049fe:	f8c3 0344 	str.w	r0, [r3, #836]	; 0x344
 1004a02:	d103      	bne.n	1004a0c <z_clock_set_timeout+0x70>
	z_impl_k_busy_wait(usec_to_wait);
 1004a04:	200f      	movs	r0, #15
 1004a06:	f013 f875 	bl	1017af4 <z_impl_k_busy_wait>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0;
 1004a0a:	6037      	str	r7, [r6, #0]
 1004a0c:	f44f 0280 	mov.w	r2, #4194304	; 0x400000
 1004a10:	4b13      	ldr	r3, [pc, #76]	; (1004a60 <z_clock_set_timeout+0xc4>)
 1004a12:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
     return p_reg->COUNTER;
 1004a16:	f8d5 0504 	ldr.w	r0, [r5, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
 1004a1a:	1a23      	subs	r3, r4, r0
 1004a1c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
	if (diff == 1) {
 1004a20:	2b01      	cmp	r3, #1
 1004a22:	d104      	bne.n	1004a2e <z_clock_set_timeout+0x92>
		handle_next_tick_case(t);
 1004a24:	f7ff ff60 	bl	10048e8 <handle_next_tick_case>
 1004a28:	e00b      	b.n	1004a42 <z_clock_set_timeout+0xa6>
		ticks = 0;
 1004a2a:	2000      	movs	r0, #0
 1004a2c:	e7cc      	b.n	10049c8 <z_clock_set_timeout+0x2c>
	nrf_rtc_cc_set(RTC, 0, cyc & COUNTER_MAX);
 1004a2e:	f024 437f 	bic.w	r3, r4, #4278190080	; 0xff000000
    p_reg->CC[ch] = cc_val;
 1004a32:	f8c5 3540 	str.w	r3, [r5, #1344]	; 0x540
     return p_reg->COUNTER;
 1004a36:	f8d5 0504 	ldr.w	r0, [r5, #1284]	; 0x504
	return (a - b) & COUNTER_MAX;
 1004a3a:	1a24      	subs	r4, r4, r0
 1004a3c:	3c02      	subs	r4, #2
	if (diff > MAX_TICKS) {
 1004a3e:	0223      	lsls	r3, r4, #8
 1004a40:	d4f0      	bmi.n	1004a24 <z_clock_set_timeout+0x88>
    p_reg->INTENSET = mask;
 1004a42:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 1004a46:	4b02      	ldr	r3, [pc, #8]	; (1004a50 <z_clock_set_timeout+0xb4>)
 1004a48:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	set_protected_absolute_ticks(cyc);
}
 1004a4c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 1004a4e:	bf00      	nop
 1004a50:	41016000 	.word	0x41016000
 1004a54:	007fffff 	.word	0x007fffff
 1004a58:	21000968 	.word	0x21000968
 1004a5c:	41016140 	.word	0x41016140
 1004a60:	e000e100 	.word	0xe000e100

01004a64 <z_clock_elapsed>:
	__asm__ volatile(
 1004a64:	f04f 0220 	mov.w	r2, #32
 1004a68:	f3ef 8311 	mrs	r3, BASEPRI
 1004a6c:	f382 8811 	msr	BASEPRI, r2
 1004a70:	f3bf 8f6f 	isb	sy
     return p_reg->COUNTER;
 1004a74:	4a06      	ldr	r2, [pc, #24]	; (1004a90 <z_clock_elapsed+0x2c>)
 1004a76:	f8d2 0504 	ldr.w	r0, [r2, #1284]	; 0x504
	if (!IS_ENABLED(CONFIG_TICKLESS_KERNEL)) {
		return 0;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) / CYC_PER_TICK;
 1004a7a:	4a06      	ldr	r2, [pc, #24]	; (1004a94 <z_clock_elapsed+0x30>)
	return (a - b) & COUNTER_MAX;
 1004a7c:	6812      	ldr	r2, [r2, #0]
 1004a7e:	1a80      	subs	r0, r0, r2
 1004a80:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
	__asm__ volatile(
 1004a84:	f383 8811 	msr	BASEPRI, r3
 1004a88:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
 1004a8c:	4770      	bx	lr
 1004a8e:	bf00      	nop
 1004a90:	41016000 	.word	0x41016000
 1004a94:	21000968 	.word	0x21000968

01004a98 <z_timer_cycle_get_32>:
	__asm__ volatile(
 1004a98:	f04f 0320 	mov.w	r3, #32
 1004a9c:	f3ef 8211 	mrs	r2, BASEPRI
 1004aa0:	f383 8811 	msr	BASEPRI, r3
 1004aa4:	f3bf 8f6f 	isb	sy

u32_t z_timer_cycle_get_32(void)
{
	k_spinlock_key_t key = k_spin_lock(&lock);
	u32_t ret = counter_sub(counter(), last_count) + last_count;
 1004aa8:	4906      	ldr	r1, [pc, #24]	; (1004ac4 <z_timer_cycle_get_32+0x2c>)
 1004aaa:	4b07      	ldr	r3, [pc, #28]	; (1004ac8 <z_timer_cycle_get_32+0x30>)
 1004aac:	6808      	ldr	r0, [r1, #0]
 1004aae:	f8d3 3504 	ldr.w	r3, [r3, #1284]	; 0x504
	__asm__ volatile(
 1004ab2:	f382 8811 	msr	BASEPRI, r2
 1004ab6:	f3bf 8f6f 	isb	sy
	return (a - b) & COUNTER_MAX;
 1004aba:	1a1b      	subs	r3, r3, r0
 1004abc:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000

	k_spin_unlock(&lock, key);
	return ret;
}
 1004ac0:	4418      	add	r0, r3
 1004ac2:	4770      	bx	lr
 1004ac4:	21000968 	.word	0x21000968
 1004ac8:	41016000 	.word	0x41016000

01004acc <uECC_get_rng>:
}

uECC_RNG_Function uECC_get_rng(void)
{
	return g_rng_function;
}
 1004acc:	4b01      	ldr	r3, [pc, #4]	; (1004ad4 <uECC_get_rng+0x8>)
 1004ace:	6818      	ldr	r0, [r3, #0]
 1004ad0:	4770      	bx	lr
 1004ad2:	bf00      	nop
 1004ad4:	21000070 	.word	0x21000070

01004ad8 <vli_mmod_fast_secp256r1>:
{
	return &curve_secp256r1;
}

void vli_mmod_fast_secp256r1(unsigned int *result, unsigned int*product)
{
 1004ad8:	b5f0      	push	{r4, r5, r6, r7, lr}
	unsigned int tmp[NUM_ECC_WORDS];
	int carry;

	/* t */
	uECC_vli_set(result, product, NUM_ECC_WORDS);
 1004ada:	2208      	movs	r2, #8
{
 1004adc:	b089      	sub	sp, #36	; 0x24
 1004ade:	460c      	mov	r4, r1
 1004ae0:	4606      	mov	r6, r0
	uECC_vli_set(result, product, NUM_ECC_WORDS);
 1004ae2:	f011 f920 	bl	1015d26 <uECC_vli_set>

	/* s1 */
	tmp[0] = tmp[1] = tmp[2] = 0;
 1004ae6:	2700      	movs	r7, #0
	tmp[3] = product[11];
 1004ae8:	6acb      	ldr	r3, [r1, #44]	; 0x2c
	tmp[4] = product[12];
	tmp[5] = product[13];
	tmp[6] = product[14];
	tmp[7] = product[15];
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1004aea:	466a      	mov	r2, sp
	tmp[3] = product[11];
 1004aec:	9303      	str	r3, [sp, #12]
	tmp[4] = product[12];
 1004aee:	6b0b      	ldr	r3, [r1, #48]	; 0x30
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1004af0:	4668      	mov	r0, sp
	tmp[4] = product[12];
 1004af2:	9304      	str	r3, [sp, #16]
	tmp[5] = product[13];
 1004af4:	6b4b      	ldr	r3, [r1, #52]	; 0x34
	tmp[0] = tmp[1] = tmp[2] = 0;
 1004af6:	e9cd 7701 	strd	r7, r7, [sp, #4]
	tmp[5] = product[13];
 1004afa:	9305      	str	r3, [sp, #20]
	tmp[6] = product[14];
 1004afc:	6b8b      	ldr	r3, [r1, #56]	; 0x38
	tmp[0] = tmp[1] = tmp[2] = 0;
 1004afe:	9700      	str	r7, [sp, #0]
	tmp[6] = product[14];
 1004b00:	9306      	str	r3, [sp, #24]
	tmp[7] = product[15];
 1004b02:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1004b04:	4669      	mov	r1, sp
	tmp[7] = product[15];
 1004b06:	9307      	str	r3, [sp, #28]
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1004b08:	2308      	movs	r3, #8
 1004b0a:	f011 f813 	bl	1015b34 <uECC_vli_add>
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004b0e:	2308      	movs	r3, #8
	carry = uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1004b10:	4605      	mov	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004b12:	466a      	mov	r2, sp
 1004b14:	4631      	mov	r1, r6
 1004b16:	4630      	mov	r0, r6
 1004b18:	f011 f80c 	bl	1015b34 <uECC_vli_add>

	/* s2 */
	tmp[3] = product[12];
 1004b1c:	6b23      	ldr	r3, [r4, #48]	; 0x30
	tmp[4] = product[13];
	tmp[5] = product[14];
	tmp[6] = product[15];
	tmp[7] = 0;
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1004b1e:	466a      	mov	r2, sp
	tmp[3] = product[12];
 1004b20:	9303      	str	r3, [sp, #12]
	tmp[4] = product[13];
 1004b22:	6b63      	ldr	r3, [r4, #52]	; 0x34
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1004b24:	4669      	mov	r1, sp
	tmp[4] = product[13];
 1004b26:	9304      	str	r3, [sp, #16]
	tmp[5] = product[14];
 1004b28:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004b2a:	4405      	add	r5, r0
	tmp[5] = product[14];
 1004b2c:	9305      	str	r3, [sp, #20]
	tmp[6] = product[15];
 1004b2e:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1004b30:	4668      	mov	r0, sp
	tmp[7] = 0;
 1004b32:	e9cd 3706 	strd	r3, r7, [sp, #24]
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1004b36:	2308      	movs	r3, #8
 1004b38:	f010 fffc 	bl	1015b34 <uECC_vli_add>
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004b3c:	4631      	mov	r1, r6
 1004b3e:	2308      	movs	r3, #8
 1004b40:	466a      	mov	r2, sp
	carry += uECC_vli_add(tmp, tmp, tmp, NUM_ECC_WORDS);
 1004b42:	4405      	add	r5, r0
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004b44:	4630      	mov	r0, r6
 1004b46:	f010 fff5 	bl	1015b34 <uECC_vli_add>

	/* s3 */
	tmp[0] = product[8];
 1004b4a:	6a23      	ldr	r3, [r4, #32]
	tmp[1] = product[9];
	tmp[2] = product[10];
	tmp[3] = tmp[4] = tmp[5] = 0;
	tmp[6] = product[14];
	tmp[7] = product[15];
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004b4c:	466a      	mov	r2, sp
	tmp[0] = product[8];
 1004b4e:	9300      	str	r3, [sp, #0]
	tmp[1] = product[9];
 1004b50:	6a63      	ldr	r3, [r4, #36]	; 0x24
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004b52:	4405      	add	r5, r0
	tmp[1] = product[9];
 1004b54:	9301      	str	r3, [sp, #4]
	tmp[2] = product[10];
 1004b56:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004b58:	4630      	mov	r0, r6
	tmp[2] = product[10];
 1004b5a:	9302      	str	r3, [sp, #8]
	tmp[6] = product[14];
 1004b5c:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	tmp[3] = tmp[4] = tmp[5] = 0;
 1004b5e:	e9cd 7704 	strd	r7, r7, [sp, #16]
	tmp[6] = product[14];
 1004b62:	9306      	str	r3, [sp, #24]
	tmp[7] = product[15];
 1004b64:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	tmp[3] = tmp[4] = tmp[5] = 0;
 1004b66:	9703      	str	r7, [sp, #12]
	tmp[7] = product[15];
 1004b68:	9307      	str	r3, [sp, #28]
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004b6a:	2308      	movs	r3, #8
 1004b6c:	f010 ffe2 	bl	1015b34 <uECC_vli_add>

	/* s4 */
	tmp[0] = product[9];
 1004b70:	6a63      	ldr	r3, [r4, #36]	; 0x24
	tmp[1] = product[10];
	tmp[2] = product[11];
	tmp[3] = product[13];
	tmp[4] = product[14];
 1004b72:	6ba2      	ldr	r2, [r4, #56]	; 0x38
	tmp[0] = product[9];
 1004b74:	9300      	str	r3, [sp, #0]
	tmp[1] = product[10];
 1004b76:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	tmp[4] = product[14];
 1004b78:	9204      	str	r2, [sp, #16]
	tmp[1] = product[10];
 1004b7a:	9301      	str	r3, [sp, #4]
	tmp[2] = product[11];
 1004b7c:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	tmp[5] = product[15];
 1004b7e:	6be2      	ldr	r2, [r4, #60]	; 0x3c
	tmp[2] = product[11];
 1004b80:	9302      	str	r3, [sp, #8]
	tmp[3] = product[13];
 1004b82:	6b63      	ldr	r3, [r4, #52]	; 0x34
  	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004b84:	4405      	add	r5, r0
	tmp[6] = product[13];
 1004b86:	e9cd 2305 	strd	r2, r3, [sp, #20]
	tmp[3] = product[13];
 1004b8a:	9303      	str	r3, [sp, #12]
	tmp[7] = product[8];
 1004b8c:	6a23      	ldr	r3, [r4, #32]
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004b8e:	466a      	mov	r2, sp
	tmp[7] = product[8];
 1004b90:	9307      	str	r3, [sp, #28]
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004b92:	4630      	mov	r0, r6
 1004b94:	2308      	movs	r3, #8
 1004b96:	f010 ffcd 	bl	1015b34 <uECC_vli_add>

	/* d1 */
	tmp[0] = product[11];
 1004b9a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	tmp[1] = product[12];
	tmp[2] = product[13];
	tmp[3] = tmp[4] = tmp[5] = 0;
	tmp[6] = product[8];
	tmp[7] = product[10];
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004b9c:	466a      	mov	r2, sp
	tmp[0] = product[11];
 1004b9e:	9300      	str	r3, [sp, #0]
	tmp[1] = product[12];
 1004ba0:	6b23      	ldr	r3, [r4, #48]	; 0x30
	carry += uECC_vli_add(result, result, tmp, NUM_ECC_WORDS);
 1004ba2:	4405      	add	r5, r0
	tmp[1] = product[12];
 1004ba4:	9301      	str	r3, [sp, #4]
	tmp[2] = product[13];
 1004ba6:	6b63      	ldr	r3, [r4, #52]	; 0x34
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004ba8:	4630      	mov	r0, r6
	tmp[2] = product[13];
 1004baa:	9302      	str	r3, [sp, #8]
	tmp[6] = product[8];
 1004bac:	6a23      	ldr	r3, [r4, #32]
	tmp[3] = tmp[4] = tmp[5] = 0;
 1004bae:	e9cd 7704 	strd	r7, r7, [sp, #16]
	tmp[6] = product[8];
 1004bb2:	9306      	str	r3, [sp, #24]
	tmp[7] = product[10];
 1004bb4:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	tmp[3] = tmp[4] = tmp[5] = 0;
 1004bb6:	9703      	str	r7, [sp, #12]
	tmp[7] = product[10];
 1004bb8:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004bba:	2308      	movs	r3, #8
 1004bbc:	f011 f8e9 	bl	1015d92 <uECC_vli_sub>

	/* d2 */
	tmp[0] = product[12];
 1004bc0:	6b23      	ldr	r3, [r4, #48]	; 0x30
	tmp[2] = product[14];
	tmp[3] = product[15];
	tmp[4] = tmp[5] = 0;
	tmp[6] = product[9];
	tmp[7] = product[11];
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004bc2:	466a      	mov	r2, sp
	tmp[0] = product[12];
 1004bc4:	9300      	str	r3, [sp, #0]
	tmp[1] = product[13];
 1004bc6:	6b63      	ldr	r3, [r4, #52]	; 0x34
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004bc8:	1a2d      	subs	r5, r5, r0
	tmp[1] = product[13];
 1004bca:	9301      	str	r3, [sp, #4]
	tmp[2] = product[14];
 1004bcc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004bce:	4630      	mov	r0, r6
	tmp[2] = product[14];
 1004bd0:	9302      	str	r3, [sp, #8]
	tmp[3] = product[15];
 1004bd2:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	tmp[4] = tmp[5] = 0;
 1004bd4:	e9cd 7704 	strd	r7, r7, [sp, #16]
	tmp[3] = product[15];
 1004bd8:	9303      	str	r3, [sp, #12]
	tmp[6] = product[9];
 1004bda:	6a63      	ldr	r3, [r4, #36]	; 0x24
 1004bdc:	9306      	str	r3, [sp, #24]
	tmp[7] = product[11];
 1004bde:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 1004be0:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004be2:	2308      	movs	r3, #8
 1004be4:	f011 f8d5 	bl	1015d92 <uECC_vli_sub>

	/* d3 */
	tmp[0] = product[13];
 1004be8:	6b63      	ldr	r3, [r4, #52]	; 0x34
	tmp[3] = product[8];
	tmp[4] = product[9];
	tmp[5] = product[10];
	tmp[6] = 0;
	tmp[7] = product[12];
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004bea:	466a      	mov	r2, sp
	tmp[0] = product[13];
 1004bec:	9300      	str	r3, [sp, #0]
	tmp[1] = product[14];
 1004bee:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004bf0:	1a2d      	subs	r5, r5, r0
	tmp[1] = product[14];
 1004bf2:	9301      	str	r3, [sp, #4]
	tmp[2] = product[15];
 1004bf4:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004bf6:	4630      	mov	r0, r6
	tmp[2] = product[15];
 1004bf8:	9302      	str	r3, [sp, #8]
	tmp[3] = product[8];
 1004bfa:	6a23      	ldr	r3, [r4, #32]
 1004bfc:	9303      	str	r3, [sp, #12]
	tmp[4] = product[9];
 1004bfe:	6a63      	ldr	r3, [r4, #36]	; 0x24
 1004c00:	9304      	str	r3, [sp, #16]
	tmp[5] = product[10];
 1004c02:	6aa3      	ldr	r3, [r4, #40]	; 0x28
	tmp[6] = 0;
 1004c04:	e9cd 3705 	strd	r3, r7, [sp, #20]
	tmp[7] = product[12];
 1004c08:	6b23      	ldr	r3, [r4, #48]	; 0x30
 1004c0a:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004c0c:	2308      	movs	r3, #8
 1004c0e:	f011 f8c0 	bl	1015d92 <uECC_vli_sub>

	/* d4 */
	tmp[0] = product[14];
 1004c12:	6ba3      	ldr	r3, [r4, #56]	; 0x38
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004c14:	1a2d      	subs	r5, r5, r0
	tmp[0] = product[14];
 1004c16:	9300      	str	r3, [sp, #0]
	tmp[1] = product[15];
 1004c18:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	tmp[3] = product[9];
	tmp[4] = product[10];
	tmp[5] = product[11];
	tmp[6] = 0;
	tmp[7] = product[13];
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004c1a:	466a      	mov	r2, sp
	tmp[2] = 0;
 1004c1c:	e9cd 3701 	strd	r3, r7, [sp, #4]
	tmp[3] = product[9];
 1004c20:	6a63      	ldr	r3, [r4, #36]	; 0x24
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004c22:	4630      	mov	r0, r6
	tmp[3] = product[9];
 1004c24:	9303      	str	r3, [sp, #12]
	tmp[4] = product[10];
 1004c26:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1004c28:	9304      	str	r3, [sp, #16]
	tmp[5] = product[11];
 1004c2a:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	tmp[6] = 0;
 1004c2c:	e9cd 3705 	strd	r3, r7, [sp, #20]
	tmp[7] = product[13];
 1004c30:	6b63      	ldr	r3, [r4, #52]	; 0x34
 1004c32:	9307      	str	r3, [sp, #28]
	carry -= uECC_vli_sub(result, result, tmp, NUM_ECC_WORDS);
 1004c34:	2308      	movs	r3, #8
 1004c36:	f011 f8ac 	bl	1015d92 <uECC_vli_sub>

	if (carry < 0) {
 1004c3a:	1a2d      	subs	r5, r5, r0
 1004c3c:	d410      	bmi.n	1004c60 <vli_mmod_fast_secp256r1+0x188>
			carry += uECC_vli_add(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
		}
		while (carry < 0);
	} else  {
		while (carry || 
		       uECC_vli_cmp_unsafe(curve_secp256r1.p, result, NUM_ECC_WORDS) != 1) {
 1004c3e:	4c0d      	ldr	r4, [pc, #52]	; (1004c74 <vli_mmod_fast_secp256r1+0x19c>)
		while (carry || 
 1004c40:	b935      	cbnz	r5, 1004c50 <vli_mmod_fast_secp256r1+0x178>
		       uECC_vli_cmp_unsafe(curve_secp256r1.p, result, NUM_ECC_WORDS) != 1) {
 1004c42:	2208      	movs	r2, #8
 1004c44:	4631      	mov	r1, r6
 1004c46:	4620      	mov	r0, r4
 1004c48:	f011 f879 	bl	1015d3e <uECC_vli_cmp_unsafe>
		while (carry || 
 1004c4c:	2801      	cmp	r0, #1
 1004c4e:	d00f      	beq.n	1004c70 <vli_mmod_fast_secp256r1+0x198>
			carry -= uECC_vli_sub(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
 1004c50:	2308      	movs	r3, #8
 1004c52:	4622      	mov	r2, r4
 1004c54:	4631      	mov	r1, r6
 1004c56:	4630      	mov	r0, r6
 1004c58:	f011 f89b 	bl	1015d92 <uECC_vli_sub>
 1004c5c:	1a2d      	subs	r5, r5, r0
 1004c5e:	e7ef      	b.n	1004c40 <vli_mmod_fast_secp256r1+0x168>
			carry += uECC_vli_add(result, result, curve_secp256r1.p, NUM_ECC_WORDS);
 1004c60:	4a04      	ldr	r2, [pc, #16]	; (1004c74 <vli_mmod_fast_secp256r1+0x19c>)
 1004c62:	2308      	movs	r3, #8
 1004c64:	4631      	mov	r1, r6
 1004c66:	4630      	mov	r0, r6
 1004c68:	f010 ff64 	bl	1015b34 <uECC_vli_add>
		while (carry < 0);
 1004c6c:	182d      	adds	r5, r5, r0
 1004c6e:	d4f8      	bmi.n	1004c62 <vli_mmod_fast_secp256r1+0x18a>
		}
	}
}
 1004c70:	b009      	add	sp, #36	; 0x24
 1004c72:	bdf0      	pop	{r4, r5, r6, r7, pc}
 1004c74:	010182a4 	.word	0x010182a4

01004c78 <arch_swap>:
#ifdef CONFIG_EXECUTION_BENCHMARKING
	read_timer_start_of_swap();
#endif

	/* store off key and return value */
	_current->arch.basepri = key;
 1004c78:	4a09      	ldr	r2, [pc, #36]	; (1004ca0 <arch_swap+0x28>)
	_current->arch.swap_return_value = _k_neg_eagain;
 1004c7a:	490a      	ldr	r1, [pc, #40]	; (1004ca4 <arch_swap+0x2c>)
	_current->arch.basepri = key;
 1004c7c:	6893      	ldr	r3, [r2, #8]
	_current->arch.swap_return_value = _k_neg_eagain;
 1004c7e:	6809      	ldr	r1, [r1, #0]
	_current->arch.basepri = key;
 1004c80:	66d8      	str	r0, [r3, #108]	; 0x6c
	_current->arch.swap_return_value = _k_neg_eagain;
 1004c82:	6719      	str	r1, [r3, #112]	; 0x70

#if defined(CONFIG_CPU_CORTEX_M)
	/* set pending bit to make sure we will take a PendSV exception */
	SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 1004c84:	4908      	ldr	r1, [pc, #32]	; (1004ca8 <arch_swap+0x30>)
 1004c86:	684b      	ldr	r3, [r1, #4]
 1004c88:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 1004c8c:	604b      	str	r3, [r1, #4]
 1004c8e:	2300      	movs	r3, #0
 1004c90:	f383 8811 	msr	BASEPRI, r3
 1004c94:	f3bf 8f6f 	isb	sy
#endif

	/* Context switch is performed here. Returning implies the
	 * thread has been context-switched-in again.
	 */
	return _current->arch.swap_return_value;
 1004c98:	6893      	ldr	r3, [r2, #8]
}
 1004c9a:	6f18      	ldr	r0, [r3, #112]	; 0x70
 1004c9c:	4770      	bx	lr
 1004c9e:	bf00      	nop
 1004ca0:	210065b8 	.word	0x210065b8
 1004ca4:	01018e40 	.word	0x01018e40
 1004ca8:	e000ed00 	.word	0xe000ed00

01004cac <z_arm_pendsv>:
    pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_TRACING */

    /* load _kernel into r1 and current k_thread into r2 */
    ldr r1, =_kernel
 1004cac:	490f      	ldr	r1, [pc, #60]	; (1004cec <z_arm_pendsv+0x40>)
    ldr r2, [r1, #_kernel_offset_to_current]
 1004cae:	688a      	ldr	r2, [r1, #8]

    /* addr of callee-saved regs in thread in r0 */
    ldr r0, =_thread_offset_to_callee_saved
 1004cb0:	f04f 0030 	mov.w	r0, #48	; 0x30
    add r0, r2
 1004cb4:	4410      	add	r0, r2

    /* save callee-saved + psp in thread */
#if defined(CONFIG_CPU_CORTEX_M)
    mrs ip, PSP
 1004cb6:	f3ef 8c09 	mrs	ip, PSP
    mov r6, r11
    mov r7, ip
    /* store r8-12 */
    stmea r0!, {r3-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    stmia r0, {v1-v8, ip}
 1004cba:	e880 1ff0 	stmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}

    /* Protect the kernel state while we play with the thread lists */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 1004cbe:	2020      	movs	r0, #32
    msr BASEPRI, r0
 1004cc0:	f380 8811 	msr	BASEPRI, r0
    isb /* Make the effect of disabling interrupts be realized immediately */
 1004cc4:	f3bf 8f6f 	isb	sy
     * the new thread is context-switched in since all decisions
     * to pend PendSV have been taken with the current kernel
     * state and this is what we're handling currently.
     */
#if defined(CONFIG_CPU_CORTEX_M)
    ldr v4, =_SCS_ICSR
 1004cc8:	4f09      	ldr	r7, [pc, #36]	; (1004cf0 <z_arm_pendsv+0x44>)
    ldr v3, =_SCS_ICSR_UNPENDSV
 1004cca:	f04f 6600 	mov.w	r6, #134217728	; 0x8000000
#endif

    /* _kernel is still in r1 */

    /* fetch the thread to run from the ready queue cache */
    ldr r2, [r1, #_kernel_offset_to_ready_q_cache]
 1004cce:	6a4a      	ldr	r2, [r1, #36]	; 0x24

    str r2, [r1, #_kernel_offset_to_current]
 1004cd0:	608a      	str	r2, [r1, #8]
     * has been handled.
     */

    /* _SCS_ICSR is still in v4 and _SCS_ICSR_UNPENDSV in v3 */
#if defined(CONFIG_CPU_CORTEX_M)
    str v3, [v4, #0]
 1004cd2:	603e      	str	r6, [r7, #0]

    ldr r0, [r4]
    movs.n r3, #0
    str r3, [r4]
#else
    ldr r0, [r2, #_thread_offset_to_basepri]
 1004cd4:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
    movs r3, #0
 1004cd6:	2300      	movs	r3, #0
    str r3, [r2, #_thread_offset_to_basepri]
 1004cd8:	66d3      	str	r3, [r2, #108]	; 0x6c
    /* restore r4-r7, go back 9*4 bytes to the start of the stored block */
    subs r0, #36
    ldmia r0!, {r4-r7}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    /* restore BASEPRI for the incoming thread */
    msr BASEPRI, r0
 1004cda:	f380 8811 	msr	BASEPRI, r0
    isb

#endif

    /* load callee-saved + psp from thread */
    add r0, r2, #_thread_offset_to_callee_saved
 1004cde:	f102 0030 	add.w	r0, r2, #48	; 0x30
    ldmia r0, {v1-v8, ip}
 1004ce2:	e890 1ff0 	ldmia.w	r0, {r4, r5, r6, r7, r8, r9, sl, fp, ip}
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
    msr PSP, ip
 1004ce6:	f38c 8809 	msr	PSP, ip

    /*
     * Cortex-M: return from PendSV exception
     * Cortex-R: return to the caller (_IntExit or z_arm_svc)
     */
    bx lr
 1004cea:	4770      	bx	lr
    ldr r1, =_kernel
 1004cec:	210065b8 	.word	0x210065b8
    ldr v4, =_SCS_ICSR
 1004cf0:	e000ed04 	.word	0xe000ed04

01004cf4 <z_arm_svc>:
  bne _stack_frame_endif
_stack_frame_msp:
  mrs r0, MSP
_stack_frame_endif:
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    tst lr, #0x4    /* did we come from thread mode ? */
 1004cf4:	f01e 0f04 	tst.w	lr, #4
    ite eq  /* if zero (equal), came from handler mode */
 1004cf8:	bf0c      	ite	eq
        mrseq r0, MSP   /* handler mode, stack frame is on MSP */
 1004cfa:	f3ef 8008 	mrseq	r0, MSP
        mrsne r0, PSP   /* thread mode, stack frame is on PSP */
 1004cfe:	f3ef 8009 	mrsne	r0, PSP
#endif


    /* Figure out what SVC call number was invoked */

    ldr r1, [r0, #24]   /* grab address of PC from stack frame */
 1004d02:	6981      	ldr	r1, [r0, #24]
     */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    subs r1, r1, #2
    ldrb r1, [r1]
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    ldrb r1, [r1, #-2]
 1004d04:	f811 1c02 	ldrb.w	r1, [r1, #-2]
#endif
    bne _oops

#endif /* CONFIG_USERSPACE */

    cmp r1, #2
 1004d08:	2902      	cmp	r1, #2
    beq _oops
 1004d0a:	d0ff      	beq.n	1004d0c <_oops>

01004d0c <_oops>:
    /* exception return is done in z_arm_int_exit() */
    b z_arm_int_exit
#endif

_oops:
    push {r0, lr}
 1004d0c:	b501      	push	{r0, lr}
    bl z_do_kernel_oops
 1004d0e:	f011 fd59 	bl	10167c4 <z_do_kernel_oops>
    /* return from SVC exception is done here */
    pop {r0, pc}
 1004d12:	bd01      	pop	{r0, pc}

01004d14 <arch_irq_enable>:
#define REG_FROM_IRQ(irq) (irq / NUM_IRQS_PER_REG)
#define BIT_FROM_IRQ(irq) (irq % NUM_IRQS_PER_REG)

void arch_irq_enable(unsigned int irq)
{
	NVIC_EnableIRQ((IRQn_Type)irq);
 1004d14:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
 1004d16:	2b00      	cmp	r3, #0
 1004d18:	db08      	blt.n	1004d2c <arch_irq_enable+0x18>
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 1004d1a:	2201      	movs	r2, #1
 1004d1c:	f000 001f 	and.w	r0, r0, #31
 1004d20:	fa02 f000 	lsl.w	r0, r2, r0
 1004d24:	4a02      	ldr	r2, [pc, #8]	; (1004d30 <arch_irq_enable+0x1c>)
 1004d26:	095b      	lsrs	r3, r3, #5
 1004d28:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
}
 1004d2c:	4770      	bx	lr
 1004d2e:	bf00      	nop
 1004d30:	e000e100 	.word	0xe000e100

01004d34 <arch_irq_disable>:

void arch_irq_disable(unsigned int irq)
{
	NVIC_DisableIRQ((IRQn_Type)irq);
 1004d34:	b243      	sxtb	r3, r0
  if ((int32_t)(IRQn) >= 0)
 1004d36:	2b00      	cmp	r3, #0
 1004d38:	db0d      	blt.n	1004d56 <arch_irq_disable+0x22>
    NVIC->ICER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 1004d3a:	2201      	movs	r2, #1
 1004d3c:	f000 001f 	and.w	r0, r0, #31
 1004d40:	fa02 f000 	lsl.w	r0, r2, r0
 1004d44:	095b      	lsrs	r3, r3, #5
 1004d46:	4a04      	ldr	r2, [pc, #16]	; (1004d58 <arch_irq_disable+0x24>)
 1004d48:	3320      	adds	r3, #32
 1004d4a:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
  \details Acts as a special kind of Data Memory Barrier.
           It completes when all explicit memory accesses before this instruction complete.
 */
__STATIC_FORCEINLINE void __DSB(void)
{
  __ASM volatile ("dsb 0xF":::"memory");
 1004d4e:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 1004d52:	f3bf 8f6f 	isb	sy
}
 1004d56:	4770      	bx	lr
 1004d58:	e000e100 	.word	0xe000e100

01004d5c <arch_irq_is_enabled>:

int arch_irq_is_enabled(unsigned int irq)
{
	return NVIC->ISER[REG_FROM_IRQ(irq)] & BIT(BIT_FROM_IRQ(irq));
 1004d5c:	4b05      	ldr	r3, [pc, #20]	; (1004d74 <arch_irq_is_enabled+0x18>)
 1004d5e:	0942      	lsrs	r2, r0, #5
 1004d60:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 1004d64:	2301      	movs	r3, #1
 1004d66:	f000 001f 	and.w	r0, r0, #31
 1004d6a:	fa03 f000 	lsl.w	r0, r3, r0
}
 1004d6e:	4010      	ands	r0, r2
 1004d70:	4770      	bx	lr
 1004d72:	bf00      	nop
 1004d74:	e000e100 	.word	0xe000e100

01004d78 <z_arm_irq_priority_set>:
	 */
	__ASSERT(prio <= (BIT(NUM_IRQ_PRIO_BITS) - 1),
		 "invalid priority %d! values must be less than %lu\n",
		 prio - _IRQ_PRIO_OFFSET,
		 BIT(NUM_IRQ_PRIO_BITS) - (_IRQ_PRIO_OFFSET));
	NVIC_SetPriority((IRQn_Type)irq, prio);
 1004d78:	b243      	sxtb	r3, r0
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
 1004d7a:	2b00      	cmp	r3, #0
	prio += _IRQ_PRIO_OFFSET;
 1004d7c:	f101 0101 	add.w	r1, r1, #1
  {
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1004d80:	bfac      	ite	ge
 1004d82:	f103 4360 	addge.w	r3, r3, #3758096384	; 0xe0000000
  }
  else
  {
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1004d86:	4b06      	ldrlt	r3, [pc, #24]	; (1004da0 <z_arm_irq_priority_set+0x28>)
 1004d88:	ea4f 1141 	mov.w	r1, r1, lsl #5
 1004d8c:	b2c9      	uxtb	r1, r1
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1004d8e:	bfab      	itete	ge
 1004d90:	f503 4361 	addge.w	r3, r3, #57600	; 0xe100
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1004d94:	f000 000f 	andlt.w	r0, r0, #15
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1004d98:	f883 1300 	strbge.w	r1, [r3, #768]	; 0x300
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1004d9c:	5419      	strblt	r1, [r3, r0]
}
 1004d9e:	4770      	bx	lr
 1004da0:	e000ed14 	.word	0xe000ed14

01004da4 <_arch_isr_direct_pm>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
}

#ifdef CONFIG_SYS_POWER_MANAGEMENT
void _arch_isr_direct_pm(void)
{
 1004da4:	b508      	push	{r3, lr}
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Lock all interrupts. irq_lock() will on this CPU only disable those
	 * lower than BASEPRI, which is not what we want. See comments in
	 * arch/arm/core/aarch32/isr_wrapper.S
	 */
	__asm__ volatile("cpsid i" : : : "memory");
 1004da6:	b672      	cpsid	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	if (_kernel.idle) {
 1004da8:	4b04      	ldr	r3, [pc, #16]	; (1004dbc <_arch_isr_direct_pm+0x18>)
 1004daa:	6a18      	ldr	r0, [r3, #32]
 1004dac:	b118      	cbz	r0, 1004db6 <_arch_isr_direct_pm+0x12>
		s32_t idle_val = _kernel.idle;

		_kernel.idle = 0;
 1004dae:	2200      	movs	r2, #0
 1004db0:	621a      	str	r2, [r3, #32]
		z_sys_power_save_idle_exit(idle_val);
 1004db2:	f012 fbdf 	bl	1017574 <z_sys_power_save_idle_exit>

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE) \
	|| defined(CONFIG_ARMV7_R)
	irq_unlock(key);
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	__asm__ volatile("cpsie i" : : : "memory");
 1004db6:	b662      	cpsie	i
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

}
 1004db8:	bd08      	pop	{r3, pc}
 1004dba:	bf00      	nop
 1004dbc:	210065b8 	.word	0x210065b8

01004dc0 <arch_new_thread>:
#ifdef CONFIG_INIT_STACKS
	memset(stack, 0xaa, stack_size);
#endif
#if defined(CONFIG_THREAD_STACK_INFO)
	thread->stack_info.start = (uintptr_t)stack;
	thread->stack_info.size = stack_size;
 1004dc0:	e9c0 1218 	strd	r1, r2, [r0, #96]	; 0x60
			- MPU_GUARD_ALIGN_AND_SIZE;
		stackSize -= MPU_GUARD_ALIGN_AND_SIZE_FLOAT
			- MPU_GUARD_ALIGN_AND_SIZE;
	}
#endif
	stackEnd = pStackMem + stackSize;
 1004dc4:	440a      	add	r2, r1
	 *
	 * The initial carved stack frame only needs to contain the basic
	 * stack frame (state context), because no FP operations have been
	 * performed yet for this thread.
	 */
	pInitCtx = (struct __esf *)(Z_STACK_PTR_ALIGN(stackEnd -
 1004dc6:	3a20      	subs	r2, #32
 1004dc8:	f022 0207 	bic.w	r2, r2, #7
#if defined(CONFIG_CPU_CORTEX_M)
	/* force ARM mode by clearing LSB of address */
	pInitCtx->basic.pc &= 0xfffffffe;
#endif

	pInitCtx->basic.a1 = (u32_t)pEntry;
 1004dcc:	6013      	str	r3, [r2, #0]
	pInitCtx->basic.a2 = (u32_t)parameter1;
 1004dce:	9b00      	ldr	r3, [sp, #0]
	pInitCtx->basic.pc &= 0xfffffffe;
 1004dd0:	4907      	ldr	r1, [pc, #28]	; (1004df0 <arch_new_thread+0x30>)
	pInitCtx->basic.a2 = (u32_t)parameter1;
 1004dd2:	6053      	str	r3, [r2, #4]
	pInitCtx->basic.a3 = (u32_t)parameter2;
 1004dd4:	9b01      	ldr	r3, [sp, #4]
	pInitCtx->basic.pc &= 0xfffffffe;
 1004dd6:	f021 0101 	bic.w	r1, r1, #1
	pInitCtx->basic.a3 = (u32_t)parameter2;
 1004dda:	6093      	str	r3, [r2, #8]
	pInitCtx->basic.a4 = (u32_t)parameter3;
 1004ddc:	9b02      	ldr	r3, [sp, #8]
	pInitCtx->basic.pc &= 0xfffffffe;
 1004dde:	6191      	str	r1, [r2, #24]
	pInitCtx->basic.a4 = (u32_t)parameter3;
 1004de0:	60d3      	str	r3, [r2, #12]

#if defined(CONFIG_CPU_CORTEX_M)
	pInitCtx->basic.xpsr =
 1004de2:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
 1004de6:	61d3      	str	r3, [r2, #28]
#endif /* CONFIG_COMPILER_ISA_THUMB2 */
#endif /* CONFIG_CPU_CORTEX_M */

	thread->callee_saved.psp = (u32_t)pInitCtx;

	thread->arch.basepri = 0;
 1004de8:	2300      	movs	r3, #0
	thread->callee_saved.psp = (u32_t)pInitCtx;
 1004dea:	6502      	str	r2, [r0, #80]	; 0x50
	thread->arch.basepri = 0;
 1004dec:	66c3      	str	r3, [r0, #108]	; 0x6c

	/*
	 * initial values in all other registers/thread entries are
	 * irrelevant.
	 */
}
 1004dee:	4770      	bx	lr
 1004df0:	01014e0b 	.word	0x01014e0b

01004df4 <arch_switch_to_main_thread>:

void arch_switch_to_main_thread(struct k_thread *main_thread,
				k_thread_stack_t *main_stack,
				size_t main_stack_size,
				k_thread_entry_t _main)
{
 1004df4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1004df6:	460c      	mov	r4, r1
 1004df8:	4617      	mov	r7, r2
 1004dfa:	4606      	mov	r6, r0
 1004dfc:	461d      	mov	r5, r3
	 * to set up access permissions for fixed memory sections, such
	 * as Application Memory or No-Cacheable SRAM area.
	 *
	 * This function is invoked once, upon system initialization.
	 */
	z_arm_configure_static_mpu_regions();
 1004dfe:	f000 fb07 	bl	1005410 <z_arm_configure_static_mpu_regions>
	start_of_main_stack =
		Z_THREAD_STACK_BUFFER(main_stack) + main_stack_size;

	start_of_main_stack = (char *)Z_STACK_PTR_ALIGN(start_of_main_stack);

	_current = main_thread;
 1004e02:	4b09      	ldr	r3, [pc, #36]	; (1004e28 <arch_switch_to_main_thread+0x34>)
	start_of_main_stack =
 1004e04:	443c      	add	r4, r7
	start_of_main_stack = (char *)Z_STACK_PTR_ALIGN(start_of_main_stack);
 1004e06:	f024 0407 	bic.w	r4, r4, #7
	_current = main_thread;
 1004e0a:	609e      	str	r6, [r3, #8]

	/*
	 * Set PSP to the highest address of the main stack
	 * before enabling interrupts and jumping to main.
	 */
	__asm__ volatile (
 1004e0c:	4628      	mov	r0, r5
 1004e0e:	f384 8809 	msr	PSP, r4
 1004e12:	2100      	movs	r1, #0
 1004e14:	b663      	cpsie	if
 1004e16:	f381 8811 	msr	BASEPRI, r1
 1004e1a:	f3bf 8f6f 	isb	sy
 1004e1e:	2200      	movs	r2, #0
 1004e20:	2300      	movs	r3, #0
 1004e22:	f00f fff2 	bl	1014e0a <z_thread_entry>
	:
	: "r" (_main), "r" (start_of_main_stack)
	: "r0" /* not to be overwritten by msr PSP, %1 */
	);

	CODE_UNREACHABLE;
 1004e26:	bf00      	nop
 1004e28:	210065b8 	.word	0x210065b8

01004e2c <z_arm_cpu_idle_init>:
 * void z_arm_cpu_idle_init(void);
 */

SECTION_FUNC(TEXT, z_arm_cpu_idle_init)
#if defined(CONFIG_CPU_CORTEX_M)
	ldr	r1, =_SCB_SCR
 1004e2c:	4901      	ldr	r1, [pc, #4]	; (1004e34 <z_arm_cpu_idle_init+0x8>)
	movs.n	r2, #_SCR_INIT_BITS
 1004e2e:	2210      	movs	r2, #16
	str	r2, [r1]
 1004e30:	600a      	str	r2, [r1, #0]
#endif
	bx	lr
 1004e32:	4770      	bx	lr
	ldr	r1, =_SCB_SCR
 1004e34:	e000ed10 	.word	0xe000ed10

01004e38 <arch_cpu_idle>:
	 * before entering low power state.
	 *
	 * Set PRIMASK before configuring BASEPRI to prevent interruption
	 * before wake-up.
	 */
	cpsid	i
 1004e38:	b672      	cpsid	i

	/*
	 * Set wake-up interrupt priority to the lowest and synchronise to
	 * ensure that this is visible to the WFI instruction.
	 */
	eors.n	r0, r0
 1004e3a:	4040      	eors	r0, r0
	msr	BASEPRI, r0
 1004e3c:	f380 8811 	msr	BASEPRI, r0
	isb
 1004e40:	f3bf 8f6f 	isb	sy

	/*
	 * Wait for all memory transactions to complete before entering low
	 * power state.
	 */
	dsb
 1004e44:	f3bf 8f4f 	dsb	sy

	/* Enter low power state */
	wfi
 1004e48:	bf30      	wfi

	/*
	 * Clear PRIMASK and flush instruction buffer to immediately service
	 * the wake-up interrupt.
	 */
	cpsie	i
 1004e4a:	b662      	cpsie	i
	isb
 1004e4c:	f3bf 8f6f 	isb	sy

	bx	lr
 1004e50:	4770      	bx	lr
 1004e52:	bf00      	nop

01004e54 <z_arm_fatal_error>:
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
		esf->basic.pc);
}

void z_arm_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
 1004e54:	b573      	push	{r0, r1, r4, r5, r6, lr}
 1004e56:	4606      	mov	r6, r0

	if (esf != NULL) {
 1004e58:	460c      	mov	r4, r1
 1004e5a:	b301      	cbz	r1, 1004e9e <z_arm_fatal_error+0x4a>
	return ((u8_t *)data - (u8_t *)__log_const_start)/
 1004e5c:	4b13      	ldr	r3, [pc, #76]	; (1004eac <z_arm_fatal_error+0x58>)
 1004e5e:	4d14      	ldr	r5, [pc, #80]	; (1004eb0 <z_arm_fatal_error+0x5c>)
	LOG_ERR("r0/a1:  0x%08x  r1/a2:  0x%08x  r2/a3:  0x%08x",
 1004e60:	4814      	ldr	r0, [pc, #80]	; (1004eb4 <z_arm_fatal_error+0x60>)
 1004e62:	1aed      	subs	r5, r5, r3
 1004e64:	08ed      	lsrs	r5, r5, #3
 1004e66:	01ad      	lsls	r5, r5, #6
 1004e68:	f045 0501 	orr.w	r5, r5, #1
 1004e6c:	f8ad 5000 	strh.w	r5, [sp]
 1004e70:	e9d1 2301 	ldrd	r2, r3, [r1, #4]
 1004e74:	6809      	ldr	r1, [r1, #0]
 1004e76:	f010 fac4 	bl	1015402 <log_3>
	LOG_ERR("r3/a4:  0x%08x r12/ip:  0x%08x r14/lr:  0x%08x",
 1004e7a:	f8ad 5000 	strh.w	r5, [sp]
 1004e7e:	e9d4 2304 	ldrd	r2, r3, [r4, #16]
 1004e82:	68e1      	ldr	r1, [r4, #12]
 1004e84:	480c      	ldr	r0, [pc, #48]	; (1004eb8 <z_arm_fatal_error+0x64>)
 1004e86:	f010 fabc 	bl	1015402 <log_3>
	LOG_ERR(" xpsr:  0x%08x", esf->basic.xpsr);
 1004e8a:	462a      	mov	r2, r5
 1004e8c:	69e1      	ldr	r1, [r4, #28]
 1004e8e:	480b      	ldr	r0, [pc, #44]	; (1004ebc <z_arm_fatal_error+0x68>)
 1004e90:	f010 fa8a 	bl	10153a8 <log_1>
	LOG_ERR("Faulting instruction address (r15/pc): 0x%08x",
 1004e94:	462a      	mov	r2, r5
 1004e96:	69a1      	ldr	r1, [r4, #24]
 1004e98:	4809      	ldr	r0, [pc, #36]	; (1004ec0 <z_arm_fatal_error+0x6c>)
 1004e9a:	f010 fa85 	bl	10153a8 <log_1>
		esf_dump(esf);
	}
	z_fatal_error(reason, esf);
 1004e9e:	4621      	mov	r1, r4
 1004ea0:	4630      	mov	r0, r6
}
 1004ea2:	b002      	add	sp, #8
 1004ea4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	z_fatal_error(reason, esf);
 1004ea8:	f00e be9a 	b.w	1013be0 <z_fatal_error>
 1004eac:	010180b8 	.word	0x010180b8
 1004eb0:	010181c0 	.word	0x010181c0
 1004eb4:	010192b3 	.word	0x010192b3
 1004eb8:	010192e2 	.word	0x010192e2
 1004ebc:	01019311 	.word	0x01019311
 1004ec0:	01019320 	.word	0x01019320

01004ec4 <z_SysNmiOnReset>:
_ASM_FILE_PROLOGUE

GTEXT(z_SysNmiOnReset)

SECTION_FUNC(TEXT, z_SysNmiOnReset)
    wfi
 1004ec4:	bf30      	wfi
    b z_SysNmiOnReset
 1004ec6:	f7ff bffd 	b.w	1004ec4 <z_SysNmiOnReset>
 1004eca:	bf00      	nop

01004ecc <z_arm_prep_c>:
 * This routine prepares for the execution of and runs C code.
 *
 * @return N/A
 */
void z_arm_prep_c(void)
{
 1004ecc:	b508      	push	{r3, lr}
	SCB->VTOR = VECTOR_ADDRESS & SCB_VTOR_TBLOFF_Msk;
 1004ece:	4b08      	ldr	r3, [pc, #32]	; (1004ef0 <z_arm_prep_c+0x24>)
 1004ed0:	4a08      	ldr	r2, [pc, #32]	; (1004ef4 <z_arm_prep_c+0x28>)
 1004ed2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 1004ed6:	6093      	str	r3, [r2, #8]
  __ASM volatile ("dsb 0xF":::"memory");
 1004ed8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 1004edc:	f3bf 8f6f 	isb	sy
	relocate_vector_table();
#if defined(CONFIG_CPU_HAS_FPU)
	z_arm_floating_point_init();
#endif
	z_bss_zero();
 1004ee0:	f00e fefc 	bl	1013cdc <z_bss_zero>
	z_data_copy();
 1004ee4:	f00e ff04 	bl	1013cf0 <z_data_copy>
#if defined(CONFIG_ARMV7_R) && defined(CONFIG_INIT_STACKS)
	z_arm_init_stacks();
#endif
	z_arm_interrupt_init();
 1004ee8:	f000 fa60 	bl	10053ac <z_arm_interrupt_init>
	z_cstart();
 1004eec:	f00e ff3e 	bl	1013d6c <z_cstart>
 1004ef0:	01000000 	.word	0x01000000
 1004ef4:	e000ed00 	.word	0xe000ed00

01004ef8 <_isr_wrapper>:
 * @return N/A
 */
SECTION_FUNC(TEXT, _isr_wrapper)

#if defined(CONFIG_CPU_CORTEX_M)
	push {r0,lr}		/* r0, lr are now the first items on the stack */
 1004ef8:	b501      	push	{r0, lr}
	 * Disable interrupts to prevent nesting while exiting idle state. This
	 * is only necessary for the Cortex-M because it is the only ARM
	 * architecture variant that automatically enables interrupts when
	 * entering an ISR.
	 */
	cpsid i  /* PRIMASK = 1 */
 1004efa:	b672      	cpsid	i
#endif

	/* is this a wakeup from idle ? */
	ldr r2, =_kernel
 1004efc:	4a0b      	ldr	r2, [pc, #44]	; (1004f2c <_isr_wrapper+0x34>)
	/* requested idle duration, in ticks */
	ldr r0, [r2, #_kernel_offset_to_idle]
 1004efe:	6a10      	ldr	r0, [r2, #32]
	cmp r0, #0
 1004f00:	2800      	cmp	r0, #0
	str r1, [r2, #_kernel_offset_to_idle]
	bl z_sys_power_save_idle_exit
_idle_state_cleared:

#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	ittt ne
 1004f02:	bf1e      	ittt	ne
	movne	r1, #0
 1004f04:	2100      	movne	r1, #0
		/* clear kernel idle state */
		strne	r1, [r2, #_kernel_offset_to_idle]
 1004f06:	6211      	strne	r1, [r2, #32]
		blne	z_sys_power_save_idle_exit
 1004f08:	f012 fb34 	blne	1017574 <z_sys_power_save_idle_exit>
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

#if defined(CONFIG_CPU_CORTEX_M)
	cpsie i		/* re-enable interrupts (PRIMASK = 0) */
 1004f0c:	b662      	cpsie	i
#endif

#endif /* CONFIG_SYS_POWER_MANAGEMENT */

#if defined(CONFIG_CPU_CORTEX_M)
	mrs r0, IPSR	/* get exception number */
 1004f0e:	f3ef 8005 	mrs	r0, IPSR
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	ldr r1, =16
	subs r0, r1	/* get IRQ number */
	lsls r0, #3	/* table is 8-byte wide */
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	sub r0, r0, #16	/* get IRQ number */
 1004f12:	f1a0 0010 	sub.w	r0, r0, #16
	lsl r0, r0, #3	/* table is 8-byte wide */
 1004f16:	ea4f 00c0 	mov.w	r0, r0, lsl #3
	 * interface function.
	 */
	cpsie i
#endif /* !CONFIG_CPU_CORTEX_M */

	ldr r1, =_sw_isr_table
 1004f1a:	4905      	ldr	r1, [pc, #20]	; (1004f30 <_isr_wrapper+0x38>)
	add r1, r1, r0	/* table entry: ISRs must have their MSB set to stay
 1004f1c:	4401      	add	r1, r0
			 * in thumb mode */

	ldm r1!,{r0,r3}	/* arg in r0, ISR in r3 */
 1004f1e:	c909      	ldmia	r1!, {r0, r3}
#ifdef CONFIG_EXECUTION_BENCHMARKING
	push {r0, r3}	/* Save r0 and r3 into stack */
	bl read_timer_end_of_isr
	pop {r0, r3}	/* Restore r0 and r3 regs */
#endif /* CONFIG_EXECUTION_BENCHMARKING */
	blx r3		/* call ISR */
 1004f20:	4798      	blx	r3

#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
	pop {r0, r3}
	mov lr, r3
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	pop {r0, lr}
 1004f22:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */

	/* Use 'bx' instead of 'b' because 'bx' can jump further, and use
	 * 'bx' instead of 'blx' because exception return is done in
	 * z_arm_int_exit() */
	ldr r1, =z_arm_int_exit
 1004f26:	4903      	ldr	r1, [pc, #12]	; (1004f34 <_isr_wrapper+0x3c>)
	bx r1
 1004f28:	4708      	bx	r1
 1004f2a:	0000      	.short	0x0000
	ldr r2, =_kernel
 1004f2c:	210065b8 	.word	0x210065b8
	ldr r1, =_sw_isr_table
 1004f30:	01017fc8 	.word	0x01017fc8
	ldr r1, =z_arm_int_exit
 1004f34:	0100536d 	.word	0x0100536d

01004f38 <__start>:
 * search for a __start symbol instead, so create that alias here.
 */
SECTION_SUBSEC_FUNC(TEXT,_reset_section,__start)

#if defined(CONFIG_PLATFORM_SPECIFIC_INIT)
    bl z_platform_init
 1004f38:	f010 f9e4 	bl	1015304 <z_platform_init>

    /* lock interrupts: will get unlocked when switch to main task */
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
    cpsid i
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
    movs.n r0, #_EXC_IRQ_DEFAULT_PRIO
 1004f3c:	2020      	movs	r0, #32
    msr BASEPRI, r0
 1004f3e:	f380 8811 	msr	BASEPRI, r0

    /*
     * Set PSP and use it to boot without using MSP, so that it
     * gets set to z_interrupt_stacks during initialization.
     */
    ldr r0, =z_interrupt_stacks
 1004f42:	4808      	ldr	r0, [pc, #32]	; (1004f64 <__start+0x2c>)
    ldr r1, =CONFIG_ISR_STACK_SIZE
 1004f44:	f44f 6100 	mov.w	r1, #2048	; 0x800
    adds r0, r0, r1
 1004f48:	1840      	adds	r0, r0, r1
    msr PSP, r0
 1004f4a:	f380 8809 	msr	PSP, r0
    mrs r0, CONTROL
 1004f4e:	f3ef 8014 	mrs	r0, CONTROL
    movs r1, #2
 1004f52:	2102      	movs	r1, #2
    orrs r0, r1 /* CONTROL_SPSEL_Msk */
 1004f54:	4308      	orrs	r0, r1
    msr CONTROL, r0
 1004f56:	f380 8814 	msr	CONTROL, r0
    /*
     * When changing the stack pointer, software must use an ISB instruction
     * immediately after the MSR instruction. This ensures that instructions
     * after the ISB instruction execute using the new stack pointer.
     */
    isb
 1004f5a:	f3bf 8f6f 	isb	sy
    /*
     * 'bl' jumps the furthest of the branch instructions that are
     * supported on all platforms. So it is used when jumping to z_arm_prep_c
     * (even though we do not intend to return).
     */
    bl z_arm_prep_c
 1004f5e:	f7ff ffb5 	bl	1004ecc <z_arm_prep_c>
 1004f62:	0000      	.short	0x0000
    ldr r0, =z_interrupt_stacks
 1004f64:	21007910 	.word	0x21007910

01004f68 <z_arm_bus_fault>:
#else
#error Unknown ARM architecture
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
SECTION_SUBSEC_FUNC(TEXT,__fault,z_arm_exc_spurious)

	mrs r0, MSP
 1004f68:	f3ef 8008 	mrs	r0, MSP
	mrs r1, PSP
 1004f6c:	f3ef 8109 	mrs	r1, PSP
	mov r2, lr /* EXC_RETURN */
 1004f70:	4672      	mov	r2, lr

	push {r0, lr}
 1004f72:	b501      	push	{r0, lr}

	bl z_arm_fault
 1004f74:	f000 f926 	bl	10051c4 <z_arm_fault>

	pop {r0, pc}
 1004f78:	bd01      	pop	{r0, pc}
 1004f7a:	bf00      	nop

01004f7c <usage_fault.isra.0>:
 *
 * See z_arm_fault_dump() for example.
 *
 * @return error code to identify the fatal error reason
 */
static u32_t usage_fault(const z_arch_esf_t *esf)
 1004f7c:	b570      	push	{r4, r5, r6, lr}
 1004f7e:	4b27      	ldr	r3, [pc, #156]	; (100501c <usage_fault.isra.0+0xa0>)
 1004f80:	4c27      	ldr	r4, [pc, #156]	; (1005020 <usage_fault.isra.0+0xa4>)
	u32_t reason = K_ERR_CPU_EXCEPTION;

	PR_FAULT_INFO("***** USAGE FAULT *****");

	/* bits are sticky: they stack and must be reset */
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
 1004f82:	4d28      	ldr	r5, [pc, #160]	; (1005024 <usage_fault.isra.0+0xa8>)
 1004f84:	1ae4      	subs	r4, r4, r3
 1004f86:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** USAGE FAULT *****");
 1004f88:	01a4      	lsls	r4, r4, #6
 1004f8a:	f044 0601 	orr.w	r6, r4, #1
 1004f8e:	4631      	mov	r1, r6
 1004f90:	4825      	ldr	r0, [pc, #148]	; (1005028 <usage_fault.isra.0+0xac>)
 1004f92:	f010 f9fc 	bl	101538e <log_0>
	if ((SCB->CFSR & SCB_CFSR_DIVBYZERO_Msk) != 0) {
 1004f96:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 1004f98:	0192      	lsls	r2, r2, #6
 1004f9a:	d503      	bpl.n	1004fa4 <usage_fault.isra.0+0x28>
		PR_FAULT_INFO("  Division by zero");
 1004f9c:	4631      	mov	r1, r6
 1004f9e:	4823      	ldr	r0, [pc, #140]	; (100502c <usage_fault.isra.0+0xb0>)
 1004fa0:	f010 f9f5 	bl	101538e <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNALIGNED_Msk) != 0) {
 1004fa4:	6aab      	ldr	r3, [r5, #40]	; 0x28
 1004fa6:	01db      	lsls	r3, r3, #7
 1004fa8:	d504      	bpl.n	1004fb4 <usage_fault.isra.0+0x38>
		PR_FAULT_INFO("  Unaligned memory access");
 1004faa:	4821      	ldr	r0, [pc, #132]	; (1005030 <usage_fault.isra.0+0xb4>)
 1004fac:	f044 0101 	orr.w	r1, r4, #1
 1004fb0:	f010 f9ed 	bl	101538e <log_0>
	}
#if defined(CONFIG_ARMV8_M_MAINLINE)
	if ((SCB->CFSR & SCB_CFSR_STKOF_Msk) != 0) {
 1004fb4:	4d1b      	ldr	r5, [pc, #108]	; (1005024 <usage_fault.isra.0+0xa8>)
 1004fb6:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 1004fb8:	02d6      	lsls	r6, r2, #11
 1004fba:	d504      	bpl.n	1004fc6 <usage_fault.isra.0+0x4a>
		PR_FAULT_INFO("  Stack overflow (context area not valid)");
 1004fbc:	481d      	ldr	r0, [pc, #116]	; (1005034 <usage_fault.isra.0+0xb8>)
 1004fbe:	f044 0101 	orr.w	r1, r4, #1
 1004fc2:	f010 f9e4 	bl	101538e <log_0>
		 */
		reason = K_ERR_STACK_CHK_FAIL;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
	}
#endif /* CONFIG_ARMV8_M_MAINLINE */
	if ((SCB->CFSR & SCB_CFSR_NOCP_Msk) != 0) {
 1004fc6:	6aab      	ldr	r3, [r5, #40]	; 0x28
 1004fc8:	0318      	lsls	r0, r3, #12
 1004fca:	d504      	bpl.n	1004fd6 <usage_fault.isra.0+0x5a>
		PR_FAULT_INFO("  No coprocessor instructions");
 1004fcc:	481a      	ldr	r0, [pc, #104]	; (1005038 <usage_fault.isra.0+0xbc>)
 1004fce:	f044 0101 	orr.w	r1, r4, #1
 1004fd2:	f010 f9dc 	bl	101538e <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVPC_Msk) != 0) {
 1004fd6:	4d13      	ldr	r5, [pc, #76]	; (1005024 <usage_fault.isra.0+0xa8>)
 1004fd8:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 1004fda:	0351      	lsls	r1, r2, #13
 1004fdc:	d504      	bpl.n	1004fe8 <usage_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Illegal load of EXC_RETURN into PC");
 1004fde:	4817      	ldr	r0, [pc, #92]	; (100503c <usage_fault.isra.0+0xc0>)
 1004fe0:	f044 0101 	orr.w	r1, r4, #1
 1004fe4:	f010 f9d3 	bl	101538e <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_INVSTATE_Msk) != 0) {
 1004fe8:	6aab      	ldr	r3, [r5, #40]	; 0x28
 1004fea:	039a      	lsls	r2, r3, #14
 1004fec:	d504      	bpl.n	1004ff8 <usage_fault.isra.0+0x7c>
		PR_FAULT_INFO("  Illegal use of the EPSR");
 1004fee:	4814      	ldr	r0, [pc, #80]	; (1005040 <usage_fault.isra.0+0xc4>)
 1004ff0:	f044 0101 	orr.w	r1, r4, #1
 1004ff4:	f010 f9cb 	bl	101538e <log_0>
	}
	if ((SCB->CFSR & SCB_CFSR_UNDEFINSTR_Msk) != 0) {
 1004ff8:	4d0a      	ldr	r5, [pc, #40]	; (1005024 <usage_fault.isra.0+0xa8>)
 1004ffa:	6aab      	ldr	r3, [r5, #40]	; 0x28
 1004ffc:	03db      	lsls	r3, r3, #15
 1004ffe:	d504      	bpl.n	100500a <usage_fault.isra.0+0x8e>
		PR_FAULT_INFO("  Attempt to execute undefined instruction");
 1005000:	4810      	ldr	r0, [pc, #64]	; (1005044 <usage_fault.isra.0+0xc8>)
 1005002:	f044 0101 	orr.w	r1, r4, #1
 1005006:	f010 f9c2 	bl	101538e <log_0>
	}

	/* clear UFSR sticky bits */
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
 100500a:	6aab      	ldr	r3, [r5, #40]	; 0x28

	return reason;
}
 100500c:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_USGFAULTSR_Msk;
 100500e:	ea6f 4303 	mvn.w	r3, r3, lsl #16
 1005012:	ea6f 4313 	mvn.w	r3, r3, lsr #16
 1005016:	62ab      	str	r3, [r5, #40]	; 0x28
}
 1005018:	bd70      	pop	{r4, r5, r6, pc}
 100501a:	bf00      	nop
 100501c:	010180b8 	.word	0x010180b8
 1005020:	010181c0 	.word	0x010181c0
 1005024:	e000ed00 	.word	0xe000ed00
 1005028:	0101934e 	.word	0x0101934e
 100502c:	01019366 	.word	0x01019366
 1005030:	01019379 	.word	0x01019379
 1005034:	01019393 	.word	0x01019393
 1005038:	010193bd 	.word	0x010193bd
 100503c:	010193db 	.word	0x010193db
 1005040:	01019400 	.word	0x01019400
 1005044:	0101941a 	.word	0x0101941a

01005048 <mem_manage_fault.isra.0>:
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
 1005048:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100504c:	4b22      	ldr	r3, [pc, #136]	; (10050d8 <mem_manage_fault.isra.0+0x90>)
 100504e:	4c23      	ldr	r4, [pc, #140]	; (10050dc <mem_manage_fault.isra.0+0x94>)
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
 1005050:	4d23      	ldr	r5, [pc, #140]	; (10050e0 <mem_manage_fault.isra.0+0x98>)
 1005052:	1ae4      	subs	r4, r4, r3
 1005054:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** MPU FAULT *****");
 1005056:	01a4      	lsls	r4, r4, #6
 1005058:	f044 0801 	orr.w	r8, r4, #1
static u32_t mem_manage_fault(z_arch_esf_t *esf, int from_hard_fault,
 100505c:	4607      	mov	r7, r0
 100505e:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** MPU FAULT *****");
 1005060:	4820      	ldr	r0, [pc, #128]	; (10050e4 <mem_manage_fault.isra.0+0x9c>)
 1005062:	4641      	mov	r1, r8
 1005064:	f010 f993 	bl	101538e <log_0>
	if ((SCB->CFSR & SCB_CFSR_MSTKERR_Msk) != 0) {
 1005068:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 100506a:	06d3      	lsls	r3, r2, #27
 100506c:	d503      	bpl.n	1005076 <mem_manage_fault.isra.0+0x2e>
		PR_FAULT_INFO("  Stacking error (context area might be"
 100506e:	4641      	mov	r1, r8
 1005070:	481d      	ldr	r0, [pc, #116]	; (10050e8 <mem_manage_fault.isra.0+0xa0>)
 1005072:	f010 f98c 	bl	101538e <log_0>
	if ((SCB->CFSR & SCB_CFSR_MUNSTKERR_Msk) != 0) {
 1005076:	6aab      	ldr	r3, [r5, #40]	; 0x28
 1005078:	0718      	lsls	r0, r3, #28
 100507a:	d504      	bpl.n	1005086 <mem_manage_fault.isra.0+0x3e>
		PR_FAULT_INFO("  Unstacking error");
 100507c:	481b      	ldr	r0, [pc, #108]	; (10050ec <mem_manage_fault.isra.0+0xa4>)
 100507e:	f044 0101 	orr.w	r1, r4, #1
 1005082:	f010 f984 	bl	101538e <log_0>
	if ((SCB->CFSR & SCB_CFSR_DACCVIOL_Msk) != 0) {
 1005086:	4d16      	ldr	r5, [pc, #88]	; (10050e0 <mem_manage_fault.isra.0+0x98>)
 1005088:	6aab      	ldr	r3, [r5, #40]	; 0x28
 100508a:	0799      	lsls	r1, r3, #30
 100508c:	d512      	bpl.n	10050b4 <mem_manage_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Data Access Violation");
 100508e:	f044 0801 	orr.w	r8, r4, #1
 1005092:	4641      	mov	r1, r8
 1005094:	4816      	ldr	r0, [pc, #88]	; (10050f0 <mem_manage_fault.isra.0+0xa8>)
 1005096:	f010 f97a 	bl	101538e <log_0>
		mmfar = SCB->MMFAR;
 100509a:	6b69      	ldr	r1, [r5, #52]	; 0x34
		if ((SCB->CFSR & SCB_CFSR_MMARVALID_Msk) != 0) {
 100509c:	6aab      	ldr	r3, [r5, #40]	; 0x28
 100509e:	061a      	lsls	r2, r3, #24
 10050a0:	d508      	bpl.n	10050b4 <mem_manage_fault.isra.0+0x6c>
			PR_EXC("  MMFAR Address: 0x%x", mmfar);
 10050a2:	4642      	mov	r2, r8
 10050a4:	4813      	ldr	r0, [pc, #76]	; (10050f4 <mem_manage_fault.isra.0+0xac>)
 10050a6:	f010 f97f 	bl	10153a8 <log_1>
			if (from_hard_fault) {
 10050aa:	b11f      	cbz	r7, 10050b4 <mem_manage_fault.isra.0+0x6c>
				SCB->CFSR &= ~SCB_CFSR_MMARVALID_Msk;
 10050ac:	6aab      	ldr	r3, [r5, #40]	; 0x28
 10050ae:	f023 0380 	bic.w	r3, r3, #128	; 0x80
 10050b2:	62ab      	str	r3, [r5, #40]	; 0x28
	if ((SCB->CFSR & SCB_CFSR_IACCVIOL_Msk) != 0) {
 10050b4:	4d0a      	ldr	r5, [pc, #40]	; (10050e0 <mem_manage_fault.isra.0+0x98>)
 10050b6:	6aab      	ldr	r3, [r5, #40]	; 0x28
 10050b8:	07db      	lsls	r3, r3, #31
 10050ba:	d504      	bpl.n	10050c6 <mem_manage_fault.isra.0+0x7e>
		PR_FAULT_INFO("  Instruction Access Violation");
 10050bc:	480e      	ldr	r0, [pc, #56]	; (10050f8 <mem_manage_fault.isra.0+0xb0>)
 10050be:	f044 0101 	orr.w	r1, r4, #1
 10050c2:	f010 f964 	bl	101538e <log_0>
	*recoverable = memory_fault_recoverable(esf);
 10050c6:	2000      	movs	r0, #0
	if (SCB->CFSR & SCB_CFSR_MSTKERR_Msk) {
 10050c8:	6aab      	ldr	r3, [r5, #40]	; 0x28
	SCB->CFSR |= SCB_CFSR_MEMFAULTSR_Msk;
 10050ca:	6aab      	ldr	r3, [r5, #40]	; 0x28
 10050cc:	f043 03ff 	orr.w	r3, r3, #255	; 0xff
 10050d0:	62ab      	str	r3, [r5, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
 10050d2:	7030      	strb	r0, [r6, #0]
}
 10050d4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 10050d8:	010180b8 	.word	0x010180b8
 10050dc:	010181c0 	.word	0x010181c0
 10050e0:	e000ed00 	.word	0xe000ed00
 10050e4:	01019445 	.word	0x01019445
 10050e8:	0101945b 	.word	0x0101945b
 10050ec:	0101948e 	.word	0x0101948e
 10050f0:	010194a1 	.word	0x010194a1
 10050f4:	010194b9 	.word	0x010194b9
 10050f8:	010194cf 	.word	0x010194cf

010050fc <bus_fault.isra.0>:
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
 10050fc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1005100:	4b26      	ldr	r3, [pc, #152]	; (100519c <bus_fault.isra.0+0xa0>)
 1005102:	4c27      	ldr	r4, [pc, #156]	; (10051a0 <bus_fault.isra.0+0xa4>)
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
 1005104:	4d27      	ldr	r5, [pc, #156]	; (10051a4 <bus_fault.isra.0+0xa8>)
 1005106:	1ae4      	subs	r4, r4, r3
 1005108:	08e4      	lsrs	r4, r4, #3
	PR_FAULT_INFO("***** BUS FAULT *****");
 100510a:	01a4      	lsls	r4, r4, #6
 100510c:	f044 0801 	orr.w	r8, r4, #1
static int bus_fault(z_arch_esf_t *esf, int from_hard_fault, bool *recoverable)
 1005110:	4607      	mov	r7, r0
 1005112:	460e      	mov	r6, r1
	PR_FAULT_INFO("***** BUS FAULT *****");
 1005114:	4824      	ldr	r0, [pc, #144]	; (10051a8 <bus_fault.isra.0+0xac>)
 1005116:	4641      	mov	r1, r8
 1005118:	f010 f939 	bl	101538e <log_0>
	if (SCB->CFSR & SCB_CFSR_STKERR_Msk) {
 100511c:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 100511e:	04d1      	lsls	r1, r2, #19
 1005120:	d503      	bpl.n	100512a <bus_fault.isra.0+0x2e>
		PR_FAULT_INFO("  Stacking error");
 1005122:	4641      	mov	r1, r8
 1005124:	4821      	ldr	r0, [pc, #132]	; (10051ac <bus_fault.isra.0+0xb0>)
 1005126:	f010 f932 	bl	101538e <log_0>
	if (SCB->CFSR & SCB_CFSR_UNSTKERR_Msk) {
 100512a:	6aab      	ldr	r3, [r5, #40]	; 0x28
 100512c:	051a      	lsls	r2, r3, #20
 100512e:	d504      	bpl.n	100513a <bus_fault.isra.0+0x3e>
		PR_FAULT_INFO("  Unstacking error");
 1005130:	481f      	ldr	r0, [pc, #124]	; (10051b0 <bus_fault.isra.0+0xb4>)
 1005132:	f044 0101 	orr.w	r1, r4, #1
 1005136:	f010 f92a 	bl	101538e <log_0>
	if (SCB->CFSR & SCB_CFSR_PRECISERR_Msk) {
 100513a:	4d1a      	ldr	r5, [pc, #104]	; (10051a4 <bus_fault.isra.0+0xa8>)
 100513c:	6aab      	ldr	r3, [r5, #40]	; 0x28
 100513e:	059b      	lsls	r3, r3, #22
 1005140:	d512      	bpl.n	1005168 <bus_fault.isra.0+0x6c>
		PR_FAULT_INFO("  Precise data bus error");
 1005142:	f044 0801 	orr.w	r8, r4, #1
 1005146:	4641      	mov	r1, r8
 1005148:	481a      	ldr	r0, [pc, #104]	; (10051b4 <bus_fault.isra.0+0xb8>)
 100514a:	f010 f920 	bl	101538e <log_0>
		STORE_xFAR(bfar, SCB->BFAR);
 100514e:	6ba9      	ldr	r1, [r5, #56]	; 0x38
		if ((SCB->CFSR & SCB_CFSR_BFARVALID_Msk) != 0) {
 1005150:	6aab      	ldr	r3, [r5, #40]	; 0x28
 1005152:	0418      	lsls	r0, r3, #16
 1005154:	d508      	bpl.n	1005168 <bus_fault.isra.0+0x6c>
			PR_EXC("  BFAR Address: 0x%x", bfar);
 1005156:	4642      	mov	r2, r8
 1005158:	4817      	ldr	r0, [pc, #92]	; (10051b8 <bus_fault.isra.0+0xbc>)
 100515a:	f010 f925 	bl	10153a8 <log_1>
			if (from_hard_fault) {
 100515e:	b11f      	cbz	r7, 1005168 <bus_fault.isra.0+0x6c>
				SCB->CFSR &= ~SCB_CFSR_BFARVALID_Msk;
 1005160:	6aab      	ldr	r3, [r5, #40]	; 0x28
 1005162:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 1005166:	62ab      	str	r3, [r5, #40]	; 0x28
	if (SCB->CFSR & SCB_CFSR_IMPRECISERR_Msk) {
 1005168:	4d0e      	ldr	r5, [pc, #56]	; (10051a4 <bus_fault.isra.0+0xa8>)
 100516a:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 100516c:	0552      	lsls	r2, r2, #21
 100516e:	d504      	bpl.n	100517a <bus_fault.isra.0+0x7e>
		PR_FAULT_INFO("  Imprecise data bus error");
 1005170:	4812      	ldr	r0, [pc, #72]	; (10051bc <bus_fault.isra.0+0xc0>)
 1005172:	f044 0101 	orr.w	r1, r4, #1
 1005176:	f010 f90a 	bl	101538e <log_0>
	if ((SCB->CFSR & SCB_CFSR_IBUSERR_Msk) != 0) {
 100517a:	6aab      	ldr	r3, [r5, #40]	; 0x28
 100517c:	05db      	lsls	r3, r3, #23
 100517e:	d504      	bpl.n	100518a <bus_fault.isra.0+0x8e>
		PR_FAULT_INFO("  Instruction bus error");
 1005180:	480f      	ldr	r0, [pc, #60]	; (10051c0 <bus_fault.isra.0+0xc4>)
 1005182:	f044 0101 	orr.w	r1, r4, #1
 1005186:	f010 f902 	bl	101538e <log_0>
	*recoverable = memory_fault_recoverable(esf);
 100518a:	2000      	movs	r0, #0
	SCB->CFSR |= SCB_CFSR_BUSFAULTSR_Msk;
 100518c:	4a05      	ldr	r2, [pc, #20]	; (10051a4 <bus_fault.isra.0+0xa8>)
 100518e:	6a93      	ldr	r3, [r2, #40]	; 0x28
 1005190:	f443 437f 	orr.w	r3, r3, #65280	; 0xff00
 1005194:	6293      	str	r3, [r2, #40]	; 0x28
	*recoverable = memory_fault_recoverable(esf);
 1005196:	7030      	strb	r0, [r6, #0]
}
 1005198:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 100519c:	010180b8 	.word	0x010180b8
 10051a0:	010181c0 	.word	0x010181c0
 10051a4:	e000ed00 	.word	0xe000ed00
 10051a8:	010194ee 	.word	0x010194ee
 10051ac:	01019504 	.word	0x01019504
 10051b0:	0101948e 	.word	0x0101948e
 10051b4:	01019515 	.word	0x01019515
 10051b8:	0101952e 	.word	0x0101952e
 10051bc:	01019543 	.word	0x01019543
 10051c0:	0101955e 	.word	0x0101955e

010051c4 <z_arm_fault>:
 * @param psp PSP value immediately after the exception occurred
 * @param exc_return EXC_RETURN value present in LR after exception entry.
 *
 */
void z_arm_fault(u32_t msp, u32_t psp, u32_t exc_return)
{
 10051c4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	u32_t reason = K_ERR_CPU_EXCEPTION;
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 10051c8:	4b56      	ldr	r3, [pc, #344]	; (1005324 <z_arm_fault+0x160>)
{
 10051ca:	460f      	mov	r7, r1
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 10051cc:	685e      	ldr	r6, [r3, #4]
 10051ce:	2500      	movs	r5, #0
{
 10051d0:	b08a      	sub	sp, #40	; 0x28
	int fault = SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk;
 10051d2:	f3c6 0408 	ubfx	r4, r6, #0, #9
 10051d6:	f385 8811 	msr	BASEPRI, r5
 10051da:	f3bf 8f6f 	isb	sy
	if ((exc_return & EXC_RETURN_INDICATOR_PREFIX) !=
 10051de:	f002 437f 	and.w	r3, r2, #4278190080	; 0xff000000
 10051e2:	f1b3 4f7f 	cmp.w	r3, #4278190080	; 0xff000000
 10051e6:	d10d      	bne.n	1005204 <z_arm_fault+0x40>
	if ((exc_return & EXC_RETURN_MODE_THREAD) &&
 10051e8:	f002 030c 	and.w	r3, r2, #12
 10051ec:	2b08      	cmp	r3, #8
 10051ee:	d10b      	bne.n	1005208 <z_arm_fault+0x44>
 10051f0:	494d      	ldr	r1, [pc, #308]	; (1005328 <z_arm_fault+0x164>)
 10051f2:	4b4e      	ldr	r3, [pc, #312]	; (100532c <z_arm_fault+0x168>)
		PR_EXC("SPSEL in thread mode does not indicate PSP");
 10051f4:	484e      	ldr	r0, [pc, #312]	; (1005330 <z_arm_fault+0x16c>)
 10051f6:	1ac9      	subs	r1, r1, r3
 10051f8:	08c9      	lsrs	r1, r1, #3
 10051fa:	0189      	lsls	r1, r1, #6
 10051fc:	f041 0101 	orr.w	r1, r1, #1
 1005200:	f010 f8c5 	bl	101538e <log_0>
		return NULL;
 1005204:	462f      	mov	r7, r5
 1005206:	e003      	b.n	1005210 <z_arm_fault+0x4c>
		if (exc_return & EXC_RETURN_MODE_THREAD) {
 1005208:	0712      	lsls	r2, r2, #28
 100520a:	d401      	bmi.n	1005210 <z_arm_fault+0x4c>
			ptr_esf = (z_arch_esf_t *)msp;
 100520c:	4607      	mov	r7, r0
			*nested_exc = true;
 100520e:	2501      	movs	r5, #1
	*recoverable = false;
 1005210:	2300      	movs	r3, #0
 1005212:	f88d 3007 	strb.w	r3, [sp, #7]
	switch (fault) {
 1005216:	1ee3      	subs	r3, r4, #3
 1005218:	2b09      	cmp	r3, #9
 100521a:	d86a      	bhi.n	10052f2 <z_arm_fault+0x12e>
 100521c:	e8df f003 	tbb	[pc, r3]
 1005220:	3c5c5805 	.word	0x3c5c5805
 1005224:	69696969 	.word	0x69696969
 1005228:	6069      	.short	0x6069
	*recoverable = false;
 100522a:	f04f 0800 	mov.w	r8, #0
 100522e:	4b3f      	ldr	r3, [pc, #252]	; (100532c <z_arm_fault+0x168>)
 1005230:	4e3d      	ldr	r6, [pc, #244]	; (1005328 <z_arm_fault+0x164>)
	PR_FAULT_INFO("***** HARD FAULT *****");
 1005232:	4840      	ldr	r0, [pc, #256]	; (1005334 <z_arm_fault+0x170>)
 1005234:	1af6      	subs	r6, r6, r3
 1005236:	08f6      	lsrs	r6, r6, #3
 1005238:	01b6      	lsls	r6, r6, #6
 100523a:	f046 0601 	orr.w	r6, r6, #1
 100523e:	4631      	mov	r1, r6
 1005240:	f010 f8a5 	bl	101538e <log_0>
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
 1005244:	4b37      	ldr	r3, [pc, #220]	; (1005324 <z_arm_fault+0x160>)
	*recoverable = false;
 1005246:	f88d 8007 	strb.w	r8, [sp, #7]
	if ((SCB->HFSR & SCB_HFSR_VECTTBL_Msk) != 0) {
 100524a:	6adc      	ldr	r4, [r3, #44]	; 0x2c
 100524c:	f014 0402 	ands.w	r4, r4, #2
 1005250:	d005      	beq.n	100525e <z_arm_fault+0x9a>
		PR_EXC("  Bus fault on vector table read");
 1005252:	4631      	mov	r1, r6
 1005254:	4838      	ldr	r0, [pc, #224]	; (1005338 <z_arm_fault+0x174>)
	PR_FAULT_INFO(
 1005256:	f010 f89a 	bl	101538e <log_0>
	u32_t reason = K_ERR_CPU_EXCEPTION;
 100525a:	2400      	movs	r4, #0
}
 100525c:	e01f      	b.n	100529e <z_arm_fault+0xda>
	} else if ((SCB->HFSR & SCB_HFSR_FORCED_Msk) != 0) {
 100525e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 1005260:	005b      	lsls	r3, r3, #1
 1005262:	d51c      	bpl.n	100529e <z_arm_fault+0xda>
		PR_EXC("  Fault escalation (see below)");
 1005264:	4631      	mov	r1, r6
 1005266:	4835      	ldr	r0, [pc, #212]	; (100533c <z_arm_fault+0x178>)
 1005268:	f010 f891 	bl	101538e <log_0>
		if (SCB_MMFSR != 0) {
 100526c:	4b34      	ldr	r3, [pc, #208]	; (1005340 <z_arm_fault+0x17c>)
 100526e:	781b      	ldrb	r3, [r3, #0]
 1005270:	b12b      	cbz	r3, 100527e <z_arm_fault+0xba>
			reason = mem_manage_fault(esf, 1, recoverable);
 1005272:	2001      	movs	r0, #1
 1005274:	f10d 0107 	add.w	r1, sp, #7
		reason = mem_manage_fault(esf, 0, recoverable);
 1005278:	f7ff fee6 	bl	1005048 <mem_manage_fault.isra.0>
 100527c:	e00e      	b.n	100529c <z_arm_fault+0xd8>
		} else if (SCB_BFSR != 0) {
 100527e:	4b31      	ldr	r3, [pc, #196]	; (1005344 <z_arm_fault+0x180>)
 1005280:	781b      	ldrb	r3, [r3, #0]
 1005282:	b12b      	cbz	r3, 1005290 <z_arm_fault+0xcc>
			reason = bus_fault(esf, 1, recoverable);
 1005284:	2001      	movs	r0, #1
 1005286:	f10d 0107 	add.w	r1, sp, #7
		reason = bus_fault(esf, 0, recoverable);
 100528a:	f7ff ff37 	bl	10050fc <bus_fault.isra.0>
 100528e:	e005      	b.n	100529c <z_arm_fault+0xd8>
		} else if (SCB_UFSR != 0) {
 1005290:	4b2d      	ldr	r3, [pc, #180]	; (1005348 <z_arm_fault+0x184>)
 1005292:	881b      	ldrh	r3, [r3, #0]
 1005294:	b29b      	uxth	r3, r3
 1005296:	b113      	cbz	r3, 100529e <z_arm_fault+0xda>
			reason = usage_fault(esf);
 1005298:	f7ff fe70 	bl	1004f7c <usage_fault.isra.0>
 100529c:	4604      	mov	r4, r0
	 esf = get_esf(msp, psp, exc_return, &nested_exc);
	__ASSERT(esf != NULL,
		"ESF could not be retrieved successfully. Shall never occur.");

	reason = fault_handle(esf, fault, &recoverable);
	if (recoverable) {
 100529e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 10052a2:	b993      	cbnz	r3, 10052ca <z_arm_fault+0x106>
		return;
	}

	/* Copy ESF */
	memcpy(&esf_copy, esf, sizeof(z_arch_esf_t));
 10052a4:	2220      	movs	r2, #32
 10052a6:	4639      	mov	r1, r7
 10052a8:	a802      	add	r0, sp, #8
 10052aa:	f011 fb05 	bl	10168b8 <memcpy>
	/* Overwrite stacked IPSR to mark a nested exception,
	 * or a return to Thread mode. Note that this may be
	 * required, if the retrieved ESF contents are invalid
	 * due to, for instance, a stacking error.
	 */
	if (nested_exc) {
 10052ae:	9b09      	ldr	r3, [sp, #36]	; 0x24
 10052b0:	b39d      	cbz	r5, 100531a <z_arm_fault+0x156>
		if ((esf_copy.basic.xpsr & IPSR_ISR_Msk) == 0) {
 10052b2:	f3c3 0208 	ubfx	r2, r3, #0, #9
 10052b6:	b922      	cbnz	r2, 10052c2 <z_arm_fault+0xfe>
			esf_copy.basic.xpsr |= IPSR_ISR_Msk;
 10052b8:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 10052bc:	ea6f 2343 	mvn.w	r3, r3, lsl #9
		}
	} else {
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
 10052c0:	9309      	str	r3, [sp, #36]	; 0x24
	}

	z_arm_fatal_error(reason, &esf_copy);
 10052c2:	4620      	mov	r0, r4
 10052c4:	a902      	add	r1, sp, #8
 10052c6:	f7ff fdc5 	bl	1004e54 <z_arm_fatal_error>
}
 10052ca:	b00a      	add	sp, #40	; 0x28
 10052cc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		reason = mem_manage_fault(esf, 0, recoverable);
 10052d0:	2000      	movs	r0, #0
 10052d2:	f10d 0107 	add.w	r1, sp, #7
 10052d6:	e7cf      	b.n	1005278 <z_arm_fault+0xb4>
		reason = bus_fault(esf, 0, recoverable);
 10052d8:	2000      	movs	r0, #0
 10052da:	f10d 0107 	add.w	r1, sp, #7
 10052de:	e7d4      	b.n	100528a <z_arm_fault+0xc6>
 10052e0:	4911      	ldr	r1, [pc, #68]	; (1005328 <z_arm_fault+0x164>)
 10052e2:	4b12      	ldr	r3, [pc, #72]	; (100532c <z_arm_fault+0x168>)
	PR_FAULT_INFO(
 10052e4:	4819      	ldr	r0, [pc, #100]	; (100534c <z_arm_fault+0x188>)
 10052e6:	1ac9      	subs	r1, r1, r3
 10052e8:	08c9      	lsrs	r1, r1, #3
 10052ea:	0189      	lsls	r1, r1, #6
 10052ec:	f041 0101 	orr.w	r1, r1, #1
 10052f0:	e7b1      	b.n	1005256 <z_arm_fault+0x92>
 10052f2:	4a0e      	ldr	r2, [pc, #56]	; (100532c <z_arm_fault+0x168>)
 10052f4:	4b0c      	ldr	r3, [pc, #48]	; (1005328 <z_arm_fault+0x164>)
	PR_FAULT_INFO("***** %s %d) *****",
 10052f6:	4816      	ldr	r0, [pc, #88]	; (1005350 <z_arm_fault+0x18c>)
 10052f8:	1a9b      	subs	r3, r3, r2
 10052fa:	08db      	lsrs	r3, r3, #3
 10052fc:	f416 7ff8 	tst.w	r6, #496	; 0x1f0
 1005300:	ea4f 1383 	mov.w	r3, r3, lsl #6
 1005304:	4913      	ldr	r1, [pc, #76]	; (1005354 <z_arm_fault+0x190>)
 1005306:	f043 0301 	orr.w	r3, r3, #1
 100530a:	bf18      	it	ne
 100530c:	4601      	movne	r1, r0
 100530e:	f1a4 0210 	sub.w	r2, r4, #16
 1005312:	4811      	ldr	r0, [pc, #68]	; (1005358 <z_arm_fault+0x194>)
 1005314:	f010 f85c 	bl	10153d0 <log_2>
 1005318:	e79f      	b.n	100525a <z_arm_fault+0x96>
		esf_copy.basic.xpsr &= ~(IPSR_ISR_Msk);
 100531a:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 100531e:	f023 0301 	bic.w	r3, r3, #1
 1005322:	e7cd      	b.n	10052c0 <z_arm_fault+0xfc>
 1005324:	e000ed00 	.word	0xe000ed00
 1005328:	010181c0 	.word	0x010181c0
 100532c:	010180b8 	.word	0x010180b8
 1005330:	01019576 	.word	0x01019576
 1005334:	010195a1 	.word	0x010195a1
 1005338:	010195b8 	.word	0x010195b8
 100533c:	010195d9 	.word	0x010195d9
 1005340:	e000ed28 	.word	0xe000ed28
 1005344:	e000ed29 	.word	0xe000ed29
 1005348:	e000ed2a 	.word	0xe000ed2a
 100534c:	010195f8 	.word	0x010195f8
 1005350:	01019643 	.word	0x01019643
 1005354:	0101962e 	.word	0x0101962e
 1005358:	0101965c 	.word	0x0101965c

0100535c <z_arm_fault_init>:
 */
void z_arm_fault_init(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	SCB->CCR |= SCB_CCR_DIV_0_TRP_Msk;
 100535c:	4a02      	ldr	r2, [pc, #8]	; (1005368 <z_arm_fault_init+0xc>)
 100535e:	6953      	ldr	r3, [r2, #20]
 1005360:	f043 0310 	orr.w	r3, r3, #16
 1005364:	6153      	str	r3, [r2, #20]
	 * Stack to attempt to descend into secure region, in which case a
	 * Secure Hard Fault will occur and we can track the fault from there.
	 */
	SCB->CCR |= SCB_CCR_STKOFHFNMIGN_Msk;
#endif /* CONFIG_BUILTIN_STACK_GUARD */
}
 1005366:	4770      	bx	lr
 1005368:	e000ed00 	.word	0xe000ed00

0100536c <z_arm_exc_exit>:
 */

SECTION_SUBSEC_FUNC(TEXT, _HandlerModeExit, z_arm_exc_exit)

#ifdef CONFIG_PREEMPT_ENABLED
	ldr r3, =_kernel
 100536c:	4b04      	ldr	r3, [pc, #16]	; (1005380 <_EXIT_EXC+0x2>)

	ldr r1, [r3, #_kernel_offset_to_current]
 100536e:	6899      	ldr	r1, [r3, #8]
	ldr r0, [r3, #_kernel_offset_to_ready_q_cache]
 1005370:	6a58      	ldr	r0, [r3, #36]	; 0x24
	cmp r0, r1
 1005372:	4288      	cmp	r0, r1
	beq _EXIT_EXC
 1005374:	d003      	beq.n	100537e <_EXIT_EXC>

	/* context switch required, pend the PendSV exception */
	ldr r1, =_SCS_ICSR
 1005376:	4903      	ldr	r1, [pc, #12]	; (1005384 <_EXIT_EXC+0x6>)
	ldr r2, =_SCS_ICSR_PENDSV
 1005378:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
	str r2, [r1]
 100537c:	600a      	str	r2, [r1, #0]

0100537e <_EXIT_EXC>:
#else
	pop {r0, lr}
#endif /* CONFIG_ARMV6_M_ARMV8_M_BASELINE */
#endif /* CONFIG_STACK_SENTINEL */

	bx lr
 100537e:	4770      	bx	lr
	ldr r3, =_kernel
 1005380:	210065b8 	.word	0x210065b8
	ldr r1, =_SCS_ICSR
 1005384:	e000ed04 	.word	0xe000ed04

01005388 <sys_arch_reboot>:
  __ASM volatile ("dsb 0xF":::"memory");
 1005388:	f3bf 8f4f 	dsb	sy
__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
{
  __DSB();                                                          /* Ensure all outstanding memory accesses included
                                                                       buffered write are completed before reset */
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
                           (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 100538c:	4905      	ldr	r1, [pc, #20]	; (10053a4 <sys_arch_reboot+0x1c>)
 100538e:	4b06      	ldr	r3, [pc, #24]	; (10053a8 <sys_arch_reboot+0x20>)
 1005390:	68ca      	ldr	r2, [r1, #12]
 1005392:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 1005396:	4313      	orrs	r3, r2
  SCB->AIRCR  = (uint32_t)((0x5FAUL << SCB_AIRCR_VECTKEY_Pos)    |
 1005398:	60cb      	str	r3, [r1, #12]
 100539a:	f3bf 8f4f 	dsb	sy
                            SCB_AIRCR_SYSRESETREQ_Msk    );         /* Keep priority group unchanged */
  __DSB();                                                          /* Ensure completion of memory access */

  for(;;)                                                           /* wait until reset */
  {
    __NOP();
 100539e:	bf00      	nop
  for(;;)                                                           /* wait until reset */
 10053a0:	e7fd      	b.n	100539e <sys_arch_reboot+0x16>
 10053a2:	bf00      	nop
 10053a4:	e000ed00 	.word	0xe000ed00
 10053a8:	05fa0004 	.word	0x05fa0004

010053ac <z_arm_interrupt_init>:
 * @return N/A
 */

void z_arm_interrupt_init(void)
{
	int irq = 0;
 10053ac:	2300      	movs	r3, #0
    NVIC->IPR[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 10053ae:	2120      	movs	r1, #32
 10053b0:	4803      	ldr	r0, [pc, #12]	; (10053c0 <z_arm_interrupt_init+0x14>)
 10053b2:	18c2      	adds	r2, r0, r3

	for (; irq < CONFIG_NUM_IRQS; irq++) {
 10053b4:	3301      	adds	r3, #1
 10053b6:	2b1e      	cmp	r3, #30
 10053b8:	f882 1300 	strb.w	r1, [r2, #768]	; 0x300
 10053bc:	d1f9      	bne.n	10053b2 <z_arm_interrupt_init+0x6>
		NVIC_SetPriority((IRQn_Type)irq, _IRQ_PRIO_OFFSET);
	}
}
 10053be:	4770      	bx	lr
 10053c0:	e000e100 	.word	0xe000e100

010053c4 <z_impl_k_thread_abort>:
#include <sys/__assert.h>

extern void z_thread_single_abort(struct k_thread *thread);

void z_impl_k_thread_abort(k_tid_t thread)
{
 10053c4:	b538      	push	{r3, r4, r5, lr}
 10053c6:	4604      	mov	r4, r0
	__asm__ volatile(
 10053c8:	f04f 0320 	mov.w	r3, #32
 10053cc:	f3ef 8511 	mrs	r5, BASEPRI
 10053d0:	f383 8811 	msr	BASEPRI, r3
 10053d4:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	__ASSERT(!(thread->base.user_options & K_ESSENTIAL),
		 "essential thread aborted");

	z_thread_single_abort(thread);
 10053d8:	f00e ffd8 	bl	101438c <z_thread_single_abort>
	z_thread_monitor_exit(thread);

	if (_current == thread) {
 10053dc:	4b0a      	ldr	r3, [pc, #40]	; (1005408 <z_impl_k_thread_abort+0x44>)
 10053de:	689b      	ldr	r3, [r3, #8]
 10053e0:	42a3      	cmp	r3, r4
 10053e2:	d10b      	bne.n	10053fc <z_impl_k_thread_abort+0x38>
		if ((SCB->ICSR & SCB_ICSR_VECTACTIVE_Msk) == 0) {
 10053e4:	4b09      	ldr	r3, [pc, #36]	; (100540c <z_impl_k_thread_abort+0x48>)
 10053e6:	685a      	ldr	r2, [r3, #4]
 10053e8:	f3c2 0208 	ubfx	r2, r2, #0, #9
 10053ec:	b912      	cbnz	r2, 10053f4 <z_impl_k_thread_abort+0x30>
	int ret;
	z_check_stack_sentinel();
#ifndef CONFIG_ARM
	sys_trace_thread_switched_out();
#endif
	ret = arch_swap(key);
 10053ee:	4628      	mov	r0, r5
 10053f0:	f7ff fc42 	bl	1004c78 <arch_swap>
			(void)z_swap_irqlock(key);
			CODE_UNREACHABLE;
		} else {
			SCB->ICSR |= SCB_ICSR_PENDSVSET_Msk;
 10053f4:	685a      	ldr	r2, [r3, #4]
 10053f6:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 10053fa:	605a      	str	r2, [r3, #4]
		}
	}

	/* The abort handler might have altered the ready queue. */
	z_reschedule_irqlock(key);
 10053fc:	4628      	mov	r0, r5
}
 10053fe:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule_irqlock(key);
 1005402:	f012 ba71 	b.w	10178e8 <z_reschedule_irqlock>
 1005406:	bf00      	nop
 1005408:	210065b8 	.word	0x210065b8
 100540c:	e000ed00 	.word	0xe000ed00

01005410 <z_arm_configure_static_mpu_regions>:
 *
 * For some MPU architectures, such as the unmodified ARMv8-M MPU,
 * the function must execute with MPU enabled.
 */
void z_arm_configure_static_mpu_regions(void)
{
 1005410:	b510      	push	{r4, lr}
		.size = (u32_t)&_nocache_ram_size,
		.attr = K_MEM_PARTITION_P_RW_U_NA_NOCACHE,
		};
#endif /* CONFIG_NOCACHE_MEMORY */
#if defined(CONFIG_ARCH_HAS_RAMFUNC_SUPPORT)
		const struct k_mem_partition ramfunc_region =
 1005412:	4b0e      	ldr	r3, [pc, #56]	; (100544c <z_arm_configure_static_mpu_regions+0x3c>)
{
 1005414:	b088      	sub	sp, #32
		const struct k_mem_partition ramfunc_region =
 1005416:	9302      	str	r3, [sp, #8]
 1005418:	4b0d      	ldr	r3, [pc, #52]	; (1005450 <z_arm_configure_static_mpu_regions+0x40>)
	/* Configure the static MPU regions within firmware SRAM boundaries.
	 * Start address of the image is given by _image_ram_start. The end
	 * of the firmware SRAM area is marked by __kernel_ram_end, taking
	 * into account the unused SRAM area, as well.
	 */
	arm_core_mpu_configure_static_mpu_regions(static_regions,
 100541a:	4c0e      	ldr	r4, [pc, #56]	; (1005454 <z_arm_configure_static_mpu_regions+0x44>)
		const struct k_mem_partition ramfunc_region =
 100541c:	9303      	str	r3, [sp, #12]
 100541e:	4b0e      	ldr	r3, [pc, #56]	; (1005458 <z_arm_configure_static_mpu_regions+0x48>)
	arm_core_mpu_configure_static_mpu_regions(static_regions,
 1005420:	4a0e      	ldr	r2, [pc, #56]	; (100545c <z_arm_configure_static_mpu_regions+0x4c>)
		const struct k_mem_partition ramfunc_region =
 1005422:	9304      	str	r3, [sp, #16]
	const struct k_mem_partition *static_regions[] = {
 1005424:	ab02      	add	r3, sp, #8
 1005426:	9301      	str	r3, [sp, #4]
	arm_core_mpu_configure_static_mpu_regions(static_regions,
 1005428:	a801      	add	r0, sp, #4
 100542a:	4623      	mov	r3, r4
 100542c:	2101      	movs	r1, #1
 100542e:	f000 f93d 	bl	10056ac <arm_core_mpu_configure_static_mpu_regions>
	/* Define a constant array of k_mem_partition objects that holds the
	 * boundaries of the areas, inside which dynamic region programming
	 * is allowed. The information is passed to the underlying driver at
	 * initialization.
	 */
	const struct k_mem_partition dyn_region_areas[] = {
 1005432:	2300      	movs	r3, #0
 1005434:	9307      	str	r3, [sp, #28]
		{
		.start = _MPU_DYNAMIC_REGIONS_AREA_START,
 1005436:	4b0a      	ldr	r3, [pc, #40]	; (1005460 <z_arm_configure_static_mpu_regions+0x50>)
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
		}
	};

	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
 1005438:	2101      	movs	r1, #1
		.size =  _MPU_DYNAMIC_REGIONS_AREA_SIZE,
 100543a:	1ae4      	subs	r4, r4, r3
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
 100543c:	a805      	add	r0, sp, #20
	const struct k_mem_partition dyn_region_areas[] = {
 100543e:	9305      	str	r3, [sp, #20]
 1005440:	9406      	str	r4, [sp, #24]
	arm_core_mpu_mark_areas_for_dynamic_regions(dyn_region_areas,
 1005442:	f000 f93d 	bl	10056c0 <arm_core_mpu_mark_areas_for_dynamic_regions>
		ARRAY_SIZE(dyn_region_areas));
#endif /* CONFIG_MPU_REQUIRES_NON_OVERLAPPING_REGIONS */
}
 1005446:	b008      	add	sp, #32
 1005448:	bd10      	pop	{r4, pc}
 100544a:	bf00      	nop
 100544c:	21000000 	.word	0x21000000
 1005450:	00000000 	.word	0x00000000
 1005454:	21010000 	.word	0x21010000
 1005458:	00010006 	.word	0x00010006
 100545c:	21000000 	.word	0x21000000
 1005460:	21000660 	.word	0x21000660

01005464 <region_init>:
 * Note:
 *   The caller must provide a valid region index.
 */
static void region_init(const u32_t index,
	const struct arm_mpu_region *region_conf)
{
 1005464:	b510      	push	{r4, lr}
	ARM_MPU_SetRegion(
		/* RNR */
		index,
		/* RBAR */
		(region_conf->base & MPU_RBAR_BASE_Msk)
 1005466:	680b      	ldr	r3, [r1, #0]
		| (region_conf->attr.rbar &
 1005468:	7a0c      	ldrb	r4, [r1, #8]
		(region_conf->base & MPU_RBAR_BASE_Msk)
 100546a:	f023 021f 	bic.w	r2, r3, #31
		| (region_conf->attr.rbar &
 100546e:	f004 031f 	and.w	r3, r4, #31
 1005472:	431a      	orrs	r2, r3
			(MPU_RBAR_XN_Msk | MPU_RBAR_AP_Msk | MPU_RBAR_SH_Msk)),
		/* RLAR */
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
 1005474:	68cb      	ldr	r3, [r1, #12]
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
 1005476:	0964      	lsrs	r4, r4, #5
		(region_conf->attr.r_limit & MPU_RLAR_LIMIT_Msk)
 1005478:	f023 031f 	bic.w	r3, r3, #31
* \param rbar Value for RBAR register.
* \param rlar Value for RLAR register.
*/   
__STATIC_INLINE void ARM_MPU_SetRegionEx(MPU_Type* mpu, uint32_t rnr, uint32_t rbar, uint32_t rlar)
{
  mpu->RNR = rnr;
 100547c:	4904      	ldr	r1, [pc, #16]	; (1005490 <region_init+0x2c>)
		| ((region_conf->attr.mair_idx << MPU_RLAR_AttrIndx_Pos)
 100547e:	ea43 0344 	orr.w	r3, r3, r4, lsl #1
			& MPU_RLAR_AttrIndx_Msk)
		| MPU_RLAR_EN_Msk
 1005482:	f043 0301 	orr.w	r3, r3, #1
 1005486:	6088      	str	r0, [r1, #8]
  mpu->RBAR = rbar;
 1005488:	60ca      	str	r2, [r1, #12]
  mpu->RLAR = rlar;
 100548a:	610b      	str	r3, [r1, #16]
	);

	LOG_DBG("[%d] 0x%08x 0x%08x 0x%08x 0x%08x",
			index, region_conf->base, region_conf->attr.rbar,
			region_conf->attr.mair_idx, region_conf->attr.r_limit);
}
 100548c:	bd10      	pop	{r4, pc}
 100548e:	bf00      	nop
 1005490:	e000ed90 	.word	0xe000ed90

01005494 <region_allocate_and_init.part.0>:
#include <arm_mpu_v8_internal.h>
#else
#error "Unsupported ARM CPU"
#endif

static int region_allocate_and_init(const u8_t index,
 1005494:	b508      	push	{r3, lr}
 1005496:	4a07      	ldr	r2, [pc, #28]	; (10054b4 <region_allocate_and_init.part.0+0x20>)
 1005498:	4b07      	ldr	r3, [pc, #28]	; (10054b8 <region_allocate_and_init.part.0+0x24>)
 100549a:	4601      	mov	r1, r0
 100549c:	1ad2      	subs	r2, r2, r3
 100549e:	08d2      	lsrs	r2, r2, #3
{
	/* Attempt to allocate new region index. */
	if (index > (get_num_regions() - 1)) {

		/* No available MPU region index. */
		LOG_ERR("Failed to allocate new MPU region %u\n", index);
 10054a0:	0192      	lsls	r2, r2, #6
 10054a2:	4806      	ldr	r0, [pc, #24]	; (10054bc <region_allocate_and_init.part.0+0x28>)
 10054a4:	f042 0201 	orr.w	r2, r2, #1
 10054a8:	f00f ff7e 	bl	10153a8 <log_1>

	/* Program region */
	region_init(index, region_conf);

	return index;
}
 10054ac:	f06f 0015 	mvn.w	r0, #21
 10054b0:	bd08      	pop	{r3, pc}
 10054b2:	bf00      	nop
 10054b4:	010181b0 	.word	0x010181b0
 10054b8:	010180b8 	.word	0x010180b8
 10054bc:	01019673 	.word	0x01019673

010054c0 <mpu_configure_regions_and_partition.constprop.0>:
 * sanity check of the memory regions to be programmed.
 *
 * The function performs a full partition of the background memory
 * area, effectively, leaving no space in this area uncovered by MPU.
 */
static int mpu_configure_regions_and_partition(const struct k_mem_partition
 10054c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10054c4:	4607      	mov	r7, r0
 10054c6:	4688      	mov	r8, r1
 10054c8:	4614      	mov	r4, r2
	bool do_sanity_check)
{
	int i;
	int reg_index = start_reg_index;

	for (i = 0; i < regions_num; i++) {
 10054ca:	2600      	movs	r6, #0
	MPU->RNR = index;
 10054cc:	4d56      	ldr	r5, [pc, #344]	; (1005628 <mpu_configure_regions_and_partition.constprop.0+0x168>)
static int mpu_configure_regions_and_partition(const struct k_mem_partition
 10054ce:	b085      	sub	sp, #20
	for (i = 0; i < regions_num; i++) {
 10054d0:	4546      	cmp	r6, r8
 10054d2:	da35      	bge.n	1005540 <mpu_configure_regions_and_partition.constprop.0+0x80>
		if (regions[i]->size == 0U) {
 10054d4:	f857 3026 	ldr.w	r3, [r7, r6, lsl #2]
 10054d8:	f8d3 9004 	ldr.w	r9, [r3, #4]
 10054dc:	f1b9 0f00 	cmp.w	r9, #0
 10054e0:	d051      	beq.n	1005586 <mpu_configure_regions_and_partition.constprop.0+0xc6>
		&&
 10054e2:	f1b9 0f1f 	cmp.w	r9, #31
 10054e6:	d91e      	bls.n	1005526 <mpu_configure_regions_and_partition.constprop.0+0x66>
		&&
 10054e8:	f019 0f1f 	tst.w	r9, #31
 10054ec:	d11b      	bne.n	1005526 <mpu_configure_regions_and_partition.constprop.0+0x66>
		((part->start &
 10054ee:	f8d3 a000 	ldr.w	sl, [r3]
		&&
 10054f2:	f01a 0f1f 	tst.w	sl, #31
 10054f6:	d116      	bne.n	1005526 <mpu_configure_regions_and_partition.constprop.0+0x66>
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
 10054f8:	4650      	mov	r0, sl
 10054fa:	f011 f98f 	bl	101681c <arm_cmse_mpu_region_get>
 10054fe:	4683      	mov	fp, r0
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
 1005500:	eb09 000a 	add.w	r0, r9, sl
 1005504:	3801      	subs	r0, #1
 1005506:	f011 f989 	bl	101681c <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
 100550a:	4583      	cmp	fp, r0
 100550c:	d01c      	beq.n	1005548 <mpu_configure_regions_and_partition.constprop.0+0x88>
	return -EINVAL;
 100550e:	f06f 0b15 	mvn.w	fp, #21
 1005512:	4a46      	ldr	r2, [pc, #280]	; (100562c <mpu_configure_regions_and_partition.constprop.0+0x16c>)
 1005514:	4b46      	ldr	r3, [pc, #280]	; (1005630 <mpu_configure_regions_and_partition.constprop.0+0x170>)
		int u_reg_index =
			get_region_index(regions[i]->start, regions[i]->size);

		if ((u_reg_index == -EINVAL) ||
			(u_reg_index > (reg_index - 1))) {
			LOG_ERR("Invalid underlying region index %u",
 1005516:	4659      	mov	r1, fp
 1005518:	1ad2      	subs	r2, r2, r3
 100551a:	08d2      	lsrs	r2, r2, #3
 100551c:	0192      	lsls	r2, r2, #6
 100551e:	4845      	ldr	r0, [pc, #276]	; (1005634 <mpu_configure_regions_and_partition.constprop.0+0x174>)
 1005520:	f042 0201 	orr.w	r2, r2, #1
 1005524:	e008      	b.n	1005538 <mpu_configure_regions_and_partition.constprop.0+0x78>
			LOG_ERR("Partition %u: sanity check failed.", i);
 1005526:	4631      	mov	r1, r6
 1005528:	4a40      	ldr	r2, [pc, #256]	; (100562c <mpu_configure_regions_and_partition.constprop.0+0x16c>)
 100552a:	4b41      	ldr	r3, [pc, #260]	; (1005630 <mpu_configure_regions_and_partition.constprop.0+0x170>)
 100552c:	4842      	ldr	r0, [pc, #264]	; (1005638 <mpu_configure_regions_and_partition.constprop.0+0x178>)
 100552e:	1ad2      	subs	r2, r2, r3
 1005530:	08d2      	lsrs	r2, r2, #3
 1005532:	0192      	lsls	r2, r2, #6
 1005534:	f042 0201 	orr.w	r2, r2, #1
			LOG_ERR("Invalid underlying region index %u",
 1005538:	f00f ff36 	bl	10153a8 <log_1>

			reg_index =
				mpu_configure_region(reg_index, regions[i]);

			if (reg_index == -EINVAL) {
				return reg_index;
 100553c:	f06f 0415 	mvn.w	r4, #21
			reg_index++;
		}
	}

	return reg_index;
}
 1005540:	4620      	mov	r0, r4
 1005542:	b005      	add	sp, #20
 1005544:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((u_reg_index == -EINVAL) ||
 1005548:	f11b 0f16 	cmn.w	fp, #22
 100554c:	d0e1      	beq.n	1005512 <mpu_configure_regions_and_partition.constprop.0+0x52>
			(u_reg_index > (reg_index - 1))) {
 100554e:	1e63      	subs	r3, r4, #1
		if ((u_reg_index == -EINVAL) ||
 1005550:	455b      	cmp	r3, fp
 1005552:	dbde      	blt.n	1005512 <mpu_configure_regions_and_partition.constprop.0+0x52>
	MPU->RNR = index;
 1005554:	f8c5 b008 	str.w	fp, [r5, #8]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
 1005558:	68e8      	ldr	r0, [r5, #12]
	MPU->RNR = index;
 100555a:	f8c5 b008 	str.w	fp, [r5, #8]
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
 100555e:	692b      	ldr	r3, [r5, #16]
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
 1005560:	f857 1026 	ldr.w	r1, [r7, r6, lsl #2]
	return MPU->RBAR & MPU_RBAR_BASE_Msk;
 1005564:	f020 001f 	bic.w	r0, r0, #31
	return (MPU->RLAR & MPU_RLAR_LIMIT_Msk) | (~MPU_RLAR_LIMIT_Msk);
 1005568:	f043 0a1f 	orr.w	sl, r3, #31
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
 100556c:	e9d1 3200 	ldrd	r3, r2, [r1]
 1005570:	441a      	add	r2, r3
		if ((regions[i]->start == u_reg_base) &&
 1005572:	4298      	cmp	r0, r3
		u32_t reg_last = regions[i]->start + regions[i]->size - 1;
 1005574:	f102 39ff 	add.w	r9, r2, #4294967295
		if ((regions[i]->start == u_reg_base) &&
 1005578:	d118      	bne.n	10055ac <mpu_configure_regions_and_partition.constprop.0+0xec>
 100557a:	45ca      	cmp	sl, r9
 100557c:	d105      	bne.n	100558a <mpu_configure_regions_and_partition.constprop.0+0xca>
			mpu_configure_region(u_reg_index, regions[i]);
 100557e:	fa5f f08b 	uxtb.w	r0, fp
 1005582:	f011 f92a 	bl	10167da <mpu_configure_region>
	for (i = 0; i < regions_num; i++) {
 1005586:	3601      	adds	r6, #1
 1005588:	e7a2      	b.n	10054d0 <mpu_configure_regions_and_partition.constprop.0+0x10>
	MPU->RNR = index;
 100558a:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
 100558e:	68eb      	ldr	r3, [r5, #12]
		| (base & MPU_RBAR_BASE_Msk);
 1005590:	f022 021f 	bic.w	r2, r2, #31
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
 1005594:	f003 031f 	and.w	r3, r3, #31
		| (base & MPU_RBAR_BASE_Msk);
 1005598:	431a      	orrs	r2, r3
	MPU->RBAR = (MPU->RBAR & (~MPU_RBAR_BASE_Msk))
 100559a:	60ea      	str	r2, [r5, #12]
				mpu_configure_region(reg_index, regions[i]);
 100559c:	b2e0      	uxtb	r0, r4
				mpu_configure_region(reg_index, regions[i]);
 100559e:	f011 f91c 	bl	10167da <mpu_configure_region>
			if (reg_index == -EINVAL) {
 10055a2:	f110 0f16 	cmn.w	r0, #22
 10055a6:	d0c9      	beq.n	100553c <mpu_configure_regions_and_partition.constprop.0+0x7c>
			reg_index++;
 10055a8:	1c44      	adds	r4, r0, #1
 10055aa:	e7ec      	b.n	1005586 <mpu_configure_regions_and_partition.constprop.0+0xc6>
	MPU->RNR = index;
 10055ac:	f8c5 b008 	str.w	fp, [r5, #8]
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
 10055b0:	692a      	ldr	r2, [r5, #16]
 10055b2:	3b01      	subs	r3, #1
 10055b4:	f023 031f 	bic.w	r3, r3, #31
 10055b8:	f002 021f 	and.w	r2, r2, #31
		| (limit & MPU_RLAR_LIMIT_Msk);
 10055bc:	4313      	orrs	r3, r2
		} else if (reg_last == u_reg_last) {
 10055be:	45ca      	cmp	sl, r9
 10055c0:	b2e0      	uxtb	r0, r4
	MPU->RLAR = (MPU->RLAR & (~MPU_RLAR_LIMIT_Msk))
 10055c2:	612b      	str	r3, [r5, #16]
		} else if (reg_last == u_reg_last) {
 10055c4:	d0eb      	beq.n	100559e <mpu_configure_regions_and_partition.constprop.0+0xde>
				mpu_configure_region(reg_index, regions[i]);
 10055c6:	f011 f908 	bl	10167da <mpu_configure_region>
			if (reg_index == -EINVAL) {
 10055ca:	f110 0f16 	cmn.w	r0, #22
 10055ce:	d0b5      	beq.n	100553c <mpu_configure_regions_and_partition.constprop.0+0x7c>
	MPU->RNR = index;
 10055d0:	f8c5 b008 	str.w	fp, [r5, #8]
	attr->rbar = MPU->RBAR &
 10055d4:	68ea      	ldr	r2, [r5, #12]
 10055d6:	f89d 3008 	ldrb.w	r3, [sp, #8]
			REGION_LIMIT_ADDR((regions[i]->start +
 10055da:	f10a 3aff 	add.w	sl, sl, #4294967295
	attr->rbar = MPU->RBAR &
 10055de:	f362 0304 	bfi	r3, r2, #0, #5
 10055e2:	f88d 3008 	strb.w	r3, [sp, #8]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
 10055e6:	692b      	ldr	r3, [r5, #16]
 10055e8:	f89d 2008 	ldrb.w	r2, [sp, #8]
 10055ec:	085b      	lsrs	r3, r3, #1
 10055ee:	f363 1247 	bfi	r2, r3, #5, #3
			fill_region.base = regions[i]->start +
 10055f2:	f857 3026 	ldr.w	r3, [r7, r6, lsl #2]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
 10055f6:	f88d 2008 	strb.w	r2, [sp, #8]
			fill_region.base = regions[i]->start +
 10055fa:	e9d3 1300 	ldrd	r1, r3, [r3]
 10055fe:	440b      	add	r3, r1
 1005600:	9300      	str	r3, [sp, #0]
			REGION_LIMIT_ADDR((regions[i]->start +
 1005602:	f023 031f 	bic.w	r3, r3, #31
			reg_index++;
 1005606:	1c44      	adds	r4, r0, #1
			REGION_LIMIT_ADDR((regions[i]->start +
 1005608:	4453      	add	r3, sl
 100560a:	eba3 0309 	sub.w	r3, r3, r9
				region_allocate_and_init(reg_index,
 100560e:	b2e0      	uxtb	r0, r4
			REGION_LIMIT_ADDR((regions[i]->start +
 1005610:	f023 031f 	bic.w	r3, r3, #31
	if (index > (get_num_regions() - 1)) {
 1005614:	280f      	cmp	r0, #15
			fill_region.attr.r_limit =
 1005616:	9303      	str	r3, [sp, #12]
 1005618:	d902      	bls.n	1005620 <mpu_configure_regions_and_partition.constprop.0+0x160>
 100561a:	f7ff ff3b 	bl	1005494 <region_allocate_and_init.part.0>
 100561e:	e7c0      	b.n	10055a2 <mpu_configure_regions_and_partition.constprop.0+0xe2>
	region_init(index, region_conf);
 1005620:	4669      	mov	r1, sp
 1005622:	f7ff ff1f 	bl	1005464 <region_init>
			if (reg_index == -EINVAL) {
 1005626:	e7bf      	b.n	10055a8 <mpu_configure_regions_and_partition.constprop.0+0xe8>
 1005628:	e000ed90 	.word	0xe000ed90
 100562c:	010181b0 	.word	0x010181b0
 1005630:	010180b8 	.word	0x010180b8
 1005634:	010196bc 	.word	0x010196bc
 1005638:	01019699 	.word	0x01019699

0100563c <arm_core_mpu_enable>:
void arm_core_mpu_enable(void)
{
	/* Enable MPU and use the default memory map as a
	 * background region for privileged software access.
	 */
	MPU->CTRL = MPU_CTRL_ENABLE_Msk | MPU_CTRL_PRIVDEFENA_Msk;
 100563c:	2205      	movs	r2, #5
 100563e:	4b03      	ldr	r3, [pc, #12]	; (100564c <arm_core_mpu_enable+0x10>)
 1005640:	605a      	str	r2, [r3, #4]
 1005642:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 1005646:	f3bf 8f6f 	isb	sy

	/* Make sure that all the registers are set before proceeding */
	__DSB();
	__ISB();
}
 100564a:	4770      	bx	lr
 100564c:	e000ed90 	.word	0xe000ed90

01005650 <arm_core_mpu_disable>:
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
 1005650:	f3bf 8f5f 	dmb	sy
{
	/* Force any outstanding transfers to complete before disabling MPU */
	__DMB();

	/* Disable MPU */
	MPU->CTRL = 0;
 1005654:	2200      	movs	r2, #0
 1005656:	4b01      	ldr	r3, [pc, #4]	; (100565c <arm_core_mpu_disable+0xc>)
 1005658:	605a      	str	r2, [r3, #4]
}
 100565a:	4770      	bx	lr
 100565c:	e000ed90 	.word	0xe000ed90

01005660 <arm_mpu_init>:
 *
 * This function provides the default configuration mechanism for the Memory
 * Protection Unit (MPU).
 */
static int arm_mpu_init(struct device *arg)
{
 1005660:	b538      	push	{r3, r4, r5, lr}
	u32_t r_index;

	if (mpu_config.num_regions > get_num_regions()) {
 1005662:	4c0e      	ldr	r4, [pc, #56]	; (100569c <arm_mpu_init+0x3c>)
 1005664:	6825      	ldr	r5, [r4, #0]
 1005666:	2d10      	cmp	r5, #16
 1005668:	d814      	bhi.n	1005694 <arm_mpu_init+0x34>
		return -1;
	}

	LOG_DBG("total region count: %d", get_num_regions());

	arm_core_mpu_disable();
 100566a:	f7ff fff1 	bl	1005650 <arm_core_mpu_disable>

	/* Architecture-specific configuration */
	mpu_init();

	/* Program fixed regions configured at SOC definition. */
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
 100566e:	2000      	movs	r0, #0
	MPU->MAIR0 =
 1005670:	4b0b      	ldr	r3, [pc, #44]	; (10056a0 <arm_mpu_init+0x40>)
 1005672:	4a0c      	ldr	r2, [pc, #48]	; (10056a4 <arm_mpu_init+0x44>)
 1005674:	631a      	str	r2, [r3, #48]	; 0x30
 1005676:	4285      	cmp	r5, r0
 1005678:	d105      	bne.n	1005686 <arm_mpu_init+0x26>
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
	}

	/* Update the number of programmed MPU regions. */
	static_regions_num = mpu_config.num_regions;
 100567a:	4b0b      	ldr	r3, [pc, #44]	; (10056a8 <arm_mpu_init+0x48>)
 100567c:	701d      	strb	r5, [r3, #0]


	arm_core_mpu_enable();
 100567e:	f7ff ffdd 	bl	100563c <arm_core_mpu_enable>
	__ASSERT(
		(MPU->TYPE & MPU_TYPE_DREGION_Msk) >> MPU_TYPE_DREGION_Pos ==
		NUM_MPU_REGIONS,
		"Invalid number of MPU regions\n");
#endif /* CORTEX_M0PLUS || CPU_CORTEX_M3 || CPU_CORTEX_M4 */
	return 0;
 1005682:	2000      	movs	r0, #0
}
 1005684:	bd38      	pop	{r3, r4, r5, pc}
		region_init(r_index, &mpu_config.mpu_regions[r_index]);
 1005686:	6861      	ldr	r1, [r4, #4]
 1005688:	eb01 1100 	add.w	r1, r1, r0, lsl #4
 100568c:	f7ff feea 	bl	1005464 <region_init>
	for (r_index = 0U; r_index < mpu_config.num_regions; r_index++) {
 1005690:	3001      	adds	r0, #1
 1005692:	e7f0      	b.n	1005676 <arm_mpu_init+0x16>
		return -1;
 1005694:	f04f 30ff 	mov.w	r0, #4294967295
 1005698:	e7f4      	b.n	1005684 <arm_mpu_init+0x24>
 100569a:	bf00      	nop
 100569c:	01018350 	.word	0x01018350
 10056a0:	e000ed90 	.word	0xe000ed90
 10056a4:	0044ffaa 	.word	0x0044ffaa
 10056a8:	2100668f 	.word	0x2100668f

010056ac <arm_core_mpu_configure_static_mpu_regions>:
{
 10056ac:	b510      	push	{r4, lr}
static int mpu_configure_static_mpu_regions(const struct k_mem_partition
	*static_regions[], const u8_t regions_num,
	const u32_t background_area_base,
	const u32_t background_area_end)
{
	int mpu_reg_index = static_regions_num;
 10056ae:	4c03      	ldr	r4, [pc, #12]	; (10056bc <arm_core_mpu_configure_static_mpu_regions+0x10>)
	 * given boundaries.
	 */
	ARG_UNUSED(background_area_base);
	ARG_UNUSED(background_area_end);

	mpu_reg_index = mpu_configure_regions_and_partition(static_regions,
 10056b0:	7822      	ldrb	r2, [r4, #0]
 10056b2:	f7ff ff05 	bl	10054c0 <mpu_configure_regions_and_partition.constprop.0>
		regions_num, mpu_reg_index, true);

	static_regions_num = mpu_reg_index;
 10056b6:	7020      	strb	r0, [r4, #0]
}
 10056b8:	bd10      	pop	{r4, pc}
 10056ba:	bf00      	nop
 10056bc:	2100668f 	.word	0x2100668f

010056c0 <arm_core_mpu_mark_areas_for_dynamic_regions>:
{
 10056c0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10056c4:	4d26      	ldr	r5, [pc, #152]	; (1005760 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa0>)
 10056c6:	468a      	mov	sl, r1
{
	/* In ARMv8-M architecture we need to store the index values
	 * and the default configuration of the MPU regions, inside
	 * which dynamic memory regions may be programmed at run-time.
	 */
	for (int i = 0; i < dyn_region_areas_num; i++) {
 10056c8:	4606      	mov	r6, r0
 10056ca:	f04f 0800 	mov.w	r8, #0
 10056ce:	46ab      	mov	fp, r5
	MPU->RNR = index;
 10056d0:	4f24      	ldr	r7, [pc, #144]	; (1005764 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa4>)
	for (int i = 0; i < dyn_region_areas_num; i++) {
 10056d2:	45d0      	cmp	r8, sl
 10056d4:	da1b      	bge.n	100570e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
		if (dyn_region_areas[i].size == 0U) {
 10056d6:	f8d6 9004 	ldr.w	r9, [r6, #4]
 10056da:	f1b9 0f00 	cmp.w	r9, #0
 10056de:	d039      	beq.n	1005754 <arm_core_mpu_mark_areas_for_dynamic_regions+0x94>
		}
		/* Non-empty area */

		/* Retrieve HW MPU region index */
		dyn_reg_info[i].index =
			get_region_index(dyn_region_areas[i].start,
 10056e0:	6831      	ldr	r1, [r6, #0]
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
 10056e2:	4608      	mov	r0, r1
 10056e4:	9101      	str	r1, [sp, #4]
 10056e6:	f011 f899 	bl	101681c <arm_cmse_mpu_region_get>
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
 10056ea:	9901      	ldr	r1, [sp, #4]
	u32_t region_start_addr = arm_cmse_mpu_region_get(start);
 10056ec:	4604      	mov	r4, r0
	u32_t region_end_addr = arm_cmse_mpu_region_get(start + size - 1);
 10056ee:	eb09 0001 	add.w	r0, r9, r1
 10056f2:	3801      	subs	r0, #1
 10056f4:	f011 f892 	bl	101681c <arm_cmse_mpu_region_get>
	if (region_start_addr == region_end_addr) {
 10056f8:	4284      	cmp	r4, r0
 10056fa:	f04f 0214 	mov.w	r2, #20
 10056fe:	4b1a      	ldr	r3, [pc, #104]	; (1005768 <arm_core_mpu_mark_areas_for_dynamic_regions+0xa8>)
 1005700:	d008      	beq.n	1005714 <arm_core_mpu_mark_areas_for_dynamic_regions+0x54>
		dyn_reg_info[i].index =
 1005702:	f06f 0315 	mvn.w	r3, #21
 1005706:	fb02 f808 	mul.w	r8, r2, r8
 100570a:	f84b 3008 	str.w	r3, [fp, r8]
}
 100570e:	b003      	add	sp, #12
 1005710:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
					dyn_region_areas[i].size);

		if (dyn_reg_info[i].index == -EINVAL) {
 1005714:	f114 0f16 	cmn.w	r4, #22
		dyn_reg_info[i].index =
 1005718:	602c      	str	r4, [r5, #0]
		if (dyn_reg_info[i].index == -EINVAL) {
 100571a:	d0f8      	beq.n	100570e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>

			return -EINVAL;
		}

		if (dyn_reg_info[i].index >= static_regions_num) {
 100571c:	7819      	ldrb	r1, [r3, #0]
 100571e:	42a1      	cmp	r1, r4
 1005720:	ddf5      	ble.n	100570e <arm_core_mpu_mark_areas_for_dynamic_regions+0x4e>
	attr->rbar = MPU->RBAR &
 1005722:	fb02 b008 	mla	r0, r2, r8, fp
	MPU->RNR = index;
 1005726:	60bc      	str	r4, [r7, #8]
	MPU->RNR = index;
 1005728:	60bc      	str	r4, [r7, #8]
	attr->rbar = MPU->RBAR &
 100572a:	68fc      	ldr	r4, [r7, #12]
 100572c:	f100 0108 	add.w	r1, r0, #8
 1005730:	7b00      	ldrb	r0, [r0, #12]
 1005732:	f364 0004 	bfi	r0, r4, #0, #5
 1005736:	7108      	strb	r0, [r1, #4]
	attr->mair_idx = (MPU->RLAR & MPU_RLAR_AttrIndx_Msk) >>
 1005738:	6938      	ldr	r0, [r7, #16]
 100573a:	790c      	ldrb	r4, [r1, #4]
 100573c:	0840      	lsrs	r0, r0, #1
 100573e:	f360 1447 	bfi	r4, r0, #5, #3
 1005742:	710c      	strb	r4, [r1, #4]
	region_conf->base = (MPU->RBAR & MPU_RBAR_BASE_Msk);
 1005744:	68f9      	ldr	r1, [r7, #12]
 1005746:	f021 011f 	bic.w	r1, r1, #31
 100574a:	6069      	str	r1, [r5, #4]
	region_conf->attr.r_limit = MPU->RLAR & MPU_RLAR_LIMIT_Msk;
 100574c:	6939      	ldr	r1, [r7, #16]
 100574e:	f021 011f 	bic.w	r1, r1, #31
 1005752:	6129      	str	r1, [r5, #16]
	for (int i = 0; i < dyn_region_areas_num; i++) {
 1005754:	f108 0801 	add.w	r8, r8, #1
 1005758:	3514      	adds	r5, #20
 100575a:	360c      	adds	r6, #12
 100575c:	e7b9      	b.n	10056d2 <arm_core_mpu_mark_areas_for_dynamic_regions+0x12>
 100575e:	bf00      	nop
 1005760:	2100096c 	.word	0x2100096c
 1005764:	e000ed90 	.word	0xe000ed90
 1005768:	2100668f 	.word	0x2100668f

0100576c <__stdout_hook_install>:

static int (*_stdout_hook)(int) = _stdout_hook_default;

void __stdout_hook_install(int (*hook)(int))
{
	_stdout_hook = hook;
 100576c:	4b01      	ldr	r3, [pc, #4]	; (1005774 <__stdout_hook_install+0x8>)
 100576e:	6018      	str	r0, [r3, #0]
}
 1005770:	4770      	bx	lr
 1005772:	bf00      	nop
 1005774:	21000074 	.word	0x21000074

01005778 <bt_hci_driver_register>:
struct bt_hci_raw_cmd_ext *cmd_ext;
static size_t cmd_ext_size;

int bt_hci_driver_register(const struct bt_hci_driver *drv)
{
	if (bt_dev.drv) {
 1005778:	4a07      	ldr	r2, [pc, #28]	; (1005798 <bt_hci_driver_register+0x20>)
{
 100577a:	4603      	mov	r3, r0
	if (bt_dev.drv) {
 100577c:	6810      	ldr	r0, [r2, #0]
 100577e:	b928      	cbnz	r0, 100578c <bt_hci_driver_register+0x14>
		return -EALREADY;
	}

	if (!drv->open || !drv->send) {
 1005780:	68d9      	ldr	r1, [r3, #12]
 1005782:	b131      	cbz	r1, 1005792 <bt_hci_driver_register+0x1a>
 1005784:	6919      	ldr	r1, [r3, #16]
 1005786:	b121      	cbz	r1, 1005792 <bt_hci_driver_register+0x1a>
		return -EINVAL;
	}

	bt_dev.drv = drv;
 1005788:	6013      	str	r3, [r2, #0]
	BT_DBG("Registered %s", drv->name ? drv->name : "");

	bt_monitor_new_index(BT_MONITOR_TYPE_PRIMARY, drv->bus,
			     BT_ADDR_ANY, drv->name ? drv->name : "bt0");

	return 0;
 100578a:	4770      	bx	lr
		return -EALREADY;
 100578c:	f06f 0044 	mvn.w	r0, #68	; 0x44
 1005790:	4770      	bx	lr
		return -EINVAL;
 1005792:	f06f 0015 	mvn.w	r0, #21
}
 1005796:	4770      	bx	lr
 1005798:	21000980 	.word	0x21000980

0100579c <bt_buf_get_rx>:

struct net_buf *bt_buf_get_rx(enum bt_buf_type type, k_timeout_t timeout)
{
 100579c:	b570      	push	{r4, r5, r6, lr}
	struct net_buf *buf;

	switch (type) {
 100579e:	f000 06fd 	and.w	r6, r0, #253	; 0xfd
 10057a2:	2e01      	cmp	r6, #1
{
 10057a4:	4605      	mov	r5, r0
	switch (type) {
 10057a6:	d00d      	beq.n	10057c4 <bt_buf_get_rx+0x28>
 10057a8:	4b0c      	ldr	r3, [pc, #48]	; (10057dc <bt_buf_get_rx+0x40>)
 10057aa:	4a0d      	ldr	r2, [pc, #52]	; (10057e0 <bt_buf_get_rx+0x44>)
	case BT_BUF_EVT:
	case BT_BUF_ACL_IN:
		break;
	default:
		BT_ERR("Invalid type: %u", type);
 10057ac:	4601      	mov	r1, r0
 10057ae:	1ad2      	subs	r2, r2, r3
 10057b0:	08d2      	lsrs	r2, r2, #3
 10057b2:	0192      	lsls	r2, r2, #6
 10057b4:	480b      	ldr	r0, [pc, #44]	; (10057e4 <bt_buf_get_rx+0x48>)
 10057b6:	f042 0201 	orr.w	r2, r2, #1
 10057ba:	f00f fdf5 	bl	10153a8 <log_1>
		return NULL;
 10057be:	2400      	movs	r4, #0

	net_buf_reserve(buf, BT_BUF_RESERVE);
	bt_buf_set_type(buf, type);

	return buf;
}
 10057c0:	4620      	mov	r0, r4
 10057c2:	bd70      	pop	{r4, r5, r6, pc}
	buf = net_buf_alloc(&hci_rx_pool, timeout);
 10057c4:	4808      	ldr	r0, [pc, #32]	; (10057e8 <bt_buf_get_rx+0x4c>)
 10057c6:	f011 f94c 	bl	1016a62 <net_buf_alloc_fixed>
	if (!buf) {
 10057ca:	4604      	mov	r4, r0
 10057cc:	2800      	cmp	r0, #0
 10057ce:	d0f7      	beq.n	10057c0 <bt_buf_get_rx+0x24>
	net_buf_reserve(buf, BT_BUF_RESERVE);
 10057d0:	4631      	mov	r1, r6
 10057d2:	3008      	adds	r0, #8
 10057d4:	f011 f964 	bl	1016aa0 <net_buf_simple_reserve>
	*(u8_t *)net_buf_user_data(buf) = type;
 10057d8:	7525      	strb	r5, [r4, #20]
	return buf;
 10057da:	e7f1      	b.n	10057c0 <bt_buf_get_rx+0x24>
 10057dc:	010180b8 	.word	0x010180b8
 10057e0:	01018178 	.word	0x01018178
 10057e4:	010196f5 	.word	0x010196f5
 10057e8:	21000634 	.word	0x21000634

010057ec <bt_buf_get_tx>:

struct net_buf *bt_buf_get_tx(enum bt_buf_type type, k_timeout_t timeout,
			      const void *data, size_t size)
{
 10057ec:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct net_buf_pool *pool;
	struct net_buf *buf;

	switch (type) {
 10057f0:	4605      	mov	r5, r0
{
 10057f2:	e9dd 7806 	ldrd	r7, r8, [sp, #24]
	switch (type) {
 10057f6:	b180      	cbz	r0, 100581a <bt_buf_get_tx+0x2e>
 10057f8:	2802      	cmp	r0, #2
 10057fa:	d026      	beq.n	100584a <bt_buf_get_tx+0x5e>
 10057fc:	4b14      	ldr	r3, [pc, #80]	; (1005850 <bt_buf_get_tx+0x64>)
 10057fe:	4a15      	ldr	r2, [pc, #84]	; (1005854 <bt_buf_get_tx+0x68>)
			size--;
			break;
		}
	/* Fallthrough */
	default:
		BT_ERR("Invalid type: %u", type);
 1005800:	4601      	mov	r1, r0
 1005802:	1ad2      	subs	r2, r2, r3
 1005804:	08d2      	lsrs	r2, r2, #3
 1005806:	0192      	lsls	r2, r2, #6
 1005808:	4813      	ldr	r0, [pc, #76]	; (1005858 <bt_buf_get_tx+0x6c>)
 100580a:	f042 0201 	orr.w	r2, r2, #1
 100580e:	f00f fdcb 	bl	10153a8 <log_1>
		return NULL;
 1005812:	2400      	movs	r4, #0
	if (data && size) {
		net_buf_add_mem(buf, data, size);
	}

	return buf;
}
 1005814:	4620      	mov	r0, r4
 1005816:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (type) {
 100581a:	4810      	ldr	r0, [pc, #64]	; (100585c <bt_buf_get_tx+0x70>)
	buf = net_buf_alloc(pool, timeout);
 100581c:	f011 f921 	bl	1016a62 <net_buf_alloc_fixed>
	if (!buf) {
 1005820:	4604      	mov	r4, r0
 1005822:	2800      	cmp	r0, #0
 1005824:	d0f6      	beq.n	1005814 <bt_buf_get_tx+0x28>
	net_buf_reserve(buf, BT_BUF_RESERVE);
 1005826:	f100 0608 	add.w	r6, r0, #8
 100582a:	2101      	movs	r1, #1
 100582c:	4630      	mov	r0, r6
 100582e:	f011 f937 	bl	1016aa0 <net_buf_simple_reserve>
 1005832:	7525      	strb	r5, [r4, #20]
	if (data && size) {
 1005834:	2f00      	cmp	r7, #0
 1005836:	d0ed      	beq.n	1005814 <bt_buf_get_tx+0x28>
 1005838:	f1b8 0f00 	cmp.w	r8, #0
 100583c:	d0ea      	beq.n	1005814 <bt_buf_get_tx+0x28>
		net_buf_add_mem(buf, data, size);
 100583e:	4642      	mov	r2, r8
 1005840:	4639      	mov	r1, r7
 1005842:	4630      	mov	r0, r6
 1005844:	f011 f943 	bl	1016ace <net_buf_simple_add_mem>
 1005848:	e7e4      	b.n	1005814 <bt_buf_get_tx+0x28>
		pool = &hci_acl_pool;
 100584a:	4805      	ldr	r0, [pc, #20]	; (1005860 <bt_buf_get_tx+0x74>)
 100584c:	e7e6      	b.n	100581c <bt_buf_get_tx+0x30>
 100584e:	bf00      	nop
 1005850:	010180b8 	.word	0x010180b8
 1005854:	01018178 	.word	0x01018178
 1005858:	010196f5 	.word	0x010196f5
 100585c:	2100060c 	.word	0x2100060c
 1005860:	210005e4 	.word	0x210005e4

01005864 <bt_recv>:
{
	return bt_buf_get_rx(BT_BUF_EVT, timeout);
}

int bt_recv(struct net_buf *buf)
{
 1005864:	b508      	push	{r3, lr}
			return -EINVAL;
		}
	}

	/* Queue to RAW rx queue */
	net_buf_put(raw_rx, buf);
 1005866:	4b03      	ldr	r3, [pc, #12]	; (1005874 <bt_recv+0x10>)
{
 1005868:	4601      	mov	r1, r0
	net_buf_put(raw_rx, buf);
 100586a:	6818      	ldr	r0, [r3, #0]
 100586c:	f011 f91c 	bl	1016aa8 <net_buf_put>

	return 0;
}
 1005870:	2000      	movs	r0, #0
 1005872:	bd08      	pop	{r3, pc}
 1005874:	21000984 	.word	0x21000984

01005878 <bt_enable_raw>:
		cmd_ext_size = size;
	}
}

int bt_enable_raw(struct k_fifo *rx_queue)
{
 1005878:	b538      	push	{r3, r4, r5, lr}
 100587a:	4a13      	ldr	r2, [pc, #76]	; (10058c8 <bt_enable_raw+0x50>)
	const struct bt_hci_driver *drv = bt_dev.drv;
 100587c:	4b13      	ldr	r3, [pc, #76]	; (10058cc <bt_enable_raw+0x54>)
 100587e:	4c14      	ldr	r4, [pc, #80]	; (10058d0 <bt_enable_raw+0x58>)
 1005880:	681d      	ldr	r5, [r3, #0]
	int err;

	BT_DBG("");

	raw_rx = rx_queue;
 1005882:	1aa4      	subs	r4, r4, r2
 1005884:	4b13      	ldr	r3, [pc, #76]	; (10058d4 <bt_enable_raw+0x5c>)
 1005886:	08e4      	lsrs	r4, r4, #3
 1005888:	6018      	str	r0, [r3, #0]

	if (!bt_dev.drv) {
 100588a:	01a4      	lsls	r4, r4, #6
 100588c:	b945      	cbnz	r5, 10058a0 <bt_enable_raw+0x28>
		BT_ERR("No HCI driver registered");
 100588e:	4812      	ldr	r0, [pc, #72]	; (10058d8 <bt_enable_raw+0x60>)
 1005890:	f044 0101 	orr.w	r1, r4, #1
 1005894:	f00f fd7b 	bl	101538e <log_0>
		return -ENODEV;
 1005898:	f06f 0512 	mvn.w	r5, #18
	}

	BT_INFO("Bluetooth enabled in RAW mode");

	return 0;
}
 100589c:	4628      	mov	r0, r5
 100589e:	bd38      	pop	{r3, r4, r5, pc}
		bt_hci_ecc_init();
 10058a0:	f000 f96c 	bl	1005b7c <bt_hci_ecc_init>
	err = drv->open();
 10058a4:	68eb      	ldr	r3, [r5, #12]
 10058a6:	4798      	blx	r3
	if (err) {
 10058a8:	4605      	mov	r5, r0
 10058aa:	b130      	cbz	r0, 10058ba <bt_enable_raw+0x42>
		BT_ERR("HCI driver open failed (%d)", err);
 10058ac:	4601      	mov	r1, r0
 10058ae:	f044 0201 	orr.w	r2, r4, #1
 10058b2:	480a      	ldr	r0, [pc, #40]	; (10058dc <bt_enable_raw+0x64>)
 10058b4:	f00f fd78 	bl	10153a8 <log_1>
		return err;
 10058b8:	e7f0      	b.n	100589c <bt_enable_raw+0x24>
	BT_INFO("Bluetooth enabled in RAW mode");
 10058ba:	4809      	ldr	r0, [pc, #36]	; (10058e0 <bt_enable_raw+0x68>)
 10058bc:	f044 0103 	orr.w	r1, r4, #3
 10058c0:	f00f fd65 	bl	101538e <log_0>
	return 0;
 10058c4:	e7ea      	b.n	100589c <bt_enable_raw+0x24>
 10058c6:	bf00      	nop
 10058c8:	010180b8 	.word	0x010180b8
 10058cc:	21000980 	.word	0x21000980
 10058d0:	01018178 	.word	0x01018178
 10058d4:	21000984 	.word	0x21000984
 10058d8:	01019706 	.word	0x01019706
 10058dc:	0101971f 	.word	0x0101971f
 10058e0:	0101973b 	.word	0x0101973b

010058e4 <ecc_thread>:

	bt_recv(buf);
}

static void ecc_thread(void *p1, void *p2, void *p3)
{
 10058e4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 10058e8:	f8df 8194 	ldr.w	r8, [pc, #404]	; 1005a80 <ecc_thread+0x19c>
 10058ec:	4d5b      	ldr	r5, [pc, #364]	; (1005a5c <ecc_thread+0x178>)
 10058ee:	4647      	mov	r7, r8
 10058f0:	4b5b      	ldr	r3, [pc, #364]	; (1005a60 <ecc_thread+0x17c>)
	return z_impl_k_sem_take(sem, timeout);
 10058f2:	f8df 9190 	ldr.w	r9, [pc, #400]	; 1005a84 <ecc_thread+0x1a0>
 10058f6:	1aed      	subs	r5, r5, r3
 10058f8:	08ed      	lsrs	r5, r5, #3
 10058fa:	f04f 32ff 	mov.w	r2, #4294967295
 10058fe:	f04f 33ff 	mov.w	r3, #4294967295
 1005902:	4648      	mov	r0, r9
 1005904:	f00e fec6 	bl	1014694 <z_impl_k_sem_take>
 1005908:	e8d8 4faf 	lda	r4, [r8]
	while (true) {
		k_sem_take(&cmd_sem, K_FOREVER);

		if (atomic_test_bit(flags, PENDING_PUB_KEY)) {
 100590c:	f014 0401 	ands.w	r4, r4, #1
 1005910:	d056      	beq.n	10059c0 <ecc_thread+0xdc>
		rc = uECC_make_key(ecc.pk, ecc.private_key, &curve_secp256r1);
 1005912:	f8df a164 	ldr.w	sl, [pc, #356]	; 1005a78 <ecc_thread+0x194>
 1005916:	4c53      	ldr	r4, [pc, #332]	; (1005a64 <ecc_thread+0x180>)
	} while (memcmp(ecc.private_key, debug_private_key, 32) == 0);
 1005918:	4e53      	ldr	r6, [pc, #332]	; (1005a68 <ecc_thread+0x184>)
		rc = uECC_make_key(ecc.pk, ecc.private_key, &curve_secp256r1);
 100591a:	4652      	mov	r2, sl
 100591c:	4621      	mov	r1, r4
 100591e:	4853      	ldr	r0, [pc, #332]	; (1005a6c <ecc_thread+0x188>)
 1005920:	f010 f85c 	bl	10159dc <uECC_make_key>
		if (rc == TC_CRYPTO_FAIL) {
 1005924:	bbc8      	cbnz	r0, 100599a <ecc_thread+0xb6>
			BT_ERR("Failed to create ECC public/private pair");
 1005926:	01a9      	lsls	r1, r5, #6
 1005928:	4851      	ldr	r0, [pc, #324]	; (1005a70 <ecc_thread+0x18c>)
 100592a:	f041 0101 	orr.w	r1, r1, #1
 100592e:	f00f fd2e 	bl	101538e <log_0>
			return BT_HCI_ERR_UNSPECIFIED;
 1005932:	f04f 0a1f 	mov.w	sl, #31
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 1005936:	f04f 32ff 	mov.w	r2, #4294967295
 100593a:	f04f 33ff 	mov.w	r3, #4294967295
 100593e:	2001      	movs	r0, #1
 1005940:	f7ff ff2c 	bl	100579c <bt_buf_get_rx>
	hdr = net_buf_add(buf, sizeof(*hdr));
 1005944:	f100 0608 	add.w	r6, r0, #8
 1005948:	2102      	movs	r1, #2
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 100594a:	4604      	mov	r4, r0
	hdr = net_buf_add(buf, sizeof(*hdr));
 100594c:	4630      	mov	r0, r6
 100594e:	f011 f8b8 	bl	1016ac2 <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_LE_META_EVENT;
 1005952:	233e      	movs	r3, #62	; 0x3e
 1005954:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*meta) + sizeof(*evt);
 1005956:	2342      	movs	r3, #66	; 0x42
	meta = net_buf_add(buf, sizeof(*meta));
 1005958:	2101      	movs	r1, #1
	hdr->len = sizeof(*meta) + sizeof(*evt);
 100595a:	7043      	strb	r3, [r0, #1]
	meta = net_buf_add(buf, sizeof(*meta));
 100595c:	4630      	mov	r0, r6
 100595e:	f011 f8b0 	bl	1016ac2 <net_buf_simple_add>
	meta->subevent = BT_HCI_EVT_LE_P256_PUBLIC_KEY_COMPLETE;
 1005962:	2308      	movs	r3, #8
	evt = net_buf_add(buf, sizeof(*evt));
 1005964:	2141      	movs	r1, #65	; 0x41
	meta->subevent = BT_HCI_EVT_LE_P256_PUBLIC_KEY_COMPLETE;
 1005966:	7003      	strb	r3, [r0, #0]
	evt = net_buf_add(buf, sizeof(*evt));
 1005968:	4630      	mov	r0, r6
 100596a:	f011 f8aa 	bl	1016ac2 <net_buf_simple_add>
 100596e:	4606      	mov	r6, r0
	evt->status = status;
 1005970:	f800 ab01 	strb.w	sl, [r0], #1
	if (status) {
 1005974:	f1ba 0f00 	cmp.w	sl, #0
 1005978:	d019      	beq.n	10059ae <ecc_thread+0xca>
		(void)memset(evt->key, 0, sizeof(evt->key));
 100597a:	2240      	movs	r2, #64	; 0x40
 100597c:	2100      	movs	r1, #0
 100597e:	f010 ffc6 	bl	101690e <memset>
 * @return Previous value of @a target.
 */
#ifdef CONFIG_ATOMIC_OPERATIONS_BUILTIN
static inline atomic_val_t atomic_and(atomic_t *target, atomic_val_t value)
{
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 1005982:	e8d7 3fef 	ldaex	r3, [r7]
 1005986:	f023 0301 	bic.w	r3, r3, #1
 100598a:	e8c7 3fe2 	stlex	r2, r3, [r7]
 100598e:	2a00      	cmp	r2, #0
 1005990:	d1f7      	bne.n	1005982 <ecc_thread+0x9e>
	bt_recv(buf);
 1005992:	4620      	mov	r0, r4
	bt_recv(buf);
 1005994:	f7ff ff66 	bl	1005864 <bt_recv>
	while (true) {
 1005998:	e7af      	b.n	10058fa <ecc_thread+0x16>
	} while (memcmp(ecc.private_key, debug_private_key, 32) == 0);
 100599a:	2220      	movs	r2, #32
 100599c:	4631      	mov	r1, r6
 100599e:	4620      	mov	r0, r4
 10059a0:	f010 ff7a 	bl	1016898 <memcmp>
 10059a4:	2800      	cmp	r0, #0
 10059a6:	d0b8      	beq.n	100591a <ecc_thread+0x36>
	return 0;
 10059a8:	f04f 0a00 	mov.w	sl, #0
 10059ac:	e7c3      	b.n	1005936 <ecc_thread+0x52>
		sys_memcpy_swap(evt->key, ecc.pk, 32);
 10059ae:	492f      	ldr	r1, [pc, #188]	; (1005a6c <ecc_thread+0x188>)
 10059b0:	f011 f845 	bl	1016a3e <sys_memcpy_swap.constprop.0>
		sys_memcpy_swap(&evt->key[32], &ecc.pk[32], 32);
 10059b4:	492f      	ldr	r1, [pc, #188]	; (1005a74 <ecc_thread+0x190>)
 10059b6:	f106 0021 	add.w	r0, r6, #33	; 0x21
 10059ba:	f011 f840 	bl	1016a3e <sys_memcpy_swap.constprop.0>
 10059be:	e7e0      	b.n	1005982 <ecc_thread+0x9e>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 10059c0:	e8d8 3faf 	lda	r3, [r8]
			emulate_le_p256_public_key_cmd();
		} else if (atomic_test_bit(flags, PENDING_DHKEY)) {
 10059c4:	079b      	lsls	r3, r3, #30
 10059c6:	d598      	bpl.n	10058fa <ecc_thread+0x16>
	ret = uECC_valid_public_key(ecc.pk, &curve_secp256r1);
 10059c8:	492b      	ldr	r1, [pc, #172]	; (1005a78 <ecc_thread+0x194>)
 10059ca:	4828      	ldr	r0, [pc, #160]	; (1005a6c <ecc_thread+0x188>)
 10059cc:	f010 fed3 	bl	1016776 <uECC_valid_public_key>
	if (ret < 0) {
 10059d0:	1e01      	subs	r1, r0, #0
 10059d2:	da34      	bge.n	1005a3e <ecc_thread+0x15a>
		BT_ERR("public key is not valid (ret %d)", ret);
 10059d4:	01aa      	lsls	r2, r5, #6
 10059d6:	4829      	ldr	r0, [pc, #164]	; (1005a7c <ecc_thread+0x198>)
 10059d8:	f042 0201 	orr.w	r2, r2, #1
 10059dc:	f00f fce4 	bl	10153a8 <log_1>
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 10059e0:	f04f 32ff 	mov.w	r2, #4294967295
 10059e4:	f04f 33ff 	mov.w	r3, #4294967295
 10059e8:	2001      	movs	r0, #1
 10059ea:	f7ff fed7 	bl	100579c <bt_buf_get_rx>
	hdr = net_buf_add(buf, sizeof(*hdr));
 10059ee:	f100 0a08 	add.w	sl, r0, #8
 10059f2:	2102      	movs	r1, #2
	buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 10059f4:	4606      	mov	r6, r0
	hdr = net_buf_add(buf, sizeof(*hdr));
 10059f6:	4650      	mov	r0, sl
 10059f8:	f011 f863 	bl	1016ac2 <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_LE_META_EVENT;
 10059fc:	233e      	movs	r3, #62	; 0x3e
 10059fe:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*meta) + sizeof(*evt);
 1005a00:	2322      	movs	r3, #34	; 0x22
	meta = net_buf_add(buf, sizeof(*meta));
 1005a02:	2101      	movs	r1, #1
	hdr->len = sizeof(*meta) + sizeof(*evt);
 1005a04:	7043      	strb	r3, [r0, #1]
	meta = net_buf_add(buf, sizeof(*meta));
 1005a06:	4650      	mov	r0, sl
 1005a08:	f011 f85b 	bl	1016ac2 <net_buf_simple_add>
	meta->subevent = BT_HCI_EVT_LE_GENERATE_DHKEY_COMPLETE;
 1005a0c:	2309      	movs	r3, #9
	evt = net_buf_add(buf, sizeof(*evt));
 1005a0e:	2121      	movs	r1, #33	; 0x21
	meta->subevent = BT_HCI_EVT_LE_GENERATE_DHKEY_COMPLETE;
 1005a10:	7003      	strb	r3, [r0, #0]
	evt = net_buf_add(buf, sizeof(*evt));
 1005a12:	4650      	mov	r0, sl
 1005a14:	f011 f855 	bl	1016ac2 <net_buf_simple_add>
 1005a18:	4603      	mov	r3, r0
	if (ret == TC_CRYPTO_FAIL) {
 1005a1a:	3001      	adds	r0, #1
 1005a1c:	b9c4      	cbnz	r4, 1005a50 <ecc_thread+0x16c>
		evt->status = BT_HCI_ERR_UNSPECIFIED;
 1005a1e:	221f      	movs	r2, #31
		(void)memset(evt->dhkey, 0, sizeof(evt->dhkey));
 1005a20:	4621      	mov	r1, r4
		evt->status = BT_HCI_ERR_UNSPECIFIED;
 1005a22:	701a      	strb	r2, [r3, #0]
		(void)memset(evt->dhkey, 0, sizeof(evt->dhkey));
 1005a24:	2220      	movs	r2, #32
 1005a26:	f010 ff72 	bl	101690e <memset>
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 1005a2a:	e8d7 3fef 	ldaex	r3, [r7]
 1005a2e:	f023 0302 	bic.w	r3, r3, #2
 1005a32:	e8c7 3fe2 	stlex	r2, r3, [r7]
 1005a36:	2a00      	cmp	r2, #0
 1005a38:	d1f7      	bne.n	1005a2a <ecc_thread+0x146>
	bt_recv(buf);
 1005a3a:	4630      	mov	r0, r6
 1005a3c:	e7aa      	b.n	1005994 <ecc_thread+0xb0>
		ret = uECC_shared_secret(ecc.pk, ecc.private_key, ecc.dhkey,
 1005a3e:	4a0b      	ldr	r2, [pc, #44]	; (1005a6c <ecc_thread+0x188>)
 1005a40:	4b0d      	ldr	r3, [pc, #52]	; (1005a78 <ecc_thread+0x194>)
 1005a42:	4610      	mov	r0, r2
 1005a44:	f1a2 0120 	sub.w	r1, r2, #32
 1005a48:	f010 f817 	bl	1015a7a <uECC_shared_secret>
 1005a4c:	4604      	mov	r4, r0
 1005a4e:	e7c7      	b.n	10059e0 <ecc_thread+0xfc>
		evt->status = 0U;
 1005a50:	2200      	movs	r2, #0
		sys_memcpy_swap(evt->dhkey, ecc.dhkey, sizeof(ecc.dhkey));
 1005a52:	4906      	ldr	r1, [pc, #24]	; (1005a6c <ecc_thread+0x188>)
		evt->status = 0U;
 1005a54:	701a      	strb	r2, [r3, #0]
		sys_memcpy_swap(evt->dhkey, ecc.dhkey, sizeof(ecc.dhkey));
 1005a56:	f010 fff2 	bl	1016a3e <sys_memcpy_swap.constprop.0>
 1005a5a:	e7e6      	b.n	1005a2a <ecc_thread+0x146>
 1005a5c:	01018170 	.word	0x01018170
 1005a60:	010180b8 	.word	0x010180b8
 1005a64:	21006690 	.word	0x21006690
 1005a68:	01018458 	.word	0x01018458
 1005a6c:	210066b0 	.word	0x210066b0
 1005a70:	01019764 	.word	0x01019764
 1005a74:	210066d0 	.word	0x210066d0
 1005a78:	010183a8 	.word	0x010183a8
 1005a7c:	0101978d 	.word	0x0101978d
 1005a80:	210009fc 	.word	0x210009fc
 1005a84:	21000558 	.word	0x21000558

01005a88 <bt_hci_ecc_send>:

	send_cmd_status(BT_HCI_OP_LE_P256_PUBLIC_KEY, status);
}

int bt_hci_ecc_send(struct net_buf *buf)
{
 1005a88:	b570      	push	{r4, r5, r6, lr}
	return (enum bt_buf_type)(*(u8_t *)net_buf_user_data(buf));
 1005a8a:	7d05      	ldrb	r5, [r0, #20]
 1005a8c:	4604      	mov	r4, r0
	if (bt_buf_get_type(buf) == BT_BUF_CMD) {
 1005a8e:	b9ad      	cbnz	r5, 1005abc <bt_hci_ecc_send+0x34>
		struct bt_hci_cmd_hdr *chdr = (void *)buf->data;

		switch (sys_le16_to_cpu(chdr->opcode)) {
 1005a90:	f242 0125 	movw	r1, #8229	; 0x2025
		struct bt_hci_cmd_hdr *chdr = (void *)buf->data;
 1005a94:	6883      	ldr	r3, [r0, #8]
		switch (sys_le16_to_cpu(chdr->opcode)) {
 1005a96:	881a      	ldrh	r2, [r3, #0]
 1005a98:	428a      	cmp	r2, r1
 1005a9a:	d016      	beq.n	1005aca <bt_hci_ecc_send+0x42>
 1005a9c:	f242 0126 	movw	r1, #8230	; 0x2026
 1005aa0:	428a      	cmp	r2, r1
 1005aa2:	d034      	beq.n	1005b0e <bt_hci_ecc_send+0x86>
 1005aa4:	f242 0101 	movw	r1, #8193	; 0x2001
 1005aa8:	428a      	cmp	r2, r1
 1005aaa:	d107      	bne.n	1005abc <bt_hci_ecc_send+0x34>
	cmd->events[0] &= ~0x80; /* LE Read Local P-256 PKey Compl */
 1005aac:	78da      	ldrb	r2, [r3, #3]
 1005aae:	f002 027f 	and.w	r2, r2, #127	; 0x7f
 1005ab2:	70da      	strb	r2, [r3, #3]
	cmd->events[1] &= ~0x01; /* LE Generate DHKey Compl Event */
 1005ab4:	791a      	ldrb	r2, [r3, #4]
 1005ab6:	f022 0201 	bic.w	r2, r2, #1
 1005aba:	711a      	strb	r2, [r3, #4]
		default:
			break;
		}
	}

	return bt_dev.drv->send(buf);
 1005abc:	4b2a      	ldr	r3, [pc, #168]	; (1005b68 <bt_hci_ecc_send+0xe0>)
 1005abe:	4620      	mov	r0, r4
}
 1005ac0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return bt_dev.drv->send(buf);
 1005ac4:	681b      	ldr	r3, [r3, #0]
 1005ac6:	691b      	ldr	r3, [r3, #16]
 1005ac8:	4718      	bx	r3
			net_buf_pull(buf, sizeof(*chdr));
 1005aca:	2103      	movs	r1, #3
 1005acc:	3008      	adds	r0, #8
 1005ace:	f011 f810 	bl	1016af2 <net_buf_simple_pull>
	net_buf_unref(buf);
 1005ad2:	4620      	mov	r0, r4
 1005ad4:	f00c ff30 	bl	1012938 <net_buf_unref>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 1005ad8:	4b24      	ldr	r3, [pc, #144]	; (1005b6c <bt_hci_ecc_send+0xe4>)
 1005ada:	e8d3 2faf 	lda	r2, [r3]
	if (atomic_test_bit(flags, PENDING_DHKEY)) {
 1005ade:	0790      	lsls	r0, r2, #30
 1005ae0:	d507      	bpl.n	1005af2 <bt_hci_ecc_send+0x6a>
		status = BT_HCI_ERR_CMD_DISALLOWED;
 1005ae2:	250c      	movs	r5, #12
	send_cmd_status(BT_HCI_OP_LE_P256_PUBLIC_KEY, status);
 1005ae4:	4629      	mov	r1, r5
 1005ae6:	f242 0025 	movw	r0, #8229	; 0x2025
	send_cmd_status(BT_HCI_OP_LE_GENERATE_DHKEY, status);
 1005aea:	f010 ff84 	bl	10169f6 <send_cmd_status>
}
 1005aee:	2000      	movs	r0, #0
 1005af0:	bd70      	pop	{r4, r5, r6, pc}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 1005af2:	e8d3 2fef 	ldaex	r2, [r3]
 1005af6:	f042 0101 	orr.w	r1, r2, #1
 1005afa:	e8c3 1fe0 	stlex	r0, r1, [r3]
 1005afe:	2800      	cmp	r0, #0
 1005b00:	d1f7      	bne.n	1005af2 <bt_hci_ecc_send+0x6a>
	} else if (atomic_test_and_set_bit(flags, PENDING_PUB_KEY)) {
 1005b02:	07d1      	lsls	r1, r2, #31
 1005b04:	d4ed      	bmi.n	1005ae2 <bt_hci_ecc_send+0x5a>
	z_impl_k_sem_give(sem);
 1005b06:	481a      	ldr	r0, [pc, #104]	; (1005b70 <bt_hci_ecc_send+0xe8>)
 1005b08:	f00e fd9e 	bl	1014648 <z_impl_k_sem_give>
}
 1005b0c:	e7ea      	b.n	1005ae4 <bt_hci_ecc_send+0x5c>
			net_buf_pull(buf, sizeof(*chdr));
 1005b0e:	2103      	movs	r1, #3
 1005b10:	3008      	adds	r0, #8
 1005b12:	f010 ffee 	bl	1016af2 <net_buf_simple_pull>
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 1005b16:	4b15      	ldr	r3, [pc, #84]	; (1005b6c <bt_hci_ecc_send+0xe4>)
 1005b18:	e8d3 2faf 	lda	r2, [r3]
	if (atomic_test_bit(flags, PENDING_PUB_KEY)) {
 1005b1c:	07d2      	lsls	r2, r2, #31
 1005b1e:	d507      	bpl.n	1005b30 <bt_hci_ecc_send+0xa8>
		status = BT_HCI_ERR_CMD_DISALLOWED;
 1005b20:	250c      	movs	r5, #12
	net_buf_unref(buf);
 1005b22:	4620      	mov	r0, r4
 1005b24:	f00c ff08 	bl	1012938 <net_buf_unref>
	send_cmd_status(BT_HCI_OP_LE_GENERATE_DHKEY, status);
 1005b28:	4629      	mov	r1, r5
 1005b2a:	f242 0026 	movw	r0, #8230	; 0x2026
 1005b2e:	e7dc      	b.n	1005aea <bt_hci_ecc_send+0x62>
	if (buf->len < sizeof(struct bt_hci_cp_le_generate_dhkey)) {
 1005b30:	89a2      	ldrh	r2, [r4, #12]
 1005b32:	2a3f      	cmp	r2, #63	; 0x3f
 1005b34:	d915      	bls.n	1005b62 <bt_hci_ecc_send+0xda>
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 1005b36:	e8d3 2fef 	ldaex	r2, [r3]
 1005b3a:	f042 0102 	orr.w	r1, r2, #2
 1005b3e:	e8c3 1fe0 	stlex	r0, r1, [r3]
 1005b42:	2800      	cmp	r0, #0
 1005b44:	d1f7      	bne.n	1005b36 <bt_hci_ecc_send+0xae>
	if (atomic_test_and_set_bit(flags, PENDING_DHKEY)) {
 1005b46:	0793      	lsls	r3, r2, #30
 1005b48:	d4ea      	bmi.n	1005b20 <bt_hci_ecc_send+0x98>
	cmd = (void *)buf->data;
 1005b4a:	68a1      	ldr	r1, [r4, #8]
	sys_memcpy_swap(ecc.pk, cmd->key, 32);
 1005b4c:	4809      	ldr	r0, [pc, #36]	; (1005b74 <bt_hci_ecc_send+0xec>)
 1005b4e:	f010 ff76 	bl	1016a3e <sys_memcpy_swap.constprop.0>
	sys_memcpy_swap(&ecc.pk[32], &cmd->key[32], 32);
 1005b52:	4809      	ldr	r0, [pc, #36]	; (1005b78 <bt_hci_ecc_send+0xf0>)
 1005b54:	3120      	adds	r1, #32
 1005b56:	f010 ff72 	bl	1016a3e <sys_memcpy_swap.constprop.0>
	z_impl_k_sem_give(sem);
 1005b5a:	4805      	ldr	r0, [pc, #20]	; (1005b70 <bt_hci_ecc_send+0xe8>)
 1005b5c:	f00e fd74 	bl	1014648 <z_impl_k_sem_give>
}
 1005b60:	e7df      	b.n	1005b22 <bt_hci_ecc_send+0x9a>
		status = BT_HCI_ERR_INVALID_PARAM;
 1005b62:	2512      	movs	r5, #18
 1005b64:	e7dd      	b.n	1005b22 <bt_hci_ecc_send+0x9a>
 1005b66:	bf00      	nop
 1005b68:	21000980 	.word	0x21000980
 1005b6c:	210009fc 	.word	0x210009fc
 1005b70:	21000558 	.word	0x21000558
 1005b74:	210066b0 	.word	0x210066b0
 1005b78:	210066d0 	.word	0x210066d0

01005b7c <bt_hci_ecc_init>:
{
	return !bt_rand(dst, len);
}

void bt_hci_ecc_init(void)
{
 1005b7c:	b510      	push	{r4, lr}
 1005b7e:	b088      	sub	sp, #32
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 1005b80:	2200      	movs	r2, #0
 1005b82:	2300      	movs	r3, #0
 1005b84:	e9cd 2306 	strd	r2, r3, [sp, #24]
 1005b88:	2300      	movs	r3, #0
 1005b8a:	220a      	movs	r2, #10
 1005b8c:	4c09      	ldr	r4, [pc, #36]	; (1005bb4 <bt_hci_ecc_init+0x38>)
 1005b8e:	e9cd 2303 	strd	r2, r3, [sp, #12]
 1005b92:	e9cd 3301 	strd	r3, r3, [sp, #4]
 1005b96:	9300      	str	r3, [sp, #0]
 1005b98:	f240 424c 	movw	r2, #1100	; 0x44c
 1005b9c:	4620      	mov	r0, r4
 1005b9e:	4b06      	ldr	r3, [pc, #24]	; (1005bb8 <bt_hci_ecc_init+0x3c>)
 1005ba0:	4906      	ldr	r1, [pc, #24]	; (1005bbc <bt_hci_ecc_init+0x40>)
 1005ba2:	f00e fddf 	bl	1014764 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
 1005ba6:	4620      	mov	r0, r4
 1005ba8:	4905      	ldr	r1, [pc, #20]	; (1005bc0 <bt_hci_ecc_init+0x44>)
	k_thread_create(&ecc_thread_data, ecc_thread_stack,
			K_THREAD_STACK_SIZEOF(ecc_thread_stack), ecc_thread,
			NULL, NULL, NULL, K_PRIO_PREEMPT(10), 0, K_NO_WAIT);
	k_thread_name_set(&ecc_thread_data, "BT ECC");
}
 1005baa:	b008      	add	sp, #32
 1005bac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 1005bb0:	f011 bfa2 	b.w	1017af8 <z_impl_k_thread_name_set>
 1005bb4:	21000988 	.word	0x21000988
 1005bb8:	010058e5 	.word	0x010058e5
 1005bbc:	21006e00 	.word	0x21006e00
 1005bc0:	010197ae 	.word	0x010197ae

01005bc4 <mem_init>:

#include "mem.h"

void mem_init(void *mem_pool, u16_t mem_size, u16_t mem_count,
	      void **mem_head)
{
 1005bc4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1005bc8:	4614      	mov	r4, r2
	*mem_head = mem_pool;

	/* Store free mem_count after the list's next pointer at an 32-bit
	 * aligned memory location to ensure atomic read/write (in ARM for now).
	 */
	*((u16_t *)MROUND((u8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
 1005bca:	1dc2      	adds	r2, r0, #7

	/* Initialize next pointers to form a free list,
	 * next pointer is stored in the first 32-bit of each block
	 */
	(void)memset(((u8_t *)mem_pool + (mem_size * (--mem_count))), 0,
 1005bcc:	1e66      	subs	r6, r4, #1
	*((u16_t *)MROUND((u8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
 1005bce:	f022 0203 	bic.w	r2, r2, #3
	(void)memset(((u8_t *)mem_pool + (mem_size * (--mem_count))), 0,
 1005bd2:	b2b6      	uxth	r6, r6
	*mem_head = mem_pool;
 1005bd4:	6018      	str	r0, [r3, #0]
{
 1005bd6:	4605      	mov	r5, r0
 1005bd8:	460f      	mov	r7, r1
	(void)memset(((u8_t *)mem_pool + (mem_size * (--mem_count))), 0,
 1005bda:	fb01 0006 	mla	r0, r1, r6, r0
{
 1005bde:	b082      	sub	sp, #8
	*((u16_t *)MROUND((u8_t *)mem_pool + sizeof(mem_pool))) = mem_count;
 1005be0:	8014      	strh	r4, [r2, #0]
	(void)memset(((u8_t *)mem_pool + (mem_size * (--mem_count))), 0,
 1005be2:	2100      	movs	r1, #0
 1005be4:	2204      	movs	r2, #4
 1005be6:	f010 fe92 	bl	101690e <memset>
		     sizeof(mem_pool));
	while (mem_count--) {
 1005bea:	b1b6      	cbz	r6, 1005c1a <mem_init+0x56>
 1005bec:	f64f 78ff 	movw	r8, #65535	; 0xffff
 1005bf0:	3c02      	subs	r4, #2
 1005bf2:	b2a4      	uxth	r4, r4
 1005bf4:	fb04 7307 	mla	r3, r4, r7, r7
 1005bf8:	fb04 f607 	mul.w	r6, r4, r7
 1005bfc:	441d      	add	r5, r3
 1005bfe:	1af6      	subs	r6, r6, r3
		u32_t next;

		next = (u32_t)((u8_t *) mem_pool +
			       (mem_size * (mem_count + 1)));
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
 1005c00:	2204      	movs	r2, #4
	while (mem_count--) {
 1005c02:	3c01      	subs	r4, #1
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
 1005c04:	19a8      	adds	r0, r5, r6
 1005c06:	eb0d 0102 	add.w	r1, sp, r2
	while (mem_count--) {
 1005c0a:	b2a4      	uxth	r4, r4
		next = (u32_t)((u8_t *) mem_pool +
 1005c0c:	9501      	str	r5, [sp, #4]
		memcpy(((u8_t *)mem_pool + (mem_size * mem_count)),
 1005c0e:	f010 fe53 	bl	10168b8 <memcpy>
	while (mem_count--) {
 1005c12:	4544      	cmp	r4, r8
 1005c14:	eba5 0507 	sub.w	r5, r5, r7
 1005c18:	d1f2      	bne.n	1005c00 <mem_init+0x3c>
		       (void *)&next, sizeof(next));
	}
}
 1005c1a:	b002      	add	sp, #8
 1005c1c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

01005c20 <mem_acquire>:

void *mem_acquire(void **mem_head)
{
 1005c20:	b570      	push	{r4, r5, r6, lr}
	if (*mem_head) {
 1005c22:	6805      	ldr	r5, [r0, #0]
{
 1005c24:	b082      	sub	sp, #8
	if (*mem_head) {
 1005c26:	b195      	cbz	r5, 1005c4e <mem_acquire+0x2e>
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
					       sizeof(mem_head)));
		free_count--;

		mem = *mem_head;
		memcpy(&head, mem, sizeof(head));
 1005c28:	2204      	movs	r2, #4
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
 1005c2a:	1deb      	adds	r3, r5, #7
 1005c2c:	f023 0303 	bic.w	r3, r3, #3
 1005c30:	4604      	mov	r4, r0
		memcpy(&head, mem, sizeof(head));
 1005c32:	4629      	mov	r1, r5
 1005c34:	eb0d 0002 	add.w	r0, sp, r2
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
 1005c38:	881e      	ldrh	r6, [r3, #0]
		memcpy(&head, mem, sizeof(head));
 1005c3a:	f010 fe3d 	bl	10168b8 <memcpy>

		/* Store free mem_count after the list's next pointer */
		if (head) {
 1005c3e:	9a01      	ldr	r2, [sp, #4]
 1005c40:	b122      	cbz	r2, 1005c4c <mem_acquire+0x2c>
			*((u16_t *)MROUND((u8_t *)head + sizeof(head))) =
 1005c42:	1dd3      	adds	r3, r2, #7
		free_count--;
 1005c44:	3e01      	subs	r6, #1
			*((u16_t *)MROUND((u8_t *)head + sizeof(head))) =
 1005c46:	f023 0303 	bic.w	r3, r3, #3
 1005c4a:	801e      	strh	r6, [r3, #0]
				free_count;
		}

		*mem_head = head;
 1005c4c:	6022      	str	r2, [r4, #0]
		return mem;
	}

	return NULL;
}
 1005c4e:	4628      	mov	r0, r5
 1005c50:	b002      	add	sp, #8
 1005c52:	bd70      	pop	{r4, r5, r6, pc}

01005c54 <mem_release>:
void mem_release(void *mem, void **mem_head)
{
	u16_t free_count = 0U;

	/* Get the free count from the list and increment it */
	if (*mem_head) {
 1005c54:	680b      	ldr	r3, [r1, #0]
{
 1005c56:	b570      	push	{r4, r5, r6, lr}
 1005c58:	460c      	mov	r4, r1
 1005c5a:	4605      	mov	r5, r0
	if (*mem_head) {
 1005c5c:	b183      	cbz	r3, 1005c80 <mem_release+0x2c>
		free_count = *((u16_t *)MROUND((u8_t *)*mem_head +
 1005c5e:	3307      	adds	r3, #7
 1005c60:	f023 0303 	bic.w	r3, r3, #3
 1005c64:	881e      	ldrh	r6, [r3, #0]
 1005c66:	3601      	adds	r6, #1
 1005c68:	b2b6      	uxth	r6, r6
					       sizeof(mem_head)));
	}
	free_count++;

	memcpy(mem, mem_head, sizeof(mem));
 1005c6a:	2204      	movs	r2, #4
 1005c6c:	4621      	mov	r1, r4
 1005c6e:	4628      	mov	r0, r5
 1005c70:	f010 fe22 	bl	10168b8 <memcpy>

	/* Store free mem_count after the list's next pointer */
	*((u16_t *)MROUND((u8_t *)mem + sizeof(mem))) = free_count;
 1005c74:	1deb      	adds	r3, r5, #7
 1005c76:	f023 0303 	bic.w	r3, r3, #3
 1005c7a:	801e      	strh	r6, [r3, #0]

	*mem_head = mem;
 1005c7c:	6025      	str	r5, [r4, #0]
}
 1005c7e:	bd70      	pop	{r4, r5, r6, pc}
 1005c80:	2601      	movs	r6, #1
 1005c82:	e7f2      	b.n	1005c6a <mem_release+0x16>

01005c84 <mem_get>:
}

void *mem_get(void *mem_pool, u16_t mem_size, u16_t index)
{
	return ((void *)((u8_t *)mem_pool + (mem_size * index)));
}
 1005c84:	fb02 0001 	mla	r0, r2, r1, r0
 1005c88:	4770      	bx	lr
 1005c8a:	bf00      	nop

01005c8c <mem_index_get>:

u16_t mem_index_get(void *mem, void *mem_pool, u16_t mem_size)
{
	return ((u16_t)((u8_t *)mem - (u8_t *)mem_pool) / mem_size);
 1005c8c:	1a40      	subs	r0, r0, r1
 1005c8e:	b280      	uxth	r0, r0
}
 1005c90:	fbb0 f0f2 	udiv	r0, r0, r2
 1005c94:	4770      	bx	lr
 1005c96:	bf00      	nop

01005c98 <mem_rcopy>:
 * @details Example: [ 0x11 0x22 0x33 ] -> [ 0x33 0x22 0x11 ]
 */
void mem_rcopy(u8_t *dst, u8_t const *src, u16_t len)
{
	src += len;
	while (len--) {
 1005c98:	1e53      	subs	r3, r2, #1
	src += len;
 1005c9a:	4411      	add	r1, r2
	while (len--) {
 1005c9c:	b29b      	uxth	r3, r3
 1005c9e:	b142      	cbz	r2, 1005cb2 <mem_rcopy+0x1a>
 1005ca0:	43db      	mvns	r3, r3
 1005ca2:	3801      	subs	r0, #1
 1005ca4:	18ca      	adds	r2, r1, r3
		*dst++ = *--src;
 1005ca6:	f811 3d01 	ldrb.w	r3, [r1, #-1]!
	while (len--) {
 1005caa:	4291      	cmp	r1, r2
		*dst++ = *--src;
 1005cac:	f800 3f01 	strb.w	r3, [r0, #1]!
	while (len--) {
 1005cb0:	d1f9      	bne.n	1005ca6 <mem_rcopy+0xe>
	}
}
 1005cb2:	4770      	bx	lr

01005cb4 <mem_nz>:
 * @brief Determine if src[0..len-1] contains one or more non-zero bytes
 * @return 0 if all bytes are zero; otherwise 1
 */
u8_t mem_nz(u8_t *src, u16_t len)
{
	while (len--) {
 1005cb4:	4401      	add	r1, r0
 1005cb6:	e002      	b.n	1005cbe <mem_nz+0xa>
		if (*src++) {
 1005cb8:	f810 3b01 	ldrb.w	r3, [r0], #1
 1005cbc:	b91b      	cbnz	r3, 1005cc6 <mem_nz+0x12>
	while (len--) {
 1005cbe:	4288      	cmp	r0, r1
 1005cc0:	d1fa      	bne.n	1005cb8 <mem_nz+0x4>
			return 1;
		}
	}

	return 0;
 1005cc2:	2000      	movs	r0, #0
 1005cc4:	4770      	bx	lr
			return 1;
 1005cc6:	2001      	movs	r0, #1
}
 1005cc8:	4770      	bx	lr
 1005cca:	bf00      	nop

01005ccc <memq_init>:
 * @return          Initial link-element
 */
memq_link_t *memq_init(memq_link_t *link, memq_link_t **head, memq_link_t **tail)
{
	/* Head and tail pointer to the initial link - forms an empty queue */
	*head = *tail = link;
 1005ccc:	6010      	str	r0, [r2, #0]
 1005cce:	6008      	str	r0, [r1, #0]

	return link;
}
 1005cd0:	4770      	bx	lr
 1005cd2:	bf00      	nop

01005cd4 <memq_deinit>:
memq_link_t *memq_deinit(memq_link_t **head, memq_link_t **tail)
{
	memq_link_t *old_head;

	/* If head and tail are not equal, then queue is not empty */
	if (*head != *tail) {
 1005cd4:	680a      	ldr	r2, [r1, #0]
{
 1005cd6:	4603      	mov	r3, r0
	if (*head != *tail) {
 1005cd8:	6800      	ldr	r0, [r0, #0]
 1005cda:	4290      	cmp	r0, r2
		return NULL;
	}

	old_head = *head;
	*head = *tail = NULL;
 1005cdc:	bf09      	itett	eq
 1005cde:	2200      	moveq	r2, #0
		return NULL;
 1005ce0:	2000      	movne	r0, #0
	*head = *tail = NULL;
 1005ce2:	600a      	streq	r2, [r1, #0]
 1005ce4:	601a      	streq	r2, [r3, #0]

	return old_head;
}
 1005ce6:	4770      	bx	lr

01005ce8 <memq_enqueue>:
 * @param mem[in]      The memory payload to be enqueued. Pointed to by old tail
 * @param tail[in,out] Tail of queue. Will be updated to point to link
 * @return             New tail. Note: Does not point to the new mem
 */
memq_link_t *memq_enqueue(memq_link_t *link, void *mem, memq_link_t **tail)
{
 1005ce8:	b410      	push	{r4}
	/* Let the old tail element point to the new tail element */
	(*tail)->next = link;
 1005cea:	6814      	ldr	r4, [r2, #0]
 1005cec:	6020      	str	r0, [r4, #0]

	/* Let the old tail element point the the new memory */
	(*tail)->mem = mem;
 1005cee:	6814      	ldr	r4, [r2, #0]
 1005cf0:	6061      	str	r1, [r4, #4]
	 * The new tail-element is not expected to point to anything sensible
	 */
	*tail = link;

	return link;
}
 1005cf2:	bc10      	pop	{r4}
	*tail = link;
 1005cf4:	6010      	str	r0, [r2, #0]
}
 1005cf6:	4770      	bx	lr

01005cf8 <memq_peek>:
 * @return         head or NULL if queue is empty
 */
memq_link_t *memq_peek(memq_link_t *head, memq_link_t *tail, void **mem)
{
	/* If head and tail are equal, then queue empty */
	if (head == tail) {
 1005cf8:	4288      	cmp	r0, r1
 1005cfa:	d003      	beq.n	1005d04 <memq_peek+0xc>
		return NULL;
	}

	/* Extract the head link-element's memory */
	if (mem) {
 1005cfc:	b11a      	cbz	r2, 1005d06 <memq_peek+0xe>
		*mem = head->mem;
 1005cfe:	6843      	ldr	r3, [r0, #4]
 1005d00:	6013      	str	r3, [r2, #0]
 1005d02:	4770      	bx	lr
		return NULL;
 1005d04:	2000      	movs	r0, #0
	}

	return head; /* queue was not empty */
}
 1005d06:	4770      	bx	lr

01005d08 <memq_dequeue>:
memq_link_t *memq_dequeue(memq_link_t *tail, memq_link_t **head, void **mem)
{
	memq_link_t *old_head;

	/* Use memq peek to get the old head and its mem */
	old_head = memq_peek(*head, tail, mem);
 1005d08:	680b      	ldr	r3, [r1, #0]
	if (head == tail) {
 1005d0a:	4283      	cmp	r3, r0
 1005d0c:	d009      	beq.n	1005d22 <memq_dequeue+0x1a>
	if (mem) {
 1005d0e:	b12a      	cbz	r2, 1005d1c <memq_dequeue+0x14>
		*mem = head->mem;
 1005d10:	6858      	ldr	r0, [r3, #4]
 1005d12:	6010      	str	r0, [r2, #0]
	if (old_head == NULL) {
		return NULL; /* queue is empty */
	}

	/* Update the head-pointer to point to the new head element */
	*head = old_head->next;
 1005d14:	681a      	ldr	r2, [r3, #0]
 1005d16:	600a      	str	r2, [r1, #0]

	return old_head;
}
 1005d18:	4618      	mov	r0, r3
 1005d1a:	4770      	bx	lr
	if (old_head == NULL) {
 1005d1c:	2b00      	cmp	r3, #0
 1005d1e:	d1f9      	bne.n	1005d14 <memq_dequeue+0xc>
 1005d20:	e7fa      	b.n	1005d18 <memq_dequeue+0x10>
		return NULL; /* queue is empty */
 1005d22:	2300      	movs	r3, #0
 1005d24:	e7f8      	b.n	1005d18 <memq_dequeue+0x10>
 1005d26:	bf00      	nop

01005d28 <mayfly_init>:
#if defined(MAYFLY_UT)
static u8_t _state;
#endif /* MAYFLY_UT */

void mayfly_init(void)
{
 1005d28:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1005d2c:	270c      	movs	r7, #12
 1005d2e:	f8df 8034 	ldr.w	r8, [pc, #52]	; 1005d64 <mayfly_init+0x3c>
 1005d32:	4e0b      	ldr	r6, [pc, #44]	; (1005d60 <mayfly_init+0x38>)
 1005d34:	4645      	mov	r5, r8
 1005d36:	f106 0430 	add.w	r4, r6, #48	; 0x30
	while (callee_id--) {
		u8_t caller_id;

		caller_id = MAYFLY_CALLER_COUNT;
		while (caller_id--) {
			memq_init(&mfl[callee_id][caller_id],
 1005d3a:	4621      	mov	r1, r4
 1005d3c:	4628      	mov	r0, r5
 1005d3e:	1d22      	adds	r2, r4, #4
 1005d40:	3c0c      	subs	r4, #12
 1005d42:	f7ff ffc3 	bl	1005ccc <memq_init>
		while (caller_id--) {
 1005d46:	42b4      	cmp	r4, r6
 1005d48:	f1a5 0508 	sub.w	r5, r5, #8
 1005d4c:	d1f5      	bne.n	1005d3a <mayfly_init+0x12>
	while (callee_id--) {
 1005d4e:	3f04      	subs	r7, #4
 1005d50:	1d3b      	adds	r3, r7, #4
 1005d52:	f1a8 0820 	sub.w	r8, r8, #32
 1005d56:	f1a4 0630 	sub.w	r6, r4, #48	; 0x30
 1005d5a:	d1eb      	bne.n	1005d34 <mayfly_init+0xc>
				  &mft[callee_id][caller_id].head,
				  &mft[callee_id][caller_id].tail);
		}
	}
}
 1005d5c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 1005d60:	21000b08 	.word	0x21000b08
 1005d64:	21000a78 	.word	0x21000a78

01005d68 <mayfly_enable>:

void mayfly_enable(u8_t caller_id, u8_t callee_id, u8_t enable)
{
 1005d68:	b430      	push	{r4, r5}
 1005d6a:	4603      	mov	r3, r0
 1005d6c:	460c      	mov	r4, r1
	if (enable) {
 1005d6e:	b19a      	cbz	r2, 1005d98 <mayfly_enable+0x30>
		if (mft[callee_id][caller_id].enable_req ==
 1005d70:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 1005d74:	0108      	lsls	r0, r1, #4
 1005d76:	4d14      	ldr	r5, [pc, #80]	; (1005dc8 <mayfly_enable+0x60>)
 1005d78:	eb03 0143 	add.w	r1, r3, r3, lsl #1
 1005d7c:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 1005d80:	4429      	add	r1, r5
 1005d82:	7a48      	ldrb	r0, [r1, #9]
 1005d84:	7a0d      	ldrb	r5, [r1, #8]
 1005d86:	42a8      	cmp	r0, r5
		    mft[callee_id][caller_id].enable_ack) {
			mft[callee_id][caller_id].enable_req++;
 1005d88:	bf04      	itt	eq
 1005d8a:	3001      	addeq	r0, #1
 1005d8c:	7208      	strbeq	r0, [r1, #8]
		}

		mayfly_enable_cb(caller_id, callee_id, enable);
 1005d8e:	4621      	mov	r1, r4

			/* pend the callee for execution */
			mayfly_pend(caller_id, callee_id);
		}
	}
}
 1005d90:	bc30      	pop	{r4, r5}
		mayfly_enable_cb(caller_id, callee_id, enable);
 1005d92:	4618      	mov	r0, r3
 1005d94:	f00c bb7c 	b.w	1012490 <mayfly_enable_cb>
		if (mft[callee_id][caller_id].disable_req ==
 1005d98:	eb01 0241 	add.w	r2, r1, r1, lsl #1
 1005d9c:	4d0a      	ldr	r5, [pc, #40]	; (1005dc8 <mayfly_enable+0x60>)
 1005d9e:	0112      	lsls	r2, r2, #4
 1005da0:	eb00 0340 	add.w	r3, r0, r0, lsl #1
 1005da4:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 1005da8:	442b      	add	r3, r5
 1005daa:	7a9d      	ldrb	r5, [r3, #10]
 1005dac:	7ada      	ldrb	r2, [r3, #11]
 1005dae:	42aa      	cmp	r2, r5
 1005db0:	d001      	beq.n	1005db6 <mayfly_enable+0x4e>
}
 1005db2:	bc30      	pop	{r4, r5}
 1005db4:	4770      	bx	lr
			mfp[callee_id] = 1U;
 1005db6:	2501      	movs	r5, #1
			mft[callee_id][caller_id].disable_req++;
 1005db8:	442a      	add	r2, r5
 1005dba:	729a      	strb	r2, [r3, #10]
			mfp[callee_id] = 1U;
 1005dbc:	4b03      	ldr	r3, [pc, #12]	; (1005dcc <mayfly_enable+0x64>)
 1005dbe:	545d      	strb	r5, [r3, r1]
}
 1005dc0:	bc30      	pop	{r4, r5}
			mayfly_pend(caller_id, callee_id);
 1005dc2:	f00c bbab 	b.w	101251c <mayfly_pend>
 1005dc6:	bf00      	nop
 1005dc8:	21000a84 	.word	0x21000a84
 1005dcc:	21000a80 	.word	0x21000a80

01005dd0 <mayfly_enqueue>:

u32_t mayfly_enqueue(u8_t caller_id, u8_t callee_id, u8_t chain,
			struct mayfly *m)
{
 1005dd0:	b570      	push	{r4, r5, r6, lr}
 1005dd2:	461c      	mov	r4, r3
 1005dd4:	4606      	mov	r6, r0
 1005dd6:	460d      	mov	r5, r1
	u8_t state;
	u8_t ack;

	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
		!mayfly_is_enabled(caller_id, callee_id) ||
 1005dd8:	b32a      	cbz	r2, 1005e26 <mayfly_enqueue+0x56>
		(mft[callee_id][caller_id].disable_req !=
		 mft[callee_id][caller_id].disable_ack);

	/* shadow the ack */
	ack = m->_ack;
 1005dda:	7863      	ldrb	r3, [r4, #1]

	/* already in queue */
	state = (m->_req - ack) & 0x03;
 1005ddc:	7822      	ldrb	r2, [r4, #0]
 1005dde:	1ad2      	subs	r2, r2, r3
	if (state != 0U) {
 1005de0:	f012 0203 	ands.w	r2, r2, #3
 1005de4:	d005      	beq.n	1005df2 <mayfly_enqueue+0x22>
		if (chain) {
			if (state != 1U) {
 1005de6:	2a01      	cmp	r2, #1
 1005de8:	d041      	beq.n	1005e6e <mayfly_enqueue+0x9e>
				/* mark as ready in queue */
				m->_req = ack + 1;
 1005dea:	3301      	adds	r3, #1
 1005dec:	b2db      	uxtb	r3, r3
 1005dee:	7023      	strb	r3, [r4, #0]

				goto mayfly_enqueue_pend;
 1005df0:	e010      	b.n	1005e14 <mayfly_enqueue+0x44>
		return 0;
	}

	/* new, add as ready in the queue */
	m->_req = ack + 1;
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
 1005df2:	eb05 0245 	add.w	r2, r5, r5, lsl #1
 1005df6:	0112      	lsls	r2, r2, #4
 1005df8:	1d11      	adds	r1, r2, #4
 1005dfa:	eb06 0246 	add.w	r2, r6, r6, lsl #1
 1005dfe:	eb01 0282 	add.w	r2, r1, r2, lsl #2
	m->_req = ack + 1;
 1005e02:	3301      	adds	r3, #1
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
 1005e04:	491b      	ldr	r1, [pc, #108]	; (1005e74 <mayfly_enqueue+0xa4>)
	m->_req = ack + 1;
 1005e06:	b2db      	uxtb	r3, r3
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
 1005e08:	440a      	add	r2, r1
 1005e0a:	6860      	ldr	r0, [r4, #4]
 1005e0c:	4621      	mov	r1, r4
	m->_req = ack + 1;
 1005e0e:	7023      	strb	r3, [r4, #0]
	memq_enqueue(m->_link, m, &mft[callee_id][caller_id].tail);
 1005e10:	f7ff ff6a 	bl	1005ce8 <memq_enqueue>

mayfly_enqueue_pend:
	/* set mayfly callee pending */
	mfp[callee_id] = 1U;
 1005e14:	2201      	movs	r2, #1
 1005e16:	4b18      	ldr	r3, [pc, #96]	; (1005e78 <mayfly_enqueue+0xa8>)

	/* pend the callee for execution */
	mayfly_pend(caller_id, callee_id);
 1005e18:	4630      	mov	r0, r6
 1005e1a:	4629      	mov	r1, r5
	mfp[callee_id] = 1U;
 1005e1c:	555a      	strb	r2, [r3, r5]
	mayfly_pend(caller_id, callee_id);
 1005e1e:	f00c fb7d 	bl	101251c <mayfly_pend>

	return 0;
 1005e22:	2000      	movs	r0, #0
}
 1005e24:	bd70      	pop	{r4, r5, r6, pc}
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
 1005e26:	f00c fb5b 	bl	10124e0 <mayfly_prio_is_equal>
 1005e2a:	2800      	cmp	r0, #0
 1005e2c:	d0d5      	beq.n	1005dda <mayfly_enqueue+0xa>
		!mayfly_is_enabled(caller_id, callee_id) ||
 1005e2e:	4629      	mov	r1, r5
 1005e30:	4630      	mov	r0, r6
 1005e32:	f00c fb41 	bl	10124b8 <mayfly_is_enabled>
	chain = chain || !mayfly_prio_is_equal(caller_id, callee_id) ||
 1005e36:	2800      	cmp	r0, #0
 1005e38:	d0cf      	beq.n	1005dda <mayfly_enqueue+0xa>
		(mft[callee_id][caller_id].disable_req !=
 1005e3a:	eb05 0345 	add.w	r3, r5, r5, lsl #1
 1005e3e:	011a      	lsls	r2, r3, #4
 1005e40:	490c      	ldr	r1, [pc, #48]	; (1005e74 <mayfly_enqueue+0xa4>)
 1005e42:	eb06 0346 	add.w	r3, r6, r6, lsl #1
 1005e46:	eb02 0383 	add.w	r3, r2, r3, lsl #2
 1005e4a:	440b      	add	r3, r1
		!mayfly_is_enabled(caller_id, callee_id) ||
 1005e4c:	7a9a      	ldrb	r2, [r3, #10]
 1005e4e:	7adb      	ldrb	r3, [r3, #11]
 1005e50:	429a      	cmp	r2, r3
 1005e52:	d1c2      	bne.n	1005dda <mayfly_enqueue+0xa>
	ack = m->_ack;
 1005e54:	7863      	ldrb	r3, [r4, #1]
	state = (m->_req - ack) & 0x03;
 1005e56:	7822      	ldrb	r2, [r4, #0]
 1005e58:	1ad2      	subs	r2, r2, r3
	if (state != 0U) {
 1005e5a:	0792      	lsls	r2, r2, #30
 1005e5c:	d002      	beq.n	1005e64 <mayfly_enqueue+0x94>
		m->_req = ack + 2;
 1005e5e:	3302      	adds	r3, #2
 1005e60:	b2db      	uxtb	r3, r3
 1005e62:	7023      	strb	r3, [r4, #0]
		m->fp(m->param);
 1005e64:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
 1005e68:	4798      	blx	r3
		return 0;
 1005e6a:	2000      	movs	r0, #0
}
 1005e6c:	bd70      	pop	{r4, r5, r6, pc}
			return 1;
 1005e6e:	4610      	mov	r0, r2
}
 1005e70:	bd70      	pop	{r4, r5, r6, pc}
 1005e72:	bf00      	nop
 1005e74:	21000a84 	.word	0x21000a84
 1005e78:	21000a80 	.word	0x21000a80

01005e7c <mayfly_run>:
{
	u8_t disable = 0U;
	u8_t enable = 0U;
	u8_t caller_id;

	if (!mfp[callee_id]) {
 1005e7c:	494c      	ldr	r1, [pc, #304]	; (1005fb0 <mayfly_run+0x134>)
 1005e7e:	5c0b      	ldrb	r3, [r1, r0]
 1005e80:	2b00      	cmp	r3, #0
 1005e82:	f000 8093 	beq.w	1005fac <mayfly_run+0x130>
		return;
	}
	mfp[callee_id] = 0U;
 1005e86:	2200      	movs	r2, #0
{
 1005e88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
 1005e8c:	4b49      	ldr	r3, [pc, #292]	; (1005fb4 <mayfly_run+0x138>)
 1005e8e:	ebc0 1b00 	rsb	fp, r0, r0, lsl #4
{
 1005e92:	b087      	sub	sp, #28
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
 1005e94:	eb03 0b8b 	add.w	fp, r3, fp, lsl #2
	u8_t enable = 0U;
 1005e98:	9203      	str	r2, [sp, #12]
	u8_t disable = 0U;
 1005e9a:	9201      	str	r2, [sp, #4]
	mfp[callee_id] = 0U;
 1005e9c:	540a      	strb	r2, [r1, r0]
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
 1005e9e:	f10b 0204 	add.w	r2, fp, #4

	/* iterate through each caller queue to this callee_id */
	caller_id = MAYFLY_CALLER_COUNT;
	while (caller_id--) {
 1005ea2:	f04f 0803 	mov.w	r8, #3
 1005ea6:	4691      	mov	r9, r2
 1005ea8:	eb00 0740 	add.w	r7, r0, r0, lsl #1
 1005eac:	eb03 1707 	add.w	r7, r3, r7, lsl #4
 1005eb0:	9002      	str	r0, [sp, #8]
		memq_link_t *link;
		struct mayfly *m = 0;
 1005eb2:	2300      	movs	r3, #0

		/* fetch mayfly in callee queue, if any */
		link = memq_peek(mft[callee_id][caller_id].head,
 1005eb4:	e9d7 0109 	ldrd	r0, r1, [r7, #36]	; 0x24
 1005eb8:	aa05      	add	r2, sp, #20
		struct mayfly *m = 0;
 1005eba:	9305      	str	r3, [sp, #20]
		link = memq_peek(mft[callee_id][caller_id].head,
 1005ebc:	f7ff ff1c 	bl	1005cf8 <memq_peek>
				 mft[callee_id][caller_id].tail,
				 (void **)&m);
		while (link) {
 1005ec0:	f107 0624 	add.w	r6, r7, #36	; 0x24
 1005ec4:	4683      	mov	fp, r0
 1005ec6:	b380      	cbz	r0, 1005f2a <mayfly_run+0xae>
#if defined(MAYFLY_UT)
			_state = 0U;
#endif /* MAYFLY_UT */

			/* execute work if ready */
			state = (m->_req - m->_ack) & 0x03;
 1005ec8:	9c05      	ldr	r4, [sp, #20]
 1005eca:	7825      	ldrb	r5, [r4, #0]
 1005ecc:	7863      	ldrb	r3, [r4, #1]
 1005ece:	1aed      	subs	r5, r5, r3
 1005ed0:	f005 0503 	and.w	r5, r5, #3
			if (state == 1U) {
 1005ed4:	2d01      	cmp	r5, #1
 1005ed6:	d106      	bne.n	1005ee6 <mayfly_run+0x6a>
#if defined(MAYFLY_UT)
				_state = 1U;
#endif /* MAYFLY_UT */

				/* mark mayfly as ran */
				m->_ack--;
 1005ed8:	3b01      	subs	r3, #1
 1005eda:	7063      	strb	r3, [r4, #1]

				/* call the mayfly function */
				m->fp(m->param);
 1005edc:	e9d4 0302 	ldrd	r0, r3, [r4, #8]
 1005ee0:	4798      	blx	r3
 1005ee2:	9c05      	ldr	r4, [sp, #20]
 1005ee4:	7863      	ldrb	r3, [r4, #1]
	req = m->_req;
 1005ee6:	7822      	ldrb	r2, [r4, #0]
	if (((req - m->_ack) & 0x03) != 1U) {
 1005ee8:	1ad3      	subs	r3, r2, r3
 1005eea:	f003 0303 	and.w	r3, r3, #3
 1005eee:	2b01      	cmp	r3, #1
	req = m->_req;
 1005ef0:	fa5f fa82 	uxtb.w	sl, r2
	if (((req - m->_ack) & 0x03) != 1U) {
 1005ef4:	d00f      	beq.n	1005f16 <mayfly_run+0x9a>
		memq_dequeue(mft[callee_id][caller_id].tail,
 1005ef6:	2200      	movs	r2, #0
 1005ef8:	4631      	mov	r1, r6
 1005efa:	6ab8      	ldr	r0, [r7, #40]	; 0x28
 1005efc:	f7ff ff04 	bl	1005d08 <memq_dequeue>
		ack = m->_ack;
 1005f00:	7862      	ldrb	r2, [r4, #1]
		if (((m->_req - ack) & 0x03) == 1U) {
 1005f02:	7823      	ldrb	r3, [r4, #0]
		m->_link = link;
 1005f04:	f8c4 b004 	str.w	fp, [r4, #4]
		if (((m->_req - ack) & 0x03) == 1U) {
 1005f08:	1a9b      	subs	r3, r3, r2
 1005f0a:	f003 0303 	and.w	r3, r3, #3
 1005f0e:	2b01      	cmp	r3, #1
		m->_ack = req;
 1005f10:	f884 a001 	strb.w	sl, [r4, #1]
		if (((m->_req - ack) & 0x03) == 1U) {
 1005f14:	d043      	beq.n	1005f9e <mayfly_run+0x122>

			/* dequeue if not re-pended */
			dequeue(callee_id, caller_id, link, m);

			/* fetch next mayfly in callee queue, if any */
			link = memq_peek(mft[callee_id][caller_id].head,
 1005f16:	e9d7 0109 	ldrd	r0, r1, [r7, #36]	; 0x24
 1005f1a:	aa05      	add	r2, sp, #20
 1005f1c:	f7ff feec 	bl	1005cf8 <memq_peek>
 */
#if defined(CONFIG_BT_MAYFLY_YIELD_AFTER_CALL)
			/* yield out of mayfly_run if a mayfly function was
			 * called.
			 */
			if (state == 1U) {
 1005f20:	2d01      	cmp	r5, #1
			link = memq_peek(mft[callee_id][caller_id].head,
 1005f22:	4683      	mov	fp, r0
			if (state == 1U) {
 1005f24:	d029      	beq.n	1005f7a <mayfly_run+0xfe>
		while (link) {
 1005f26:	2800      	cmp	r0, #0
 1005f28:	d1ce      	bne.n	1005ec8 <mayfly_run+0x4c>
				}
			}
#endif
		}

		if (mft[callee_id][caller_id].disable_req !=
 1005f2a:	f897 302e 	ldrb.w	r3, [r7, #46]	; 0x2e
 1005f2e:	f897 202f 	ldrb.w	r2, [r7, #47]	; 0x2f
 1005f32:	429a      	cmp	r2, r3
 1005f34:	d003      	beq.n	1005f3e <mayfly_run+0xc2>
		    mft[callee_id][caller_id].disable_ack) {
			disable = 1U;
 1005f36:	2201      	movs	r2, #1

			mft[callee_id][caller_id].disable_ack =
 1005f38:	f887 302f 	strb.w	r3, [r7, #47]	; 0x2f
			disable = 1U;
 1005f3c:	9201      	str	r2, [sp, #4]
				mft[callee_id][caller_id].disable_req;
		}

		if (mft[callee_id][caller_id].enable_req !=
 1005f3e:	f897 302c 	ldrb.w	r3, [r7, #44]	; 0x2c
 1005f42:	f897 202d 	ldrb.w	r2, [r7, #45]	; 0x2d
 1005f46:	429a      	cmp	r2, r3
 1005f48:	d003      	beq.n	1005f52 <mayfly_run+0xd6>
		    mft[callee_id][caller_id].enable_ack) {
			enable = 1U;
 1005f4a:	2201      	movs	r2, #1

			mft[callee_id][caller_id].enable_ack =
 1005f4c:	f887 302d 	strb.w	r3, [r7, #45]	; 0x2d
			enable = 1U;
 1005f50:	9203      	str	r2, [sp, #12]
	while (caller_id--) {
 1005f52:	f108 38ff 	add.w	r8, r8, #4294967295
 1005f56:	fa5f f888 	uxtb.w	r8, r8
 1005f5a:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
 1005f5e:	f1a7 070c 	sub.w	r7, r7, #12
 1005f62:	d1a6      	bne.n	1005eb2 <mayfly_run+0x36>
				mft[callee_id][caller_id].enable_req;
		}
	}

	if (disable && !enable) {
 1005f64:	e9dd 3a01 	ldrd	r3, sl, [sp, #4]
 1005f68:	b1b3      	cbz	r3, 1005f98 <mayfly_run+0x11c>
 1005f6a:	9b03      	ldr	r3, [sp, #12]
 1005f6c:	b9a3      	cbnz	r3, 1005f98 <mayfly_run+0x11c>
		mayfly_enable_cb(callee_id, callee_id, 0);
 1005f6e:	461a      	mov	r2, r3
 1005f70:	4651      	mov	r1, sl
 1005f72:	4650      	mov	r0, sl
 1005f74:	f00c fa8c 	bl	1012490 <mayfly_enable_cb>
 1005f78:	e00e      	b.n	1005f98 <mayfly_run+0x11c>
				if (caller_id || link) {
 1005f7a:	f1b8 0f00 	cmp.w	r8, #0
 1005f7e:	d101      	bne.n	1005f84 <mayfly_run+0x108>
 1005f80:	2800      	cmp	r0, #0
 1005f82:	d0d2      	beq.n	1005f2a <mayfly_run+0xae>
					mfp[callee_id] = 1U;
 1005f84:	2301      	movs	r3, #1
 1005f86:	f8dd a008 	ldr.w	sl, [sp, #8]
 1005f8a:	4a09      	ldr	r2, [pc, #36]	; (1005fb0 <mayfly_run+0x134>)
					mayfly_pend(callee_id, callee_id);
 1005f8c:	4651      	mov	r1, sl
 1005f8e:	4650      	mov	r0, sl
					mfp[callee_id] = 1U;
 1005f90:	f802 300a 	strb.w	r3, [r2, sl]
					mayfly_pend(callee_id, callee_id);
 1005f94:	f00c fac2 	bl	101251c <mayfly_pend>
	}
}
 1005f98:	b007      	add	sp, #28
 1005f9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			m->_ack = ack;
 1005f9e:	7062      	strb	r2, [r4, #1]
			memq_enqueue(link, m, &mft[callee_id][callee_id].tail);
 1005fa0:	4621      	mov	r1, r4
 1005fa2:	4658      	mov	r0, fp
 1005fa4:	464a      	mov	r2, r9
 1005fa6:	f7ff fe9f 	bl	1005ce8 <memq_enqueue>
 1005faa:	e7b4      	b.n	1005f16 <mayfly_run+0x9a>
 1005fac:	4770      	bx	lr
 1005fae:	bf00      	nop
 1005fb0:	21000a80 	.word	0x21000a80
 1005fb4:	21000a84 	.word	0x21000a84

01005fb8 <util_ones_count_get>:
 */
u8_t util_ones_count_get(u8_t *octets, u8_t octets_len)
{
	u8_t one_count = 0U;

	while (octets_len--) {
 1005fb8:	b1a9      	cbz	r1, 1005fe6 <util_ones_count_get+0x2e>
 1005fba:	4603      	mov	r3, r0
	u8_t one_count = 0U;
 1005fbc:	2000      	movs	r0, #0
 1005fbe:	1e4a      	subs	r2, r1, #1
 1005fc0:	b2d2      	uxtb	r2, r2
{
 1005fc2:	b410      	push	{r4}
 1005fc4:	1e59      	subs	r1, r3, #1
 1005fc6:	189c      	adds	r4, r3, r2
		u8_t bite;

		bite = *octets;
 1005fc8:	f811 3f01 	ldrb.w	r3, [r1, #1]!
		while (bite) {
 1005fcc:	b13b      	cbz	r3, 1005fde <util_ones_count_get+0x26>
			bite &= (bite - 1);
 1005fce:	b25b      	sxtb	r3, r3
 1005fd0:	1e5a      	subs	r2, r3, #1
 1005fd2:	4013      	ands	r3, r2
			one_count++;
 1005fd4:	3001      	adds	r0, #1
		while (bite) {
 1005fd6:	f013 03ff 	ands.w	r3, r3, #255	; 0xff
			one_count++;
 1005fda:	b2c0      	uxtb	r0, r0
		while (bite) {
 1005fdc:	d1f7      	bne.n	1005fce <util_ones_count_get+0x16>
	while (octets_len--) {
 1005fde:	42a1      	cmp	r1, r4
 1005fe0:	d1f2      	bne.n	1005fc8 <util_ones_count_get+0x10>
		}
		octets++;
	}

	return one_count;
}
 1005fe2:	bc10      	pop	{r4}
 1005fe4:	4770      	bx	lr
	u8_t one_count = 0U;
 1005fe6:	4608      	mov	r0, r1
}
 1005fe8:	4770      	bx	lr
 1005fea:	bf00      	nop

01005fec <ticker_worker>:
	u32_t ticks_elapsed;
	u32_t ticks_expired;
	u8_t ticker_id_head;

	/* Defer worker if job running */
	instance->worker_trigger = 1U;
 1005fec:	2301      	movs	r3, #1
{
 1005fee:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	if (instance->job_guard) {
 1005ff2:	7f82      	ldrb	r2, [r0, #30]
{
 1005ff4:	b089      	sub	sp, #36	; 0x24
	if (instance->job_guard) {
 1005ff6:	9203      	str	r2, [sp, #12]
	instance->worker_trigger = 1U;
 1005ff8:	77c3      	strb	r3, [r0, #31]
	if (instance->job_guard) {
 1005ffa:	2a00      	cmp	r2, #0
 1005ffc:	f040 80a5 	bne.w	100614a <ticker_worker+0x15e>
		return;
	}

	/* If no tickers queued (active), do nothing */
	if (instance->ticker_id_head == TICKER_NULL) {
 1006000:	7f43      	ldrb	r3, [r0, #29]
 1006002:	4681      	mov	r9, r0
 1006004:	2bff      	cmp	r3, #255	; 0xff
 1006006:	f000 809f 	beq.w	1006148 <ticker_worker+0x15c>
		instance->worker_trigger = 0U;
		return;
	}

	/* Get ticks elapsed since last job execution */
	ticks_elapsed = ticker_ticks_diff_get(cntr_cnt_get(),
 100600a:	f00b fca1 	bl	1011950 <cntr_cnt_get>
 * @param ticks_now Highest tick count (now)
 * @param ticks_old Tick count to subtract from ticks_now
 */
u32_t ticker_ticks_diff_get(u32_t ticks_now, u32_t ticks_old)
{
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 100600e:	f8d9 2014 	ldr.w	r2, [r9, #20]
	if (instance->ticker_id_slot_previous != TICKER_NULL) {
 1006012:	f899 301c 	ldrb.w	r3, [r9, #28]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1006016:	1a80      	subs	r0, r0, r2
	if (instance->ticker_id_slot_previous != TICKER_NULL) {
 1006018:	2bff      	cmp	r3, #255	; 0xff
	ticker_id_head = instance->ticker_id_head;
 100601a:	f899 501d 	ldrb.w	r5, [r9, #29]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 100601e:	f020 4a7f 	bic.w	sl, r0, #4278190080	; 0xff000000
	if (instance->ticker_id_slot_previous != TICKER_NULL) {
 1006022:	f000 8101 	beq.w	1006228 <ticker_worker+0x23c>
		if (instance->ticks_slot_previous > ticks_elapsed) {
 1006026:	f8d9 3018 	ldr.w	r3, [r9, #24]
	u8_t slot_reserved = 0;
 100602a:	4553      	cmp	r3, sl
 100602c:	bf94      	ite	ls
 100602e:	2300      	movls	r3, #0
 1006030:	2301      	movhi	r3, #1
 1006032:	9301      	str	r3, [sp, #4]
	while (ticker_id_head != TICKER_NULL) {
 1006034:	2dff      	cmp	r5, #255	; 0xff
	node = &instance->nodes[0];
 1006036:	f8d9 8000 	ldr.w	r8, [r9]
	while (ticker_id_head != TICKER_NULL) {
 100603a:	f000 80f8 	beq.w	100622e <ticker_worker+0x242>
	ticks_expired = 0U;
 100603e:	2600      	movs	r6, #0
			ticker->ext_data->ticks_drift = 0U;
 1006040:	f8cd 9008 	str.w	r9, [sp, #8]
		ticker = &node[ticker_id_head];
 1006044:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 1006048:	eb08 1405 	add.w	r4, r8, r5, lsl #4
		ticks_to_expire = ticker->ticks_to_expire;
 100604c:	68a3      	ldr	r3, [r4, #8]
		ticker = &node[ticker_id_head];
 100604e:	012d      	lsls	r5, r5, #4
		if (ticks_elapsed < ticks_to_expire) {
 1006050:	4553      	cmp	r3, sl
 1006052:	d855      	bhi.n	1006100 <ticker_worker+0x114>
		if (ticker->ticks_slot != 0U &&
 1006054:	69a7      	ldr	r7, [r4, #24]
		ticker_id_head = ticker->next;
 1006056:	f818 5005 	ldrb.w	r5, [r8, r5]
		ticks_elapsed -= ticks_to_expire;
 100605a:	ebaa 0a03 	sub.w	sl, sl, r3
		ticks_expired += ticks_to_expire;
 100605e:	441e      	add	r6, r3
		if (ticker->ticks_slot != 0U &&
 1006060:	2f00      	cmp	r7, #0
 1006062:	d078      	beq.n	1006156 <ticker_worker+0x16a>
 1006064:	9b01      	ldr	r3, [sp, #4]
 1006066:	2b00      	cmp	r3, #0
 1006068:	d07b      	beq.n	1006162 <ticker_worker+0x176>
 100606a:	f8b4 c01e 	ldrh.w	ip, [r4, #30]
			struct ticker_ext *ext_data = ticker->ext_data;
 100606e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
			if (ext_data &&
 1006070:	b153      	cbz	r3, 1006088 <ticker_worker+0x9c>
 1006072:	681a      	ldr	r2, [r3, #0]
 1006074:	b12a      	cbz	r2, 1006082 <ticker_worker+0x96>
			    ext_data->ticks_slot_window != 0U &&
 1006076:	7a1a      	ldrb	r2, [r3, #8]
 1006078:	b91a      	cbnz	r2, 1006082 <ticker_worker+0x96>
			    TICKER_RESCHEDULE_STATE_NONE &&
 100607a:	8ba2      	ldrh	r2, [r4, #28]
 100607c:	4562      	cmp	r2, ip
 100607e:	f240 80cf 	bls.w	1006220 <ticker_worker+0x234>
				ext_data->reschedule_state =
 1006082:	f04f 0200 	mov.w	r2, #0
 1006086:	721a      	strb	r2, [r3, #8]
			ticker->lazy_current++;
 1006088:	f10c 0c01 	add.w	ip, ip, #1
			if ((ticker->must_expire == 0U) ||
 100608c:	f894 202c 	ldrb.w	r2, [r4, #44]	; 0x2c
			ticker->lazy_current++;
 1006090:	fa1f fc8c 	uxth.w	ip, ip
 1006094:	f8a4 c01e 	strh.w	ip, [r4, #30]
			if ((ticker->must_expire == 0U) ||
 1006098:	2a00      	cmp	r2, #0
 100609a:	d02f      	beq.n	10060fc <ticker_worker+0x110>
 100609c:	8ba2      	ldrh	r2, [r4, #28]
 100609e:	4562      	cmp	r2, ip
 10060a0:	d22c      	bcs.n	10060fc <ticker_worker+0x110>
			    (ticker->lazy_periodic >= ticker->lazy_current) ||
 10060a2:	2b00      	cmp	r3, #0
 10060a4:	f000 80ba 	beq.w	100621c <ticker_worker+0x230>
			    TICKER_RESCHEDULE_PENDING(ticker)) {
 10060a8:	7a1a      	ldrb	r2, [r3, #8]
 10060aa:	2a01      	cmp	r2, #1
 10060ac:	d026      	beq.n	10060fc <ticker_worker+0x110>
			must_expire_skip = 1U;
 10060ae:	2701      	movs	r7, #1
			ticker->ext_data->ticks_drift = 0U;
 10060b0:	2200      	movs	r2, #0
 10060b2:	605a      	str	r2, [r3, #4]
			ticker->ext_data->reschedule_state =
 10060b4:	721a      	strb	r2, [r3, #8]
		if (((ticker->req - ticker->ack) & 0xff) != 1U) {
 10060b6:	78a2      	ldrb	r2, [r4, #2]
 10060b8:	7863      	ldrb	r3, [r4, #1]
 10060ba:	1a9b      	subs	r3, r3, r2
 10060bc:	b2db      	uxtb	r3, r3
 10060be:	2b01      	cmp	r3, #1
 10060c0:	d11c      	bne.n	10060fc <ticker_worker+0x110>
		if (ticker->timeout_func) {
 10060c2:	f8d4 900c 	ldr.w	r9, [r4, #12]
		ticker->ack--;
 10060c6:	3a01      	subs	r2, #1
 10060c8:	70a2      	strb	r2, [r4, #2]
		if (ticker->timeout_func) {
 10060ca:	f1b9 0f00 	cmp.w	r9, #0
 10060ce:	d015      	beq.n	10060fc <ticker_worker+0x110>
					   ticks_expired -
 10060d0:	9a02      	ldr	r2, [sp, #8]
 10060d2:	6963      	ldr	r3, [r4, #20]
 10060d4:	6950      	ldr	r0, [r2, #20]
 10060d6:	1af3      	subs	r3, r6, r3
 10060d8:	4418      	add	r0, r3
			ticker->timeout_func(ticks_at_expire,
 10060da:	6a61      	ldr	r1, [r4, #36]	; 0x24
 10060dc:	6923      	ldr	r3, [r4, #16]
			ticks_at_expire = (instance->ticks_current +
 10060de:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
			ticker->timeout_func(ticks_at_expire,
 10060e2:	2f00      	cmp	r7, #0
 10060e4:	f040 8096 	bne.w	1006214 <ticker_worker+0x228>
 10060e8:	8be2      	ldrh	r2, [r4, #30]
 10060ea:	47c8      	blx	r9
				if (ticker->ticks_slot != 0U) {
 10060ec:	69a3      	ldr	r3, [r4, #24]
				ticker->lazy_current = 0U;
 10060ee:	83e7      	strh	r7, [r4, #30]
					slot_reserved = 1U;
 10060f0:	2b00      	cmp	r3, #0
 10060f2:	9b01      	ldr	r3, [sp, #4]
 10060f4:	bf18      	it	ne
 10060f6:	2301      	movne	r3, #1
				ticker->force = 0U;
 10060f8:	70e7      	strb	r7, [r4, #3]
					slot_reserved = 1U;
 10060fa:	9301      	str	r3, [sp, #4]
	while (ticker_id_head != TICKER_NULL) {
 10060fc:	2dff      	cmp	r5, #255	; 0xff
 10060fe:	d1a1      	bne.n	1006044 <ticker_worker+0x58>
 1006100:	4631      	mov	r1, r6
 1006102:	f8dd 9008 	ldr.w	r9, [sp, #8]
	if (instance->ticks_elapsed_first == instance->ticks_elapsed_last) {
 1006106:	f899 300b 	ldrb.w	r3, [r9, #11]
 100610a:	f899 200a 	ldrb.w	r2, [r9, #10]
 100610e:	429a      	cmp	r2, r3
 1006110:	d109      	bne.n	1006126 <ticker_worker+0x13a>
	u8_t idx = *ticks_elapsed_index + 1;
 1006112:	3201      	adds	r2, #1
 1006114:	b2d2      	uxtb	r2, r2
	if (idx == DOUBLE_BUFFER_SIZE) {
 1006116:	2a02      	cmp	r2, #2
 1006118:	bf16      	itet	ne
 100611a:	4613      	movne	r3, r2
 100611c:	2300      	moveq	r3, #0
	*ticks_elapsed_index = idx;
 100611e:	9303      	strne	r3, [sp, #12]
 1006120:	9a03      	ldr	r2, [sp, #12]
 1006122:	f889 200b 	strb.w	r2, [r9, #11]
	instance->worker_trigger = 0U;
 1006126:	2200      	movs	r2, #0
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
 1006128:	f8d9 4024 	ldr.w	r4, [r9, #36]	; 0x24
	instance->ticks_elapsed[instance->ticks_elapsed_last] = ticks_expired;
 100612c:	eb09 0383 	add.w	r3, r9, r3, lsl #2
 1006130:	60d9      	str	r1, [r3, #12]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
 1006132:	2003      	movs	r0, #3
	instance->worker_trigger = 0U;
 1006134:	f889 201f 	strb.w	r2, [r9, #31]
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
 1006138:	464b      	mov	r3, r9
 100613a:	2201      	movs	r2, #1
 100613c:	2104      	movs	r1, #4
 100613e:	46a4      	mov	ip, r4
}
 1006140:	b009      	add	sp, #36	; 0x24
 1006142:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	instance->sched_cb(TICKER_CALL_ID_WORKER, TICKER_CALL_ID_JOB, 1,
 1006146:	4760      	bx	ip
		instance->worker_trigger = 0U;
 1006148:	77c2      	strb	r2, [r0, #31]
}
 100614a:	b009      	add	sp, #36	; 0x24
 100614c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1006150:	4674      	mov	r4, lr
 1006152:	e9dd 6506 	ldrd	r6, r5, [sp, #24]
		if (ticker->ext_data) {
 1006156:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1006158:	b10b      	cbz	r3, 100615e <ticker_worker+0x172>
 100615a:	2700      	movs	r7, #0
 100615c:	e7a8      	b.n	10060b0 <ticker_worker+0xc4>
 100615e:	461f      	mov	r7, r3
 1006160:	e7a9      	b.n	10060b6 <ticker_worker+0xca>
	if ((ticker->priority != TICKER_PRIORITY_CRITICAL) &&
 1006162:	f994 302d 	ldrsb.w	r3, [r4, #45]	; 0x2d
 1006166:	9304      	str	r3, [sp, #16]
 1006168:	3380      	adds	r3, #128	; 0x80
 100616a:	d0f4      	beq.n	1006156 <ticker_worker+0x16a>
 100616c:	2dff      	cmp	r5, #255	; 0xff
 100616e:	d0f2      	beq.n	1006156 <ticker_worker+0x16a>
		s32_t lazy_current = ticker->lazy_current;
 1006170:	f8b4 c01e 	ldrh.w	ip, [r4, #30]
		u32_t current_age = ticker->ticks_periodic +
 1006174:	46ab      	mov	fp, r5
		s32_t lazy_current = ticker->lazy_current;
 1006176:	4662      	mov	r2, ip
		if (lazy_current >= ticker->lazy_periodic) {
 1006178:	8ba3      	ldrh	r3, [r4, #28]
		u32_t current_age = ticker->ticks_periodic +
 100617a:	6861      	ldr	r1, [r4, #4]
		if (lazy_current >= ticker->lazy_periodic) {
 100617c:	459c      	cmp	ip, r3
			lazy_current -= ticker->lazy_periodic;
 100617e:	bf28      	it	cs
 1006180:	ebac 0203 	subcs.w	r2, ip, r3
				(lazy_current - ticker->priority);
 1006184:	9b04      	ldr	r3, [sp, #16]
		u32_t current_age = ticker->ticks_periodic +
 1006186:	e9cd 6506 	strd	r6, r5, [sp, #24]
				(lazy_current - ticker->priority);
 100618a:	1ad3      	subs	r3, r2, r3
		u32_t current_age = ticker->ticks_periodic +
 100618c:	fb02 1201 	mla	r2, r2, r1, r1
				(lazy_current - ticker->priority);
 1006190:	9305      	str	r3, [sp, #20]
		u32_t current_age = ticker->ticks_periodic +
 1006192:	9d04      	ldr	r5, [sp, #16]
		u32_t acc_ticks_to_expire = 0U;
 1006194:	2000      	movs	r0, #0
		u32_t current_age = ticker->ticks_periodic +
 1006196:	f8cd c010 	str.w	ip, [sp, #16]
 100619a:	46a6      	mov	lr, r4
 100619c:	4616      	mov	r6, r2
 100619e:	46bc      	mov	ip, r7
 10061a0:	465b      	mov	r3, fp
 10061a2:	f8dd 9014 	ldr.w	r9, [sp, #20]
 10061a6:	e003      	b.n	10061b0 <ticker_worker+0x1c4>
			id_head = ticker_next->next;
 10061a8:	f818 3003 	ldrb.w	r3, [r8, r3]
		while (id_head != TICKER_NULL) {
 10061ac:	2bff      	cmp	r3, #255	; 0xff
 10061ae:	d0cf      	beq.n	1006150 <ticker_worker+0x164>
			struct ticker_node *ticker_next = &nodes[id_head];
 10061b0:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 10061b4:	eb08 1203 	add.w	r2, r8, r3, lsl #4
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
 10061b8:	6897      	ldr	r7, [r2, #8]
			struct ticker_node *ticker_next = &nodes[id_head];
 10061ba:	011b      	lsls	r3, r3, #4
			acc_ticks_to_expire += ticker_next->ticks_to_expire;
 10061bc:	4438      	add	r0, r7
			if (acc_ticks_to_expire > ticker->ticks_slot) {
 10061be:	4584      	cmp	ip, r0
 10061c0:	d3c6      	bcc.n	1006150 <ticker_worker+0x164>
			if (ticker_next->ticks_slot == 0U) {
 10061c2:	6991      	ldr	r1, [r2, #24]
 10061c4:	2900      	cmp	r1, #0
 10061c6:	d0ef      	beq.n	10061a8 <ticker_worker+0x1bc>
			s32_t lazy_next = ticker_next->lazy_current;
 10061c8:	f8b2 b01e 	ldrh.w	fp, [r2, #30]
				ticker_next->lazy_periodic > lazy_next;
 10061cc:	8b91      	ldrh	r1, [r2, #28]
			if (!lazy_next_periodic_skip) {
 10061ce:	458b      	cmp	fp, r1
 10061d0:	d3ea      	bcc.n	10061a8 <ticker_worker+0x1bc>
			u32_t next_age = (ticker_next->ticks_periodic == 0U ?
 10061d2:	6854      	ldr	r4, [r2, #4]
				lazy_next -= ticker_next->lazy_periodic;
 10061d4:	ebab 0101 	sub.w	r1, fp, r1
				ticker_next->priority;
 10061d8:	f992 b02d 	ldrsb.w	fp, [r2, #45]	; 0x2d
					  0U :
 10061dc:	b114      	cbz	r4, 10061e4 <ticker_worker+0x1f8>
 10061de:	1be7      	subs	r7, r4, r7
			u32_t next_age = (ticker_next->ticks_periodic == 0U ?
 10061e0:	fb04 7401 	mla	r4, r4, r1, r7
			u8_t next_force = (ticker_next->force > ticker->force);
 10061e4:	78d2      	ldrb	r2, [r2, #3]
 10061e6:	f89e 7003 	ldrb.w	r7, [lr, #3]
				(lazy_next - ticker_next->priority) >
 10061ea:	eba1 010b 	sub.w	r1, r1, fp
			if (!lazy_next_periodic_skip &&
 10061ee:	4297      	cmp	r7, r2
 10061f0:	d30a      	bcc.n	1006208 <ticker_worker+0x21c>
			    (next_force ||
 10061f2:	f11b 0f80 	cmn.w	fp, #128	; 0x80
 10061f6:	d007      	beq.n	1006208 <ticker_worker+0x21c>
			     next_is_critical ||
 10061f8:	4589      	cmp	r9, r1
 10061fa:	da01      	bge.n	1006200 <ticker_worker+0x214>
			    (next_has_priority && !current_is_older) ||
 10061fc:	42a6      	cmp	r6, r4
 10061fe:	d903      	bls.n	1006208 <ticker_worker+0x21c>
 1006200:	455d      	cmp	r5, fp
 1006202:	d1d1      	bne.n	10061a8 <ticker_worker+0x1bc>
			    (equal_priority && next_is_older))) {
 1006204:	42a6      	cmp	r6, r4
 1006206:	d2cf      	bcs.n	10061a8 <ticker_worker+0x1bc>
 1006208:	4674      	mov	r4, lr
 100620a:	e9dd 6506 	ldrd	r6, r5, [sp, #24]
 100620e:	f8dd c010 	ldr.w	ip, [sp, #16]
 1006212:	e72c      	b.n	100606e <ticker_worker+0x82>
			ticker->timeout_func(ticks_at_expire,
 1006214:	f64f 72ff 	movw	r2, #65535	; 0xffff
 1006218:	47c8      	blx	r9
			if (must_expire_skip == 0U) {
 100621a:	e76f      	b.n	10060fc <ticker_worker+0x110>
			must_expire_skip = 1U;
 100621c:	2701      	movs	r7, #1
 100621e:	e74a      	b.n	10060b6 <ticker_worker+0xca>
				ext_data->reschedule_state =
 1006220:	f04f 0201 	mov.w	r2, #1
 1006224:	721a      	strb	r2, [r3, #8]
 1006226:	e72f      	b.n	1006088 <ticker_worker+0x9c>
	u8_t slot_reserved = 0;
 1006228:	9b03      	ldr	r3, [sp, #12]
 100622a:	9301      	str	r3, [sp, #4]
 100622c:	e702      	b.n	1006034 <ticker_worker+0x48>
	ticks_expired = 0U;
 100622e:	2300      	movs	r3, #0
 1006230:	4619      	mov	r1, r3
 1006232:	e768      	b.n	1006106 <ticker_worker+0x11a>

01006234 <ticker_job>:
	if (instance->worker_trigger) {
 1006234:	7fc2      	ldrb	r2, [r0, #31]
 1006236:	2a00      	cmp	r2, #0
 1006238:	f040 8600 	bne.w	1006e3c <ticker_job+0xc08>
{
 100623c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1006240:	4683      	mov	fp, r0
	instance->job_guard = 1U;
 1006242:	2001      	movs	r0, #1
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
 1006244:	f89b 300a 	ldrb.w	r3, [fp, #10]
 1006248:	f89b 100b 	ldrb.w	r1, [fp, #11]
	instance->job_guard = 1U;
 100624c:	f88b 001e 	strb.w	r0, [fp, #30]
	ticks_previous = instance->ticks_current;
 1006250:	f8db 0014 	ldr.w	r0, [fp, #20]
{
 1006254:	b08f      	sub	sp, #60	; 0x3c
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
 1006256:	4299      	cmp	r1, r3
	ticks_previous = instance->ticks_current;
 1006258:	9005      	str	r0, [sp, #20]
	if (instance->ticks_elapsed_first != instance->ticks_elapsed_last) {
 100625a:	f000 8094 	beq.w	1006386 <ticker_job+0x152>
	u8_t idx = *ticks_elapsed_index + 1;
 100625e:	3301      	adds	r3, #1
 1006260:	b2db      	uxtb	r3, r3
	if (idx == DOUBLE_BUFFER_SIZE) {
 1006262:	2b02      	cmp	r3, #2
		idx = 0U;
 1006264:	bf08      	it	eq
 1006266:	4613      	moveq	r3, r2
		flag_elapsed = 1U;
 1006268:	2201      	movs	r2, #1
	*ticks_elapsed_index = idx;
 100626a:	f88b 300a 	strb.w	r3, [fp, #10]
		ticks_elapsed =
 100626e:	eb0b 0383 	add.w	r3, fp, r3, lsl #2
 1006272:	68db      	ldr	r3, [r3, #12]
		flag_elapsed = 1U;
 1006274:	920d      	str	r2, [sp, #52]	; 0x34
		instance->ticks_current += ticks_elapsed;
 1006276:	9a05      	ldr	r2, [sp, #20]
		ticks_elapsed =
 1006278:	9302      	str	r3, [sp, #8]
		instance->ticks_current += ticks_elapsed;
 100627a:	18d3      	adds	r3, r2, r3
		instance->ticks_current &= HAL_TICKER_CNTR_MASK;
 100627c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 1006280:	f8cb 3014 	str.w	r3, [fp, #20]
	node = &instance->nodes[0];
 1006284:	f8db 1000 	ldr.w	r1, [fp]
	count_user = instance->count_user;
 1006288:	f89b 2009 	ldrb.w	r2, [fp, #9]
	ticker_id_old_head = instance->ticker_id_head;
 100628c:	f89b 301d 	ldrb.w	r3, [fp, #29]
	node = &instance->nodes[0];
 1006290:	9104      	str	r1, [sp, #16]
	users = &instance->users[0];
 1006292:	f8db 1004 	ldr.w	r1, [fp, #4]
	ticker_id_old_head = instance->ticker_id_head;
 1006296:	9306      	str	r3, [sp, #24]
	while (count_user--) {
 1006298:	1e53      	subs	r3, r2, #1
	count_user = instance->count_user;
 100629a:	9207      	str	r2, [sp, #28]
	while (count_user--) {
 100629c:	b2db      	uxtb	r3, r3
	users = &instance->users[0];
 100629e:	910c      	str	r1, [sp, #48]	; 0x30
	while (count_user--) {
 10062a0:	2a00      	cmp	r2, #0
 10062a2:	f000 830b 	beq.w	10068bc <ticker_job+0x688>
 10062a6:	eb01 06c3 	add.w	r6, r1, r3, lsl #3
	pending = 0U;
 10062aa:	2300      	movs	r3, #0
 10062ac:	9308      	str	r3, [sp, #32]
	insert_head = TICKER_NULL;
 10062ae:	23ff      	movs	r3, #255	; 0xff
 10062b0:	4637      	mov	r7, r6
 10062b2:	46d9      	mov	r9, fp
 10062b4:	9301      	str	r3, [sp, #4]
		user_ops = &user->user_op[0];
 10062b6:	46ba      	mov	sl, r7
 10062b8:	687b      	ldr	r3, [r7, #4]
 10062ba:	f897 c003 	ldrb.w	ip, [r7, #3]
 10062be:	9307      	str	r3, [sp, #28]
		while (user->middle != user->last) {
 10062c0:	78bb      	ldrb	r3, [r7, #2]
 10062c2:	4563      	cmp	r3, ip
					ticks_used = 0;
 10062c4:	4698      	mov	r8, r3
			user_op = &user_ops[user->middle];
 10062c6:	f04f 0134 	mov.w	r1, #52	; 0x34
 10062ca:	9807      	ldr	r0, [sp, #28]
			middle = user->middle + 1;
 10062cc:	f103 0201 	add.w	r2, r3, #1
		while (user->middle != user->last) {
 10062d0:	f000 8188 	beq.w	10065e4 <ticker_job+0x3b0>
			if (middle == user->count_user_op) {
 10062d4:	f89a 4000 	ldrb.w	r4, [sl]
			user_op = &user_ops[user->middle];
 10062d8:	fb01 f503 	mul.w	r5, r1, r3
			middle = user->middle + 1;
 10062dc:	b2d3      	uxtb	r3, r2
				middle = 0U;
 10062de:	429c      	cmp	r4, r3
 10062e0:	bf08      	it	eq
 10062e2:	2300      	moveq	r3, #0
			user->middle = middle;
 10062e4:	f88a 3002 	strb.w	r3, [sl, #2]
			if (user_op->op < TICKER_USER_OP_TYPE_UPDATE) {
 10062e8:	5d42      	ldrb	r2, [r0, r5]
			user_op = &user_ops[user->middle];
 10062ea:	4405      	add	r5, r0
			if (user_op->op < TICKER_USER_OP_TYPE_UPDATE) {
 10062ec:	2a04      	cmp	r2, #4
 10062ee:	f240 8173 	bls.w	10065d8 <ticker_job+0x3a4>
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
 10062f2:	2a07      	cmp	r2, #7
 10062f4:	f200 8086 	bhi.w	1006404 <ticker_job+0x1d0>
			ticker = &node[user_op->id];
 10062f8:	7869      	ldrb	r1, [r5, #1]
 10062fa:	9804      	ldr	r0, [sp, #16]
 10062fc:	eb01 0641 	add.w	r6, r1, r1, lsl #1
 1006300:	eb00 1406 	add.w	r4, r0, r6, lsl #4
			state = (ticker->req - ticker->ack) & 0xff;
 1006304:	78a7      	ldrb	r7, [r4, #2]
 1006306:	7860      	ldrb	r0, [r4, #1]
			ticker = &node[user_op->id];
 1006308:	0136      	lsls	r6, r6, #4
			state = (ticker->req - ticker->ack) & 0xff;
 100630a:	1bc0      	subs	r0, r0, r7
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
 100630c:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
			ticker = &node[user_op->id];
 1006310:	960a      	str	r6, [sp, #40]	; 0x28
			if ((user_op->op > TICKER_USER_OP_TYPE_STOP_ABS) ||
 1006312:	d077      	beq.n	1006404 <ticker_job+0x1d0>
			    (state == 0U) ||
 1006314:	2a05      	cmp	r2, #5
 1006316:	d065      	beq.n	10063e4 <ticker_job+0x1b0>
			if (state == 1U) {
 1006318:	2801      	cmp	r0, #1
 100631a:	d137      	bne.n	100638c <ticker_job+0x158>
	previous = instance->ticker_id_head;
 100631c:	f899 c01d 	ldrb.w	ip, [r9, #29]
	ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
 1006320:	f8d9 6000 	ldr.w	r6, [r9]
	while (current != TICKER_NULL) {
 1006324:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
 1006328:	d017      	beq.n	100635a <ticker_job+0x126>
		ticker_current = &node[current];
 100632a:	eb0c 004c 	add.w	r0, ip, ip, lsl #1
		if (current == id) {
 100632e:	4561      	cmp	r1, ip
		ticker_current = &node[current];
 1006330:	eb06 1000 	add.w	r0, r6, r0, lsl #4
		if (current == id) {
 1006334:	f000 814d 	beq.w	10065d2 <ticker_job+0x39e>
	total = 0U;
 1006338:	2300      	movs	r3, #0
 100633a:	e001      	b.n	1006340 <ticker_job+0x10c>
		if (current == id) {
 100633c:	4561      	cmp	r1, ip
 100633e:	d070      	beq.n	1006422 <ticker_job+0x1ee>
		total += ticker_current->ticks_to_expire;
 1006340:	46e6      	mov	lr, ip
		current = ticker_current->next;
 1006342:	f890 c000 	ldrb.w	ip, [r0]
		total += ticker_current->ticks_to_expire;
 1006346:	f8d0 8008 	ldr.w	r8, [r0, #8]
	while (current != TICKER_NULL) {
 100634a:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
		ticker_current = &node[current];
 100634e:	eb0c 004c 	add.w	r0, ip, ip, lsl #1
		total += ticker_current->ticks_to_expire;
 1006352:	4443      	add	r3, r8
		ticker_current = &node[current];
 1006354:	eb06 1000 	add.w	r0, r6, r0, lsl #4
	while (current != TICKER_NULL) {
 1006358:	d1f0      	bne.n	100633c <ticker_job+0x108>
	ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
 100635a:	2600      	movs	r6, #0
	if (user_op->op == TICKER_USER_OP_TYPE_UPDATE) {
 100635c:	2a05      	cmp	r2, #5
	ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
 100635e:	60a6      	str	r6, [r4, #8]
	if (user_op->op == TICKER_USER_OP_TYPE_UPDATE) {
 1006360:	f000 8122 	beq.w	10065a8 <ticker_job+0x374>
		ticker->req = ticker->ack;
 1006364:	7067      	strb	r7, [r4, #1]
		if (instance->ticker_id_slot_previous == user_op->id) {
 1006366:	f899 301c 	ldrb.w	r3, [r9, #28]
 100636a:	428b      	cmp	r3, r1
 100636c:	d022      	beq.n	10063b4 <ticker_job+0x180>
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 100636e:	2000      	movs	r0, #0
	if (user_op->fp_op_func) {
 1006370:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 1006372:	7028      	strb	r0, [r5, #0]
	user_op->status = status;
 1006374:	62a8      	str	r0, [r5, #40]	; 0x28
	if (user_op->fp_op_func) {
 1006376:	b10b      	cbz	r3, 100637c <ticker_job+0x148>
		user_op->fp_op_func(user_op->status, user_op->op_context);
 1006378:	6b29      	ldr	r1, [r5, #48]	; 0x30
 100637a:	4798      	blx	r3
 100637c:	f89a c003 	ldrb.w	ip, [sl, #3]
 1006380:	f89a 3002 	ldrb.w	r3, [sl, #2]
 1006384:	e79d      	b.n	10062c2 <ticker_job+0x8e>
		flag_elapsed = 0U;
 1006386:	920d      	str	r2, [sp, #52]	; 0x34
		ticks_elapsed = 0U;
 1006388:	9202      	str	r2, [sp, #8]
 100638a:	e77b      	b.n	1006284 <ticker_job+0x50>
				instance->sched_cb(TICKER_CALL_ID_JOB,
 100638c:	2104      	movs	r1, #4
 100638e:	4657      	mov	r7, sl
 1006390:	464b      	mov	r3, r9
 1006392:	2201      	movs	r2, #1
 1006394:	4608      	mov	r0, r1
 1006396:	f8d9 4024 	ldr.w	r4, [r9, #36]	; 0x24
 100639a:	47a0      	blx	r4
				pending = 1U;
 100639c:	2301      	movs	r3, #1
	while (count_user--) {
 100639e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
				pending = 1U;
 10063a0:	9308      	str	r3, [sp, #32]
	while (count_user--) {
 10063a2:	42ba      	cmp	r2, r7
				user->middle = prev;
 10063a4:	f88a 8002 	strb.w	r8, [sl, #2]
	while (count_user--) {
 10063a8:	f1a7 0308 	sub.w	r3, r7, #8
 10063ac:	f000 8121 	beq.w	10065f2 <ticker_job+0x3be>
 10063b0:	461f      	mov	r7, r3
 10063b2:	e780      	b.n	10062b6 <ticker_job+0x82>
			instance->ticker_id_slot_previous = TICKER_NULL;
 10063b4:	23ff      	movs	r3, #255	; 0xff
			if (user_op->op == TICKER_USER_OP_TYPE_STOP_ABS) {
 10063b6:	2a07      	cmp	r2, #7
			instance->ticker_id_slot_previous = TICKER_NULL;
 10063b8:	f889 301c 	strb.w	r3, [r9, #28]
			if (user_op->op == TICKER_USER_OP_TYPE_STOP_ABS) {
 10063bc:	f040 81d5 	bne.w	100676a <ticker_job+0x536>
				ticks_at_stop =
 10063c0:	6868      	ldr	r0, [r5, #4]
			ticks_current = instance->ticks_current;
 10063c2:	f8d9 3014 	ldr.w	r3, [r9, #20]
			if (!((ticks_at_stop - ticks_current) &
 10063c6:	1ac2      	subs	r2, r0, r3
 10063c8:	0211      	lsls	r1, r2, #8
 10063ca:	f100 81c5 	bmi.w	1006758 <ticker_job+0x524>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 10063ce:	f022 437f 	bic.w	r3, r2, #4278190080	; 0xff000000
				ticks_used = ticks_elapsed +
 10063d2:	9a02      	ldr	r2, [sp, #8]
 10063d4:	4413      	add	r3, r2
			if (instance->ticks_slot_previous > ticks_used) {
 10063d6:	f8d9 2018 	ldr.w	r2, [r9, #24]
 10063da:	429a      	cmp	r2, r3
				instance->ticks_slot_previous = ticks_used;
 10063dc:	bf88      	it	hi
 10063de:	f8c9 3018 	strhi.w	r3, [r9, #24]
 10063e2:	e7c4      	b.n	100636e <ticker_job+0x13a>
			    ((user_op->op == TICKER_USER_OP_TYPE_UPDATE) &&
 10063e4:	686e      	ldr	r6, [r5, #4]
 10063e6:	2e00      	cmp	r6, #0
 10063e8:	d196      	bne.n	1006318 <ticker_job+0xe4>
			     (user_op->params.update.ticks_drift_plus == 0U) &&
 10063ea:	68ae      	ldr	r6, [r5, #8]
 10063ec:	2e00      	cmp	r6, #0
 10063ee:	d193      	bne.n	1006318 <ticker_job+0xe4>
			     (user_op->params.update.ticks_drift_minus == 0U) &&
 10063f0:	68ee      	ldr	r6, [r5, #12]
 10063f2:	2e00      	cmp	r6, #0
 10063f4:	d190      	bne.n	1006318 <ticker_job+0xe4>
			     (user_op->params.update.ticks_slot_plus == 0U) &&
 10063f6:	692e      	ldr	r6, [r5, #16]
 10063f8:	2e00      	cmp	r6, #0
 10063fa:	d18d      	bne.n	1006318 <ticker_job+0xe4>
			     (user_op->params.update.lazy == 0U) &&
 10063fc:	696e      	ldr	r6, [r5, #20]
 10063fe:	f036 467f 	bics.w	r6, r6, #4278190080	; 0xff000000
 1006402:	d189      	bne.n	1006318 <ticker_job+0xe4>
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 1006404:	2100      	movs	r1, #0
	user_op->status = status;
 1006406:	2001      	movs	r0, #1
	if (user_op->fp_op_func) {
 1006408:	6aea      	ldr	r2, [r5, #44]	; 0x2c
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 100640a:	7029      	strb	r1, [r5, #0]
	user_op->status = status;
 100640c:	62a8      	str	r0, [r5, #40]	; 0x28
	if (user_op->fp_op_func) {
 100640e:	2a00      	cmp	r2, #0
 1006410:	f43f af57 	beq.w	10062c2 <ticker_job+0x8e>
		user_op->fp_op_func(user_op->status, user_op->op_context);
 1006414:	6b29      	ldr	r1, [r5, #48]	; 0x30
 1006416:	4790      	blx	r2
 1006418:	f89a c003 	ldrb.w	ip, [sl, #3]
 100641c:	f89a 3002 	ldrb.w	r3, [sl, #2]
 1006420:	e74f      	b.n	10062c2 <ticker_job+0x8e>
	if (previous == current) {
 1006422:	458e      	cmp	lr, r1
 1006424:	d016      	beq.n	1006454 <ticker_job+0x220>
 1006426:	eb0e 0e4e 	add.w	lr, lr, lr, lsl #1
 100642a:	eb06 110e 	add.w	r1, r6, lr, lsl #4
	node[previous].next = ticker_current->next;
 100642e:	7807      	ldrb	r7, [r0, #0]
	timeout = ticker_current->ticks_to_expire;
 1006430:	6880      	ldr	r0, [r0, #8]
	if (ticker_current->next != TICKER_NULL) {
 1006432:	2fff      	cmp	r7, #255	; 0xff
	node[previous].next = ticker_current->next;
 1006434:	700f      	strb	r7, [r1, #0]
	if (ticker_current->next != TICKER_NULL) {
 1006436:	d006      	beq.n	1006446 <ticker_job+0x212>
		node[ticker_current->next].ticks_to_expire += timeout;
 1006438:	eb07 0747 	add.w	r7, r7, r7, lsl #1
 100643c:	eb06 1707 	add.w	r7, r6, r7, lsl #4
 1006440:	68b9      	ldr	r1, [r7, #8]
 1006442:	4401      	add	r1, r0
 1006444:	60b9      	str	r1, [r7, #8]
	return (total + timeout);
 1006446:	18c6      	adds	r6, r0, r3
	if (user_op->op == TICKER_USER_OP_TYPE_UPDATE) {
 1006448:	2a05      	cmp	r2, #5
	ticker->ticks_to_expire = ticker_dequeue(instance, user_op->id);
 100644a:	60a6      	str	r6, [r4, #8]
	if (user_op->op == TICKER_USER_OP_TYPE_UPDATE) {
 100644c:	d008      	beq.n	1006460 <ticker_job+0x22c>
 100644e:	78a7      	ldrb	r7, [r4, #2]
 1006450:	7869      	ldrb	r1, [r5, #1]
 1006452:	e787      	b.n	1006364 <ticker_job+0x130>
 1006454:	4601      	mov	r1, r0
		instance->ticker_id_head = ticker_current->next;
 1006456:	7802      	ldrb	r2, [r0, #0]
 1006458:	f889 201d 	strb.w	r2, [r9, #29]
 100645c:	782a      	ldrb	r2, [r5, #0]
 100645e:	e7e6      	b.n	100642e <ticker_job+0x1fa>
		ticker_job_node_update(ticker, user_op, instance->ticks_current,
 1006460:	f8d9 7014 	ldr.w	r7, [r9, #20]
 1006464:	9703      	str	r7, [sp, #12]
	ticks_now = cntr_cnt_get();
 1006466:	f00b fa73 	bl	1011950 <cntr_cnt_get>
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
 100646a:	9b02      	ldr	r3, [sp, #8]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 100646c:	eba0 0c07 	sub.w	ip, r0, r7
 1006470:	f02c 477f 	bic.w	r7, ip, #4278190080	; 0xff000000
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
 1006474:	443b      	add	r3, r7
	if (ticks_to_expire > ticks_elapsed) {
 1006476:	429e      	cmp	r6, r3
	ticks_now = cntr_cnt_get();
 1006478:	4680      	mov	r8, r0
	if (ticks_to_expire > ticks_elapsed) {
 100647a:	f240 80a1 	bls.w	10065c0 <ticker_job+0x38c>
		ticks_to_expire -= ticks_elapsed;
 100647e:	1af2      	subs	r2, r6, r3
 1006480:	6963      	ldr	r3, [r4, #20]
	if ((ticker->ticks_periodic != 0U) &&
 1006482:	6866      	ldr	r6, [r4, #4]
 1006484:	2e00      	cmp	r6, #0
 1006486:	d053      	beq.n	1006530 <ticker_job+0x2fc>
	    (user_op->params.update.lazy != 0U)) {
 1006488:	8aa8      	ldrh	r0, [r5, #20]
	if ((ticker->ticks_periodic != 0U) &&
 100648a:	2800      	cmp	r0, #0
 100648c:	d050      	beq.n	1006530 <ticker_job+0x2fc>
		user_op->params.update.lazy--;
 100648e:	3801      	subs	r0, #1
 1006490:	b280      	uxth	r0, r0
		while ((ticks_to_expire > ticker->ticks_periodic) &&
 1006492:	4296      	cmp	r6, r2
 1006494:	8be1      	ldrh	r1, [r4, #30]
		user_op->params.update.lazy--;
 1006496:	82a8      	strh	r0, [r5, #20]
		while ((ticks_to_expire > ticker->ticks_periodic) &&
 1006498:	d225      	bcs.n	10064e6 <ticker_job+0x2b2>
 100649a:	f106 0b01 	add.w	fp, r6, #1
 100649e:	930b      	str	r3, [sp, #44]	; 0x2c
 10064a0:	e011      	b.n	10064c6 <ticker_job+0x292>
 10064a2:	46de      	mov	lr, fp
		ticker->remainder_current += HAL_TICKER_REMAINDER_RANGE;
 10064a4:	f100 70e8 	add.w	r0, r0, #30408704	; 0x1d00000
 10064a8:	f500 30d4 	add.w	r0, r0, #108544	; 0x1a800
 10064ac:	f500 70a5 	add.w	r0, r0, #330	; 0x14a
	ticker->remainder_current -= ticker->remainder_periodic;
 10064b0:	9b09      	ldr	r3, [sp, #36]	; 0x24
			ticker->lazy_current--;
 10064b2:	3901      	subs	r1, #1
			ticks_to_expire -= ticker->ticks_periodic +
 10064b4:	eba2 020e 	sub.w	r2, r2, lr
			ticker->lazy_current--;
 10064b8:	b289      	uxth	r1, r1
	ticker->remainder_current -= ticker->remainder_periodic;
 10064ba:	1ac0      	subs	r0, r0, r3
		while ((ticks_to_expire > ticker->ticks_periodic) &&
 10064bc:	4296      	cmp	r6, r2
			ticker->lazy_current--;
 10064be:	83e1      	strh	r1, [r4, #30]
	ticker->remainder_current -= ticker->remainder_periodic;
 10064c0:	6260      	str	r0, [r4, #36]	; 0x24
		while ((ticks_to_expire > ticker->ticks_periodic) &&
 10064c2:	d20e      	bcs.n	10064e2 <ticker_job+0x2ae>
 10064c4:	8aa8      	ldrh	r0, [r5, #20]
 10064c6:	4288      	cmp	r0, r1
 10064c8:	f080 81ab 	bcs.w	1006822 <ticker_job+0x5ee>
					   ticker_remainder_dec(ticker);
 10064cc:	e9d4 3008 	ldrd	r3, r0, [r4, #32]
	if ((ticker->remainder_current >= BIT(31)) ||
 10064d0:	f8df e2c0 	ldr.w	lr, [pc, #704]	; 1006794 <ticker_job+0x560>
					   ticker_remainder_dec(ticker);
 10064d4:	9309      	str	r3, [sp, #36]	; 0x24
	if ((ticker->remainder_current >= BIT(31)) ||
 10064d6:	4bae      	ldr	r3, [pc, #696]	; (1006790 <ticker_job+0x55c>)
 10064d8:	4486      	add	lr, r0
 10064da:	459e      	cmp	lr, r3
 10064dc:	d8e1      	bhi.n	10064a2 <ticker_job+0x26e>
 10064de:	46b6      	mov	lr, r6
 10064e0:	e7e6      	b.n	10064b0 <ticker_job+0x27c>
 10064e2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 10064e4:	8aa8      	ldrh	r0, [r5, #20]
		while (ticker->lazy_current < user_op->params.update.lazy) {
 10064e6:	4281      	cmp	r1, r0
 10064e8:	d221      	bcs.n	100652e <ticker_job+0x2fa>
					   ticker_remainder_inc(ticker);
 10064ea:	6a20      	ldr	r0, [r4, #32]
 10064ec:	f106 0e01 	add.w	lr, r6, #1
 10064f0:	9009      	str	r0, [sp, #36]	; 0x24
 10064f2:	930b      	str	r3, [sp, #44]	; 0x2c
 10064f4:	e007      	b.n	1006506 <ticker_job+0x2d2>
	ticker->remainder_current += ticker->remainder_periodic;
 10064f6:	46b3      	mov	fp, r6
 10064f8:	6260      	str	r0, [r4, #36]	; 0x24
		while (ticker->lazy_current < user_op->params.update.lazy) {
 10064fa:	8aa8      	ldrh	r0, [r5, #20]
			ticker->lazy_current++;
 10064fc:	3101      	adds	r1, #1
 10064fe:	b289      	uxth	r1, r1
		while (ticker->lazy_current < user_op->params.update.lazy) {
 1006500:	4281      	cmp	r1, r0
			ticks_to_expire += ticker->ticks_periodic +
 1006502:	445a      	add	r2, fp
		while (ticker->lazy_current < user_op->params.update.lazy) {
 1006504:	d211      	bcs.n	100652a <ticker_job+0x2f6>
	ticker->remainder_current += ticker->remainder_periodic;
 1006506:	9b09      	ldr	r3, [sp, #36]	; 0x24
 1006508:	6a60      	ldr	r0, [r4, #36]	; 0x24
	if ((ticker->remainder_current < BIT(31)) &&
 100650a:	f8df b288 	ldr.w	fp, [pc, #648]	; 1006794 <ticker_job+0x560>
	ticker->remainder_current += ticker->remainder_periodic;
 100650e:	4418      	add	r0, r3
	if ((ticker->remainder_current < BIT(31)) &&
 1006510:	4b9f      	ldr	r3, [pc, #636]	; (1006790 <ticker_job+0x55c>)
 1006512:	4483      	add	fp, r0
 1006514:	459b      	cmp	fp, r3
 1006516:	d8ee      	bhi.n	10064f6 <ticker_job+0x2c2>
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 1006518:	f1a0 70e8 	sub.w	r0, r0, #30408704	; 0x1d00000
 100651c:	f5a0 30d4 	sub.w	r0, r0, #108544	; 0x1a800
 1006520:	f5a0 70a5 	sub.w	r0, r0, #330	; 0x14a
 1006524:	46f3      	mov	fp, lr
 1006526:	6260      	str	r0, [r4, #36]	; 0x24
		return 1;
 1006528:	e7e7      	b.n	10064fa <ticker_job+0x2c6>
 100652a:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 100652c:	83e1      	strh	r1, [r4, #30]
		ticker->lazy_periodic = user_op->params.update.lazy;
 100652e:	83a0      	strh	r0, [r4, #28]
	struct ticker_ext *ext_data = ticker->ext_data;
 1006530:	6aa6      	ldr	r6, [r4, #40]	; 0x28
				user_op->params.update.ticks_drift_minus;
 1006532:	e9d5 0e01 	ldrd	r0, lr, [r5, #4]
	ticker->ticks_to_expire = ticks_to_expire +
 1006536:	4402      	add	r2, r0
	ticker->ticks_to_expire_minus +=
 1006538:	4473      	add	r3, lr
	ticker->ticks_to_expire = ticks_to_expire +
 100653a:	60a2      	str	r2, [r4, #8]
	ticker->ticks_to_expire_minus +=
 100653c:	6163      	str	r3, [r4, #20]
	if (ext_data && ext_data->ticks_slot_window != 0U) {
 100653e:	b136      	cbz	r6, 100654e <ticker_job+0x31a>
 1006540:	6831      	ldr	r1, [r6, #0]
 1006542:	b121      	cbz	r1, 100654e <ticker_job+0x31a>
			user_op->params.update.ticks_drift_plus -
 1006544:	eba0 000e 	sub.w	r0, r0, lr
		ext_data->ticks_drift =
 1006548:	6070      	str	r0, [r6, #4]
 100654a:	68a2      	ldr	r2, [r4, #8]
 100654c:	6963      	ldr	r3, [r4, #20]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
 100654e:	f41c 0f00 	tst.w	ip, #8388608	; 0x800000
 1006552:	d120      	bne.n	1006596 <ticker_job+0x362>
		ticks_to_expire += ticker_ticks_diff_get(ticks_at_start,
 1006554:	443a      	add	r2, r7
	if (ticks_to_expire > ticks_to_expire_minus) {
 1006556:	429a      	cmp	r2, r3
 1006558:	d91a      	bls.n	1006590 <ticker_job+0x35c>
		ticks_to_expire -= ticks_to_expire_minus;
 100655a:	1ad2      	subs	r2, r2, r3
		ticks_to_expire_minus = 0U;
 100655c:	2300      	movs	r3, #0
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
 100655e:	6163      	str	r3, [r4, #20]
	ticker->ticks_to_expire = ticks_to_expire;
 1006560:	60a2      	str	r2, [r4, #8]
	ticker->ticks_slot += user_op->params.update.ticks_slot_plus;
 1006562:	68e9      	ldr	r1, [r5, #12]
 1006564:	69a3      	ldr	r3, [r4, #24]
	if (ticker->ticks_slot > user_op->params.update.ticks_slot_minus) {
 1006566:	692a      	ldr	r2, [r5, #16]
	ticker->ticks_slot += user_op->params.update.ticks_slot_plus;
 1006568:	440b      	add	r3, r1
	if (ticker->ticks_slot > user_op->params.update.ticks_slot_minus) {
 100656a:	4293      	cmp	r3, r2
		ticker->ticks_slot = 0U;
 100656c:	bf94      	ite	ls
 100656e:	2300      	movls	r3, #0
		ticker->ticks_slot -= user_op->params.update.ticks_slot_minus;
 1006570:	1a9b      	subhi	r3, r3, r2
	if (user_op->params.update.force != 0U) {
 1006572:	7daa      	ldrb	r2, [r5, #22]
 1006574:	61a3      	str	r3, [r4, #24]
 1006576:	b102      	cbz	r2, 100657a <ticker_job+0x346>
		ticker->force = user_op->params.update.force;
 1006578:	70e2      	strb	r2, [r4, #3]
	ticker->next = *insert_head;
 100657a:	9b04      	ldr	r3, [sp, #16]
 100657c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 100657e:	4619      	mov	r1, r3
 1006580:	9b01      	ldr	r3, [sp, #4]
 1006582:	548b      	strb	r3, [r1, r2]
		ticker->req++;
 1006584:	7863      	ldrb	r3, [r4, #1]
	*insert_head = user_op->id;
 1006586:	786a      	ldrb	r2, [r5, #1]
		ticker->req++;
 1006588:	3301      	adds	r3, #1
	*insert_head = user_op->id;
 100658a:	9201      	str	r2, [sp, #4]
		ticker->req++;
 100658c:	7063      	strb	r3, [r4, #1]
 100658e:	e6ee      	b.n	100636e <ticker_job+0x13a>
 1006590:	1a9b      	subs	r3, r3, r2
		ticks_to_expire = 0U;
 1006592:	2200      	movs	r2, #0
 1006594:	e7e3      	b.n	100655e <ticker_job+0x32a>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1006596:	9903      	ldr	r1, [sp, #12]
 1006598:	eba1 0708 	sub.w	r7, r1, r8
 100659c:	f027 477f 	bic.w	r7, r7, #4278190080	; 0xff000000
		if (ticks_to_expire > delta_current_start) {
 10065a0:	4297      	cmp	r7, r2
 10065a2:	d213      	bcs.n	10065cc <ticker_job+0x398>
			ticks_to_expire -= delta_current_start;
 10065a4:	1bd2      	subs	r2, r2, r7
 10065a6:	e7d6      	b.n	1006556 <ticker_job+0x322>
		ticker_job_node_update(ticker, user_op, instance->ticks_current,
 10065a8:	f8d9 7014 	ldr.w	r7, [r9, #20]
 10065ac:	9703      	str	r7, [sp, #12]
	ticks_now = cntr_cnt_get();
 10065ae:	f00b f9cf 	bl	1011950 <cntr_cnt_get>
 10065b2:	4680      	mov	r8, r0
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
 10065b4:	9b02      	ldr	r3, [sp, #8]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 10065b6:	eba0 0c07 	sub.w	ip, r0, r7
 10065ba:	f02c 477f 	bic.w	r7, ip, #4278190080	; 0xff000000
	ticks_elapsed += ticker_ticks_diff_get(ticks_now, ticks_current);
 10065be:	443b      	add	r3, r7
		ticker->ticks_to_expire_minus += ticks_elapsed -
 10065c0:	6961      	ldr	r1, [r4, #20]
		ticks_to_expire = 0U;
 10065c2:	2200      	movs	r2, #0
		ticker->ticks_to_expire_minus += ticks_elapsed -
 10065c4:	440b      	add	r3, r1
 10065c6:	1b9b      	subs	r3, r3, r6
 10065c8:	6163      	str	r3, [r4, #20]
		ticks_to_expire = 0U;
 10065ca:	e75a      	b.n	1006482 <ticker_job+0x24e>
			ticks_to_expire_minus +=
 10065cc:	443b      	add	r3, r7
 10065ce:	1a9b      	subs	r3, r3, r2
	if (ticks_to_expire > ticks_to_expire_minus) {
 10065d0:	e7df      	b.n	1006592 <ticker_job+0x35e>
		if (current == id) {
 10065d2:	4601      	mov	r1, r0
	total = 0U;
 10065d4:	2300      	movs	r3, #0
 10065d6:	e73e      	b.n	1006456 <ticker_job+0x222>
		while (user->middle != user->last) {
 10065d8:	4563      	cmp	r3, ip
 10065da:	4698      	mov	r8, r3
			middle = user->middle + 1;
 10065dc:	f103 0201 	add.w	r2, r3, #1
		while (user->middle != user->last) {
 10065e0:	f47f ae78 	bne.w	10062d4 <ticker_job+0xa0>
 10065e4:	4657      	mov	r7, sl
	while (count_user--) {
 10065e6:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 10065e8:	f1a7 0308 	sub.w	r3, r7, #8
 10065ec:	42ba      	cmp	r2, r7
 10065ee:	f47f aedf 	bne.w	10063b0 <ticker_job+0x17c>
 10065f2:	f899 a01d 	ldrb.w	sl, [r9, #29]
 10065f6:	9b06      	ldr	r3, [sp, #24]
 10065f8:	46cb      	mov	fp, r9
 10065fa:	ebb3 030a 	subs.w	r3, r3, sl
 10065fe:	bf18      	it	ne
 1006600:	2301      	movne	r3, #1
 1006602:	9307      	str	r3, [sp, #28]
	if (flag_elapsed) {
 1006604:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 1006606:	2b00      	cmp	r3, #0
 1006608:	f040 8160 	bne.w	10068cc <ticker_job+0x698>
	node = &instance->nodes[0];
 100660c:	f8d9 3000 	ldr.w	r3, [r9]
	count_user = instance->count_user;
 1006610:	f899 2009 	ldrb.w	r2, [r9, #9]
	users = &instance->users[0];
 1006614:	f8d9 1004 	ldr.w	r1, [r9, #4]
	node = &instance->nodes[0];
 1006618:	9304      	str	r3, [sp, #16]
	while (count_user--) {
 100661a:	1e53      	subs	r3, r2, #1
 100661c:	b2db      	uxtb	r3, r3
	users = &instance->users[0];
 100661e:	9109      	str	r1, [sp, #36]	; 0x24
	while (count_user--) {
 1006620:	2a00      	cmp	r2, #0
 1006622:	f000 8102 	beq.w	100682a <ticker_job+0x5f6>
 1006626:	eb01 08c3 	add.w	r8, r1, r3, lsl #3
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 100662a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 100662c:	9303      	str	r3, [sp, #12]
		user_ops = (void *)&user->user_op[0];
 100662e:	f8d8 3004 	ldr.w	r3, [r8, #4]
		user_ops_first = user->first;
 1006632:	f898 4001 	ldrb.w	r4, [r8, #1]
		user_ops = (void *)&user->user_op[0];
 1006636:	9305      	str	r3, [sp, #20]
		while ((insert_head != TICKER_NULL) ||
 1006638:	9b01      	ldr	r3, [sp, #4]
 100663a:	2bff      	cmp	r3, #255	; 0xff
 100663c:	d055      	beq.n	10066ea <ticker_job+0x4b6>
				ticker = &node[id_insert];
 100663e:	9a01      	ldr	r2, [sp, #4]
 1006640:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 1006644:	4692      	mov	sl, r2
 1006646:	9a04      	ldr	r2, [sp, #16]
 1006648:	ea4f 1c03 	mov.w	ip, r3, lsl #4
 100664c:	eb02 1303 	add.w	r3, r2, r3, lsl #4
				insert_head = ticker->next;
 1006650:	f812 200c 	ldrb.w	r2, [r2, ip]
 1006654:	9201      	str	r2, [sp, #4]
				user_op = NULL;
 1006656:	2200      	movs	r2, #0
	ticker->next = TICKER_NULL;
 1006658:	20ff      	movs	r0, #255	; 0xff
 100665a:	7018      	strb	r0, [r3, #0]
	(void)ticker_enqueue(instance, id_insert);
 100665c:	f8db 7000 	ldr.w	r7, [fp]
	current = instance->ticker_id_head;
 1006660:	f89b 101d 	ldrb.w	r1, [fp, #29]
	ticker_new = &node[id];
 1006664:	eb07 060c 	add.w	r6, r7, ip
	while ((current != TICKER_NULL) && (ticks_to_expire >=
 1006668:	4281      	cmp	r1, r0
	ticks_to_expire = ticker_new->ticks_to_expire;
 100666a:	68b5      	ldr	r5, [r6, #8]
	previous = TICKER_NULL;
 100666c:	bf18      	it	ne
 100666e:	9302      	strne	r3, [sp, #8]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
 1006670:	d110      	bne.n	1006694 <ticker_job+0x460>
 1006672:	e088      	b.n	1006786 <ticker_job+0x552>
		if (ticks_to_expire == 0 && (ticker_new->lazy_current >
 1006674:	ebb5 050c 	subs.w	r5, r5, ip
 1006678:	d105      	bne.n	1006686 <ticker_job+0x452>
 100667a:	f8be e01e 	ldrh.w	lr, [lr, #30]
 100667e:	8bf3      	ldrh	r3, [r6, #30]
 1006680:	4573      	cmp	r3, lr
 1006682:	f200 80cb 	bhi.w	100681c <ticker_job+0x5e8>
		current = ticker_current->next;
 1006686:	f817 c009 	ldrb.w	ip, [r7, r9]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
 100668a:	4608      	mov	r0, r1
 100668c:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
 1006690:	d06e      	beq.n	1006770 <ticker_job+0x53c>
 1006692:	4661      	mov	r1, ip
		(ticker_current = &node[current])->ticks_to_expire))) {
 1006694:	eb01 0941 	add.w	r9, r1, r1, lsl #1
 1006698:	eb07 1e09 	add.w	lr, r7, r9, lsl #4
		(ticks_to_expire_current =
 100669c:	f8de c008 	ldr.w	ip, [lr, #8]
		(ticker_current = &node[current])->ticks_to_expire))) {
 10066a0:	ea4f 1909 	mov.w	r9, r9, lsl #4
	while ((current != TICKER_NULL) && (ticks_to_expire >=
 10066a4:	45ac      	cmp	ip, r5
 10066a6:	d9e5      	bls.n	1006674 <ticker_job+0x440>
 10066a8:	9b02      	ldr	r3, [sp, #8]
	if (previous == TICKER_NULL) {
 10066aa:	28ff      	cmp	r0, #255	; 0xff
	ticker_new->ticks_to_expire = ticks_to_expire;
 10066ac:	60b5      	str	r5, [r6, #8]
	ticker_new->next = current;
 10066ae:	7031      	strb	r1, [r6, #0]
	if (previous == TICKER_NULL) {
 10066b0:	d163      	bne.n	100677a <ticker_job+0x546>
		instance->ticker_id_head = id;
 10066b2:	f88b a01d 	strb.w	sl, [fp, #29]
	if (current != TICKER_NULL) {
 10066b6:	29ff      	cmp	r1, #255	; 0xff
 10066b8:	d006      	beq.n	10066c8 <ticker_job+0x494>
		node[current].ticks_to_expire -= ticks_to_expire;
 10066ba:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 10066be:	eb07 1701 	add.w	r7, r7, r1, lsl #4
 10066c2:	68b9      	ldr	r1, [r7, #8]
 10066c4:	1b4d      	subs	r5, r1, r5
 10066c6:	60bd      	str	r5, [r7, #8]
	ticker->req = ticker->ack + 1;
 10066c8:	7899      	ldrb	r1, [r3, #2]
 10066ca:	3101      	adds	r1, #1
 10066cc:	7059      	strb	r1, [r3, #1]
			if (user_op) {
 10066ce:	2a00      	cmp	r2, #0
 10066d0:	d0b2      	beq.n	1006638 <ticker_job+0x404>
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 10066d2:	9903      	ldr	r1, [sp, #12]
	if (user_op->fp_op_func) {
 10066d4:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 10066d6:	7011      	strb	r1, [r2, #0]
	user_op->status = status;
 10066d8:	6291      	str	r1, [r2, #40]	; 0x28
	if (user_op->fp_op_func) {
 10066da:	2b00      	cmp	r3, #0
 10066dc:	d0ac      	beq.n	1006638 <ticker_job+0x404>
		user_op->fp_op_func(user_op->status, user_op->op_context);
 10066de:	2000      	movs	r0, #0
 10066e0:	6b11      	ldr	r1, [r2, #48]	; 0x30
 10066e2:	4798      	blx	r3
		while ((insert_head != TICKER_NULL) ||
 10066e4:	9b01      	ldr	r3, [sp, #4]
 10066e6:	2bff      	cmp	r3, #255	; 0xff
 10066e8:	d1a9      	bne.n	100663e <ticker_job+0x40a>
 10066ea:	f898 3002 	ldrb.w	r3, [r8, #2]
 10066ee:	42a3      	cmp	r3, r4
 10066f0:	d02b      	beq.n	100674a <ticker_job+0x516>
	user_op->status = status;
 10066f2:	2501      	movs	r5, #1
 10066f4:	9e05      	ldr	r6, [sp, #20]
				user_op = &user_ops[user_ops_first];
 10066f6:	2234      	movs	r2, #52	; 0x34
 10066f8:	fb02 f104 	mul.w	r1, r2, r4
				if (first == user->count_user_op) {
 10066fc:	f898 2000 	ldrb.w	r2, [r8]
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
 1006700:	5c70      	ldrb	r0, [r6, r1]
				first = user_ops_first + 1;
 1006702:	3401      	adds	r4, #1
 1006704:	b2e4      	uxtb	r4, r4
					first = 0U;
 1006706:	42a2      	cmp	r2, r4
 1006708:	bf08      	it	eq
 100670a:	2400      	moveq	r4, #0
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
 100670c:	2804      	cmp	r0, #4
				user_op = &user_ops[user_ops_first];
 100670e:	eb06 0201 	add.w	r2, r6, r1
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
 1006712:	d118      	bne.n	1006746 <ticker_job+0x512>
				id_insert = user_op->id;
 1006714:	f892 a001 	ldrb.w	sl, [r2, #1]
				ticker = &node[id_insert];
 1006718:	9b04      	ldr	r3, [sp, #16]
 100671a:	eb0a 0c4a 	add.w	ip, sl, sl, lsl #1
 100671e:	eb03 130c 	add.w	r3, r3, ip, lsl #4
				if (((ticker->req -
 1006722:	7858      	ldrb	r0, [r3, #1]
				      ticker->ack) & 0xff) != 0U) {
 1006724:	789f      	ldrb	r7, [r3, #2]
				ticker = &node[id_insert];
 1006726:	ea4f 1c0c 	mov.w	ip, ip, lsl #4
				if (((ticker->req -
 100672a:	1bc0      	subs	r0, r0, r7
 100672c:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
 1006730:	d032      	beq.n	1006798 <ticker_job+0x564>
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 1006732:	9b03      	ldr	r3, [sp, #12]
 1006734:	5473      	strb	r3, [r6, r1]
	if (user_op->fp_op_func) {
 1006736:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	user_op->status = status;
 1006738:	6295      	str	r5, [r2, #40]	; 0x28
	if (user_op->fp_op_func) {
 100673a:	b113      	cbz	r3, 1006742 <ticker_job+0x50e>
		user_op->fp_op_func(user_op->status, user_op->op_context);
 100673c:	2001      	movs	r0, #1
 100673e:	6b11      	ldr	r1, [r2, #48]	; 0x30
 1006740:	4798      	blx	r3
		while ((insert_head != TICKER_NULL) ||
 1006742:	f898 3002 	ldrb.w	r3, [r8, #2]
 1006746:	42a3      	cmp	r3, r4
 1006748:	d1d5      	bne.n	10066f6 <ticker_job+0x4c2>
	while (count_user--) {
 100674a:	9a09      	ldr	r2, [sp, #36]	; 0x24
 100674c:	f1a8 0308 	sub.w	r3, r8, #8
 1006750:	4542      	cmp	r2, r8
 1006752:	d068      	beq.n	1006826 <ticker_job+0x5f2>
 1006754:	4698      	mov	r8, r3
 1006756:	e76a      	b.n	100662e <ticker_job+0x3fa>
				if (ticks_elapsed > ticks_used) {
 1006758:	9a02      	ldr	r2, [sp, #8]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 100675a:	1a1b      	subs	r3, r3, r0
 100675c:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
				if (ticks_elapsed > ticks_used) {
 1006760:	429a      	cmp	r2, r3
					ticks_used = 0;
 1006762:	bf94      	ite	ls
 1006764:	2300      	movls	r3, #0
					ticks_used = ticks_elapsed -
 1006766:	1ad3      	subhi	r3, r2, r3
 1006768:	e635      	b.n	10063d6 <ticker_job+0x1a2>
				ticks_at_stop = cntr_cnt_get();
 100676a:	f00b f8f1 	bl	1011950 <cntr_cnt_get>
 100676e:	e628      	b.n	10063c2 <ticker_job+0x18e>
	ticker_new->next = current;
 1006770:	4661      	mov	r1, ip
 1006772:	9b02      	ldr	r3, [sp, #8]
	ticker_new->ticks_to_expire = ticks_to_expire;
 1006774:	60b5      	str	r5, [r6, #8]
	ticker_new->next = current;
 1006776:	f886 c000 	strb.w	ip, [r6]
		node[previous].next = id;
 100677a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 100677e:	0100      	lsls	r0, r0, #4
 1006780:	f807 a000 	strb.w	sl, [r7, r0]
 1006784:	e797      	b.n	10066b6 <ticker_job+0x482>
	ticker_new->next = current;
 1006786:	f807 100c 	strb.w	r1, [r7, ip]
		instance->ticker_id_head = id;
 100678a:	f88b a01d 	strb.w	sl, [fp, #29]
	if (current != TICKER_NULL) {
 100678e:	e79b      	b.n	10066c8 <ticker_job+0x494>
 1006790:	7f172b59 	.word	0x7f172b59
 1006794:	ff172b5a 	.word	0xff172b5a
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
 1006798:	f64f 71ff 	movw	r1, #65535	; 0xffff
 100679c:	8a97      	ldrh	r7, [r2, #20]
				ticker_job_op_start(ticker, user_op,
 100679e:	f8db 5014 	ldr.w	r5, [fp, #20]
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
 10067a2:	428f      	cmp	r7, r1
 10067a4:	d02f      	beq.n	1006806 <ticker_job+0x5d2>
 10067a6:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c
	ticker->ext_data = start->ext_data;
 10067aa:	6a51      	ldr	r1, [r2, #36]	; 0x24
	ticker->ticks_periodic = start->ticks_periodic;
 10067ac:	68d6      	ldr	r6, [r2, #12]
	ticker->ext_data = start->ext_data;
 10067ae:	6299      	str	r1, [r3, #40]	; 0x28
	ticker->remainder_periodic = start->remainder_periodic;
 10067b0:	6911      	ldr	r1, [r2, #16]
	ticker->ticks_periodic = start->ticks_periodic;
 10067b2:	605e      	str	r6, [r3, #4]
	ticker->remainder_periodic = start->remainder_periodic;
 10067b4:	6219      	str	r1, [r3, #32]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
 10067b6:	6856      	ldr	r6, [r2, #4]
	ticker->timeout_func = start->fp_timeout_func;
 10067b8:	e9d2 1e06 	ldrd	r1, lr, [r2, #24]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
 10067bc:	839f      	strh	r7, [r3, #28]
	ticker->ticks_slot = start->ticks_slot;
 10067be:	6199      	str	r1, [r3, #24]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
 10067c0:	1b77      	subs	r7, r6, r5
	ticker->context = start->context;
 10067c2:	6a11      	ldr	r1, [r2, #32]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
 10067c4:	f417 0f00 	tst.w	r7, #8388608	; 0x800000
	ticker->context = start->context;
 10067c8:	e9c3 e103 	strd	lr, r1, [r3, #12]
	ticker->ticks_to_expire = start->ticks_first;
 10067cc:	6891      	ldr	r1, [r2, #8]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
 10067ce:	d10b      	bne.n	10067e8 <ticker_job+0x5b4>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 10067d0:	f027 477f 	bic.w	r7, r7, #4278190080	; 0xff000000
		ticks_to_expire += ticker_ticks_diff_get(ticks_at_start,
 10067d4:	4439      	add	r1, r7
	if (ticks_to_expire > ticks_to_expire_minus) {
 10067d6:	b179      	cbz	r1, 10067f8 <ticker_job+0x5c4>
	ticker->force = 1U;
 10067d8:	2501      	movs	r5, #1
	ticker->ticks_to_expire = ticks_to_expire;
 10067da:	6099      	str	r1, [r3, #8]
	ticker->remainder_current = 0U;
 10067dc:	9903      	ldr	r1, [sp, #12]
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
 10067de:	6158      	str	r0, [r3, #20]
	ticker->remainder_current = 0U;
 10067e0:	6259      	str	r1, [r3, #36]	; 0x24
	ticker->lazy_current = 0U;
 10067e2:	83d9      	strh	r1, [r3, #30]
	ticker->force = 1U;
 10067e4:	70dd      	strb	r5, [r3, #3]
}
 10067e6:	e737      	b.n	1006658 <ticker_job+0x424>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 10067e8:	1bad      	subs	r5, r5, r6
 10067ea:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		if (ticks_to_expire > delta_current_start) {
 10067ee:	42a9      	cmp	r1, r5
 10067f0:	d905      	bls.n	10067fe <ticker_job+0x5ca>
			ticks_to_expire -= delta_current_start;
 10067f2:	1b49      	subs	r1, r1, r5
	if (ticks_to_expire > ticks_to_expire_minus) {
 10067f4:	2900      	cmp	r1, #0
 10067f6:	d1ef      	bne.n	10067d8 <ticker_job+0x5a4>
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
 10067f8:	4608      	mov	r0, r1
		ticks_to_expire = 0U;
 10067fa:	2100      	movs	r1, #0
 10067fc:	e7ec      	b.n	10067d8 <ticker_job+0x5a4>
			    (delta_current_start - ticks_to_expire);
 10067fe:	1a69      	subs	r1, r5, r1
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
 1006800:	4608      	mov	r0, r1
		ticks_to_expire = 0U;
 1006802:	2100      	movs	r1, #0
 1006804:	e7e8      	b.n	10067d8 <ticker_job+0x5a4>
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
 1006806:	2101      	movs	r1, #1
 1006808:	f883 102c 	strb.w	r1, [r3, #44]	; 0x2c
	ticker->ext_data = start->ext_data;
 100680c:	6a51      	ldr	r1, [r2, #36]	; 0x24
	ticker->ticks_periodic = start->ticks_periodic;
 100680e:	68d6      	ldr	r6, [r2, #12]
	ticker->ext_data = start->ext_data;
 1006810:	6299      	str	r1, [r3, #40]	; 0x28
	ticker->remainder_periodic = start->remainder_periodic;
 1006812:	6911      	ldr	r1, [r2, #16]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
 1006814:	4607      	mov	r7, r0
	ticker->ticks_periodic = start->ticks_periodic;
 1006816:	605e      	str	r6, [r3, #4]
	ticker->remainder_periodic = start->remainder_periodic;
 1006818:	6219      	str	r1, [r3, #32]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
 100681a:	e7cc      	b.n	10067b6 <ticker_job+0x582>
 100681c:	4665      	mov	r5, ip
 100681e:	9b02      	ldr	r3, [sp, #8]
 1006820:	e743      	b.n	10066aa <ticker_job+0x476>
 1006822:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 1006824:	e65f      	b.n	10064e6 <ticker_job+0x2b2>
 1006826:	f89b a01d 	ldrb.w	sl, [fp, #29]
	if (instance->ticker_id_head != ticker_id_old_head) {
 100682a:	9b06      	ldr	r3, [sp, #24]
 100682c:	459a      	cmp	sl, r3
 100682e:	f000 830f 	beq.w	1006e50 <ticker_job+0xc1c>
	if (!pending) {
 1006832:	9b08      	ldr	r3, [sp, #32]
 1006834:	2b00      	cmp	r3, #0
 1006836:	f000 832e 	beq.w	1006e96 <ticker_job+0xc62>
	instance->job_guard = 0U;
 100683a:	2300      	movs	r3, #0
 100683c:	f89b a01d 	ldrb.w	sl, [fp, #29]
 1006840:	f88b 301e 	strb.w	r3, [fp, #30]
	if (instance->ticker_id_head == TICKER_NULL) {
 1006844:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
 1006848:	f000 83b3 	beq.w	1006fb2 <ticker_job+0xd7e>
	if (ticker_id_old_head == TICKER_NULL) {
 100684c:	9b06      	ldr	r3, [sp, #24]
 100684e:	2bff      	cmp	r3, #255	; 0xff
 1006850:	f000 83ca 	beq.w	1006fe8 <ticker_job+0xdb4>
	i = 10U;
 1006854:	270a      	movs	r7, #10
	ticks_to_expire = ticker->ticks_to_expire;
 1006856:	f8db 3000 	ldr.w	r3, [fp]
 100685a:	eb0a 024a 	add.w	r2, sl, sl, lsl #1
 100685e:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 1006862:	689d      	ldr	r5, [r3, #8]
		LL_ASSERT(i);
 1006864:	4e94      	ldr	r6, [pc, #592]	; (1006ab8 <ticker_job+0x884>)
		ctr = cntr_cnt_get();
 1006866:	f00b f873 	bl	1011950 <cntr_cnt_get>
		cc = instance->ticks_current;
 100686a:	f8db 3014 	ldr.w	r3, [fp, #20]
		ctr = cntr_cnt_get();
 100686e:	4680      	mov	r8, r0
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1006870:	1ac4      	subs	r4, r0, r3
 1006872:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
		ticks_elapsed = ticker_ticks_diff_get(ctr, cc) +
 1006876:	3403      	adds	r4, #3
		cc += MAX(ticks_elapsed, ticks_to_expire);
 1006878:	42ac      	cmp	r4, r5
 100687a:	bf2c      	ite	cs
 100687c:	191b      	addcs	r3, r3, r4
 100687e:	195b      	addcc	r3, r3, r5
		cc &= HAL_TICKER_CNTR_MASK;
 1006880:	f023 447f 	bic.w	r4, r3, #4278190080	; 0xff000000
		instance->trigger_set_cb(cc);
 1006884:	4620      	mov	r0, r4
 1006886:	f8db 2028 	ldr.w	r2, [fp, #40]	; 0x28
 100688a:	4790      	blx	r2
		ctr_post = cntr_cnt_get();
 100688c:	f00b f860 	bl	1011950 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1006890:	eba0 0008 	sub.w	r0, r0, r8
 1006894:	eba4 0408 	sub.w	r4, r4, r8
 1006898:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 100689c:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
	} while ((ticker_ticks_diff_get(ctr_post, ctr) +
 10068a0:	3003      	adds	r0, #3
		  ticker_ticks_diff_get(cc, ctr));
 10068a2:	42a0      	cmp	r0, r4
		i--;
 10068a4:	f107 37ff 	add.w	r7, r7, #4294967295
		  ticker_ticks_diff_get(cc, ctr));
 10068a8:	f240 82dd 	bls.w	1006e66 <ticker_job+0xc32>
		LL_ASSERT(i);
 10068ac:	2f00      	cmp	r7, #0
 10068ae:	d1da      	bne.n	1006866 <ticker_job+0x632>
 10068b0:	f640 0171 	movw	r1, #2161	; 0x871
 10068b4:	4630      	mov	r0, r6
 10068b6:	f7fc fe67 	bl	1003588 <bt_ctlr_assert_handle>
 10068ba:	e7d4      	b.n	1006866 <ticker_job+0x632>
	if (flag_elapsed) {
 10068bc:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 10068be:	2b00      	cmp	r3, #0
 10068c0:	f000 82df 	beq.w	1006e82 <ticker_job+0xc4e>
	pending = 0U;
 10068c4:	9b07      	ldr	r3, [sp, #28]
 10068c6:	9308      	str	r3, [sp, #32]
	insert_head = TICKER_NULL;
 10068c8:	23ff      	movs	r3, #255	; 0xff
 10068ca:	9301      	str	r3, [sp, #4]
	ticks_now = cntr_cnt_get();
 10068cc:	f00b f840 	bl	1011950 <cntr_cnt_get>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 10068d0:	9b05      	ldr	r3, [sp, #20]
	while (instance->ticker_id_head != TICKER_NULL) {
 10068d2:	f89b a01d 	ldrb.w	sl, [fp, #29]
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 10068d6:	1ac0      	subs	r0, r0, r3
 10068d8:	f020 437f 	bic.w	r3, r0, #4278190080	; 0xff000000
 10068dc:	9304      	str	r3, [sp, #16]
	node = &instance->nodes[0];
 10068de:	f8db 3000 	ldr.w	r3, [fp]
	while (instance->ticker_id_head != TICKER_NULL) {
 10068e2:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
	node = &instance->nodes[0];
 10068e6:	9303      	str	r3, [sp, #12]
	while (instance->ticker_id_head != TICKER_NULL) {
 10068e8:	f000 80b0 	beq.w	1006a4c <ticker_job+0x818>
	ticks_expired = 0U;
 10068ec:	f04f 0800 	mov.w	r8, #0
	while (instance->ticker_id_head != TICKER_NULL) {
 10068f0:	f8dd 9008 	ldr.w	r9, [sp, #8]
 10068f4:	e02e      	b.n	1006954 <ticker_job+0x720>
		is_must_expire_skip = (ticker->must_expire &&
 10068f6:	8bdc      	ldrh	r4, [r3, #30]
 10068f8:	3c00      	subs	r4, #0
 10068fa:	bf18      	it	ne
 10068fc:	2401      	movne	r4, #1
		if (instance->ticks_slot_previous > ticks_to_expire) {
 10068fe:	f8db 1018 	ldr.w	r1, [fp, #24]
 1006902:	428a      	cmp	r2, r1
			instance->ticker_id_slot_previous = TICKER_NULL;
 1006904:	bf22      	ittt	cs
 1006906:	f04f 32ff 	movcs.w	r2, #4294967295
 100690a:	f88b 201c 	strbcs.w	r2, [fp, #28]
			instance->ticks_slot_previous = 0U;
 100690e:	2200      	movcs	r2, #0
		if ((ticker->ticks_slot != 0U) &&
 1006910:	699d      	ldr	r5, [r3, #24]
			instance->ticks_slot_previous -= ticks_to_expire;
 1006912:	bf38      	it	cc
 1006914:	1a8a      	subcc	r2, r1, r2
			instance->ticks_slot_previous = 0U;
 1006916:	f8cb 2018 	str.w	r2, [fp, #24]
		if ((ticker->ticks_slot != 0U) &&
 100691a:	b135      	cbz	r5, 100692a <ticker_job+0x6f6>
		    (((ticker->req - ticker->ack) & 0xff) == 2U) &&
 100691c:	785a      	ldrb	r2, [r3, #1]
 100691e:	7899      	ldrb	r1, [r3, #2]
 1006920:	1a52      	subs	r2, r2, r1
 1006922:	b2d2      	uxtb	r2, r2
		if ((ticker->ticks_slot != 0U) &&
 1006924:	2a02      	cmp	r2, #2
 1006926:	f000 814f 	beq.w	1006bc8 <ticker_job+0x994>
 100692a:	6a99      	ldr	r1, [r3, #40]	; 0x28
		ticker->ticks_to_expire = 0U;
 100692c:	2200      	movs	r2, #0
 100692e:	609a      	str	r2, [r3, #8]
		instance->ticker_id_head = ticker->next;
 1006930:	9a03      	ldr	r2, [sp, #12]
 1006932:	f812 200e 	ldrb.w	r2, [r2, lr]
 1006936:	f88b 201d 	strb.w	r2, [fp, #29]
		if ((ticker->ticks_periodic != 0U) ||
 100693a:	685c      	ldr	r4, [r3, #4]
 100693c:	bb0c      	cbnz	r4, 1006982 <ticker_job+0x74e>
 100693e:	b111      	cbz	r1, 1006946 <ticker_job+0x712>
		    TICKER_RESCHEDULE_PENDING(ticker)) {
 1006940:	7a0a      	ldrb	r2, [r1, #8]
 1006942:	2a01      	cmp	r2, #1
 1006944:	d05e      	beq.n	1006a04 <ticker_job+0x7d0>
			ticker->req = ticker->ack;
 1006946:	789a      	ldrb	r2, [r3, #2]
 1006948:	705a      	strb	r2, [r3, #1]
	while (instance->ticker_id_head != TICKER_NULL) {
 100694a:	f89b a01d 	ldrb.w	sl, [fp, #29]
 100694e:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
 1006952:	d07b      	beq.n	1006a4c <ticker_job+0x818>
		ticker = &node[id_expired];
 1006954:	9b03      	ldr	r3, [sp, #12]
 1006956:	eb0a 014a 	add.w	r1, sl, sl, lsl #1
 100695a:	eb03 1301 	add.w	r3, r3, r1, lsl #4
		ticks_to_expire = ticker->ticks_to_expire;
 100695e:	689a      	ldr	r2, [r3, #8]
		ticker = &node[id_expired];
 1006960:	ea4f 1e01 	mov.w	lr, r1, lsl #4
		if (ticks_elapsed < ticks_to_expire) {
 1006964:	454a      	cmp	r2, r9
 1006966:	f200 8292 	bhi.w	1006e8e <ticker_job+0xc5a>
		ticks_latency -= ticks_to_expire;
 100696a:	9904      	ldr	r1, [sp, #16]
		is_must_expire_skip = (ticker->must_expire &&
 100696c:	f893 002c 	ldrb.w	r0, [r3, #44]	; 0x2c
		ticks_latency -= ticks_to_expire;
 1006970:	1a89      	subs	r1, r1, r2
		ticks_elapsed -= ticks_to_expire;
 1006972:	eba9 0902 	sub.w	r9, r9, r2
		ticks_expired += ticks_to_expire;
 1006976:	4490      	add	r8, r2
		ticks_latency -= ticks_to_expire;
 1006978:	9104      	str	r1, [sp, #16]
		is_must_expire_skip = (ticker->must_expire &&
 100697a:	2800      	cmp	r0, #0
 100697c:	d1bb      	bne.n	10068f6 <ticker_job+0x6c2>
 100697e:	4604      	mov	r4, r0
 1006980:	e7bd      	b.n	10068fe <ticker_job+0x6ca>
			if (TICKER_RESCHEDULE_PENDING(ticker)) {
 1006982:	b111      	cbz	r1, 100698a <ticker_job+0x756>
 1006984:	7a0a      	ldrb	r2, [r1, #8]
 1006986:	2a01      	cmp	r2, #1
 1006988:	d03c      	beq.n	1006a04 <ticker_job+0x7d0>
				if (!ticker->lazy_current) {
 100698a:	8bda      	ldrh	r2, [r3, #30]
 100698c:	920b      	str	r2, [sp, #44]	; 0x2c
 100698e:	2a00      	cmp	r2, #0
 1006990:	f040 812b 	bne.w	1006bea <ticker_job+0x9b6>
					lazy_periodic = ticker->lazy_periodic;
 1006994:	8b9a      	ldrh	r2, [r3, #28]
 1006996:	785d      	ldrb	r5, [r3, #1]
 1006998:	4694      	mov	ip, r2
 100699a:	9209      	str	r2, [sp, #36]	; 0x24
				while (count--) {
 100699c:	1c66      	adds	r6, r4, #1
 100699e:	960a      	str	r6, [sp, #40]	; 0x28
				ticks_to_expire = 0U;
 10069a0:	2200      	movs	r2, #0
 10069a2:	e9d3 7108 	ldrd	r7, r1, [r3, #32]
 10069a6:	4666      	mov	r6, ip
 10069a8:	930c      	str	r3, [sp, #48]	; 0x30
 10069aa:	e004      	b.n	10069b6 <ticker_job+0x782>
 10069ac:	46a4      	mov	ip, r4
				while (count--) {
 10069ae:	3e01      	subs	r6, #1
 10069b0:	1c73      	adds	r3, r6, #1
					ticks_to_expire +=
 10069b2:	4462      	add	r2, ip
				while (count--) {
 10069b4:	d012      	beq.n	10069dc <ticker_job+0x7a8>
	if ((ticker->remainder_current < BIT(31)) &&
 10069b6:	f8df c108 	ldr.w	ip, [pc, #264]	; 1006ac0 <ticker_job+0x88c>
 10069ba:	4b40      	ldr	r3, [pc, #256]	; (1006abc <ticker_job+0x888>)
	ticker->remainder_current += ticker->remainder_periodic;
 10069bc:	4439      	add	r1, r7
	if ((ticker->remainder_current < BIT(31)) &&
 10069be:	448c      	add	ip, r1
 10069c0:	459c      	cmp	ip, r3
 10069c2:	d8f3      	bhi.n	10069ac <ticker_job+0x778>
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 10069c4:	f8dd c028 	ldr.w	ip, [sp, #40]	; 0x28
 10069c8:	f1a1 71e8 	sub.w	r1, r1, #30408704	; 0x1d00000
				while (count--) {
 10069cc:	3e01      	subs	r6, #1
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 10069ce:	f5a1 31d4 	sub.w	r1, r1, #108544	; 0x1a800
				while (count--) {
 10069d2:	1c73      	adds	r3, r6, #1
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 10069d4:	f5a1 71a5 	sub.w	r1, r1, #330	; 0x14a
					ticks_to_expire +=
 10069d8:	4462      	add	r2, ip
				while (count--) {
 10069da:	d1ec      	bne.n	10069b6 <ticker_job+0x782>
 10069dc:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 10069de:	970a      	str	r7, [sp, #40]	; 0x28
 10069e0:	6259      	str	r1, [r3, #36]	; 0x24
				if (!ticker->must_expire) {
 10069e2:	2800      	cmp	r0, #0
 10069e4:	f000 8200 	beq.w	1006de8 <ticker_job+0xbb4>
				ticker->lazy_current += (lazy_periodic + lazy);
 10069e8:	990b      	ldr	r1, [sp, #44]	; 0x2c
 10069ea:	9809      	ldr	r0, [sp, #36]	; 0x24
 10069ec:	4401      	add	r1, r0
 10069ee:	83d9      	strh	r1, [r3, #30]
 10069f0:	e00a      	b.n	1006a08 <ticker_job+0x7d4>
		instance->ticker_id_head = ticker->next;
 10069f2:	9a03      	ldr	r2, [sp, #12]
		ticker->ticks_to_expire = 0U;
 10069f4:	609c      	str	r4, [r3, #8]
		instance->ticker_id_head = ticker->next;
 10069f6:	f812 200e 	ldrb.w	r2, [r2, lr]
 10069fa:	f88b 201d 	strb.w	r2, [fp, #29]
		if ((ticker->ticks_periodic != 0U) ||
 10069fe:	685a      	ldr	r2, [r3, #4]
 1006a00:	2a00      	cmp	r2, #0
 1006a02:	d09d      	beq.n	1006940 <ticker_job+0x70c>
				ticker->req = ticker->ack;
 1006a04:	464a      	mov	r2, r9
 1006a06:	789d      	ldrb	r5, [r3, #2]
			ticks_to_expire_prep(ticker, instance->ticks_current,
 1006a08:	9805      	ldr	r0, [sp, #20]
 1006a0a:	f8db 1014 	ldr.w	r1, [fp, #20]
 1006a0e:	eb00 0608 	add.w	r6, r0, r8
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
 1006a12:	1a74      	subs	r4, r6, r1
 1006a14:	0227      	lsls	r7, r4, #8
	u32_t ticks_to_expire_minus = ticker->ticks_to_expire_minus;
 1006a16:	6958      	ldr	r0, [r3, #20]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
 1006a18:	f100 80ca 	bmi.w	1006bb0 <ticker_job+0x97c>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1006a1c:	f024 447f 	bic.w	r4, r4, #4278190080	; 0xff000000
		ticks_to_expire += ticker_ticks_diff_get(ticks_at_start,
 1006a20:	4422      	add	r2, r4
	if (ticks_to_expire > ticks_to_expire_minus) {
 1006a22:	4290      	cmp	r0, r2
 1006a24:	f080 80cd 	bcs.w	1006bc2 <ticker_job+0x98e>
		ticks_to_expire -= ticks_to_expire_minus;
 1006a28:	1a12      	subs	r2, r2, r0
		ticks_to_expire_minus = 0U;
 1006a2a:	2000      	movs	r0, #0
	ticker->ticks_to_expire = ticks_to_expire;
 1006a2c:	609a      	str	r2, [r3, #8]
			ticker->next = *insert_head;
 1006a2e:	9a03      	ldr	r2, [sp, #12]
			ticker->req++;
 1006a30:	3501      	adds	r5, #1
			ticker->next = *insert_head;
 1006a32:	4611      	mov	r1, r2
 1006a34:	9a01      	ldr	r2, [sp, #4]
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
 1006a36:	6158      	str	r0, [r3, #20]
			ticker->next = *insert_head;
 1006a38:	f801 200e 	strb.w	r2, [r1, lr]
			ticker->req++;
 1006a3c:	705d      	strb	r5, [r3, #1]
 1006a3e:	f8cd a004 	str.w	sl, [sp, #4]
	while (instance->ticker_id_head != TICKER_NULL) {
 1006a42:	f89b a01d 	ldrb.w	sl, [fp, #29]
 1006a46:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
 1006a4a:	d183      	bne.n	1006954 <ticker_job+0x720>
			flag_compare_update = 1U;
 1006a4c:	e9dd 1306 	ldrd	r1, r3, [sp, #24]
 1006a50:	4551      	cmp	r1, sl
 1006a52:	bf18      	it	ne
 1006a54:	2301      	movne	r3, #1
	count_user = instance->count_user;
 1006a56:	f89b 2009 	ldrb.w	r2, [fp, #9]
	users = &instance->users[0];
 1006a5a:	f8db 1004 	ldr.w	r1, [fp, #4]
			flag_compare_update = 1U;
 1006a5e:	9307      	str	r3, [sp, #28]
	while (count_user--) {
 1006a60:	1e53      	subs	r3, r2, #1
 1006a62:	b2db      	uxtb	r3, r3
	users = &instance->users[0];
 1006a64:	9109      	str	r1, [sp, #36]	; 0x24
	while (count_user--) {
 1006a66:	2a00      	cmp	r2, #0
 1006a68:	f000 811a 	beq.w	1006ca0 <ticker_job+0xa6c>
 1006a6c:	9a09      	ldr	r2, [sp, #36]	; 0x24
 1006a6e:	eb02 08c3 	add.w	r8, r2, r3, lsl #3
		user_ops = (void *)&user->user_op[0];
 1006a72:	f8d8 3004 	ldr.w	r3, [r8, #4]
		user_ops_first = user->first;
 1006a76:	f898 4001 	ldrb.w	r4, [r8, #1]
		user_ops = (void *)&user->user_op[0];
 1006a7a:	9305      	str	r3, [sp, #20]
		while ((insert_head != TICKER_NULL) ||
 1006a7c:	9b01      	ldr	r3, [sp, #4]
 1006a7e:	2bff      	cmp	r3, #255	; 0xff
 1006a80:	d05e      	beq.n	1006b40 <ticker_job+0x90c>
				ticker = &node[id_insert];
 1006a82:	9a01      	ldr	r2, [sp, #4]
 1006a84:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 1006a88:	4692      	mov	sl, r2
 1006a8a:	9a03      	ldr	r2, [sp, #12]
 1006a8c:	ea4f 1c03 	mov.w	ip, r3, lsl #4
 1006a90:	eb02 1303 	add.w	r3, r2, r3, lsl #4
				insert_head = ticker->next;
 1006a94:	f812 200c 	ldrb.w	r2, [r2, ip]
 1006a98:	9201      	str	r2, [sp, #4]
				user_op = NULL;
 1006a9a:	2200      	movs	r2, #0
	ticker->next = TICKER_NULL;
 1006a9c:	20ff      	movs	r0, #255	; 0xff
 1006a9e:	7018      	strb	r0, [r3, #0]
	(void)ticker_enqueue(instance, id_insert);
 1006aa0:	f8db 7000 	ldr.w	r7, [fp]
	current = instance->ticker_id_head;
 1006aa4:	f89b 101d 	ldrb.w	r1, [fp, #29]
	ticker_new = &node[id];
 1006aa8:	eb07 060c 	add.w	r6, r7, ip
	while ((current != TICKER_NULL) && (ticks_to_expire >=
 1006aac:	4281      	cmp	r1, r0
	ticks_to_expire = ticker_new->ticks_to_expire;
 1006aae:	68b5      	ldr	r5, [r6, #8]
	previous = TICKER_NULL;
 1006ab0:	bf18      	it	ne
 1006ab2:	9304      	strne	r3, [sp, #16]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
 1006ab4:	d117      	bne.n	1006ae6 <ticker_job+0x8b2>
 1006ab6:	e0df      	b.n	1006c78 <ticker_job+0xa44>
 1006ab8:	01018478 	.word	0x01018478
 1006abc:	7f172b59 	.word	0x7f172b59
 1006ac0:	ff172b5a 	.word	0xff172b5a
		if (ticks_to_expire == 0 && (ticker_new->lazy_current >
 1006ac4:	ebb5 050c 	subs.w	r5, r5, ip
 1006ac8:	d105      	bne.n	1006ad6 <ticker_job+0x8a2>
 1006aca:	f8be e01e 	ldrh.w	lr, [lr, #30]
 1006ace:	8bf3      	ldrh	r3, [r6, #30]
 1006ad0:	4573      	cmp	r3, lr
 1006ad2:	f200 809b 	bhi.w	1006c0c <ticker_job+0x9d8>
		current = ticker_current->next;
 1006ad6:	f817 c009 	ldrb.w	ip, [r7, r9]
	while ((current != TICKER_NULL) && (ticks_to_expire >=
 1006ada:	4608      	mov	r0, r1
 1006adc:	f1bc 0fff 	cmp.w	ip, #255	; 0xff
 1006ae0:	f000 8089 	beq.w	1006bf6 <ticker_job+0x9c2>
 1006ae4:	4661      	mov	r1, ip
		(ticker_current = &node[current])->ticks_to_expire))) {
 1006ae6:	eb01 0941 	add.w	r9, r1, r1, lsl #1
 1006aea:	eb07 1e09 	add.w	lr, r7, r9, lsl #4
		(ticks_to_expire_current =
 1006aee:	f8de c008 	ldr.w	ip, [lr, #8]
		(ticker_current = &node[current])->ticks_to_expire))) {
 1006af2:	ea4f 1909 	mov.w	r9, r9, lsl #4
	while ((current != TICKER_NULL) && (ticks_to_expire >=
 1006af6:	45ac      	cmp	ip, r5
 1006af8:	d9e4      	bls.n	1006ac4 <ticker_job+0x890>
 1006afa:	9b04      	ldr	r3, [sp, #16]
	if (previous == TICKER_NULL) {
 1006afc:	28ff      	cmp	r0, #255	; 0xff
	ticker_new->ticks_to_expire = ticks_to_expire;
 1006afe:	60b5      	str	r5, [r6, #8]
	ticker_new->next = current;
 1006b00:	7031      	strb	r1, [r6, #0]
	if (previous == TICKER_NULL) {
 1006b02:	d17d      	bne.n	1006c00 <ticker_job+0x9cc>
		instance->ticker_id_head = id;
 1006b04:	f88b a01d 	strb.w	sl, [fp, #29]
	if (current != TICKER_NULL) {
 1006b08:	29ff      	cmp	r1, #255	; 0xff
 1006b0a:	d006      	beq.n	1006b1a <ticker_job+0x8e6>
		node[current].ticks_to_expire -= ticks_to_expire;
 1006b0c:	eb01 0141 	add.w	r1, r1, r1, lsl #1
 1006b10:	eb07 1701 	add.w	r7, r7, r1, lsl #4
 1006b14:	68b9      	ldr	r1, [r7, #8]
 1006b16:	1b4d      	subs	r5, r1, r5
 1006b18:	60bd      	str	r5, [r7, #8]
	ticker->req = ticker->ack + 1;
 1006b1a:	7899      	ldrb	r1, [r3, #2]
 1006b1c:	3101      	adds	r1, #1
 1006b1e:	7059      	strb	r1, [r3, #1]
			if (user_op) {
 1006b20:	2a00      	cmp	r2, #0
 1006b22:	d0ab      	beq.n	1006a7c <ticker_job+0x848>
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 1006b24:	f04f 0100 	mov.w	r1, #0
 1006b28:	7011      	strb	r1, [r2, #0]
	user_op->status = status;
 1006b2a:	2100      	movs	r1, #0
	if (user_op->fp_op_func) {
 1006b2c:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	user_op->status = status;
 1006b2e:	6291      	str	r1, [r2, #40]	; 0x28
	if (user_op->fp_op_func) {
 1006b30:	2b00      	cmp	r3, #0
 1006b32:	d0a3      	beq.n	1006a7c <ticker_job+0x848>
		user_op->fp_op_func(user_op->status, user_op->op_context);
 1006b34:	2000      	movs	r0, #0
 1006b36:	6b11      	ldr	r1, [r2, #48]	; 0x30
 1006b38:	4798      	blx	r3
		while ((insert_head != TICKER_NULL) ||
 1006b3a:	9b01      	ldr	r3, [sp, #4]
 1006b3c:	2bff      	cmp	r3, #255	; 0xff
 1006b3e:	d1a0      	bne.n	1006a82 <ticker_job+0x84e>
 1006b40:	f898 3002 	ldrb.w	r3, [r8, #2]
 1006b44:	42a3      	cmp	r3, r4
 1006b46:	d02c      	beq.n	1006ba2 <ticker_job+0x96e>
	user_op->status = status;
 1006b48:	2501      	movs	r5, #1
 1006b4a:	9e05      	ldr	r6, [sp, #20]
				user_op = &user_ops[user_ops_first];
 1006b4c:	2234      	movs	r2, #52	; 0x34
 1006b4e:	fb02 f104 	mul.w	r1, r2, r4
				if (first == user->count_user_op) {
 1006b52:	f898 2000 	ldrb.w	r2, [r8]
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
 1006b56:	5c70      	ldrb	r0, [r6, r1]
				first = user_ops_first + 1;
 1006b58:	3401      	adds	r4, #1
 1006b5a:	b2e4      	uxtb	r4, r4
					first = 0U;
 1006b5c:	42a2      	cmp	r2, r4
 1006b5e:	bf08      	it	eq
 1006b60:	2400      	moveq	r4, #0
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
 1006b62:	2804      	cmp	r0, #4
				user_op = &user_ops[user_ops_first];
 1006b64:	eb06 0201 	add.w	r2, r6, r1
				if (user_op->op != TICKER_USER_OP_TYPE_START) {
 1006b68:	d119      	bne.n	1006b9e <ticker_job+0x96a>
				id_insert = user_op->id;
 1006b6a:	f892 a001 	ldrb.w	sl, [r2, #1]
				ticker = &node[id_insert];
 1006b6e:	9b03      	ldr	r3, [sp, #12]
 1006b70:	eb0a 0c4a 	add.w	ip, sl, sl, lsl #1
 1006b74:	eb03 130c 	add.w	r3, r3, ip, lsl #4
				if (((ticker->req -
 1006b78:	7858      	ldrb	r0, [r3, #1]
				      ticker->ack) & 0xff) != 0U) {
 1006b7a:	789f      	ldrb	r7, [r3, #2]
				ticker = &node[id_insert];
 1006b7c:	ea4f 1c0c 	mov.w	ip, ip, lsl #4
				if (((ticker->req -
 1006b80:	1bc0      	subs	r0, r0, r7
 1006b82:	f010 00ff 	ands.w	r0, r0, #255	; 0xff
 1006b86:	d044      	beq.n	1006c12 <ticker_job+0x9de>
	user_op->op = TICKER_USER_OP_TYPE_NONE;
 1006b88:	f04f 0300 	mov.w	r3, #0
 1006b8c:	5473      	strb	r3, [r6, r1]
	if (user_op->fp_op_func) {
 1006b8e:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
	user_op->status = status;
 1006b90:	6295      	str	r5, [r2, #40]	; 0x28
	if (user_op->fp_op_func) {
 1006b92:	b113      	cbz	r3, 1006b9a <ticker_job+0x966>
		user_op->fp_op_func(user_op->status, user_op->op_context);
 1006b94:	2001      	movs	r0, #1
 1006b96:	6b11      	ldr	r1, [r2, #48]	; 0x30
 1006b98:	4798      	blx	r3
		while ((insert_head != TICKER_NULL) ||
 1006b9a:	f898 3002 	ldrb.w	r3, [r8, #2]
 1006b9e:	42a3      	cmp	r3, r4
 1006ba0:	d1d4      	bne.n	1006b4c <ticker_job+0x918>
	while (count_user--) {
 1006ba2:	9a09      	ldr	r2, [sp, #36]	; 0x24
 1006ba4:	f1a8 0308 	sub.w	r3, r8, #8
 1006ba8:	4542      	cmp	r2, r8
 1006baa:	d079      	beq.n	1006ca0 <ticker_job+0xa6c>
 1006bac:	4698      	mov	r8, r3
 1006bae:	e760      	b.n	1006a72 <ticker_job+0x83e>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1006bb0:	1b89      	subs	r1, r1, r6
 1006bb2:	f021 417f 	bic.w	r1, r1, #4278190080	; 0xff000000
		if (ticks_to_expire > delta_current_start) {
 1006bb6:	4291      	cmp	r1, r2
 1006bb8:	d214      	bcs.n	1006be4 <ticker_job+0x9b0>
			ticks_to_expire -= delta_current_start;
 1006bba:	1a52      	subs	r2, r2, r1
	if (ticks_to_expire > ticks_to_expire_minus) {
 1006bbc:	4290      	cmp	r0, r2
 1006bbe:	f4ff af33 	bcc.w	1006a28 <ticker_job+0x7f4>
 1006bc2:	1a80      	subs	r0, r0, r2
		ticks_to_expire = 0U;
 1006bc4:	2200      	movs	r2, #0
 1006bc6:	e731      	b.n	1006a2c <ticker_job+0x7f8>
		    !TICKER_RESCHEDULE_PENDING(ticker)) {
 1006bc8:	6a99      	ldr	r1, [r3, #40]	; 0x28
		    (((ticker->req - ticker->ack) & 0xff) == 2U) &&
 1006bca:	2c00      	cmp	r4, #0
 1006bcc:	f47f aeae 	bne.w	100692c <ticker_job+0x6f8>
		    !is_must_expire_skip &&
 1006bd0:	b119      	cbz	r1, 1006bda <ticker_job+0x9a6>
		    !TICKER_RESCHEDULE_PENDING(ticker)) {
 1006bd2:	7a0a      	ldrb	r2, [r1, #8]
 1006bd4:	2a01      	cmp	r2, #1
 1006bd6:	f43f af0c 	beq.w	10069f2 <ticker_job+0x7be>
			instance->ticker_id_slot_previous = id_expired;
 1006bda:	f88b a01c 	strb.w	sl, [fp, #28]
			instance->ticks_slot_previous = ticker->ticks_slot;
 1006bde:	f8cb 5018 	str.w	r5, [fp, #24]
 1006be2:	e6a3      	b.n	100692c <ticker_job+0x6f8>
			ticks_to_expire_minus +=
 1006be4:	4408      	add	r0, r1
 1006be6:	1a80      	subs	r0, r0, r2
	if (ticks_to_expire > ticks_to_expire_minus) {
 1006be8:	e7ec      	b.n	1006bc4 <ticker_job+0x990>
					ticker->req = ticker->ack;
 1006bea:	f04f 0c00 	mov.w	ip, #0
 1006bee:	789d      	ldrb	r5, [r3, #2]
					lazy_periodic = 0U;
 1006bf0:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 1006bf4:	e6d2      	b.n	100699c <ticker_job+0x768>
	ticker_new->next = current;
 1006bf6:	4661      	mov	r1, ip
 1006bf8:	9b04      	ldr	r3, [sp, #16]
	ticker_new->ticks_to_expire = ticks_to_expire;
 1006bfa:	60b5      	str	r5, [r6, #8]
	ticker_new->next = current;
 1006bfc:	f886 c000 	strb.w	ip, [r6]
		node[previous].next = id;
 1006c00:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 1006c04:	0100      	lsls	r0, r0, #4
 1006c06:	f807 a000 	strb.w	sl, [r7, r0]
 1006c0a:	e77d      	b.n	1006b08 <ticker_job+0x8d4>
 1006c0c:	4665      	mov	r5, ip
 1006c0e:	9b04      	ldr	r3, [sp, #16]
 1006c10:	e774      	b.n	1006afc <ticker_job+0x8c8>
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
 1006c12:	f64f 71ff 	movw	r1, #65535	; 0xffff
 1006c16:	8a97      	ldrh	r7, [r2, #20]
				ticker_job_op_start(ticker, user_op,
 1006c18:	f8db 5014 	ldr.w	r5, [fp, #20]
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
 1006c1c:	428f      	cmp	r7, r1
 1006c1e:	d030      	beq.n	1006c82 <ticker_job+0xa4e>
 1006c20:	f883 002c 	strb.w	r0, [r3, #44]	; 0x2c
	ticker->ext_data = start->ext_data;
 1006c24:	6a51      	ldr	r1, [r2, #36]	; 0x24
	ticker->ticks_periodic = start->ticks_periodic;
 1006c26:	68d6      	ldr	r6, [r2, #12]
	ticker->ext_data = start->ext_data;
 1006c28:	6299      	str	r1, [r3, #40]	; 0x28
	ticker->remainder_periodic = start->remainder_periodic;
 1006c2a:	6911      	ldr	r1, [r2, #16]
	ticker->ticks_periodic = start->ticks_periodic;
 1006c2c:	605e      	str	r6, [r3, #4]
	ticker->remainder_periodic = start->remainder_periodic;
 1006c2e:	6219      	str	r1, [r3, #32]
	ticks_to_expire_prep(ticker, ticks_current, start->ticks_at_start);
 1006c30:	6856      	ldr	r6, [r2, #4]
	ticker->timeout_func = start->fp_timeout_func;
 1006c32:	e9d2 1e06 	ldrd	r1, lr, [r2, #24]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
 1006c36:	839f      	strh	r7, [r3, #28]
	ticker->ticks_slot = start->ticks_slot;
 1006c38:	6199      	str	r1, [r3, #24]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
 1006c3a:	1b77      	subs	r7, r6, r5
	ticker->context = start->context;
 1006c3c:	6a11      	ldr	r1, [r2, #32]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
 1006c3e:	f417 0f00 	tst.w	r7, #8388608	; 0x800000
	ticker->context = start->context;
 1006c42:	e9c3 e103 	strd	lr, r1, [r3, #12]
	ticker->ticks_to_expire = start->ticks_first;
 1006c46:	6891      	ldr	r1, [r2, #8]
	if (!((ticks_at_start - ticks_current) & BIT(HAL_TICKER_CNTR_MSBIT))) {
 1006c48:	d10b      	bne.n	1006c62 <ticker_job+0xa2e>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1006c4a:	f027 477f 	bic.w	r7, r7, #4278190080	; 0xff000000
		ticks_to_expire += ticker_ticks_diff_get(ticks_at_start,
 1006c4e:	4439      	add	r1, r7
	if (ticks_to_expire > ticks_to_expire_minus) {
 1006c50:	b179      	cbz	r1, 1006c72 <ticker_job+0xa3e>
	ticker->force = 1U;
 1006c52:	2501      	movs	r5, #1
	ticker->ticks_to_expire = ticks_to_expire;
 1006c54:	6099      	str	r1, [r3, #8]
	ticker->remainder_current = 0U;
 1006c56:	2100      	movs	r1, #0
	ticker->ticks_to_expire_minus = ticks_to_expire_minus;
 1006c58:	6158      	str	r0, [r3, #20]
	ticker->remainder_current = 0U;
 1006c5a:	6259      	str	r1, [r3, #36]	; 0x24
	ticker->lazy_current = 0U;
 1006c5c:	83d9      	strh	r1, [r3, #30]
	ticker->force = 1U;
 1006c5e:	70dd      	strb	r5, [r3, #3]
}
 1006c60:	e71c      	b.n	1006a9c <ticker_job+0x868>
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 1006c62:	1bad      	subs	r5, r5, r6
 1006c64:	f025 457f 	bic.w	r5, r5, #4278190080	; 0xff000000
		if (ticks_to_expire > delta_current_start) {
 1006c68:	42a9      	cmp	r1, r5
 1006c6a:	d915      	bls.n	1006c98 <ticker_job+0xa64>
			ticks_to_expire -= delta_current_start;
 1006c6c:	1b49      	subs	r1, r1, r5
	if (ticks_to_expire > ticks_to_expire_minus) {
 1006c6e:	2900      	cmp	r1, #0
 1006c70:	d1ef      	bne.n	1006c52 <ticker_job+0xa1e>
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
 1006c72:	4608      	mov	r0, r1
		ticks_to_expire = 0U;
 1006c74:	2100      	movs	r1, #0
 1006c76:	e7ec      	b.n	1006c52 <ticker_job+0xa1e>
	ticker_new->next = current;
 1006c78:	f807 100c 	strb.w	r1, [r7, ip]
		instance->ticker_id_head = id;
 1006c7c:	f88b a01d 	strb.w	sl, [fp, #29]
	if (current != TICKER_NULL) {
 1006c80:	e74b      	b.n	1006b1a <ticker_job+0x8e6>
	ticker->must_expire = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 1U :
 1006c82:	2101      	movs	r1, #1
 1006c84:	f883 102c 	strb.w	r1, [r3, #44]	; 0x2c
	ticker->ext_data = start->ext_data;
 1006c88:	6a51      	ldr	r1, [r2, #36]	; 0x24
	ticker->ticks_periodic = start->ticks_periodic;
 1006c8a:	68d6      	ldr	r6, [r2, #12]
	ticker->ext_data = start->ext_data;
 1006c8c:	6299      	str	r1, [r3, #40]	; 0x28
	ticker->remainder_periodic = start->remainder_periodic;
 1006c8e:	6911      	ldr	r1, [r2, #16]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
 1006c90:	4607      	mov	r7, r0
	ticker->ticks_periodic = start->ticks_periodic;
 1006c92:	605e      	str	r6, [r3, #4]
	ticker->remainder_periodic = start->remainder_periodic;
 1006c94:	6219      	str	r1, [r3, #32]
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
 1006c96:	e7cb      	b.n	1006c30 <ticker_job+0x9fc>
			    (delta_current_start - ticks_to_expire);
 1006c98:	1a69      	subs	r1, r5, r1
	ticker->lazy_periodic = (start->lazy == TICKER_LAZY_MUST_EXPIRE) ? 0U :
 1006c9a:	4608      	mov	r0, r1
		ticks_to_expire = 0U;
 1006c9c:	2100      	movs	r1, #0
 1006c9e:	e7d8      	b.n	1006c52 <ticker_job+0xa1e>
	u8_t  rescheduled = 0U;
 1006ca0:	2200      	movs	r2, #0
	nodes = &instance->nodes[0];
 1006ca2:	f8db 4000 	ldr.w	r4, [fp]
	while (rescheduling) {
 1006ca6:	f89b a01d 	ldrb.w	sl, [fp, #29]
 1006caa:	f8cd b004 	str.w	fp, [sp, #4]
		while (ticker_id_head != TICKER_NULL) {
 1006cae:	f1ba 0fff 	cmp.w	sl, #255	; 0xff
 1006cb2:	d00f      	beq.n	1006cd4 <ticker_job+0xaa0>
 1006cb4:	46d6      	mov	lr, sl
			ticker = &nodes[ticker_id_head];
 1006cb6:	eb0e 034e 	add.w	r3, lr, lr, lsl #1
 1006cba:	eb04 1103 	add.w	r1, r4, r3, lsl #4
			ext_data = ticker->ext_data;
 1006cbe:	6a88      	ldr	r0, [r1, #40]	; 0x28
			ticker = &nodes[ticker_id_head];
 1006cc0:	011b      	lsls	r3, r3, #4
			if (ext_data && ext_data->reschedule_state ==
 1006cc2:	b110      	cbz	r0, 1006cca <ticker_job+0xa96>
 1006cc4:	7a05      	ldrb	r5, [r0, #8]
 1006cc6:	2d01      	cmp	r5, #1
 1006cc8:	d015      	beq.n	1006cf6 <ticker_job+0xac2>
			ticker_id_head = ticker->next;
 1006cca:	f814 e003 	ldrb.w	lr, [r4, r3]
		while (ticker_id_head != TICKER_NULL) {
 1006cce:	f1be 0fff 	cmp.w	lr, #255	; 0xff
 1006cd2:	d1f0      	bne.n	1006cb6 <ticker_job+0xa82>
	return rescheduled;
 1006cd4:	f8dd b004 	ldr.w	fp, [sp, #4]
		if (ticker_job_reschedule_in_window(instance, ticks_elapsed)) {
 1006cd8:	2a00      	cmp	r2, #0
 1006cda:	f43f ada6 	beq.w	100682a <ticker_job+0x5f6>
	if (instance->ticker_id_head != ticker_id_old_head) {
 1006cde:	9b06      	ldr	r3, [sp, #24]
 1006ce0:	4553      	cmp	r3, sl
 1006ce2:	f47f ada6 	bne.w	1006832 <ticker_job+0x5fe>
	if (!pending) {
 1006ce6:	9b08      	ldr	r3, [sp, #32]
 1006ce8:	2b00      	cmp	r3, #0
 1006cea:	f000 8170 	beq.w	1006fce <ticker_job+0xd9a>
	instance->job_guard = 0U;
 1006cee:	2300      	movs	r3, #0
 1006cf0:	f88b 301e 	strb.w	r3, [fp, #30]
	if (flag_compare_update) {
 1006cf4:	e5a6      	b.n	1006844 <ticker_job+0x610>
		if (instance->ticker_id_slot_previous != TICKER_NULL &&
 1006cf6:	9b01      	ldr	r3, [sp, #4]
 1006cf8:	4684      	mov	ip, r0
 1006cfa:	7f1b      	ldrb	r3, [r3, #28]
 1006cfc:	2bff      	cmp	r3, #255	; 0xff
 1006cfe:	d04f      	beq.n	1006da0 <ticker_job+0xb6c>
			instance->ticks_slot_previous > ticks_elapsed) {
 1006d00:	9b01      	ldr	r3, [sp, #4]
 1006d02:	6998      	ldr	r0, [r3, #24]
		if (instance->ticker_id_slot_previous != TICKER_NULL &&
 1006d04:	9b02      	ldr	r3, [sp, #8]
 1006d06:	4283      	cmp	r3, r0
 1006d08:	d24a      	bcs.n	1006da0 <ticker_job+0xb6c>
			window_start_ticks = instance->ticks_slot_previous -
 1006d0a:	1ac0      	subs	r0, r0, r3
		if (ext_data->ticks_drift < ext_data->ticks_slot_window) {
 1006d0c:	e9dc 5300 	ldrd	r5, r3, [ip]
 1006d10:	42ab      	cmp	r3, r5
		ticker_id_iter = nodes[ticker_id_head].next;
 1006d12:	780f      	ldrb	r7, [r1, #0]
		if (ext_data->ticks_drift < ext_data->ticks_slot_window) {
 1006d14:	d239      	bcs.n	1006d8a <ticker_job+0xb56>
		while (ticker_id_iter != TICKER_NULL &&
 1006d16:	2fff      	cmp	r7, #255	; 0xff
			ticks_slot_window = ext_data->ticks_slot_window -
 1006d18:	eba5 0503 	sub.w	r5, r5, r3
		while (ticker_id_iter != TICKER_NULL &&
 1006d1c:	d035      	beq.n	1006d8a <ticker_job+0xb56>
		       ticks_start_offset + ticker->ticks_slot <=
 1006d1e:	698e      	ldr	r6, [r1, #24]
		while (ticker_id_iter != TICKER_NULL &&
 1006d20:	2300      	movs	r3, #0
 1006d22:	42b5      	cmp	r5, r6
 1006d24:	d33f      	bcc.n	1006da6 <ticker_job+0xb72>
 1006d26:	46b1      	mov	r9, r6
 1006d28:	4698      	mov	r8, r3
 1006d2a:	463a      	mov	r2, r7
 1006d2c:	9103      	str	r1, [sp, #12]
 1006d2e:	e01b      	b.n	1006d68 <ticker_job+0xb34>
			if (node->ticks_to_expire >
 1006d30:	f8d1 b008 	ldr.w	fp, [r1, #8]
					MIN(ticks_slot_window,
 1006d34:	f1ab 0304 	sub.w	r3, fp, #4
			if (node->ticks_to_expire >
 1006d38:	f1bb 0f04 	cmp.w	fp, #4
					MIN(ticks_slot_window,
 1006d3c:	4443      	add	r3, r8
			if (node->ticks_to_expire >
 1006d3e:	d908      	bls.n	1006d52 <ticker_job+0xb1e>
				window_end_ticks =
 1006d40:	42ab      	cmp	r3, r5
 1006d42:	bf28      	it	cs
 1006d44:	462b      	movcs	r3, r5
			if (window_end_ticks > ticks_start_offset +
 1006d46:	454b      	cmp	r3, r9
 1006d48:	d903      	bls.n	1006d52 <ticker_job+0xb1e>
			if (ticks_to_expire != 0U &&
 1006d4a:	1b9b      	subs	r3, r3, r6
 1006d4c:	d001      	beq.n	1006d52 <ticker_job+0xb1e>
 1006d4e:	4283      	cmp	r3, r0
 1006d50:	d228      	bcs.n	1006da4 <ticker_job+0xb70>
			window_start_ticks  = node->ticks_to_expire +
 1006d52:	6988      	ldr	r0, [r1, #24]
			ticker_id_iter = node->next;
 1006d54:	5ca2      	ldrb	r2, [r4, r2]
			window_start_ticks  = node->ticks_to_expire +
 1006d56:	4458      	add	r0, fp
			ticks_start_offset += node->ticks_to_expire;
 1006d58:	44d8      	add	r8, fp
			ticks_to_expire     = ticks_slot_window -
 1006d5a:	1bab      	subs	r3, r5, r6
		while (ticker_id_iter != TICKER_NULL &&
 1006d5c:	2aff      	cmp	r2, #255	; 0xff
		       ticks_start_offset + ticker->ticks_slot <=
 1006d5e:	eb08 0906 	add.w	r9, r8, r6
		while (ticker_id_iter != TICKER_NULL &&
 1006d62:	d01f      	beq.n	1006da4 <ticker_job+0xb70>
 1006d64:	454d      	cmp	r5, r9
 1006d66:	d31d      	bcc.n	1006da4 <ticker_job+0xb70>
			node = &nodes[ticker_id_iter];
 1006d68:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 1006d6c:	eb04 1102 	add.w	r1, r4, r2, lsl #4
			if (node->ext_data &&
 1006d70:	f8d1 b028 	ldr.w	fp, [r1, #40]	; 0x28
			node = &nodes[ticker_id_iter];
 1006d74:	0112      	lsls	r2, r2, #4
			if (node->ext_data &&
 1006d76:	f1bb 0f00 	cmp.w	fp, #0
 1006d7a:	d0d9      	beq.n	1006d30 <ticker_job+0xafc>
 1006d7c:	f89b b008 	ldrb.w	fp, [fp, #8]
 1006d80:	f1bb 0f01 	cmp.w	fp, #1
 1006d84:	d1d4      	bne.n	1006d30 <ticker_job+0xafc>
				ticker_id_iter = node->next;
 1006d86:	5ca2      	ldrb	r2, [r4, r2]
				continue;
 1006d88:	e7e8      	b.n	1006d5c <ticker_job+0xb28>
		ticker->ticks_to_expire = ticks_to_expire;
 1006d8a:	2300      	movs	r3, #0
 1006d8c:	608b      	str	r3, [r1, #8]
		ticker->lazy_current--;
 1006d8e:	8bcb      	ldrh	r3, [r1, #30]
		rescheduled  = 1U;
 1006d90:	2201      	movs	r2, #1
		ticker->lazy_current--;
 1006d92:	3b01      	subs	r3, #1
 1006d94:	83cb      	strh	r3, [r1, #30]
		ext_data->reschedule_state =
 1006d96:	f04f 0302 	mov.w	r3, #2
 1006d9a:	f88c 3008 	strb.w	r3, [ip, #8]
		rescheduled  = 1U;
 1006d9e:	e786      	b.n	1006cae <ticker_job+0xa7a>
		window_start_ticks = 0U;
 1006da0:	2000      	movs	r0, #0
 1006da2:	e7b3      	b.n	1006d0c <ticker_job+0xad8>
 1006da4:	9903      	ldr	r1, [sp, #12]
		ticker->ticks_to_expire = ticks_to_expire;
 1006da6:	463a      	mov	r2, r7
 1006da8:	f04f 08ff 	mov.w	r8, #255	; 0xff
 1006dac:	608b      	str	r3, [r1, #8]
		while (ticker_id_iter != TICKER_NULL) {
 1006dae:	e000      	b.n	1006db2 <ticker_job+0xb7e>
 1006db0:	462a      	mov	r2, r5
			node = &nodes[ticker_id_iter];
 1006db2:	eb02 0042 	add.w	r0, r2, r2, lsl #1
 1006db6:	eb04 1900 	add.w	r9, r4, r0, lsl #4
			if (ticker->ticks_to_expire > node->ticks_to_expire) {
 1006dba:	f8d9 6008 	ldr.w	r6, [r9, #8]
			node = &nodes[ticker_id_iter];
 1006dbe:	0105      	lsls	r5, r0, #4
			if (ticker->ticks_to_expire > node->ticks_to_expire) {
 1006dc0:	429e      	cmp	r6, r3
			node = &nodes[ticker_id_iter];
 1006dc2:	ea4f 0042 	mov.w	r0, r2, lsl #1
			if (ticker->ticks_to_expire > node->ticks_to_expire) {
 1006dc6:	d23a      	bcs.n	1006e3e <ticker_job+0xc0a>
				ticker->ticks_to_expire -=
 1006dc8:	1b9b      	subs	r3, r3, r6
 1006dca:	608b      	str	r3, [r1, #8]
			ticker_id_iter = node->next;
 1006dcc:	5d65      	ldrb	r5, [r4, r5]
		while (ticker_id_iter != TICKER_NULL) {
 1006dce:	4690      	mov	r8, r2
 1006dd0:	2dff      	cmp	r5, #255	; 0xff
 1006dd2:	d1ed      	bne.n	1006db0 <ticker_job+0xb7c>
			instance->ticker_id_head = nodes[ticker_id_head].next;
 1006dd4:	9b01      	ldr	r3, [sp, #4]
			nodes[ticker_id_head].next = nodes[ticker_id_prev].next;
 1006dd6:	4402      	add	r2, r0
			instance->ticker_id_head = nodes[ticker_id_head].next;
 1006dd8:	775f      	strb	r7, [r3, #29]
			nodes[ticker_id_head].next = nodes[ticker_id_prev].next;
 1006dda:	0112      	lsls	r2, r2, #4
 1006ddc:	5ca3      	ldrb	r3, [r4, r2]
			nodes[ticker_id_prev].next = ticker_id_head;
 1006dde:	46ba      	mov	sl, r7
			nodes[ticker_id_head].next = nodes[ticker_id_prev].next;
 1006de0:	700b      	strb	r3, [r1, #0]
			nodes[ticker_id_prev].next = ticker_id_head;
 1006de2:	f804 e002 	strb.w	lr, [r4, r2]
 1006de6:	e7d2      	b.n	1006d8e <ticker_job+0xb5a>
					while (ticks_to_expire <
 1006de8:	9e04      	ldr	r6, [sp, #16]
 1006dea:	4296      	cmp	r6, r2
 1006dec:	f67f adfc 	bls.w	10069e8 <ticker_job+0x7b4>
 1006df0:	4633      	mov	r3, r6
 1006df2:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 1006df4:	f104 0c01 	add.w	ip, r4, #1
 1006df8:	950d      	str	r5, [sp, #52]	; 0x34
 1006dfa:	e005      	b.n	1006e08 <ticker_job+0xbd4>
 1006dfc:	4626      	mov	r6, r4
						ticks_to_expire +=
 1006dfe:	4432      	add	r2, r6
						lazy++;
 1006e00:	3001      	adds	r0, #1
					while (ticks_to_expire <
 1006e02:	4293      	cmp	r3, r2
						lazy++;
 1006e04:	b280      	uxth	r0, r0
					while (ticks_to_expire <
 1006e06:	d911      	bls.n	1006e2c <ticker_job+0xbf8>
	if ((ticker->remainder_current < BIT(31)) &&
 1006e08:	4e80      	ldr	r6, [pc, #512]	; (100700c <ticker_job+0xdd8>)
 1006e0a:	4d81      	ldr	r5, [pc, #516]	; (1007010 <ticker_job+0xddc>)
	ticker->remainder_current += ticker->remainder_periodic;
 1006e0c:	4439      	add	r1, r7
	if ((ticker->remainder_current < BIT(31)) &&
 1006e0e:	198e      	adds	r6, r1, r6
 1006e10:	42ae      	cmp	r6, r5
 1006e12:	d8f3      	bhi.n	1006dfc <ticker_job+0xbc8>
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 1006e14:	4666      	mov	r6, ip
 1006e16:	f1a1 71e8 	sub.w	r1, r1, #30408704	; 0x1d00000
						ticks_to_expire +=
 1006e1a:	4432      	add	r2, r6
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 1006e1c:	f5a1 31d4 	sub.w	r1, r1, #108544	; 0x1a800
						lazy++;
 1006e20:	3001      	adds	r0, #1
					while (ticks_to_expire <
 1006e22:	4293      	cmp	r3, r2
		ticker->remainder_current -= HAL_TICKER_REMAINDER_RANGE;
 1006e24:	f5a1 71a5 	sub.w	r1, r1, #330	; 0x14a
						lazy++;
 1006e28:	b280      	uxth	r0, r0
					while (ticks_to_expire <
 1006e2a:	d8ed      	bhi.n	1006e08 <ticker_job+0xbd4>
 1006e2c:	e9dd 350c 	ldrd	r3, r5, [sp, #48]	; 0x30
 1006e30:	9c09      	ldr	r4, [sp, #36]	; 0x24
 1006e32:	6259      	str	r1, [r3, #36]	; 0x24
 1006e34:	4404      	add	r4, r0
 1006e36:	b2a0      	uxth	r0, r4
 1006e38:	9009      	str	r0, [sp, #36]	; 0x24
 1006e3a:	e5d5      	b.n	10069e8 <ticker_job+0x7b4>
 1006e3c:	4770      	bx	lr
				node->ticks_to_expire -=
 1006e3e:	1af3      	subs	r3, r6, r3
		if (ticker_id_prev != TICKER_NULL) {
 1006e40:	f1b8 0fff 	cmp.w	r8, #255	; 0xff
				node->ticks_to_expire -=
 1006e44:	f8c9 3008 	str.w	r3, [r9, #8]
		if (ticker_id_prev != TICKER_NULL) {
 1006e48:	d0a1      	beq.n	1006d8e <ticker_job+0xb5a>
 1006e4a:	4642      	mov	r2, r8
 1006e4c:	0050      	lsls	r0, r2, #1
 1006e4e:	e7c1      	b.n	1006dd4 <ticker_job+0xba0>
	if (!pending) {
 1006e50:	9b08      	ldr	r3, [sp, #32]
 1006e52:	2b00      	cmp	r3, #0
 1006e54:	f000 80a2 	beq.w	1006f9c <ticker_job+0xd68>
	instance->job_guard = 0U;
 1006e58:	2300      	movs	r3, #0
 1006e5a:	f88b 301e 	strb.w	r3, [fp, #30]
	if (flag_compare_update) {
 1006e5e:	9b07      	ldr	r3, [sp, #28]
 1006e60:	2b00      	cmp	r3, #0
 1006e62:	f040 80be 	bne.w	1006fe2 <ticker_job+0xdae>
 1006e66:	f89b 201f 	ldrb.w	r2, [fp, #31]
	if (instance->worker_trigger) {
 1006e6a:	b16a      	cbz	r2, 1006e88 <ticker_job+0xc54>
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
 1006e6c:	f8db 4024 	ldr.w	r4, [fp, #36]	; 0x24
 1006e70:	465b      	mov	r3, fp
 1006e72:	2201      	movs	r2, #1
 1006e74:	2103      	movs	r1, #3
 1006e76:	2004      	movs	r0, #4
 1006e78:	46a4      	mov	ip, r4
}
 1006e7a:	b00f      	add	sp, #60	; 0x3c
 1006e7c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		instance->sched_cb(TICKER_CALL_ID_JOB, TICKER_CALL_ID_WORKER, 1,
 1006e80:	4760      	bx	ip
	instance->job_guard = 0U;
 1006e82:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 1006e84:	f88b 301e 	strb.w	r3, [fp, #30]
}
 1006e88:	b00f      	add	sp, #60	; 0x3c
 1006e8a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			ticker->ticks_to_expire -= ticks_elapsed;
 1006e8e:	eba2 0209 	sub.w	r2, r2, r9
 1006e92:	609a      	str	r2, [r3, #8]
			break;
 1006e94:	e5da      	b.n	1006a4c <ticker_job+0x818>
	count_user = instance->count_user;
 1006e96:	f89b 3009 	ldrb.w	r3, [fp, #9]
	users = &instance->users[0];
 1006e9a:	f8db 2004 	ldr.w	r2, [fp, #4]
	while (count_user--) {
 1006e9e:	1e5c      	subs	r4, r3, #1
	users = &instance->users[0];
 1006ea0:	9201      	str	r2, [sp, #4]
	while (count_user--) {
 1006ea2:	b2e4      	uxtb	r4, r4
 1006ea4:	2b00      	cmp	r3, #0
 1006ea6:	f43f acc8 	beq.w	100683a <ticker_job+0x606>
		flag_compare_update = 1U;
 1006eaa:	2301      	movs	r3, #1
 1006eac:	9307      	str	r3, [sp, #28]
 1006eae:	9b01      	ldr	r3, [sp, #4]
 1006eb0:	eb03 04c4 	add.w	r4, r3, r4, lsl #3
		while (user->first != user->last) {
 1006eb4:	7863      	ldrb	r3, [r4, #1]
 1006eb6:	78e2      	ldrb	r2, [r4, #3]
		user_op = &user->user_op[0];
 1006eb8:	6866      	ldr	r6, [r4, #4]
		while (user->first != user->last) {
 1006eba:	429a      	cmp	r2, r3
 1006ebc:	d05b      	beq.n	1006f76 <ticker_job+0xd42>
			uop->status = TICKER_STATUS_FAILURE;
 1006ebe:	f04f 0801 	mov.w	r8, #1
 1006ec2:	e00b      	b.n	1006edc <ticker_job+0xca8>
	switch (uop->op) {
 1006ec4:	2901      	cmp	r1, #1
 1006ec6:	d052      	beq.n	1006f6e <ticker_job+0xd3a>
			first = user->first + 1;
 1006ec8:	7863      	ldrb	r3, [r4, #1]
			if (first == user->count_user_op) {
 1006eca:	7821      	ldrb	r1, [r4, #0]
			first = user->first + 1;
 1006ecc:	3301      	adds	r3, #1
 1006ece:	b2db      	uxtb	r3, r3
				first = 0U;
 1006ed0:	4299      	cmp	r1, r3
 1006ed2:	bf08      	it	eq
 1006ed4:	2300      	moveq	r3, #0
		while (user->first != user->last) {
 1006ed6:	429a      	cmp	r2, r3
			user->first = first;
 1006ed8:	7063      	strb	r3, [r4, #1]
		while (user->first != user->last) {
 1006eda:	d04c      	beq.n	1006f76 <ticker_job+0xd42>
			ticker_job_op_inquire(instance, &user_op[user->first]);
 1006edc:	2134      	movs	r1, #52	; 0x34
 1006ede:	fb01 f303 	mul.w	r3, r1, r3
	switch (uop->op) {
 1006ee2:	5cf1      	ldrb	r1, [r6, r3]
			ticker_job_op_inquire(instance, &user_op[user->first]);
 1006ee4:	4433      	add	r3, r6
	switch (uop->op) {
 1006ee6:	2902      	cmp	r1, #2
 1006ee8:	d01b      	beq.n	1006f22 <ticker_job+0xcee>
 1006eea:	2903      	cmp	r1, #3
 1006eec:	d1ea      	bne.n	1006ec4 <ticker_job+0xc90>
		if (uop->id < instance->count_node) {
 1006eee:	785a      	ldrb	r2, [r3, #1]
 1006ef0:	f89b 1008 	ldrb.w	r1, [fp, #8]
 1006ef4:	4291      	cmp	r1, r2
 1006ef6:	d911      	bls.n	1006f1c <ticker_job+0xce8>
			node[uop->id].priority =
 1006ef8:	f8db 1000 	ldr.w	r1, [fp]
 1006efc:	7918      	ldrb	r0, [r3, #4]
 1006efe:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 1006f02:	eb01 1202 	add.w	r2, r1, r2, lsl #4
 1006f06:	f882 002d 	strb.w	r0, [r2, #45]	; 0x2d
			uop->status = TICKER_STATUS_SUCCESS;
 1006f0a:	2200      	movs	r2, #0
 1006f0c:	629a      	str	r2, [r3, #40]	; 0x28
		fp_op_func = uop->fp_op_func;
 1006f0e:	6ada      	ldr	r2, [r3, #44]	; 0x2c
	if (fp_op_func) {
 1006f10:	b112      	cbz	r2, 1006f18 <ticker_job+0xce4>
		fp_op_func(uop->status, uop->op_context);
 1006f12:	6b19      	ldr	r1, [r3, #48]	; 0x30
 1006f14:	6a98      	ldr	r0, [r3, #40]	; 0x28
 1006f16:	4790      	blx	r2
 1006f18:	78e2      	ldrb	r2, [r4, #3]
 1006f1a:	e7d5      	b.n	1006ec8 <ticker_job+0xc94>
			uop->status = TICKER_STATUS_FAILURE;
 1006f1c:	f8c3 8028 	str.w	r8, [r3, #40]	; 0x28
 1006f20:	e7f5      	b.n	1006f0e <ticker_job+0xcda>
		ticker_by_next_slot_get(instance,
 1006f22:	e9d3 c101 	ldrd	ip, r1, [r3, #4]
	_ticker_id_head = *ticker_id_head;
 1006f26:	f89c 2000 	ldrb.w	r2, [ip]
		ticker_by_next_slot_get(instance,
 1006f2a:	f8d3 e00c 	ldr.w	lr, [r3, #12]
	if ((_ticker_id_head == TICKER_NULL) ||
 1006f2e:	2aff      	cmp	r2, #255	; 0xff
	node = instance->nodes;
 1006f30:	f8db 5000 	ldr.w	r5, [fp]
	if ((_ticker_id_head == TICKER_NULL) ||
 1006f34:	f8db 0014 	ldr.w	r0, [fp, #20]
 1006f38:	d002      	beq.n	1006f40 <ticker_job+0xd0c>
 1006f3a:	680f      	ldr	r7, [r1, #0]
 1006f3c:	4287      	cmp	r7, r0
 1006f3e:	d026      	beq.n	1006f8e <ticker_job+0xd5a>
		_ticker_id_head = instance->ticker_id_head;
 1006f40:	f89b 201d 	ldrb.w	r2, [fp, #29]
		*ticks_current = instance->ticks_current;
 1006f44:	6008      	str	r0, [r1, #0]
		_ticks_to_expire = 0U;
 1006f46:	2100      	movs	r1, #0
 1006f48:	e00b      	b.n	1006f62 <ticker_job+0xd2e>
	       ((ticker = &node[_ticker_id_head])->ticks_slot == 0U)) {
 1006f4a:	eb02 0042 	add.w	r0, r2, r2, lsl #1
 1006f4e:	eb05 1a00 	add.w	sl, r5, r0, lsl #4
	while ((_ticker_id_head != TICKER_NULL) &&
 1006f52:	f8da 7018 	ldr.w	r7, [sl, #24]
	       ((ticker = &node[_ticker_id_head])->ticks_slot == 0U)) {
 1006f56:	0100      	lsls	r0, r0, #4
	while ((_ticker_id_head != TICKER_NULL) &&
 1006f58:	b9af      	cbnz	r7, 1006f86 <ticker_job+0xd52>
		_ticks_to_expire += ticker->ticks_to_expire;
 1006f5a:	f8da 9008 	ldr.w	r9, [sl, #8]
		_ticker_id_head = ticker->next;
 1006f5e:	5c2a      	ldrb	r2, [r5, r0]
		_ticks_to_expire += ticker->ticks_to_expire;
 1006f60:	4449      	add	r1, r9
	while ((_ticker_id_head != TICKER_NULL) &&
 1006f62:	2aff      	cmp	r2, #255	; 0xff
 1006f64:	d1f1      	bne.n	1006f4a <ticker_job+0xd16>
	*ticker_id_head = _ticker_id_head;
 1006f66:	f88c 2000 	strb.w	r2, [ip]
	*ticks_to_expire = _ticks_to_expire;
 1006f6a:	f8ce 1000 	str.w	r1, [lr]
		uop->status = TICKER_STATUS_SUCCESS;
 1006f6e:	2200      	movs	r2, #0
 1006f70:	629a      	str	r2, [r3, #40]	; 0x28
		fp_op_func = uop->fp_op_func;
 1006f72:	6ada      	ldr	r2, [r3, #44]	; 0x2c
		break;
 1006f74:	e7cc      	b.n	1006f10 <ticker_job+0xcdc>
	while (count_user--) {
 1006f76:	9a01      	ldr	r2, [sp, #4]
 1006f78:	f1a4 0308 	sub.w	r3, r4, #8
 1006f7c:	42a2      	cmp	r2, r4
 1006f7e:	f43f af6b 	beq.w	1006e58 <ticker_job+0xc24>
 1006f82:	461c      	mov	r4, r3
 1006f84:	e796      	b.n	1006eb4 <ticker_job+0xc80>
		_ticks_to_expire += ticker->ticks_to_expire;
 1006f86:	f8da 0008 	ldr.w	r0, [sl, #8]
 1006f8a:	4401      	add	r1, r0
 1006f8c:	e7eb      	b.n	1006f66 <ticker_job+0xd32>
		ticker = &node[_ticker_id_head];
 1006f8e:	eb02 0242 	add.w	r2, r2, r2, lsl #1
 1006f92:	0112      	lsls	r2, r2, #4
		_ticker_id_head = ticker->next;
 1006f94:	5caa      	ldrb	r2, [r5, r2]
	_ticks_to_expire = *ticks_to_expire;
 1006f96:	f8de 1000 	ldr.w	r1, [lr]
	while ((_ticker_id_head != TICKER_NULL) &&
 1006f9a:	e7e2      	b.n	1006f62 <ticker_job+0xd2e>
	count_user = instance->count_user;
 1006f9c:	f89b 3009 	ldrb.w	r3, [fp, #9]
	users = &instance->users[0];
 1006fa0:	f8db 2004 	ldr.w	r2, [fp, #4]
	while (count_user--) {
 1006fa4:	1e5c      	subs	r4, r3, #1
	users = &instance->users[0];
 1006fa6:	9201      	str	r2, [sp, #4]
	while (count_user--) {
 1006fa8:	b2e4      	uxtb	r4, r4
 1006faa:	2b00      	cmp	r3, #0
 1006fac:	f47f af7f 	bne.w	1006eae <ticker_job+0xc7a>
 1006fb0:	e752      	b.n	1006e58 <ticker_job+0xc24>
		if (cntr_stop() == 0) {
 1006fb2:	f00a fcb3 	bl	101191c <cntr_stop>
 1006fb6:	2800      	cmp	r0, #0
 1006fb8:	f47f af55 	bne.w	1006e66 <ticker_job+0xc32>
			instance->ticks_slot_previous = 0U;
 1006fbc:	f8cb 0018 	str.w	r0, [fp, #24]
			instance->ticks_current = cntr_cnt_get();
 1006fc0:	f00a fcc6 	bl	1011950 <cntr_cnt_get>
 1006fc4:	f89b 201f 	ldrb.w	r2, [fp, #31]
 1006fc8:	f8cb 0014 	str.w	r0, [fp, #20]
 1006fcc:	e74d      	b.n	1006e6a <ticker_job+0xc36>
	count_user = instance->count_user;
 1006fce:	f89b 3009 	ldrb.w	r3, [fp, #9]
	users = &instance->users[0];
 1006fd2:	f8db 1004 	ldr.w	r1, [fp, #4]
	while (count_user--) {
 1006fd6:	1e5c      	subs	r4, r3, #1
	users = &instance->users[0];
 1006fd8:	9101      	str	r1, [sp, #4]
	while (count_user--) {
 1006fda:	b2e4      	uxtb	r4, r4
 1006fdc:	b18b      	cbz	r3, 1007002 <ticker_job+0xdce>
			flag_compare_update = 1U;
 1006fde:	9207      	str	r2, [sp, #28]
 1006fe0:	e765      	b.n	1006eae <ticker_job+0xc7a>
 1006fe2:	f89b a01d 	ldrb.w	sl, [fp, #29]
 1006fe6:	e42d      	b.n	1006844 <ticker_job+0x610>
		ticks_current = cntr_cnt_get();
 1006fe8:	f00a fcb2 	bl	1011950 <cntr_cnt_get>
 1006fec:	4604      	mov	r4, r0
		if (cntr_start() == 0) {
 1006fee:	f00a fc85 	bl	10118fc <cntr_start>
 1006ff2:	f89b a01d 	ldrb.w	sl, [fp, #29]
 1006ff6:	2800      	cmp	r0, #0
 1006ff8:	f47f ac2c 	bne.w	1006854 <ticker_job+0x620>
			instance->ticks_current = ticks_current;
 1006ffc:	f8cb 4014 	str.w	r4, [fp, #20]
 1007000:	e428      	b.n	1006854 <ticker_job+0x620>
	instance->job_guard = 0U;
 1007002:	9b08      	ldr	r3, [sp, #32]
 1007004:	f88b 301e 	strb.w	r3, [fp, #30]
	if (flag_compare_update) {
 1007008:	e41c      	b.n	1006844 <ticker_job+0x610>
 100700a:	bf00      	nop
 100700c:	ff172b5a 	.word	0xff172b5a
 1007010:	7f172b59 	.word	0x7f172b59

01007014 <ticker_init>:
{
 1007014:	b4f0      	push	{r4, r5, r6, r7}
 1007016:	9f04      	ldr	r7, [sp, #16]
 1007018:	f89d 5014 	ldrb.w	r5, [sp, #20]
 100701c:	9e06      	ldr	r6, [sp, #24]
	if (instance_index >= TICKER_INSTANCE_MAX) {
 100701e:	2800      	cmp	r0, #0
 1007020:	d13c      	bne.n	100709c <ticker_init+0x88>
	instance->count_node = count_node;
 1007022:	f8df c080 	ldr.w	ip, [pc, #128]	; 10070a4 <ticker_init+0x90>
	while (count_node--) {
 1007026:	1e4c      	subs	r4, r1, #1
	instance->count_node = count_node;
 1007028:	f88c 1008 	strb.w	r1, [ip, #8]
	instance->nodes = node;
 100702c:	f8cc 2000 	str.w	r2, [ip]
	while (count_node--) {
 1007030:	b2e4      	uxtb	r4, r4
 1007032:	b149      	cbz	r1, 1007048 <ticker_init+0x34>
 1007034:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 1007038:	eb02 1104 	add.w	r1, r2, r4, lsl #4
 100703c:	4291      	cmp	r1, r2
		instance->nodes[count_node].priority = 0;
 100703e:	f881 002d 	strb.w	r0, [r1, #45]	; 0x2d
	while (count_node--) {
 1007042:	f1a1 0130 	sub.w	r1, r1, #48	; 0x30
 1007046:	d1f9      	bne.n	100703c <ticker_init+0x28>
	while (count_user--) {
 1007048:	1e5a      	subs	r2, r3, #1
	instance->count_user = count_user;
 100704a:	f88c 3009 	strb.w	r3, [ip, #9]
	instance->users = user;
 100704e:	f8cc 7004 	str.w	r7, [ip, #4]
	while (count_user--) {
 1007052:	b2d2      	uxtb	r2, r2
 1007054:	b16b      	cbz	r3, 1007072 <ticker_init+0x5e>
		user_op_ += users[count_user].count_user_op;
 1007056:	2034      	movs	r0, #52	; 0x34
 1007058:	eb07 03c2 	add.w	r3, r7, r2, lsl #3
		users[count_user].user_op = user_op_;
 100705c:	4619      	mov	r1, r3
 100705e:	605e      	str	r6, [r3, #4]
		user_op_ += users[count_user].count_user_op;
 1007060:	f813 2908 	ldrb.w	r2, [r3], #-8
	while (count_user--) {
 1007064:	428f      	cmp	r7, r1
		count_op -= users[count_user].count_user_op;
 1007066:	eba5 0502 	sub.w	r5, r5, r2
		user_op_ += users[count_user].count_user_op;
 100706a:	fb00 6602 	mla	r6, r0, r2, r6
		count_op -= users[count_user].count_user_op;
 100706e:	b2ed      	uxtb	r5, r5
	while (count_user--) {
 1007070:	d1f4      	bne.n	100705c <ticker_init+0x48>
	if (count_op) {
 1007072:	b99d      	cbnz	r5, 100709c <ticker_init+0x88>
	instance->ticker_id_slot_previous = TICKER_NULL;
 1007074:	f64f 73ff 	movw	r3, #65535	; 0xffff
	instance->caller_id_get_cb = caller_id_get_cb;
 1007078:	9a07      	ldr	r2, [sp, #28]
	return TICKER_STATUS_SUCCESS;
 100707a:	4628      	mov	r0, r5
	instance->caller_id_get_cb = caller_id_get_cb;
 100707c:	f8cc 2020 	str.w	r2, [ip, #32]
	instance->sched_cb = sched_cb;
 1007080:	9a08      	ldr	r2, [sp, #32]
	instance->ticks_slot_previous = 0U;
 1007082:	e9cc 5505 	strd	r5, r5, [ip, #20]
	instance->sched_cb = sched_cb;
 1007086:	f8cc 2024 	str.w	r2, [ip, #36]	; 0x24
	instance->trigger_set_cb = trigger_set_cb;
 100708a:	9a09      	ldr	r2, [sp, #36]	; 0x24
	instance->ticks_elapsed_first = 0U;
 100708c:	f8ac 500a 	strh.w	r5, [ip, #10]
	instance->trigger_set_cb = trigger_set_cb;
 1007090:	f8cc 2028 	str.w	r2, [ip, #40]	; 0x28
	instance->ticker_id_slot_previous = TICKER_NULL;
 1007094:	f8ac 301c 	strh.w	r3, [ip, #28]
}
 1007098:	bcf0      	pop	{r4, r5, r6, r7}
 100709a:	4770      	bx	lr
		return TICKER_STATUS_FAILURE;
 100709c:	2001      	movs	r0, #1
}
 100709e:	bcf0      	pop	{r4, r5, r6, r7}
 10070a0:	4770      	bx	lr
 10070a2:	bf00      	nop
 10070a4:	21000b44 	.word	0x21000b44

010070a8 <ticker_trigger>:
	if (instance->sched_cb) {
 10070a8:	222c      	movs	r2, #44	; 0x2c
 10070aa:	4b07      	ldr	r3, [pc, #28]	; (10070c8 <ticker_trigger+0x20>)
{
 10070ac:	b410      	push	{r4}
	if (instance->sched_cb) {
 10070ae:	fb02 3300 	mla	r3, r2, r0, r3
 10070b2:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 10070b4:	b12c      	cbz	r4, 10070c2 <ticker_trigger+0x1a>
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
 10070b6:	46a4      	mov	ip, r4
 10070b8:	2201      	movs	r2, #1
 10070ba:	2103      	movs	r1, #3
 10070bc:	2002      	movs	r0, #2
}
 10070be:	bc10      	pop	{r4}
		instance->sched_cb(TICKER_CALL_ID_TRIGGER,
 10070c0:	4760      	bx	ip
}
 10070c2:	bc10      	pop	{r4}
 10070c4:	4770      	bx	lr
 10070c6:	bf00      	nop
 10070c8:	21000b44 	.word	0x21000b44

010070cc <ticker_start_ext>:
{
 10070cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct ticker_instance *instance = &_instance[instance_index];
 10070d0:	262c      	movs	r6, #44	; 0x2c
{
 10070d2:	460c      	mov	r4, r1
	struct ticker_instance *instance = &_instance[instance_index];
 10070d4:	4923      	ldr	r1, [pc, #140]	; (1007164 <ticker_start_ext+0x98>)
 10070d6:	fb06 1600 	mla	r6, r6, r0, r1
	user = &instance->users[user_id];
 10070da:	6871      	ldr	r1, [r6, #4]
 10070dc:	eb01 07c4 	add.w	r7, r1, r4, lsl #3
	last = user->last + 1;
 10070e0:	78f8      	ldrb	r0, [r7, #3]
	if (last >= user->count_user_op) {
 10070e2:	f811 1034 	ldrb.w	r1, [r1, r4, lsl #3]
	last = user->last + 1;
 10070e6:	1c45      	adds	r5, r0, #1
 10070e8:	b2ed      	uxtb	r5, r5
		last = 0U;
 10070ea:	42a9      	cmp	r1, r5
 10070ec:	bf98      	it	ls
 10070ee:	2500      	movls	r5, #0
	if (last == user->first) {
 10070f0:	f897 c001 	ldrb.w	ip, [r7, #1]
{
 10070f4:	f8bd 102c 	ldrh.w	r1, [sp, #44]	; 0x2c
	if (last == user->first) {
 10070f8:	45ac      	cmp	ip, r5
 10070fa:	d030      	beq.n	100715e <ticker_start_ext+0x92>
	user_op = &user->user_op[user->last];
 10070fc:	f04f 0c34 	mov.w	ip, #52	; 0x34
	user_op->op = TICKER_USER_OP_TYPE_START;
 1007100:	f04f 0804 	mov.w	r8, #4
	user_op->status = TICKER_STATUS_BUSY;
 1007104:	f04f 0e02 	mov.w	lr, #2
	user_op = &user->user_op[user->last];
 1007108:	fb0c fc00 	mul.w	ip, ip, r0
 100710c:	f8d7 9004 	ldr.w	r9, [r7, #4]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
 1007110:	4620      	mov	r0, r4
	user_op = &user->user_op[user->last];
 1007112:	eb09 040c 	add.w	r4, r9, ip
	user_op->op = TICKER_USER_OP_TYPE_START;
 1007116:	f809 800c 	strb.w	r8, [r9, ip]
	user_op->params.start.ticks_at_start = ticks_anchor;
 100711a:	6063      	str	r3, [r4, #4]
	user_op->params.start.ticks_first = ticks_first;
 100711c:	9b08      	ldr	r3, [sp, #32]
	user_op->id = ticker_id;
 100711e:	7062      	strb	r2, [r4, #1]
	user_op->params.start.ticks_first = ticks_first;
 1007120:	60a3      	str	r3, [r4, #8]
	user_op->params.start.ticks_periodic = ticks_periodic;
 1007122:	9b09      	ldr	r3, [sp, #36]	; 0x24
	user_op->params.start.lazy = lazy;
 1007124:	82a1      	strh	r1, [r4, #20]
	user_op->params.start.ticks_periodic = ticks_periodic;
 1007126:	60e3      	str	r3, [r4, #12]
	user_op->params.start.remainder_periodic = remainder_periodic;
 1007128:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	user_op->status = TICKER_STATUS_BUSY;
 100712a:	f8c4 e028 	str.w	lr, [r4, #40]	; 0x28
	user_op->params.start.remainder_periodic = remainder_periodic;
 100712e:	6123      	str	r3, [r4, #16]
	user_op->params.start.ticks_slot = ticks_slot;
 1007130:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 1007132:	61a3      	str	r3, [r4, #24]
	user_op->params.start.ext_data = ext_data;
 1007134:	9b11      	ldr	r3, [sp, #68]	; 0x44
 1007136:	6263      	str	r3, [r4, #36]	; 0x24
	user_op->params.start.fp_timeout_func = fp_timeout_func;
 1007138:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 100713a:	61e3      	str	r3, [r4, #28]
	user_op->params.start.context = context;
 100713c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 100713e:	6223      	str	r3, [r4, #32]
	user_op->fp_op_func = fp_op_func;
 1007140:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 1007142:	62e3      	str	r3, [r4, #44]	; 0x2c
	user_op->op_context = op_context;
 1007144:	9b10      	ldr	r3, [sp, #64]	; 0x40
 1007146:	6323      	str	r3, [r4, #48]	; 0x30
	user->last = last;
 1007148:	70fd      	strb	r5, [r7, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
 100714a:	e9d6 3508 	ldrd	r3, r5, [r6, #32]
 100714e:	4798      	blx	r3
 1007150:	4633      	mov	r3, r6
 1007152:	4641      	mov	r1, r8
 1007154:	2200      	movs	r2, #0
 1007156:	47a8      	blx	r5
	return user_op->status;
 1007158:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
 100715a:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		return TICKER_STATUS_FAILURE;
 100715e:	2001      	movs	r0, #1
}
 1007160:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 1007164:	21000b44 	.word	0x21000b44

01007168 <ticker_start>:
{
 1007168:	b530      	push	{r4, r5, lr}
	return ticker_start_ext(instance_index, user_id, ticker_id,
 100716a:	2500      	movs	r5, #0
{
 100716c:	b08b      	sub	sp, #44	; 0x2c
 100716e:	9c0e      	ldr	r4, [sp, #56]	; 0x38
	return ticker_start_ext(instance_index, user_id, ticker_id,
 1007170:	9509      	str	r5, [sp, #36]	; 0x24
 1007172:	9400      	str	r4, [sp, #0]
{
 1007174:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
 1007176:	9c10      	ldr	r4, [sp, #64]	; 0x40
	return ticker_start_ext(instance_index, user_id, ticker_id,
 1007178:	9501      	str	r5, [sp, #4]
 100717a:	9402      	str	r4, [sp, #8]
{
 100717c:	f8bd 5044 	ldrh.w	r5, [sp, #68]	; 0x44
 1007180:	9c12      	ldr	r4, [sp, #72]	; 0x48
	return ticker_start_ext(instance_index, user_id, ticker_id,
 1007182:	9503      	str	r5, [sp, #12]
 1007184:	9404      	str	r4, [sp, #16]
{
 1007186:	9d13      	ldr	r5, [sp, #76]	; 0x4c
 1007188:	9c14      	ldr	r4, [sp, #80]	; 0x50
	return ticker_start_ext(instance_index, user_id, ticker_id,
 100718a:	9505      	str	r5, [sp, #20]
 100718c:	9406      	str	r4, [sp, #24]
{
 100718e:	9d15      	ldr	r5, [sp, #84]	; 0x54
 1007190:	9c16      	ldr	r4, [sp, #88]	; 0x58
	return ticker_start_ext(instance_index, user_id, ticker_id,
 1007192:	e9cd 5407 	strd	r5, r4, [sp, #28]
 1007196:	f7ff ff99 	bl	10070cc <ticker_start_ext>
}
 100719a:	b00b      	add	sp, #44	; 0x2c
 100719c:	bd30      	pop	{r4, r5, pc}
 100719e:	bf00      	nop

010071a0 <ticker_update>:
{
 10071a0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	struct ticker_instance *instance = &_instance[instance_index];
 10071a4:	262c      	movs	r6, #44	; 0x2c
 10071a6:	4c22      	ldr	r4, [pc, #136]	; (1007230 <ticker_update+0x90>)
{
 10071a8:	f8bd 802c 	ldrh.w	r8, [sp, #44]	; 0x2c
	struct ticker_instance *instance = &_instance[instance_index];
 10071ac:	fb06 4600 	mla	r6, r6, r0, r4
	user = &instance->users[user_id];
 10071b0:	6870      	ldr	r0, [r6, #4]
{
 10071b2:	f89d e030 	ldrb.w	lr, [sp, #48]	; 0x30
	user = &instance->users[user_id];
 10071b6:	eb00 07c1 	add.w	r7, r0, r1, lsl #3
	last = user->last + 1;
 10071ba:	f897 c003 	ldrb.w	ip, [r7, #3]
	if (last >= user->count_user_op) {
 10071be:	f810 0031 	ldrb.w	r0, [r0, r1, lsl #3]
	last = user->last + 1;
 10071c2:	f10c 0501 	add.w	r5, ip, #1
 10071c6:	b2ed      	uxtb	r5, r5
		last = 0U;
 10071c8:	42a8      	cmp	r0, r5
 10071ca:	bf98      	it	ls
 10071cc:	2500      	movls	r5, #0
	if (last == user->first) {
 10071ce:	7878      	ldrb	r0, [r7, #1]
 10071d0:	42a8      	cmp	r0, r5
 10071d2:	d029      	beq.n	1007228 <ticker_update+0x88>
	user_op = &user->user_op[user->last];
 10071d4:	2434      	movs	r4, #52	; 0x34
	user_op->op = TICKER_USER_OP_TYPE_UPDATE;
 10071d6:	f04f 0a05 	mov.w	sl, #5
	user_op->status = TICKER_STATUS_BUSY;
 10071da:	f04f 0902 	mov.w	r9, #2
	user_op = &user->user_op[user->last];
 10071de:	fb04 f40c 	mul.w	r4, r4, ip
 10071e2:	f8d7 c004 	ldr.w	ip, [r7, #4]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
 10071e6:	4608      	mov	r0, r1
	user_op->op = TICKER_USER_OP_TYPE_UPDATE;
 10071e8:	f80c a004 	strb.w	sl, [ip, r4]
	user_op = &user->user_op[user->last];
 10071ec:	4464      	add	r4, ip
	user_op->params.update.ticks_drift_plus = ticks_drift_plus;
 10071ee:	6063      	str	r3, [r4, #4]
	user_op->params.update.ticks_drift_minus = ticks_drift_minus;
 10071f0:	9b08      	ldr	r3, [sp, #32]
	user_op->id = ticker_id;
 10071f2:	7062      	strb	r2, [r4, #1]
	user_op->params.update.ticks_drift_minus = ticks_drift_minus;
 10071f4:	60a3      	str	r3, [r4, #8]
	user_op->params.update.ticks_slot_plus = ticks_slot_plus;
 10071f6:	9b09      	ldr	r3, [sp, #36]	; 0x24
	user_op->params.update.force = force;
 10071f8:	f884 e016 	strb.w	lr, [r4, #22]
	user_op->params.update.ticks_slot_plus = ticks_slot_plus;
 10071fc:	60e3      	str	r3, [r4, #12]
	user_op->params.update.ticks_slot_minus = ticks_slot_minus;
 10071fe:	9b0a      	ldr	r3, [sp, #40]	; 0x28
	user_op->params.update.lazy = lazy;
 1007200:	f8a4 8014 	strh.w	r8, [r4, #20]
	user_op->params.update.ticks_slot_minus = ticks_slot_minus;
 1007204:	6123      	str	r3, [r4, #16]
	user_op->fp_op_func = fp_op_func;
 1007206:	9b0d      	ldr	r3, [sp, #52]	; 0x34
	user_op->status = TICKER_STATUS_BUSY;
 1007208:	f8c4 9028 	str.w	r9, [r4, #40]	; 0x28
	user_op->fp_op_func = fp_op_func;
 100720c:	62e3      	str	r3, [r4, #44]	; 0x2c
	user_op->op_context = op_context;
 100720e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 1007210:	6323      	str	r3, [r4, #48]	; 0x30
	user->last = last;
 1007212:	70fd      	strb	r5, [r7, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
 1007214:	e9d6 3508 	ldrd	r3, r5, [r6, #32]
 1007218:	4798      	blx	r3
 100721a:	4633      	mov	r3, r6
 100721c:	2200      	movs	r2, #0
 100721e:	2104      	movs	r1, #4
 1007220:	47a8      	blx	r5
	return user_op->status;
 1007222:	6aa0      	ldr	r0, [r4, #40]	; 0x28
}
 1007224:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return TICKER_STATUS_FAILURE;
 1007228:	2001      	movs	r0, #1
}
 100722a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 100722e:	bf00      	nop
 1007230:	21000b44 	.word	0x21000b44

01007234 <ticker_stop>:
{
 1007234:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct ticker_instance *instance = &_instance[instance_index];
 1007238:	272c      	movs	r7, #44	; 0x2c
 100723a:	4c1a      	ldr	r4, [pc, #104]	; (10072a4 <ticker_stop+0x70>)
 100723c:	fb07 4700 	mla	r7, r7, r0, r4
	user = &instance->users[user_id];
 1007240:	687c      	ldr	r4, [r7, #4]
 1007242:	eb04 0cc1 	add.w	ip, r4, r1, lsl #3
	last = user->last + 1;
 1007246:	f89c 6003 	ldrb.w	r6, [ip, #3]
	if (last >= user->count_user_op) {
 100724a:	f814 0031 	ldrb.w	r0, [r4, r1, lsl #3]
	last = user->last + 1;
 100724e:	1c74      	adds	r4, r6, #1
 1007250:	b2e4      	uxtb	r4, r4
		last = 0U;
 1007252:	42a0      	cmp	r0, r4
 1007254:	bf98      	it	ls
 1007256:	2400      	movls	r4, #0
	if (last == user->first) {
 1007258:	f89c 0001 	ldrb.w	r0, [ip, #1]
 100725c:	42a0      	cmp	r0, r4
 100725e:	d01e      	beq.n	100729e <ticker_stop+0x6a>
	user_op = &user->user_op[user->last];
 1007260:	2534      	movs	r5, #52	; 0x34
	user_op->op = TICKER_USER_OP_TYPE_STOP;
 1007262:	f04f 0806 	mov.w	r8, #6
	user_op->status = TICKER_STATUS_BUSY;
 1007266:	f04f 0e02 	mov.w	lr, #2
	user_op = &user->user_op[user->last];
 100726a:	fb05 f506 	mul.w	r5, r5, r6
 100726e:	f8dc 6004 	ldr.w	r6, [ip, #4]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
 1007272:	4608      	mov	r0, r1
	user_op->op = TICKER_USER_OP_TYPE_STOP;
 1007274:	f806 8005 	strb.w	r8, [r6, r5]
	user_op = &user->user_op[user->last];
 1007278:	4435      	add	r5, r6
	user_op->fp_op_func = fp_op_func;
 100727a:	62eb      	str	r3, [r5, #44]	; 0x2c
	user_op->op_context = op_context;
 100727c:	9b06      	ldr	r3, [sp, #24]
	user_op->id = ticker_id;
 100727e:	706a      	strb	r2, [r5, #1]
	user_op->op_context = op_context;
 1007280:	632b      	str	r3, [r5, #48]	; 0x30
	user_op->status = TICKER_STATUS_BUSY;
 1007282:	f8c5 e028 	str.w	lr, [r5, #40]	; 0x28
	user->last = last;
 1007286:	f88c 4003 	strb.w	r4, [ip, #3]
	instance->sched_cb(instance->caller_id_get_cb(user_id),
 100728a:	e9d7 3408 	ldrd	r3, r4, [r7, #32]
 100728e:	4798      	blx	r3
 1007290:	463b      	mov	r3, r7
 1007292:	2200      	movs	r2, #0
 1007294:	2104      	movs	r1, #4
 1007296:	47a0      	blx	r4
	return user_op->status;
 1007298:	6aa8      	ldr	r0, [r5, #40]	; 0x28
}
 100729a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return TICKER_STATUS_FAILURE;
 100729e:	2001      	movs	r0, #1
}
 10072a0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 10072a4:	21000b44 	.word	0x21000b44

010072a8 <ticker_ticks_now_get>:
	return cntr_cnt_get();
 10072a8:	f00a bb52 	b.w	1011950 <cntr_cnt_get>

010072ac <ticker_ticks_diff_get>:
	return ((ticks_now - ticks_old) & HAL_TICKER_CNTR_MASK);
 10072ac:	1a40      	subs	r0, r0, r1
}
 10072ae:	f020 407f 	bic.w	r0, r0, #4278190080	; 0xff000000
 10072b2:	4770      	bx	lr

010072b4 <ll_addr_get>:
static u8_t pub_addr[BDADDR_SIZE];
static u8_t rnd_addr[BDADDR_SIZE];

u8_t *ll_addr_get(u8_t addr_type, u8_t *bdaddr)
{
	if (addr_type > 1) {
 10072b4:	2801      	cmp	r0, #1
 10072b6:	d813      	bhi.n	10072e0 <ll_addr_get+0x2c>
{
 10072b8:	b508      	push	{r3, lr}
		return NULL;
	}

	if (addr_type) {
 10072ba:	b948      	cbnz	r0, 10072d0 <ll_addr_get+0x1c>
		}

		return rnd_addr;
	}

	if (bdaddr) {
 10072bc:	b131      	cbz	r1, 10072cc <ll_addr_get+0x18>
		memcpy(bdaddr, pub_addr, BDADDR_SIZE);
 10072be:	4608      	mov	r0, r1
 10072c0:	2206      	movs	r2, #6
 10072c2:	4909      	ldr	r1, [pc, #36]	; (10072e8 <ll_addr_get+0x34>)
 10072c4:	f00f faf8 	bl	10168b8 <memcpy>
	}

	return pub_addr;
 10072c8:	4807      	ldr	r0, [pc, #28]	; (10072e8 <ll_addr_get+0x34>)
}
 10072ca:	bd08      	pop	{r3, pc}
	return pub_addr;
 10072cc:	4806      	ldr	r0, [pc, #24]	; (10072e8 <ll_addr_get+0x34>)
}
 10072ce:	bd08      	pop	{r3, pc}
		if (bdaddr) {
 10072d0:	b141      	cbz	r1, 10072e4 <ll_addr_get+0x30>
			memcpy(bdaddr, rnd_addr, BDADDR_SIZE);
 10072d2:	4608      	mov	r0, r1
 10072d4:	2206      	movs	r2, #6
 10072d6:	4905      	ldr	r1, [pc, #20]	; (10072ec <ll_addr_get+0x38>)
 10072d8:	f00f faee 	bl	10168b8 <memcpy>
		return rnd_addr;
 10072dc:	4803      	ldr	r0, [pc, #12]	; (10072ec <ll_addr_get+0x38>)
}
 10072de:	bd08      	pop	{r3, pc}
		return NULL;
 10072e0:	2000      	movs	r0, #0
}
 10072e2:	4770      	bx	lr
		return rnd_addr;
 10072e4:	4801      	ldr	r0, [pc, #4]	; (10072ec <ll_addr_get+0x38>)
}
 10072e6:	bd08      	pop	{r3, pc}
 10072e8:	21000b70 	.word	0x21000b70
 10072ec:	21000b78 	.word	0x21000b78

010072f0 <ll_addr_set>:

u32_t ll_addr_set(u8_t addr_type, u8_t const *const bdaddr)
{
 10072f0:	b570      	push	{r4, r5, r6, lr}
 10072f2:	4606      	mov	r6, r0
	if (IS_ENABLED(CONFIG_BT_BROADCASTER) &&
	    ull_adv_is_enabled(0)) {
 10072f4:	2000      	movs	r0, #0
{
 10072f6:	460d      	mov	r5, r1
	    ull_adv_is_enabled(0)) {
 10072f8:	f003 fc3e 	bl	100ab78 <ull_adv_is_enabled>
	if (IS_ENABLED(CONFIG_BT_BROADCASTER) &&
 10072fc:	b988      	cbnz	r0, 1007322 <ll_addr_set+0x32>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	if (IS_ENABLED(CONFIG_BT_OBSERVER) &&
	    (ull_scan_is_enabled(0) & (BIT(1) | BIT(2)))) {
 10072fe:	f003 fd89 	bl	100ae14 <ull_scan_is_enabled>
	if (IS_ENABLED(CONFIG_BT_OBSERVER) &&
 1007302:	f010 0406 	ands.w	r4, r0, #6
 1007306:	d10c      	bne.n	1007322 <ll_addr_set+0x32>
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

	if (addr_type) {
		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
 1007308:	4629      	mov	r1, r5
 100730a:	2206      	movs	r2, #6
	if (addr_type) {
 100730c:	b926      	cbnz	r6, 1007318 <ll_addr_set+0x28>
	} else {
		memcpy(pub_addr, bdaddr, BDADDR_SIZE);
 100730e:	4806      	ldr	r0, [pc, #24]	; (1007328 <ll_addr_set+0x38>)
 1007310:	f00f fad2 	bl	10168b8 <memcpy>
	}

	return 0;
}
 1007314:	4620      	mov	r0, r4
 1007316:	bd70      	pop	{r4, r5, r6, pc}
		memcpy(rnd_addr, bdaddr, BDADDR_SIZE);
 1007318:	4804      	ldr	r0, [pc, #16]	; (100732c <ll_addr_set+0x3c>)
 100731a:	f00f facd 	bl	10168b8 <memcpy>
}
 100731e:	4620      	mov	r0, r4
 1007320:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 1007322:	240c      	movs	r4, #12
}
 1007324:	4620      	mov	r0, r4
 1007326:	bd70      	pop	{r4, r5, r6, pc}
 1007328:	21000b70 	.word	0x21000b70
 100732c:	21000b78 	.word	0x21000b78

01007330 <ll_tx_pwr_lvl_get>:
#include "ull_conn_internal.h"

u8_t ll_tx_pwr_lvl_get(u8_t handle_type,
		       u16_t handle, u8_t type, s8_t *tx_pwr_lvl)
{
	switch (handle_type) {
 1007330:	2802      	cmp	r0, #2
 1007332:	d001      	beq.n	1007338 <ll_tx_pwr_lvl_get+0x8>
			}
			break;
		}
#endif /* CONFIG_BT_CONN */
		default: {
			return BT_HCI_ERR_UNKNOWN_CMD;
 1007334:	2001      	movs	r0, #1
		}
	}

	return BT_HCI_ERR_SUCCESS;
}
 1007336:	4770      	bx	lr
{
 1007338:	b538      	push	{r3, r4, r5, lr}
 100733a:	4604      	mov	r4, r0
			conn = ll_connected_get(handle);
 100733c:	4608      	mov	r0, r1
 100733e:	461d      	mov	r5, r3
 1007340:	f004 f90e 	bl	100b560 <ll_connected_get>
			if (!conn) {
 1007344:	b110      	cbz	r0, 100734c <ll_tx_pwr_lvl_get+0x1c>
				*tx_pwr_lvl = RADIO_TXP_DEFAULT;
 1007346:	2000      	movs	r0, #0
 1007348:	7028      	strb	r0, [r5, #0]
}
 100734a:	bd38      	pop	{r3, r4, r5, pc}
				return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100734c:	4620      	mov	r0, r4
}
 100734e:	bd38      	pop	{r3, r4, r5, pc}

01007350 <ll_tx_pwr_get>:
{
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	*min = lll_radio_tx_pwr_min_get();
	*max = lll_radio_tx_pwr_max_get();
#else
	*min = RADIO_TXP_DEFAULT;
 1007350:	2300      	movs	r3, #0
 1007352:	7003      	strb	r3, [r0, #0]
	*max = RADIO_TXP_DEFAULT;
 1007354:	700b      	strb	r3, [r1, #0]
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */
}
 1007356:	4770      	bx	lr

01007358 <hci_driver_init>:
	.open	= hci_driver_open,
	.send	= hci_driver_send,
};

static int hci_driver_init(struct device *unused)
{
 1007358:	b508      	push	{r3, lr}
	ARG_UNUSED(unused);

	bt_hci_driver_register(&drv);
 100735a:	4802      	ldr	r0, [pc, #8]	; (1007364 <hci_driver_init+0xc>)
 100735c:	f7fe fa0c 	bl	1005778 <bt_hci_driver_register>

	return 0;
}
 1007360:	2000      	movs	r0, #0
 1007362:	bd08      	pop	{r3, pc}
 1007364:	01018584 	.word	0x01018584

01007368 <prio_recv_thread>:
{
 1007368:	b570      	push	{r4, r5, r6, lr}
	return z_impl_k_sem_take(sem, timeout);
 100736a:	4e1a      	ldr	r6, [pc, #104]	; (10073d4 <prio_recv_thread+0x6c>)
				k_fifo_put(&recv_fifo, node_rx);
 100736c:	4d1a      	ldr	r5, [pc, #104]	; (10073d8 <prio_recv_thread+0x70>)
{
 100736e:	b082      	sub	sp, #8
 1007370:	e012      	b.n	1007398 <prio_recv_thread+0x30>
			buf = bt_buf_get_evt(BT_HCI_EVT_NUM_COMPLETED_PACKETS,
 1007372:	f04f 33ff 	mov.w	r3, #4294967295
 1007376:	f04f 32ff 	mov.w	r2, #4294967295
 100737a:	2100      	movs	r1, #0
 100737c:	2013      	movs	r0, #19
 100737e:	f00f fb33 	bl	10169e8 <bt_buf_get_evt>
			hci_num_cmplt_encode(buf, handle, num_cmplt);
 1007382:	4622      	mov	r2, r4
			buf = bt_buf_get_evt(BT_HCI_EVT_NUM_COMPLETED_PACKETS,
 1007384:	4604      	mov	r4, r0
			hci_num_cmplt_encode(buf, handle, num_cmplt);
 1007386:	f8bd 1002 	ldrh.w	r1, [sp, #2]
 100738a:	f001 fe91 	bl	10090b0 <hci_num_cmplt_encode>
			bt_recv_prio(buf);
 100738e:	4620      	mov	r0, r4
 1007390:	f00f fb2d 	bl	10169ee <bt_recv_prio>
	z_impl_k_yield();
 1007394:	f00d f8e4 	bl	1014560 <z_impl_k_yield>
		while ((num_cmplt = ll_rx_get((void *)&node_rx, &handle))) {
 1007398:	f10d 0102 	add.w	r1, sp, #2
 100739c:	a801      	add	r0, sp, #4
 100739e:	f002 fb93 	bl	1009ac8 <ll_rx_get>
 10073a2:	4604      	mov	r4, r0
 10073a4:	2800      	cmp	r0, #0
 10073a6:	d1e4      	bne.n	1007372 <prio_recv_thread+0xa>
		if (node_rx) {
 10073a8:	9b01      	ldr	r3, [sp, #4]
 10073aa:	b15b      	cbz	r3, 10073c4 <prio_recv_thread+0x5c>
			ll_rx_dequeue();
 10073ac:	f002 fc58 	bl	1009c60 <ll_rx_dequeue>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
 10073b0:	9c01      	ldr	r4, [sp, #4]
 10073b2:	4620      	mov	r0, r4
 10073b4:	f001 fe94 	bl	10090e0 <hci_get_class>
				k_fifo_put(&recv_fifo, node_rx);
 10073b8:	9901      	ldr	r1, [sp, #4]
			node_rx->hdr.user_meta = hci_get_class(node_rx);
 10073ba:	7160      	strb	r0, [r4, #5]
				k_fifo_put(&recv_fifo, node_rx);
 10073bc:	4628      	mov	r0, r5
 10073be:	f010 fa10 	bl	10177e2 <k_queue_append>
			continue;
 10073c2:	e7e9      	b.n	1007398 <prio_recv_thread+0x30>
	return z_impl_k_sem_take(sem, timeout);
 10073c4:	f04f 32ff 	mov.w	r2, #4294967295
 10073c8:	f04f 33ff 	mov.w	r3, #4294967295
 10073cc:	4630      	mov	r0, r6
 10073ce:	f00d f961 	bl	1014694 <z_impl_k_sem_take>
		while ((num_cmplt = ll_rx_get((void *)&node_rx, &handle))) {
 10073d2:	e7e1      	b.n	1007398 <prio_recv_thread+0x30>
 10073d4:	21000570 	.word	0x21000570
 10073d8:	210005cc 	.word	0x210005cc

010073dc <hci_driver_send>:
{
 10073dc:	b530      	push	{r4, r5, lr}
	if (!buf->len) {
 10073de:	8983      	ldrh	r3, [r0, #12]
{
 10073e0:	b083      	sub	sp, #12
	if (!buf->len) {
 10073e2:	2b00      	cmp	r3, #0
 10073e4:	d03a      	beq.n	100745c <hci_driver_send+0x80>
 10073e6:	7d03      	ldrb	r3, [r0, #20]
	switch (type) {
 10073e8:	4604      	mov	r4, r0
 10073ea:	b31b      	cbz	r3, 1007434 <hci_driver_send+0x58>
 10073ec:	2b02      	cmp	r3, #2
 10073ee:	d00f      	beq.n	1007410 <hci_driver_send+0x34>
 10073f0:	4821      	ldr	r0, [pc, #132]	; (1007478 <hci_driver_send+0x9c>)
 10073f2:	4a22      	ldr	r2, [pc, #136]	; (100747c <hci_driver_send+0xa0>)
		BT_ERR("Unknown HCI type %u", type);
 10073f4:	4619      	mov	r1, r3
 10073f6:	1a12      	subs	r2, r2, r0
 10073f8:	08d2      	lsrs	r2, r2, #3
 10073fa:	0192      	lsls	r2, r2, #6
 10073fc:	4820      	ldr	r0, [pc, #128]	; (1007480 <hci_driver_send+0xa4>)
 10073fe:	f042 0201 	orr.w	r2, r2, #1
 1007402:	f00d ffd1 	bl	10153a8 <log_1>
		return -EINVAL;
 1007406:	f06f 0515 	mvn.w	r5, #21
}
 100740a:	4628      	mov	r0, r5
 100740c:	b003      	add	sp, #12
 100740e:	bd30      	pop	{r4, r5, pc}
	err = hci_acl_handle(buf, &evt);
 1007410:	a901      	add	r1, sp, #4
 1007412:	f001 f8ff 	bl	1008614 <hci_acl_handle>
	if (evt) {
 1007416:	9b01      	ldr	r3, [sp, #4]
	err = hci_acl_handle(buf, &evt);
 1007418:	4605      	mov	r5, r0
	if (evt) {
 100741a:	b113      	cbz	r3, 1007422 <hci_driver_send+0x46>
		bt_recv_prio(evt);
 100741c:	4618      	mov	r0, r3
 100741e:	f00f fae6 	bl	10169ee <bt_recv_prio>
	if (!err) {
 1007422:	2d00      	cmp	r5, #0
 1007424:	d1f1      	bne.n	100740a <hci_driver_send+0x2e>
		net_buf_unref(buf);
 1007426:	2500      	movs	r5, #0
 1007428:	4620      	mov	r0, r4
 100742a:	f00b fa85 	bl	1012938 <net_buf_unref>
}
 100742e:	4628      	mov	r0, r5
 1007430:	b003      	add	sp, #12
 1007432:	bd30      	pop	{r4, r5, pc}
	evt = hci_cmd_handle(buf, (void **) &node_rx);
 1007434:	a901      	add	r1, sp, #4
	struct node_rx_pdu *node_rx = NULL;
 1007436:	9301      	str	r3, [sp, #4]
	evt = hci_cmd_handle(buf, (void **) &node_rx);
 1007438:	f000 fbde 	bl	1007bf8 <hci_cmd_handle>
	if (evt) {
 100743c:	2800      	cmp	r0, #0
 100743e:	d0f2      	beq.n	1007426 <hci_driver_send+0x4a>
		bt_recv_prio(evt);
 1007440:	f00f fad5 	bl	10169ee <bt_recv_prio>
		if (node_rx) {
 1007444:	9d01      	ldr	r5, [sp, #4]
 1007446:	2d00      	cmp	r5, #0
 1007448:	d0ed      	beq.n	1007426 <hci_driver_send+0x4a>
			node_rx->hdr.user_meta = hci_get_class(node_rx);
 100744a:	4628      	mov	r0, r5
 100744c:	f001 fe48 	bl	10090e0 <hci_get_class>
 1007450:	7168      	strb	r0, [r5, #5]
			k_fifo_put(&recv_fifo, node_rx);
 1007452:	9901      	ldr	r1, [sp, #4]
 1007454:	480b      	ldr	r0, [pc, #44]	; (1007484 <hci_driver_send+0xa8>)
 1007456:	f010 f9c4 	bl	10177e2 <k_queue_append>
	if (!err) {
 100745a:	e7e4      	b.n	1007426 <hci_driver_send+0x4a>
 100745c:	4b06      	ldr	r3, [pc, #24]	; (1007478 <hci_driver_send+0x9c>)
 100745e:	4907      	ldr	r1, [pc, #28]	; (100747c <hci_driver_send+0xa0>)
		BT_ERR("Empty HCI packet");
 1007460:	4809      	ldr	r0, [pc, #36]	; (1007488 <hci_driver_send+0xac>)
 1007462:	1ac9      	subs	r1, r1, r3
 1007464:	08c9      	lsrs	r1, r1, #3
 1007466:	0189      	lsls	r1, r1, #6
 1007468:	f041 0101 	orr.w	r1, r1, #1
 100746c:	f00d ff8f 	bl	101538e <log_0>
		return -EINVAL;
 1007470:	f06f 0515 	mvn.w	r5, #21
 1007474:	e7c9      	b.n	100740a <hci_driver_send+0x2e>
 1007476:	bf00      	nop
 1007478:	010180b8 	.word	0x010180b8
 100747c:	010180e8 	.word	0x010180e8
 1007480:	010184dc 	.word	0x010184dc
 1007484:	210005cc 	.word	0x210005cc
 1007488:	010184c8 	.word	0x010184c8

0100748c <hci_driver_open>:
{
 100748c:	b5d0      	push	{r4, r6, r7, lr}
	err = ll_init(&sem_prio_recv);
 100748e:	4822      	ldr	r0, [pc, #136]	; (1007518 <hci_driver_open+0x8c>)
{
 1007490:	b088      	sub	sp, #32
	err = ll_init(&sem_prio_recv);
 1007492:	f002 f871 	bl	1009578 <ll_init>
	if (err) {
 1007496:	4604      	mov	r4, r0
 1007498:	2800      	cmp	r0, #0
 100749a:	d12f      	bne.n	10074fc <hci_driver_open+0x70>
	hci_init(&hbuf_signal);
 100749c:	481f      	ldr	r0, [pc, #124]	; (100751c <hci_driver_open+0x90>)
 100749e:	f001 fe37 	bl	1009110 <hci_init>
	k_thread_create(&prio_recv_thread_data, prio_recv_thread_stack,
 10074a2:	2600      	movs	r6, #0
 10074a4:	2700      	movs	r7, #0
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 10074a6:	f06f 0309 	mvn.w	r3, #9
 10074aa:	f44f 72e0 	mov.w	r2, #448	; 0x1c0
 10074ae:	9303      	str	r3, [sp, #12]
 10074b0:	e9cd 6706 	strd	r6, r7, [sp, #24]
 10074b4:	e9cd 4401 	strd	r4, r4, [sp, #4]
 10074b8:	4b19      	ldr	r3, [pc, #100]	; (1007520 <hci_driver_open+0x94>)
 10074ba:	491a      	ldr	r1, [pc, #104]	; (1007524 <hci_driver_open+0x98>)
 10074bc:	9404      	str	r4, [sp, #16]
 10074be:	9400      	str	r4, [sp, #0]
 10074c0:	4819      	ldr	r0, [pc, #100]	; (1007528 <hci_driver_open+0x9c>)
 10074c2:	f00d f94f 	bl	1014764 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
 10074c6:	4919      	ldr	r1, [pc, #100]	; (100752c <hci_driver_open+0xa0>)
 10074c8:	4817      	ldr	r0, [pc, #92]	; (1007528 <hci_driver_open+0x9c>)
 10074ca:	f010 fb15 	bl	1017af8 <z_impl_k_thread_name_set>
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 10074ce:	f06f 0307 	mvn.w	r3, #7
 10074d2:	f44f 7200 	mov.w	r2, #512	; 0x200
 10074d6:	9303      	str	r3, [sp, #12]
 10074d8:	e9cd 6706 	strd	r6, r7, [sp, #24]
 10074dc:	e9cd 4401 	strd	r4, r4, [sp, #4]
 10074e0:	4b13      	ldr	r3, [pc, #76]	; (1007530 <hci_driver_open+0xa4>)
 10074e2:	4914      	ldr	r1, [pc, #80]	; (1007534 <hci_driver_open+0xa8>)
 10074e4:	9404      	str	r4, [sp, #16]
 10074e6:	9400      	str	r4, [sp, #0]
 10074e8:	4813      	ldr	r0, [pc, #76]	; (1007538 <hci_driver_open+0xac>)
 10074ea:	f00d f93b 	bl	1014764 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
 10074ee:	4913      	ldr	r1, [pc, #76]	; (100753c <hci_driver_open+0xb0>)
 10074f0:	4811      	ldr	r0, [pc, #68]	; (1007538 <hci_driver_open+0xac>)
 10074f2:	f010 fb01 	bl	1017af8 <z_impl_k_thread_name_set>
}
 10074f6:	4620      	mov	r0, r4
 10074f8:	b008      	add	sp, #32
 10074fa:	bdd0      	pop	{r4, r6, r7, pc}
 10074fc:	4b10      	ldr	r3, [pc, #64]	; (1007540 <hci_driver_open+0xb4>)
 10074fe:	4a11      	ldr	r2, [pc, #68]	; (1007544 <hci_driver_open+0xb8>)
		BT_ERR("LL initialization failed: %d", err);
 1007500:	4601      	mov	r1, r0
 1007502:	1ad2      	subs	r2, r2, r3
 1007504:	08d2      	lsrs	r2, r2, #3
 1007506:	0192      	lsls	r2, r2, #6
 1007508:	480f      	ldr	r0, [pc, #60]	; (1007548 <hci_driver_open+0xbc>)
 100750a:	f042 0201 	orr.w	r2, r2, #1
 100750e:	f00d ff4b 	bl	10153a8 <log_1>
}
 1007512:	4620      	mov	r0, r4
 1007514:	b008      	add	sp, #32
 1007516:	bdd0      	pop	{r4, r6, r7, pc}
 1007518:	21000570 	.word	0x21000570
 100751c:	210000a0 	.word	0x210000a0
 1007520:	01007369 	.word	0x01007369
 1007524:	21007250 	.word	0x21007250
 1007528:	21000b8c 	.word	0x21000b8c
 100752c:	01018510 	.word	0x01018510
 1007530:	0100754d 	.word	0x0100754d
 1007534:	21007410 	.word	0x21007410
 1007538:	21000c00 	.word	0x21000c00
 100753c:	0101851c 	.word	0x0101851c
 1007540:	010180b8 	.word	0x010180b8
 1007544:	010180e8 	.word	0x010180e8
 1007548:	010184f0 	.word	0x010184f0

0100754c <recv_thread>:
{
 100754c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1007550:	4cb0      	ldr	r4, [pc, #704]	; (1007814 <recv_thread+0x2c8>)
 1007552:	4fb1      	ldr	r7, [pc, #708]	; (1007818 <recv_thread+0x2cc>)
 1007554:	f8df 92d4 	ldr.w	r9, [pc, #724]	; 100782c <recv_thread+0x2e0>
 1007558:	f8df 82d4 	ldr.w	r8, [pc, #724]	; 1007830 <recv_thread+0x2e4>
		LL_ASSERT(err == 0);
 100755c:	f8df a2d4 	ldr.w	sl, [pc, #724]	; 1007834 <recv_thread+0x2e8>
{
 1007560:	b085      	sub	sp, #20
		parm0.val = timeout;
		return (int) arch_syscall_invoke4(*(uintptr_t *)&events, *(uintptr_t *)&num_events, parm0.split.lo, parm0.split.hi, K_SYSCALL_K_POLL);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll(events, num_events, timeout);
 1007562:	f04f 32ff 	mov.w	r2, #4294967295
 1007566:	f04f 33ff 	mov.w	r3, #4294967295
 100756a:	2102      	movs	r1, #2
 100756c:	48a9      	ldr	r0, [pc, #676]	; (1007814 <recv_thread+0x2c8>)
 100756e:	f00d fb83 	bl	1014c78 <z_impl_k_poll>
		LL_ASSERT(err == 0);
 1007572:	2800      	cmp	r0, #0
 1007574:	f040 809c 	bne.w	10076b0 <recv_thread+0x164>
		if (events[0].state == K_POLL_STATE_SIGNALED) {
 1007578:	68e3      	ldr	r3, [r4, #12]
 100757a:	f403 33f8 	and.w	r3, r3, #126976	; 0x1f000
 100757e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
 1007582:	f000 8090 	beq.w	10076a6 <recv_thread+0x15a>
		} else if (events[1].state ==
 1007586:	6a23      	ldr	r3, [r4, #32]
 1007588:	f403 33f8 	and.w	r3, r3, #126976	; 0x1f000
 100758c:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 1007590:	f000 80db 	beq.w	100774a <recv_thread+0x1fe>
		struct node_rx_pdu *node_rx = NULL;
 1007594:	2500      	movs	r5, #0
		events[0].state = K_POLL_STATE_NOT_READY;
 1007596:	68e2      	ldr	r2, [r4, #12]
		events[1].state = K_POLL_STATE_NOT_READY;
 1007598:	6a23      	ldr	r3, [r4, #32]
	s32_t hbuf_total = hci_hbuf_total;
 100759a:	49a0      	ldr	r1, [pc, #640]	; (100781c <recv_thread+0x2d0>)
		events[0].state = K_POLL_STATE_NOT_READY;
 100759c:	f36f 3210 	bfc	r2, #12, #5
	s32_t hbuf_total = hci_hbuf_total;
 10075a0:	f8d1 b000 	ldr.w	fp, [r1]
		events[1].state = K_POLL_STATE_NOT_READY;
 10075a4:	f36f 3310 	bfc	r3, #12, #5
		events[0].state = K_POLL_STATE_NOT_READY;
 10075a8:	60e2      	str	r2, [r4, #12]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 10075aa:	4a9d      	ldr	r2, [pc, #628]	; (1007820 <recv_thread+0x2d4>)
		events[1].state = K_POLL_STATE_NOT_READY;
 10075ac:	6223      	str	r3, [r4, #32]
 10075ae:	e8d2 3fef 	ldaex	r3, [r2]
 10075b2:	f023 0101 	bic.w	r1, r3, #1
 10075b6:	e8c2 1fe0 	stlex	r0, r1, [r2]
 10075ba:	2800      	cmp	r0, #0
 10075bc:	d1f7      	bne.n	10075ae <recv_thread+0x62>
	if (reset) {
 10075be:	07db      	lsls	r3, r3, #31
	list->head = NULL;
 10075c0:	bf44      	itt	mi
 10075c2:	2300      	movmi	r3, #0
	list->tail = NULL;
 10075c4:	e9c7 3300 	strdmi	r3, r3, [r7]
	if (hbuf_total <= 0) {
 10075c8:	f1bb 0f00 	cmp.w	fp, #0
 10075cc:	f340 80c4 	ble.w	1007758 <recv_thread+0x20c>
	hbuf_count = hbuf_total - (hci_hbuf_sent - hci_hbuf_acked);
 10075d0:	f8d9 3000 	ldr.w	r3, [r9]
 10075d4:	f8d8 2000 	ldr.w	r2, [r8]
 10075d8:	ebab 0303 	sub.w	r3, fp, r3
 10075dc:	4413      	add	r3, r2
	node_rx = (void *)sys_slist_peek_head(&hbuf_pend);
 10075de:	683e      	ldr	r6, [r7, #0]
	hbuf_count = hbuf_total - (hci_hbuf_sent - hci_hbuf_acked);
 10075e0:	4a90      	ldr	r2, [pc, #576]	; (1007824 <recv_thread+0x2d8>)
 10075e2:	6013      	str	r3, [r2, #0]
	if (!node_rx) {
 10075e4:	2e00      	cmp	r6, #0
 10075e6:	f000 80e1 	beq.w	10077ac <recv_thread+0x260>
	class = node_rx->hdr.user_meta;
 10075ea:	7972      	ldrb	r2, [r6, #5]
	if (n) {
 10075ec:	2d00      	cmp	r5, #0
 10075ee:	d168      	bne.n	10076c2 <recv_thread+0x176>
	switch (class) {
 10075f0:	2a04      	cmp	r2, #4
 10075f2:	d839      	bhi.n	1007668 <recv_thread+0x11c>
 10075f4:	2a02      	cmp	r2, #2
 10075f6:	f200 8090 	bhi.w	100771a <recv_thread+0x1ce>
		LL_ASSERT(0);
 10075fa:	f44f 7191 	mov.w	r1, #290	; 0x122
 10075fe:	4650      	mov	r0, sl
 1007600:	9201      	str	r2, [sp, #4]
 1007602:	f7fb ffc1 	bl	1003588 <bt_ctlr_assert_handle>
	switch (class) {
 1007606:	9a01      	ldr	r2, [sp, #4]
 1007608:	9603      	str	r6, [sp, #12]
 100760a:	2a00      	cmp	r2, #0
 100760c:	f040 808b 	bne.w	1007726 <recv_thread+0x1da>
		LL_ASSERT(0);
 1007610:	21b4      	movs	r1, #180	; 0xb4
 1007612:	4650      	mov	r0, sl
 1007614:	f7fb ffb8 	bl	1003588 <bt_ctlr_assert_handle>
	node_rx->hdr.next = NULL;
 1007618:	2200      	movs	r2, #0
 100761a:	9b03      	ldr	r3, [sp, #12]
	ll_rx_mem_release((void **)&node_rx);
 100761c:	a803      	add	r0, sp, #12
	node_rx->hdr.next = NULL;
 100761e:	601a      	str	r2, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
 1007620:	f002 fbb2 	bl	1009d88 <ll_rx_mem_release>
		hbuf_count = hbuf_total - (hci_hbuf_sent - hci_hbuf_acked);
 1007624:	f8d9 3000 	ldr.w	r3, [r9]
 1007628:	f8d8 1000 	ldr.w	r1, [r8]
 100762c:	ebab 0303 	sub.w	r3, fp, r3
 1007630:	440b      	add	r3, r1
		node_rx = (void *)sys_slist_peek_head(&hbuf_pend);
 1007632:	683a      	ldr	r2, [r7, #0]
		hbuf_count = hbuf_total - (hci_hbuf_sent - hci_hbuf_acked);
 1007634:	497b      	ldr	r1, [pc, #492]	; (1007824 <recv_thread+0x2d8>)
 1007636:	600b      	str	r3, [r1, #0]
		if (node_rx) {
 1007638:	b12a      	cbz	r2, 1007646 <recv_thread+0xfa>
			class = node_rx->hdr.user_meta;
 100763a:	7952      	ldrb	r2, [r2, #5]
			if (class == HCI_CLASS_EVT_CONNECTION ||
 100763c:	1ed1      	subs	r1, r2, #3
 100763e:	2901      	cmp	r1, #1
 1007640:	d90d      	bls.n	100765e <recv_thread+0x112>
			    class == HCI_CLASS_EVT_LLCP ||
 1007642:	2a05      	cmp	r2, #5
 1007644:	d009      	beq.n	100765a <recv_thread+0x10e>
		if (buf) {
 1007646:	b12d      	cbz	r5, 1007654 <recv_thread+0x108>
			if (buf->len) {
 1007648:	89ab      	ldrh	r3, [r5, #12]
				bt_recv(buf);
 100764a:	4628      	mov	r0, r5
			if (buf->len) {
 100764c:	2b00      	cmp	r3, #0
 100764e:	d035      	beq.n	10076bc <recv_thread+0x170>
				bt_recv(buf);
 1007650:	f7fe f908 	bl	1005864 <bt_recv>
	z_impl_k_yield();
 1007654:	f00c ff84 	bl	1014560 <z_impl_k_yield>
	while (1) {
 1007658:	e783      	b.n	1007562 <recv_thread+0x16>
			    (class == HCI_CLASS_ACL_DATA && hbuf_count)) {
 100765a:	2b00      	cmp	r3, #0
 100765c:	d0f3      	beq.n	1007646 <recv_thread+0xfa>
	if (z_syscall_trap()) {
		return (int) arch_syscall_invoke2(*(uintptr_t *)&signal, *(uintptr_t *)&result, K_SYSCALL_K_POLL_SIGNAL_RAISE);
	}
#endif
	compiler_barrier();
	return z_impl_k_poll_signal_raise(signal, result);
 100765e:	2100      	movs	r1, #0
 1007660:	4871      	ldr	r0, [pc, #452]	; (1007828 <recv_thread+0x2dc>)
 1007662:	f00d fb69 	bl	1014d38 <z_impl_k_poll_signal_raise>
 1007666:	e7ee      	b.n	1007646 <recv_thread+0xfa>
	switch (class) {
 1007668:	2a05      	cmp	r2, #5
 100766a:	d115      	bne.n	1007698 <recv_thread+0x14c>
		if (hbuf_count) {
 100766c:	2b00      	cmp	r3, #0
 100766e:	d0f1      	beq.n	1007654 <recv_thread+0x108>
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 1007670:	687a      	ldr	r2, [r7, #4]
 1007672:	6833      	ldr	r3, [r6, #0]
 1007674:	4296      	cmp	r6, r2
	list->head = node;
 1007676:	603b      	str	r3, [r7, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 1007678:	f000 80b6 	beq.w	10077e8 <recv_thread+0x29c>
		buf = bt_buf_get_rx(BT_BUF_ACL_IN, K_FOREVER);
 100767c:	f04f 32ff 	mov.w	r2, #4294967295
 1007680:	f04f 33ff 	mov.w	r3, #4294967295
 1007684:	2003      	movs	r0, #3
 1007686:	9603      	str	r6, [sp, #12]
 1007688:	f7fe f888 	bl	100579c <bt_buf_get_rx>
 100768c:	4605      	mov	r5, r0
		hci_acl_encode(node_rx, buf);
 100768e:	9803      	ldr	r0, [sp, #12]
 1007690:	4629      	mov	r1, r5
 1007692:	f001 f857 	bl	1008744 <hci_acl_encode>
		break;
 1007696:	e7bf      	b.n	1007618 <recv_thread+0xcc>
		LL_ASSERT(0);
 1007698:	f44f 7191 	mov.w	r1, #290	; 0x122
 100769c:	4650      	mov	r0, sl
 100769e:	f7fb ff73 	bl	1003588 <bt_ctlr_assert_handle>
		buf = encode_node(node_rx, class);
 10076a2:	9603      	str	r6, [sp, #12]
	switch (class) {
 10076a4:	e7b4      	b.n	1007610 <recv_thread+0xc4>
			events[0].signal->signaled = 0U;
 10076a6:	2300      	movs	r3, #0
 10076a8:	6922      	ldr	r2, [r4, #16]
		struct node_rx_pdu *node_rx = NULL;
 10076aa:	461d      	mov	r5, r3
			events[0].signal->signaled = 0U;
 10076ac:	6093      	str	r3, [r2, #8]
 10076ae:	e772      	b.n	1007596 <recv_thread+0x4a>
		LL_ASSERT(err == 0);
 10076b0:	f44f 71ad 	mov.w	r1, #346	; 0x15a
 10076b4:	4650      	mov	r0, sl
 10076b6:	f7fb ff67 	bl	1003588 <bt_ctlr_assert_handle>
 10076ba:	e75d      	b.n	1007578 <recv_thread+0x2c>
				net_buf_unref(buf);
 10076bc:	f00b f93c 	bl	1012938 <net_buf_unref>
 10076c0:	e7c8      	b.n	1007654 <recv_thread+0x108>
		if (class == HCI_CLASS_EVT_CONNECTION ||
 10076c2:	1ed1      	subs	r1, r2, #3
 10076c4:	2901      	cmp	r1, #1
 10076c6:	d961      	bls.n	100778c <recv_thread+0x240>
		    class == HCI_CLASS_EVT_LLCP ||
 10076c8:	2a05      	cmp	r2, #5
 10076ca:	d072      	beq.n	10077b2 <recv_thread+0x266>
	if (hbuf_count != -1) {
 10076cc:	3301      	adds	r3, #1
	u8_t class = node_rx->hdr.user_meta;
 10076ce:	796a      	ldrb	r2, [r5, #5]
	if (hbuf_count != -1) {
 10076d0:	d04a      	beq.n	1007768 <recv_thread+0x21c>
 10076d2:	683e      	ldr	r6, [r7, #0]
		switch (class) {
 10076d4:	2a04      	cmp	r2, #4
 10076d6:	d860      	bhi.n	100779a <recv_thread+0x24e>
 10076d8:	2a02      	cmp	r2, #2
 10076da:	f200 808d 	bhi.w	10077f8 <recv_thread+0x2ac>
 10076de:	1e53      	subs	r3, r2, #1
 10076e0:	2b01      	cmp	r3, #1
 10076e2:	f200 8083 	bhi.w	10077ec <recv_thread+0x2a0>
	buf = encode_node(node_rx, class);
 10076e6:	9503      	str	r5, [sp, #12]
		if (class == HCI_CLASS_EVT_DISCARDABLE) {
 10076e8:	2a02      	cmp	r2, #2
 10076ea:	f000 80ab 	beq.w	1007844 <recv_thread+0x2f8>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 10076ee:	f04f 32ff 	mov.w	r2, #4294967295
 10076f2:	f04f 33ff 	mov.w	r3, #4294967295
 10076f6:	2001      	movs	r0, #1
 10076f8:	f7fe f850 	bl	100579c <bt_buf_get_rx>
 10076fc:	4605      	mov	r5, r0
		if (buf) {
 10076fe:	2d00      	cmp	r5, #0
 1007700:	f000 809a 	beq.w	1007838 <recv_thread+0x2ec>
			hci_evt_encode(node_rx, buf);
 1007704:	4629      	mov	r1, r5
 1007706:	9803      	ldr	r0, [sp, #12]
 1007708:	f001 f876 	bl	10087f8 <hci_evt_encode>
	node_rx->hdr.next = NULL;
 100770c:	2200      	movs	r2, #0
 100770e:	9b03      	ldr	r3, [sp, #12]
	ll_rx_mem_release((void **)&node_rx);
 1007710:	a803      	add	r0, sp, #12
	node_rx->hdr.next = NULL;
 1007712:	601a      	str	r2, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
 1007714:	f002 fb38 	bl	1009d88 <ll_rx_mem_release>
	return buf;
 1007718:	e795      	b.n	1007646 <recv_thread+0xfa>
 100771a:	6879      	ldr	r1, [r7, #4]
 100771c:	6833      	ldr	r3, [r6, #0]
 100771e:	428e      	cmp	r6, r1
	list->head = node;
 1007720:	603b      	str	r3, [r7, #0]
Z_GENLIST_GET_NOT_EMPTY(slist, snode)
 1007722:	d052      	beq.n	10077ca <recv_thread+0x27e>
		buf = encode_node(node_rx, class);
 1007724:	9603      	str	r6, [sp, #12]
		if (class == HCI_CLASS_EVT_DISCARDABLE) {
 1007726:	2a02      	cmp	r2, #2
 1007728:	d047      	beq.n	10077ba <recv_thread+0x26e>
			buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 100772a:	f04f 32ff 	mov.w	r2, #4294967295
 100772e:	f04f 33ff 	mov.w	r3, #4294967295
 1007732:	2001      	movs	r0, #1
 1007734:	f7fe f832 	bl	100579c <bt_buf_get_rx>
 1007738:	4605      	mov	r5, r0
		if (buf) {
 100773a:	2d00      	cmp	r5, #0
 100773c:	f43f af6c 	beq.w	1007618 <recv_thread+0xcc>
			hci_evt_encode(node_rx, buf);
 1007740:	4629      	mov	r1, r5
 1007742:	9803      	ldr	r0, [sp, #12]
 1007744:	f001 f858 	bl	10087f8 <hci_evt_encode>
 1007748:	e766      	b.n	1007618 <recv_thread+0xcc>
			node_rx = k_fifo_get(events[1].fifo, K_NO_WAIT);
 100774a:	6a60      	ldr	r0, [r4, #36]	; 0x24
	return z_impl_k_queue_get(queue, timeout);
 100774c:	2200      	movs	r2, #0
 100774e:	2300      	movs	r3, #0
 1007750:	f00c fc3a 	bl	1013fc8 <z_impl_k_queue_get>
 1007754:	4605      	mov	r5, r0
 1007756:	e71e      	b.n	1007596 <recv_thread+0x4a>
		hbuf_count = -1;
 1007758:	f04f 33ff 	mov.w	r3, #4294967295
 100775c:	4a31      	ldr	r2, [pc, #196]	; (1007824 <recv_thread+0x2d8>)
 100775e:	6013      	str	r3, [r2, #0]
		if (node_rx && !buf) {
 1007760:	2d00      	cmp	r5, #0
 1007762:	f43f af77 	beq.w	1007654 <recv_thread+0x108>
	u8_t class = node_rx->hdr.user_meta;
 1007766:	796a      	ldrb	r2, [r5, #5]
	switch (class) {
 1007768:	2a04      	cmp	r2, #4
 100776a:	9503      	str	r5, [sp, #12]
 100776c:	d92f      	bls.n	10077ce <recv_thread+0x282>
 100776e:	2a05      	cmp	r2, #5
 1007770:	d12f      	bne.n	10077d2 <recv_thread+0x286>
		buf = bt_buf_get_rx(BT_BUF_ACL_IN, K_FOREVER);
 1007772:	f04f 32ff 	mov.w	r2, #4294967295
 1007776:	f04f 33ff 	mov.w	r3, #4294967295
 100777a:	2003      	movs	r0, #3
 100777c:	f7fe f80e 	bl	100579c <bt_buf_get_rx>
 1007780:	4605      	mov	r5, r0
		hci_acl_encode(node_rx, buf);
 1007782:	9803      	ldr	r0, [sp, #12]
 1007784:	4629      	mov	r1, r5
 1007786:	f000 ffdd 	bl	1008744 <hci_acl_encode>
		break;
 100778a:	e7bf      	b.n	100770c <recv_thread+0x1c0>
	return z_impl_k_poll_signal_raise(signal, result);
 100778c:	2100      	movs	r1, #0
 100778e:	4826      	ldr	r0, [pc, #152]	; (1007828 <recv_thread+0x2dc>)
 1007790:	f00d fad2 	bl	1014d38 <z_impl_k_poll_signal_raise>
		if (node_rx && !buf) {
 1007794:	4b23      	ldr	r3, [pc, #140]	; (1007824 <recv_thread+0x2d8>)
 1007796:	681b      	ldr	r3, [r3, #0]
 1007798:	e798      	b.n	10076cc <recv_thread+0x180>
		switch (class) {
 100779a:	2a05      	cmp	r2, #5
 100779c:	d126      	bne.n	10077ec <recv_thread+0x2a0>
			if (pend || !hbuf_count) {
 100779e:	2e00      	cmp	r6, #0
 10077a0:	d130      	bne.n	1007804 <recv_thread+0x2b8>
 10077a2:	4b20      	ldr	r3, [pc, #128]	; (1007824 <recv_thread+0x2d8>)
 10077a4:	681b      	ldr	r3, [r3, #0]
 10077a6:	b36b      	cbz	r3, 1007804 <recv_thread+0x2b8>
	buf = encode_node(node_rx, class);
 10077a8:	9503      	str	r5, [sp, #12]
	switch (class) {
 10077aa:	e7e2      	b.n	1007772 <recv_thread+0x226>
		if (node_rx && !buf) {
 10077ac:	2d00      	cmp	r5, #0
 10077ae:	d18d      	bne.n	10076cc <recv_thread+0x180>
 10077b0:	e750      	b.n	1007654 <recv_thread+0x108>
		    (class == HCI_CLASS_ACL_DATA && hbuf_count)) {
 10077b2:	2b00      	cmp	r3, #0
 10077b4:	d1ea      	bne.n	100778c <recv_thread+0x240>
	u8_t class = node_rx->hdr.user_meta;
 10077b6:	796a      	ldrb	r2, [r5, #5]
	if (hbuf_count != -1) {
 10077b8:	e78c      	b.n	10076d4 <recv_thread+0x188>
			buf = bt_buf_get_evt(BT_HCI_EVT_UNKNOWN, true,
 10077ba:	2200      	movs	r2, #0
 10077bc:	2300      	movs	r3, #0
 10077be:	2101      	movs	r1, #1
 10077c0:	2000      	movs	r0, #0
 10077c2:	f00f f911 	bl	10169e8 <bt_buf_get_evt>
 10077c6:	4605      	mov	r5, r0
 10077c8:	e7b7      	b.n	100773a <recv_thread+0x1ee>
	list->tail = node;
 10077ca:	607b      	str	r3, [r7, #4]
}
 10077cc:	e7aa      	b.n	1007724 <recv_thread+0x1d8>
	switch (class) {
 10077ce:	2a00      	cmp	r2, #0
 10077d0:	d18a      	bne.n	10076e8 <recv_thread+0x19c>
		LL_ASSERT(0);
 10077d2:	4650      	mov	r0, sl
 10077d4:	21b4      	movs	r1, #180	; 0xb4
 10077d6:	f7fb fed7 	bl	1003588 <bt_ctlr_assert_handle>
	node_rx->hdr.next = NULL;
 10077da:	2200      	movs	r2, #0
 10077dc:	9b03      	ldr	r3, [sp, #12]
	ll_rx_mem_release((void **)&node_rx);
 10077de:	a803      	add	r0, sp, #12
	node_rx->hdr.next = NULL;
 10077e0:	601a      	str	r2, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
 10077e2:	f002 fad1 	bl	1009d88 <ll_rx_mem_release>
		if (buf) {
 10077e6:	e735      	b.n	1007654 <recv_thread+0x108>
	list->tail = node;
 10077e8:	607b      	str	r3, [r7, #4]
}
 10077ea:	e747      	b.n	100767c <recv_thread+0x130>
			LL_ASSERT(0);
 10077ec:	21d9      	movs	r1, #217	; 0xd9
 10077ee:	4650      	mov	r0, sl
 10077f0:	f7fb feca 	bl	1003588 <bt_ctlr_assert_handle>
	buf = encode_node(node_rx, class);
 10077f4:	9503      	str	r5, [sp, #12]
	switch (class) {
 10077f6:	e7ec      	b.n	10077d2 <recv_thread+0x286>
			hbuf_count = 1;
 10077f8:	2301      	movs	r3, #1
 10077fa:	4a0a      	ldr	r2, [pc, #40]	; (1007824 <recv_thread+0x2d8>)
 10077fc:	6013      	str	r3, [r2, #0]
			if (pend || !hbuf_count) {
 10077fe:	b90e      	cbnz	r6, 1007804 <recv_thread+0x2b8>
	buf = encode_node(node_rx, class);
 1007800:	9503      	str	r5, [sp, #12]
		if (class == HCI_CLASS_EVT_DISCARDABLE) {
 1007802:	e774      	b.n	10076ee <recv_thread+0x1a2>
	parent->next = child;
 1007804:	2200      	movs	r2, #0
Z_GENLIST_APPEND(slist, snode)
 1007806:	687b      	ldr	r3, [r7, #4]
	parent->next = child;
 1007808:	602a      	str	r2, [r5, #0]
Z_GENLIST_APPEND(slist, snode)
 100780a:	b31b      	cbz	r3, 1007854 <recv_thread+0x308>
	parent->next = child;
 100780c:	601d      	str	r5, [r3, #0]
	list->tail = node;
 100780e:	607d      	str	r5, [r7, #4]
		if (buf) {
 1007810:	e720      	b.n	1007654 <recv_thread+0x108>
 1007812:	bf00      	nop
 1007814:	21000078 	.word	0x21000078
 1007818:	21000b84 	.word	0x21000b84
 100781c:	21000d2c 	.word	0x21000d2c
 1007820:	21000d30 	.word	0x21000d30
 1007824:	21000b80 	.word	0x21000b80
 1007828:	210000a0 	.word	0x210000a0
 100782c:	21000d28 	.word	0x21000d28
 1007830:	21000d04 	.word	0x21000d04
 1007834:	01018524 	.word	0x01018524
	node_rx->hdr.next = NULL;
 1007838:	9b03      	ldr	r3, [sp, #12]
	ll_rx_mem_release((void **)&node_rx);
 100783a:	a803      	add	r0, sp, #12
	node_rx->hdr.next = NULL;
 100783c:	601d      	str	r5, [r3, #0]
	ll_rx_mem_release((void **)&node_rx);
 100783e:	f002 faa3 	bl	1009d88 <ll_rx_mem_release>
		if (buf) {
 1007842:	e707      	b.n	1007654 <recv_thread+0x108>
			buf = bt_buf_get_evt(BT_HCI_EVT_UNKNOWN, true,
 1007844:	2200      	movs	r2, #0
 1007846:	2300      	movs	r3, #0
 1007848:	2101      	movs	r1, #1
 100784a:	2000      	movs	r0, #0
 100784c:	f00f f8cc 	bl	10169e8 <bt_buf_get_evt>
 1007850:	4605      	mov	r5, r0
 1007852:	e754      	b.n	10076fe <recv_thread+0x1b2>
	list->head = node;
 1007854:	e9c7 5500 	strd	r5, r5, [r7]
		if (buf) {
 1007858:	e6fc      	b.n	1007654 <recv_thread+0x108>
 100785a:	bf00      	nop

0100785c <meta_evt>:
{
	return bt_hci_cmd_status_create(_opcode, status);
}

static void *meta_evt(struct net_buf *buf, u8_t subevt, u8_t melen)
{
 100785c:	b570      	push	{r4, r5, r6, lr}
	hdr = net_buf_add(buf, sizeof(*hdr));
 100785e:	f100 0408 	add.w	r4, r0, #8
{
 1007862:	4615      	mov	r5, r2
 1007864:	460e      	mov	r6, r1
	hdr = net_buf_add(buf, sizeof(*hdr));
 1007866:	4620      	mov	r0, r4
 1007868:	2102      	movs	r1, #2
 100786a:	f00f f92a 	bl	1016ac2 <net_buf_simple_add>
	hdr->evt = evt;
 100786e:	223e      	movs	r2, #62	; 0x3e
	struct bt_hci_evt_le_meta_event *me;

	hci_evt_create(buf, BT_HCI_EVT_LE_META_EVENT, sizeof(*me) + melen);
 1007870:	1c6b      	adds	r3, r5, #1
	me = net_buf_add(buf, sizeof(*me));
 1007872:	2101      	movs	r1, #1
	hdr->evt = evt;
 1007874:	7002      	strb	r2, [r0, #0]
	hdr->len = len;
 1007876:	7043      	strb	r3, [r0, #1]
	me = net_buf_add(buf, sizeof(*me));
 1007878:	4620      	mov	r0, r4
 100787a:	f00f f922 	bl	1016ac2 <net_buf_simple_add>
	me->subevent = subevt;
 100787e:	7006      	strb	r6, [r0, #0]

	return net_buf_add(buf, melen);
 1007880:	4629      	mov	r1, r5
 1007882:	4620      	mov	r0, r4
}
 1007884:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return net_buf_add(buf, melen);
 1007888:	f00f b91b 	b.w	1016ac2 <net_buf_simple_add>

0100788c <le_remote_feat_complete>:
}
#endif /* CONFIG_BT_CTLR_LE_ENC */

static void le_remote_feat_complete(u8_t status, struct pdu_data *pdu_data,
				    u16_t handle, struct net_buf *buf)
{
 100788c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	struct bt_hci_evt_le_remote_feat_complete *sep;

	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1007890:	f04f 0900 	mov.w	r9, #0
 1007894:	464c      	mov	r4, r9
 1007896:	4f16      	ldr	r7, [pc, #88]	; (10078f0 <le_remote_feat_complete+0x64>)
{
 1007898:	4606      	mov	r6, r0
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 100789a:	6878      	ldr	r0, [r7, #4]
{
 100789c:	4617      	mov	r7, r2
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 100789e:	f000 5500 	and.w	r5, r0, #536870912	; 0x20000000
 10078a2:	ea54 0205 	orrs.w	r2, r4, r5
 10078a6:	d008      	beq.n	10078ba <le_remote_feat_complete+0x2e>
 10078a8:	4688      	mov	r8, r1
	    !(le_event_mask & BT_EVT_MASK_LE_REMOTE_FEAT_COMPLETE)) {
 10078aa:	4649      	mov	r1, r9
 10078ac:	4a11      	ldr	r2, [pc, #68]	; (10078f4 <le_remote_feat_complete+0x68>)
 10078ae:	6812      	ldr	r2, [r2, #0]
 10078b0:	f002 0008 	and.w	r0, r2, #8
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 10078b4:	ea50 0201 	orrs.w	r2, r0, r1
 10078b8:	d101      	bne.n	10078be <le_remote_feat_complete+0x32>
		       &pdu_data->llctrl.feature_rsp.features[0],
		       sizeof(sep->features));
	} else {
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
	}
}
 10078ba:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	sep = meta_evt(buf, BT_HCI_EV_LE_REMOTE_FEAT_COMPLETE, sizeof(*sep));
 10078be:	4618      	mov	r0, r3
 10078c0:	220b      	movs	r2, #11
 10078c2:	2104      	movs	r1, #4
 10078c4:	f7ff ffca 	bl	100785c <meta_evt>
	sep->status = status;
 10078c8:	7006      	strb	r6, [r0, #0]
	sep->handle = sys_cpu_to_le16(handle);
 10078ca:	f8a0 7001 	strh.w	r7, [r0, #1]
	if (!status) {
 10078ce:	b93e      	cbnz	r6, 10078e0 <le_remote_feat_complete+0x54>
		memcpy(&sep->features[0],
 10078d0:	f108 0104 	add.w	r1, r8, #4
 10078d4:	2208      	movs	r2, #8
}
 10078d6:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		memcpy(&sep->features[0],
 10078da:	3003      	adds	r0, #3
 10078dc:	f00e bfec 	b.w	10168b8 <memcpy>
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
 10078e0:	4649      	mov	r1, r9
}
 10078e2:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		(void)memset(&sep->features[0], 0x00, sizeof(sep->features));
 10078e6:	2208      	movs	r2, #8
 10078e8:	3003      	adds	r0, #3
 10078ea:	f00f b810 	b.w	101690e <memset>
 10078ee:	bf00      	nop
 10078f0:	21000000 	.word	0x21000000
 10078f4:	21000008 	.word	0x21000008

010078f8 <encrypt_change.part.0>:
static void encrypt_change(u8_t err, u16_t handle,
 10078f8:	b570      	push	{r4, r5, r6, lr}
	hdr = net_buf_add(buf, sizeof(*hdr));
 10078fa:	f102 0508 	add.w	r5, r2, #8
static void encrypt_change(u8_t err, u16_t handle,
 10078fe:	4604      	mov	r4, r0
 1007900:	460e      	mov	r6, r1
	hdr = net_buf_add(buf, sizeof(*hdr));
 1007902:	4628      	mov	r0, r5
 1007904:	2102      	movs	r1, #2
 1007906:	f00f f8dc 	bl	1016ac2 <net_buf_simple_add>
	hdr->evt = evt;
 100790a:	2208      	movs	r2, #8
	hdr = net_buf_add(buf, sizeof(*hdr));
 100790c:	4603      	mov	r3, r0
	hdr->len = len;
 100790e:	2104      	movs	r1, #4
	hdr->evt = evt;
 1007910:	701a      	strb	r2, [r3, #0]
	hdr->len = len;
 1007912:	7059      	strb	r1, [r3, #1]
	ep = net_buf_add(buf, sizeof(*ep));
 1007914:	4628      	mov	r0, r5
 1007916:	f00f f8d4 	bl	1016ac2 <net_buf_simple_add>
	ep->encrypt = !err ? 1 : 0;
 100791a:	fab4 f384 	clz	r3, r4
 100791e:	095b      	lsrs	r3, r3, #5
	ep->status = err;
 1007920:	7004      	strb	r4, [r0, #0]
	ep->encrypt = !err ? 1 : 0;
 1007922:	70c3      	strb	r3, [r0, #3]
	ep->handle = sys_cpu_to_le16(handle);
 1007924:	f8a0 6001 	strh.w	r6, [r0, #1]
}
 1007928:	bd70      	pop	{r4, r5, r6, pc}
 100792a:	bf00      	nop

0100792c <hci_remote_version_info_encode.part.0>:
	sep->max_rx_time = pdu_data->llctrl.length_rsp.max_rx_time;
}
#endif /* CONFIG_BT_CTLR_DATA_LENGTH */

#if defined(CONFIG_BT_REMOTE_VERSION)
void hci_remote_version_info_encode(struct pdu_data *pdu_data, u16_t handle,
 100792c:	b570      	push	{r4, r5, r6, lr}
	hdr = net_buf_add(buf, sizeof(*hdr));
 100792e:	f102 0508 	add.w	r5, r2, #8
void hci_remote_version_info_encode(struct pdu_data *pdu_data, u16_t handle,
 1007932:	4604      	mov	r4, r0
 1007934:	460e      	mov	r6, r1
	hdr = net_buf_add(buf, sizeof(*hdr));
 1007936:	4628      	mov	r0, r5
 1007938:	2102      	movs	r1, #2
 100793a:	f00f f8c2 	bl	1016ac2 <net_buf_simple_add>
	hdr->evt = evt;
 100793e:	220c      	movs	r2, #12
	hdr = net_buf_add(buf, sizeof(*hdr));
 1007940:	4603      	mov	r3, r0
	hdr->len = len;
 1007942:	2108      	movs	r1, #8
	hdr->evt = evt;
 1007944:	701a      	strb	r2, [r3, #0]
	hdr->len = len;
 1007946:	7059      	strb	r1, [r3, #1]
	if (!(event_mask & BT_EVT_MASK_REMOTE_VERSION_INFO)) {
		return;
	}

	hci_evt_create(buf, BT_HCI_EVT_REMOTE_VERSION_INFO, sizeof(*ep));
	ep = net_buf_add(buf, sizeof(*ep));
 1007948:	4628      	mov	r0, r5
 100794a:	f00f f8ba 	bl	1016ac2 <net_buf_simple_add>

	ver_ind = &pdu_data->llctrl.version_ind;
	ep->status = 0x00;
 100794e:	2300      	movs	r3, #0
	ep->handle = sys_cpu_to_le16(handle);
 1007950:	f8a0 6001 	strh.w	r6, [r0, #1]
	ep->status = 0x00;
 1007954:	7003      	strb	r3, [r0, #0]
	ep->version = ver_ind->version_number;
 1007956:	7923      	ldrb	r3, [r4, #4]
 1007958:	70c3      	strb	r3, [r0, #3]
	ep->manufacturer = ver_ind->company_id;
 100795a:	f8b4 3005 	ldrh.w	r3, [r4, #5]
 100795e:	8083      	strh	r3, [r0, #4]
	ep->subversion = ver_ind->sub_version_number;
 1007960:	f8b4 3007 	ldrh.w	r3, [r4, #7]
 1007964:	80c3      	strh	r3, [r0, #6]
}
 1007966:	bd70      	pop	{r4, r5, r6, pc}

01007968 <bt_hci_evt_create>:
{
 1007968:	b570      	push	{r4, r5, r6, lr}
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
 100796a:	f04f 32ff 	mov.w	r2, #4294967295
{
 100796e:	460e      	mov	r6, r1
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
 1007970:	f04f 33ff 	mov.w	r3, #4294967295
 1007974:	2100      	movs	r1, #0
{
 1007976:	4605      	mov	r5, r0
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
 1007978:	f00f f836 	bl	10169e8 <bt_buf_get_evt>
	hdr = net_buf_add(buf, sizeof(*hdr));
 100797c:	2102      	movs	r1, #2
	buf = bt_buf_get_evt(evt, false, K_FOREVER);
 100797e:	4604      	mov	r4, r0
	hdr = net_buf_add(buf, sizeof(*hdr));
 1007980:	3008      	adds	r0, #8
 1007982:	f00f f89e 	bl	1016ac2 <net_buf_simple_add>
 1007986:	4603      	mov	r3, r0
	hdr->len = len;
 1007988:	705e      	strb	r6, [r3, #1]
	hdr->evt = evt;
 100798a:	701d      	strb	r5, [r3, #0]
}
 100798c:	4620      	mov	r0, r4
 100798e:	bd70      	pop	{r4, r5, r6, pc}

01007990 <bt_hci_cmd_complete_create>:
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
 1007990:	3103      	adds	r1, #3
{
 1007992:	b538      	push	{r3, r4, r5, lr}
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
 1007994:	b2c9      	uxtb	r1, r1
{
 1007996:	4605      	mov	r5, r0
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
 1007998:	200e      	movs	r0, #14
 100799a:	f7ff ffe5 	bl	1007968 <bt_hci_evt_create>
	cc = net_buf_add(buf, sizeof(*cc));
 100799e:	2103      	movs	r1, #3
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_COMPLETE, sizeof(*cc) + plen);
 10079a0:	4604      	mov	r4, r0
	cc = net_buf_add(buf, sizeof(*cc));
 10079a2:	3008      	adds	r0, #8
 10079a4:	f00f f88d 	bl	1016ac2 <net_buf_simple_add>
	cc->ncmd = 1U;
 10079a8:	2201      	movs	r2, #1
	cc = net_buf_add(buf, sizeof(*cc));
 10079aa:	4603      	mov	r3, r0
	cc->ncmd = 1U;
 10079ac:	701a      	strb	r2, [r3, #0]
}
 10079ae:	4620      	mov	r0, r4
	cc->opcode = sys_cpu_to_le16(op);
 10079b0:	f8a3 5001 	strh.w	r5, [r3, #1]
}
 10079b4:	bd38      	pop	{r3, r4, r5, pc}
 10079b6:	bf00      	nop

010079b8 <bt_hci_cmd_status_create>:
{
 10079b8:	b570      	push	{r4, r5, r6, lr}
 10079ba:	4605      	mov	r5, r0
 10079bc:	460e      	mov	r6, r1
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_STATUS, sizeof(*cs));
 10079be:	200f      	movs	r0, #15
 10079c0:	2104      	movs	r1, #4
 10079c2:	f7ff ffd1 	bl	1007968 <bt_hci_evt_create>
	cs = net_buf_add(buf, sizeof(*cs));
 10079c6:	2104      	movs	r1, #4
	buf = bt_hci_evt_create(BT_HCI_EVT_CMD_STATUS, sizeof(*cs));
 10079c8:	4604      	mov	r4, r0
	cs = net_buf_add(buf, sizeof(*cs));
 10079ca:	3008      	adds	r0, #8
 10079cc:	f00f f879 	bl	1016ac2 <net_buf_simple_add>
	cs->ncmd = 1U;
 10079d0:	2201      	movs	r2, #1
	cs = net_buf_add(buf, sizeof(*cs));
 10079d2:	4603      	mov	r3, r0
	cs->status = status;
 10079d4:	701e      	strb	r6, [r3, #0]
	cs->ncmd = 1U;
 10079d6:	705a      	strb	r2, [r3, #1]
}
 10079d8:	4620      	mov	r0, r4
	cs->opcode = sys_cpu_to_le16(op);
 10079da:	805d      	strh	r5, [r3, #2]
}
 10079dc:	bd70      	pop	{r4, r5, r6, pc}
 10079de:	bf00      	nop

010079e0 <hci_cmd_complete>:
{
 10079e0:	b538      	push	{r3, r4, r5, lr}
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 10079e2:	4b06      	ldr	r3, [pc, #24]	; (10079fc <hci_cmd_complete+0x1c>)
{
 10079e4:	4604      	mov	r4, r0
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 10079e6:	8818      	ldrh	r0, [r3, #0]
{
 10079e8:	460d      	mov	r5, r1
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 10079ea:	f7ff ffd1 	bl	1007990 <bt_hci_cmd_complete_create>
	return net_buf_add(*buf, plen);
 10079ee:	4629      	mov	r1, r5
	*buf = bt_hci_cmd_complete_create(_opcode, plen);
 10079f0:	6020      	str	r0, [r4, #0]
	return net_buf_add(*buf, plen);
 10079f2:	3008      	adds	r0, #8
}
 10079f4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	return net_buf_add(*buf, plen);
 10079f8:	f00f b863 	b.w	1016ac2 <net_buf_simple_add>
 10079fc:	21006684 	.word	0x21006684

01007a00 <reset>:
{
 1007a00:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	event_mask = DEFAULT_EVENT_MASK;
 1007a04:	f04f 32ff 	mov.w	r2, #4294967295
 1007a08:	f641 73ff 	movw	r3, #8191	; 0x1fff
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
 1007a0c:	f04f 0800 	mov.w	r8, #0
 1007a10:	f04f 0900 	mov.w	r9, #0
	dup_count = -1;
 1007a14:	f04f 3eff 	mov.w	lr, #4294967295
	le_event_mask = DEFAULT_LE_EVENT_MASK;
 1007a18:	261f      	movs	r6, #31
 1007a1a:	2700      	movs	r7, #0
{
 1007a1c:	460d      	mov	r5, r1
	event_mask = DEFAULT_EVENT_MASK;
 1007a1e:	4921      	ldr	r1, [pc, #132]	; (1007aa4 <reset+0xa4>)
	dup_count = -1;
 1007a20:	f8df c0a8 	ldr.w	ip, [pc, #168]	; 1007acc <reset+0xcc>
	event_mask = DEFAULT_EVENT_MASK;
 1007a24:	e9c1 2300 	strd	r2, r3, [r1]
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
 1007a28:	4b1f      	ldr	r3, [pc, #124]	; (1007aa8 <reset+0xa8>)
	dup_count = -1;
 1007a2a:	f8cc e000 	str.w	lr, [ip]
	event_mask_page_2 = DEFAULT_EVENT_MASK_PAGE_2;
 1007a2e:	e9c3 8900 	strd	r8, r9, [r3]
	le_event_mask = DEFAULT_LE_EVENT_MASK;
 1007a32:	4b1e      	ldr	r3, [pc, #120]	; (1007aac <reset+0xac>)
 1007a34:	e9c3 6700 	strd	r6, r7, [r3]
	if (buf) {
 1007a38:	b320      	cbz	r0, 1007a84 <reset+0x84>
		ll_reset();
 1007a3a:	f001 feed 	bl	1009818 <ll_reset>
		ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1007a3e:	4628      	mov	r0, r5
 1007a40:	2101      	movs	r1, #1
 1007a42:	f7ff ffcd 	bl	10079e0 <hci_cmd_complete>
		ccst->status = 0x00;
 1007a46:	2400      	movs	r4, #0
	hci_hbuf_acked = 0U;
 1007a48:	4b19      	ldr	r3, [pc, #100]	; (1007ab0 <reset+0xb0>)
	hci_hbuf_total = 0;
 1007a4a:	4e1a      	ldr	r6, [pc, #104]	; (1007ab4 <reset+0xb4>)
	hci_hbuf_sent = 0U;
 1007a4c:	4d1a      	ldr	r5, [pc, #104]	; (1007ab8 <reset+0xb8>)
		ccst->status = 0x00;
 1007a4e:	7004      	strb	r4, [r0, #0]
	(void)memset(hci_hbuf_pend, 0, sizeof(hci_hbuf_pend));
 1007a50:	2220      	movs	r2, #32
 1007a52:	4621      	mov	r1, r4
 1007a54:	4819      	ldr	r0, [pc, #100]	; (1007abc <reset+0xbc>)
	hci_hbuf_acked = 0U;
 1007a56:	601c      	str	r4, [r3, #0]
	hci_hbuf_total = 0;
 1007a58:	6034      	str	r4, [r6, #0]
	hci_hbuf_sent = 0U;
 1007a5a:	602c      	str	r4, [r5, #0]
	(void)memset(hci_hbuf_pend, 0, sizeof(hci_hbuf_pend));
 1007a5c:	f00e ff57 	bl	101690e <memset>
	conn_count = 0U;
 1007a60:	4a17      	ldr	r2, [pc, #92]	; (1007ac0 <reset+0xc0>)
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 1007a62:	4b18      	ldr	r3, [pc, #96]	; (1007ac4 <reset+0xc4>)
 1007a64:	6014      	str	r4, [r2, #0]
 1007a66:	e8d3 2fef 	ldaex	r2, [r3]
 1007a6a:	f042 0201 	orr.w	r2, r2, #1
 1007a6e:	e8c3 2fe1 	stlex	r1, r2, [r3]
 1007a72:	2900      	cmp	r1, #0
 1007a74:	d1f7      	bne.n	1007a66 <reset+0x66>
		k_poll_signal_raise(hbuf_signal, 0x0);
 1007a76:	4b14      	ldr	r3, [pc, #80]	; (1007ac8 <reset+0xc8>)
 1007a78:	6818      	ldr	r0, [r3, #0]
 1007a7a:	4621      	mov	r1, r4
}
 1007a7c:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1007a80:	f00d b95a 	b.w	1014d38 <z_impl_k_poll_signal_raise>
 1007a84:	4604      	mov	r4, r0
	hci_hbuf_total = 0;
 1007a86:	480b      	ldr	r0, [pc, #44]	; (1007ab4 <reset+0xb4>)
	hci_hbuf_acked = 0U;
 1007a88:	4b09      	ldr	r3, [pc, #36]	; (1007ab0 <reset+0xb0>)
	hci_hbuf_sent = 0U;
 1007a8a:	4d0b      	ldr	r5, [pc, #44]	; (1007ab8 <reset+0xb8>)
	hci_hbuf_total = 0;
 1007a8c:	6004      	str	r4, [r0, #0]
	(void)memset(hci_hbuf_pend, 0, sizeof(hci_hbuf_pend));
 1007a8e:	2220      	movs	r2, #32
 1007a90:	4621      	mov	r1, r4
 1007a92:	480a      	ldr	r0, [pc, #40]	; (1007abc <reset+0xbc>)
	hci_hbuf_acked = 0U;
 1007a94:	601c      	str	r4, [r3, #0]
	hci_hbuf_sent = 0U;
 1007a96:	602c      	str	r4, [r5, #0]
	(void)memset(hci_hbuf_pend, 0, sizeof(hci_hbuf_pend));
 1007a98:	f00e ff39 	bl	101690e <memset>
	conn_count = 0U;
 1007a9c:	4b08      	ldr	r3, [pc, #32]	; (1007ac0 <reset+0xc0>)
 1007a9e:	601c      	str	r4, [r3, #0]
}
 1007aa0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 1007aa4:	21000000 	.word	0x21000000
 1007aa8:	210006c0 	.word	0x210006c0
 1007aac:	21000008 	.word	0x21000008
 1007ab0:	21000d04 	.word	0x21000d04
 1007ab4:	21000d2c 	.word	0x21000d2c
 1007ab8:	21000d28 	.word	0x21000d28
 1007abc:	21000d08 	.word	0x21000d08
 1007ac0:	21000c74 	.word	0x21000c74
 1007ac4:	21000d30 	.word	0x21000d30
 1007ac8:	21000d00 	.word	0x21000d00
 1007acc:	21000c78 	.word	0x21000c78

01007ad0 <hci_vendor_cmd_handle_common>:
{
 1007ad0:	b570      	push	{r4, r5, r6, lr}
 1007ad2:	1e43      	subs	r3, r0, #1
 1007ad4:	4614      	mov	r4, r2
 1007ad6:	b086      	sub	sp, #24
 1007ad8:	2b09      	cmp	r3, #9
 1007ada:	d806      	bhi.n	1007aea <hci_vendor_cmd_handle_common+0x1a>
 1007adc:	e8df f003 	tbb	[pc, r3]
 1007ae0:	05382109 	.word	0x05382109
 1007ae4:	54054605 	.word	0x54054605
 1007ae8:	7b6b      	.short	0x7b6b
	return 0;
 1007aea:	f06f 0015 	mvn.w	r0, #21
}
 1007aee:	b006      	add	sp, #24
 1007af0:	bd70      	pop	{r4, r5, r6, pc}
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007af2:	4620      	mov	r0, r4
 1007af4:	210d      	movs	r1, #13
 1007af6:	f7ff ff73 	bl	10079e0 <hci_cmd_complete>
	rp->status = 0x00;
 1007afa:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007afc:	4603      	mov	r3, r0
	rp->status = 0x00;
 1007afe:	7001      	strb	r1, [r0, #0]
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
 1007b00:	7081      	strb	r1, [r0, #2]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
 1007b02:	7101      	strb	r1, [r0, #4]
	rp->fw_variant = 0U;
 1007b04:	7141      	strb	r1, [r0, #5]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
 1007b06:	7201      	strb	r1, [r0, #8]
	rp->fw_build = sys_cpu_to_le32(KERNEL_PATCHLEVEL & 0xffff);
 1007b08:	7241      	strb	r1, [r0, #9]
 1007b0a:	7281      	strb	r1, [r0, #10]
 1007b0c:	72c1      	strb	r1, [r0, #11]
 1007b0e:	7301      	strb	r1, [r0, #12]
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
 1007b10:	2402      	movs	r4, #2
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
 1007b12:	2203      	movs	r2, #3
	return 0;
 1007b14:	4608      	mov	r0, r1
	rp->hw_platform = sys_cpu_to_le16(BT_HCI_VS_HW_PLAT);
 1007b16:	705c      	strb	r4, [r3, #1]
	rp->fw_version = (KERNEL_VERSION_MAJOR & 0xff);
 1007b18:	719c      	strb	r4, [r3, #6]
	rp->hw_variant = sys_cpu_to_le16(BT_HCI_VS_HW_VAR);
 1007b1a:	70da      	strb	r2, [r3, #3]
	rp->fw_revision = sys_cpu_to_le16(KERNEL_VERSION_MINOR);
 1007b1c:	71da      	strb	r2, [r3, #7]
}
 1007b1e:	b006      	add	sp, #24
 1007b20:	bd70      	pop	{r4, r5, r6, pc}
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007b22:	4620      	mov	r0, r4
 1007b24:	2141      	movs	r1, #65	; 0x41
 1007b26:	f7ff ff5b 	bl	10079e0 <hci_cmd_complete>
	rp->status = 0x00;
 1007b2a:	2400      	movs	r4, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007b2c:	4605      	mov	r5, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
 1007b2e:	4621      	mov	r1, r4
 1007b30:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
 1007b32:	f800 4b01 	strb.w	r4, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
 1007b36:	f00e feea 	bl	101690e <memset>
	return 0;
 1007b3a:	4620      	mov	r0, r4
	rp->commands[0] |= BIT(5) | BIT(7);
 1007b3c:	786a      	ldrb	r2, [r5, #1]
	rp->commands[1] |= BIT(0) | BIT(1);
 1007b3e:	78ab      	ldrb	r3, [r5, #2]
	rp->commands[0] |= BIT(5) | BIT(7);
 1007b40:	f062 0258 	orn	r2, r2, #88	; 0x58
	rp->commands[1] |= BIT(0) | BIT(1);
 1007b44:	f043 0303 	orr.w	r3, r3, #3
	rp->commands[0] |= BIT(5) | BIT(7);
 1007b48:	706a      	strb	r2, [r5, #1]
	rp->commands[1] |= BIT(0) | BIT(1);
 1007b4a:	70ab      	strb	r3, [r5, #2]
}
 1007b4c:	b006      	add	sp, #24
 1007b4e:	bd70      	pop	{r4, r5, r6, pc}
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007b50:	4620      	mov	r0, r4
 1007b52:	2109      	movs	r1, #9
 1007b54:	f7ff ff44 	bl	10079e0 <hci_cmd_complete>
	rp->status = 0x00;
 1007b58:	2400      	movs	r4, #0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
 1007b5a:	2208      	movs	r2, #8
 1007b5c:	4621      	mov	r1, r4
	rp->status = 0x00;
 1007b5e:	f800 4b01 	strb.w	r4, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
 1007b62:	f00e fed4 	bl	101690e <memset>
	return 0;
 1007b66:	4620      	mov	r0, r4
}
 1007b68:	b006      	add	sp, #24
 1007b6a:	bd70      	pop	{r4, r5, r6, pc}
	ll_addr_set(0, &cmd->bdaddr.val[0]);
 1007b6c:	6889      	ldr	r1, [r1, #8]
 1007b6e:	2000      	movs	r0, #0
 1007b70:	f7ff fbbe 	bl	10072f0 <ll_addr_set>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1007b74:	4620      	mov	r0, r4
 1007b76:	2101      	movs	r1, #1
 1007b78:	f7ff ff32 	bl	10079e0 <hci_cmd_complete>
	ccst->status = 0x00;
 1007b7c:	2200      	movs	r2, #0
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1007b7e:	4603      	mov	r3, r0
	return 0;
 1007b80:	4610      	mov	r0, r2
	ccst->status = 0x00;
 1007b82:	701a      	strb	r2, [r3, #0]
}
 1007b84:	b006      	add	sp, #24
 1007b86:	bd70      	pop	{r4, r5, r6, pc}
	const char build_info[] = HCI_VS_BUILD_INFO;
 1007b88:	466d      	mov	r5, sp
 1007b8a:	4e1a      	ldr	r6, [pc, #104]	; (1007bf4 <hci_vendor_cmd_handle_common+0x124>)
 1007b8c:	ce0f      	ldmia	r6!, {r0, r1, r2, r3}
 1007b8e:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 1007b90:	e896 0003 	ldmia.w	r6, {r0, r1}
 1007b94:	f845 0b04 	str.w	r0, [r5], #4
 1007b98:	7029      	strb	r1, [r5, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp) + sizeof(build_info));
 1007b9a:	4620      	mov	r0, r4
 1007b9c:	2116      	movs	r1, #22
 1007b9e:	f7ff ff1f 	bl	10079e0 <hci_cmd_complete>
	rp->status = 0x00;
 1007ba2:	2400      	movs	r4, #0
	memcpy(rp->info, build_info, sizeof(build_info));
 1007ba4:	2215      	movs	r2, #21
 1007ba6:	4669      	mov	r1, sp
	rp->status = 0x00;
 1007ba8:	f800 4b01 	strb.w	r4, [r0], #1
	memcpy(rp->info, build_info, sizeof(build_info));
 1007bac:	f00e fe84 	bl	10168b8 <memcpy>
	return 0;
 1007bb0:	4620      	mov	r0, r4
}
 1007bb2:	b006      	add	sp, #24
 1007bb4:	bd70      	pop	{r4, r5, r6, pc}
	rp = hci_cmd_complete(evt, sizeof(*rp) +
 1007bb6:	4620      	mov	r0, r4
 1007bb8:	2118      	movs	r1, #24
 1007bba:	f7ff ff11 	bl	10079e0 <hci_cmd_complete>
	rp->status = 0x00;
 1007bbe:	2400      	movs	r4, #0
	rp = hci_cmd_complete(evt, sizeof(*rp) +
 1007bc0:	4605      	mov	r5, r0
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
 1007bc2:	2101      	movs	r1, #1
	rp->status = 0x00;
 1007bc4:	f800 4b02 	strb.w	r4, [r0], #2
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
 1007bc8:	f00a fd4e 	bl	1012668 <hci_vendor_read_static_addr>
 1007bcc:	4603      	mov	r3, r0
	return 0;
 1007bce:	4620      	mov	r0, r4
	rp->num_addrs = hci_vendor_read_static_addr(rp->a, 1);
 1007bd0:	706b      	strb	r3, [r5, #1]
}
 1007bd2:	b006      	add	sp, #24
 1007bd4:	bd70      	pop	{r4, r5, r6, pc}
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007bd6:	4620      	mov	r0, r4
 1007bd8:	2121      	movs	r1, #33	; 0x21
 1007bda:	f7ff ff01 	bl	10079e0 <hci_cmd_complete>
	rp->status = 0x00;
 1007bde:	2400      	movs	r4, #0
 1007be0:	4601      	mov	r1, r0
	hci_vendor_read_key_hierarchy_roots(rp->ir, rp->er);
 1007be2:	3001      	adds	r0, #1
	rp->status = 0x00;
 1007be4:	f801 4b11 	strb.w	r4, [r1], #17
	hci_vendor_read_key_hierarchy_roots(rp->ir, rp->er);
 1007be8:	f00a fdaa 	bl	1012740 <hci_vendor_read_key_hierarchy_roots>
	return 0;
 1007bec:	4620      	mov	r0, r4
}
 1007bee:	b006      	add	sp, #24
 1007bf0:	bd70      	pop	{r4, r5, r6, pc}
 1007bf2:	bf00      	nop
 1007bf4:	01018598 	.word	0x01018598

01007bf8 <hci_cmd_handle>:
{
 1007bf8:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct net_buf *evt = NULL;
 1007bfa:	2500      	movs	r5, #0
	if (cmd->len < sizeof(*chdr)) {
 1007bfc:	8983      	ldrh	r3, [r0, #12]
{
 1007bfe:	b08f      	sub	sp, #60	; 0x3c
	if (cmd->len < sizeof(*chdr)) {
 1007c00:	2b02      	cmp	r3, #2
	struct net_buf *evt = NULL;
 1007c02:	9509      	str	r5, [sp, #36]	; 0x24
	if (cmd->len < sizeof(*chdr)) {
 1007c04:	f240 80e0 	bls.w	1007dc8 <hci_cmd_handle+0x1d0>
	chdr = net_buf_pull_mem(cmd, sizeof(*chdr));
 1007c08:	4604      	mov	r4, r0
 1007c0a:	460e      	mov	r6, r1
 1007c0c:	3008      	adds	r0, #8
 1007c0e:	2103      	movs	r1, #3
 1007c10:	f00e ff77 	bl	1016b02 <net_buf_simple_pull_mem>
	if (cmd->len < chdr->param_len) {
 1007c14:	89a2      	ldrh	r2, [r4, #12]
 1007c16:	7883      	ldrb	r3, [r0, #2]
 1007c18:	429a      	cmp	r2, r3
 1007c1a:	f0c0 80fb 	bcc.w	1007e14 <hci_cmd_handle+0x21c>
	_opcode = sys_le16_to_cpu(chdr->opcode);
 1007c1e:	8803      	ldrh	r3, [r0, #0]
 1007c20:	4d86      	ldr	r5, [pc, #536]	; (1007e3c <hci_cmd_handle+0x244>)
	switch (BT_OGF(_opcode)) {
 1007c22:	f3c3 2285 	ubfx	r2, r3, #10, #6
 1007c26:	2a08      	cmp	r2, #8
	_opcode = sys_le16_to_cpu(chdr->opcode);
 1007c28:	b298      	uxth	r0, r3
 1007c2a:	802b      	strh	r3, [r5, #0]
	ocf = BT_OCF(_opcode);
 1007c2c:	f3c3 0309 	ubfx	r3, r3, #0, #10
	switch (BT_OGF(_opcode)) {
 1007c30:	d86b      	bhi.n	1007d0a <hci_cmd_handle+0x112>
 1007c32:	2a00      	cmp	r2, #0
 1007c34:	d073      	beq.n	1007d1e <hci_cmd_handle+0x126>
 1007c36:	3a01      	subs	r2, #1
 1007c38:	2a07      	cmp	r2, #7
 1007c3a:	d870      	bhi.n	1007d1e <hci_cmd_handle+0x126>
 1007c3c:	e8df f002 	tbb	[pc, r2]
 1007c40:	579c6f8e 	.word	0x579c6f8e
 1007c44:	046f6f74 	.word	0x046f6f74
	switch (ocf) {
 1007c48:	3b01      	subs	r3, #1
 1007c4a:	2b4d      	cmp	r3, #77	; 0x4d
 1007c4c:	d867      	bhi.n	1007d1e <hci_cmd_handle+0x126>
 1007c4e:	e8df f013 	tbh	[pc, r3, lsl #1]
 1007c52:	02e5      	.short	0x02e5
 1007c54:	02620274 	.word	0x02620274
 1007c58:	025d0066 	.word	0x025d0066
 1007c5c:	04670242 	.word	0x04670242
 1007c60:	045b0461 	.word	0x045b0461
 1007c64:	02ab0456 	.word	0x02ab0456
 1007c68:	0281029a 	.word	0x0281029a
 1007c6c:	044a0303 	.word	0x044a0303
 1007c70:	043c0440 	.word	0x043c0440
 1007c74:	03270438 	.word	0x03270438
 1007c78:	03130323 	.word	0x03130323
 1007c7c:	0387039b 	.word	0x0387039b
 1007c80:	036d037b 	.word	0x036d037b
 1007c84:	03600368 	.word	0x03600368
 1007c88:	0066034d 	.word	0x0066034d
 1007c8c:	00660066 	.word	0x00660066
 1007c90:	0471033e 	.word	0x0471033e
 1007c94:	0224023a 	.word	0x0224023a
 1007c98:	0066021e 	.word	0x0066021e
 1007c9c:	02170066 	.word	0x02170066
 1007ca0:	0203020d 	.word	0x0203020d
 1007ca4:	042701f7 	.word	0x042701f7
 1007ca8:	04090416 	.word	0x04090416
 1007cac:	03dc03fd 	.word	0x03dc03fd
 1007cb0:	03a403b5 	.word	0x03a403b5
 1007cb4:	006602b7 	.word	0x006602b7
 1007cb8:	00660066 	.word	0x00660066
 1007cbc:	00660066 	.word	0x00660066
 1007cc0:	00660066 	.word	0x00660066
 1007cc4:	00660066 	.word	0x00660066
 1007cc8:	00660066 	.word	0x00660066
 1007ccc:	00660066 	.word	0x00660066
 1007cd0:	00660066 	.word	0x00660066
 1007cd4:	00660066 	.word	0x00660066
 1007cd8:	00660066 	.word	0x00660066
 1007cdc:	00660066 	.word	0x00660066
 1007ce0:	00660066 	.word	0x00660066
 1007ce4:	03070066 	.word	0x03070066
 1007ce8:	00660066 	.word	0x00660066
 1007cec:	0339      	.short	0x0339
	switch (ocf) {
 1007cee:	3b01      	subs	r3, #1
 1007cf0:	2b08      	cmp	r3, #8
 1007cf2:	d814      	bhi.n	1007d1e <hci_cmd_handle+0x126>
 1007cf4:	e8df f013 	tbh	[pc, r3, lsl #1]
 1007cf8:	00ae0102 	.word	0x00ae0102
 1007cfc:	00130092 	.word	0x00130092
 1007d00:	00130013 	.word	0x00130013
 1007d04:	00130013 	.word	0x00130013
 1007d08:	0119      	.short	0x0119
	switch (BT_OGF(_opcode)) {
 1007d0a:	2a3f      	cmp	r2, #63	; 0x3f
 1007d0c:	d107      	bne.n	1007d1e <hci_cmd_handle+0x126>

/* Map vendor command handler directly to common implementation */
inline int hci_vendor_cmd_handle(u16_t ocf, struct net_buf *cmd,
				 struct net_buf **evt)
{
	return hci_vendor_cmd_handle_common(ocf, cmd, evt);
 1007d0e:	4621      	mov	r1, r4
 1007d10:	4618      	mov	r0, r3
 1007d12:	aa09      	add	r2, sp, #36	; 0x24
 1007d14:	f7ff fedc 	bl	1007ad0 <hci_vendor_cmd_handle_common>
	if (err == -EINVAL) {
 1007d18:	3016      	adds	r0, #22
 1007d1a:	d11c      	bne.n	1007d56 <hci_cmd_handle+0x15e>
 1007d1c:	8828      	ldrh	r0, [r5, #0]
	return bt_hci_cmd_status_create(_opcode, status);
 1007d1e:	2101      	movs	r1, #1
 1007d20:	f7ff fe4a 	bl	10079b8 <bt_hci_cmd_status_create>
}
 1007d24:	b00f      	add	sp, #60	; 0x3c
 1007d26:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (ocf) {
 1007d28:	2b05      	cmp	r3, #5
 1007d2a:	d1f8      	bne.n	1007d1e <hci_cmd_handle+0x126>
	handle = sys_le16_to_cpu(cmd->handle);
 1007d2c:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007d2e:	2104      	movs	r1, #4
 1007d30:	a809      	add	r0, sp, #36	; 0x24
	handle = sys_le16_to_cpu(cmd->handle);
 1007d32:	881d      	ldrh	r5, [r3, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007d34:	f7ff fe54 	bl	10079e0 <hci_cmd_complete>
 1007d38:	4604      	mov	r4, r0
	handle = sys_le16_to_cpu(cmd->handle);
 1007d3a:	b2a8      	uxth	r0, r5
	rp->status = ll_rssi_get(handle, &rp->rssi);
 1007d3c:	1ce1      	adds	r1, r4, #3
 1007d3e:	f003 fe89 	bl	100ba54 <ll_rssi_get>
	rp->handle = sys_cpu_to_le16(handle);
 1007d42:	f8a4 5001 	strh.w	r5, [r4, #1]
	rp->status = ll_rssi_get(handle, &rp->rssi);
 1007d46:	7020      	strb	r0, [r4, #0]
	rp->rssi = (!rp->status) ? -rp->rssi : 127;
 1007d48:	2800      	cmp	r0, #0
 1007d4a:	f040 83ff 	bne.w	100854c <hci_cmd_handle+0x954>
 1007d4e:	78e3      	ldrb	r3, [r4, #3]
 1007d50:	425b      	negs	r3, r3
 1007d52:	b25b      	sxtb	r3, r3
 1007d54:	70e3      	strb	r3, [r4, #3]
	if (err == -EINVAL) {
 1007d56:	9809      	ldr	r0, [sp, #36]	; 0x24
}
 1007d58:	b00f      	add	sp, #60	; 0x3c
 1007d5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (ocf) {
 1007d5c:	2b06      	cmp	r3, #6
 1007d5e:	f000 83f8 	beq.w	1008552 <hci_cmd_handle+0x95a>
 1007d62:	2b1d      	cmp	r3, #29
 1007d64:	d1db      	bne.n	1007d1e <hci_cmd_handle+0x126>
	handle = sys_le16_to_cpu(cmd->handle);
 1007d66:	68a3      	ldr	r3, [r4, #8]
	status = ll_version_ind_send(handle);
 1007d68:	8818      	ldrh	r0, [r3, #0]
 1007d6a:	f003 fd67 	bl	100b83c <ll_version_ind_send>
 1007d6e:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
 1007d70:	8828      	ldrh	r0, [r5, #0]
 1007d72:	f7ff fe21 	bl	10079b8 <bt_hci_cmd_status_create>
}
 1007d76:	e7d5      	b.n	1007d24 <hci_cmd_handle+0x12c>
	switch (ocf) {
 1007d78:	2b35      	cmp	r3, #53	; 0x35
 1007d7a:	d832      	bhi.n	1007de2 <hci_cmd_handle+0x1ea>
 1007d7c:	2b2c      	cmp	r3, #44	; 0x2c
 1007d7e:	d80a      	bhi.n	1007d96 <hci_cmd_handle+0x19e>
 1007d80:	2b01      	cmp	r3, #1
 1007d82:	f000 83f9 	beq.w	1008578 <hci_cmd_handle+0x980>
 1007d86:	2b03      	cmp	r3, #3
 1007d88:	d1c9      	bne.n	1007d1e <hci_cmd_handle+0x126>
		reset(cmd, evt);
 1007d8a:	4620      	mov	r0, r4
 1007d8c:	a909      	add	r1, sp, #36	; 0x24
 1007d8e:	f7ff fe37 	bl	1007a00 <reset>
		break;
 1007d92:	9809      	ldr	r0, [sp, #36]	; 0x24
 1007d94:	e7c6      	b.n	1007d24 <hci_cmd_handle+0x12c>
 1007d96:	3b2d      	subs	r3, #45	; 0x2d
 1007d98:	2b08      	cmp	r3, #8
 1007d9a:	d8c0      	bhi.n	1007d1e <hci_cmd_handle+0x126>
 1007d9c:	a201      	add	r2, pc, #4	; (adr r2, 1007da4 <hci_cmd_handle+0x1ac>)
 1007d9e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 1007da2:	bf00      	nop
 1007da4:	01007fcd 	.word	0x01007fcd
 1007da8:	01007d1f 	.word	0x01007d1f
 1007dac:	01007d1f 	.word	0x01007d1f
 1007db0:	01007d1f 	.word	0x01007d1f
 1007db4:	01007ff3 	.word	0x01007ff3
 1007db8:	01007d1f 	.word	0x01007d1f
 1007dbc:	01007fa7 	.word	0x01007fa7
 1007dc0:	01007d1f 	.word	0x01007d1f
 1007dc4:	01007f43 	.word	0x01007f43
 1007dc8:	491d      	ldr	r1, [pc, #116]	; (1007e40 <hci_cmd_handle+0x248>)
 1007dca:	4b1e      	ldr	r3, [pc, #120]	; (1007e44 <hci_cmd_handle+0x24c>)
		BT_ERR("No HCI Command header");
 1007dcc:	481e      	ldr	r0, [pc, #120]	; (1007e48 <hci_cmd_handle+0x250>)
 1007dce:	1ac9      	subs	r1, r1, r3
 1007dd0:	08c9      	lsrs	r1, r1, #3
		BT_ERR("Invalid HCI CMD packet length");
 1007dd2:	0189      	lsls	r1, r1, #6
 1007dd4:	f041 0101 	orr.w	r1, r1, #1
 1007dd8:	f00d fad9 	bl	101538e <log_0>
		return NULL;
 1007ddc:	4628      	mov	r0, r5
}
 1007dde:	b00f      	add	sp, #60	; 0x3c
 1007de0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	switch (ocf) {
 1007de2:	2b7b      	cmp	r3, #123	; 0x7b
 1007de4:	f000 83d7 	beq.w	1008596 <hci_cmd_handle+0x99e>
 1007de8:	2b7c      	cmp	r3, #124	; 0x7c
 1007dea:	d10e      	bne.n	1007e0a <hci_cmd_handle+0x212>
		write_auth_payload_timeout(cmd, evt);
 1007dec:	68a3      	ldr	r3, [r4, #8]
	handle = sys_le16_to_cpu(cmd->handle);
 1007dee:	881d      	ldrh	r5, [r3, #0]
	status = ll_apto_set(handle, auth_payload_timeout);
 1007df0:	8859      	ldrh	r1, [r3, #2]
 1007df2:	b2a8      	uxth	r0, r5
 1007df4:	f003 fe70 	bl	100bad8 <ll_apto_set>
	status = ll_start_enc_req_send(handle, 0x00, &cmd->ltk[0]);
 1007df8:	4604      	mov	r4, r0
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007dfa:	2103      	movs	r1, #3
 1007dfc:	a809      	add	r0, sp, #36	; 0x24
 1007dfe:	f7ff fdef 	bl	10079e0 <hci_cmd_complete>
	rp->status = status;
 1007e02:	7004      	strb	r4, [r0, #0]
	rp->handle = sys_cpu_to_le16(handle);
 1007e04:	f8a0 5001 	strh.w	r5, [r0, #1]
	if (err == -EINVAL) {
 1007e08:	e7a5      	b.n	1007d56 <hci_cmd_handle+0x15e>
	switch (ocf) {
 1007e0a:	2b63      	cmp	r3, #99	; 0x63
 1007e0c:	d187      	bne.n	1007d1e <hci_cmd_handle+0x126>
 *
 *  @return 64-bit integer in host endianness.
 */
static inline u64_t sys_get_le64(const u8_t src[8])
{
	return ((u64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
 1007e0e:	68a2      	ldr	r2, [r4, #8]
	event_mask_page_2 = sys_get_le64(cmd->events_page_2);
 1007e10:	4b0e      	ldr	r3, [pc, #56]	; (1007e4c <hci_cmd_handle+0x254>)
 1007e12:	e205      	b.n	1008220 <hci_cmd_handle+0x628>
 1007e14:	490a      	ldr	r1, [pc, #40]	; (1007e40 <hci_cmd_handle+0x248>)
 1007e16:	4b0b      	ldr	r3, [pc, #44]	; (1007e44 <hci_cmd_handle+0x24c>)
		BT_ERR("Invalid HCI CMD packet length");
 1007e18:	480d      	ldr	r0, [pc, #52]	; (1007e50 <hci_cmd_handle+0x258>)
 1007e1a:	e7d8      	b.n	1007dce <hci_cmd_handle+0x1d6>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007e1c:	2109      	movs	r1, #9
 1007e1e:	a809      	add	r0, sp, #36	; 0x24
 1007e20:	f7ff fdde 	bl	10079e0 <hci_cmd_complete>
	rp->status = 0x00;
 1007e24:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007e26:	4604      	mov	r4, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
 1007e28:	2208      	movs	r2, #8
	rp->status = 0x00;
 1007e2a:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
 1007e2e:	f00e fd6e 	bl	101690e <memset>
	rp->features[4] = (1 << 5) | (1 << 6);
 1007e32:	2360      	movs	r3, #96	; 0x60
 1007e34:	9809      	ldr	r0, [sp, #36]	; 0x24
 1007e36:	7163      	strb	r3, [r4, #5]
}
 1007e38:	e774      	b.n	1007d24 <hci_cmd_handle+0x12c>
 1007e3a:	bf00      	nop
 1007e3c:	21006684 	.word	0x21006684
 1007e40:	010180e0 	.word	0x010180e0
 1007e44:	010180b8 	.word	0x010180b8
 1007e48:	010185b0 	.word	0x010185b0
 1007e4c:	210006c0 	.word	0x210006c0
 1007e50:	010185c8 	.word	0x010185c8
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007e54:	2141      	movs	r1, #65	; 0x41
 1007e56:	a809      	add	r0, sp, #36	; 0x24
 1007e58:	f7ff fdc2 	bl	10079e0 <hci_cmd_complete>
	rp->status = 0x00;
 1007e5c:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007e5e:	4604      	mov	r4, r0
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
 1007e60:	2240      	movs	r2, #64	; 0x40
	rp->status = 0x00;
 1007e62:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->commands[0], 0, sizeof(rp->commands));
 1007e66:	f00e fd52 	bl	101690e <memset>
	rp->commands[26] |= BIT(4) | BIT(5);
 1007e6a:	23ff      	movs	r3, #255	; 0xff
	rp->commands[2] |= BIT(7);
 1007e6c:	78e5      	ldrb	r5, [r4, #3]
	rp->commands[0] |= BIT(5);
 1007e6e:	7860      	ldrb	r0, [r4, #1]
	rp->commands[5] |= BIT(6) | BIT(7);
 1007e70:	79a1      	ldrb	r1, [r4, #6]
	rp->commands[10] |= BIT(5) | BIT(6) | BIT(7);
 1007e72:	7ae2      	ldrb	r2, [r4, #11]
	rp->commands[2] |= BIT(7);
 1007e74:	f065 057f 	orn	r5, r5, #127	; 0x7f
	rp->commands[0] |= BIT(5);
 1007e78:	f040 0020 	orr.w	r0, r0, #32
	rp->commands[5] |= BIT(6) | BIT(7);
 1007e7c:	f061 013f 	orn	r1, r1, #63	; 0x3f
	rp->commands[10] |= BIT(5) | BIT(6) | BIT(7);
 1007e80:	f062 021b 	orn	r2, r2, #27
	rp->commands[14] |= BIT(3) | BIT(5);
 1007e84:	7be6      	ldrb	r6, [r4, #15]
	rp->commands[2] |= BIT(7);
 1007e86:	70e5      	strb	r5, [r4, #3]
	rp->commands[0] |= BIT(5);
 1007e88:	7060      	strb	r0, [r4, #1]
	rp->commands[15] |= BIT(5);
 1007e8a:	7c25      	ldrb	r5, [r4, #16]
	rp->commands[22] |= BIT(2);
 1007e8c:	7de0      	ldrb	r0, [r4, #23]
	rp->commands[5] |= BIT(6) | BIT(7);
 1007e8e:	71a1      	strb	r1, [r4, #6]
	rp->commands[10] |= BIT(5) | BIT(6) | BIT(7);
 1007e90:	72e2      	strb	r2, [r4, #11]
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
 1007e92:	7ea1      	ldrb	r1, [r4, #26]
	rp->commands[28] |= BIT(3);
 1007e94:	7f62      	ldrb	r2, [r4, #29]
	rp->commands[14] |= BIT(3) | BIT(5);
 1007e96:	f046 0628 	orr.w	r6, r6, #40	; 0x28
	rp->commands[15] |= BIT(5);
 1007e9a:	f045 0522 	orr.w	r5, r5, #34	; 0x22
	rp->commands[22] |= BIT(2);
 1007e9e:	f040 0004 	orr.w	r0, r0, #4
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
 1007ea2:	f061 0108 	orn	r1, r1, #8
	rp->commands[28] |= BIT(1) | BIT(2);
 1007ea6:	f042 020f 	orr.w	r2, r2, #15
	rp->commands[14] |= BIT(3) | BIT(5);
 1007eaa:	73e6      	strb	r6, [r4, #15]
	rp->commands[15] |= BIT(5);
 1007eac:	7425      	strb	r5, [r4, #16]
	rp->commands[32] |= BIT(4) | BIT(5);
 1007eae:	f894 6021 	ldrb.w	r6, [r4, #33]	; 0x21
	rp->commands[33] |= BIT(4) | BIT(5);
 1007eb2:	f894 5022 	ldrb.w	r5, [r4, #34]	; 0x22
	rp->commands[22] |= BIT(2);
 1007eb6:	75e0      	strb	r0, [r4, #23]
	rp->commands[25] |= BIT(5) | BIT(6) | BIT(7);
 1007eb8:	76a1      	strb	r1, [r4, #26]
	rp->commands[35] |= BIT(0) | BIT(1) | BIT(2);
 1007eba:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
	rp->commands[39] |= BIT(2);
 1007ebe:	f894 1028 	ldrb.w	r1, [r4, #40]	; 0x28
	rp->commands[28] |= BIT(1) | BIT(2);
 1007ec2:	7762      	strb	r2, [r4, #29]
	rp->commands[38] |= BIT(7);
 1007ec4:	f894 2027 	ldrb.w	r2, [r4, #39]	; 0x27
	rp->commands[35] |= BIT(0) | BIT(1) | BIT(2);
 1007ec8:	f040 007f 	orr.w	r0, r0, #127	; 0x7f
	rp->commands[32] |= BIT(4) | BIT(5);
 1007ecc:	f046 0630 	orr.w	r6, r6, #48	; 0x30
	rp->commands[33] |= BIT(6) | BIT(7);
 1007ed0:	f065 050f 	orn	r5, r5, #15
	rp->commands[39] |= BIT(2);
 1007ed4:	f041 0104 	orr.w	r1, r1, #4
	rp->commands[38] |= BIT(7);
 1007ed8:	f062 027f 	orn	r2, r2, #127	; 0x7f
	rp->commands[35] |= BIT(0) | BIT(1) | BIT(2);
 1007edc:	f884 0024 	strb.w	r0, [r4, #36]	; 0x24
	rp->commands[32] |= BIT(4) | BIT(5);
 1007ee0:	f884 6021 	strb.w	r6, [r4, #33]	; 0x21
 1007ee4:	9809      	ldr	r0, [sp, #36]	; 0x24
	rp->commands[33] |= BIT(6) | BIT(7);
 1007ee6:	f884 5022 	strb.w	r5, [r4, #34]	; 0x22
	rp->commands[39] |= BIT(2);
 1007eea:	f884 1028 	strb.w	r1, [r4, #40]	; 0x28
	rp->commands[38] |= BIT(7);
 1007eee:	f884 2027 	strb.w	r2, [r4, #39]	; 0x27
	rp->commands[26] |= BIT(4) | BIT(5);
 1007ef2:	76e3      	strb	r3, [r4, #27]
	rp->commands[27] |= BIT(2) | BIT(4) | BIT(5);
 1007ef4:	7723      	strb	r3, [r4, #28]
	rp->commands[34] |= BIT(1) | BIT(2);
 1007ef6:	f884 3023 	strb.w	r3, [r4, #35]	; 0x23
}
 1007efa:	e713      	b.n	1007d24 <hci_cmd_handle+0x12c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007efc:	2109      	movs	r1, #9
 1007efe:	a809      	add	r0, sp, #36	; 0x24
 1007f00:	f7ff fd6e 	bl	10079e0 <hci_cmd_complete>
	rp->status = 0x00;
 1007f04:	2200      	movs	r2, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007f06:	4603      	mov	r3, r0
	rp->hci_version = LL_VERSION_NUMBER;
 1007f08:	200b      	movs	r0, #11
	rp->lmp_subversion = sys_cpu_to_le16(ll_settings_subversion_number());
 1007f0a:	f04f 31ff 	mov.w	r1, #4294967295
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
 1007f0e:	f06f 050e 	mvn.w	r5, #14
 1007f12:	2405      	movs	r4, #5
	rp->status = 0x00;
 1007f14:	701a      	strb	r2, [r3, #0]
	rp->hci_version = LL_VERSION_NUMBER;
 1007f16:	7058      	strb	r0, [r3, #1]
	rp->lmp_version = LL_VERSION_NUMBER;
 1007f18:	7118      	strb	r0, [r3, #4]
	rp->manufacturer = sys_cpu_to_le16(ll_settings_company_id());
 1007f1a:	715d      	strb	r5, [r3, #5]
 1007f1c:	9809      	ldr	r0, [sp, #36]	; 0x24
 1007f1e:	719c      	strb	r4, [r3, #6]
	rp->hci_revision = sys_cpu_to_le16(0);
 1007f20:	709a      	strb	r2, [r3, #2]
 1007f22:	70da      	strb	r2, [r3, #3]
	rp->lmp_subversion = sys_cpu_to_le16(ll_settings_subversion_number());
 1007f24:	71d9      	strb	r1, [r3, #7]
 1007f26:	7219      	strb	r1, [r3, #8]
	if (err == -EINVAL) {
 1007f28:	e6fc      	b.n	1007d24 <hci_cmd_handle+0x12c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007f2a:	2107      	movs	r1, #7
 1007f2c:	a809      	add	r0, sp, #36	; 0x24
 1007f2e:	f7ff fd57 	bl	10079e0 <hci_cmd_complete>
 1007f32:	4601      	mov	r1, r0
	rp->status = 0x00;
 1007f34:	2000      	movs	r0, #0
 1007f36:	f801 0b01 	strb.w	r0, [r1], #1
	ll_addr_get(0, &rp->bdaddr.val[0]);
 1007f3a:	f7ff f9bb 	bl	10072b4 <ll_addr_get>
 1007f3e:	9809      	ldr	r0, [sp, #36]	; 0x24
}
 1007f40:	e6f0      	b.n	1007d24 <hci_cmd_handle+0x12c>
	if (hci_hbuf_total <= 0) {
 1007f42:	4bbd      	ldr	r3, [pc, #756]	; (1008238 <hci_cmd_handle+0x640>)
 1007f44:	681b      	ldr	r3, [r3, #0]
 1007f46:	2b00      	cmp	r3, #0
 1007f48:	f340 830e 	ble.w	1008568 <hci_cmd_handle+0x970>
	} else if (!conn_count) {
 1007f4c:	4bbb      	ldr	r3, [pc, #748]	; (100823c <hci_cmd_handle+0x644>)
 1007f4e:	681b      	ldr	r3, [r3, #0]
 1007f50:	b30b      	cbz	r3, 1007f96 <hci_cmd_handle+0x39e>
		host_num_completed_packets(cmd, evt);
 1007f52:	68a7      	ldr	r7, [r4, #8]
	for (i = 0; i < cmd->num_handles; i++) {
 1007f54:	f897 c000 	ldrb.w	ip, [r7]
	u32_t count = 0U;
 1007f58:	4664      	mov	r4, ip
	for (i = 0; i < cmd->num_handles; i++) {
 1007f5a:	f1bc 0f00 	cmp.w	ip, #0
 1007f5e:	f000 8330 	beq.w	10085c2 <hci_cmd_handle+0x9ca>
	u32_t count = 0U;
 1007f62:	2400      	movs	r4, #0
		    (c > hci_hbuf_pend[h])) {
 1007f64:	4db6      	ldr	r5, [pc, #728]	; (1008240 <hci_cmd_handle+0x648>)
	for (i = 0; i < cmd->num_handles; i++) {
 1007f66:	4623      	mov	r3, r4
 1007f68:	e00a      	b.n	1007f80 <hci_cmd_handle+0x388>
		    (c > hci_hbuf_pend[h])) {
 1007f6a:	f835 0011 	ldrh.w	r0, [r5, r1, lsl #1]
		if ((h >= ARRAY_SIZE(hci_hbuf_pend)) ||
 1007f6e:	4282      	cmp	r2, r0
		hci_hbuf_pend[h] -= c;
 1007f70:	eba0 0602 	sub.w	r6, r0, r2
		if ((h >= ARRAY_SIZE(hci_hbuf_pend)) ||
 1007f74:	d80f      	bhi.n	1007f96 <hci_cmd_handle+0x39e>
	for (i = 0; i < cmd->num_handles; i++) {
 1007f76:	4563      	cmp	r3, ip
		hci_hbuf_pend[h] -= c;
 1007f78:	f825 6011 	strh.w	r6, [r5, r1, lsl #1]
	for (i = 0; i < cmd->num_handles; i++) {
 1007f7c:	f000 8321 	beq.w	10085c2 <hci_cmd_handle+0x9ca>
		hci_hbuf_pend[h] -= c;
 1007f80:	eb07 0283 	add.w	r2, r7, r3, lsl #2
		u16_t h = sys_le16_to_cpu(cmd->h[i].handle);
 1007f84:	f8b2 1001 	ldrh.w	r1, [r2, #1]
		u16_t c = sys_le16_to_cpu(cmd->h[i].count);
 1007f88:	f8b2 2003 	ldrh.w	r2, [r2, #3]
		if ((h >= ARRAY_SIZE(hci_hbuf_pend)) ||
 1007f8c:	290f      	cmp	r1, #15
	for (i = 0; i < cmd->num_handles; i++) {
 1007f8e:	f103 0301 	add.w	r3, r3, #1
		count += c;
 1007f92:	4414      	add	r4, r2
		if ((h >= ARRAY_SIZE(hci_hbuf_pend)) ||
 1007f94:	d9e9      	bls.n	1007f6a <hci_cmd_handle+0x372>
		ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1007f96:	2101      	movs	r1, #1
 1007f98:	a809      	add	r0, sp, #36	; 0x24
 1007f9a:	f7ff fd21 	bl	10079e0 <hci_cmd_complete>
		ccst->status = BT_HCI_ERR_INVALID_PARAM;
 1007f9e:	2312      	movs	r3, #18
 1007fa0:	7003      	strb	r3, [r0, #0]
		return;
 1007fa2:	9809      	ldr	r0, [sp, #36]	; 0x24
 1007fa4:	e6be      	b.n	1007d24 <hci_cmd_handle+0x12c>
		host_buffer_size(cmd, evt);
 1007fa6:	68a3      	ldr	r3, [r4, #8]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1007fa8:	2101      	movs	r1, #1
 1007faa:	a809      	add	r0, sp, #36	; 0x24
	u16_t acl_pkts = sys_le16_to_cpu(cmd->acl_pkts);
 1007fac:	f8b3 4003 	ldrh.w	r4, [r3, #3]
	u16_t acl_mtu = sys_le16_to_cpu(cmd->acl_mtu);
 1007fb0:	881d      	ldrh	r5, [r3, #0]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1007fb2:	f7ff fd15 	bl	10079e0 <hci_cmd_complete>
	if (hci_hbuf_total) {
 1007fb6:	4ba0      	ldr	r3, [pc, #640]	; (1008238 <hci_cmd_handle+0x640>)
 1007fb8:	681a      	ldr	r2, [r3, #0]
 1007fba:	2a00      	cmp	r2, #0
 1007fbc:	f040 82d8 	bne.w	1008570 <hci_cmd_handle+0x978>
	if (acl_mtu < LL_LENGTH_OCTETS_RX_MAX) {
 1007fc0:	2d1a      	cmp	r5, #26
 1007fc2:	d9ec      	bls.n	1007f9e <hci_cmd_handle+0x3a6>
	hci_hbuf_total = -acl_pkts;
 1007fc4:	4264      	negs	r4, r4
 1007fc6:	9809      	ldr	r0, [sp, #36]	; 0x24
 1007fc8:	601c      	str	r4, [r3, #0]
 1007fca:	e6ab      	b.n	1007d24 <hci_cmd_handle+0x12c>
		read_tx_power_level(cmd, evt);
 1007fcc:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007fce:	2104      	movs	r1, #4
 1007fd0:	a809      	add	r0, sp, #36	; 0x24
	handle = sys_le16_to_cpu(cmd->handle);
 1007fd2:	881d      	ldrh	r5, [r3, #0]
	type = cmd->type;
 1007fd4:	789e      	ldrb	r6, [r3, #2]
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007fd6:	f7ff fd03 	bl	10079e0 <hci_cmd_complete>
	status = ll_tx_pwr_lvl_get(BT_HCI_VS_LL_HANDLE_TYPE_CONN,
 1007fda:	4632      	mov	r2, r6
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1007fdc:	4604      	mov	r4, r0
	status = ll_tx_pwr_lvl_get(BT_HCI_VS_LL_HANDLE_TYPE_CONN,
 1007fde:	1cc3      	adds	r3, r0, #3
	handle = sys_le16_to_cpu(cmd->handle);
 1007fe0:	b2a9      	uxth	r1, r5
	status = ll_tx_pwr_lvl_get(BT_HCI_VS_LL_HANDLE_TYPE_CONN,
 1007fe2:	2002      	movs	r0, #2
 1007fe4:	f7ff f9a4 	bl	1007330 <ll_tx_pwr_lvl_get>
	rp->status = status;
 1007fe8:	7020      	strb	r0, [r4, #0]
	rp->handle = sys_cpu_to_le16(handle);
 1007fea:	9809      	ldr	r0, [sp, #36]	; 0x24
 1007fec:	f8a4 5001 	strh.w	r5, [r4, #1]
}
 1007ff0:	e698      	b.n	1007d24 <hci_cmd_handle+0x12c>
	u8_t flow_enable = cmd->flow_enable;
 1007ff2:	68a3      	ldr	r3, [r4, #8]
	if (!hci_hbuf_total || conn_count) {
 1007ff4:	4c90      	ldr	r4, [pc, #576]	; (1008238 <hci_cmd_handle+0x640>)
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1007ff6:	2101      	movs	r1, #1
 1007ff8:	a809      	add	r0, sp, #36	; 0x24
	u8_t flow_enable = cmd->flow_enable;
 1007ffa:	781d      	ldrb	r5, [r3, #0]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1007ffc:	f7ff fcf0 	bl	10079e0 <hci_cmd_complete>
	if (!hci_hbuf_total || conn_count) {
 1008000:	6823      	ldr	r3, [r4, #0]
 1008002:	2b00      	cmp	r3, #0
 1008004:	f000 82b4 	beq.w	1008570 <hci_cmd_handle+0x978>
 1008008:	4a8c      	ldr	r2, [pc, #560]	; (100823c <hci_cmd_handle+0x644>)
 100800a:	6812      	ldr	r2, [r2, #0]
 100800c:	2a00      	cmp	r2, #0
 100800e:	f040 82af 	bne.w	1008570 <hci_cmd_handle+0x978>
		ccst->status = 0x00;
 1008012:	7002      	strb	r2, [r0, #0]
	switch (flow_enable) {
 1008014:	2d00      	cmp	r5, #0
 1008016:	f000 82e5 	beq.w	10085e4 <hci_cmd_handle+0x9ec>
 100801a:	2d01      	cmp	r5, #1
 100801c:	d1bf      	bne.n	1007f9e <hci_cmd_handle+0x3a6>
		if (hci_hbuf_total > 0) {
 100801e:	2b00      	cmp	r3, #0
 1008020:	f73f ae99 	bgt.w	1007d56 <hci_cmd_handle+0x15e>
	hci_hbuf_sent = 0U;
 1008024:	2100      	movs	r1, #0
 1008026:	4887      	ldr	r0, [pc, #540]	; (1008244 <hci_cmd_handle+0x64c>)
	hci_hbuf_acked = 0U;
 1008028:	4b87      	ldr	r3, [pc, #540]	; (1008248 <hci_cmd_handle+0x650>)
	hci_hbuf_sent = 0U;
 100802a:	6001      	str	r1, [r0, #0]
	(void)memset(hci_hbuf_pend, 0, sizeof(hci_hbuf_pend));
 100802c:	2220      	movs	r2, #32
 100802e:	4884      	ldr	r0, [pc, #528]	; (1008240 <hci_cmd_handle+0x648>)
	hci_hbuf_acked = 0U;
 1008030:	6019      	str	r1, [r3, #0]
	(void)memset(hci_hbuf_pend, 0, sizeof(hci_hbuf_pend));
 1008032:	f00e fc6c 	bl	101690e <memset>
	hci_hbuf_total = -hci_hbuf_total;
 1008036:	6823      	ldr	r3, [r4, #0]
 1008038:	9809      	ldr	r0, [sp, #36]	; 0x24
 100803a:	425b      	negs	r3, r3
 100803c:	6023      	str	r3, [r4, #0]
 100803e:	e671      	b.n	1007d24 <hci_cmd_handle+0x12c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1008040:	2102      	movs	r1, #2
 1008042:	a809      	add	r0, sp, #36	; 0x24
 1008044:	f7ff fccc 	bl	10079e0 <hci_cmd_complete>
 1008048:	4604      	mov	r4, r0
	rp->rl_size = ll_rl_size_get();
 100804a:	f006 fe2f 	bl	100ecac <ll_rl_size_get>
	rp->status = 0x00;
 100804e:	2300      	movs	r3, #0
	rp->rl_size = ll_rl_size_get();
 1008050:	7060      	strb	r0, [r4, #1]
	rp->status = 0x00;
 1008052:	7023      	strb	r3, [r4, #0]
	if (err == -EINVAL) {
 1008054:	9809      	ldr	r0, [sp, #36]	; 0x24
 1008056:	e665      	b.n	1007d24 <hci_cmd_handle+0x12c>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1008058:	2101      	movs	r1, #1
 100805a:	a809      	add	r0, sp, #36	; 0x24
 100805c:	f7ff fcc0 	bl	10079e0 <hci_cmd_complete>
 1008060:	4604      	mov	r4, r0
	ccst->status = ll_rl_clear();
 1008062:	f006 fe25 	bl	100ecb0 <ll_rl_clear>
 1008066:	7020      	strb	r0, [r4, #0]
	if (err == -EINVAL) {
 1008068:	9809      	ldr	r0, [sp, #36]	; 0x24
 100806a:	e65b      	b.n	1007d24 <hci_cmd_handle+0x12c>
	status = ll_rl_remove(&cmd->peer_id_addr);
 100806c:	68a0      	ldr	r0, [r4, #8]
 100806e:	f007 f9f1 	bl	100f454 <ll_rl_remove>
	status = ll_phy_default_set(cmd->tx_phys, cmd->rx_phys);
 1008072:	4604      	mov	r4, r0
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1008074:	2101      	movs	r1, #1
 1008076:	a809      	add	r0, sp, #36	; 0x24
 1008078:	f7ff fcb2 	bl	10079e0 <hci_cmd_complete>
	ccst->status = status;
 100807c:	7004      	strb	r4, [r0, #0]
 100807e:	e66a      	b.n	1007d56 <hci_cmd_handle+0x15e>
		le_add_dev_to_rl(cmd, evt);
 1008080:	68a0      	ldr	r0, [r4, #8]
	status = ll_rl_add(&cmd->peer_id_addr, cmd->peer_irk, cmd->local_irk);
 1008082:	f100 0217 	add.w	r2, r0, #23
 1008086:	1dc1      	adds	r1, r0, #7
 1008088:	f007 f92e 	bl	100f2e8 <ll_rl_add>
 100808c:	e7f1      	b.n	1008072 <hci_cmd_handle+0x47a>
		le_write_default_data_len(cmd, evt);
 100808e:	68a3      	ldr	r3, [r4, #8]
	status = ll_length_default_set(max_tx_octets, max_tx_time);
 1008090:	8859      	ldrh	r1, [r3, #2]
 1008092:	8818      	ldrh	r0, [r3, #0]
 1008094:	f003 fc4a 	bl	100b92c <ll_length_default_set>
 1008098:	e7eb      	b.n	1008072 <hci_cmd_handle+0x47a>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 100809a:	2105      	movs	r1, #5
 100809c:	a809      	add	r0, sp, #36	; 0x24
 100809e:	f7ff fc9f 	bl	10079e0 <hci_cmd_complete>
 10080a2:	4604      	mov	r4, r0
	ll_length_default_get(&max_tx_octets, &max_tx_time);
 10080a4:	a90a      	add	r1, sp, #40	; 0x28
 10080a6:	f10d 0022 	add.w	r0, sp, #34	; 0x22
 10080aa:	f003 fc33 	bl	100b914 <ll_length_default_get>
	rp->status = 0x00;
 10080ae:	2200      	movs	r2, #0
	rp->max_tx_octets = sys_cpu_to_le16(max_tx_octets);
 10080b0:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
 10080b4:	f8a4 3001 	strh.w	r3, [r4, #1]
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
 10080b8:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
	rp->status = 0x00;
 10080bc:	7022      	strb	r2, [r4, #0]
 10080be:	9809      	ldr	r0, [sp, #36]	; 0x24
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
 10080c0:	f8a4 3003 	strh.w	r3, [r4, #3]
	if (err == -EINVAL) {
 10080c4:	e62e      	b.n	1007d24 <hci_cmd_handle+0x12c>
		le_set_data_len(cmd, evt);
 10080c6:	68a3      	ldr	r3, [r4, #8]
	handle = sys_le16_to_cpu(cmd->handle);
 10080c8:	881d      	ldrh	r5, [r3, #0]
	status = ll_length_req_send(handle, tx_octets, tx_time);
 10080ca:	889a      	ldrh	r2, [r3, #4]
 10080cc:	8859      	ldrh	r1, [r3, #2]
 10080ce:	b2a8      	uxth	r0, r5
 10080d0:	f003 fbd4 	bl	100b87c <ll_length_req_send>
 10080d4:	e690      	b.n	1007df8 <hci_cmd_handle+0x200>
		le_set_adv_param(cmd, evt);
 10080d6:	68a4      	ldr	r4, [r4, #8]
	    (cmd->type != BT_HCI_ADV_DIRECT_IND)) {
 10080d8:	7921      	ldrb	r1, [r4, #4]
	min_interval = sys_le16_to_cpu(cmd->min_interval);
 10080da:	8820      	ldrh	r0, [r4, #0]
	if (IS_ENABLED(CONFIG_BT_CTLR_PARAM_CHECK) &&
 10080dc:	2901      	cmp	r1, #1
 10080de:	d00a      	beq.n	10080f6 <hci_cmd_handle+0x4fe>
		u16_t max_interval = sys_le16_to_cpu(cmd->max_interval);
 10080e0:	8863      	ldrh	r3, [r4, #2]
		if ((min_interval > max_interval) ||
 10080e2:	4298      	cmp	r0, r3
 10080e4:	f63f af57 	bhi.w	1007f96 <hci_cmd_handle+0x39e>
 10080e8:	281f      	cmp	r0, #31
 10080ea:	f67f af54 	bls.w	1007f96 <hci_cmd_handle+0x39e>
		    (min_interval < 0x0020) ||
 10080ee:	f5b3 4f80 	cmp.w	r3, #16384	; 0x4000
 10080f2:	f63f af50 	bhi.w	1007f96 <hci_cmd_handle+0x39e>
	status = ll_adv_params_set(min_interval, cmd->type,
 10080f6:	7ba5      	ldrb	r5, [r4, #14]
 10080f8:	79a3      	ldrb	r3, [r4, #6]
 10080fa:	7962      	ldrb	r2, [r4, #5]
 10080fc:	9502      	str	r5, [sp, #8]
 10080fe:	7b65      	ldrb	r5, [r4, #13]
				   &cmd->direct_addr.a.val[0], cmd->channel_map,
 1008100:	3407      	adds	r4, #7
	status = ll_adv_params_set(min_interval, cmd->type,
 1008102:	e9cd 4500 	strd	r4, r5, [sp]
 1008106:	f002 fb67 	bl	100a7d8 <ll_adv_params_set>
 100810a:	e7b2      	b.n	1008072 <hci_cmd_handle+0x47a>
	status = ll_addr_set(1, &cmd->bdaddr.val[0]);
 100810c:	68a1      	ldr	r1, [r4, #8]
 100810e:	2001      	movs	r0, #1
 1008110:	f7ff f8ee 	bl	10072f0 <ll_addr_set>
 1008114:	e7ad      	b.n	1008072 <hci_cmd_handle+0x47a>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1008116:	2109      	movs	r1, #9
 1008118:	a809      	add	r0, sp, #36	; 0x24
 100811a:	f7ff fc61 	bl	10079e0 <hci_cmd_complete>
	rp->status = 0x00;
 100811e:	2100      	movs	r1, #0
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1008120:	4604      	mov	r4, r0
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
 1008122:	2208      	movs	r2, #8
	rp->status = 0x00;
 1008124:	f800 1b01 	strb.w	r1, [r0], #1
	(void)memset(&rp->features[0], 0x00, sizeof(rp->features));
 1008128:	f00e fbf1 	bl	101690e <memset>
	dst[0] = val;
 100812c:	21ff      	movs	r1, #255	; 0xff
	dst[1] = val >> 8;
 100812e:	2249      	movs	r2, #73	; 0x49
	dst[2] = val >> 16;
 1008130:	2301      	movs	r3, #1
	dst[0] = val;
 1008132:	7061      	strb	r1, [r4, #1]
	dst[1] = val >> 8;
 1008134:	70a2      	strb	r2, [r4, #2]
	dst[2] = val >> 16;
 1008136:	70e3      	strb	r3, [r4, #3]
	if (err == -EINVAL) {
 1008138:	e60d      	b.n	1007d56 <hci_cmd_handle+0x15e>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 100813a:	2104      	movs	r1, #4
 100813c:	a809      	add	r0, sp, #36	; 0x24
 100813e:	f7ff fc4f 	bl	10079e0 <hci_cmd_complete>
	rp->status = 0x00;
 1008142:	2300      	movs	r3, #0
	rp->le_max_num = CONFIG_BT_CTLR_TX_BUFFERS;
 1008144:	2107      	movs	r1, #7
	rp->le_max_len = sys_cpu_to_le16(CONFIG_BT_CTLR_TX_BUFFER_SIZE);
 1008146:	221b      	movs	r2, #27
	rp->le_max_num = CONFIG_BT_CTLR_TX_BUFFERS;
 1008148:	70c1      	strb	r1, [r0, #3]
	rp->status = 0x00;
 100814a:	7003      	strb	r3, [r0, #0]
	rp->le_max_len = sys_cpu_to_le16(CONFIG_BT_CTLR_TX_BUFFER_SIZE);
 100814c:	7042      	strb	r2, [r0, #1]
 100814e:	7083      	strb	r3, [r0, #2]
	if (err == -EINVAL) {
 1008150:	9809      	ldr	r0, [sp, #36]	; 0x24
 1008152:	e5e7      	b.n	1007d24 <hci_cmd_handle+0x12c>
		le_create_connection(cmd, evt);
 1008154:	68a4      	ldr	r4, [r4, #8]
	status = ll_create_connection(scan_interval, scan_window,
 1008156:	f8b4 6013 	ldrh.w	r6, [r4, #19]
 100815a:	8861      	ldrh	r1, [r4, #2]
 100815c:	7963      	ldrb	r3, [r4, #5]
 100815e:	7922      	ldrb	r2, [r4, #4]
 1008160:	8820      	ldrh	r0, [r4, #0]
 1008162:	9604      	str	r6, [sp, #16]
 1008164:	f8b4 6011 	ldrh.w	r6, [r4, #17]
 1008168:	3406      	adds	r4, #6
 100816a:	9603      	str	r6, [sp, #12]
 100816c:	f8b4 6009 	ldrh.w	r6, [r4, #9]
 1008170:	9602      	str	r6, [sp, #8]
 1008172:	79a6      	ldrb	r6, [r4, #6]
 1008174:	e9cd 4600 	strd	r4, r6, [sp]
 1008178:	f006 f848 	bl	100e20c <ll_create_connection>
 100817c:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
 100817e:	8828      	ldrh	r0, [r5, #0]
 1008180:	f7ff fc1a 	bl	10079b8 <bt_hci_cmd_status_create>
	if (err == -EINVAL) {
 1008184:	e5ce      	b.n	1007d24 <hci_cmd_handle+0x12c>
		le_set_scan_enable(cmd, evt);
 1008186:	68a3      	ldr	r3, [r4, #8]
	if (cmd->enable && cmd->filter_dup) {
 1008188:	7818      	ldrb	r0, [r3, #0]
 100818a:	2800      	cmp	r0, #0
 100818c:	f000 8225 	beq.w	10085da <hci_cmd_handle+0x9e2>
 1008190:	785b      	ldrb	r3, [r3, #1]
 1008192:	2b00      	cmp	r3, #0
 1008194:	f000 8221 	beq.w	10085da <hci_cmd_handle+0x9e2>
		dup_count = 0;
 1008198:	2300      	movs	r3, #0
 100819a:	492c      	ldr	r1, [pc, #176]	; (100824c <hci_cmd_handle+0x654>)
		dup_curr = 0U;
 100819c:	4a2c      	ldr	r2, [pc, #176]	; (1008250 <hci_cmd_handle+0x658>)
		dup_count = 0;
 100819e:	600b      	str	r3, [r1, #0]
		dup_curr = 0U;
 10081a0:	6013      	str	r3, [r2, #0]
	status = ll_scan_enable(cmd->enable);
 10081a2:	f002 fdb5 	bl	100ad10 <ll_scan_enable>
 10081a6:	e764      	b.n	1008072 <hci_cmd_handle+0x47a>
		le_set_scan_param(cmd, evt);
 10081a8:	68a4      	ldr	r4, [r4, #8]
	status = ll_scan_params_set(cmd->scan_type, interval, window,
 10081aa:	7963      	ldrb	r3, [r4, #5]
 10081ac:	f8b4 2003 	ldrh.w	r2, [r4, #3]
 10081b0:	f8b4 1001 	ldrh.w	r1, [r4, #1]
 10081b4:	7820      	ldrb	r0, [r4, #0]
 10081b6:	79a4      	ldrb	r4, [r4, #6]
 10081b8:	9400      	str	r4, [sp, #0]
 10081ba:	f7f8 fbe5 	bl	1000988 <ll_scan_params_set>
 10081be:	e758      	b.n	1008072 <hci_cmd_handle+0x47a>
		le_set_phy(cmd, evt);
 10081c0:	68a2      	ldr	r2, [r4, #8]
	if (cmd->all_phys & BT_HCI_LE_PHY_TX_ANY) {
 10081c2:	7893      	ldrb	r3, [r2, #2]
		cmd->tx_phys |= mask_phys;
 10081c4:	78d1      	ldrb	r1, [r2, #3]
	if (cmd->all_phys & BT_HCI_LE_PHY_TX_ANY) {
 10081c6:	07df      	lsls	r7, r3, #31
		cmd->tx_phys |= mask_phys;
 10081c8:	bf44      	itt	mi
 10081ca:	f041 0107 	orrmi.w	r1, r1, #7
 10081ce:	70d1      	strbmi	r1, [r2, #3]
	if (cmd->all_phys & BT_HCI_LE_PHY_RX_ANY) {
 10081d0:	f013 0f02 	tst.w	r3, #2
		cmd->rx_phys |= mask_phys;
 10081d4:	7913      	ldrb	r3, [r2, #4]
	handle = sys_le16_to_cpu(cmd->handle);
 10081d6:	8816      	ldrh	r6, [r2, #0]
		cmd->rx_phys |= mask_phys;
 10081d8:	bf1c      	itt	ne
 10081da:	f043 0307 	orrne.w	r3, r3, #7
 10081de:	7113      	strbne	r3, [r2, #4]
	phy_opts = sys_le16_to_cpu(cmd->phy_opts);
 10081e0:	f8b2 4005 	ldrh.w	r4, [r2, #5]
	if ((cmd->tx_phys | cmd->rx_phys) & ~mask_phys) {
 10081e4:	ea43 0201 	orr.w	r2, r3, r1
 10081e8:	f012 0ff8 	tst.w	r2, #248	; 0xf8
 10081ec:	f040 8204 	bne.w	10085f8 <hci_cmd_handle+0xa00>
	if (!(cmd->tx_phys & 0x07) ||
 10081f0:	074f      	lsls	r7, r1, #29
 10081f2:	f000 81fc 	beq.w	10085ee <hci_cmd_handle+0x9f6>
 10081f6:	075a      	lsls	r2, r3, #29
 10081f8:	f000 81f9 	beq.w	10085ee <hci_cmd_handle+0x9f6>
	if (phy_opts & 0x03) {
 10081fc:	f014 0203 	ands.w	r2, r4, #3
		phy_opts -= 1U;
 1008200:	bf18      	it	ne
 1008202:	f104 34ff 	addne.w	r4, r4, #4294967295
	status = ll_phy_req_send(handle, cmd->tx_phys, phy_opts,
 1008206:	4630      	mov	r0, r6
		phy_opts &= 1;
 1008208:	bf18      	it	ne
 100820a:	f004 0201 	andne.w	r2, r4, #1
	status = ll_phy_req_send(handle, cmd->tx_phys, phy_opts,
 100820e:	f003 fbcd 	bl	100b9ac <ll_phy_req_send>
 1008212:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
 1008214:	8828      	ldrh	r0, [r5, #0]
 1008216:	f7ff fbcf 	bl	10079b8 <bt_hci_cmd_status_create>
 100821a:	e583      	b.n	1007d24 <hci_cmd_handle+0x12c>
	return ((u64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
 100821c:	68a2      	ldr	r2, [r4, #8]
	le_event_mask = sys_get_le64(cmd->events);
 100821e:	4b0d      	ldr	r3, [pc, #52]	; (1008254 <hci_cmd_handle+0x65c>)
 1008220:	6814      	ldr	r4, [r2, #0]
 1008222:	6852      	ldr	r2, [r2, #4]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1008224:	2101      	movs	r1, #1
	le_event_mask = sys_get_le64(cmd->events);
 1008226:	e9c3 4200 	strd	r4, r2, [r3]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 100822a:	a809      	add	r0, sp, #36	; 0x24
 100822c:	f7ff fbd8 	bl	10079e0 <hci_cmd_complete>
	ccst->status = 0x00;
 1008230:	2300      	movs	r3, #0
 1008232:	7003      	strb	r3, [r0, #0]
	if (err == -EINVAL) {
 1008234:	e58f      	b.n	1007d56 <hci_cmd_handle+0x15e>
 1008236:	bf00      	nop
 1008238:	21000d2c 	.word	0x21000d2c
 100823c:	21000c74 	.word	0x21000c74
 1008240:	21000d08 	.word	0x21000d08
 1008244:	21000d28 	.word	0x21000d28
 1008248:	21000d04 	.word	0x21000d04
 100824c:	21000c78 	.word	0x21000c78
 1008250:	21000c7c 	.word	0x21000c7c
 1008254:	21000008 	.word	0x21000008
	status = ll_connect_disable(node_rx);
 1008258:	4630      	mov	r0, r6
 100825a:	f006 faed 	bl	100e838 <ll_connect_disable>
 100825e:	e708      	b.n	1008072 <hci_cmd_handle+0x47a>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1008260:	2103      	movs	r1, #3
 1008262:	a809      	add	r0, sp, #36	; 0x24
 1008264:	f7ff fbbc 	bl	10079e0 <hci_cmd_complete>
	rp->status = 0x00;
 1008268:	2300      	movs	r3, #0
 100826a:	4601      	mov	r1, r0
	ll_tx_pwr_get(&rp->min_tx_power, &rp->max_tx_power);
 100826c:	3001      	adds	r0, #1
	rp->status = 0x00;
 100826e:	f801 3b02 	strb.w	r3, [r1], #2
	ll_tx_pwr_get(&rp->min_tx_power, &rp->max_tx_power);
 1008272:	f7ff f86d 	bl	1007350 <ll_tx_pwr_get>
	if (err == -EINVAL) {
 1008276:	e56e      	b.n	1007d56 <hci_cmd_handle+0x15e>
	handle = sys_le16_to_cpu(cmd->handle);
 1008278:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
 100827a:	2108      	movs	r1, #8
 100827c:	a809      	add	r0, sp, #36	; 0x24
	handle = sys_le16_to_cpu(cmd->handle);
 100827e:	881d      	ldrh	r5, [r3, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1008280:	f7ff fbae 	bl	10079e0 <hci_cmd_complete>
 1008284:	4604      	mov	r4, r0
	handle = sys_le16_to_cpu(cmd->handle);
 1008286:	b2a8      	uxth	r0, r5
	status = ll_chm_get(handle, rp->ch_map);
 1008288:	1ce1      	adds	r1, r4, #3
 100828a:	f003 fa75 	bl	100b778 <ll_chm_get>
	rp->status = status;
 100828e:	7020      	strb	r0, [r4, #0]
	rp->handle = sys_le16_to_cpu(handle);
 1008290:	9809      	ldr	r0, [sp, #36]	; 0x24
 1008292:	f8a4 5001 	strh.w	r5, [r4, #1]
	if (err == -EINVAL) {
 1008296:	e545      	b.n	1007d24 <hci_cmd_handle+0x12c>
	status = ll_chm_update(&cmd->ch_map[0]);
 1008298:	68a0      	ldr	r0, [r4, #8]
 100829a:	f006 fb09 	bl	100e8b0 <ll_chm_update>
 100829e:	e6e8      	b.n	1008072 <hci_cmd_handle+0x47a>
	status = ll_conn_update(handle, 0, 0, conn_interval_min,
 10082a0:	2200      	movs	r2, #0
		le_conn_update(cmd, evt);
 10082a2:	68a1      	ldr	r1, [r4, #8]
	status = ll_conn_update(handle, 0, 0, conn_interval_min,
 10082a4:	890c      	ldrh	r4, [r1, #8]
 10082a6:	884b      	ldrh	r3, [r1, #2]
 10082a8:	8808      	ldrh	r0, [r1, #0]
 10082aa:	9402      	str	r4, [sp, #8]
 10082ac:	88cc      	ldrh	r4, [r1, #6]
 10082ae:	9401      	str	r4, [sp, #4]
 10082b0:	8889      	ldrh	r1, [r1, #4]
 10082b2:	9100      	str	r1, [sp, #0]
 10082b4:	4611      	mov	r1, r2
 10082b6:	f003 f9d7 	bl	100b668 <ll_conn_update>
 10082ba:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
 10082bc:	8828      	ldrh	r0, [r5, #0]
 10082be:	f7ff fb7b 	bl	10079b8 <bt_hci_cmd_status_create>
	if (err == -EINVAL) {
 10082c2:	e52f      	b.n	1007d24 <hci_cmd_handle+0x12c>
		le_set_privacy_mode(cmd, evt);
 10082c4:	68a0      	ldr	r0, [r4, #8]
	status = ll_priv_mode_set(&cmd->id_addr, cmd->mode);
 10082c6:	79c1      	ldrb	r1, [r0, #7]
 10082c8:	f007 f9a8 	bl	100f61c <ll_priv_mode_set>
 10082cc:	e6d1      	b.n	1008072 <hci_cmd_handle+0x47a>
		le_conn_param_req_reply(cmd, evt);
 10082ce:	68a1      	ldr	r1, [r4, #8]
	status = ll_conn_update(handle, 2, 0, interval_min, interval_max,
 10082d0:	2200      	movs	r2, #0
 10082d2:	8908      	ldrh	r0, [r1, #8]
	handle = sys_le16_to_cpu(cmd->handle);
 10082d4:	880d      	ldrh	r5, [r1, #0]
	status = ll_conn_update(handle, 2, 0, interval_min, interval_max,
 10082d6:	884b      	ldrh	r3, [r1, #2]
 10082d8:	9002      	str	r0, [sp, #8]
 10082da:	88c8      	ldrh	r0, [r1, #6]
 10082dc:	9001      	str	r0, [sp, #4]
 10082de:	8889      	ldrh	r1, [r1, #4]
 10082e0:	b2a8      	uxth	r0, r5
 10082e2:	9100      	str	r1, [sp, #0]
 10082e4:	2102      	movs	r1, #2
 10082e6:	f003 f9bf 	bl	100b668 <ll_conn_update>
 10082ea:	e585      	b.n	1007df8 <hci_cmd_handle+0x200>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 10082ec:	2109      	movs	r1, #9
 10082ee:	a809      	add	r0, sp, #36	; 0x24
 10082f0:	f7ff fb76 	bl	10079e0 <hci_cmd_complete>
	dst[0] = val;
 10082f4:	243f      	movs	r4, #63	; 0x3f
 10082f6:	23ff      	movs	r3, #255	; 0xff
	rp->status = 0x00;
 10082f8:	2200      	movs	r2, #0
	dst[1] = val >> 8;
 10082fa:	2103      	movs	r1, #3
	dst[0] = val;
 10082fc:	70c4      	strb	r4, [r0, #3]
 10082fe:	7002      	strb	r2, [r0, #0]
 1008300:	7043      	strb	r3, [r0, #1]
	dst[1] = val >> 8;
 1008302:	7083      	strb	r3, [r0, #2]
 1008304:	7181      	strb	r1, [r0, #6]
	dst[0] = val;
 1008306:	71c2      	strb	r2, [r0, #7]
	dst[1] = val >> 8;
 1008308:	7202      	strb	r2, [r0, #8]
 100830a:	7103      	strb	r3, [r0, #4]
	dst[0] = val;
 100830c:	7143      	strb	r3, [r0, #5]
	if (err == -EINVAL) {
 100830e:	9809      	ldr	r0, [sp, #36]	; 0x24
 1008310:	e508      	b.n	1007d24 <hci_cmd_handle+0x12c>
	status = ll_start_enc_req_send(handle, BT_HCI_ERR_PIN_OR_KEY_MISSING,
 1008312:	2200      	movs	r2, #0
 1008314:	2106      	movs	r1, #6
	handle = sys_le16_to_cpu(cmd->handle);
 1008316:	68a3      	ldr	r3, [r4, #8]
 1008318:	881d      	ldrh	r5, [r3, #0]
	status = ll_start_enc_req_send(handle, 0x00, &cmd->ltk[0]);
 100831a:	b2a8      	uxth	r0, r5
 100831c:	f005 fedc 	bl	100e0d8 <ll_start_enc_req_send>
 1008320:	e56a      	b.n	1007df8 <hci_cmd_handle+0x200>
	handle = sys_le16_to_cpu(cmd->handle);
 1008322:	68a2      	ldr	r2, [r4, #8]
	status = ll_start_enc_req_send(handle, 0x00, &cmd->ltk[0]);
 1008324:	2100      	movs	r1, #0
	handle = sys_le16_to_cpu(cmd->handle);
 1008326:	f832 5b02 	ldrh.w	r5, [r2], #2
 100832a:	e7f6      	b.n	100831a <hci_cmd_handle+0x722>
		le_start_encryption(cmd, evt);
 100832c:	68a2      	ldr	r2, [r4, #8]
				 (u8_t *)&cmd->rand,
 100832e:	4611      	mov	r1, r2
	status = ll_enc_req_send(handle,
 1008330:	f102 030c 	add.w	r3, r2, #12
 1008334:	f831 0b02 	ldrh.w	r0, [r1], #2
 1008338:	320a      	adds	r2, #10
 100833a:	f006 fae9 	bl	100e910 <ll_enc_req_send>
 100833e:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
 1008340:	8828      	ldrh	r0, [r5, #0]
 1008342:	f7ff fb39 	bl	10079b8 <bt_hci_cmd_status_create>
	if (err == -EINVAL) {
 1008346:	e4ed      	b.n	1007d24 <hci_cmd_handle+0x12c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1008348:	2109      	movs	r1, #9
 100834a:	a809      	add	r0, sp, #36	; 0x24
 100834c:	f7ff fb48 	bl	10079e0 <hci_cmd_complete>
	rp->status = 0x00;
 1008350:	2300      	movs	r3, #0
	lll_trng_get(rp->rand, count);
 1008352:	2108      	movs	r1, #8
	rp->status = 0x00;
 1008354:	f800 3b01 	strb.w	r3, [r0], #1
	lll_trng_get(rp->rand, count);
 1008358:	f007 fcfc 	bl	100fd54 <lll_trng_get>
	if (err == -EINVAL) {
 100835c:	9809      	ldr	r0, [sp, #36]	; 0x24
 100835e:	e4e1      	b.n	1007d24 <hci_cmd_handle+0x12c>
		le_encrypt(cmd, evt);
 1008360:	68a0      	ldr	r0, [r4, #8]
	ecb_encrypt(cmd->key, cmd->plaintext, enc_data, NULL);
 1008362:	2300      	movs	r3, #0
 1008364:	f100 0110 	add.w	r1, r0, #16
 1008368:	aa0a      	add	r2, sp, #40	; 0x28
 100836a:	f009 fb29 	bl	10119c0 <ecb_encrypt>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 100836e:	2111      	movs	r1, #17
 1008370:	a809      	add	r0, sp, #36	; 0x24
 1008372:	f7ff fb35 	bl	10079e0 <hci_cmd_complete>
	rp->status = 0x00;
 1008376:	2300      	movs	r3, #0
	memcpy(rp->enc_data, enc_data, 16);
 1008378:	2210      	movs	r2, #16
	rp->status = 0x00;
 100837a:	f800 3b01 	strb.w	r3, [r0], #1
	memcpy(rp->enc_data, enc_data, 16);
 100837e:	a90a      	add	r1, sp, #40	; 0x28
 1008380:	f00e fa9a 	bl	10168b8 <memcpy>
	if (err == -EINVAL) {
 1008384:	9809      	ldr	r0, [sp, #36]	; 0x24
 1008386:	e4cd      	b.n	1007d24 <hci_cmd_handle+0x12c>
	handle = sys_le16_to_cpu(cmd->handle);
 1008388:	68a3      	ldr	r3, [r4, #8]
	status = ll_feature_req_send(handle);
 100838a:	8818      	ldrh	r0, [r3, #0]
 100838c:	f003 fa36 	bl	100b7fc <ll_feature_req_send>
 1008390:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
 1008392:	8828      	ldrh	r0, [r5, #0]
 1008394:	f7ff fb10 	bl	10079b8 <bt_hci_cmd_status_create>
	if (err == -EINVAL) {
 1008398:	e4c4      	b.n	1007d24 <hci_cmd_handle+0x12c>
		le_set_default_phy(cmd, evt);
 100839a:	68a3      	ldr	r3, [r4, #8]
	if (cmd->all_phys & BT_HCI_LE_PHY_TX_ANY) {
 100839c:	781a      	ldrb	r2, [r3, #0]
 100839e:	07d1      	lsls	r1, r2, #31
		cmd->tx_phys = 0x07;
 10083a0:	bf49      	itett	mi
 10083a2:	2107      	movmi	r1, #7
 10083a4:	7858      	ldrbpl	r0, [r3, #1]
 10083a6:	4608      	movmi	r0, r1
 10083a8:	7059      	strbmi	r1, [r3, #1]
	if (cmd->all_phys & BT_HCI_LE_PHY_RX_ANY) {
 10083aa:	0792      	lsls	r2, r2, #30
		cmd->rx_phys = 0x07;
 10083ac:	bf49      	itett	mi
 10083ae:	2207      	movmi	r2, #7
 10083b0:	7899      	ldrbpl	r1, [r3, #2]
 10083b2:	4611      	movmi	r1, r2
 10083b4:	709a      	strbmi	r2, [r3, #2]
	status = ll_phy_default_set(cmd->tx_phys, cmd->rx_phys);
 10083b6:	f003 faef 	bl	100b998 <ll_phy_default_set>
 10083ba:	e65a      	b.n	1008072 <hci_cmd_handle+0x47a>
	handle = sys_le16_to_cpu(cmd->handle);
 10083bc:	68a3      	ldr	r3, [r4, #8]
	rp = hci_cmd_complete(evt, sizeof(*rp));
 10083be:	2105      	movs	r1, #5
 10083c0:	a809      	add	r0, sp, #36	; 0x24
	handle = sys_le16_to_cpu(cmd->handle);
 10083c2:	881d      	ldrh	r5, [r3, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
 10083c4:	f7ff fb0c 	bl	10079e0 <hci_cmd_complete>
 10083c8:	4604      	mov	r4, r0
	handle = sys_le16_to_cpu(cmd->handle);
 10083ca:	b2a8      	uxth	r0, r5
	status = ll_phy_get(handle, &rp->tx_phy, &rp->rx_phy);
 10083cc:	1d22      	adds	r2, r4, #4
 10083ce:	1ce1      	adds	r1, r4, #3
 10083d0:	f003 fac0 	bl	100b954 <ll_phy_get>
 * @return least significant bit set, 0 if @a op is 0
 */

static ALWAYS_INLINE unsigned int find_lsb_set(u32_t op)
{
	return __builtin_ffs(op);
 10083d4:	78e6      	ldrb	r6, [r4, #3]
 10083d6:	7921      	ldrb	r1, [r4, #4]
 10083d8:	fa96 f2a6 	rbit	r2, r6
 10083dc:	fa91 f3a1 	rbit	r3, r1
 10083e0:	2e00      	cmp	r6, #0
 10083e2:	fab2 f282 	clz	r2, r2
 10083e6:	bf08      	it	eq
 10083e8:	f04f 32ff 	moveq.w	r2, #4294967295
 10083ec:	2900      	cmp	r1, #0
 10083ee:	fab3 f383 	clz	r3, r3
 10083f2:	bf08      	it	eq
 10083f4:	f04f 33ff 	moveq.w	r3, #4294967295
 10083f8:	3201      	adds	r2, #1
	rp->status = status;
 10083fa:	7020      	strb	r0, [r4, #0]
	rp->tx_phy = find_lsb_set(rp->tx_phy);
 10083fc:	70e2      	strb	r2, [r4, #3]
 10083fe:	3301      	adds	r3, #1
 1008400:	9809      	ldr	r0, [sp, #36]	; 0x24
	rp->handle = sys_cpu_to_le16(handle);
 1008402:	f8a4 5001 	strh.w	r5, [r4, #1]
	rp->rx_phy = find_lsb_set(rp->rx_phy);
 1008406:	7123      	strb	r3, [r4, #4]
	if (err == -EINVAL) {
 1008408:	e48c      	b.n	1007d24 <hci_cmd_handle+0x12c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 100840a:	2109      	movs	r1, #9
 100840c:	a809      	add	r0, sp, #36	; 0x24
 100840e:	f7ff fae7 	bl	10079e0 <hci_cmd_complete>
 1008412:	4604      	mov	r4, r0
	ll_length_max_get(&max_tx_octets, &max_tx_time,
 1008414:	ab0a      	add	r3, sp, #40	; 0x28
 1008416:	f10d 0222 	add.w	r2, sp, #34	; 0x22
 100841a:	a908      	add	r1, sp, #32
 100841c:	f10d 001e 	add.w	r0, sp, #30
 1008420:	f003 fa8e 	bl	100b940 <ll_length_max_get>
	rp->status = 0x00;
 1008424:	2200      	movs	r2, #0
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
 1008426:	f8bd 3020 	ldrh.w	r3, [sp, #32]
	rp->max_tx_octets = sys_cpu_to_le16(max_tx_octets);
 100842a:	f8bd 101e 	ldrh.w	r1, [sp, #30]
	rp->max_tx_time = sys_cpu_to_le16(max_tx_time);
 100842e:	f8a4 3003 	strh.w	r3, [r4, #3]
	rp->max_tx_octets = sys_cpu_to_le16(max_tx_octets);
 1008432:	f8a4 1001 	strh.w	r1, [r4, #1]
	rp->max_rx_octets = sys_cpu_to_le16(max_rx_octets);
 1008436:	f8bd 3022 	ldrh.w	r3, [sp, #34]	; 0x22
 100843a:	f8a4 3005 	strh.w	r3, [r4, #5]
	rp->max_rx_time = sys_cpu_to_le16(max_rx_time);
 100843e:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
	rp->status = 0x00;
 1008442:	7022      	strb	r2, [r4, #0]
 1008444:	9809      	ldr	r0, [sp, #36]	; 0x24
	rp->max_rx_time = sys_cpu_to_le16(max_rx_time);
 1008446:	f8a4 3007 	strh.w	r3, [r4, #7]
	if (err == -EINVAL) {
 100844a:	e46b      	b.n	1007d24 <hci_cmd_handle+0x12c>
	u16_t timeout = sys_le16_to_cpu(cmd->rpa_timeout);
 100844c:	68a3      	ldr	r3, [r4, #8]
	ll_rl_timeout_set(timeout);
 100844e:	8818      	ldrh	r0, [r3, #0]
 1008450:	f006 fc8e 	bl	100ed70 <ll_rl_timeout_set>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1008454:	2101      	movs	r1, #1
 1008456:	a809      	add	r0, sp, #36	; 0x24
 1008458:	f7ff fac2 	bl	10079e0 <hci_cmd_complete>
	ccst->status = 0x00;
 100845c:	2300      	movs	r3, #0
 100845e:	7003      	strb	r3, [r0, #0]
	if (err == -EINVAL) {
 1008460:	9809      	ldr	r0, [sp, #36]	; 0x24
 1008462:	e45f      	b.n	1007d24 <hci_cmd_handle+0x12c>
	u8_t enable = cmd->enable;
 1008464:	68a3      	ldr	r3, [r4, #8]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1008466:	2101      	movs	r1, #1
 1008468:	a809      	add	r0, sp, #36	; 0x24
	u8_t enable = cmd->enable;
 100846a:	781d      	ldrb	r5, [r3, #0]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 100846c:	f7ff fab8 	bl	10079e0 <hci_cmd_complete>
 1008470:	4604      	mov	r4, r0
	ccst->status = ll_rl_enable(enable);
 1008472:	4628      	mov	r0, r5
 1008474:	f006 fc60 	bl	100ed38 <ll_rl_enable>
 1008478:	7020      	strb	r0, [r4, #0]
	if (err == -EINVAL) {
 100847a:	9809      	ldr	r0, [sp, #36]	; 0x24
 100847c:	e452      	b.n	1007d24 <hci_cmd_handle+0x12c>
	memcpy(dst, src, sizeof(*dst));
}

static inline void bt_addr_le_copy(bt_addr_le_t *dst, const bt_addr_le_t *src)
{
	memcpy(dst, src, sizeof(*dst));
 100847e:	2207      	movs	r2, #7
 1008480:	68a1      	ldr	r1, [r4, #8]
 1008482:	a80a      	add	r0, sp, #40	; 0x28
 1008484:	f00e fa18 	bl	10168b8 <memcpy>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1008488:	2107      	movs	r1, #7
 100848a:	a809      	add	r0, sp, #36	; 0x24
 100848c:	f7ff faa8 	bl	10079e0 <hci_cmd_complete>
 1008490:	4604      	mov	r4, r0
	rp->status = ll_rl_lrpa_get(&peer_id_addr, &rp->local_rpa);
 1008492:	a80a      	add	r0, sp, #40	; 0x28
 1008494:	1c61      	adds	r1, r4, #1
 1008496:	f007 f8a5 	bl	100f5e4 <ll_rl_lrpa_get>
 100849a:	7020      	strb	r0, [r4, #0]
	if (err == -EINVAL) {
 100849c:	9809      	ldr	r0, [sp, #36]	; 0x24
 100849e:	e441      	b.n	1007d24 <hci_cmd_handle+0x12c>
 10084a0:	2207      	movs	r2, #7
 10084a2:	68a1      	ldr	r1, [r4, #8]
 10084a4:	a80a      	add	r0, sp, #40	; 0x28
 10084a6:	f00e fa07 	bl	10168b8 <memcpy>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 10084aa:	2107      	movs	r1, #7
 10084ac:	a809      	add	r0, sp, #36	; 0x24
 10084ae:	f7ff fa97 	bl	10079e0 <hci_cmd_complete>
 10084b2:	4604      	mov	r4, r0
	rp->status = ll_rl_crpa_get(&peer_id_addr, &rp->peer_rpa);
 10084b4:	a80a      	add	r0, sp, #40	; 0x28
 10084b6:	1c61      	adds	r1, r4, #1
 10084b8:	f007 f870 	bl	100f59c <ll_rl_crpa_get>
 10084bc:	7020      	strb	r0, [r4, #0]
	if (err == -EINVAL) {
 10084be:	9809      	ldr	r0, [sp, #36]	; 0x24
 10084c0:	e430      	b.n	1007d24 <hci_cmd_handle+0x12c>
	status = ll_wl_remove(&cmd->addr);
 10084c2:	68a0      	ldr	r0, [r4, #8]
 10084c4:	f006 fb8c 	bl	100ebe0 <ll_wl_remove>
 10084c8:	e5d3      	b.n	1008072 <hci_cmd_handle+0x47a>
	status = ll_wl_add(&cmd->addr);
 10084ca:	68a0      	ldr	r0, [r4, #8]
 10084cc:	f006 fea4 	bl	100f218 <ll_wl_add>
 10084d0:	e5cf      	b.n	1008072 <hci_cmd_handle+0x47a>
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 10084d2:	2101      	movs	r1, #1
 10084d4:	a809      	add	r0, sp, #36	; 0x24
 10084d6:	f7ff fa83 	bl	10079e0 <hci_cmd_complete>
 10084da:	4604      	mov	r4, r0
	ccst->status = ll_wl_clear();
 10084dc:	f006 fb50 	bl	100eb80 <ll_wl_clear>
 10084e0:	7020      	strb	r0, [r4, #0]
	if (err == -EINVAL) {
 10084e2:	9809      	ldr	r0, [sp, #36]	; 0x24
 10084e4:	e41e      	b.n	1007d24 <hci_cmd_handle+0x12c>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 10084e6:	2102      	movs	r1, #2
 10084e8:	a809      	add	r0, sp, #36	; 0x24
 10084ea:	f7ff fa79 	bl	10079e0 <hci_cmd_complete>
	rp->status = 0x00;
 10084ee:	2300      	movs	r3, #0
 10084f0:	7003      	strb	r3, [r0, #0]
	rp = hci_cmd_complete(evt, sizeof(*rp));
 10084f2:	4604      	mov	r4, r0
	rp->wl_size = ll_wl_size_get();
 10084f4:	f006 fb42 	bl	100eb7c <ll_wl_size_get>
 10084f8:	7060      	strb	r0, [r4, #1]
	if (err == -EINVAL) {
 10084fa:	9809      	ldr	r0, [sp, #36]	; 0x24
 10084fc:	e412      	b.n	1007d24 <hci_cmd_handle+0x12c>
	status = ll_adv_enable(cmd->enable);
 10084fe:	68a3      	ldr	r3, [r4, #8]
 1008500:	7818      	ldrb	r0, [r3, #0]
 1008502:	f7f7 ff59 	bl	10003b8 <ll_adv_enable>
 1008506:	e5b4      	b.n	1008072 <hci_cmd_handle+0x47a>
	status = ll_adv_scan_rsp_set(cmd->len, &cmd->data[0]);
 1008508:	68a1      	ldr	r1, [r4, #8]
 100850a:	f811 0b01 	ldrb.w	r0, [r1], #1
 100850e:	f002 fa49 	bl	100a9a4 <ll_adv_scan_rsp_set>
 1008512:	e5ae      	b.n	1008072 <hci_cmd_handle+0x47a>
	status = ll_adv_data_set(cmd->len, &cmd->data[0]);
 1008514:	68a1      	ldr	r1, [r4, #8]
 1008516:	f811 0b01 	ldrb.w	r0, [r1], #1
 100851a:	f002 f9f7 	bl	100a90c <ll_adv_data_set>
 100851e:	e5a8      	b.n	1008072 <hci_cmd_handle+0x47a>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 1008520:	2102      	movs	r1, #2
 1008522:	a809      	add	r0, sp, #36	; 0x24
 1008524:	f7ff fa5c 	bl	10079e0 <hci_cmd_complete>
	rp->status = 0x00;
 1008528:	2300      	movs	r3, #0
 100852a:	7003      	strb	r3, [r0, #0]
	rp->tx_power_level = 0;
 100852c:	7043      	strb	r3, [r0, #1]
	if (err == -EINVAL) {
 100852e:	9809      	ldr	r0, [sp, #36]	; 0x24
 1008530:	f7ff bbf8 	b.w	1007d24 <hci_cmd_handle+0x12c>
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0);
 1008534:	2300      	movs	r3, #0
		le_conn_param_req_neg_reply(cmd, evt);
 1008536:	68a2      	ldr	r2, [r4, #8]
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0);
 1008538:	2102      	movs	r1, #2
	handle = sys_le16_to_cpu(cmd->handle);
 100853a:	8815      	ldrh	r5, [r2, #0]
	status = ll_conn_update(handle, 2, cmd->reason, 0, 0, 0, 0);
 100853c:	7892      	ldrb	r2, [r2, #2]
 100853e:	b2a8      	uxth	r0, r5
 1008540:	e9cd 3301 	strd	r3, r3, [sp, #4]
 1008544:	9300      	str	r3, [sp, #0]
 1008546:	f003 f88f 	bl	100b668 <ll_conn_update>
 100854a:	e455      	b.n	1007df8 <hci_cmd_handle+0x200>
	rp->rssi = (!rp->status) ? -rp->rssi : 127;
 100854c:	237f      	movs	r3, #127	; 0x7f
	dst[2] = val >> 16;
 100854e:	70e3      	strb	r3, [r4, #3]
	if (err == -EINVAL) {
 1008550:	e401      	b.n	1007d56 <hci_cmd_handle+0x15e>
		disconnect(cmd, evt);
 1008552:	68a3      	ldr	r3, [r4, #8]
	status = ll_terminate_ind_send(handle, cmd->reason);
 1008554:	7899      	ldrb	r1, [r3, #2]
 1008556:	8818      	ldrh	r0, [r3, #0]
 1008558:	f003 f932 	bl	100b7c0 <ll_terminate_ind_send>
 100855c:	4601      	mov	r1, r0
	return bt_hci_cmd_status_create(_opcode, status);
 100855e:	8828      	ldrh	r0, [r5, #0]
 1008560:	f7ff fa2a 	bl	10079b8 <bt_hci_cmd_status_create>
	if (err == -EINVAL) {
 1008564:	f7ff bbde 	b.w	1007d24 <hci_cmd_handle+0x12c>
		ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1008568:	2101      	movs	r1, #1
 100856a:	a809      	add	r0, sp, #36	; 0x24
 100856c:	f7ff fa38 	bl	10079e0 <hci_cmd_complete>
		ccst->status = BT_HCI_ERR_CMD_DISALLOWED;
 1008570:	230c      	movs	r3, #12
 1008572:	7003      	strb	r3, [r0, #0]
		return;
 1008574:	f7ff bbef 	b.w	1007d56 <hci_cmd_handle+0x15e>
	return ((u64_t)sys_get_le32(&src[4]) << 32) | sys_get_le32(&src[0]);
 1008578:	68a1      	ldr	r1, [r4, #8]
	event_mask = sys_get_le64(cmd->events);
 100857a:	4a22      	ldr	r2, [pc, #136]	; (1008604 <hci_cmd_handle+0xa0c>)
 100857c:	680d      	ldr	r5, [r1, #0]
 100857e:	684c      	ldr	r4, [r1, #4]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1008580:	a809      	add	r0, sp, #36	; 0x24
 1008582:	4619      	mov	r1, r3
	event_mask = sys_get_le64(cmd->events);
 1008584:	e9c2 5400 	strd	r5, r4, [r2]
	ccst = hci_cmd_complete(evt, sizeof(*ccst));
 1008588:	f7ff fa2a 	bl	10079e0 <hci_cmd_complete>
	ccst->status = 0x00;
 100858c:	2300      	movs	r3, #0
 100858e:	7003      	strb	r3, [r0, #0]
	if (err == -EINVAL) {
 1008590:	9809      	ldr	r0, [sp, #36]	; 0x24
 1008592:	f7ff bbc7 	b.w	1007d24 <hci_cmd_handle+0x12c>
	handle = sys_le16_to_cpu(cmd->handle);
 1008596:	68a3      	ldr	r3, [r4, #8]
	status = ll_apto_get(handle, &auth_payload_timeout);
 1008598:	a90a      	add	r1, sp, #40	; 0x28
	handle = sys_le16_to_cpu(cmd->handle);
 100859a:	881d      	ldrh	r5, [r3, #0]
	status = ll_apto_get(handle, &auth_payload_timeout);
 100859c:	b2a8      	uxth	r0, r5
 100859e:	f003 fa73 	bl	100ba88 <ll_apto_get>
	rp = hci_cmd_complete(evt, sizeof(*rp));
 10085a2:	2105      	movs	r1, #5
	status = ll_apto_get(handle, &auth_payload_timeout);
 10085a4:	4604      	mov	r4, r0
	rp = hci_cmd_complete(evt, sizeof(*rp));
 10085a6:	a809      	add	r0, sp, #36	; 0x24
 10085a8:	f7ff fa1a 	bl	10079e0 <hci_cmd_complete>
 10085ac:	4603      	mov	r3, r0
	rp->status = status;
 10085ae:	7004      	strb	r4, [r0, #0]
	rp->handle = sys_cpu_to_le16(handle);
 10085b0:	f8a0 5001 	strh.w	r5, [r0, #1]
	rp->auth_payload_timeout = sys_cpu_to_le16(auth_payload_timeout);
 10085b4:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
 10085b8:	9809      	ldr	r0, [sp, #36]	; 0x24
 10085ba:	f8a3 2003 	strh.w	r2, [r3, #3]
}
 10085be:	f7ff bbb1 	b.w	1007d24 <hci_cmd_handle+0x12c>
	hci_hbuf_acked += count;
 10085c2:	4a11      	ldr	r2, [pc, #68]	; (1008608 <hci_cmd_handle+0xa10>)
	k_poll_signal_raise(hbuf_signal, 0x0);
 10085c4:	4911      	ldr	r1, [pc, #68]	; (100860c <hci_cmd_handle+0xa14>)
	hci_hbuf_acked += count;
 10085c6:	6813      	ldr	r3, [r2, #0]
	k_poll_signal_raise(hbuf_signal, 0x0);
 10085c8:	6808      	ldr	r0, [r1, #0]
	hci_hbuf_acked += count;
 10085ca:	4423      	add	r3, r4
 10085cc:	6013      	str	r3, [r2, #0]
 10085ce:	2100      	movs	r1, #0
 10085d0:	f00c fbb2 	bl	1014d38 <z_impl_k_poll_signal_raise>
 10085d4:	9809      	ldr	r0, [sp, #36]	; 0x24
 10085d6:	f7ff bba5 	b.w	1007d24 <hci_cmd_handle+0x12c>
		dup_count = -1;
 10085da:	f04f 32ff 	mov.w	r2, #4294967295
 10085de:	4b0c      	ldr	r3, [pc, #48]	; (1008610 <hci_cmd_handle+0xa18>)
 10085e0:	601a      	str	r2, [r3, #0]
 10085e2:	e5de      	b.n	10081a2 <hci_cmd_handle+0x5aa>
		if (hci_hbuf_total < 0) {
 10085e4:	2b00      	cmp	r3, #0
 10085e6:	f6bf ad1d 	bge.w	1008024 <hci_cmd_handle+0x42c>
 10085ea:	f7ff bbb4 	b.w	1007d56 <hci_cmd_handle+0x15e>
	return bt_hci_cmd_status_create(_opcode, status);
 10085ee:	2112      	movs	r1, #18
 10085f0:	f7ff f9e2 	bl	10079b8 <bt_hci_cmd_status_create>
	if (err == -EINVAL) {
 10085f4:	f7ff bb96 	b.w	1007d24 <hci_cmd_handle+0x12c>
	return bt_hci_cmd_status_create(_opcode, status);
 10085f8:	2111      	movs	r1, #17
 10085fa:	f7ff f9dd 	bl	10079b8 <bt_hci_cmd_status_create>
		return;
 10085fe:	f7ff bb91 	b.w	1007d24 <hci_cmd_handle+0x12c>
 1008602:	bf00      	nop
 1008604:	21000000 	.word	0x21000000
 1008608:	21000d04 	.word	0x21000d04
 100860c:	21000d00 	.word	0x21000d00
 1008610:	21000c78 	.word	0x21000c78

01008614 <hci_acl_handle>:
	*evt = NULL;
 1008614:	2200      	movs	r2, #0
	if (buf->len < sizeof(*acl)) {
 1008616:	8983      	ldrh	r3, [r0, #12]
{
 1008618:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if (buf->len < sizeof(*acl)) {
 100861c:	2b03      	cmp	r3, #3
	*evt = NULL;
 100861e:	600a      	str	r2, [r1, #0]
	if (buf->len < sizeof(*acl)) {
 1008620:	d942      	bls.n	10086a8 <hci_acl_handle+0x94>
	acl = net_buf_pull_mem(buf, sizeof(*acl));
 1008622:	4605      	mov	r5, r0
 1008624:	460e      	mov	r6, r1
 1008626:	3008      	adds	r0, #8
 1008628:	2104      	movs	r1, #4
 100862a:	f00e fa6a 	bl	1016b02 <net_buf_simple_pull_mem>
	if (buf->len < len) {
 100862e:	89ab      	ldrh	r3, [r5, #12]
	len = sys_le16_to_cpu(acl->len);
 1008630:	8847      	ldrh	r7, [r0, #2]
	handle = sys_le16_to_cpu(acl->handle);
 1008632:	f8b0 8000 	ldrh.w	r8, [r0]
	if (buf->len < len) {
 1008636:	42bb      	cmp	r3, r7
 1008638:	d343      	bcc.n	10086c2 <hci_acl_handle+0xae>
	node_tx = ll_tx_mem_acquire();
 100863a:	f002 ffa5 	bl	100b588 <ll_tx_mem_acquire>
	flags = bt_acl_flags(handle);
 100863e:	ea4f 3318 	mov.w	r3, r8, lsr #12
	if (!node_tx) {
 1008642:	4604      	mov	r4, r0
 1008644:	2800      	cmp	r0, #0
 1008646:	d040      	beq.n	10086ca <hci_acl_handle+0xb6>
	if (bt_acl_flags_bc(flags) != BT_ACL_POINT_TO_POINT) {
 1008648:	089a      	lsrs	r2, r3, #2
 100864a:	d102      	bne.n	1008652 <hci_acl_handle+0x3e>
	switch (bt_acl_flags_pb(flags)) {
 100864c:	b333      	cbz	r3, 100869c <hci_acl_handle+0x88>
 100864e:	2b01      	cmp	r3, #1
 1008650:	d003      	beq.n	100865a <hci_acl_handle+0x46>
		return -EINVAL;
 1008652:	f06f 0015 	mvn.w	r0, #21
}
 1008656:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		pdu_data->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
 100865a:	7902      	ldrb	r2, [r0, #4]
 100865c:	f363 0201 	bfi	r2, r3, #0, #2
 1008660:	7102      	strb	r2, [r0, #4]
	pdu_data->len = len;
 1008662:	7167      	strb	r7, [r4, #5]
	memcpy(&pdu_data->lldata[0], buf->data, len);
 1008664:	68a9      	ldr	r1, [r5, #8]
 1008666:	463a      	mov	r2, r7
 1008668:	1de0      	adds	r0, r4, #7
 100866a:	f00e f925 	bl	10168b8 <memcpy>
	if (ll_tx_mem_enqueue(handle, node_tx)) {
 100866e:	4621      	mov	r1, r4
 1008670:	f3c8 000b 	ubfx	r0, r8, #0, #12
 1008674:	f002 ff94 	bl	100b5a0 <ll_tx_mem_enqueue>
 1008678:	2800      	cmp	r0, #0
 100867a:	d0ec      	beq.n	1008656 <hci_acl_handle+0x42>
 100867c:	4b2a      	ldr	r3, [pc, #168]	; (1008728 <hci_acl_handle+0x114>)
 100867e:	492b      	ldr	r1, [pc, #172]	; (100872c <hci_acl_handle+0x118>)
		BT_ERR("Invalid Tx Enqueue");
 1008680:	482b      	ldr	r0, [pc, #172]	; (1008730 <hci_acl_handle+0x11c>)
 1008682:	1ac9      	subs	r1, r1, r3
 1008684:	08c9      	lsrs	r1, r1, #3
 1008686:	0189      	lsls	r1, r1, #6
 1008688:	f041 0101 	orr.w	r1, r1, #1
 100868c:	f00c fe7f 	bl	101538e <log_0>
		ll_tx_mem_release(node_tx);
 1008690:	4620      	mov	r0, r4
 1008692:	f002 ff7f 	bl	100b594 <ll_tx_mem_release>
		return -EINVAL;
 1008696:	f06f 0015 	mvn.w	r0, #21
 100869a:	e7dc      	b.n	1008656 <hci_acl_handle+0x42>
		pdu_data->ll_id = PDU_DATA_LLID_DATA_START;
 100869c:	2202      	movs	r2, #2
 100869e:	7903      	ldrb	r3, [r0, #4]
 10086a0:	f362 0301 	bfi	r3, r2, #0, #2
 10086a4:	7103      	strb	r3, [r0, #4]
		break;
 10086a6:	e7dc      	b.n	1008662 <hci_acl_handle+0x4e>
 10086a8:	4920      	ldr	r1, [pc, #128]	; (100872c <hci_acl_handle+0x118>)
 10086aa:	4b1f      	ldr	r3, [pc, #124]	; (1008728 <hci_acl_handle+0x114>)
		BT_ERR("No HCI ACL header");
 10086ac:	4821      	ldr	r0, [pc, #132]	; (1008734 <hci_acl_handle+0x120>)
 10086ae:	1ac9      	subs	r1, r1, r3
 10086b0:	08c9      	lsrs	r1, r1, #3
		BT_ERR("Invalid HCI ACL packet length");
 10086b2:	0189      	lsls	r1, r1, #6
 10086b4:	f041 0101 	orr.w	r1, r1, #1
 10086b8:	f00c fe69 	bl	101538e <log_0>
		return -EINVAL;
 10086bc:	f06f 0015 	mvn.w	r0, #21
 10086c0:	e7c9      	b.n	1008656 <hci_acl_handle+0x42>
 10086c2:	491a      	ldr	r1, [pc, #104]	; (100872c <hci_acl_handle+0x118>)
 10086c4:	4b18      	ldr	r3, [pc, #96]	; (1008728 <hci_acl_handle+0x114>)
		BT_ERR("Invalid HCI ACL packet length");
 10086c6:	481c      	ldr	r0, [pc, #112]	; (1008738 <hci_acl_handle+0x124>)
 10086c8:	e7f1      	b.n	10086ae <hci_acl_handle+0x9a>
 10086ca:	4b17      	ldr	r3, [pc, #92]	; (1008728 <hci_acl_handle+0x114>)
 10086cc:	4917      	ldr	r1, [pc, #92]	; (100872c <hci_acl_handle+0x118>)
		BT_ERR("Tx Buffer Overflow");
 10086ce:	481b      	ldr	r0, [pc, #108]	; (100873c <hci_acl_handle+0x128>)
 10086d0:	1ac9      	subs	r1, r1, r3
 10086d2:	08c9      	lsrs	r1, r1, #3
 10086d4:	0189      	lsls	r1, r1, #6
 10086d6:	f041 0101 	orr.w	r1, r1, #1
 10086da:	f00c fe58 	bl	101538e <log_0>
	if (!(event_mask & BT_EVT_MASK_DATA_BUFFER_OVERFLOW)) {
 10086de:	4623      	mov	r3, r4
 10086e0:	4917      	ldr	r1, [pc, #92]	; (1008740 <hci_acl_handle+0x12c>)
 10086e2:	6809      	ldr	r1, [r1, #0]
 10086e4:	f001 7200 	and.w	r2, r1, #33554432	; 0x2000000
 10086e8:	4313      	orrs	r3, r2
 10086ea:	d102      	bne.n	10086f2 <hci_acl_handle+0xde>
		return -ENOBUFS;
 10086ec:	f06f 0036 	mvn.w	r0, #54	; 0x36
 10086f0:	e7b1      	b.n	1008656 <hci_acl_handle+0x42>
	*buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 10086f2:	f04f 33ff 	mov.w	r3, #4294967295
 10086f6:	f04f 32ff 	mov.w	r2, #4294967295
 10086fa:	2001      	movs	r0, #1
 10086fc:	f7fd f84e 	bl	100579c <bt_buf_get_rx>
	hdr = net_buf_add(buf, sizeof(*hdr));
 1008700:	2102      	movs	r1, #2
	*buf = bt_buf_get_rx(BT_BUF_EVT, K_FOREVER);
 1008702:	6030      	str	r0, [r6, #0]
	hdr = net_buf_add(buf, sizeof(*hdr));
 1008704:	3008      	adds	r0, #8
 1008706:	f00e f9dc 	bl	1016ac2 <net_buf_simple_add>
	hdr->len = len;
 100870a:	2401      	movs	r4, #1
	hdr->evt = evt;
 100870c:	221a      	movs	r2, #26
	hdr->len = len;
 100870e:	7044      	strb	r4, [r0, #1]
	hdr->evt = evt;
 1008710:	7002      	strb	r2, [r0, #0]
	ep = net_buf_add(*buf, sizeof(*ep));
 1008712:	6830      	ldr	r0, [r6, #0]
 1008714:	4621      	mov	r1, r4
 1008716:	3008      	adds	r0, #8
 1008718:	f00e f9d3 	bl	1016ac2 <net_buf_simple_add>
 100871c:	4603      	mov	r3, r0
		return -ENOBUFS;
 100871e:	f06f 0036 	mvn.w	r0, #54	; 0x36
	ep->link_type = BT_OVERFLOW_LINK_ACL;
 1008722:	701c      	strb	r4, [r3, #0]
 1008724:	e797      	b.n	1008656 <hci_acl_handle+0x42>
 1008726:	bf00      	nop
 1008728:	010180b8 	.word	0x010180b8
 100872c:	010180e0 	.word	0x010180e0
 1008730:	01018630 	.word	0x01018630
 1008734:	010185e8 	.word	0x010185e8
 1008738:	010185fc 	.word	0x010185fc
 100873c:	0101861c 	.word	0x0101861c
 1008740:	21000000 	.word	0x21000000

01008744 <hci_acl_encode>:
	u16_t handle;
	u8_t *data;

	handle = node_rx->hdr.handle;

	switch (pdu_data->ll_id) {
 1008744:	f890 3020 	ldrb.w	r3, [r0, #32]
 1008748:	f003 0303 	and.w	r3, r3, #3
 100874c:	3b01      	subs	r3, #1
 100874e:	2b01      	cmp	r3, #1
 1008750:	d904      	bls.n	100875c <hci_acl_encode+0x18>
		}
#endif
		break;

	default:
		LL_ASSERT(0);
 1008752:	f640 515c 	movw	r1, #3420	; 0xd5c
 1008756:	4823      	ldr	r0, [pc, #140]	; (10087e4 <hci_acl_encode+0xa0>)
 1008758:	f7fa bf16 	b.w	1003588 <bt_ctlr_assert_handle>
{
 100875c:	b570      	push	{r4, r5, r6, lr}
 100875e:	4604      	mov	r4, r0
		acl = (void *)net_buf_add(buf, sizeof(*acl));
 1008760:	f101 0508 	add.w	r5, r1, #8
 1008764:	4628      	mov	r0, r5
 1008766:	2104      	movs	r1, #4
	handle = node_rx->hdr.handle;
 1008768:	88e6      	ldrh	r6, [r4, #6]
		acl = (void *)net_buf_add(buf, sizeof(*acl));
 100876a:	f00e f9aa 	bl	1016ac2 <net_buf_simple_add>
 100876e:	4603      	mov	r3, r0
		if (pdu_data->ll_id == PDU_DATA_LLID_DATA_START) {
 1008770:	f894 2020 	ldrb.w	r2, [r4, #32]
 1008774:	f002 0203 	and.w	r2, r2, #3
 1008778:	2a02      	cmp	r2, #2
			handle_flags = bt_acl_handle_pack(handle, BT_ACL_START);
 100877a:	bf0c      	ite	eq
 100877c:	f446 5200 	orreq.w	r2, r6, #8192	; 0x2000
			handle_flags = bt_acl_handle_pack(handle, BT_ACL_CONT);
 1008780:	f446 5280 	orrne.w	r2, r6, #4096	; 0x1000
		acl->handle = sys_cpu_to_le16(handle_flags);
 1008784:	8002      	strh	r2, [r0, #0]
		acl->len = sys_cpu_to_le16(pdu_data->len);
 1008786:	f894 1021 	ldrb.w	r1, [r4, #33]	; 0x21
		data = (void *)net_buf_add(buf, pdu_data->len);
 100878a:	4628      	mov	r0, r5
		acl->len = sys_cpu_to_le16(pdu_data->len);
 100878c:	8059      	strh	r1, [r3, #2]
		data = (void *)net_buf_add(buf, pdu_data->len);
 100878e:	f00e f998 	bl	1016ac2 <net_buf_simple_add>
		memcpy(data, pdu_data->lldata, pdu_data->len);
 1008792:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
 1008796:	f104 0123 	add.w	r1, r4, #35	; 0x23
 100879a:	f00e f88d 	bl	10168b8 <memcpy>
		if (hci_hbuf_total > 0) {
 100879e:	4b12      	ldr	r3, [pc, #72]	; (10087e8 <hci_acl_encode+0xa4>)
 10087a0:	681a      	ldr	r2, [r3, #0]
 10087a2:	2a00      	cmp	r2, #0
 10087a4:	dd10      	ble.n	10087c8 <hci_acl_encode+0x84>
			LL_ASSERT((hci_hbuf_sent - hci_hbuf_acked) <
 10087a6:	4c11      	ldr	r4, [pc, #68]	; (10087ec <hci_acl_encode+0xa8>)
 10087a8:	4911      	ldr	r1, [pc, #68]	; (10087f0 <hci_acl_encode+0xac>)
 10087aa:	6823      	ldr	r3, [r4, #0]
 10087ac:	6809      	ldr	r1, [r1, #0]
 10087ae:	1a59      	subs	r1, r3, r1
 10087b0:	4291      	cmp	r1, r2
 10087b2:	d210      	bcs.n	10087d6 <hci_acl_encode+0x92>
			hci_hbuf_sent++;
 10087b4:	3301      	adds	r3, #1
			LL_ASSERT(handle < ARRAY_SIZE(hci_hbuf_pend));
 10087b6:	2e0f      	cmp	r6, #15
			hci_hbuf_sent++;
 10087b8:	6023      	str	r3, [r4, #0]
			LL_ASSERT(handle < ARRAY_SIZE(hci_hbuf_pend));
 10087ba:	d806      	bhi.n	10087ca <hci_acl_encode+0x86>
			hci_hbuf_pend[handle]++;
 10087bc:	4a0d      	ldr	r2, [pc, #52]	; (10087f4 <hci_acl_encode+0xb0>)
 10087be:	f832 3016 	ldrh.w	r3, [r2, r6, lsl #1]
 10087c2:	3301      	adds	r3, #1
 10087c4:	f822 3016 	strh.w	r3, [r2, r6, lsl #1]
		break;
	}
}
 10087c8:	bd70      	pop	{r4, r5, r6, pc}
			LL_ASSERT(handle < ARRAY_SIZE(hci_hbuf_pend));
 10087ca:	f640 5155 	movw	r1, #3413	; 0xd55
 10087ce:	4805      	ldr	r0, [pc, #20]	; (10087e4 <hci_acl_encode+0xa0>)
 10087d0:	f7fa feda 	bl	1003588 <bt_ctlr_assert_handle>
 10087d4:	e7f2      	b.n	10087bc <hci_acl_encode+0x78>
			LL_ASSERT((hci_hbuf_sent - hci_hbuf_acked) <
 10087d6:	f640 514f 	movw	r1, #3407	; 0xd4f
 10087da:	4802      	ldr	r0, [pc, #8]	; (10087e4 <hci_acl_encode+0xa0>)
 10087dc:	f7fa fed4 	bl	1003588 <bt_ctlr_assert_handle>
 10087e0:	6823      	ldr	r3, [r4, #0]
 10087e2:	e7e7      	b.n	10087b4 <hci_acl_encode+0x70>
 10087e4:	01018644 	.word	0x01018644
 10087e8:	21000d2c 	.word	0x21000d2c
 10087ec:	21000d28 	.word	0x21000d28
 10087f0:	21000d04 	.word	0x21000d04
 10087f4:	21000d08 	.word	0x21000d08

010087f8 <hci_evt_encode>:
#endif /* CONFIG_BT_CONN */

void hci_evt_encode(struct node_rx_pdu *node_rx, struct net_buf *buf)
{
 10087f8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct pdu_data *pdu_data = PDU_DATA(node_rx);

	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
 10087fc:	7905      	ldrb	r5, [r0, #4]
{
 10087fe:	4604      	mov	r4, r0
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
 1008800:	2d02      	cmp	r5, #2
{
 1008802:	460e      	mov	r6, r1
 1008804:	b08b      	sub	sp, #44	; 0x2c
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
 1008806:	d010      	beq.n	100882a <hci_evt_encode+0x32>
	handle = node_rx->hdr.handle;
 1008808:	3d04      	subs	r5, #4
 100880a:	88c7      	ldrh	r7, [r0, #6]
	switch (node_rx->hdr.type) {
 100880c:	2d0a      	cmp	r5, #10
 100880e:	d829      	bhi.n	1008864 <hci_evt_encode+0x6c>
 1008810:	e8df f015 	tbh	[pc, r5, lsl #1]
 1008814:	00280030 	.word	0x00280030
 1008818:	00280028 	.word	0x00280028
 100881c:	0199014c 	.word	0x0199014c
 1008820:	020b01e6 	.word	0x020b01e6
 1008824:	0131011a 	.word	0x0131011a
 1008828:	00e1      	.short	0x00e1
 100882a:	f890 3023 	ldrb.w	r3, [r0, #35]	; 0x23
		encode_control(node_rx, pdu_data, buf);
	} else if (IS_ENABLED(CONFIG_BT_CONN)) {
		encode_data_ctrl(node_rx, pdu_data, buf);
 100882e:	88e5      	ldrh	r5, [r4, #6]
 1008830:	3b03      	subs	r3, #3
	struct pdu_data *pdu_data = PDU_DATA(node_rx);
 1008832:	3020      	adds	r0, #32
	switch (pdu_data->llctrl.opcode) {
 1008834:	2b12      	cmp	r3, #18
 1008836:	f200 8212 	bhi.w	1008c5e <hci_evt_encode+0x466>
 100883a:	e8df f013 	tbh	[pc, r3, lsl #1]
 100883e:	0279      	.short	0x0279
 1008840:	02100210 	.word	0x02100210
 1008844:	02bb02d2 	.word	0x02bb02d2
 1008848:	02cb0210 	.word	0x02cb0210
 100884c:	02100210 	.word	0x02100210
 1008850:	02ac029f 	.word	0x02ac029f
 1008854:	02590210 	.word	0x02590210
 1008858:	02100210 	.word	0x02100210
 100885c:	02100210 	.word	0x02100210
 1008860:	02160216 	.word	0x02160216
		LL_ASSERT(0);
 1008864:	f640 4167 	movw	r1, #3175	; 0xc67
 1008868:	48ce      	ldr	r0, [pc, #824]	; (1008ba4 <hci_evt_encode+0x3ac>)
 100886a:	f7fa fe8d 	bl	1003588 <bt_ctlr_assert_handle>
	}
}
 100886e:	b00b      	add	sp, #44	; 0x2c
 1008870:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	rssi = -(node_rx->hdr.rx_ftr.rssi);
 1008874:	7f03      	ldrb	r3, [r0, #28]
	const u8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
 1008876:	4acc      	ldr	r2, [pc, #816]	; (1008ba8 <hci_evt_encode+0x3b0>)
	if (adv->tx_addr) {
 1008878:	f890 5020 	ldrb.w	r5, [r0, #32]
	rssi = -(node_rx->hdr.rx_ftr.rssi);
 100887c:	425b      	negs	r3, r3
	const u8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
 100887e:	e892 0003 	ldmia.w	r2, {r0, r1}
	rssi = -(node_rx->hdr.rx_ftr.rssi);
 1008882:	b25b      	sxtb	r3, r3
	const u8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
 1008884:	0c0a      	lsrs	r2, r1, #16
	if (adv->tx_addr) {
 1008886:	066f      	lsls	r7, r5, #25
	rl_idx = node_rx->hdr.rx_ftr.rl_idx;
 1008888:	f894 b01e 	ldrb.w	fp, [r4, #30]
	direct = node_rx->hdr.rx_ftr.direct;
 100888c:	f894 801f 	ldrb.w	r8, [r4, #31]
	const u8_t c_adv_type[] = { 0x00, 0x01, 0x03, 0xff, 0x04,
 1008890:	9006      	str	r0, [sp, #24]
 1008892:	f8ad 101c 	strh.w	r1, [sp, #28]
 1008896:	f88d 201e 	strb.w	r2, [sp, #30]
	rssi = -(node_rx->hdr.rx_ftr.rssi);
 100889a:	9305      	str	r3, [sp, #20]
	if (adv->tx_addr) {
 100889c:	f100 82b9 	bmi.w	1008e12 <hci_evt_encode+0x61a>
	if (direct) {
 10088a0:	f1b8 0f00 	cmp.w	r8, #0
 10088a4:	f040 82e4 	bne.w	1008e70 <hci_evt_encode+0x678>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 10088a8:	4642      	mov	r2, r8
 10088aa:	49c0      	ldr	r1, [pc, #768]	; (1008bac <hci_evt_encode+0x3b4>)
 10088ac:	6849      	ldr	r1, [r1, #4]
 10088ae:	f001 5300 	and.w	r3, r1, #536870912	; 0x20000000
 10088b2:	4313      	orrs	r3, r2
 10088b4:	d0db      	beq.n	100886e <hci_evt_encode+0x76>
	    !(le_event_mask & BT_EVT_MASK_LE_ADVERTISING_REPORT)) {
 10088b6:	4643      	mov	r3, r8
 10088b8:	49bd      	ldr	r1, [pc, #756]	; (1008bb0 <hci_evt_encode+0x3b8>)
 10088ba:	6809      	ldr	r1, [r1, #0]
 10088bc:	f001 0202 	and.w	r2, r1, #2
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 10088c0:	4313      	orrs	r3, r2
 10088c2:	d0d4      	beq.n	100886e <hci_evt_encode+0x76>
	if (dup_count >= 0) {
 10088c4:	f8df 9314 	ldr.w	r9, [pc, #788]	; 1008bdc <hci_evt_encode+0x3e4>
 10088c8:	f8d9 2000 	ldr.w	r2, [r9]
 10088cc:	2a00      	cmp	r2, #0
 10088ce:	db48      	blt.n	1008962 <hci_evt_encode+0x16a>
		for (i = 0; i < dup_count; i++) {
 10088d0:	bf08      	it	eq
 10088d2:	f104 0a22 	addeq.w	sl, r4, #34	; 0x22
 10088d6:	d019      	beq.n	100890c <hci_evt_encode+0x114>
 10088d8:	4647      	mov	r7, r8
 10088da:	4db6      	ldr	r5, [pc, #728]	; (1008bb4 <hci_evt_encode+0x3bc>)
 10088dc:	f104 0a22 	add.w	sl, r4, #34	; 0x22
			if (!memcmp(&adv->adv_ind.addr[0],
 10088e0:	2206      	movs	r2, #6
 10088e2:	4629      	mov	r1, r5
 10088e4:	4650      	mov	r0, sl
 10088e6:	f00d ffd7 	bl	1016898 <memcmp>
 10088ea:	b940      	cbnz	r0, 10088fe <hci_evt_encode+0x106>
			    adv->tx_addr == dup_filter[i].addr.type) {
 10088ec:	f894 2020 	ldrb.w	r2, [r4, #32]
 10088f0:	f815 1c01 	ldrb.w	r1, [r5, #-1]
 10088f4:	f3c2 1080 	ubfx	r0, r2, #6, #1
				    sizeof(bt_addr_t)) &&
 10088f8:	4288      	cmp	r0, r1
 10088fa:	f000 839d 	beq.w	1009038 <hci_evt_encode+0x840>
		for (i = 0; i < dup_count; i++) {
 10088fe:	f8d9 2000 	ldr.w	r2, [r9]
 1008902:	3701      	adds	r7, #1
 1008904:	4297      	cmp	r7, r2
 1008906:	f105 0508 	add.w	r5, r5, #8
 100890a:	dbe9      	blt.n	10088e0 <hci_evt_encode+0xe8>
		memcpy(&dup_filter[dup_curr].addr.a.val[0],
 100890c:	4daa      	ldr	r5, [pc, #680]	; (1008bb8 <hci_evt_encode+0x3c0>)
 100890e:	4fab      	ldr	r7, [pc, #684]	; (1008bbc <hci_evt_encode+0x3c4>)
 1008910:	682a      	ldr	r2, [r5, #0]
 1008912:	4651      	mov	r1, sl
 1008914:	eb07 02c2 	add.w	r2, r7, r2, lsl #3
 1008918:	1c90      	adds	r0, r2, #2
 100891a:	2206      	movs	r2, #6
 100891c:	f00d ffcc 	bl	10168b8 <memcpy>
		dup_filter[dup_curr].mask = BIT(adv->type);
 1008920:	2101      	movs	r1, #1
		dup_filter[dup_curr].addr.type = adv->tx_addr;
 1008922:	682a      	ldr	r2, [r5, #0]
 1008924:	f894 0020 	ldrb.w	r0, [r4, #32]
 1008928:	eb07 0cc2 	add.w	ip, r7, r2, lsl #3
 100892c:	f3c0 1080 	ubfx	r0, r0, #6, #1
 1008930:	f88c 0001 	strb.w	r0, [ip, #1]
		dup_filter[dup_curr].mask = BIT(adv->type);
 1008934:	f894 0020 	ldrb.w	r0, [r4, #32]
		if (dup_count < CONFIG_BT_CTLR_DUP_FILTER_LEN) {
 1008938:	f8d9 3000 	ldr.w	r3, [r9]
		dup_filter[dup_curr].mask = BIT(adv->type);
 100893c:	f000 000f 	and.w	r0, r0, #15
		if (dup_count < CONFIG_BT_CTLR_DUP_FILTER_LEN) {
 1008940:	2b0f      	cmp	r3, #15
		dup_filter[dup_curr].mask = BIT(adv->type);
 1008942:	fa01 f100 	lsl.w	r1, r1, r0
 1008946:	f807 1032 	strb.w	r1, [r7, r2, lsl #3]
			dup_count++;
 100894a:	bfdb      	ittet	le
 100894c:	1c59      	addle	r1, r3, #1
			dup_curr = dup_count;
 100894e:	460a      	movle	r2, r1
			dup_curr++;
 1008950:	3201      	addgt	r2, #1
			dup_count++;
 1008952:	f8c9 1000 	strle.w	r1, [r9]
		if (dup_curr == CONFIG_BT_CTLR_DUP_FILTER_LEN) {
 1008956:	2a10      	cmp	r2, #16
			dup_curr = 0U;
 1008958:	bf08      	it	eq
 100895a:	2300      	moveq	r3, #0
			dup_curr++;
 100895c:	602a      	str	r2, [r5, #0]
			dup_curr = 0U;
 100895e:	bf08      	it	eq
 1008960:	602b      	streq	r3, [r5, #0]
	if (adv->type != PDU_ADV_TYPE_DIRECT_IND) {
 1008962:	f894 3020 	ldrb.w	r3, [r4, #32]
 1008966:	f003 030f 	and.w	r3, r3, #15
 100896a:	2b01      	cmp	r3, #1
 100896c:	f000 8361 	beq.w	1009032 <hci_evt_encode+0x83a>
		data_len = (adv->len - BDADDR_SIZE);
 1008970:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
 1008974:	f1a3 0806 	sub.w	r8, r3, #6
 1008978:	fa5f f888 	uxtb.w	r8, r8
 100897c:	4647      	mov	r7, r8
 100897e:	3305      	adds	r3, #5
 1008980:	b2da      	uxtb	r2, r3
	sep = meta_evt(buf, BT_HCI_EVT_LE_ADVERTISING_REPORT,
 1008982:	2102      	movs	r1, #2
 1008984:	4630      	mov	r0, r6
 1008986:	f7fe ff69 	bl	100785c <meta_evt>
	sep->num_reports = 1U;
 100898a:	2301      	movs	r3, #1
 100898c:	7003      	strb	r3, [r0, #0]
	adv_info->evt_type = c_adv_type[adv->type];
 100898e:	f894 3020 	ldrb.w	r3, [r4, #32]
 1008992:	aa0a      	add	r2, sp, #40	; 0x28
 1008994:	f003 030f 	and.w	r3, r3, #15
 1008998:	4413      	add	r3, r2
 100899a:	f813 3c10 	ldrb.w	r3, [r3, #-16]
	sep = meta_evt(buf, BT_HCI_EVT_LE_ADVERTISING_REPORT,
 100899e:	4605      	mov	r5, r0
	adv_info->evt_type = c_adv_type[adv->type];
 10089a0:	7043      	strb	r3, [r0, #1]
	if (rl_idx < ll_rl_size_get()) {
 10089a2:	f006 f983 	bl	100ecac <ll_rl_size_get>
 10089a6:	4583      	cmp	fp, r0
 10089a8:	f080 8337 	bcs.w	100901a <hci_evt_encode+0x822>
		ll_rl_id_addr_get(rl_idx, &adv_info->addr.type,
 10089ac:	4658      	mov	r0, fp
 10089ae:	1cea      	adds	r2, r5, #3
 10089b0:	1ca9      	adds	r1, r5, #2
 10089b2:	f006 f94f 	bl	100ec54 <ll_rl_id_addr_get>
		adv_info->addr.type += 2U;
 10089b6:	78ab      	ldrb	r3, [r5, #2]
 10089b8:	3302      	adds	r3, #2
 10089ba:	70ab      	strb	r3, [r5, #2]
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
 10089bc:	f105 060a 	add.w	r6, r5, #10
 10089c0:	4630      	mov	r0, r6
 10089c2:	463a      	mov	r2, r7
	adv_info->length = data_len;
 10089c4:	f885 8009 	strb.w	r8, [r5, #9]
	memcpy(&adv_info->data[0], &adv->adv_ind.data[0], data_len);
 10089c8:	f104 0128 	add.w	r1, r4, #40	; 0x28
 10089cc:	f00d ff74 	bl	10168b8 <memcpy>
	*prssi = rssi;
 10089d0:	9b05      	ldr	r3, [sp, #20]
 10089d2:	55f3      	strb	r3, [r6, r7]
 10089d4:	e74b      	b.n	100886e <hci_evt_encode+0x76>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 10089d6:	2100      	movs	r1, #0
 10089d8:	460a      	mov	r2, r1
 10089da:	4874      	ldr	r0, [pc, #464]	; (1008bac <hci_evt_encode+0x3b4>)
 10089dc:	6840      	ldr	r0, [r0, #4]
 10089de:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
 10089e2:	4313      	orrs	r3, r2
 10089e4:	d007      	beq.n	10089f6 <hci_evt_encode+0x1fe>
	    !(le_event_mask & BT_EVT_MASK_LE_PHY_UPDATE_COMPLETE)) {
 10089e6:	460b      	mov	r3, r1
 10089e8:	4871      	ldr	r0, [pc, #452]	; (1008bb0 <hci_evt_encode+0x3b8>)
 10089ea:	6800      	ldr	r0, [r0, #0]
 10089ec:	f400 6200 	and.w	r2, r0, #2048	; 0x800
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 10089f0:	4313      	orrs	r3, r2
 10089f2:	f040 815a 	bne.w	1008caa <hci_evt_encode+0x4b2>
 10089f6:	f894 0021 	ldrb.w	r0, [r4, #33]	; 0x21
 10089fa:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 10089fe:	fa90 f1a0 	rbit	r1, r0
 1008a02:	fa93 f2a3 	rbit	r2, r3
 1008a06:	2800      	cmp	r0, #0
 1008a08:	fab1 f181 	clz	r1, r1
 1008a0c:	bf08      	it	eq
 1008a0e:	f04f 31ff 	moveq.w	r1, #4294967295
 1008a12:	2b00      	cmp	r3, #0
 1008a14:	fab2 f282 	clz	r2, r2
 1008a18:	bf08      	it	eq
 1008a1a:	f04f 32ff 	moveq.w	r2, #4294967295
 1008a1e:	4868      	ldr	r0, [pc, #416]	; (1008bc0 <hci_evt_encode+0x3c8>)
 1008a20:	4b68      	ldr	r3, [pc, #416]	; (1008bc4 <hci_evt_encode+0x3cc>)
		BT_WARN("handle: 0x%04x, status: %x, tx: %x, rx: %x.", handle,
 1008a22:	f894 5020 	ldrb.w	r5, [r4, #32]
 1008a26:	1a1b      	subs	r3, r3, r0
 1008a28:	08db      	lsrs	r3, r3, #3
 1008a2a:	1c48      	adds	r0, r1, #1
 1008a2c:	019b      	lsls	r3, r3, #6
 1008a2e:	1c54      	adds	r4, r2, #1
 1008a30:	9008      	str	r0, [sp, #32]
 1008a32:	2204      	movs	r2, #4
 1008a34:	4864      	ldr	r0, [pc, #400]	; (1008bc8 <hci_evt_encode+0x3d0>)
 1008a36:	f043 0302 	orr.w	r3, r3, #2
 1008a3a:	a906      	add	r1, sp, #24
 1008a3c:	9706      	str	r7, [sp, #24]
 1008a3e:	9409      	str	r4, [sp, #36]	; 0x24
 1008a40:	9507      	str	r5, [sp, #28]
 1008a42:	f00c fcfa 	bl	101543a <log_n>
		return;
 1008a46:	e712      	b.n	100886e <hci_evt_encode+0x76>
	if (!(event_mask_page_2 & BT_EVT_MASK_AUTH_PAYLOAD_TIMEOUT_EXP)) {
 1008a48:	2300      	movs	r3, #0
 1008a4a:	4960      	ldr	r1, [pc, #384]	; (1008bcc <hci_evt_encode+0x3d4>)
 1008a4c:	6809      	ldr	r1, [r1, #0]
 1008a4e:	f401 0200 	and.w	r2, r1, #8388608	; 0x800000
 1008a52:	4313      	orrs	r3, r2
 1008a54:	f43f af0b 	beq.w	100886e <hci_evt_encode+0x76>
	hdr = net_buf_add(buf, sizeof(*hdr));
 1008a58:	3608      	adds	r6, #8
 1008a5a:	2102      	movs	r1, #2
 1008a5c:	4630      	mov	r0, r6
 1008a5e:	f00e f830 	bl	1016ac2 <net_buf_simple_add>
	hdr->evt = evt;
 1008a62:	2257      	movs	r2, #87	; 0x57
	hdr = net_buf_add(buf, sizeof(*hdr));
 1008a64:	4603      	mov	r3, r0
	hdr->len = len;
 1008a66:	2102      	movs	r1, #2
	ep = net_buf_add(buf, sizeof(*ep));
 1008a68:	4630      	mov	r0, r6
	hdr->evt = evt;
 1008a6a:	701a      	strb	r2, [r3, #0]
	hdr->len = len;
 1008a6c:	7059      	strb	r1, [r3, #1]
	ep = net_buf_add(buf, sizeof(*ep));
 1008a6e:	f00e f828 	bl	1016ac2 <net_buf_simple_add>
	ep->handle = sys_cpu_to_le16(handle);
 1008a72:	8007      	strh	r7, [r0, #0]
 1008a74:	e6fb      	b.n	100886e <hci_evt_encode+0x76>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008a76:	2100      	movs	r1, #0
 1008a78:	460a      	mov	r2, r1
 1008a7a:	484c      	ldr	r0, [pc, #304]	; (1008bac <hci_evt_encode+0x3b4>)
 1008a7c:	6840      	ldr	r0, [r0, #4]
 1008a7e:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
 1008a82:	4313      	orrs	r3, r2
 1008a84:	f43f aef3 	beq.w	100886e <hci_evt_encode+0x76>
	    !(le_event_mask & BT_EVT_MASK_LE_CHAN_SEL_ALGO)) {
 1008a88:	460b      	mov	r3, r1
 1008a8a:	4849      	ldr	r0, [pc, #292]	; (1008bb0 <hci_evt_encode+0x3b8>)
 1008a8c:	6800      	ldr	r0, [r0, #0]
 1008a8e:	f400 2200 	and.w	r2, r0, #524288	; 0x80000
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008a92:	4313      	orrs	r3, r2
 1008a94:	f43f aeeb 	beq.w	100886e <hci_evt_encode+0x76>
	sep = meta_evt(buf, BT_HCI_EVT_LE_CHAN_SEL_ALGO, sizeof(*sep));
 1008a98:	4630      	mov	r0, r6
 1008a9a:	2203      	movs	r2, #3
 1008a9c:	2114      	movs	r1, #20
 1008a9e:	f7fe fedd 	bl	100785c <meta_evt>
	sep->handle = sys_cpu_to_le16(handle);
 1008aa2:	8007      	strh	r7, [r0, #0]
	sep->chan_sel_algo = cs->csa;
 1008aa4:	f894 3020 	ldrb.w	r3, [r4, #32]
 1008aa8:	7083      	strb	r3, [r0, #2]
 1008aaa:	e6e0      	b.n	100886e <hci_evt_encode+0x76>
	u8_t status = node_rx->status;
 1008aac:	f890 5020 	ldrb.w	r5, [r0, #32]
	if (!status) {
 1008ab0:	2d00      	cmp	r5, #0
 1008ab2:	f000 81a4 	beq.w	1008dfe <hci_evt_encode+0x606>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008ab6:	f04f 0800 	mov.w	r8, #0
 1008aba:	4642      	mov	r2, r8
 1008abc:	493b      	ldr	r1, [pc, #236]	; (1008bac <hci_evt_encode+0x3b4>)
 1008abe:	6849      	ldr	r1, [r1, #4]
 1008ac0:	f001 5300 	and.w	r3, r1, #536870912	; 0x20000000
 1008ac4:	4313      	orrs	r3, r2
 1008ac6:	f43f aed2 	beq.w	100886e <hci_evt_encode+0x76>
	    (!(le_event_mask & BT_EVT_MASK_LE_CONN_COMPLETE) &&
 1008aca:	f240 2e01 	movw	lr, #513	; 0x201
 1008ace:	4643      	mov	r3, r8
 1008ad0:	f8df c0dc 	ldr.w	ip, [pc, #220]	; 1008bb0 <hci_evt_encode+0x3b8>
	     !(le_event_mask & BT_EVT_MASK_LE_ENH_CONN_COMPLETE))) {
 1008ad4:	4641      	mov	r1, r8
	    (!(le_event_mask & BT_EVT_MASK_LE_CONN_COMPLETE) &&
 1008ad6:	f8dc c000 	ldr.w	ip, [ip]
 1008ada:	ea0c 020e 	and.w	r2, ip, lr
 1008ade:	4313      	orrs	r3, r2
	     !(le_event_mask & BT_EVT_MASK_LE_ENH_CONN_COMPLETE))) {
 1008ae0:	f40c 7000 	and.w	r0, ip, #512	; 0x200
	    (!(le_event_mask & BT_EVT_MASK_LE_CONN_COMPLETE) &&
 1008ae4:	f43f aec3 	beq.w	100886e <hci_evt_encode+0x76>
	if (!status) {
 1008ae8:	2d00      	cmp	r5, #0
 1008aea:	f040 81a4 	bne.w	1008e36 <hci_evt_encode+0x63e>
		conn_count++;
 1008aee:	4a38      	ldr	r2, [pc, #224]	; (1008bd0 <hci_evt_encode+0x3d8>)
 1008af0:	6813      	ldr	r3, [r2, #0]
 1008af2:	3301      	adds	r3, #1
 1008af4:	6013      	str	r3, [r2, #0]
	if (le_event_mask & BT_EVT_MASK_LE_ENH_CONN_COMPLETE) {
 1008af6:	ea50 0301 	orrs.w	r3, r0, r1
		leecc = meta_evt(buf, BT_HCI_EVT_LE_ENH_CONN_COMPLETE,
 1008afa:	4630      	mov	r0, r6
	if (le_event_mask & BT_EVT_MASK_LE_ENH_CONN_COMPLETE) {
 1008afc:	f040 8252 	bne.w	1008fa4 <hci_evt_encode+0x7ac>
	lecc = meta_evt(buf, BT_HCI_EVT_LE_CONN_COMPLETE, sizeof(*lecc));
 1008b00:	2212      	movs	r2, #18
 1008b02:	2101      	movs	r1, #1
 1008b04:	f7fe feaa 	bl	100785c <meta_evt>
 1008b08:	4606      	mov	r6, r0
	lecc->status = 0x00;
 1008b0a:	7005      	strb	r5, [r0, #0]
	lecc->handle = sys_cpu_to_le16(handle);
 1008b0c:	f8a0 7001 	strh.w	r7, [r0, #1]
	lecc->role = node_rx->role;
 1008b10:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
	memcpy(&lecc->peer_addr.a.val[0], &node_rx->peer_addr[0], BDADDR_SIZE);
 1008b14:	2206      	movs	r2, #6
	lecc->role = node_rx->role;
 1008b16:	70f3      	strb	r3, [r6, #3]
	lecc->peer_addr.type = node_rx->peer_addr_type & 0x1;
 1008b18:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
	memcpy(&lecc->peer_addr.a.val[0], &node_rx->peer_addr[0], BDADDR_SIZE);
 1008b1c:	f104 0123 	add.w	r1, r4, #35	; 0x23
	lecc->peer_addr.type = node_rx->peer_addr_type & 0x1;
 1008b20:	f003 0301 	and.w	r3, r3, #1
 1008b24:	7133      	strb	r3, [r6, #4]
	memcpy(&lecc->peer_addr.a.val[0], &node_rx->peer_addr[0], BDADDR_SIZE);
 1008b26:	3005      	adds	r0, #5
 1008b28:	f00d fec6 	bl	10168b8 <memcpy>
	lecc->supv_timeout = sys_cpu_to_le16(node_rx->timeout);
 1008b2c:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
	lecc->interval = sys_cpu_to_le16(node_rx->interval);
 1008b2e:	8ee1      	ldrh	r1, [r4, #54]	; 0x36
	lecc->latency = sys_cpu_to_le16(node_rx->latency);
 1008b30:	8f22      	ldrh	r2, [r4, #56]	; 0x38
	lecc->interval = sys_cpu_to_le16(node_rx->interval);
 1008b32:	f8a6 100b 	strh.w	r1, [r6, #11]
	lecc->latency = sys_cpu_to_le16(node_rx->latency);
 1008b36:	f8a6 200d 	strh.w	r2, [r6, #13]
	lecc->supv_timeout = sys_cpu_to_le16(node_rx->timeout);
 1008b3a:	f8a6 300f 	strh.w	r3, [r6, #15]
	lecc->clock_accuracy = node_rx->sca;
 1008b3e:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 1008b42:	7473      	strb	r3, [r6, #17]
 1008b44:	e693      	b.n	100886e <hci_evt_encode+0x76>
	if (!(event_mask & BT_EVT_MASK_DISCONN_COMPLETE)) {
 1008b46:	2500      	movs	r5, #0
 1008b48:	462b      	mov	r3, r5
 1008b4a:	4918      	ldr	r1, [pc, #96]	; (1008bac <hci_evt_encode+0x3b4>)
 1008b4c:	6809      	ldr	r1, [r1, #0]
 1008b4e:	f001 0210 	and.w	r2, r1, #16
 1008b52:	4313      	orrs	r3, r2
 1008b54:	f43f ae8b 	beq.w	100886e <hci_evt_encode+0x76>
	hdr = net_buf_add(buf, sizeof(*hdr));
 1008b58:	3608      	adds	r6, #8
 1008b5a:	2102      	movs	r1, #2
 1008b5c:	4630      	mov	r0, r6
 1008b5e:	f00d ffb0 	bl	1016ac2 <net_buf_simple_add>
	hdr->evt = evt;
 1008b62:	2205      	movs	r2, #5
	hdr = net_buf_add(buf, sizeof(*hdr));
 1008b64:	4603      	mov	r3, r0
	hdr->len = len;
 1008b66:	2104      	movs	r1, #4
	hdr->evt = evt;
 1008b68:	701a      	strb	r2, [r3, #0]
	hdr->len = len;
 1008b6a:	7059      	strb	r1, [r3, #1]
	ep = net_buf_add(buf, sizeof(*ep));
 1008b6c:	4630      	mov	r0, r6
 1008b6e:	f00d ffa8 	bl	1016ac2 <net_buf_simple_add>
	ep->status = 0x00;
 1008b72:	7005      	strb	r5, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
 1008b74:	f8a0 7001 	strh.w	r7, [r0, #1]
	ep->reason = *((u8_t *)pdu_data);
 1008b78:	f894 3020 	ldrb.w	r3, [r4, #32]
	LL_ASSERT(handle < ARRAY_SIZE(hci_hbuf_pend));
 1008b7c:	2f0f      	cmp	r7, #15
	ep->reason = *((u8_t *)pdu_data);
 1008b7e:	70c3      	strb	r3, [r0, #3]
	LL_ASSERT(handle < ARRAY_SIZE(hci_hbuf_pend));
 1008b80:	f200 820a 	bhi.w	1008f98 <hci_evt_encode+0x7a0>
	hci_hbuf_pend[handle] = 0U;
 1008b84:	2500      	movs	r5, #0
	hci_hbuf_acked += hci_hbuf_pend[handle];
 1008b86:	4b13      	ldr	r3, [pc, #76]	; (1008bd4 <hci_evt_encode+0x3dc>)
 1008b88:	4813      	ldr	r0, [pc, #76]	; (1008bd8 <hci_evt_encode+0x3e0>)
	conn_count--;
 1008b8a:	4911      	ldr	r1, [pc, #68]	; (1008bd0 <hci_evt_encode+0x3d8>)
	hci_hbuf_acked += hci_hbuf_pend[handle];
 1008b8c:	f833 2017 	ldrh.w	r2, [r3, r7, lsl #1]
 1008b90:	6804      	ldr	r4, [r0, #0]
	hci_hbuf_pend[handle] = 0U;
 1008b92:	f823 5017 	strh.w	r5, [r3, r7, lsl #1]
	conn_count--;
 1008b96:	680b      	ldr	r3, [r1, #0]
	hci_hbuf_acked += hci_hbuf_pend[handle];
 1008b98:	4422      	add	r2, r4
	conn_count--;
 1008b9a:	3b01      	subs	r3, #1
	hci_hbuf_acked += hci_hbuf_pend[handle];
 1008b9c:	6002      	str	r2, [r0, #0]
	conn_count--;
 1008b9e:	600b      	str	r3, [r1, #0]
 1008ba0:	e665      	b.n	100886e <hci_evt_encode+0x76>
 1008ba2:	bf00      	nop
 1008ba4:	01018644 	.word	0x01018644
 1008ba8:	010181f0 	.word	0x010181f0
 1008bac:	21000000 	.word	0x21000000
 1008bb0:	21000008 	.word	0x21000008
 1008bb4:	21000c82 	.word	0x21000c82
 1008bb8:	21000c7c 	.word	0x21000c7c
 1008bbc:	21000c80 	.word	0x21000c80
 1008bc0:	010180b8 	.word	0x010180b8
 1008bc4:	010180e0 	.word	0x010180e0
 1008bc8:	01018680 	.word	0x01018680
 1008bcc:	210006c0 	.word	0x210006c0
 1008bd0:	21000c74 	.word	0x21000c74
 1008bd4:	21000d08 	.word	0x21000d08
 1008bd8:	21000d04 	.word	0x21000d04
 1008bdc:	21000c78 	.word	0x21000c78
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008be0:	2100      	movs	r1, #0
 1008be2:	460a      	mov	r2, r1
 1008be4:	489c      	ldr	r0, [pc, #624]	; (1008e58 <hci_evt_encode+0x660>)
 1008be6:	6840      	ldr	r0, [r0, #4]
 1008be8:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
 1008bec:	4313      	orrs	r3, r2
 1008bee:	f43f ae3e 	beq.w	100886e <hci_evt_encode+0x76>
	    !(le_event_mask & BT_EVT_MASK_LE_CONN_UPDATE_COMPLETE)) {
 1008bf2:	460b      	mov	r3, r1
 1008bf4:	4899      	ldr	r0, [pc, #612]	; (1008e5c <hci_evt_encode+0x664>)
 1008bf6:	6800      	ldr	r0, [r0, #0]
 1008bf8:	f000 0204 	and.w	r2, r0, #4
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008bfc:	4313      	orrs	r3, r2
 1008bfe:	f43f ae36 	beq.w	100886e <hci_evt_encode+0x76>
	sep = meta_evt(buf, BT_HCI_EVT_LE_CONN_UPDATE_COMPLETE, sizeof(*sep));
 1008c02:	2209      	movs	r2, #9
 1008c04:	2103      	movs	r1, #3
 1008c06:	4630      	mov	r0, r6
 1008c08:	f7fe fe28 	bl	100785c <meta_evt>
	sep->status = cu->status;
 1008c0c:	f894 3020 	ldrb.w	r3, [r4, #32]
	sep->handle = sys_cpu_to_le16(handle);
 1008c10:	f8a0 7001 	strh.w	r7, [r0, #1]
	sep->status = cu->status;
 1008c14:	7003      	strb	r3, [r0, #0]
	sep->interval = sys_cpu_to_le16(cu->interval);
 1008c16:	8c61      	ldrh	r1, [r4, #34]	; 0x22
	sep->latency = sys_cpu_to_le16(cu->latency);
 1008c18:	8ca2      	ldrh	r2, [r4, #36]	; 0x24
	sep->supv_timeout = sys_cpu_to_le16(cu->timeout);
 1008c1a:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
	sep->interval = sys_cpu_to_le16(cu->interval);
 1008c1c:	f8a0 1003 	strh.w	r1, [r0, #3]
	sep->latency = sys_cpu_to_le16(cu->latency);
 1008c20:	f8a0 2005 	strh.w	r2, [r0, #5]
	sep->supv_timeout = sys_cpu_to_le16(cu->timeout);
 1008c24:	f8a0 3007 	strh.w	r3, [r0, #7]
 1008c28:	e621      	b.n	100886e <hci_evt_encode+0x76>
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_KEY_REFRESH_COMPLETE)) {
 1008c2a:	2400      	movs	r4, #0
 1008c2c:	4622      	mov	r2, r4
 1008c2e:	498a      	ldr	r1, [pc, #552]	; (1008e58 <hci_evt_encode+0x660>)
 1008c30:	6849      	ldr	r1, [r1, #4]
 1008c32:	f401 4300 	and.w	r3, r1, #32768	; 0x8000
 1008c36:	4313      	orrs	r3, r2
 1008c38:	f43f ae19 	beq.w	100886e <hci_evt_encode+0x76>
	hdr = net_buf_add(buf, sizeof(*hdr));
 1008c3c:	3608      	adds	r6, #8
 1008c3e:	2102      	movs	r1, #2
 1008c40:	4630      	mov	r0, r6
 1008c42:	f00d ff3e 	bl	1016ac2 <net_buf_simple_add>
	hdr->evt = evt;
 1008c46:	2230      	movs	r2, #48	; 0x30
	hdr = net_buf_add(buf, sizeof(*hdr));
 1008c48:	4603      	mov	r3, r0
	hdr->len = len;
 1008c4a:	2103      	movs	r1, #3
	ep = net_buf_add(buf, sizeof(*ep));
 1008c4c:	4630      	mov	r0, r6
	hdr->evt = evt;
 1008c4e:	701a      	strb	r2, [r3, #0]
	hdr->len = len;
 1008c50:	7059      	strb	r1, [r3, #1]
	ep = net_buf_add(buf, sizeof(*ep));
 1008c52:	f00d ff36 	bl	1016ac2 <net_buf_simple_add>
	ep->status = 0x00;
 1008c56:	7004      	strb	r4, [r0, #0]
	ep->handle = sys_cpu_to_le16(handle);
 1008c58:	f8a0 7001 	strh.w	r7, [r0, #1]
 1008c5c:	e607      	b.n	100886e <hci_evt_encode+0x76>
		LL_ASSERT(0);
 1008c5e:	f44f 6153 	mov.w	r1, #3376	; 0xd30
 1008c62:	487f      	ldr	r0, [pc, #508]	; (1008e60 <hci_evt_encode+0x668>)
 1008c64:	f7fa fc90 	bl	1003588 <bt_ctlr_assert_handle>
}
 1008c68:	e601      	b.n	100886e <hci_evt_encode+0x76>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008c6a:	2100      	movs	r1, #0
 1008c6c:	460a      	mov	r2, r1
 1008c6e:	487a      	ldr	r0, [pc, #488]	; (1008e58 <hci_evt_encode+0x660>)
 1008c70:	6840      	ldr	r0, [r0, #4]
 1008c72:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
 1008c76:	4313      	orrs	r3, r2
 1008c78:	f43f adf9 	beq.w	100886e <hci_evt_encode+0x76>
	    !(le_event_mask & BT_EVT_MASK_LE_DATA_LEN_CHANGE)) {
 1008c7c:	460b      	mov	r3, r1
 1008c7e:	4877      	ldr	r0, [pc, #476]	; (1008e5c <hci_evt_encode+0x664>)
 1008c80:	6800      	ldr	r0, [r0, #0]
 1008c82:	f000 0240 	and.w	r2, r0, #64	; 0x40
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008c86:	4313      	orrs	r3, r2
 1008c88:	f43f adf1 	beq.w	100886e <hci_evt_encode+0x76>
	sep = meta_evt(buf, BT_HCI_EVT_LE_DATA_LEN_CHANGE, sizeof(*sep));
 1008c8c:	4630      	mov	r0, r6
 1008c8e:	220a      	movs	r2, #10
 1008c90:	2107      	movs	r1, #7
 1008c92:	f7fe fde3 	bl	100785c <meta_evt>
	sep->handle = sys_cpu_to_le16(handle);
 1008c96:	8005      	strh	r5, [r0, #0]
	sep->max_tx_octets = pdu_data->llctrl.length_rsp.max_tx_octets;
 1008c98:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 1008c9a:	8043      	strh	r3, [r0, #2]
	sep->max_tx_time = pdu_data->llctrl.length_rsp.max_tx_time;
 1008c9c:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 1008c9e:	8083      	strh	r3, [r0, #4]
	sep->max_rx_octets = pdu_data->llctrl.length_rsp.max_rx_octets;
 1008ca0:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
 1008ca2:	80c3      	strh	r3, [r0, #6]
	sep->max_rx_time = pdu_data->llctrl.length_rsp.max_rx_time;
 1008ca4:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 1008ca6:	8103      	strh	r3, [r0, #8]
 1008ca8:	e5e1      	b.n	100886e <hci_evt_encode+0x76>
	sep = meta_evt(buf, BT_HCI_EVT_LE_PHY_UPDATE_COMPLETE, sizeof(*sep));
 1008caa:	2205      	movs	r2, #5
 1008cac:	4630      	mov	r0, r6
 1008cae:	210c      	movs	r1, #12
 1008cb0:	f7fe fdd4 	bl	100785c <meta_evt>
	sep->status = pu->status;
 1008cb4:	f894 3020 	ldrb.w	r3, [r4, #32]
	sep->handle = sys_cpu_to_le16(handle);
 1008cb8:	f8a0 7001 	strh.w	r7, [r0, #1]
	sep->status = pu->status;
 1008cbc:	7003      	strb	r3, [r0, #0]
 1008cbe:	f894 2021 	ldrb.w	r2, [r4, #33]	; 0x21
 1008cc2:	fa92 f3a2 	rbit	r3, r2
 1008cc6:	2a00      	cmp	r2, #0
 1008cc8:	fab3 f383 	clz	r3, r3
 1008ccc:	bf08      	it	eq
 1008cce:	f04f 33ff 	moveq.w	r3, #4294967295
 1008cd2:	3301      	adds	r3, #1
	sep->tx_phy = find_lsb_set(pu->tx);
 1008cd4:	70c3      	strb	r3, [r0, #3]
 1008cd6:	f894 2022 	ldrb.w	r2, [r4, #34]	; 0x22
 1008cda:	fa92 f3a2 	rbit	r3, r2
 1008cde:	2a00      	cmp	r2, #0
 1008ce0:	fab3 f383 	clz	r3, r3
 1008ce4:	bf08      	it	eq
 1008ce6:	f04f 33ff 	moveq.w	r3, #4294967295
 1008cea:	3301      	adds	r3, #1
	sep->rx_phy = find_lsb_set(pu->rx);
 1008cec:	7103      	strb	r3, [r0, #4]
 1008cee:	e5be      	b.n	100886e <hci_evt_encode+0x76>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008cf0:	2100      	movs	r1, #0
 1008cf2:	460a      	mov	r2, r1
 1008cf4:	4858      	ldr	r0, [pc, #352]	; (1008e58 <hci_evt_encode+0x660>)
 1008cf6:	6840      	ldr	r0, [r0, #4]
 1008cf8:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
 1008cfc:	4313      	orrs	r3, r2
 1008cfe:	f000 8090 	beq.w	1008e22 <hci_evt_encode+0x62a>
	    !(le_event_mask & BT_EVT_MASK_LE_CONN_PARAM_REQ)) {
 1008d02:	460b      	mov	r3, r1
 1008d04:	4855      	ldr	r0, [pc, #340]	; (1008e5c <hci_evt_encode+0x664>)
 1008d06:	6800      	ldr	r0, [r0, #0]
 1008d08:	f000 0220 	and.w	r2, r0, #32
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008d0c:	4313      	orrs	r3, r2
 1008d0e:	f000 8088 	beq.w	1008e22 <hci_evt_encode+0x62a>
	sep = meta_evt(buf, BT_HCI_EVT_LE_CONN_PARAM_REQ, sizeof(*sep));
 1008d12:	4630      	mov	r0, r6
 1008d14:	220a      	movs	r2, #10
 1008d16:	2106      	movs	r1, #6
 1008d18:	f7fe fda0 	bl	100785c <meta_evt>
	sep->handle = sys_cpu_to_le16(handle);
 1008d1c:	8005      	strh	r5, [r0, #0]
	sep->interval_min = pdu_data->llctrl.conn_param_req.interval_min;
 1008d1e:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
 1008d20:	8043      	strh	r3, [r0, #2]
	sep->interval_max = pdu_data->llctrl.conn_param_req.interval_max;
 1008d22:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 1008d24:	8083      	strh	r3, [r0, #4]
	sep->latency = pdu_data->llctrl.conn_param_req.latency;
 1008d26:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 1008d28:	80c3      	strh	r3, [r0, #6]
	sep->timeout = pdu_data->llctrl.conn_param_req.timeout;
 1008d2a:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 1008d2c:	8103      	strh	r3, [r0, #8]
 1008d2e:	e59e      	b.n	100886e <hci_evt_encode+0x76>
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008d30:	2100      	movs	r1, #0
 1008d32:	460a      	mov	r2, r1
 1008d34:	4848      	ldr	r0, [pc, #288]	; (1008e58 <hci_evt_encode+0x660>)
 1008d36:	6840      	ldr	r0, [r0, #4]
 1008d38:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
 1008d3c:	4313      	orrs	r3, r2
 1008d3e:	f43f ad96 	beq.w	100886e <hci_evt_encode+0x76>
	    !(le_event_mask & BT_EVT_MASK_LE_LTK_REQUEST)) {
 1008d42:	460b      	mov	r3, r1
 1008d44:	4845      	ldr	r0, [pc, #276]	; (1008e5c <hci_evt_encode+0x664>)
 1008d46:	6800      	ldr	r0, [r0, #0]
 1008d48:	f000 0210 	and.w	r2, r0, #16
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008d4c:	4313      	orrs	r3, r2
 1008d4e:	f43f ad8e 	beq.w	100886e <hci_evt_encode+0x76>
	sep = meta_evt(buf, BT_HCI_EVT_LE_LTK_REQUEST, sizeof(*sep));
 1008d52:	4630      	mov	r0, r6
 1008d54:	220c      	movs	r2, #12
 1008d56:	2105      	movs	r1, #5
 1008d58:	f7fe fd80 	bl	100785c <meta_evt>
 1008d5c:	4606      	mov	r6, r0
	memcpy(&sep->rand, pdu_data->llctrl.enc_req.rand, sizeof(u64_t));
 1008d5e:	f104 0124 	add.w	r1, r4, #36	; 0x24
 1008d62:	2208      	movs	r2, #8
	sep->handle = sys_cpu_to_le16(handle);
 1008d64:	f820 5b02 	strh.w	r5, [r0], #2
	memcpy(&sep->rand, pdu_data->llctrl.enc_req.rand, sizeof(u64_t));
 1008d68:	f00d fda6 	bl	10168b8 <memcpy>
	memcpy(&sep->ediv, pdu_data->llctrl.enc_req.ediv, sizeof(u16_t));
 1008d6c:	2202      	movs	r2, #2
 1008d6e:	f106 000a 	add.w	r0, r6, #10
 1008d72:	f104 012c 	add.w	r1, r4, #44	; 0x2c
 1008d76:	f00d fd9f 	bl	10168b8 <memcpy>
 1008d7a:	e578      	b.n	100886e <hci_evt_encode+0x76>
	if (!(event_mask & BT_EVT_MASK_REMOTE_VERSION_INFO)) {
 1008d7c:	2300      	movs	r3, #0
 1008d7e:	4936      	ldr	r1, [pc, #216]	; (1008e58 <hci_evt_encode+0x660>)
 1008d80:	6809      	ldr	r1, [r1, #0]
 1008d82:	f401 6200 	and.w	r2, r1, #2048	; 0x800
 1008d86:	4313      	orrs	r3, r2
 1008d88:	f43f ad71 	beq.w	100886e <hci_evt_encode+0x76>
 1008d8c:	4632      	mov	r2, r6
 1008d8e:	4629      	mov	r1, r5
 1008d90:	f7fe fdcc 	bl	100792c <hci_remote_version_info_encode.part.0>
 1008d94:	e56b      	b.n	100886e <hci_evt_encode+0x76>
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
 1008d96:	2300      	movs	r3, #0
 1008d98:	492f      	ldr	r1, [pc, #188]	; (1008e58 <hci_evt_encode+0x660>)
 1008d9a:	6809      	ldr	r1, [r1, #0]
 1008d9c:	f001 0280 	and.w	r2, r1, #128	; 0x80
 1008da0:	4313      	orrs	r3, r2
 1008da2:	f43f ad64 	beq.w	100886e <hci_evt_encode+0x76>
 1008da6:	4632      	mov	r2, r6
 1008da8:	4629      	mov	r1, r5
 1008daa:	f894 0024 	ldrb.w	r0, [r4, #36]	; 0x24
 1008dae:	f7fe fda3 	bl	10078f8 <encrypt_change.part.0>
 1008db2:	e55c      	b.n	100886e <hci_evt_encode+0x76>
		le_unknown_rsp(pdu_data, handle, buf);
 1008db4:	f894 1024 	ldrb.w	r1, [r4, #36]	; 0x24
	switch (pdu_data->llctrl.unknown_rsp.type) {
 1008db8:	290e      	cmp	r1, #14
 1008dba:	f000 80e6 	beq.w	1008f8a <hci_evt_encode+0x792>
 1008dbe:	4b29      	ldr	r3, [pc, #164]	; (1008e64 <hci_evt_encode+0x66c>)
 1008dc0:	4a29      	ldr	r2, [pc, #164]	; (1008e68 <hci_evt_encode+0x670>)
		BT_WARN("type: 0x%02x",	pdu_data->llctrl.unknown_rsp.type);
 1008dc2:	482a      	ldr	r0, [pc, #168]	; (1008e6c <hci_evt_encode+0x674>)
 1008dc4:	1a9a      	subs	r2, r3, r2
 1008dc6:	08d2      	lsrs	r2, r2, #3
 1008dc8:	0192      	lsls	r2, r2, #6
 1008dca:	f042 0202 	orr.w	r2, r2, #2
 1008dce:	f00c faeb 	bl	10153a8 <log_1>
 1008dd2:	e54c      	b.n	100886e <hci_evt_encode+0x76>
		le_remote_feat_complete(0x00, pdu_data, handle, buf);
 1008dd4:	460b      	mov	r3, r1
 1008dd6:	462a      	mov	r2, r5
 1008dd8:	4601      	mov	r1, r0
 1008dda:	2000      	movs	r0, #0
 1008ddc:	f7fe fd56 	bl	100788c <le_remote_feat_complete>
		break;
 1008de0:	e545      	b.n	100886e <hci_evt_encode+0x76>
	if (!(event_mask & BT_EVT_MASK_ENCRYPT_CHANGE)) {
 1008de2:	2000      	movs	r0, #0
 1008de4:	4603      	mov	r3, r0
 1008de6:	491c      	ldr	r1, [pc, #112]	; (1008e58 <hci_evt_encode+0x660>)
 1008de8:	6809      	ldr	r1, [r1, #0]
 1008dea:	f001 0280 	and.w	r2, r1, #128	; 0x80
 1008dee:	4313      	orrs	r3, r2
 1008df0:	f43f ad3d 	beq.w	100886e <hci_evt_encode+0x76>
 1008df4:	4632      	mov	r2, r6
 1008df6:	4629      	mov	r1, r5
 1008df8:	f7fe fd7e 	bl	10078f8 <encrypt_change.part.0>
 1008dfc:	e537      	b.n	100886e <hci_evt_encode+0x76>
		ll_rl_crpa_set(node_rx->peer_addr_type,
 1008dfe:	f100 0329 	add.w	r3, r0, #41	; 0x29
 1008e02:	f100 0123 	add.w	r1, r0, #35	; 0x23
 1008e06:	22ff      	movs	r2, #255	; 0xff
 1008e08:	f890 0022 	ldrb.w	r0, [r0, #34]	; 0x22
 1008e0c:	f006 fba4 	bl	100f558 <ll_rl_crpa_set>
 1008e10:	e651      	b.n	1008ab6 <hci_evt_encode+0x2be>
		ll_rl_crpa_set(0x00, NULL, rl_idx, &adv->adv_ind.addr[0]);
 1008e12:	2100      	movs	r1, #0
 1008e14:	465a      	mov	r2, fp
 1008e16:	4608      	mov	r0, r1
 1008e18:	f104 0322 	add.w	r3, r4, #34	; 0x22
 1008e1c:	f006 fb9c 	bl	100f558 <ll_rl_crpa_set>
 1008e20:	e53e      	b.n	10088a0 <hci_evt_encode+0xa8>
		ll_conn_update(handle, 2, BT_HCI_ERR_UNSUPP_REMOTE_FEATURE, 0,
 1008e22:	2300      	movs	r3, #0
 1008e24:	4628      	mov	r0, r5
 1008e26:	221a      	movs	r2, #26
 1008e28:	2102      	movs	r1, #2
 1008e2a:	e9cd 3301 	strd	r3, r3, [sp, #4]
 1008e2e:	9300      	str	r3, [sp, #0]
 1008e30:	f002 fc1a 	bl	100b668 <ll_conn_update>
		return;
 1008e34:	e51b      	b.n	100886e <hci_evt_encode+0x76>
	if (le_event_mask & BT_EVT_MASK_LE_ENH_CONN_COMPLETE) {
 1008e36:	ea50 0301 	orrs.w	r3, r0, r1
 1008e3a:	f040 80e2 	bne.w	1009002 <hci_evt_encode+0x80a>
	lecc = meta_evt(buf, BT_HCI_EVT_LE_CONN_COMPLETE, sizeof(*lecc));
 1008e3e:	2212      	movs	r2, #18
 1008e40:	2101      	movs	r1, #1
 1008e42:	4630      	mov	r0, r6
 1008e44:	f7fe fd0a 	bl	100785c <meta_evt>
 1008e48:	4604      	mov	r4, r0
		(void)memset(lecc, 0x00, sizeof(*lecc));
 1008e4a:	4641      	mov	r1, r8
 1008e4c:	2212      	movs	r2, #18
 1008e4e:	f00d fd5e 	bl	101690e <memset>
		lecc->status = status;
 1008e52:	7025      	strb	r5, [r4, #0]
		return;
 1008e54:	e50b      	b.n	100886e <hci_evt_encode+0x76>
 1008e56:	bf00      	nop
 1008e58:	21000000 	.word	0x21000000
 1008e5c:	21000008 	.word	0x21000008
 1008e60:	01018644 	.word	0x01018644
 1008e64:	010180e0 	.word	0x010180e0
 1008e68:	010180b8 	.word	0x010180b8
 1008e6c:	010186ac 	.word	0x010186ac
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008e70:	2100      	movs	r1, #0
 1008e72:	460a      	mov	r2, r1
 1008e74:	4887      	ldr	r0, [pc, #540]	; (1009094 <hci_evt_encode+0x89c>)
 1008e76:	6840      	ldr	r0, [r0, #4]
 1008e78:	f000 5300 	and.w	r3, r0, #536870912	; 0x20000000
 1008e7c:	4313      	orrs	r3, r2
 1008e7e:	f43f acf6 	beq.w	100886e <hci_evt_encode+0x76>
	    !(le_event_mask & BT_EVT_MASK_LE_DIRECT_ADV_REPORT)) {
 1008e82:	460b      	mov	r3, r1
 1008e84:	4884      	ldr	r0, [pc, #528]	; (1009098 <hci_evt_encode+0x8a0>)
 1008e86:	6800      	ldr	r0, [r0, #0]
 1008e88:	f400 6280 	and.w	r2, r0, #1024	; 0x400
	if (!(event_mask & BT_EVT_MASK_LE_META_EVENT) ||
 1008e8c:	4313      	orrs	r3, r2
 1008e8e:	f43f acee 	beq.w	100886e <hci_evt_encode+0x76>
	LL_ASSERT(adv->type == PDU_ADV_TYPE_DIRECT_IND);
 1008e92:	f894 3020 	ldrb.w	r3, [r4, #32]
 1008e96:	f003 030f 	and.w	r3, r3, #15
 1008e9a:	2b01      	cmp	r3, #1
 1008e9c:	d004      	beq.n	1008ea8 <hci_evt_encode+0x6b0>
 1008e9e:	f44f 611a 	mov.w	r1, #2464	; 0x9a0
 1008ea2:	487e      	ldr	r0, [pc, #504]	; (100909c <hci_evt_encode+0x8a4>)
 1008ea4:	f7fa fb70 	bl	1003588 <bt_ctlr_assert_handle>
	if (dup_count >= 0) {
 1008ea8:	f8df 9200 	ldr.w	r9, [pc, #512]	; 10090ac <hci_evt_encode+0x8b4>
 1008eac:	f8d9 2000 	ldr.w	r2, [r9]
 1008eb0:	2a00      	cmp	r2, #0
 1008eb2:	db49      	blt.n	1008f48 <hci_evt_encode+0x750>
		for (i = 0; i < dup_count; i++) {
 1008eb4:	bf08      	it	eq
 1008eb6:	f104 0a22 	addeq.w	sl, r4, #34	; 0x22
 1008eba:	d019      	beq.n	1008ef0 <hci_evt_encode+0x6f8>
 1008ebc:	2700      	movs	r7, #0
 1008ebe:	4d78      	ldr	r5, [pc, #480]	; (10090a0 <hci_evt_encode+0x8a8>)
 1008ec0:	f104 0a22 	add.w	sl, r4, #34	; 0x22
			if (!memcmp(&adv->adv_ind.addr[0],
 1008ec4:	2206      	movs	r2, #6
 1008ec6:	4629      	mov	r1, r5
 1008ec8:	4650      	mov	r0, sl
 1008eca:	f00d fce5 	bl	1016898 <memcmp>
 1008ece:	b940      	cbnz	r0, 1008ee2 <hci_evt_encode+0x6ea>
			    adv->tx_addr == dup_filter[i].addr.type) {
 1008ed0:	f894 2020 	ldrb.w	r2, [r4, #32]
 1008ed4:	f815 1c01 	ldrb.w	r1, [r5, #-1]
 1008ed8:	f3c2 1080 	ubfx	r0, r2, #6, #1
				    sizeof(bt_addr_t)) &&
 1008edc:	4288      	cmp	r0, r1
 1008ede:	f000 80c8 	beq.w	1009072 <hci_evt_encode+0x87a>
		for (i = 0; i < dup_count; i++) {
 1008ee2:	f8d9 2000 	ldr.w	r2, [r9]
 1008ee6:	3701      	adds	r7, #1
 1008ee8:	4297      	cmp	r7, r2
 1008eea:	f105 0508 	add.w	r5, r5, #8
 1008eee:	dbe9      	blt.n	1008ec4 <hci_evt_encode+0x6cc>
		memcpy(&dup_filter[dup_curr].addr.a.val[0],
 1008ef0:	4d6c      	ldr	r5, [pc, #432]	; (10090a4 <hci_evt_encode+0x8ac>)
 1008ef2:	4f6d      	ldr	r7, [pc, #436]	; (10090a8 <hci_evt_encode+0x8b0>)
 1008ef4:	682a      	ldr	r2, [r5, #0]
 1008ef6:	4651      	mov	r1, sl
 1008ef8:	eb07 02c2 	add.w	r2, r7, r2, lsl #3
 1008efc:	1c90      	adds	r0, r2, #2
 1008efe:	2206      	movs	r2, #6
 1008f00:	f00d fcda 	bl	10168b8 <memcpy>
		dup_filter[dup_curr].mask = BIT(adv->type);
 1008f04:	2001      	movs	r0, #1
		dup_filter[dup_curr].addr.type = adv->tx_addr;
 1008f06:	682a      	ldr	r2, [r5, #0]
 1008f08:	f894 1020 	ldrb.w	r1, [r4, #32]
 1008f0c:	eb07 0cc2 	add.w	ip, r7, r2, lsl #3
 1008f10:	f3c1 1180 	ubfx	r1, r1, #6, #1
 1008f14:	f88c 1001 	strb.w	r1, [ip, #1]
		dup_filter[dup_curr].mask = BIT(adv->type);
 1008f18:	f894 c020 	ldrb.w	ip, [r4, #32]
		if (dup_count < CONFIG_BT_CTLR_DUP_FILTER_LEN) {
 1008f1c:	f8d9 1000 	ldr.w	r1, [r9]
		dup_filter[dup_curr].mask = BIT(adv->type);
 1008f20:	f00c 0c0f 	and.w	ip, ip, #15
		if (dup_count < CONFIG_BT_CTLR_DUP_FILTER_LEN) {
 1008f24:	290f      	cmp	r1, #15
			dup_count++;
 1008f26:	bfd8      	it	le
 1008f28:	3101      	addle	r1, #1
		dup_filter[dup_curr].mask = BIT(adv->type);
 1008f2a:	fa00 f00c 	lsl.w	r0, r0, ip
 1008f2e:	f807 0032 	strb.w	r0, [r7, r2, lsl #3]
			dup_curr = dup_count;
 1008f32:	bfd6      	itet	le
 1008f34:	460a      	movle	r2, r1
			dup_curr++;
 1008f36:	3201      	addgt	r2, #1
			dup_count++;
 1008f38:	f8c9 1000 	strle.w	r1, [r9]
		if (dup_curr == CONFIG_BT_CTLR_DUP_FILTER_LEN) {
 1008f3c:	2a10      	cmp	r2, #16
			dup_curr = 0U;
 1008f3e:	bf08      	it	eq
 1008f40:	2300      	moveq	r3, #0
			dup_curr++;
 1008f42:	602a      	str	r2, [r5, #0]
			dup_curr = 0U;
 1008f44:	bf08      	it	eq
 1008f46:	602b      	streq	r3, [r5, #0]
	drp = meta_evt(buf, BT_HCI_EVT_LE_DIRECT_ADV_REPORT,
 1008f48:	2211      	movs	r2, #17
 1008f4a:	210b      	movs	r1, #11
 1008f4c:	4630      	mov	r0, r6
 1008f4e:	f7fe fc85 	bl	100785c <meta_evt>
	drp->num_reports = 1U;
 1008f52:	2301      	movs	r3, #1
 1008f54:	7003      	strb	r3, [r0, #0]
	dir_info->evt_type = BT_HCI_ADV_DIRECT_IND;
 1008f56:	7043      	strb	r3, [r0, #1]
	drp = meta_evt(buf, BT_HCI_EVT_LE_DIRECT_ADV_REPORT,
 1008f58:	4605      	mov	r5, r0
	if (rl_idx < ll_rl_size_get()) {
 1008f5a:	f005 fea7 	bl	100ecac <ll_rl_size_get>
 1008f5e:	4583      	cmp	fp, r0
 1008f60:	d27b      	bcs.n	100905a <hci_evt_encode+0x862>
		ll_rl_id_addr_get(rl_idx, &dir_info->addr.type,
 1008f62:	4658      	mov	r0, fp
 1008f64:	1cea      	adds	r2, r5, #3
 1008f66:	1ca9      	adds	r1, r5, #2
 1008f68:	f005 fe74 	bl	100ec54 <ll_rl_id_addr_get>
		dir_info->addr.type += 2U;
 1008f6c:	78ab      	ldrb	r3, [r5, #2]
 1008f6e:	3302      	adds	r3, #2
 1008f70:	70ab      	strb	r3, [r5, #2]
	dir_info->dir_addr.type = 0x1;
 1008f72:	2301      	movs	r3, #1
	memcpy(&dir_info->dir_addr.a.val[0],
 1008f74:	2206      	movs	r2, #6
	dir_info->dir_addr.type = 0x1;
 1008f76:	726b      	strb	r3, [r5, #9]
	memcpy(&dir_info->dir_addr.a.val[0],
 1008f78:	f104 0128 	add.w	r1, r4, #40	; 0x28
 1008f7c:	f105 000a 	add.w	r0, r5, #10
 1008f80:	f00d fc9a 	bl	10168b8 <memcpy>
	dir_info->rssi = rssi;
 1008f84:	9b05      	ldr	r3, [sp, #20]
 1008f86:	742b      	strb	r3, [r5, #16]
 1008f88:	e471      	b.n	100886e <hci_evt_encode+0x76>
		le_remote_feat_complete(BT_HCI_ERR_UNSUPP_REMOTE_FEATURE,
 1008f8a:	4633      	mov	r3, r6
 1008f8c:	462a      	mov	r2, r5
 1008f8e:	2100      	movs	r1, #0
 1008f90:	201a      	movs	r0, #26
 1008f92:	f7fe fc7b 	bl	100788c <le_remote_feat_complete>
		break;
 1008f96:	e46a      	b.n	100886e <hci_evt_encode+0x76>
	LL_ASSERT(handle < ARRAY_SIZE(hci_hbuf_pend));
 1008f98:	f640 316d 	movw	r1, #2925	; 0xb6d
 1008f9c:	483f      	ldr	r0, [pc, #252]	; (100909c <hci_evt_encode+0x8a4>)
 1008f9e:	f7fa faf3 	bl	1003588 <bt_ctlr_assert_handle>
 1008fa2:	e5ef      	b.n	1008b84 <hci_evt_encode+0x38c>
		leecc = meta_evt(buf, BT_HCI_EVT_LE_ENH_CONN_COMPLETE,
 1008fa4:	221e      	movs	r2, #30
 1008fa6:	210a      	movs	r1, #10
 1008fa8:	f7fe fc58 	bl	100785c <meta_evt>
 1008fac:	4606      	mov	r6, r0
		leecc->status = 0x00;
 1008fae:	7005      	strb	r5, [r0, #0]
		leecc->handle = sys_cpu_to_le16(handle);
 1008fb0:	f8a0 7001 	strh.w	r7, [r0, #1]
		leecc->role = node_rx->role;
 1008fb4:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
		memcpy(&leecc->peer_addr.a.val[0], &node_rx->peer_addr[0],
 1008fb8:	2206      	movs	r2, #6
		leecc->role = node_rx->role;
 1008fba:	70f3      	strb	r3, [r6, #3]
		leecc->peer_addr.type = node_rx->peer_addr_type;
 1008fbc:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
		memcpy(&leecc->peer_addr.a.val[0], &node_rx->peer_addr[0],
 1008fc0:	f104 0123 	add.w	r1, r4, #35	; 0x23
		leecc->peer_addr.type = node_rx->peer_addr_type;
 1008fc4:	7133      	strb	r3, [r6, #4]
		memcpy(&leecc->peer_addr.a.val[0], &node_rx->peer_addr[0],
 1008fc6:	3005      	adds	r0, #5
 1008fc8:	f00d fc76 	bl	10168b8 <memcpy>
		memcpy(&leecc->local_rpa.val[0], &node_rx->local_rpa[0],
 1008fcc:	2206      	movs	r2, #6
 1008fce:	f104 012f 	add.w	r1, r4, #47	; 0x2f
 1008fd2:	f106 000b 	add.w	r0, r6, #11
 1008fd6:	f00d fc6f 	bl	10168b8 <memcpy>
		memcpy(&leecc->peer_rpa.val[0], &node_rx->peer_rpa[0],
 1008fda:	2206      	movs	r2, #6
 1008fdc:	f104 0129 	add.w	r1, r4, #41	; 0x29
 1008fe0:	f106 0011 	add.w	r0, r6, #17
 1008fe4:	f00d fc68 	bl	10168b8 <memcpy>
		leecc->supv_timeout = sys_cpu_to_le16(node_rx->timeout);
 1008fe8:	8f63      	ldrh	r3, [r4, #58]	; 0x3a
		leecc->interval = sys_cpu_to_le16(node_rx->interval);
 1008fea:	8ee1      	ldrh	r1, [r4, #54]	; 0x36
		leecc->latency = sys_cpu_to_le16(node_rx->latency);
 1008fec:	8f22      	ldrh	r2, [r4, #56]	; 0x38
		leecc->interval = sys_cpu_to_le16(node_rx->interval);
 1008fee:	f8a6 1017 	strh.w	r1, [r6, #23]
		leecc->latency = sys_cpu_to_le16(node_rx->latency);
 1008ff2:	f8a6 2019 	strh.w	r2, [r6, #25]
		leecc->supv_timeout = sys_cpu_to_le16(node_rx->timeout);
 1008ff6:	f8a6 301b 	strh.w	r3, [r6, #27]
		leecc->clock_accuracy = node_rx->sca;
 1008ffa:	f894 303c 	ldrb.w	r3, [r4, #60]	; 0x3c
 1008ffe:	7773      	strb	r3, [r6, #29]
		return;
 1009000:	e435      	b.n	100886e <hci_evt_encode+0x76>
		leecc = meta_evt(buf, BT_HCI_EVT_LE_ENH_CONN_COMPLETE,
 1009002:	221e      	movs	r2, #30
 1009004:	210a      	movs	r1, #10
 1009006:	4630      	mov	r0, r6
 1009008:	f7fe fc28 	bl	100785c <meta_evt>
 100900c:	4604      	mov	r4, r0
			(void)memset(leecc, 0x00, sizeof(*leecc));
 100900e:	4641      	mov	r1, r8
 1009010:	221e      	movs	r2, #30
 1009012:	f00d fc7c 	bl	101690e <memset>
			leecc->status = status;
 1009016:	7025      	strb	r5, [r4, #0]
			return;
 1009018:	e429      	b.n	100886e <hci_evt_encode+0x76>
		adv_info->addr.type = adv->tx_addr;
 100901a:	f894 3020 	ldrb.w	r3, [r4, #32]
		memcpy(&adv_info->addr.a.val[0], &adv->adv_ind.addr[0],
 100901e:	2206      	movs	r2, #6
		adv_info->addr.type = adv->tx_addr;
 1009020:	f3c3 1380 	ubfx	r3, r3, #6, #1
 1009024:	70ab      	strb	r3, [r5, #2]
		memcpy(&adv_info->addr.a.val[0], &adv->adv_ind.addr[0],
 1009026:	f104 0122 	add.w	r1, r4, #34	; 0x22
 100902a:	1ce8      	adds	r0, r5, #3
 100902c:	f00d fc44 	bl	10168b8 <memcpy>
 1009030:	e4c4      	b.n	10089bc <hci_evt_encode+0x1c4>
 1009032:	2700      	movs	r7, #0
 1009034:	220b      	movs	r2, #11
 1009036:	e4a4      	b.n	1008982 <hci_evt_encode+0x18a>
				if (dup_filter[i].mask & BIT(adv->type)) {
 1009038:	491b      	ldr	r1, [pc, #108]	; (10090a8 <hci_evt_encode+0x8b0>)
 100903a:	f002 020f 	and.w	r2, r2, #15
 100903e:	f811 3037 	ldrb.w	r3, [r1, r7, lsl #3]
 1009042:	fa23 f002 	lsr.w	r0, r3, r2
 1009046:	07c0      	lsls	r0, r0, #31
 1009048:	f53f ac11 	bmi.w	100886e <hci_evt_encode+0x76>
				dup_filter[i].mask |= BIT(adv->type);
 100904c:	2001      	movs	r0, #1
 100904e:	fa00 f202 	lsl.w	r2, r0, r2
 1009052:	4313      	orrs	r3, r2
 1009054:	f801 3037 	strb.w	r3, [r1, r7, lsl #3]
				return false;
 1009058:	e483      	b.n	1008962 <hci_evt_encode+0x16a>
		dir_info->addr.type = adv->tx_addr;
 100905a:	f894 3020 	ldrb.w	r3, [r4, #32]
		memcpy(&dir_info->addr.a.val[0], &adv->direct_ind.adv_addr[0],
 100905e:	2206      	movs	r2, #6
		dir_info->addr.type = adv->tx_addr;
 1009060:	f3c3 1380 	ubfx	r3, r3, #6, #1
 1009064:	70ab      	strb	r3, [r5, #2]
		memcpy(&dir_info->addr.a.val[0], &adv->direct_ind.adv_addr[0],
 1009066:	f104 0122 	add.w	r1, r4, #34	; 0x22
 100906a:	1ce8      	adds	r0, r5, #3
 100906c:	f00d fc24 	bl	10168b8 <memcpy>
 1009070:	e77f      	b.n	1008f72 <hci_evt_encode+0x77a>
				if (dup_filter[i].mask & BIT(adv->type)) {
 1009072:	480d      	ldr	r0, [pc, #52]	; (10090a8 <hci_evt_encode+0x8b0>)
 1009074:	f002 020f 	and.w	r2, r2, #15
 1009078:	f810 3037 	ldrb.w	r3, [r0, r7, lsl #3]
 100907c:	fa23 f102 	lsr.w	r1, r3, r2
 1009080:	07cd      	lsls	r5, r1, #31
 1009082:	f53f abf4 	bmi.w	100886e <hci_evt_encode+0x76>
				dup_filter[i].mask |= BIT(adv->type);
 1009086:	2101      	movs	r1, #1
 1009088:	fa01 f202 	lsl.w	r2, r1, r2
 100908c:	4313      	orrs	r3, r2
 100908e:	f800 3037 	strb.w	r3, [r0, r7, lsl #3]
				return false;
 1009092:	e759      	b.n	1008f48 <hci_evt_encode+0x750>
 1009094:	21000000 	.word	0x21000000
 1009098:	21000008 	.word	0x21000008
 100909c:	01018644 	.word	0x01018644
 10090a0:	21000c82 	.word	0x21000c82
 10090a4:	21000c7c 	.word	0x21000c7c
 10090a8:	21000c80 	.word	0x21000c80
 10090ac:	21000c78 	.word	0x21000c78

010090b0 <hci_num_cmplt_encode>:

#if defined(CONFIG_BT_CONN)
void hci_num_cmplt_encode(struct net_buf *buf, u16_t handle, u8_t num)
{
 10090b0:	b570      	push	{r4, r5, r6, lr}
	hdr = net_buf_add(buf, sizeof(*hdr));
 10090b2:	f100 0408 	add.w	r4, r0, #8
{
 10090b6:	460e      	mov	r6, r1
	hdr = net_buf_add(buf, sizeof(*hdr));
 10090b8:	4620      	mov	r0, r4
 10090ba:	2102      	movs	r1, #2
{
 10090bc:	4615      	mov	r5, r2
	hdr = net_buf_add(buf, sizeof(*hdr));
 10090be:	f00d fd00 	bl	1016ac2 <net_buf_simple_add>
	hdr->evt = evt;
 10090c2:	2213      	movs	r2, #19
	hdr = net_buf_add(buf, sizeof(*hdr));
 10090c4:	4603      	mov	r3, r0
	hdr->len = len;
 10090c6:	2105      	movs	r1, #5
	hdr->evt = evt;
 10090c8:	701a      	strb	r2, [r3, #0]
	hdr->len = len;
 10090ca:	7059      	strb	r1, [r3, #1]
	num_handles = 1U;

	len = (sizeof(*ep) + (sizeof(*hc) * num_handles));
	hci_evt_create(buf, BT_HCI_EVT_NUM_COMPLETED_PACKETS, len);

	ep = net_buf_add(buf, len);
 10090cc:	4620      	mov	r0, r4
 10090ce:	f00d fcf8 	bl	1016ac2 <net_buf_simple_add>
	ep->num_handles = num_handles;
 10090d2:	2301      	movs	r3, #1
 10090d4:	7003      	strb	r3, [r0, #0]
	hc = &ep->h[0];
	hc->handle = sys_cpu_to_le16(handle);
 10090d6:	f8a0 6001 	strh.w	r6, [r0, #1]
	hc->count = sys_cpu_to_le16(num);
 10090da:	f8a0 5003 	strh.w	r5, [r0, #3]
}
 10090de:	bd70      	pop	{r4, r5, r6, pc}

010090e0 <hci_get_class>:
{
#if defined(CONFIG_BT_CONN)
	struct pdu_data *pdu_data = PDU_DATA(node_rx);
#endif

	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
 10090e0:	7903      	ldrb	r3, [r0, #4]
 10090e2:	2b02      	cmp	r3, #2
 10090e4:	d008      	beq.n	10090f8 <hci_get_class+0x18>

		switch (node_rx->hdr.type) {
 10090e6:	3b04      	subs	r3, #4
 10090e8:	b2db      	uxtb	r3, r3
 10090ea:	2b0a      	cmp	r3, #10
 10090ec:	d901      	bls.n	10090f2 <hci_get_class+0x12>
	if (node_rx->hdr.type != NODE_RX_TYPE_DC_PDU) {
 10090ee:	2000      	movs	r0, #0
#else
	} else {
		return HCI_CLASS_NONE;
	}
#endif
}
 10090f0:	4770      	bx	lr
 10090f2:	4a06      	ldr	r2, [pc, #24]	; (100910c <hci_get_class+0x2c>)
 10090f4:	5cd0      	ldrb	r0, [r2, r3]
 10090f6:	4770      	bx	lr
	} else if (pdu_data->ll_id == PDU_DATA_LLID_CTRL) {
 10090f8:	f890 3020 	ldrb.w	r3, [r0, #32]
 10090fc:	f003 0303 	and.w	r3, r3, #3
 1009100:	2b03      	cmp	r3, #3
		return HCI_CLASS_ACL_DATA;
 1009102:	bf0c      	ite	eq
 1009104:	2004      	moveq	r0, #4
 1009106:	2005      	movne	r0, #5
 1009108:	4770      	bx	lr
 100910a:	bf00      	nop
 100910c:	010186c8 	.word	0x010186c8

01009110 <hci_init>:
void hci_init(struct k_poll_signal *signal_host_buf)
{
#if defined(CONFIG_BT_HCI_ACL_FLOW_CONTROL)
	hbuf_signal = signal_host_buf;
#endif
	reset(NULL, NULL);
 1009110:	2100      	movs	r1, #0
{
 1009112:	4602      	mov	r2, r0
	hbuf_signal = signal_host_buf;
 1009114:	4b02      	ldr	r3, [pc, #8]	; (1009120 <hci_init+0x10>)
	reset(NULL, NULL);
 1009116:	4608      	mov	r0, r1
	hbuf_signal = signal_host_buf;
 1009118:	601a      	str	r2, [r3, #0]
	reset(NULL, NULL);
 100911a:	f7fe bc71 	b.w	1007a00 <reset>
 100911e:	bf00      	nop
 1009120:	21000d00 	.word	0x21000d00

01009124 <bt_rand>:
#include "hal/ecb.h"
#include "lll.h"

int bt_rand(void *buf, size_t len)
{
	return lll_trng_get(buf, len);
 1009124:	f006 be16 	b.w	100fd54 <lll_trng_get>

01009128 <bt_encrypt_le>:
}

int bt_encrypt_le(const u8_t key[16], const u8_t plaintext[16],
		  u8_t enc_data[16])
{
 1009128:	b508      	push	{r3, lr}
	BT_DBG("key %s", bt_hex(key, 16));
	BT_DBG("plaintext %s", bt_hex(plaintext, 16));

	ecb_encrypt(key, plaintext, enc_data, NULL);
 100912a:	2300      	movs	r3, #0
 100912c:	f008 fc48 	bl	10119c0 <ecb_encrypt>

	BT_DBG("enc_data %s", bt_hex(enc_data, 16));

	return 0;
}
 1009130:	2000      	movs	r0, #0
 1009132:	bd08      	pop	{r3, pc}

01009134 <perform_lll_reset>:

	return 0;
}

static void perform_lll_reset(void *param)
{
 1009134:	b510      	push	{r4, lr}
 1009136:	4604      	mov	r4, r0
	int err;

	/* Reset LLL */
	err = lll_reset();
 1009138:	f006 fe2e 	bl	100fd98 <lll_reset>
	LL_ASSERT(!err);
 100913c:	b968      	cbnz	r0, 100915a <perform_lll_reset+0x26>

#if defined(CONFIG_BT_BROADCASTER)
	/* Reset adv state */
	err = lll_adv_reset();
 100913e:	f007 fb5f 	bl	1010800 <lll_adv_reset>
	LL_ASSERT(!err);
 1009142:	b998      	cbnz	r0, 100916c <perform_lll_reset+0x38>
#endif /* CONFIG_BT_BROADCASTER */

#if defined(CONFIG_BT_OBSERVER)
	/* Reset scan state */
	err = lll_scan_reset();
 1009144:	f007 fe06 	bl	1010d54 <lll_scan_reset>
	LL_ASSERT(!err);
 1009148:	b9c8      	cbnz	r0, 100917e <perform_lll_reset+0x4a>
#endif /* CONFIG_BT_OBSERVER */

#if defined(CONFIG_BT_CONN)
	/* Reset conn role */
	err = lll_conn_reset();
 100914a:	f007 fecb 	bl	1010ee4 <lll_conn_reset>
	LL_ASSERT(!err);
 100914e:	b9f8      	cbnz	r0, 1009190 <perform_lll_reset+0x5c>
	z_impl_k_sem_give(sem);
 1009150:	4620      	mov	r0, r4
#endif /* CONFIG_BT_CONN */

#if !defined(CONFIG_BT_CTLR_ZLI)
	k_sem_give(param);
#endif /* !CONFIG_BT_CTLR_ZLI */
}
 1009152:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 1009156:	f00b ba77 	b.w	1014648 <z_impl_k_sem_give>
	LL_ASSERT(!err);
 100915a:	f240 41cf 	movw	r1, #1231	; 0x4cf
 100915e:	4811      	ldr	r0, [pc, #68]	; (10091a4 <perform_lll_reset+0x70>)
 1009160:	f7fa fa12 	bl	1003588 <bt_ctlr_assert_handle>
	err = lll_adv_reset();
 1009164:	f007 fb4c 	bl	1010800 <lll_adv_reset>
	LL_ASSERT(!err);
 1009168:	2800      	cmp	r0, #0
 100916a:	d0eb      	beq.n	1009144 <perform_lll_reset+0x10>
 100916c:	f240 41d4 	movw	r1, #1236	; 0x4d4
 1009170:	480c      	ldr	r0, [pc, #48]	; (10091a4 <perform_lll_reset+0x70>)
 1009172:	f7fa fa09 	bl	1003588 <bt_ctlr_assert_handle>
	err = lll_scan_reset();
 1009176:	f007 fded 	bl	1010d54 <lll_scan_reset>
	LL_ASSERT(!err);
 100917a:	2800      	cmp	r0, #0
 100917c:	d0e5      	beq.n	100914a <perform_lll_reset+0x16>
 100917e:	f240 41da 	movw	r1, #1242	; 0x4da
 1009182:	4808      	ldr	r0, [pc, #32]	; (10091a4 <perform_lll_reset+0x70>)
 1009184:	f7fa fa00 	bl	1003588 <bt_ctlr_assert_handle>
	err = lll_conn_reset();
 1009188:	f007 feac 	bl	1010ee4 <lll_conn_reset>
	LL_ASSERT(!err);
 100918c:	2800      	cmp	r0, #0
 100918e:	d0df      	beq.n	1009150 <perform_lll_reset+0x1c>
 1009190:	f44f 619c 	mov.w	r1, #1248	; 0x4e0
 1009194:	4803      	ldr	r0, [pc, #12]	; (10091a4 <perform_lll_reset+0x70>)
 1009196:	f7fa f9f7 	bl	1003588 <bt_ctlr_assert_handle>
 100919a:	4620      	mov	r0, r4
}
 100919c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 10091a0:	f00b ba52 	b.w	1014648 <z_impl_k_sem_give>
 10091a4:	010186e4 	.word	0x010186e4

010091a8 <disabled_cb>:
 10091a8:	f00b ba4e 	b.w	1014648 <z_impl_k_sem_give>

010091ac <tx_cmplt_get>:
	}
}

#if defined(CONFIG_BT_CONN)
static u8_t tx_cmplt_get(u16_t *handle, u8_t *first, u8_t last)
{
 10091ac:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10091b0:	460d      	mov	r5, r1
 10091b2:	4692      	mov	sl, r2
	struct lll_tx *tx;
	u8_t cmplt;

	tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
 10091b4:	4f2e      	ldr	r7, [pc, #184]	; (1009270 <tx_cmplt_get+0xc4>)
					   u8_t first, u8_t last, u8_t *idx)
{
	void *p;
	u8_t i;

	if (*idx >= count) {
 10091b6:	7809      	ldrb	r1, [r1, #0]
 10091b8:	787c      	ldrb	r4, [r7, #1]
 10091ba:	783a      	ldrb	r2, [r7, #0]
 10091bc:	428c      	cmp	r4, r1
 10091be:	bf98      	it	ls
 10091c0:	78b9      	ldrbls	r1, [r7, #2]
{
 10091c2:	4683      	mov	fp, r0
		*idx = first;
 10091c4:	bf98      	it	ls
 10091c6:	7029      	strbls	r1, [r5, #0]
	}

	if (*idx == last) {
 10091c8:	458a      	cmp	sl, r1
				    mfifo_tx_ack.n, mfifo_tx_ack.f, last,
				    first);
	if (!tx) {
		return 0;
 10091ca:	f04f 0800 	mov.w	r8, #0
 10091ce:	d044      	beq.n	100925a <tx_cmplt_get+0xae>
		return NULL;
	}

	i = *idx + 1;
 10091d0:	1c4b      	adds	r3, r1, #1
 10091d2:	b2db      	uxtb	r3, r3
	if (i == count) {
		i = 0U;
 10091d4:	429c      	cmp	r4, r3
 10091d6:	bf08      	it	eq
 10091d8:	2300      	moveq	r3, #0
	}

	p = (void *)(fifo + (*idx) * size);
 10091da:	fb02 f101 	mul.w	r1, r2, r1
 10091de:	4e25      	ldr	r6, [pc, #148]	; (1009274 <tx_cmplt_get+0xc8>)

	*idx = i;
 10091e0:	702b      	strb	r3, [r5, #0]
	if (!tx) {
 10091e2:	1873      	adds	r3, r6, r1
 10091e4:	d039      	beq.n	100925a <tx_cmplt_get+0xae>
	}

	*handle = tx->handle;
 10091e6:	5a71      	ldrh	r1, [r6, r1]
 10091e8:	f04f 0901 	mov.w	r9, #1
 10091ec:	8001      	strh	r1, [r0, #0]
	cmplt = 0U;
 10091ee:	e020      	b.n	1009232 <tx_cmplt_get+0x86>
		    (((u32_t)node_tx & ~3) &&
		     (p->ll_id == PDU_DATA_LLID_DATA_START ||
		      p->ll_id == PDU_DATA_LLID_DATA_CONTINUE))) {
			/* data packet, hence count num cmplt */
			tx->node = (void *)1;
			cmplt++;
 10091f0:	f108 0801 	add.w	r8, r8, #1
 10091f4:	f8c3 9004 	str.w	r9, [r3, #4]
		} else {
			/* ctrl packet or flushed, hence dont count num cmplt */
			tx->node = (void *)2;
		}

		if (((u32_t)node_tx & ~3)) {
 10091f8:	f030 0303 	bics.w	r3, r0, #3
			cmplt++;
 10091fc:	fa5f f888 	uxtb.w	r8, r8
		if (((u32_t)node_tx & ~3)) {
 1009200:	d125      	bne.n	100924e <tx_cmplt_get+0xa2>
	if (*idx >= count) {
 1009202:	782c      	ldrb	r4, [r5, #0]
			ll_tx_mem_release(node_tx);
		}

		tx = mfifo_dequeue_iter_get(mfifo_tx_ack.m, mfifo_tx_ack.s,
 1009204:	7878      	ldrb	r0, [r7, #1]
 1009206:	7839      	ldrb	r1, [r7, #0]
 1009208:	42a0      	cmp	r0, r4
 100920a:	bf9c      	itt	ls
 100920c:	78bc      	ldrbls	r4, [r7, #2]
		*idx = first;
 100920e:	702c      	strbls	r4, [r5, #0]
	if (*idx == last) {
 1009210:	45a2      	cmp	sl, r4
 1009212:	d022      	beq.n	100925a <tx_cmplt_get+0xae>
	i = *idx + 1;
 1009214:	1c63      	adds	r3, r4, #1
 1009216:	b2db      	uxtb	r3, r3
		i = 0U;
 1009218:	4298      	cmp	r0, r3
 100921a:	bf08      	it	eq
 100921c:	2300      	moveq	r3, #0
	p = (void *)(fifo + (*idx) * size);
 100921e:	fb01 f404 	mul.w	r4, r1, r4
	*idx = i;
 1009222:	702b      	strb	r3, [r5, #0]
					    mfifo_tx_ack.n, mfifo_tx_ack.f,
					    last, first);
	} while (tx && tx->handle == *handle);
 1009224:	1933      	adds	r3, r6, r4
 1009226:	d018      	beq.n	100925a <tx_cmplt_get+0xae>
 1009228:	5b30      	ldrh	r0, [r6, r4]
 100922a:	f8bb 1000 	ldrh.w	r1, [fp]
 100922e:	4288      	cmp	r0, r1
 1009230:	d113      	bne.n	100925a <tx_cmplt_get+0xae>
		node_tx = tx->node;
 1009232:	6858      	ldr	r0, [r3, #4]
		if (!node_tx || (node_tx == (void *)1) ||
 1009234:	2801      	cmp	r0, #1
 1009236:	d9db      	bls.n	10091f0 <tx_cmplt_get+0x44>
 1009238:	f030 0203 	bics.w	r2, r0, #3
 100923c:	d00a      	beq.n	1009254 <tx_cmplt_get+0xa8>
		     (p->ll_id == PDU_DATA_LLID_DATA_START ||
 100923e:	7901      	ldrb	r1, [r0, #4]
 1009240:	f001 0103 	and.w	r1, r1, #3
		    (((u32_t)node_tx & ~3) &&
 1009244:	3901      	subs	r1, #1
 1009246:	2901      	cmp	r1, #1
 1009248:	d90a      	bls.n	1009260 <tx_cmplt_get+0xb4>
 100924a:	2202      	movs	r2, #2
 100924c:	605a      	str	r2, [r3, #4]
			ll_tx_mem_release(node_tx);
 100924e:	f002 f9a1 	bl	100b594 <ll_tx_mem_release>
 1009252:	e7d6      	b.n	1009202 <tx_cmplt_get+0x56>
 1009254:	2202      	movs	r2, #2
 1009256:	605a      	str	r2, [r3, #4]
		if (((u32_t)node_tx & ~3)) {
 1009258:	e7d3      	b.n	1009202 <tx_cmplt_get+0x56>

	return cmplt;
}
 100925a:	4640      	mov	r0, r8
 100925c:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
			cmplt++;
 1009260:	f108 0801 	add.w	r8, r8, #1
 1009264:	fa5f f888 	uxtb.w	r8, r8
 1009268:	f8c3 9004 	str.w	r9, [r3, #4]
		if (((u32_t)node_tx & ~3)) {
 100926c:	e7ef      	b.n	100924e <tx_cmplt_get+0xa2>
 100926e:	bf00      	nop
 1009270:	21000228 	.word	0x21000228
 1009274:	2100022c 	.word	0x2100022c

01009278 <rx_demux>:
		}
}
#endif /* CONFIG_BT_CONN */

static void rx_demux(void *param)
{
 1009278:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100927c:	4ead      	ldr	r6, [pc, #692]	; (1009534 <rx_demux+0x2bc>)
	k_sem_give(sem_recv);
 100927e:	f8df 82d0 	ldr.w	r8, [pc, #720]	; 1009550 <rx_demux+0x2d8>
#if defined(CONFIG_BT_CTLR_USER_EXT)
		/* Try proprietary demuxing */
		rx_demux_rx_proprietary(link, rx, memq_ull_rx.tail,
					&memq_ull_rx.head);
#else
		LL_ASSERT(0);
 1009282:	f8df a2d0 	ldr.w	sl, [pc, #720]	; 1009554 <rx_demux+0x2dc>
{
 1009286:	b089      	sub	sp, #36	; 0x24
		link = memq_peek(memq_ull_rx.head, memq_ull_rx.tail,
 1009288:	aa05      	add	r2, sp, #20
 100928a:	e9d6 0100 	ldrd	r0, r1, [r6]
 100928e:	f7fc fd33 	bl	1005cf8 <memq_peek>
		if (link) {
 1009292:	4605      	mov	r5, r0
 1009294:	2800      	cmp	r0, #0
 1009296:	d040      	beq.n	100931a <rx_demux+0xa2>
			LL_ASSERT(rx);
 1009298:	9b05      	ldr	r3, [sp, #20]
 100929a:	2b00      	cmp	r3, #0
 100929c:	f000 8117 	beq.w	10094ce <rx_demux+0x256>
			link_tx = ull_conn_ack_by_last_peek(rx->ack_last,
 10092a0:	7818      	ldrb	r0, [r3, #0]
 10092a2:	aa06      	add	r2, sp, #24
 10092a4:	a904      	add	r1, sp, #16
 10092a6:	f004 fc99 	bl	100dbdc <ull_conn_ack_by_last_peek>
			if (link_tx) {
 10092aa:	4604      	mov	r4, r0
 10092ac:	2800      	cmp	r0, #0
 10092ae:	d06a      	beq.n	1009386 <rx_demux+0x10e>
				rx_demux_conn_tx_ack(rx->ack_last, handle,
 10092b0:	e9dd 1205 	ldrd	r1, r2, [sp, #20]
 10092b4:	f8bd 3010 	ldrh.w	r3, [sp, #16]
 10092b8:	f891 b000 	ldrb.w	fp, [r1]
 10092bc:	f10d 091c 	add.w	r9, sp, #28
 10092c0:	9207      	str	r2, [sp, #28]
 10092c2:	f8ad 3012 	strh.w	r3, [sp, #18]
static inline void rx_demux_conn_tx_ack(u8_t ack_last, u16_t handle,
 10092c6:	f10d 0712 	add.w	r7, sp, #18
		ull_conn_ack_dequeue();
 10092ca:	f004 fc9d 	bl	100dc08 <ull_conn_ack_dequeue>
		conn = ull_conn_tx_ack(handle, link, node_tx);
 10092ce:	4621      	mov	r1, r4
 10092d0:	9a07      	ldr	r2, [sp, #28]
 10092d2:	f8bd 0012 	ldrh.w	r0, [sp, #18]
 10092d6:	f004 fcd3 	bl	100dc80 <ull_conn_tx_ack>
 10092da:	4605      	mov	r5, r0
		ull_conn_link_tx_release(link);
 10092dc:	4620      	mov	r0, r4
 10092de:	f004 fc57 	bl	100db90 <ull_conn_link_tx_release>
		ull_conn_tx_demux(1);
 10092e2:	2001      	movs	r0, #1
 10092e4:	f004 f8ee 	bl	100d4c4 <ull_conn_tx_demux>
		if (conn) {
 10092e8:	b11d      	cbz	r5, 10092f2 <rx_demux+0x7a>
			ull_conn_tx_lll_enqueue(conn, 1);
 10092ea:	4628      	mov	r0, r5
 10092ec:	2101      	movs	r1, #1
 10092ee:	f004 fb67 	bl	100d9c0 <ull_conn_tx_lll_enqueue>
		link = ull_conn_ack_by_last_peek(ack_last, &handle, &node_tx);
 10092f2:	464a      	mov	r2, r9
 10092f4:	4639      	mov	r1, r7
 10092f6:	4658      	mov	r0, fp
 10092f8:	f004 fc70 	bl	100dbdc <ull_conn_ack_by_last_peek>
	} while (link);
 10092fc:	4604      	mov	r4, r0
 10092fe:	2800      	cmp	r0, #0
 1009300:	d1e3      	bne.n	10092ca <rx_demux+0x52>
	k_sem_give(sem_recv);
 1009302:	f8d8 0000 	ldr.w	r0, [r8]
 1009306:	f00b f99f 	bl	1014648 <z_impl_k_sem_give>
		link = memq_peek(memq_ull_rx.head, memq_ull_rx.tail,
 100930a:	e9d6 0100 	ldrd	r0, r1, [r6]
 100930e:	aa05      	add	r2, sp, #20
 1009310:	f7fc fcf2 	bl	1005cf8 <memq_peek>
		if (link) {
 1009314:	4605      	mov	r5, r0
 1009316:	2800      	cmp	r0, #0
 1009318:	d1be      	bne.n	1009298 <rx_demux+0x20>
			link = ull_conn_ack_peek(&ack_last, &handle, &node_tx);
 100931a:	aa06      	add	r2, sp, #24
 100931c:	a904      	add	r1, sp, #16
 100931e:	f10d 000f 	add.w	r0, sp, #15
 1009322:	f004 fc41 	bl	100dba8 <ull_conn_ack_peek>
			if (link) {
 1009326:	4604      	mov	r4, r0
 1009328:	2800      	cmp	r0, #0
 100932a:	d062      	beq.n	10093f2 <rx_demux+0x17a>
				rx_demux_conn_tx_ack(ack_last, handle,
 100932c:	9a06      	ldr	r2, [sp, #24]
 100932e:	f8bd 3010 	ldrh.w	r3, [sp, #16]
 1009332:	f89d b00f 	ldrb.w	fp, [sp, #15]
 1009336:	9207      	str	r2, [sp, #28]
 1009338:	f8ad 3012 	strh.w	r3, [sp, #18]
static inline void rx_demux_conn_tx_ack(u8_t ack_last, u16_t handle,
 100933c:	f10d 091c 	add.w	r9, sp, #28
 1009340:	f10d 0712 	add.w	r7, sp, #18
		ull_conn_ack_dequeue();
 1009344:	f004 fc60 	bl	100dc08 <ull_conn_ack_dequeue>
		conn = ull_conn_tx_ack(handle, link, node_tx);
 1009348:	4621      	mov	r1, r4
 100934a:	9a07      	ldr	r2, [sp, #28]
 100934c:	f8bd 0012 	ldrh.w	r0, [sp, #18]
 1009350:	f004 fc96 	bl	100dc80 <ull_conn_tx_ack>
 1009354:	4605      	mov	r5, r0
		ull_conn_link_tx_release(link);
 1009356:	4620      	mov	r0, r4
 1009358:	f004 fc1a 	bl	100db90 <ull_conn_link_tx_release>
		ull_conn_tx_demux(1);
 100935c:	2001      	movs	r0, #1
 100935e:	f004 f8b1 	bl	100d4c4 <ull_conn_tx_demux>
		if (conn) {
 1009362:	b11d      	cbz	r5, 100936c <rx_demux+0xf4>
			ull_conn_tx_lll_enqueue(conn, 1);
 1009364:	4628      	mov	r0, r5
 1009366:	2101      	movs	r1, #1
 1009368:	f004 fb2a 	bl	100d9c0 <ull_conn_tx_lll_enqueue>
		link = ull_conn_ack_by_last_peek(ack_last, &handle, &node_tx);
 100936c:	464a      	mov	r2, r9
 100936e:	4639      	mov	r1, r7
 1009370:	4658      	mov	r0, fp
 1009372:	f004 fc33 	bl	100dbdc <ull_conn_ack_by_last_peek>
	} while (link);
 1009376:	4604      	mov	r4, r0
 1009378:	2800      	cmp	r0, #0
 100937a:	d1e3      	bne.n	1009344 <rx_demux+0xcc>
	k_sem_give(sem_recv);
 100937c:	f8d8 0000 	ldr.w	r0, [r8]
 1009380:	f00b f962 	bl	1014648 <z_impl_k_sem_give>
			if (nack) {
 1009384:	e7c1      	b.n	100930a <rx_demux+0x92>
				nack = rx_demux_rx(link, rx);
 1009386:	9b05      	ldr	r3, [sp, #20]
 1009388:	9307      	str	r3, [sp, #28]
	switch (rx->type) {
 100938a:	791b      	ldrb	r3, [r3, #4]
 100938c:	3b01      	subs	r3, #1
 100938e:	2b08      	cmp	r3, #8
 1009390:	d818      	bhi.n	10093c4 <rx_demux+0x14c>
 1009392:	e8df f003 	tbb	[pc, r3]
 1009396:	2731      	.short	0x2731
 1009398:	17170517 	.word	0x17170517
 100939c:	1d17      	.short	0x1d17
 100939e:	05          	.byte	0x05
 100939f:	00          	.byte	0x00
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
 10093a0:	4964      	ldr	r1, [pc, #400]	; (1009534 <rx_demux+0x2bc>)
 10093a2:	2200      	movs	r2, #0
 10093a4:	6870      	ldr	r0, [r6, #4]
 10093a6:	f7fc fcaf 	bl	1005d08 <memq_dequeue>
	memq_enqueue(link, rx, &memq_ll_rx.tail);
 10093aa:	4628      	mov	r0, r5
	rx_hdr->ack_last = mfifo_tx_ack.l;
 10093ac:	4b62      	ldr	r3, [pc, #392]	; (1009538 <rx_demux+0x2c0>)
		ll_rx_put(link, rx);
 10093ae:	9907      	ldr	r1, [sp, #28]
	rx_hdr->ack_last = mfifo_tx_ack.l;
 10093b0:	78db      	ldrb	r3, [r3, #3]
	memq_enqueue(link, rx, &memq_ll_rx.tail);
 10093b2:	4a62      	ldr	r2, [pc, #392]	; (100953c <rx_demux+0x2c4>)
	rx_hdr->ack_last = mfifo_tx_ack.l;
 10093b4:	700b      	strb	r3, [r1, #0]
	memq_enqueue(link, rx, &memq_ll_rx.tail);
 10093b6:	f7fc fc97 	bl	1005ce8 <memq_enqueue>
	k_sem_give(sem_recv);
 10093ba:	f8d8 0000 	ldr.w	r0, [r8]
 10093be:	f00b f943 	bl	1014648 <z_impl_k_sem_give>
			if (nack) {
 10093c2:	e7a2      	b.n	100930a <rx_demux+0x92>
		LL_ASSERT(0);
 10093c4:	f240 6162 	movw	r1, #1634	; 0x662
 10093c8:	4650      	mov	r0, sl
 10093ca:	f7fa f8dd 	bl	1003588 <bt_ctlr_assert_handle>
			if (nack) {
 10093ce:	e75b      	b.n	1009288 <rx_demux+0x10>
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
 10093d0:	2200      	movs	r2, #0
 10093d2:	4958      	ldr	r1, [pc, #352]	; (1009534 <rx_demux+0x2bc>)
 10093d4:	6870      	ldr	r0, [r6, #4]
 10093d6:	f7fc fc97 	bl	1005d08 <memq_dequeue>
		ull_conn_setup(link, rx);
 10093da:	4628      	mov	r0, r5
 10093dc:	9907      	ldr	r1, [sp, #28]
 10093de:	f002 fc43 	bl	100bc68 <ull_conn_setup>
			if (nack) {
 10093e2:	e751      	b.n	1009288 <rx_demux+0x10>
		nack = ull_conn_rx(link, (void *)&rx);
 10093e4:	4628      	mov	r0, r5
 10093e6:	a907      	add	r1, sp, #28
 10093e8:	f002 fc4e 	bl	100bc88 <ull_conn_rx>
		if (nack) {
 10093ec:	2800      	cmp	r0, #0
 10093ee:	f000 808e 	beq.w	100950e <rx_demux+0x296>
}
 10093f2:	b009      	add	sp, #36	; 0x24
 10093f4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
 10093f8:	2200      	movs	r2, #0
 10093fa:	494e      	ldr	r1, [pc, #312]	; (1009534 <rx_demux+0x2bc>)
 10093fc:	6870      	ldr	r0, [r6, #4]
 10093fe:	f7fc fc83 	bl	1005d08 <memq_dequeue>
		rx_demux_event_done(link, rx);
 1009402:	9c07      	ldr	r4, [sp, #28]

	/* Get the ull instance */
	ull_hdr = done->param;

	/* Process role dependent event done */
	switch (done->extra.type) {
 1009404:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
	ull_hdr = done->param;
 1009408:	f8d4 9020 	ldr.w	r9, [r4, #32]
	switch (done->extra.type) {
 100940c:	b133      	cbz	r3, 100941c <rx_demux+0x1a4>
 100940e:	2b01      	cmp	r3, #1
 1009410:	d079      	beq.n	1009506 <rx_demux+0x28e>
	case EVENT_DONE_EXTRA_TYPE_NONE:
		/* ignore */
		break;

	default:
		LL_ASSERT(0);
 1009412:	f240 618a 	movw	r1, #1674	; 0x68a
 1009416:	4650      	mov	r0, sl
 1009418:	f7fa f8b6 	bl	1003588 <bt_ctlr_assert_handle>
		break;
	}

	/* release done */
	done->extra.type = 0U;
 100941c:	2700      	movs	r7, #0
	if (!MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
 100941e:	4a48      	ldr	r2, [pc, #288]	; (1009540 <rx_demux+0x2c8>)
	done->extra.type = 0U;
 1009420:	f884 7024 	strb.w	r7, [r4, #36]	; 0x24
	if (!MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
 1009424:	78d0      	ldrb	r0, [r2, #3]
	if (last == count) {
 1009426:	7851      	ldrb	r1, [r2, #1]
	last = last + 1;
 1009428:	1c43      	adds	r3, r0, #1
 100942a:	b2db      	uxtb	r3, r3
		last = 0U;
 100942c:	4299      	cmp	r1, r3
 100942e:	bf08      	it	eq
 1009430:	463b      	moveq	r3, r7
 1009432:	7891      	ldrb	r1, [r2, #2]
	if (last == first) {
 1009434:	4299      	cmp	r1, r3
 1009436:	d077      	beq.n	1009528 <rx_demux+0x2b0>
	done->hdr.link = link;
 1009438:	6025      	str	r5, [r4, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 100943a:	7811      	ldrb	r1, [r2, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 100943c:	fb00 2101 	mla	r1, r0, r1, r2
 1009440:	604c      	str	r4, [r1, #4]
	*last = idx; /* Commit: Update write index */
 1009442:	70d3      	strb	r3, [r2, #3]
	return MFIFO_DEQUEUE_GET(prep);
 1009444:	4d3f      	ldr	r5, [pc, #252]	; (1009544 <rx_demux+0x2cc>)
 1009446:	78ab      	ldrb	r3, [r5, #2]
	if (first == last) {
 1009448:	78ea      	ldrb	r2, [r5, #3]
 100944a:	782c      	ldrb	r4, [r5, #0]
 100944c:	429a      	cmp	r2, r3
 100944e:	d026      	beq.n	100949e <rx_demux+0x226>
	return (void *)(fifo + first * size);
 1009450:	4a3d      	ldr	r2, [pc, #244]	; (1009548 <rx_demux+0x2d0>)
 1009452:	fb04 2403 	mla	r4, r4, r3, r2
	release = done_release(link, done);
	LL_ASSERT(release == done);

	/* dequeue prepare pipeline */
	next = ull_prepare_dequeue_get();
	while (next) {
 1009456:	b314      	cbz	r4, 100949e <rx_demux+0x226>
		u8_t is_aborted = next->is_aborted;
 1009458:	f894 3020 	ldrb.w	r3, [r4, #32]
		u8_t is_resume = next->is_resume;
 100945c:	f003 0201 	and.w	r2, r3, #1
 1009460:	9201      	str	r2, [sp, #4]

		if (!is_aborted) {
 1009462:	079a      	lsls	r2, r3, #30
		u8_t is_aborted = next->is_aborted;
 1009464:	f3c3 0b40 	ubfx	fp, r3, #1, #1
		if (!is_aborted) {
 1009468:	d538      	bpl.n	10094dc <rx_demux+0x264>
			ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
					     TICKER_USER_ID_LLL, 0, &mfy);
			LL_ASSERT(!ret);
		}

		MFIFO_DEQUEUE(prep);
 100946a:	78ea      	ldrb	r2, [r5, #3]
 * @return              Head buffer; or NULL if queue was empty
 */
static inline void *mfifo_dequeue(u8_t *fifo, u8_t size, u8_t count,
				  u8_t last, u8_t *first)
{
	u8_t _first = *first; /* Copy read-index */
 100946c:	78ab      	ldrb	r3, [r5, #2]
 100946e:	782c      	ldrb	r4, [r5, #0]
	void *mem;

	/* Queue is empty if first == last */
	if (_first == last) {
 1009470:	429a      	cmp	r2, r3
 1009472:	7869      	ldrb	r1, [r5, #1]
 1009474:	d013      	beq.n	100949e <rx_demux+0x226>
	 * API 2: fifo is array of void-ptrs
	 */
	mem = *((void **)(fifo + _first * size));

	/* Circular buffer increment read-index modulo 'count' */
	_first += 1U;
 1009476:	3301      	adds	r3, #1
 1009478:	b2db      	uxtb	r3, r3
	if (_first == count) {
 100947a:	4299      	cmp	r1, r3
 100947c:	d03d      	beq.n	10094fa <rx_demux+0x282>
	if (first == last) {
 100947e:	429a      	cmp	r2, r3
		_first = 0U;
	}

	*first = _first; /* Write back read-index */
 1009480:	70ab      	strb	r3, [r5, #2]
	if (first == last) {
 1009482:	d00c      	beq.n	100949e <rx_demux+0x226>
	return (void *)(fifo + first * size);
 1009484:	4a30      	ldr	r2, [pc, #192]	; (1009548 <rx_demux+0x2d0>)
 1009486:	fb04 2403 	mla	r4, r4, r3, r2

		next = ull_prepare_dequeue_get();

		if (!next || (!is_aborted && (!is_resume || next->is_resume))) {
 100948a:	b144      	cbz	r4, 100949e <rx_demux+0x226>
 100948c:	f1bb 0f00 	cmp.w	fp, #0
 1009490:	d1e2      	bne.n	1009458 <rx_demux+0x1e0>
 1009492:	9b01      	ldr	r3, [sp, #4]
 1009494:	b11b      	cbz	r3, 100949e <rx_demux+0x226>
 1009496:	f894 3020 	ldrb.w	r3, [r4, #32]
 100949a:	07db      	lsls	r3, r3, #31
 100949c:	d5dc      	bpl.n	1009458 <rx_demux+0x1e0>
			break;
		}
	}

	/* ull instance will resume, dont decrement ref */
	if (!ull_hdr) {
 100949e:	f1b9 0f00 	cmp.w	r9, #0
 10094a2:	f43f aef1 	beq.w	1009288 <rx_demux+0x10>
		return;
	}

	/* Decrement prepare reference */
	LL_ASSERT(ull_hdr->ref);
 10094a6:	f899 3000 	ldrb.w	r3, [r9]
 10094aa:	2b00      	cmp	r3, #0
 10094ac:	d054      	beq.n	1009558 <rx_demux+0x2e0>
	return hdr->ref--;
 10094ae:	3b01      	subs	r3, #1
 10094b0:	b2db      	uxtb	r3, r3
 10094b2:	f889 3000 	strb.w	r3, [r9]
	ull_ref_dec(ull_hdr);

	/* If disable initiated, signal the semaphore */
	if (!ull_hdr->ref && ull_hdr->disabled_cb) {
 10094b6:	2b00      	cmp	r3, #0
 10094b8:	f47f aee6 	bne.w	1009288 <rx_demux+0x10>
 10094bc:	f8d9 3004 	ldr.w	r3, [r9, #4]
 10094c0:	2b00      	cmp	r3, #0
 10094c2:	f43f aee1 	beq.w	1009288 <rx_demux+0x10>
		ull_hdr->disabled_cb(ull_hdr->disabled_param);
 10094c6:	f8d9 0008 	ldr.w	r0, [r9, #8]
 10094ca:	4798      	blx	r3
			if (nack) {
 10094cc:	e6dc      	b.n	1009288 <rx_demux+0x10>
			LL_ASSERT(rx);
 10094ce:	f240 51d1 	movw	r1, #1489	; 0x5d1
 10094d2:	4650      	mov	r0, sl
 10094d4:	f7fa f858 	bl	1003588 <bt_ctlr_assert_handle>
 10094d8:	9b05      	ldr	r3, [sp, #20]
 10094da:	e6e1      	b.n	10092a0 <rx_demux+0x28>
			ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 10094dc:	4b1b      	ldr	r3, [pc, #108]	; (100954c <rx_demux+0x2d4>)
 10094de:	465a      	mov	r2, fp
 10094e0:	4659      	mov	r1, fp
 10094e2:	2001      	movs	r0, #1
			mfy.param = next;
 10094e4:	609c      	str	r4, [r3, #8]
			ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 10094e6:	f7fc fc73 	bl	1005dd0 <mayfly_enqueue>
			LL_ASSERT(!ret);
 10094ea:	2800      	cmp	r0, #0
 10094ec:	d0bd      	beq.n	100946a <rx_demux+0x1f2>
 10094ee:	f240 61a2 	movw	r1, #1698	; 0x6a2
 10094f2:	4650      	mov	r0, sl
 10094f4:	f7fa f848 	bl	1003588 <bt_ctlr_assert_handle>
 10094f8:	e7b7      	b.n	100946a <rx_demux+0x1f2>
	*first = _first; /* Write back read-index */
 10094fa:	2300      	movs	r3, #0
 10094fc:	70ab      	strb	r3, [r5, #2]
	if (first == last) {
 10094fe:	2a00      	cmp	r2, #0
 1009500:	d0cd      	beq.n	100949e <rx_demux+0x226>
	return (void *)(fifo + first * size);
 1009502:	4c11      	ldr	r4, [pc, #68]	; (1009548 <rx_demux+0x2d0>)
 1009504:	e7c2      	b.n	100948c <rx_demux+0x214>
		ull_conn_done(done);
 1009506:	4620      	mov	r0, r4
 1009508:	f004 f8c4 	bl	100d694 <ull_conn_done>
		break;
 100950c:	e786      	b.n	100941c <rx_demux+0x1a4>
		memq_dequeue(memq_ull_rx.tail, &memq_ull_rx.head, NULL);
 100950e:	4602      	mov	r2, r0
 1009510:	4908      	ldr	r1, [pc, #32]	; (1009534 <rx_demux+0x2bc>)
 1009512:	6870      	ldr	r0, [r6, #4]
 1009514:	f7fc fbf8 	bl	1005d08 <memq_dequeue>
		if (rx) {
 1009518:	9907      	ldr	r1, [sp, #28]
 100951a:	2900      	cmp	r1, #0
 100951c:	f43f aeb4 	beq.w	1009288 <rx_demux+0x10>
	rx_hdr->ack_last = mfifo_tx_ack.l;
 1009520:	4b05      	ldr	r3, [pc, #20]	; (1009538 <rx_demux+0x2c0>)
	memq_enqueue(link, rx, &memq_ll_rx.tail);
 1009522:	4628      	mov	r0, r5
	rx_hdr->ack_last = mfifo_tx_ack.l;
 1009524:	78db      	ldrb	r3, [r3, #3]
 1009526:	e744      	b.n	10093b2 <rx_demux+0x13a>
	LL_ASSERT(release == done);
 1009528:	f240 6191 	movw	r1, #1681	; 0x691
 100952c:	4650      	mov	r0, sl
 100952e:	f7fa f82b 	bl	1003588 <bt_ctlr_assert_handle>
 1009532:	e787      	b.n	1009444 <rx_demux+0x1cc>
 1009534:	21001350 	.word	0x21001350
 1009538:	21000228 	.word	0x21000228
 100953c:	2100134c 	.word	0x2100134c
 1009540:	210000b0 	.word	0x210000b0
 1009544:	21000104 	.word	0x21000104
 1009548:	21000108 	.word	0x21000108
 100954c:	2100029c 	.word	0x2100029c
 1009550:	21001358 	.word	0x21001358
 1009554:	010186e4 	.word	0x010186e4
	LL_ASSERT(ull_hdr->ref);
 1009558:	f240 61b4 	movw	r1, #1716	; 0x6b4
 100955c:	4650      	mov	r0, sl
 100955e:	f7fa f813 	bl	1003588 <bt_ctlr_assert_handle>
 1009562:	f899 3000 	ldrb.w	r3, [r9]
 1009566:	3b01      	subs	r3, #1
 1009568:	b2db      	uxtb	r3, r3
 100956a:	f889 3000 	strb.w	r3, [r9]
	if (!ull_hdr->ref && ull_hdr->disabled_cb) {
 100956e:	2b00      	cmp	r3, #0
 1009570:	f47f ae8a 	bne.w	1009288 <rx_demux+0x10>
 1009574:	e7a2      	b.n	10094bc <rx_demux+0x244>
 1009576:	bf00      	nop

01009578 <ll_init>:
{
 1009578:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	sem_recv = sem_rx;
 100957c:	4b93      	ldr	r3, [pc, #588]	; (10097cc <ll_init+0x254>)
{
 100957e:	b086      	sub	sp, #24
	sem_recv = sem_rx;
 1009580:	6018      	str	r0, [r3, #0]
	cntr_init();
 1009582:	f008 f9ad 	bl	10118e0 <cntr_init>
	mayfly_init();
 1009586:	f7fc fbcf 	bl	1005d28 <mayfly_init>
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
 100958a:	210b      	movs	r1, #11
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
 100958c:	2003      	movs	r0, #3
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
 100958e:	2502      	movs	r5, #2
	ticker_users[MAYFLY_CALL_ID_1][0] = TICKER_USER_ULL_HIGH_OPS;
 1009590:	2304      	movs	r3, #4
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
 1009592:	4c8f      	ldr	r4, [pc, #572]	; (10097d0 <ll_init+0x258>)
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
 1009594:	4a8f      	ldr	r2, [pc, #572]	; (10097d4 <ll_init+0x25c>)
 1009596:	e9cd 4100 	strd	r4, r1, [sp]
 100959a:	9205      	str	r2, [sp, #20]
 100959c:	498e      	ldr	r1, [pc, #568]	; (10097d8 <ll_init+0x260>)
 100959e:	4a8f      	ldr	r2, [pc, #572]	; (10097dc <ll_init+0x264>)
 10095a0:	e9cd 2103 	strd	r2, r1, [sp, #12]
 10095a4:	4a8e      	ldr	r2, [pc, #568]	; (10097e0 <ll_init+0x268>)
	ticker_users[MAYFLY_CALL_ID_1][0] = TICKER_USER_ULL_HIGH_OPS;
 10095a6:	7223      	strb	r3, [r4, #8]
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
 10095a8:	2115      	movs	r1, #21
 10095aa:	9202      	str	r2, [sp, #8]
	ticker_users[MAYFLY_CALL_ID_0][0] = TICKER_USER_LLL_OPS;
 10095ac:	7020      	strb	r0, [r4, #0]
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
 10095ae:	4a8d      	ldr	r2, [pc, #564]	; (10097e4 <ll_init+0x26c>)
 10095b0:	2000      	movs	r0, #0
	ticker_users[MAYFLY_CALL_ID_2][0] = TICKER_USER_ULL_LOW_OPS;
 10095b2:	7425      	strb	r5, [r4, #16]
	ticker_users[MAYFLY_CALL_ID_PROGRAM][0] = TICKER_USER_APP_OPS;
 10095b4:	7625      	strb	r5, [r4, #24]
	err = ticker_init(TICKER_INSTANCE_ID_CTLR,
 10095b6:	f7fd fd2d 	bl	1007014 <ticker_init>
	LL_ASSERT(!err);
 10095ba:	2800      	cmp	r0, #0
 10095bc:	f040 80ef 	bne.w	100979e <ll_init+0x226>
	return z_impl_k_sem_init(sem, initial_count, limit);
 10095c0:	2201      	movs	r2, #1
 10095c2:	2100      	movs	r1, #0
 10095c4:	4888      	ldr	r0, [pc, #544]	; (10097e8 <ll_init+0x270>)
 10095c6:	f00e fa7f 	bl	1017ac8 <z_impl_k_sem_init>
	err = lll_init();
 10095ca:	f006 fb91 	bl	100fcf0 <lll_init>
	if (err) {
 10095ce:	4604      	mov	r4, r0
 10095d0:	b118      	cbz	r0, 10095da <ll_init+0x62>
}
 10095d2:	4620      	mov	r0, r4
 10095d4:	b006      	add	sp, #24
 10095d6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	mem_init(mem_done.pool, sizeof(struct node_rx_event_done),
 10095da:	4b84      	ldr	r3, [pc, #528]	; (10097ec <ll_init+0x274>)
 10095dc:	2203      	movs	r2, #3
 10095de:	1d18      	adds	r0, r3, #4
 10095e0:	2138      	movs	r1, #56	; 0x38
 10095e2:	f7fc faef 	bl	1005bc4 <mem_init>
	mem_init(mem_link_done.pool, sizeof(memq_link_t), EVENT_DONE_MAX,
 10095e6:	4b82      	ldr	r3, [pc, #520]	; (10097f0 <ll_init+0x278>)
 10095e8:	4d82      	ldr	r5, [pc, #520]	; (10097f4 <ll_init+0x27c>)
 10095ea:	2203      	movs	r2, #3
 10095ec:	2108      	movs	r1, #8
 10095ee:	1d18      	adds	r0, r3, #4
 10095f0:	f7fc fae8 	bl	1005bc4 <mem_init>
		link = mem_acquire(&mem_link_done.free);
 10095f4:	f8df 81f8 	ldr.w	r8, [pc, #504]	; 10097f0 <ll_init+0x278>
 10095f8:	78ec      	ldrb	r4, [r5, #3]
		rx = mem_acquire(&mem_done.free);
 10095fa:	4f7c      	ldr	r7, [pc, #496]	; (10097ec <ll_init+0x274>)
	if (last == count) {
 10095fc:	786b      	ldrb	r3, [r5, #1]
	last = last + 1;
 10095fe:	3401      	adds	r4, #1
 1009600:	b2e4      	uxtb	r4, r4
		last = 0U;
 1009602:	42a3      	cmp	r3, r4
 1009604:	bf08      	it	eq
 1009606:	2400      	moveq	r4, #0
	while (MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
 1009608:	78ab      	ldrb	r3, [r5, #2]
	if (last == first) {
 100960a:	429c      	cmp	r4, r3
 100960c:	d014      	beq.n	1009638 <ll_init+0xc0>
		link = mem_acquire(&mem_link_done.free);
 100960e:	4640      	mov	r0, r8
 1009610:	f7fc fb06 	bl	1005c20 <mem_acquire>
		if (!link) {
 1009614:	4606      	mov	r6, r0
 1009616:	b178      	cbz	r0, 1009638 <ll_init+0xc0>
		rx = mem_acquire(&mem_done.free);
 1009618:	4638      	mov	r0, r7
 100961a:	f7fc fb01 	bl	1005c20 <mem_acquire>
		if (!rx) {
 100961e:	b138      	cbz	r0, 1009630 <ll_init+0xb8>
		rx->link = link;
 1009620:	6006      	str	r6, [r0, #0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 1009622:	78eb      	ldrb	r3, [r5, #3]
 1009624:	782a      	ldrb	r2, [r5, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 1009626:	fb02 5303 	mla	r3, r2, r3, r5
 100962a:	6058      	str	r0, [r3, #4]
	*last = idx; /* Commit: Update write index */
 100962c:	70ec      	strb	r4, [r5, #3]
}
 100962e:	e7e5      	b.n	10095fc <ll_init+0x84>
			mem_release(link, &mem_link_done.free);
 1009630:	4630      	mov	r0, r6
 1009632:	496f      	ldr	r1, [pc, #444]	; (10097f0 <ll_init+0x278>)
 1009634:	f7fc fb0e 	bl	1005c54 <mem_release>
	mem_init(mem_pdu_rx.pool, (PDU_RX_NODE_POOL_ELEMENT_SIZE),
 1009638:	4b6f      	ldr	r3, [pc, #444]	; (10097f8 <ll_init+0x280>)
 100963a:	220e      	movs	r2, #14
 100963c:	1d18      	adds	r0, r3, #4
 100963e:	214c      	movs	r1, #76	; 0x4c
 1009640:	f7fc fac0 	bl	1005bc4 <mem_init>
	mem_init(mem_link_rx.pool, sizeof(memq_link_t),
 1009644:	4b6d      	ldr	r3, [pc, #436]	; (10097fc <ll_init+0x284>)
 1009646:	221e      	movs	r2, #30
 1009648:	1d18      	adds	r0, r3, #4
 100964a:	2108      	movs	r1, #8
 100964c:	f7fc faba 	bl	1005bc4 <mem_init>
	link = mem_acquire(&mem_link_rx.free);
 1009650:	486a      	ldr	r0, [pc, #424]	; (10097fc <ll_init+0x284>)
 1009652:	f7fc fae5 	bl	1005c20 <mem_acquire>
	LL_ASSERT(link);
 1009656:	4604      	mov	r4, r0
 1009658:	2800      	cmp	r0, #0
 100965a:	f000 80ac 	beq.w	10097b6 <ll_init+0x23e>
	MEMQ_INIT(ull_rx, link);
 100965e:	4a68      	ldr	r2, [pc, #416]	; (1009800 <ll_init+0x288>)
 1009660:	4620      	mov	r0, r4
 1009662:	1f11      	subs	r1, r2, #4
 1009664:	f7fc fb32 	bl	1005ccc <memq_init>
	link = mem_acquire(&mem_link_rx.free);
 1009668:	4864      	ldr	r0, [pc, #400]	; (10097fc <ll_init+0x284>)
 100966a:	f7fc fad9 	bl	1005c20 <mem_acquire>
	LL_ASSERT(link);
 100966e:	4604      	mov	r4, r0
 1009670:	2800      	cmp	r0, #0
 1009672:	f000 809a 	beq.w	10097aa <ll_init+0x232>
	MEMQ_INIT(ll_rx, link);
 1009676:	4a63      	ldr	r2, [pc, #396]	; (1009804 <ll_init+0x28c>)
	mem_link_rx.quota_pdu = RX_CNT;
 1009678:	4d63      	ldr	r5, [pc, #396]	; (1009808 <ll_init+0x290>)
	MEMQ_INIT(ll_rx, link);
 100967a:	4620      	mov	r0, r4
 100967c:	1f11      	subs	r1, r2, #4
 100967e:	f7fc fb25 	bl	1005ccc <memq_init>
	mem_link_rx.quota_pdu = RX_CNT;
 1009682:	462e      	mov	r6, r5
 1009684:	230c      	movs	r3, #12
		link->mem = NULL;
 1009686:	2700      	movs	r7, #0
 1009688:	f8df 9188 	ldr.w	r9, [pc, #392]	; 1009814 <ll_init+0x29c>
		rx = mem_acquire(&mem_pdu_rx.free);
 100968c:	f8df 8168 	ldr.w	r8, [pc, #360]	; 10097f8 <ll_init+0x280>
 1009690:	f899 4003 	ldrb.w	r4, [r9, #3]
	mem_link_rx.quota_pdu = RX_CNT;
 1009694:	f806 3b04 	strb.w	r3, [r6], #4
	if (last == count) {
 1009698:	f899 3001 	ldrb.w	r3, [r9, #1]
	last = last + 1;
 100969c:	3401      	adds	r4, #1
 100969e:	b2e4      	uxtb	r4, r4
		last = 0U;
 10096a0:	42a3      	cmp	r3, r4
 10096a2:	bf08      	it	eq
 10096a4:	2400      	moveq	r4, #0
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
 10096a6:	f899 3002 	ldrb.w	r3, [r9, #2]
	if (last == first) {
 10096aa:	429c      	cmp	r4, r3
 10096ac:	d049      	beq.n	1009742 <ll_init+0x1ca>
		link = mem_acquire(&mem_link_rx.free);
 10096ae:	4630      	mov	r0, r6
 10096b0:	f7fc fab6 	bl	1005c20 <mem_acquire>
		if (!link) {
 10096b4:	4682      	mov	sl, r0
 10096b6:	2800      	cmp	r0, #0
 10096b8:	d043      	beq.n	1009742 <ll_init+0x1ca>
		rx = mem_acquire(&mem_pdu_rx.free);
 10096ba:	4640      	mov	r0, r8
 10096bc:	f7fc fab0 	bl	1005c20 <mem_acquire>
		if (!rx) {
 10096c0:	2800      	cmp	r0, #0
 10096c2:	d03a      	beq.n	100973a <ll_init+0x1c2>
		link->mem = NULL;
 10096c4:	f8ca 7004 	str.w	r7, [sl, #4]
		rx->link = link;
 10096c8:	f8c0 a000 	str.w	sl, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 10096cc:	f899 2003 	ldrb.w	r2, [r9, #3]
 10096d0:	f899 1000 	ldrb.w	r1, [r9]
	mem_link_rx.quota_pdu += delta;
 10096d4:	782b      	ldrb	r3, [r5, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 10096d6:	fb01 9202 	mla	r2, r1, r2, r9
 10096da:	3b01      	subs	r3, #1
 10096dc:	b2db      	uxtb	r3, r3
 10096de:	6050      	str	r0, [r2, #4]
 10096e0:	702b      	strb	r3, [r5, #0]
	*last = idx; /* Commit: Update write index */
 10096e2:	f889 4003 	strb.w	r4, [r9, #3]
	while (mem_link_rx.quota_pdu &&
 10096e6:	2b00      	cmp	r3, #0
 10096e8:	d1d6      	bne.n	1009698 <ll_init+0x120>
	err = lll_adv_init();
 10096ea:	f007 f887 	bl	10107fc <lll_adv_init>
	if (err) {
 10096ee:	4604      	mov	r4, r0
 10096f0:	2800      	cmp	r0, #0
 10096f2:	f47f af6e 	bne.w	10095d2 <ll_init+0x5a>
	err = ull_adv_init();
 10096f6:	f001 f995 	bl	100aa24 <ull_adv_init>
	if (err) {
 10096fa:	4604      	mov	r4, r0
 10096fc:	2800      	cmp	r0, #0
 10096fe:	f47f af68 	bne.w	10095d2 <ll_init+0x5a>
	err = lll_scan_init();
 1009702:	f007 fb25 	bl	1010d50 <lll_scan_init>
	if (err) {
 1009706:	4604      	mov	r4, r0
 1009708:	2800      	cmp	r0, #0
 100970a:	f47f af62 	bne.w	10095d2 <ll_init+0x5a>
	err = ull_scan_init();
 100970e:	f001 fa91 	bl	100ac34 <ull_scan_init>
	if (err) {
 1009712:	4604      	mov	r4, r0
 1009714:	2800      	cmp	r0, #0
 1009716:	f47f af5c 	bne.w	10095d2 <ll_init+0x5a>
	err = lll_conn_init();
 100971a:	f007 fbe1 	bl	1010ee0 <lll_conn_init>
	if (err) {
 100971e:	4604      	mov	r4, r0
 1009720:	2800      	cmp	r0, #0
 1009722:	f47f af56 	bne.w	10095d2 <ll_init+0x5a>
	err = ull_conn_init();
 1009726:	f002 f9fd 	bl	100bb24 <ull_conn_init>
	if (err) {
 100972a:	4604      	mov	r4, r0
 100972c:	2800      	cmp	r0, #0
 100972e:	f47f af50 	bne.w	10095d2 <ll_init+0x5a>
		ull_filter_reset(true);
 1009732:	2001      	movs	r0, #1
 1009734:	f005 ffa8 	bl	100f688 <ull_filter_reset>
	return  0;
 1009738:	e74b      	b.n	10095d2 <ll_init+0x5a>
			mem_release(link, &mem_link_rx.free);
 100973a:	4650      	mov	r0, sl
 100973c:	492f      	ldr	r1, [pc, #188]	; (10097fc <ll_init+0x284>)
 100973e:	f7fc fa89 	bl	1005c54 <mem_release>
	if (max > mem_link_rx.quota_pdu) {
 1009742:	782b      	ldrb	r3, [r5, #0]
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1009744:	1e5f      	subs	r7, r3, #1
 1009746:	b2ff      	uxtb	r7, r7
 1009748:	2b00      	cmp	r3, #0
 100974a:	d0ce      	beq.n	10096ea <ll_init+0x172>
 100974c:	4e2f      	ldr	r6, [pc, #188]	; (100980c <ll_init+0x294>)
		link = mem_acquire(&mem_link_rx.free);
 100974e:	f8df 90ac 	ldr.w	r9, [pc, #172]	; 10097fc <ll_init+0x284>
 1009752:	78f4      	ldrb	r4, [r6, #3]
		rx = mem_acquire(&mem_pdu_rx.free);
 1009754:	f8df 80a0 	ldr.w	r8, [pc, #160]	; 10097f8 <ll_init+0x280>
	if (last == count) {
 1009758:	7873      	ldrb	r3, [r6, #1]
	last = last + 1;
 100975a:	3401      	adds	r4, #1
 100975c:	b2e4      	uxtb	r4, r4
		last = 0U;
 100975e:	42a3      	cmp	r3, r4
 1009760:	bf08      	it	eq
 1009762:	2400      	moveq	r4, #0
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1009764:	78b3      	ldrb	r3, [r6, #2]
	if (last == first) {
 1009766:	429c      	cmp	r4, r3
 1009768:	d0bf      	beq.n	10096ea <ll_init+0x172>
		link = mem_acquire(&mem_link_rx.free);
 100976a:	4648      	mov	r0, r9
 100976c:	f7fc fa58 	bl	1005c20 <mem_acquire>
		if (!link) {
 1009770:	4682      	mov	sl, r0
 1009772:	2800      	cmp	r0, #0
 1009774:	d0b9      	beq.n	10096ea <ll_init+0x172>
		rx = mem_acquire(&mem_pdu_rx.free);
 1009776:	4640      	mov	r0, r8
 1009778:	f7fc fa52 	bl	1005c20 <mem_acquire>
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 100977c:	3f01      	subs	r7, #1
 100977e:	b2ff      	uxtb	r7, r7
		if (!rx) {
 1009780:	b1f8      	cbz	r0, 10097c2 <ll_init+0x24a>
		rx->link = link;
 1009782:	f8c0 a000 	str.w	sl, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 1009786:	78f2      	ldrb	r2, [r6, #3]
 1009788:	7831      	ldrb	r1, [r6, #0]
	mem_link_rx.quota_pdu += delta;
 100978a:	782b      	ldrb	r3, [r5, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 100978c:	fb01 6202 	mla	r2, r1, r2, r6
 1009790:	3b01      	subs	r3, #1
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1009792:	2fff      	cmp	r7, #255	; 0xff
 1009794:	6050      	str	r0, [r2, #4]
	mem_link_rx.quota_pdu += delta;
 1009796:	702b      	strb	r3, [r5, #0]
	*last = idx; /* Commit: Update write index */
 1009798:	70f4      	strb	r4, [r6, #3]
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 100979a:	d1dd      	bne.n	1009758 <ll_init+0x1e0>
 100979c:	e7a5      	b.n	10096ea <ll_init+0x172>
	LL_ASSERT(!err);
 100979e:	f240 1117 	movw	r1, #279	; 0x117
 10097a2:	481b      	ldr	r0, [pc, #108]	; (1009810 <ll_init+0x298>)
 10097a4:	f7f9 fef0 	bl	1003588 <bt_ctlr_assert_handle>
 10097a8:	e70a      	b.n	10095c0 <ll_init+0x48>
	LL_ASSERT(link);
 10097aa:	f240 41bd 	movw	r1, #1213	; 0x4bd
 10097ae:	4818      	ldr	r0, [pc, #96]	; (1009810 <ll_init+0x298>)
 10097b0:	f7f9 feea 	bl	1003588 <bt_ctlr_assert_handle>
 10097b4:	e75f      	b.n	1009676 <ll_init+0xfe>
	LL_ASSERT(link);
 10097b6:	f240 41b6 	movw	r1, #1206	; 0x4b6
 10097ba:	4815      	ldr	r0, [pc, #84]	; (1009810 <ll_init+0x298>)
 10097bc:	f7f9 fee4 	bl	1003588 <bt_ctlr_assert_handle>
 10097c0:	e74d      	b.n	100965e <ll_init+0xe6>
			mem_release(link, &mem_link_rx.free);
 10097c2:	4650      	mov	r0, sl
 10097c4:	490d      	ldr	r1, [pc, #52]	; (10097fc <ll_init+0x284>)
 10097c6:	f7fc fa45 	bl	1005c54 <mem_release>
			break;
 10097ca:	e78e      	b.n	10096ea <ll_init+0x172>
 10097cc:	21001358 	.word	0x21001358
 10097d0:	210019a0 	.word	0x210019a0
 10097d4:	01012661 	.word	0x01012661
 10097d8:	01012589 	.word	0x01012589
 10097dc:	01012551 	.word	0x01012551
 10097e0:	21001764 	.word	0x21001764
 10097e4:	21001374 	.word	0x21001374
 10097e8:	2100135c 	.word	0x2100135c
 10097ec:	21000d5c 	.word	0x21000d5c
 10097f0:	21000e08 	.word	0x21000e08
 10097f4:	210000b0 	.word	0x210000b0
 10097f8:	21000f1c 	.word	0x21000f1c
 10097fc:	21000e28 	.word	0x21000e28
 1009800:	21001354 	.word	0x21001354
 1009804:	2100134c 	.word	0x2100134c
 1009808:	21000e24 	.word	0x21000e24
 100980c:	210000d8 	.word	0x210000d8
 1009810:	010186e4 	.word	0x010186e4
 1009814:	210000c4 	.word	0x210000c4

01009818 <ll_reset>:
{
 1009818:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100981c:	b087      	sub	sp, #28
	err = ull_adv_reset();
 100981e:	f001 f903 	bl	100aa28 <ull_adv_reset>
	LL_ASSERT(!err);
 1009822:	2800      	cmp	r0, #0
 1009824:	f040 80ea 	bne.w	10099fc <ll_reset+0x1e4>
	err = ull_scan_reset();
 1009828:	f001 fab6 	bl	100ad98 <ull_scan_reset>
	LL_ASSERT(!err);
 100982c:	2800      	cmp	r0, #0
 100982e:	f040 80ef 	bne.w	1009a10 <ll_reset+0x1f8>
		err = ll_connect_disable(&rx);
 1009832:	4668      	mov	r0, sp
 1009834:	f005 f800 	bl	100e838 <ll_connect_disable>
		if (!err) {
 1009838:	2800      	cmp	r0, #0
 100983a:	f000 80f4 	beq.w	1009a26 <ll_reset+0x20e>
	err = ull_conn_reset();
 100983e:	f002 f973 	bl	100bb28 <ull_conn_reset>
	LL_ASSERT(!err);
 1009842:	2800      	cmp	r0, #0
 1009844:	f040 8100 	bne.w	1009a48 <ll_reset+0x230>
	MFIFO_INIT(tx_ack);
 1009848:	2400      	movs	r4, #0
 100984a:	4b91      	ldr	r3, [pc, #580]	; (1009a90 <ll_reset+0x278>)
		ull_filter_reset(false);
 100984c:	4620      	mov	r0, r4
	MFIFO_INIT(tx_ack);
 100984e:	805c      	strh	r4, [r3, #2]
		ull_filter_reset(false);
 1009850:	f005 ff1a 	bl	100f688 <ull_filter_reset>
	MFIFO_INIT(done);
 1009854:	4e8f      	ldr	r6, [pc, #572]	; (1009a94 <ll_reset+0x27c>)
	MFIFO_INIT(pdu_rx_free);
 1009856:	4f90      	ldr	r7, [pc, #576]	; (1009a98 <ll_reset+0x280>)
	MFIFO_INIT(prep);
 1009858:	4b90      	ldr	r3, [pc, #576]	; (1009a9c <ll_reset+0x284>)
	MFIFO_INIT(ll_pdu_rx_free);
 100985a:	4d91      	ldr	r5, [pc, #580]	; (1009aa0 <ll_reset+0x288>)
	MFIFO_INIT(prep);
 100985c:	805c      	strh	r4, [r3, #2]
	MFIFO_INIT(done);
 100985e:	8074      	strh	r4, [r6, #2]
	MFIFO_INIT(pdu_rx_free);
 1009860:	807c      	strh	r4, [r7, #2]
	MFIFO_INIT(ll_pdu_rx_free);
 1009862:	806c      	strh	r4, [r5, #2]
 1009864:	2201      	movs	r2, #1
 1009866:	4621      	mov	r1, r4
 1009868:	4668      	mov	r0, sp
 100986a:	f00e f92d 	bl	1017ac8 <z_impl_k_sem_init>
		mfy.param = &sem;
 100986e:	4b8d      	ldr	r3, [pc, #564]	; (1009aa4 <ll_reset+0x28c>)
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
 1009870:	4622      	mov	r2, r4
 1009872:	4621      	mov	r1, r4
 1009874:	2003      	movs	r0, #3
		mfy.param = &sem;
 1009876:	f8c3 d008 	str.w	sp, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_THREAD,
 100987a:	f7fc faa9 	bl	1005dd0 <mayfly_enqueue>
		LL_ASSERT(!retval);
 100987e:	2800      	cmp	r0, #0
 1009880:	f040 80e8 	bne.w	1009a54 <ll_reset+0x23c>
	return z_impl_k_sem_take(sem, timeout);
 1009884:	f04f 32ff 	mov.w	r2, #4294967295
 1009888:	f04f 33ff 	mov.w	r3, #4294967295
 100988c:	4668      	mov	r0, sp
 100988e:	f00a ff01 	bl	1014694 <z_impl_k_sem_take>
	mem_init(mem_done.pool, sizeof(struct node_rx_event_done),
 1009892:	4b85      	ldr	r3, [pc, #532]	; (1009aa8 <ll_reset+0x290>)
 1009894:	2203      	movs	r2, #3
 1009896:	1d18      	adds	r0, r3, #4
 1009898:	2138      	movs	r1, #56	; 0x38
 100989a:	f7fc f993 	bl	1005bc4 <mem_init>
	mem_init(mem_link_done.pool, sizeof(memq_link_t), EVENT_DONE_MAX,
 100989e:	4b83      	ldr	r3, [pc, #524]	; (1009aac <ll_reset+0x294>)
 10098a0:	2203      	movs	r2, #3
 10098a2:	2108      	movs	r1, #8
 10098a4:	1d18      	adds	r0, r3, #4
 10098a6:	f7fc f98d 	bl	1005bc4 <mem_init>
		link = mem_acquire(&mem_link_done.free);
 10098aa:	f8df 9200 	ldr.w	r9, [pc, #512]	; 1009aac <ll_reset+0x294>
 10098ae:	78f4      	ldrb	r4, [r6, #3]
		rx = mem_acquire(&mem_done.free);
 10098b0:	f8df 81f4 	ldr.w	r8, [pc, #500]	; 1009aa8 <ll_reset+0x290>
	if (last == count) {
 10098b4:	7873      	ldrb	r3, [r6, #1]
	last = last + 1;
 10098b6:	3401      	adds	r4, #1
 10098b8:	b2e4      	uxtb	r4, r4
		last = 0U;
 10098ba:	42a3      	cmp	r3, r4
 10098bc:	bf08      	it	eq
 10098be:	2400      	moveq	r4, #0
	while (MFIFO_ENQUEUE_IDX_GET(done, &idx)) {
 10098c0:	78b3      	ldrb	r3, [r6, #2]
	if (last == first) {
 10098c2:	429c      	cmp	r4, r3
 10098c4:	d015      	beq.n	10098f2 <ll_reset+0xda>
		link = mem_acquire(&mem_link_done.free);
 10098c6:	4648      	mov	r0, r9
 10098c8:	f7fc f9aa 	bl	1005c20 <mem_acquire>
		if (!link) {
 10098cc:	4682      	mov	sl, r0
 10098ce:	b180      	cbz	r0, 10098f2 <ll_reset+0xda>
		rx = mem_acquire(&mem_done.free);
 10098d0:	4640      	mov	r0, r8
 10098d2:	f7fc f9a5 	bl	1005c20 <mem_acquire>
		if (!rx) {
 10098d6:	b140      	cbz	r0, 10098ea <ll_reset+0xd2>
		rx->link = link;
 10098d8:	f8c0 a000 	str.w	sl, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 10098dc:	78f3      	ldrb	r3, [r6, #3]
 10098de:	7832      	ldrb	r2, [r6, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 10098e0:	fb02 6303 	mla	r3, r2, r3, r6
 10098e4:	6058      	str	r0, [r3, #4]
	*last = idx; /* Commit: Update write index */
 10098e6:	70f4      	strb	r4, [r6, #3]
}
 10098e8:	e7e4      	b.n	10098b4 <ll_reset+0x9c>
			mem_release(link, &mem_link_done.free);
 10098ea:	4650      	mov	r0, sl
 10098ec:	496f      	ldr	r1, [pc, #444]	; (1009aac <ll_reset+0x294>)
 10098ee:	f7fc f9b1 	bl	1005c54 <mem_release>
	mem_init(mem_pdu_rx.pool, (PDU_RX_NODE_POOL_ELEMENT_SIZE),
 10098f2:	4b6f      	ldr	r3, [pc, #444]	; (1009ab0 <ll_reset+0x298>)
 10098f4:	220e      	movs	r2, #14
 10098f6:	1d18      	adds	r0, r3, #4
 10098f8:	214c      	movs	r1, #76	; 0x4c
 10098fa:	f7fc f963 	bl	1005bc4 <mem_init>
	mem_init(mem_link_rx.pool, sizeof(memq_link_t),
 10098fe:	4b6d      	ldr	r3, [pc, #436]	; (1009ab4 <ll_reset+0x29c>)
 1009900:	221e      	movs	r2, #30
 1009902:	1d18      	adds	r0, r3, #4
 1009904:	2108      	movs	r1, #8
 1009906:	f7fc f95d 	bl	1005bc4 <mem_init>
	link = mem_acquire(&mem_link_rx.free);
 100990a:	486a      	ldr	r0, [pc, #424]	; (1009ab4 <ll_reset+0x29c>)
 100990c:	f7fc f988 	bl	1005c20 <mem_acquire>
	LL_ASSERT(link);
 1009910:	4604      	mov	r4, r0
 1009912:	2800      	cmp	r0, #0
 1009914:	f000 80aa 	beq.w	1009a6c <ll_reset+0x254>
	MEMQ_INIT(ull_rx, link);
 1009918:	4a67      	ldr	r2, [pc, #412]	; (1009ab8 <ll_reset+0x2a0>)
 100991a:	4620      	mov	r0, r4
 100991c:	1f11      	subs	r1, r2, #4
 100991e:	f7fc f9d5 	bl	1005ccc <memq_init>
	link = mem_acquire(&mem_link_rx.free);
 1009922:	4864      	ldr	r0, [pc, #400]	; (1009ab4 <ll_reset+0x29c>)
 1009924:	f7fc f97c 	bl	1005c20 <mem_acquire>
	LL_ASSERT(link);
 1009928:	4604      	mov	r4, r0
 100992a:	2800      	cmp	r0, #0
 100992c:	f000 8098 	beq.w	1009a60 <ll_reset+0x248>
	MEMQ_INIT(ll_rx, link);
 1009930:	4a62      	ldr	r2, [pc, #392]	; (1009abc <ll_reset+0x2a4>)
	mem_link_rx.quota_pdu = RX_CNT;
 1009932:	4e63      	ldr	r6, [pc, #396]	; (1009ac0 <ll_reset+0x2a8>)
	MEMQ_INIT(ll_rx, link);
 1009934:	4620      	mov	r0, r4
 1009936:	1f11      	subs	r1, r2, #4
 1009938:	f7fc f9c8 	bl	1005ccc <memq_init>
	mem_link_rx.quota_pdu = RX_CNT;
 100993c:	46b3      	mov	fp, r6
 100993e:	230c      	movs	r3, #12
		link->mem = NULL;
 1009940:	f04f 0800 	mov.w	r8, #0
 1009944:	78ec      	ldrb	r4, [r5, #3]
		rx = mem_acquire(&mem_pdu_rx.free);
 1009946:	f8df 9168 	ldr.w	r9, [pc, #360]	; 1009ab0 <ll_reset+0x298>
	mem_link_rx.quota_pdu = RX_CNT;
 100994a:	f80b 3b04 	strb.w	r3, [fp], #4
	if (last == count) {
 100994e:	786b      	ldrb	r3, [r5, #1]
	last = last + 1;
 1009950:	3401      	adds	r4, #1
 1009952:	b2e4      	uxtb	r4, r4
		last = 0U;
 1009954:	42a3      	cmp	r3, r4
 1009956:	bf08      	it	eq
 1009958:	2400      	moveq	r4, #0
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
 100995a:	78ab      	ldrb	r3, [r5, #2]
	if (last == first) {
 100995c:	429c      	cmp	r4, r3
 100995e:	d01f      	beq.n	10099a0 <ll_reset+0x188>
		link = mem_acquire(&mem_link_rx.free);
 1009960:	4658      	mov	r0, fp
 1009962:	f7fc f95d 	bl	1005c20 <mem_acquire>
		if (!link) {
 1009966:	4682      	mov	sl, r0
 1009968:	b1d0      	cbz	r0, 10099a0 <ll_reset+0x188>
		rx = mem_acquire(&mem_pdu_rx.free);
 100996a:	4648      	mov	r0, r9
 100996c:	f7fc f958 	bl	1005c20 <mem_acquire>
		if (!rx) {
 1009970:	b190      	cbz	r0, 1009998 <ll_reset+0x180>
		link->mem = NULL;
 1009972:	f8ca 8004 	str.w	r8, [sl, #4]
		rx->link = link;
 1009976:	f8c0 a000 	str.w	sl, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 100997a:	78ea      	ldrb	r2, [r5, #3]
 100997c:	7829      	ldrb	r1, [r5, #0]
	mem_link_rx.quota_pdu += delta;
 100997e:	7833      	ldrb	r3, [r6, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 1009980:	fb01 5202 	mla	r2, r1, r2, r5
 1009984:	3b01      	subs	r3, #1
 1009986:	b2db      	uxtb	r3, r3
 1009988:	6050      	str	r0, [r2, #4]
 100998a:	7033      	strb	r3, [r6, #0]
	*last = idx; /* Commit: Update write index */
 100998c:	70ec      	strb	r4, [r5, #3]
	while (mem_link_rx.quota_pdu &&
 100998e:	2b00      	cmp	r3, #0
 1009990:	d1dd      	bne.n	100994e <ll_reset+0x136>
}
 1009992:	b007      	add	sp, #28
 1009994:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mem_release(link, &mem_link_rx.free);
 1009998:	4650      	mov	r0, sl
 100999a:	4946      	ldr	r1, [pc, #280]	; (1009ab4 <ll_reset+0x29c>)
 100999c:	f7fc f95a 	bl	1005c54 <mem_release>
	if (max > mem_link_rx.quota_pdu) {
 10099a0:	7833      	ldrb	r3, [r6, #0]
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 10099a2:	1e5d      	subs	r5, r3, #1
 10099a4:	b2ed      	uxtb	r5, r5
 10099a6:	2b00      	cmp	r3, #0
 10099a8:	d0f3      	beq.n	1009992 <ll_reset+0x17a>
 10099aa:	78fc      	ldrb	r4, [r7, #3]
		link = mem_acquire(&mem_link_rx.free);
 10099ac:	f8df 9104 	ldr.w	r9, [pc, #260]	; 1009ab4 <ll_reset+0x29c>
		rx = mem_acquire(&mem_pdu_rx.free);
 10099b0:	f8df 80fc 	ldr.w	r8, [pc, #252]	; 1009ab0 <ll_reset+0x298>
	if (last == count) {
 10099b4:	787b      	ldrb	r3, [r7, #1]
	last = last + 1;
 10099b6:	3401      	adds	r4, #1
 10099b8:	b2e4      	uxtb	r4, r4
		last = 0U;
 10099ba:	42a3      	cmp	r3, r4
 10099bc:	bf08      	it	eq
 10099be:	2400      	moveq	r4, #0
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 10099c0:	78bb      	ldrb	r3, [r7, #2]
	if (last == first) {
 10099c2:	429c      	cmp	r4, r3
 10099c4:	d0e5      	beq.n	1009992 <ll_reset+0x17a>
		link = mem_acquire(&mem_link_rx.free);
 10099c6:	4648      	mov	r0, r9
 10099c8:	f7fc f92a 	bl	1005c20 <mem_acquire>
		if (!link) {
 10099cc:	4682      	mov	sl, r0
 10099ce:	2800      	cmp	r0, #0
 10099d0:	d0df      	beq.n	1009992 <ll_reset+0x17a>
		rx = mem_acquire(&mem_pdu_rx.free);
 10099d2:	4640      	mov	r0, r8
 10099d4:	f7fc f924 	bl	1005c20 <mem_acquire>
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 10099d8:	3d01      	subs	r5, #1
 10099da:	b2ed      	uxtb	r5, r5
		if (!rx) {
 10099dc:	2800      	cmp	r0, #0
 10099de:	d04b      	beq.n	1009a78 <ll_reset+0x260>
		rx->link = link;
 10099e0:	f8c0 a000 	str.w	sl, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 10099e4:	78fa      	ldrb	r2, [r7, #3]
 10099e6:	7839      	ldrb	r1, [r7, #0]
	mem_link_rx.quota_pdu += delta;
 10099e8:	7833      	ldrb	r3, [r6, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 10099ea:	fb01 7202 	mla	r2, r1, r2, r7
 10099ee:	3b01      	subs	r3, #1
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 10099f0:	2dff      	cmp	r5, #255	; 0xff
 10099f2:	6050      	str	r0, [r2, #4]
	mem_link_rx.quota_pdu += delta;
 10099f4:	7033      	strb	r3, [r6, #0]
	*last = idx; /* Commit: Update write index */
 10099f6:	70fc      	strb	r4, [r7, #3]
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 10099f8:	d1dc      	bne.n	10099b4 <ll_reset+0x19c>
 10099fa:	e7ca      	b.n	1009992 <ll_reset+0x17a>
	LL_ASSERT(!err);
 10099fc:	f240 1165 	movw	r1, #357	; 0x165
 1009a00:	4830      	ldr	r0, [pc, #192]	; (1009ac4 <ll_reset+0x2ac>)
 1009a02:	f7f9 fdc1 	bl	1003588 <bt_ctlr_assert_handle>
	err = ull_scan_reset();
 1009a06:	f001 f9c7 	bl	100ad98 <ull_scan_reset>
	LL_ASSERT(!err);
 1009a0a:	2800      	cmp	r0, #0
 1009a0c:	f43f af11 	beq.w	1009832 <ll_reset+0x1a>
 1009a10:	482c      	ldr	r0, [pc, #176]	; (1009ac4 <ll_reset+0x2ac>)
 1009a12:	f240 116b 	movw	r1, #363	; 0x16b
 1009a16:	f7f9 fdb7 	bl	1003588 <bt_ctlr_assert_handle>
		err = ll_connect_disable(&rx);
 1009a1a:	4668      	mov	r0, sp
 1009a1c:	f004 ff0c 	bl	100e838 <ll_connect_disable>
		if (!err) {
 1009a20:	2800      	cmp	r0, #0
 1009a22:	f47f af0c 	bne.w	100983e <ll_reset+0x26>
			scan = ull_scan_is_enabled_get(0);
 1009a26:	f001 f9d9 	bl	100addc <ull_scan_is_enabled_get>
			LL_ASSERT(scan);
 1009a2a:	4604      	mov	r4, r0
 1009a2c:	b348      	cbz	r0, 1009a82 <ll_reset+0x26a>
			scan->lll.conn = NULL;
 1009a2e:	2200      	movs	r2, #0
			scan->is_enabled = 0U;
 1009a30:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
			scan->lll.conn = NULL;
 1009a34:	6262      	str	r2, [r4, #36]	; 0x24
			scan->is_enabled = 0U;
 1009a36:	f36f 0300 	bfc	r3, #0, #1
 1009a3a:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
	err = ull_conn_reset();
 1009a3e:	f002 f873 	bl	100bb28 <ull_conn_reset>
	LL_ASSERT(!err);
 1009a42:	2800      	cmp	r0, #0
 1009a44:	f43f af00 	beq.w	1009848 <ll_reset+0x30>
 1009a48:	f240 1185 	movw	r1, #389	; 0x185
 1009a4c:	481d      	ldr	r0, [pc, #116]	; (1009ac4 <ll_reset+0x2ac>)
 1009a4e:	f7f9 fd9b 	bl	1003588 <bt_ctlr_assert_handle>
 1009a52:	e6f9      	b.n	1009848 <ll_reset+0x30>
		LL_ASSERT(!retval);
 1009a54:	f240 11b7 	movw	r1, #439	; 0x1b7
 1009a58:	481a      	ldr	r0, [pc, #104]	; (1009ac4 <ll_reset+0x2ac>)
 1009a5a:	f7f9 fd95 	bl	1003588 <bt_ctlr_assert_handle>
 1009a5e:	e711      	b.n	1009884 <ll_reset+0x6c>
	LL_ASSERT(link);
 1009a60:	f240 41bd 	movw	r1, #1213	; 0x4bd
 1009a64:	4817      	ldr	r0, [pc, #92]	; (1009ac4 <ll_reset+0x2ac>)
 1009a66:	f7f9 fd8f 	bl	1003588 <bt_ctlr_assert_handle>
 1009a6a:	e761      	b.n	1009930 <ll_reset+0x118>
	LL_ASSERT(link);
 1009a6c:	f240 41b6 	movw	r1, #1206	; 0x4b6
 1009a70:	4814      	ldr	r0, [pc, #80]	; (1009ac4 <ll_reset+0x2ac>)
 1009a72:	f7f9 fd89 	bl	1003588 <bt_ctlr_assert_handle>
 1009a76:	e74f      	b.n	1009918 <ll_reset+0x100>
			mem_release(link, &mem_link_rx.free);
 1009a78:	4650      	mov	r0, sl
 1009a7a:	490e      	ldr	r1, [pc, #56]	; (1009ab4 <ll_reset+0x29c>)
 1009a7c:	f7fc f8ea 	bl	1005c54 <mem_release>
			break;
 1009a80:	e787      	b.n	1009992 <ll_reset+0x17a>
			LL_ASSERT(scan);
 1009a82:	f240 1179 	movw	r1, #377	; 0x179
 1009a86:	480f      	ldr	r0, [pc, #60]	; (1009ac4 <ll_reset+0x2ac>)
 1009a88:	f7f9 fd7e 	bl	1003588 <bt_ctlr_assert_handle>
 1009a8c:	e7cf      	b.n	1009a2e <ll_reset+0x216>
 1009a8e:	bf00      	nop
 1009a90:	21000228 	.word	0x21000228
 1009a94:	210000b0 	.word	0x210000b0
 1009a98:	210000d8 	.word	0x210000d8
 1009a9c:	21000104 	.word	0x21000104
 1009aa0:	210000c4 	.word	0x210000c4
 1009aa4:	2100026c 	.word	0x2100026c
 1009aa8:	21000d5c 	.word	0x21000d5c
 1009aac:	21000e08 	.word	0x21000e08
 1009ab0:	21000f1c 	.word	0x21000f1c
 1009ab4:	21000e28 	.word	0x21000e28
 1009ab8:	21001354 	.word	0x21001354
 1009abc:	2100134c 	.word	0x2100134c
 1009ac0:	21000e24 	.word	0x21000e24
 1009ac4:	010186e4 	.word	0x010186e4

01009ac8 <ll_rx_get>:
{
 1009ac8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1009acc:	b085      	sub	sp, #20
 1009ace:	e9cd 0100 	strd	r0, r1, [sp]
 1009ad2:	4c5a      	ldr	r4, [pc, #360]	; (1009c3c <ll_rx_get+0x174>)
				mem_release(link, &mem_link_rx.free);
 1009ad4:	4d5a      	ldr	r5, [pc, #360]	; (1009c40 <ll_rx_get+0x178>)
 1009ad6:	f8df 9170 	ldr.w	r9, [pc, #368]	; 1009c48 <ll_rx_get+0x180>
	*node_rx = NULL;
 1009ada:	2300      	movs	r3, #0
 1009adc:	9a00      	ldr	r2, [sp, #0]
 1009ade:	6013      	str	r3, [r2, #0]
	link = memq_peek(memq_ll_rx.head, memq_ll_rx.tail, (void **)&rx);
 1009ae0:	e9d9 0100 	ldrd	r0, r1, [r9]
 1009ae4:	aa03      	add	r2, sp, #12
 1009ae6:	f7fc f907 	bl	1005cf8 <memq_peek>
	if (link) {
 1009aea:	4607      	mov	r7, r0
 1009aec:	2800      	cmp	r0, #0
 1009aee:	f000 809a 	beq.w	1009c26 <ll_rx_get+0x15e>
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, rx->ack_last);
 1009af2:	9b03      	ldr	r3, [sp, #12]
 1009af4:	4953      	ldr	r1, [pc, #332]	; (1009c44 <ll_rx_get+0x17c>)
 1009af6:	781a      	ldrb	r2, [r3, #0]
 1009af8:	9801      	ldr	r0, [sp, #4]
 1009afa:	f7ff fb57 	bl	10091ac <tx_cmplt_get>
		if (!cmplt) {
 1009afe:	4603      	mov	r3, r0
 1009b00:	2800      	cmp	r0, #0
 1009b02:	f040 8087 	bne.w	1009c14 <ll_rx_get+0x14c>
			f = mfifo_tx_ack.f;
 1009b06:	78a2      	ldrb	r2, [r4, #2]
 1009b08:	f88d 2009 	strb.w	r2, [sp, #9]
				cmplt_curr = tx_cmplt_get(&h, &f,
 1009b0c:	78e2      	ldrb	r2, [r4, #3]
 1009b0e:	f10d 0109 	add.w	r1, sp, #9
 1009b12:	f10d 000a 	add.w	r0, sp, #10
 1009b16:	461e      	mov	r6, r3
 1009b18:	f7ff fb48 	bl	10091ac <tx_cmplt_get>
 1009b1c:	ea46 0200 	orr.w	r2, r6, r0
			} while ((cmplt_prev != 0U) ||
 1009b20:	f012 02ff 	ands.w	r2, r2, #255	; 0xff
				cmplt_curr = tx_cmplt_get(&h, &f,
 1009b24:	4603      	mov	r3, r0
			} while ((cmplt_prev != 0U) ||
 1009b26:	d1f1      	bne.n	1009b0c <ll_rx_get+0x44>
			if (rx->type == NODE_RX_TYPE_DC_PDU_RELEASE) {
 1009b28:	9b03      	ldr	r3, [sp, #12]
 1009b2a:	7919      	ldrb	r1, [r3, #4]
 1009b2c:	2903      	cmp	r1, #3
 1009b2e:	d16e      	bne.n	1009c0e <ll_rx_get+0x146>
				(void)memq_dequeue(memq_ll_rx.tail,
 1009b30:	4945      	ldr	r1, [pc, #276]	; (1009c48 <ll_rx_get+0x180>)
 1009b32:	f8d9 0004 	ldr.w	r0, [r9, #4]
 1009b36:	f7fc f8e7 	bl	1005d08 <memq_dequeue>
				mem_release(link, &mem_link_rx.free);
 1009b3a:	4638      	mov	r0, r7
 1009b3c:	4943      	ldr	r1, [pc, #268]	; (1009c4c <ll_rx_get+0x184>)
 1009b3e:	f7fc f889 	bl	1005c54 <mem_release>
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
 1009b42:	782b      	ldrb	r3, [r5, #0]
 1009b44:	2b0b      	cmp	r3, #11
 1009b46:	d85b      	bhi.n	1009c00 <ll_rx_get+0x138>
	mem_link_rx.quota_pdu += delta;
 1009b48:	3301      	adds	r3, #1
				mem_release(rx, &mem_pdu_rx.free);
 1009b4a:	4941      	ldr	r1, [pc, #260]	; (1009c50 <ll_rx_get+0x188>)
 1009b4c:	9803      	ldr	r0, [sp, #12]
	mem_link_rx.quota_pdu += delta;
 1009b4e:	702b      	strb	r3, [r5, #0]
				mem_release(rx, &mem_pdu_rx.free);
 1009b50:	f7fc f880 	bl	1005c54 <mem_release>
	while (mem_link_rx.quota_pdu &&
 1009b54:	782b      	ldrb	r3, [r5, #0]
 1009b56:	2b00      	cmp	r3, #0
 1009b58:	d0bf      	beq.n	1009ada <ll_rx_get+0x12>
 1009b5a:	4f3e      	ldr	r7, [pc, #248]	; (1009c54 <ll_rx_get+0x18c>)
		link = mem_acquire(&mem_link_rx.free);
 1009b5c:	f8df 80ec 	ldr.w	r8, [pc, #236]	; 1009c4c <ll_rx_get+0x184>
 1009b60:	78fe      	ldrb	r6, [r7, #3]
		rx = mem_acquire(&mem_pdu_rx.free);
 1009b62:	f8df a0ec 	ldr.w	sl, [pc, #236]	; 1009c50 <ll_rx_get+0x188>
	if (last == count) {
 1009b66:	787b      	ldrb	r3, [r7, #1]
	last = last + 1;
 1009b68:	3601      	adds	r6, #1
 1009b6a:	b2f6      	uxtb	r6, r6
		last = 0U;
 1009b6c:	42b3      	cmp	r3, r6
 1009b6e:	bf08      	it	eq
 1009b70:	2600      	moveq	r6, #0
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
 1009b72:	78bb      	ldrb	r3, [r7, #2]
	if (last == first) {
 1009b74:	429e      	cmp	r6, r3
 1009b76:	d01e      	beq.n	1009bb6 <ll_rx_get+0xee>
		link = mem_acquire(&mem_link_rx.free);
 1009b78:	4640      	mov	r0, r8
 1009b7a:	f7fc f851 	bl	1005c20 <mem_acquire>
		if (!link) {
 1009b7e:	4683      	mov	fp, r0
 1009b80:	b1c8      	cbz	r0, 1009bb6 <ll_rx_get+0xee>
		rx = mem_acquire(&mem_pdu_rx.free);
 1009b82:	4650      	mov	r0, sl
 1009b84:	f7fc f84c 	bl	1005c20 <mem_acquire>
		if (!rx) {
 1009b88:	b188      	cbz	r0, 1009bae <ll_rx_get+0xe6>
		link->mem = NULL;
 1009b8a:	2300      	movs	r3, #0
 1009b8c:	f8cb 3004 	str.w	r3, [fp, #4]
		rx->link = link;
 1009b90:	f8c0 b000 	str.w	fp, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 1009b94:	78fa      	ldrb	r2, [r7, #3]
 1009b96:	7839      	ldrb	r1, [r7, #0]
	mem_link_rx.quota_pdu += delta;
 1009b98:	782b      	ldrb	r3, [r5, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 1009b9a:	fb01 7202 	mla	r2, r1, r2, r7
 1009b9e:	3b01      	subs	r3, #1
 1009ba0:	b2db      	uxtb	r3, r3
 1009ba2:	6050      	str	r0, [r2, #4]
 1009ba4:	702b      	strb	r3, [r5, #0]
	*last = idx; /* Commit: Update write index */
 1009ba6:	70fe      	strb	r6, [r7, #3]
	while (mem_link_rx.quota_pdu &&
 1009ba8:	2b00      	cmp	r3, #0
 1009baa:	d1dc      	bne.n	1009b66 <ll_rx_get+0x9e>
 1009bac:	e795      	b.n	1009ada <ll_rx_get+0x12>
			mem_release(link, &mem_link_rx.free);
 1009bae:	4658      	mov	r0, fp
 1009bb0:	4926      	ldr	r1, [pc, #152]	; (1009c4c <ll_rx_get+0x184>)
 1009bb2:	f7fc f84f 	bl	1005c54 <mem_release>
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1009bb6:	782b      	ldrb	r3, [r5, #0]
 1009bb8:	2b00      	cmp	r3, #0
 1009bba:	d08e      	beq.n	1009ada <ll_rx_get+0x12>
 1009bbc:	4f26      	ldr	r7, [pc, #152]	; (1009c58 <ll_rx_get+0x190>)
	last = last + 1;
 1009bbe:	78fe      	ldrb	r6, [r7, #3]
	if (last == count) {
 1009bc0:	787b      	ldrb	r3, [r7, #1]
	last = last + 1;
 1009bc2:	3601      	adds	r6, #1
 1009bc4:	b2f6      	uxtb	r6, r6
		last = 0U;
 1009bc6:	42b3      	cmp	r3, r6
 1009bc8:	bf08      	it	eq
 1009bca:	2600      	moveq	r6, #0
 1009bcc:	78bb      	ldrb	r3, [r7, #2]
	if (last == first) {
 1009bce:	429e      	cmp	r6, r3
 1009bd0:	d083      	beq.n	1009ada <ll_rx_get+0x12>
		link = mem_acquire(&mem_link_rx.free);
 1009bd2:	481e      	ldr	r0, [pc, #120]	; (1009c4c <ll_rx_get+0x184>)
 1009bd4:	f7fc f824 	bl	1005c20 <mem_acquire>
		if (!link) {
 1009bd8:	4680      	mov	r8, r0
 1009bda:	2800      	cmp	r0, #0
 1009bdc:	f43f af7d 	beq.w	1009ada <ll_rx_get+0x12>
		rx = mem_acquire(&mem_pdu_rx.free);
 1009be0:	481b      	ldr	r0, [pc, #108]	; (1009c50 <ll_rx_get+0x188>)
 1009be2:	f7fc f81d 	bl	1005c20 <mem_acquire>
		if (!rx) {
 1009be6:	b1c8      	cbz	r0, 1009c1c <ll_rx_get+0x154>
		rx->link = link;
 1009be8:	f8c0 8000 	str.w	r8, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 1009bec:	78fa      	ldrb	r2, [r7, #3]
 1009bee:	7839      	ldrb	r1, [r7, #0]
	mem_link_rx.quota_pdu += delta;
 1009bf0:	782b      	ldrb	r3, [r5, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 1009bf2:	fb01 7202 	mla	r2, r1, r2, r7
 1009bf6:	3b01      	subs	r3, #1
 1009bf8:	6050      	str	r0, [r2, #4]
 1009bfa:	702b      	strb	r3, [r5, #0]
	*last = idx; /* Commit: Update write index */
 1009bfc:	70fe      	strb	r6, [r7, #3]
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1009bfe:	e76c      	b.n	1009ada <ll_rx_get+0x12>
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
 1009c00:	f44f 7159 	mov.w	r1, #868	; 0x364
 1009c04:	4815      	ldr	r0, [pc, #84]	; (1009c5c <ll_rx_get+0x194>)
 1009c06:	f7f9 fcbf 	bl	1003588 <bt_ctlr_assert_handle>
 1009c0a:	782b      	ldrb	r3, [r5, #0]
 1009c0c:	e79c      	b.n	1009b48 <ll_rx_get+0x80>
			*node_rx = rx;
 1009c0e:	9900      	ldr	r1, [sp, #0]
 1009c10:	600b      	str	r3, [r1, #0]
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, rx->ack_last);
 1009c12:	4613      	mov	r3, r2
}
 1009c14:	4618      	mov	r0, r3
 1009c16:	b005      	add	sp, #20
 1009c18:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mem_release(link, &mem_link_rx.free);
 1009c1c:	4640      	mov	r0, r8
 1009c1e:	490b      	ldr	r1, [pc, #44]	; (1009c4c <ll_rx_get+0x184>)
 1009c20:	f7fc f818 	bl	1005c54 <mem_release>
			break;
 1009c24:	e759      	b.n	1009ada <ll_rx_get+0x12>
		cmplt = tx_cmplt_get(handle, &mfifo_tx_ack.f, mfifo_tx_ack.l);
 1009c26:	78e2      	ldrb	r2, [r4, #3]
 1009c28:	9801      	ldr	r0, [sp, #4]
 1009c2a:	4906      	ldr	r1, [pc, #24]	; (1009c44 <ll_rx_get+0x17c>)
 1009c2c:	f7ff fabe 	bl	10091ac <tx_cmplt_get>
 1009c30:	4603      	mov	r3, r0
}
 1009c32:	4618      	mov	r0, r3
 1009c34:	b005      	add	sp, #20
 1009c36:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1009c3a:	bf00      	nop
 1009c3c:	21000228 	.word	0x21000228
 1009c40:	21000e24 	.word	0x21000e24
 1009c44:	2100022a 	.word	0x2100022a
 1009c48:	21001348 	.word	0x21001348
 1009c4c:	21000e28 	.word	0x21000e28
 1009c50:	21000f1c 	.word	0x21000f1c
 1009c54:	210000c4 	.word	0x210000c4
 1009c58:	210000d8 	.word	0x210000d8
 1009c5c:	010186e4 	.word	0x010186e4

01009c60 <ll_rx_dequeue>:
	struct node_rx_hdr *rx = NULL;
 1009c60:	2300      	movs	r3, #0
{
 1009c62:	b570      	push	{r4, r5, r6, lr}
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
 1009c64:	4944      	ldr	r1, [pc, #272]	; (1009d78 <ll_rx_dequeue+0x118>)
{
 1009c66:	b082      	sub	sp, #8
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
 1009c68:	6848      	ldr	r0, [r1, #4]
 1009c6a:	aa01      	add	r2, sp, #4
	struct node_rx_hdr *rx = NULL;
 1009c6c:	9301      	str	r3, [sp, #4]
	link = memq_dequeue(memq_ll_rx.tail, &memq_ll_rx.head,
 1009c6e:	f7fc f84b 	bl	1005d08 <memq_dequeue>
	LL_ASSERT(link);
 1009c72:	4604      	mov	r4, r0
 1009c74:	2800      	cmp	r0, #0
 1009c76:	d04b      	beq.n	1009d10 <ll_rx_dequeue+0xb0>
	mem_release(link, &mem_link_rx.free);
 1009c78:	4620      	mov	r0, r4
 1009c7a:	4940      	ldr	r1, [pc, #256]	; (1009d7c <ll_rx_dequeue+0x11c>)
 1009c7c:	f7fb ffea 	bl	1005c54 <mem_release>
	switch (rx->type) {
 1009c80:	9a01      	ldr	r2, [sp, #4]
 1009c82:	7913      	ldrb	r3, [r2, #4]
 1009c84:	2b0e      	cmp	r3, #14
 1009c86:	d80d      	bhi.n	1009ca4 <ll_rx_dequeue+0x44>
 1009c88:	e8df f003 	tbb	[pc, r3]
 1009c8c:	0c080c08 	.word	0x0c080c08
 1009c90:	0c0c0c08 	.word	0x0c0c0c08
 1009c94:	08080813 	.word	0x08080813
 1009c98:	0808      	.short	0x0808
 1009c9a:	08          	.byte	0x08
 1009c9b:	00          	.byte	0x00
		LL_ASSERT(rx->type != NODE_RX_TYPE_NONE);
 1009c9c:	2b00      	cmp	r3, #0
 1009c9e:	d03d      	beq.n	1009d1c <ll_rx_dequeue+0xbc>
}
 1009ca0:	b002      	add	sp, #8
 1009ca2:	bd70      	pop	{r4, r5, r6, pc}
		LL_ASSERT(0);
 1009ca4:	f240 21a5 	movw	r1, #677	; 0x2a5
 1009ca8:	4835      	ldr	r0, [pc, #212]	; (1009d80 <ll_rx_dequeue+0x120>)
 1009caa:	f7f9 fc6d 	bl	1003588 <bt_ctlr_assert_handle>
}
 1009cae:	b002      	add	sp, #8
 1009cb0:	bd70      	pop	{r4, r5, r6, pc}
		} else if ((cc->status == BT_HCI_ERR_ADV_TIMEOUT) || cc->role) {
 1009cb2:	f892 3020 	ldrb.w	r3, [r2, #32]
 1009cb6:	2b3c      	cmp	r3, #60	; 0x3c
 1009cb8:	d037      	beq.n	1009d2a <ll_rx_dequeue+0xca>
 1009cba:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
 1009cbe:	b1f3      	cbz	r3, 1009cfe <ll_rx_dequeue+0x9e>
			struct ll_adv_set *adv = (void *)HDR_LLL2EVT(lll);
 1009cc0:	6893      	ldr	r3, [r2, #8]
 1009cc2:	681c      	ldr	r4, [r3, #0]
				if (adv->node_rx_cc_free) {
 1009cc4:	f8d4 00d4 	ldr.w	r0, [r4, #212]	; 0xd4
 1009cc8:	b128      	cbz	r0, 1009cd6 <ll_rx_dequeue+0x76>
					adv->node_rx_cc_free = NULL;
 1009cca:	2300      	movs	r3, #0
					mem_release(rx_free, &mem_pdu_rx.free);
 1009ccc:	492d      	ldr	r1, [pc, #180]	; (1009d84 <ll_rx_dequeue+0x124>)
					adv->node_rx_cc_free = NULL;
 1009cce:	f8c4 30d4 	str.w	r3, [r4, #212]	; 0xd4
					mem_release(rx_free, &mem_pdu_rx.free);
 1009cd2:	f7fb ffbf 	bl	1005c54 <mem_release>
			adv->is_enabled = 0U;
 1009cd6:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
 1009cda:	f36f 0300 	bfc	r3, #0, #1
 1009cde:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
			      ull_scan_is_enabled(0) << 1) |
 1009ce2:	2000      	movs	r0, #0
 1009ce4:	f001 f896 	bl	100ae14 <ull_scan_is_enabled>
 1009ce8:	4604      	mov	r4, r0
			      ull_adv_is_enabled(0));
 1009cea:	2000      	movs	r0, #0
 1009cec:	f000 ff44 	bl	100ab78 <ull_adv_is_enabled>
			if (!bm) {
 1009cf0:	ea50 0044 	orrs.w	r0, r0, r4, lsl #1
 1009cf4:	d1d4      	bne.n	1009ca0 <ll_rx_dequeue+0x40>
				ull_filter_adv_scan_state_cb(0);
 1009cf6:	f005 f845 	bl	100ed84 <ull_filter_adv_scan_state_cb>
}
 1009cfa:	b002      	add	sp, #8
 1009cfc:	bd70      	pop	{r4, r5, r6, pc}
			struct ll_scan_set *scan = (void *)HDR_LLL2EVT(lll);
 1009cfe:	6892      	ldr	r2, [r2, #8]
 1009d00:	6812      	ldr	r2, [r2, #0]
			scan->is_enabled = 0U;
 1009d02:	f892 1048 	ldrb.w	r1, [r2, #72]	; 0x48
 1009d06:	f363 0100 	bfi	r1, r3, #0, #1
 1009d0a:	f882 1048 	strb.w	r1, [r2, #72]	; 0x48
 1009d0e:	e7e8      	b.n	1009ce2 <ll_rx_dequeue+0x82>
	LL_ASSERT(link);
 1009d10:	f240 2115 	movw	r1, #533	; 0x215
 1009d14:	481a      	ldr	r0, [pc, #104]	; (1009d80 <ll_rx_dequeue+0x120>)
 1009d16:	f7f9 fc37 	bl	1003588 <bt_ctlr_assert_handle>
 1009d1a:	e7ad      	b.n	1009c78 <ll_rx_dequeue+0x18>
		LL_ASSERT(rx->type != NODE_RX_TYPE_NONE);
 1009d1c:	f240 21a1 	movw	r1, #673	; 0x2a1
 1009d20:	4817      	ldr	r0, [pc, #92]	; (1009d80 <ll_rx_dequeue+0x120>)
 1009d22:	f7f9 fc31 	bl	1003588 <bt_ctlr_assert_handle>
}
 1009d26:	b002      	add	sp, #8
 1009d28:	bd70      	pop	{r4, r5, r6, pc}
			struct lll_adv *lll = ftr->param;
 1009d2a:	6896      	ldr	r6, [r2, #8]
				conn_lll = lll->conn;
 1009d2c:	68b5      	ldr	r5, [r6, #8]
			struct ll_adv_set *adv = (void *)HDR_LLL2EVT(lll);
 1009d2e:	6834      	ldr	r4, [r6, #0]
				LL_ASSERT(conn_lll);
 1009d30:	b1ad      	cbz	r5, 1009d5e <ll_rx_dequeue+0xfe>
				lll->conn = NULL;
 1009d32:	2200      	movs	r2, #0
				LL_ASSERT(!conn_lll->link_tx_free);
 1009d34:	6deb      	ldr	r3, [r5, #92]	; 0x5c
				lll->conn = NULL;
 1009d36:	60b2      	str	r2, [r6, #8]
				LL_ASSERT(!conn_lll->link_tx_free);
 1009d38:	b123      	cbz	r3, 1009d44 <ll_rx_dequeue+0xe4>
 1009d3a:	f240 2131 	movw	r1, #561	; 0x231
 1009d3e:	4810      	ldr	r0, [pc, #64]	; (1009d80 <ll_rx_dequeue+0x120>)
 1009d40:	f7f9 fc22 	bl	1003588 <bt_ctlr_assert_handle>
				link = memq_deinit(&conn_lll->memq_tx.head,
 1009d44:	f105 0150 	add.w	r1, r5, #80	; 0x50
 1009d48:	f105 004c 	add.w	r0, r5, #76	; 0x4c
 1009d4c:	f7fb ffc2 	bl	1005cd4 <memq_deinit>
				LL_ASSERT(link);
 1009d50:	4606      	mov	r6, r0
 1009d52:	b150      	cbz	r0, 1009d6a <ll_rx_dequeue+0x10a>
				ll_conn_release(conn);
 1009d54:	6828      	ldr	r0, [r5, #0]
				conn_lll->link_tx_free = link;
 1009d56:	65ee      	str	r6, [r5, #92]	; 0x5c
				ll_conn_release(conn);
 1009d58:	f001 fbec 	bl	100b534 <ll_conn_release>
 1009d5c:	e7bb      	b.n	1009cd6 <ll_rx_dequeue+0x76>
				LL_ASSERT(conn_lll);
 1009d5e:	f240 212e 	movw	r1, #558	; 0x22e
 1009d62:	4807      	ldr	r0, [pc, #28]	; (1009d80 <ll_rx_dequeue+0x120>)
 1009d64:	f7f9 fc10 	bl	1003588 <bt_ctlr_assert_handle>
 1009d68:	e7e3      	b.n	1009d32 <ll_rx_dequeue+0xd2>
				LL_ASSERT(link);
 1009d6a:	f44f 710d 	mov.w	r1, #564	; 0x234
 1009d6e:	4804      	ldr	r0, [pc, #16]	; (1009d80 <ll_rx_dequeue+0x120>)
 1009d70:	f7f9 fc0a 	bl	1003588 <bt_ctlr_assert_handle>
 1009d74:	e7ee      	b.n	1009d54 <ll_rx_dequeue+0xf4>
 1009d76:	bf00      	nop
 1009d78:	21001348 	.word	0x21001348
 1009d7c:	21000e28 	.word	0x21000e28
 1009d80:	010186e4 	.word	0x010186e4
 1009d84:	21000f1c 	.word	0x21000f1c

01009d88 <ll_rx_mem_release>:
{
 1009d88:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	rx = *node_rx;
 1009d8c:	6804      	ldr	r4, [r0, #0]
{
 1009d8e:	4680      	mov	r8, r0
 1009d90:	4e8c      	ldr	r6, [pc, #560]	; (1009fc4 <ll_rx_mem_release+0x23c>)
 1009d92:	b082      	sub	sp, #8
	while (rx) {
 1009d94:	b38c      	cbz	r4, 1009dfa <ll_rx_mem_release+0x72>
			LL_ASSERT(0);
 1009d96:	4f8c      	ldr	r7, [pc, #560]	; (1009fc8 <ll_rx_mem_release+0x240>)
			mem_release(rx_free, &mem_pdu_rx.free);
 1009d98:	f8df 923c 	ldr.w	r9, [pc, #572]	; 1009fd8 <ll_rx_mem_release+0x250>
		switch (rx_free->type) {
 1009d9c:	7923      	ldrb	r3, [r4, #4]
 1009d9e:	4625      	mov	r5, r4
		rx = rx->next;
 1009da0:	6824      	ldr	r4, [r4, #0]
		switch (rx_free->type) {
 1009da2:	2b0e      	cmp	r3, #14
 1009da4:	d85b      	bhi.n	1009e5e <ll_rx_mem_release+0xd6>
 1009da6:	e8df f003 	tbb	[pc, r3]
 1009daa:	5a17      	.short	0x5a17
 1009dac:	5a175a17 	.word	0x5a175a17
 1009db0:	62085a5a 	.word	0x62085a5a
 1009db4:	17171717 	.word	0x17171717
 1009db8:	17          	.byte	0x17
 1009db9:	00          	.byte	0x00
			} else if (cc->status == BT_HCI_ERR_ADV_TIMEOUT) {
 1009dba:	f895 3020 	ldrb.w	r3, [r5, #32]
 1009dbe:	2b3c      	cmp	r3, #60	; 0x3c
 1009dc0:	f000 80da 	beq.w	1009f78 <ll_rx_mem_release+0x1f0>
			} else if (cc->status == BT_HCI_ERR_UNKNOWN_CONN_ID) {
 1009dc4:	2b02      	cmp	r3, #2
 1009dc6:	f000 80a8 	beq.w	1009f1a <ll_rx_mem_release+0x192>
				LL_ASSERT(!cc->status);
 1009dca:	b15b      	cbz	r3, 1009de4 <ll_rx_mem_release+0x5c>
 1009dcc:	f240 21fd 	movw	r1, #765	; 0x2fd
 1009dd0:	4638      	mov	r0, r7
 1009dd2:	f7f9 fbd9 	bl	1003588 <bt_ctlr_assert_handle>
 1009dd6:	792b      	ldrb	r3, [r5, #4]
			LL_ASSERT(rx_free->type != NODE_RX_TYPE_NONE);
 1009dd8:	b923      	cbnz	r3, 1009de4 <ll_rx_mem_release+0x5c>
 1009dda:	f240 313e 	movw	r1, #830	; 0x33e
 1009dde:	4638      	mov	r0, r7
 1009de0:	f7f9 fbd2 	bl	1003588 <bt_ctlr_assert_handle>
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
 1009de4:	7833      	ldrb	r3, [r6, #0]
 1009de6:	2b0b      	cmp	r3, #11
 1009de8:	d85d      	bhi.n	1009ea6 <ll_rx_mem_release+0x11e>
	mem_link_rx.quota_pdu += delta;
 1009dea:	3301      	adds	r3, #1
			mem_release(rx_free, &mem_pdu_rx.free);
 1009dec:	4628      	mov	r0, r5
 1009dee:	4649      	mov	r1, r9
	mem_link_rx.quota_pdu += delta;
 1009df0:	7033      	strb	r3, [r6, #0]
			mem_release(rx_free, &mem_pdu_rx.free);
 1009df2:	f7fb ff2f 	bl	1005c54 <mem_release>
	while (rx) {
 1009df6:	2c00      	cmp	r4, #0
 1009df8:	d1d0      	bne.n	1009d9c <ll_rx_mem_release+0x14>
	*node_rx = rx;
 1009dfa:	2700      	movs	r7, #0
 1009dfc:	f8c8 7000 	str.w	r7, [r8]
	while (mem_link_rx.quota_pdu &&
 1009e00:	7833      	ldrb	r3, [r6, #0]
 1009e02:	b34b      	cbz	r3, 1009e58 <ll_rx_mem_release+0xd0>
 1009e04:	4d71      	ldr	r5, [pc, #452]	; (1009fcc <ll_rx_mem_release+0x244>)
		link = mem_acquire(&mem_link_rx.free);
 1009e06:	f8df 81c8 	ldr.w	r8, [pc, #456]	; 1009fd0 <ll_rx_mem_release+0x248>
 1009e0a:	78ec      	ldrb	r4, [r5, #3]
		rx = mem_acquire(&mem_pdu_rx.free);
 1009e0c:	f8df 91c8 	ldr.w	r9, [pc, #456]	; 1009fd8 <ll_rx_mem_release+0x250>
	if (last == count) {
 1009e10:	786b      	ldrb	r3, [r5, #1]
	last = last + 1;
 1009e12:	3401      	adds	r4, #1
 1009e14:	b2e4      	uxtb	r4, r4
		last = 0U;
 1009e16:	42a3      	cmp	r3, r4
 1009e18:	bf08      	it	eq
 1009e1a:	2400      	moveq	r4, #0
	       MFIFO_ENQUEUE_IDX_GET(ll_pdu_rx_free, &idx)) {
 1009e1c:	78ab      	ldrb	r3, [r5, #2]
	if (last == first) {
 1009e1e:	429c      	cmp	r4, r3
 1009e20:	d04c      	beq.n	1009ebc <ll_rx_mem_release+0x134>
		link = mem_acquire(&mem_link_rx.free);
 1009e22:	4640      	mov	r0, r8
 1009e24:	f7fb fefc 	bl	1005c20 <mem_acquire>
		if (!link) {
 1009e28:	4682      	mov	sl, r0
 1009e2a:	2800      	cmp	r0, #0
 1009e2c:	d046      	beq.n	1009ebc <ll_rx_mem_release+0x134>
		rx = mem_acquire(&mem_pdu_rx.free);
 1009e2e:	4648      	mov	r0, r9
 1009e30:	f7fb fef6 	bl	1005c20 <mem_acquire>
		if (!rx) {
 1009e34:	2800      	cmp	r0, #0
 1009e36:	d03d      	beq.n	1009eb4 <ll_rx_mem_release+0x12c>
		link->mem = NULL;
 1009e38:	f8ca 7004 	str.w	r7, [sl, #4]
		rx->link = link;
 1009e3c:	f8c0 a000 	str.w	sl, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 1009e40:	78ea      	ldrb	r2, [r5, #3]
 1009e42:	7829      	ldrb	r1, [r5, #0]
	mem_link_rx.quota_pdu += delta;
 1009e44:	7833      	ldrb	r3, [r6, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 1009e46:	fb01 5202 	mla	r2, r1, r2, r5
 1009e4a:	3b01      	subs	r3, #1
 1009e4c:	b2db      	uxtb	r3, r3
 1009e4e:	6050      	str	r0, [r2, #4]
 1009e50:	7033      	strb	r3, [r6, #0]
	*last = idx; /* Commit: Update write index */
 1009e52:	70ec      	strb	r4, [r5, #3]
	while (mem_link_rx.quota_pdu &&
 1009e54:	2b00      	cmp	r3, #0
 1009e56:	d1db      	bne.n	1009e10 <ll_rx_mem_release+0x88>
}
 1009e58:	b002      	add	sp, #8
 1009e5a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			LL_ASSERT(0);
 1009e5e:	f44f 7156 	mov.w	r1, #856	; 0x358
 1009e62:	4638      	mov	r0, r7
 1009e64:	f7f9 fb90 	bl	1003588 <bt_ctlr_assert_handle>
	while (rx) {
 1009e68:	2c00      	cmp	r4, #0
 1009e6a:	d197      	bne.n	1009d9c <ll_rx_mem_release+0x14>
 1009e6c:	e7c5      	b.n	1009dfa <ll_rx_mem_release+0x72>
			conn = ll_conn_get(rx_free->handle);
 1009e6e:	88e8      	ldrh	r0, [r5, #6]
 1009e70:	f001 fb6e 	bl	100b550 <ll_conn_get>
			LL_ASSERT(!conn->lll.link_tx_free);
 1009e74:	6f83      	ldr	r3, [r0, #120]	; 0x78
			conn = ll_conn_get(rx_free->handle);
 1009e76:	4605      	mov	r5, r0
			LL_ASSERT(!conn->lll.link_tx_free);
 1009e78:	b123      	cbz	r3, 1009e84 <ll_rx_mem_release+0xfc>
 1009e7a:	f240 314b 	movw	r1, #843	; 0x34b
 1009e7e:	4638      	mov	r0, r7
 1009e80:	f7f9 fb82 	bl	1003588 <bt_ctlr_assert_handle>
			link = memq_deinit(&conn->lll.memq_tx.head,
 1009e84:	f105 016c 	add.w	r1, r5, #108	; 0x6c
 1009e88:	f105 0068 	add.w	r0, r5, #104	; 0x68
 1009e8c:	f7fb ff22 	bl	1005cd4 <memq_deinit>
			LL_ASSERT(link);
 1009e90:	4603      	mov	r3, r0
 1009e92:	2800      	cmp	r0, #0
 1009e94:	d078      	beq.n	1009f88 <ll_rx_mem_release+0x200>
			ll_conn_release(conn);
 1009e96:	4628      	mov	r0, r5
			conn->lll.link_tx_free = link;
 1009e98:	67ab      	str	r3, [r5, #120]	; 0x78
			ll_conn_release(conn);
 1009e9a:	f001 fb4b 	bl	100b534 <ll_conn_release>
	while (rx) {
 1009e9e:	2c00      	cmp	r4, #0
 1009ea0:	f47f af7c 	bne.w	1009d9c <ll_rx_mem_release+0x14>
 1009ea4:	e7a9      	b.n	1009dfa <ll_rx_mem_release+0x72>
	LL_ASSERT(delta <= 0 || mem_link_rx.quota_pdu < RX_CNT);
 1009ea6:	f44f 7159 	mov.w	r1, #868	; 0x364
 1009eaa:	4638      	mov	r0, r7
 1009eac:	f7f9 fb6c 	bl	1003588 <bt_ctlr_assert_handle>
 1009eb0:	7833      	ldrb	r3, [r6, #0]
 1009eb2:	e79a      	b.n	1009dea <ll_rx_mem_release+0x62>
			mem_release(link, &mem_link_rx.free);
 1009eb4:	4650      	mov	r0, sl
 1009eb6:	4946      	ldr	r1, [pc, #280]	; (1009fd0 <ll_rx_mem_release+0x248>)
 1009eb8:	f7fb fecc 	bl	1005c54 <mem_release>
	if (max > mem_link_rx.quota_pdu) {
 1009ebc:	7833      	ldrb	r3, [r6, #0]
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1009ebe:	1e5f      	subs	r7, r3, #1
 1009ec0:	b2ff      	uxtb	r7, r7
 1009ec2:	2b00      	cmp	r3, #0
 1009ec4:	d0c8      	beq.n	1009e58 <ll_rx_mem_release+0xd0>
 1009ec6:	4d43      	ldr	r5, [pc, #268]	; (1009fd4 <ll_rx_mem_release+0x24c>)
		link = mem_acquire(&mem_link_rx.free);
 1009ec8:	f8df 8104 	ldr.w	r8, [pc, #260]	; 1009fd0 <ll_rx_mem_release+0x248>
 1009ecc:	78ec      	ldrb	r4, [r5, #3]
		rx = mem_acquire(&mem_pdu_rx.free);
 1009ece:	f8df 9108 	ldr.w	r9, [pc, #264]	; 1009fd8 <ll_rx_mem_release+0x250>
	if (last == count) {
 1009ed2:	786b      	ldrb	r3, [r5, #1]
	last = last + 1;
 1009ed4:	3401      	adds	r4, #1
 1009ed6:	b2e4      	uxtb	r4, r4
		last = 0U;
 1009ed8:	42a3      	cmp	r3, r4
 1009eda:	bf08      	it	eq
 1009edc:	2400      	moveq	r4, #0
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1009ede:	78ab      	ldrb	r3, [r5, #2]
	if (last == first) {
 1009ee0:	429c      	cmp	r4, r3
 1009ee2:	d0b9      	beq.n	1009e58 <ll_rx_mem_release+0xd0>
		link = mem_acquire(&mem_link_rx.free);
 1009ee4:	4640      	mov	r0, r8
 1009ee6:	f7fb fe9b 	bl	1005c20 <mem_acquire>
		if (!link) {
 1009eea:	4682      	mov	sl, r0
 1009eec:	2800      	cmp	r0, #0
 1009eee:	d0b3      	beq.n	1009e58 <ll_rx_mem_release+0xd0>
		rx = mem_acquire(&mem_pdu_rx.free);
 1009ef0:	4648      	mov	r0, r9
 1009ef2:	f7fb fe95 	bl	1005c20 <mem_acquire>
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1009ef6:	3f01      	subs	r7, #1
 1009ef8:	b2ff      	uxtb	r7, r7
		if (!rx) {
 1009efa:	2800      	cmp	r0, #0
 1009efc:	d05a      	beq.n	1009fb4 <ll_rx_mem_release+0x22c>
		rx->link = link;
 1009efe:	f8c0 a000 	str.w	sl, [r0]
	void **p = (void **)(fifo + (*last) * size); /* buffer preceding idx */
 1009f02:	78ea      	ldrb	r2, [r5, #3]
 1009f04:	7829      	ldrb	r1, [r5, #0]
	mem_link_rx.quota_pdu += delta;
 1009f06:	7833      	ldrb	r3, [r6, #0]
	*p = mem; /* store the payload which for API 2 is only a void-ptr */
 1009f08:	fb01 5202 	mla	r2, r1, r2, r5
 1009f0c:	3b01      	subs	r3, #1
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1009f0e:	2fff      	cmp	r7, #255	; 0xff
 1009f10:	6050      	str	r0, [r2, #4]
	mem_link_rx.quota_pdu += delta;
 1009f12:	7033      	strb	r3, [r6, #0]
	*last = idx; /* Commit: Update write index */
 1009f14:	70ec      	strb	r4, [r5, #3]
	while ((max--) && MFIFO_ENQUEUE_IDX_GET(pdu_rx_free, &idx)) {
 1009f16:	d1dc      	bne.n	1009ed2 <ll_rx_mem_release+0x14a>
 1009f18:	e79e      	b.n	1009e58 <ll_rx_mem_release+0xd0>
				struct ll_scan_set *scan =
 1009f1a:	68ab      	ldr	r3, [r5, #8]
 1009f1c:	f8d3 a000 	ldr.w	sl, [r3]
				conn_lll = scan->lll.conn;
 1009f20:	f8da 5024 	ldr.w	r5, [sl, #36]	; 0x24
				LL_ASSERT(conn_lll);
 1009f24:	2d00      	cmp	r5, #0
 1009f26:	d03f      	beq.n	1009fa8 <ll_rx_mem_release+0x220>
				scan->lll.conn = NULL;
 1009f28:	2200      	movs	r2, #0
				LL_ASSERT(!conn_lll->link_tx_free);
 1009f2a:	6deb      	ldr	r3, [r5, #92]	; 0x5c
				scan->lll.conn = NULL;
 1009f2c:	f8ca 2024 	str.w	r2, [sl, #36]	; 0x24
				LL_ASSERT(!conn_lll->link_tx_free);
 1009f30:	b123      	cbz	r3, 1009f3c <ll_rx_mem_release+0x1b4>
 1009f32:	f240 21e6 	movw	r1, #742	; 0x2e6
 1009f36:	4638      	mov	r0, r7
 1009f38:	f7f9 fb26 	bl	1003588 <bt_ctlr_assert_handle>
				link = memq_deinit(&conn_lll->memq_tx.head,
 1009f3c:	f105 0150 	add.w	r1, r5, #80	; 0x50
 1009f40:	f105 004c 	add.w	r0, r5, #76	; 0x4c
 1009f44:	f7fb fec6 	bl	1005cd4 <memq_deinit>
				LL_ASSERT(link);
 1009f48:	4603      	mov	r3, r0
 1009f4a:	b328      	cbz	r0, 1009f98 <ll_rx_mem_release+0x210>
				ll_conn_release(conn);
 1009f4c:	6828      	ldr	r0, [r5, #0]
				conn_lll->link_tx_free = link;
 1009f4e:	65eb      	str	r3, [r5, #92]	; 0x5c
				ll_conn_release(conn);
 1009f50:	f001 faf0 	bl	100b534 <ll_conn_release>
				scan->is_enabled = 0U;
 1009f54:	f89a 3048 	ldrb.w	r3, [sl, #72]	; 0x48
				if (!ull_adv_is_enabled_get(0))
 1009f58:	2000      	movs	r0, #0
				scan->is_enabled = 0U;
 1009f5a:	f36f 0300 	bfc	r3, #0, #1
 1009f5e:	f88a 3048 	strb.w	r3, [sl, #72]	; 0x48
				if (!ull_adv_is_enabled_get(0))
 1009f62:	f000 fdfb 	bl	100ab5c <ull_adv_is_enabled_get>
 1009f66:	2800      	cmp	r0, #0
 1009f68:	f47f af45 	bne.w	1009df6 <ll_rx_mem_release+0x6e>
					ull_filter_adv_scan_state_cb(0);
 1009f6c:	f004 ff0a 	bl	100ed84 <ull_filter_adv_scan_state_cb>
	while (rx) {
 1009f70:	2c00      	cmp	r4, #0
 1009f72:	f47f af13 	bne.w	1009d9c <ll_rx_mem_release+0x14>
 1009f76:	e740      	b.n	1009dfa <ll_rx_mem_release+0x72>
				mem_release(rx_free, &mem_pdu_rx.free);
 1009f78:	4628      	mov	r0, r5
 1009f7a:	4649      	mov	r1, r9
 1009f7c:	f7fb fe6a 	bl	1005c54 <mem_release>
	while (rx) {
 1009f80:	2c00      	cmp	r4, #0
 1009f82:	f47f af0b 	bne.w	1009d9c <ll_rx_mem_release+0x14>
 1009f86:	e738      	b.n	1009dfa <ll_rx_mem_release+0x72>
 1009f88:	9001      	str	r0, [sp, #4]
			LL_ASSERT(link);
 1009f8a:	f240 314e 	movw	r1, #846	; 0x34e
 1009f8e:	4638      	mov	r0, r7
 1009f90:	f7f9 fafa 	bl	1003588 <bt_ctlr_assert_handle>
 1009f94:	9b01      	ldr	r3, [sp, #4]
 1009f96:	e77e      	b.n	1009e96 <ll_rx_mem_release+0x10e>
 1009f98:	9001      	str	r0, [sp, #4]
				LL_ASSERT(link);
 1009f9a:	f240 21e9 	movw	r1, #745	; 0x2e9
 1009f9e:	4638      	mov	r0, r7
 1009fa0:	f7f9 faf2 	bl	1003588 <bt_ctlr_assert_handle>
 1009fa4:	9b01      	ldr	r3, [sp, #4]
 1009fa6:	e7d1      	b.n	1009f4c <ll_rx_mem_release+0x1c4>
				LL_ASSERT(conn_lll);
 1009fa8:	f240 21e3 	movw	r1, #739	; 0x2e3
 1009fac:	4638      	mov	r0, r7
 1009fae:	f7f9 faeb 	bl	1003588 <bt_ctlr_assert_handle>
 1009fb2:	e7b9      	b.n	1009f28 <ll_rx_mem_release+0x1a0>
			mem_release(link, &mem_link_rx.free);
 1009fb4:	4650      	mov	r0, sl
 1009fb6:	4906      	ldr	r1, [pc, #24]	; (1009fd0 <ll_rx_mem_release+0x248>)
}
 1009fb8:	b002      	add	sp, #8
 1009fba:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
			mem_release(link, &mem_link_rx.free);
 1009fbe:	f7fb be49 	b.w	1005c54 <mem_release>
 1009fc2:	bf00      	nop
 1009fc4:	21000e24 	.word	0x21000e24
 1009fc8:	010186e4 	.word	0x010186e4
 1009fcc:	210000c4 	.word	0x210000c4
 1009fd0:	21000e28 	.word	0x21000e28
 1009fd4:	210000d8 	.word	0x210000d8
 1009fd8:	21000f1c 	.word	0x21000f1c

01009fdc <ll_rx_link_alloc>:
	return mem_acquire(&mem_link_rx.free);
 1009fdc:	4801      	ldr	r0, [pc, #4]	; (1009fe4 <ll_rx_link_alloc+0x8>)
 1009fde:	f7fb be1f 	b.w	1005c20 <mem_acquire>
 1009fe2:	bf00      	nop
 1009fe4:	21000e28 	.word	0x21000e28

01009fe8 <ll_rx_link_release>:
	mem_release(link, &mem_link_rx.free);
 1009fe8:	4901      	ldr	r1, [pc, #4]	; (1009ff0 <ll_rx_link_release+0x8>)
 1009fea:	f7fb be33 	b.w	1005c54 <mem_release>
 1009fee:	bf00      	nop
 1009ff0:	21000e28 	.word	0x21000e28

01009ff4 <ll_rx_alloc>:
	return mem_acquire(&mem_pdu_rx.free);
 1009ff4:	4801      	ldr	r0, [pc, #4]	; (1009ffc <ll_rx_alloc+0x8>)
 1009ff6:	f7fb be13 	b.w	1005c20 <mem_acquire>
 1009ffa:	bf00      	nop
 1009ffc:	21000f1c 	.word	0x21000f1c

0100a000 <ll_rx_release>:
	mem_release(node_rx, &mem_pdu_rx.free);
 100a000:	4901      	ldr	r1, [pc, #4]	; (100a008 <ll_rx_release+0x8>)
 100a002:	f7fb be27 	b.w	1005c54 <mem_release>
 100a006:	bf00      	nop
 100a008:	21000f1c 	.word	0x21000f1c

0100a00c <ll_rx_put>:
	rx_hdr->ack_last = mfifo_tx_ack.l;
 100a00c:	4b02      	ldr	r3, [pc, #8]	; (100a018 <ll_rx_put+0xc>)
	memq_enqueue(link, rx, &memq_ll_rx.tail);
 100a00e:	4a03      	ldr	r2, [pc, #12]	; (100a01c <ll_rx_put+0x10>)
	rx_hdr->ack_last = mfifo_tx_ack.l;
 100a010:	78db      	ldrb	r3, [r3, #3]
 100a012:	700b      	strb	r3, [r1, #0]
	memq_enqueue(link, rx, &memq_ll_rx.tail);
 100a014:	f7fb be68 	b.w	1005ce8 <memq_enqueue>
 100a018:	21000228 	.word	0x21000228
 100a01c:	2100134c 	.word	0x2100134c

0100a020 <ll_rx_sched>:
	k_sem_give(sem_recv);
 100a020:	4b01      	ldr	r3, [pc, #4]	; (100a028 <ll_rx_sched+0x8>)
 100a022:	6818      	ldr	r0, [r3, #0]
	z_impl_k_sem_give(sem);
 100a024:	f00a bb10 	b.w	1014648 <z_impl_k_sem_give>
 100a028:	21001358 	.word	0x21001358

0100a02c <ll_pdu_rx_alloc_peek>:
{
 100a02c:	b410      	push	{r4}
	if (count > MFIFO_AVAIL_COUNT_GET(ll_pdu_rx_free)) {
 100a02e:	4a0d      	ldr	r2, [pc, #52]	; (100a064 <ll_pdu_rx_alloc_peek+0x38>)
 100a030:	7893      	ldrb	r3, [r2, #2]
 100a032:	78d4      	ldrb	r4, [r2, #3]
	if (last >= first) {
 100a034:	42a3      	cmp	r3, r4
 100a036:	d809      	bhi.n	100a04c <ll_pdu_rx_alloc_peek+0x20>
		return last - first;
 100a038:	1ae1      	subs	r1, r4, r3
 100a03a:	b2c9      	uxtb	r1, r1
 100a03c:	4288      	cmp	r0, r1
 100a03e:	d802      	bhi.n	100a046 <ll_pdu_rx_alloc_peek+0x1a>
	if (first == last) {
 100a040:	42a3      	cmp	r3, r4
	return MFIFO_DEQUEUE_PEEK(ll_pdu_rx_free);
 100a042:	7811      	ldrb	r1, [r2, #0]
 100a044:	d109      	bne.n	100a05a <ll_pdu_rx_alloc_peek+0x2e>
		return NULL;
 100a046:	2000      	movs	r0, #0
}
 100a048:	bc10      	pop	{r4}
 100a04a:	4770      	bx	lr
		return count - first + last;
 100a04c:	7851      	ldrb	r1, [r2, #1]
 100a04e:	1ac9      	subs	r1, r1, r3
 100a050:	4421      	add	r1, r4
	if (count > MFIFO_AVAIL_COUNT_GET(ll_pdu_rx_free)) {
 100a052:	b2c9      	uxtb	r1, r1
 100a054:	4288      	cmp	r0, r1
 100a056:	d8f6      	bhi.n	100a046 <ll_pdu_rx_alloc_peek+0x1a>
	return MFIFO_DEQUEUE_PEEK(ll_pdu_rx_free);
 100a058:	7811      	ldrb	r1, [r2, #0]
	return *((void **)(fifo + first * size));
 100a05a:	fb01 2303 	mla	r3, r1, r3, r2
}
 100a05e:	bc10      	pop	{r4}
 100a060:	6858      	ldr	r0, [r3, #4]
 100a062:	4770      	bx	lr
 100a064:	210000c4 	.word	0x210000c4

0100a068 <ll_pdu_rx_alloc>:
{
 100a068:	b410      	push	{r4}
	return MFIFO_DEQUEUE(ll_pdu_rx_free);
 100a06a:	4b0a      	ldr	r3, [pc, #40]	; (100a094 <ll_pdu_rx_alloc+0x2c>)
	u8_t _first = *first; /* Copy read-index */
 100a06c:	7899      	ldrb	r1, [r3, #2]
	if (_first == last) {
 100a06e:	78da      	ldrb	r2, [r3, #3]
 100a070:	7818      	ldrb	r0, [r3, #0]
 100a072:	428a      	cmp	r2, r1
 100a074:	785c      	ldrb	r4, [r3, #1]
 100a076:	d00a      	beq.n	100a08e <ll_pdu_rx_alloc+0x26>
	_first += 1U;
 100a078:	1c4a      	adds	r2, r1, #1
 100a07a:	b2d2      	uxtb	r2, r2
		_first = 0U;
 100a07c:	4294      	cmp	r4, r2
 100a07e:	bf08      	it	eq
 100a080:	2200      	moveq	r2, #0
	mem = *((void **)(fifo + _first * size));
 100a082:	fb00 3101 	mla	r1, r0, r1, r3
 100a086:	6848      	ldr	r0, [r1, #4]
	*first = _first; /* Write back read-index */
 100a088:	709a      	strb	r2, [r3, #2]
}
 100a08a:	bc10      	pop	{r4}
 100a08c:	4770      	bx	lr
		return NULL;
 100a08e:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(ll_pdu_rx_free);
 100a090:	e7fb      	b.n	100a08a <ll_pdu_rx_alloc+0x22>
 100a092:	bf00      	nop
 100a094:	210000c4 	.word	0x210000c4

0100a098 <ll_tx_ack_put>:
{
 100a098:	b570      	push	{r4, r5, r6, lr}
	idx = MFIFO_ENQUEUE_GET(tx_ack, (void **)&tx);
 100a09a:	4c0f      	ldr	r4, [pc, #60]	; (100a0d8 <ll_tx_ack_put+0x40>)
 100a09c:	78e2      	ldrb	r2, [r4, #3]
	if (last == count) {
 100a09e:	7865      	ldrb	r5, [r4, #1]
	last = last + 1;
 100a0a0:	1c53      	adds	r3, r2, #1
 100a0a2:	b2db      	uxtb	r3, r3
		last = 0U;
 100a0a4:	429d      	cmp	r5, r3
 100a0a6:	bf08      	it	eq
 100a0a8:	2300      	moveq	r3, #0
 100a0aa:	78a5      	ldrb	r5, [r4, #2]
	if (last == first) {
 100a0ac:	429d      	cmp	r5, r3
 100a0ae:	d00a      	beq.n	100a0c6 <ll_tx_ack_put+0x2e>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
 100a0b0:	4625      	mov	r5, r4
 100a0b2:	f815 6b04 	ldrb.w	r6, [r5], #4
 100a0b6:	fb02 f206 	mul.w	r2, r2, r6
	LL_ASSERT(tx);
 100a0ba:	18ae      	adds	r6, r5, r2
 100a0bc:	d003      	beq.n	100a0c6 <ll_tx_ack_put+0x2e>
	tx->handle = handle;
 100a0be:	52a8      	strh	r0, [r5, r2]
	tx->node = node_tx;
 100a0c0:	6071      	str	r1, [r6, #4]
	*last = idx; /* Commit: Update write index */
 100a0c2:	70e3      	strb	r3, [r4, #3]
}
 100a0c4:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(tx);
 100a0c6:	f240 31ae 	movw	r1, #942	; 0x3ae
 100a0ca:	4804      	ldr	r0, [pc, #16]	; (100a0dc <ll_tx_ack_put+0x44>)
 100a0cc:	f7f9 fa5c 	bl	1003588 <bt_ctlr_assert_handle>
	tx->handle = handle;
 100a0d0:	2300      	movs	r3, #0
 100a0d2:	801b      	strh	r3, [r3, #0]
 100a0d4:	deff      	udf	#255	; 0xff
 100a0d6:	bf00      	nop
 100a0d8:	21000228 	.word	0x21000228
 100a0dc:	010186e4 	.word	0x010186e4

0100a0e0 <ull_ticker_status_give>:
	*((u32_t volatile *)param) = status;
 100a0e0:	6008      	str	r0, [r1, #0]
 100a0e2:	4801      	ldr	r0, [pc, #4]	; (100a0e8 <ull_ticker_status_give+0x8>)
 100a0e4:	f00a bab0 	b.w	1014648 <z_impl_k_sem_give>
 100a0e8:	2100135c 	.word	0x2100135c

0100a0ec <ull_ticker_status_take>:
{
 100a0ec:	b510      	push	{r4, lr}
 100a0ee:	f04f 32ff 	mov.w	r2, #4294967295
 100a0f2:	f04f 33ff 	mov.w	r3, #4294967295
 100a0f6:	460c      	mov	r4, r1
	return z_impl_k_sem_take(sem, timeout);
 100a0f8:	4802      	ldr	r0, [pc, #8]	; (100a104 <ull_ticker_status_take+0x18>)
 100a0fa:	f00a facb 	bl	1014694 <z_impl_k_sem_take>
	return *ret_cb;
 100a0fe:	6820      	ldr	r0, [r4, #0]
}
 100a100:	bd10      	pop	{r4, pc}
 100a102:	bf00      	nop
 100a104:	2100135c 	.word	0x2100135c

0100a108 <ull_disable_mark>:
	if (!*m) {
 100a108:	4a03      	ldr	r2, [pc, #12]	; (100a118 <ull_disable_mark+0x10>)
{
 100a10a:	4603      	mov	r3, r0
	if (!*m) {
 100a10c:	6810      	ldr	r0, [r2, #0]
 100a10e:	b100      	cbz	r0, 100a112 <ull_disable_mark+0xa>
}
 100a110:	4770      	bx	lr
		*m = param;
 100a112:	4618      	mov	r0, r3
 100a114:	6013      	str	r3, [r2, #0]
}
 100a116:	4770      	bx	lr
 100a118:	21000d54 	.word	0x21000d54

0100a11c <ull_disable_unmark>:
	if (*m && *m == param) {
 100a11c:	4a05      	ldr	r2, [pc, #20]	; (100a134 <ull_disable_unmark+0x18>)
{
 100a11e:	4603      	mov	r3, r0
	if (*m && *m == param) {
 100a120:	6810      	ldr	r0, [r2, #0]
 100a122:	b110      	cbz	r0, 100a12a <ull_disable_unmark+0xe>
 100a124:	4283      	cmp	r3, r0
 100a126:	d001      	beq.n	100a12c <ull_disable_unmark+0x10>
	return NULL;
 100a128:	2000      	movs	r0, #0
}
 100a12a:	4770      	bx	lr
		*m = NULL;
 100a12c:	2300      	movs	r3, #0
 100a12e:	6013      	str	r3, [r2, #0]
		return param;
 100a130:	4770      	bx	lr
 100a132:	bf00      	nop
 100a134:	21000d54 	.word	0x21000d54

0100a138 <ull_disable_mark_get>:
	return mark_get(mark_disable);
 100a138:	4b01      	ldr	r3, [pc, #4]	; (100a140 <ull_disable_mark_get+0x8>)
}
 100a13a:	6818      	ldr	r0, [r3, #0]
 100a13c:	4770      	bx	lr
 100a13e:	bf00      	nop
 100a140:	21000d54 	.word	0x21000d54

0100a144 <ull_update_mark>:
	if (!*m) {
 100a144:	4a03      	ldr	r2, [pc, #12]	; (100a154 <ull_update_mark+0x10>)
{
 100a146:	4603      	mov	r3, r0
	if (!*m) {
 100a148:	6810      	ldr	r0, [r2, #0]
 100a14a:	b100      	cbz	r0, 100a14e <ull_update_mark+0xa>
}
 100a14c:	4770      	bx	lr
		*m = param;
 100a14e:	4618      	mov	r0, r3
 100a150:	6013      	str	r3, [r2, #0]
}
 100a152:	4770      	bx	lr
 100a154:	21000d58 	.word	0x21000d58

0100a158 <ull_update_unmark>:
	if (*m && *m == param) {
 100a158:	4a05      	ldr	r2, [pc, #20]	; (100a170 <ull_update_unmark+0x18>)
{
 100a15a:	4603      	mov	r3, r0
	if (*m && *m == param) {
 100a15c:	6810      	ldr	r0, [r2, #0]
 100a15e:	b110      	cbz	r0, 100a166 <ull_update_unmark+0xe>
 100a160:	4283      	cmp	r3, r0
 100a162:	d001      	beq.n	100a168 <ull_update_unmark+0x10>
	return NULL;
 100a164:	2000      	movs	r0, #0
}
 100a166:	4770      	bx	lr
		*m = NULL;
 100a168:	2300      	movs	r3, #0
 100a16a:	6013      	str	r3, [r2, #0]
		return param;
 100a16c:	4770      	bx	lr
 100a16e:	bf00      	nop
 100a170:	21000d58 	.word	0x21000d58

0100a174 <ull_update_mark_get>:
	return mark_get(mark_update);
 100a174:	4b01      	ldr	r3, [pc, #4]	; (100a17c <ull_update_mark_get+0x8>)
}
 100a176:	6818      	ldr	r0, [r3, #0]
 100a178:	4770      	bx	lr
 100a17a:	bf00      	nop
 100a17c:	21000d58 	.word	0x21000d58

0100a180 <ull_disable>:
{
 100a180:	b530      	push	{r4, r5, lr}
	hdr = HDR_ULL(((struct lll_hdr *)lll)->parent);
 100a182:	6805      	ldr	r5, [r0, #0]
{
 100a184:	b087      	sub	sp, #28
	if (!hdr) {
 100a186:	f115 0f10 	cmn.w	r5, #16
 100a18a:	d00b      	beq.n	100a1a4 <ull_disable+0x24>
	compiler_barrier();
 100a18c:	4604      	mov	r4, r0
	return z_impl_k_sem_init(sem, initial_count, limit);
 100a18e:	2201      	movs	r2, #1
 100a190:	4668      	mov	r0, sp
 100a192:	2100      	movs	r1, #0
 100a194:	f00d fc98 	bl	1017ac8 <z_impl_k_sem_init>
	hdr->disabled_cb = disabled_cb;
 100a198:	4a0f      	ldr	r2, [pc, #60]	; (100a1d8 <ull_disable+0x58>)
	if (!hdr->ref) {
 100a19a:	7c2b      	ldrb	r3, [r5, #16]
	hdr->disabled_param = &sem;
 100a19c:	f8c5 d018 	str.w	sp, [r5, #24]
	hdr->disabled_cb = disabled_cb;
 100a1a0:	616a      	str	r2, [r5, #20]
	if (!hdr->ref) {
 100a1a2:	b913      	cbnz	r3, 100a1aa <ull_disable+0x2a>
		return ULL_STATUS_SUCCESS;
 100a1a4:	2000      	movs	r0, #0
}
 100a1a6:	b007      	add	sp, #28
 100a1a8:	bd30      	pop	{r4, r5, pc}
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
 100a1aa:	2200      	movs	r2, #0
	mfy.param = lll;
 100a1ac:	4b0b      	ldr	r3, [pc, #44]	; (100a1dc <ull_disable+0x5c>)
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
 100a1ae:	4611      	mov	r1, r2
 100a1b0:	2003      	movs	r0, #3
	mfy.param = lll;
 100a1b2:	609c      	str	r4, [r3, #8]
	ret = mayfly_enqueue(TICKER_USER_ID_THREAD, TICKER_USER_ID_LLL, 0,
 100a1b4:	f7fb fe0c 	bl	1005dd0 <mayfly_enqueue>
	LL_ASSERT(!ret);
 100a1b8:	b940      	cbnz	r0, 100a1cc <ull_disable+0x4c>
	return z_impl_k_sem_take(sem, timeout);
 100a1ba:	f04f 32ff 	mov.w	r2, #4294967295
 100a1be:	f04f 33ff 	mov.w	r3, #4294967295
 100a1c2:	4668      	mov	r0, sp
 100a1c4:	f00a fa66 	bl	1014694 <z_impl_k_sem_take>
}
 100a1c8:	b007      	add	sp, #28
 100a1ca:	bd30      	pop	{r4, r5, pc}
	LL_ASSERT(!ret);
 100a1cc:	f240 4119 	movw	r1, #1049	; 0x419
 100a1d0:	4803      	ldr	r0, [pc, #12]	; (100a1e0 <ull_disable+0x60>)
 100a1d2:	f7f9 f9d9 	bl	1003588 <bt_ctlr_assert_handle>
 100a1d6:	e7f0      	b.n	100a1ba <ull_disable+0x3a>
 100a1d8:	010091a9 	.word	0x010091a9
 100a1dc:	2100027c 	.word	0x2100027c
 100a1e0:	010186e4 	.word	0x010186e4

0100a1e4 <ull_pdu_rx_alloc_peek>:
{
 100a1e4:	b410      	push	{r4}
	if (count > MFIFO_AVAIL_COUNT_GET(pdu_rx_free)) {
 100a1e6:	4a0d      	ldr	r2, [pc, #52]	; (100a21c <ull_pdu_rx_alloc_peek+0x38>)
 100a1e8:	7893      	ldrb	r3, [r2, #2]
 100a1ea:	78d4      	ldrb	r4, [r2, #3]
	if (last >= first) {
 100a1ec:	42a3      	cmp	r3, r4
 100a1ee:	d809      	bhi.n	100a204 <ull_pdu_rx_alloc_peek+0x20>
		return last - first;
 100a1f0:	1ae1      	subs	r1, r4, r3
 100a1f2:	b2c9      	uxtb	r1, r1
 100a1f4:	4288      	cmp	r0, r1
 100a1f6:	d802      	bhi.n	100a1fe <ull_pdu_rx_alloc_peek+0x1a>
	if (first == last) {
 100a1f8:	42a3      	cmp	r3, r4
	return MFIFO_DEQUEUE_PEEK(pdu_rx_free);
 100a1fa:	7811      	ldrb	r1, [r2, #0]
 100a1fc:	d109      	bne.n	100a212 <ull_pdu_rx_alloc_peek+0x2e>
		return NULL;
 100a1fe:	2000      	movs	r0, #0
}
 100a200:	bc10      	pop	{r4}
 100a202:	4770      	bx	lr
		return count - first + last;
 100a204:	7851      	ldrb	r1, [r2, #1]
 100a206:	1ac9      	subs	r1, r1, r3
 100a208:	4421      	add	r1, r4
	if (count > MFIFO_AVAIL_COUNT_GET(pdu_rx_free)) {
 100a20a:	b2c9      	uxtb	r1, r1
 100a20c:	4288      	cmp	r0, r1
 100a20e:	d8f6      	bhi.n	100a1fe <ull_pdu_rx_alloc_peek+0x1a>
	return MFIFO_DEQUEUE_PEEK(pdu_rx_free);
 100a210:	7811      	ldrb	r1, [r2, #0]
	return *((void **)(fifo + first * size));
 100a212:	fb01 2303 	mla	r3, r1, r3, r2
}
 100a216:	bc10      	pop	{r4}
 100a218:	6858      	ldr	r0, [r3, #4]
 100a21a:	4770      	bx	lr
 100a21c:	210000d8 	.word	0x210000d8

0100a220 <ull_pdu_rx_alloc>:
{
 100a220:	b410      	push	{r4}
	return MFIFO_DEQUEUE(pdu_rx_free);
 100a222:	4b0a      	ldr	r3, [pc, #40]	; (100a24c <ull_pdu_rx_alloc+0x2c>)
	u8_t _first = *first; /* Copy read-index */
 100a224:	7899      	ldrb	r1, [r3, #2]
	if (_first == last) {
 100a226:	78da      	ldrb	r2, [r3, #3]
 100a228:	7818      	ldrb	r0, [r3, #0]
 100a22a:	428a      	cmp	r2, r1
 100a22c:	785c      	ldrb	r4, [r3, #1]
 100a22e:	d00a      	beq.n	100a246 <ull_pdu_rx_alloc+0x26>
	_first += 1U;
 100a230:	1c4a      	adds	r2, r1, #1
 100a232:	b2d2      	uxtb	r2, r2
		_first = 0U;
 100a234:	4294      	cmp	r4, r2
 100a236:	bf08      	it	eq
 100a238:	2200      	moveq	r2, #0
	mem = *((void **)(fifo + _first * size));
 100a23a:	fb00 3101 	mla	r1, r0, r1, r3
 100a23e:	6848      	ldr	r0, [r1, #4]
	*first = _first; /* Write back read-index */
 100a240:	709a      	strb	r2, [r3, #2]
}
 100a242:	bc10      	pop	{r4}
 100a244:	4770      	bx	lr
		return NULL;
 100a246:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(pdu_rx_free);
 100a248:	e7fb      	b.n	100a242 <ull_pdu_rx_alloc+0x22>
 100a24a:	bf00      	nop
 100a24c:	210000d8 	.word	0x210000d8

0100a250 <ull_rx_put>:
{
 100a250:	b538      	push	{r3, r4, r5, lr}
 100a252:	460c      	mov	r4, r1
 100a254:	4605      	mov	r5, r0
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
 100a256:	f003 fca1 	bl	100db9c <ull_conn_ack_last_idx_get>
	memq_enqueue(link, rx, &memq_ull_rx.tail);
 100a25a:	4621      	mov	r1, r4
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
 100a25c:	7020      	strb	r0, [r4, #0]
	memq_enqueue(link, rx, &memq_ull_rx.tail);
 100a25e:	4a03      	ldr	r2, [pc, #12]	; (100a26c <ull_rx_put+0x1c>)
 100a260:	4628      	mov	r0, r5
}
 100a262:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	memq_enqueue(link, rx, &memq_ull_rx.tail);
 100a266:	f7fb bd3f 	b.w	1005ce8 <memq_enqueue>
 100a26a:	bf00      	nop
 100a26c:	21001354 	.word	0x21001354

0100a270 <ull_rx_sched>:
	mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_ULL_HIGH, 1, &mfy);
 100a270:	2201      	movs	r2, #1
 100a272:	2000      	movs	r0, #0
 100a274:	4611      	mov	r1, r2
 100a276:	4b01      	ldr	r3, [pc, #4]	; (100a27c <ull_rx_sched+0xc>)
 100a278:	f7fb bdaa 	b.w	1005dd0 <mayfly_enqueue>
 100a27c:	2100028c 	.word	0x2100028c

0100a280 <ull_prepare_enqueue>:
{
 100a280:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
 100a284:	4e19      	ldr	r6, [pc, #100]	; (100a2ec <ull_prepare_enqueue+0x6c>)
{
 100a286:	f89d a024 	ldrb.w	sl, [sp, #36]	; 0x24
	idx = MFIFO_ENQUEUE_GET(prep, (void **)&e);
 100a28a:	78f4      	ldrb	r4, [r6, #3]
	if (last == count) {
 100a28c:	7877      	ldrb	r7, [r6, #1]
	last = last + 1;
 100a28e:	1c65      	adds	r5, r4, #1
 100a290:	b2ed      	uxtb	r5, r5
		last = 0U;
 100a292:	42af      	cmp	r7, r5
 100a294:	bf08      	it	eq
 100a296:	2500      	moveq	r5, #0
 100a298:	f896 c002 	ldrb.w	ip, [r6, #2]
	if (last == first) {
 100a29c:	45ac      	cmp	ip, r5
 100a29e:	d020      	beq.n	100a2e2 <ull_prepare_enqueue+0x62>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
 100a2a0:	4699      	mov	r9, r3
 100a2a2:	4633      	mov	r3, r6
 100a2a4:	460f      	mov	r7, r1
 100a2a6:	4611      	mov	r1, r2
 100a2a8:	f813 2b04 	ldrb.w	r2, [r3], #4
 100a2ac:	fb04 3402 	mla	r4, r4, r2, r3
	if (!e) {
 100a2b0:	b1bc      	cbz	r4, 100a2e2 <ull_prepare_enqueue+0x62>
 100a2b2:	4680      	mov	r8, r0
	memcpy(&e->prepare_param, prepare_param, sizeof(e->prepare_param));
 100a2b4:	2210      	movs	r2, #16
 100a2b6:	4620      	mov	r0, r4
 100a2b8:	f00c fafe 	bl	10168b8 <memcpy>
	e->is_resume = is_resume;
 100a2bc:	f894 2020 	ldrb.w	r2, [r4, #32]
	e->prio = prio;
 100a2c0:	9b08      	ldr	r3, [sp, #32]
	e->is_resume = is_resume;
 100a2c2:	f00a 0a01 	and.w	sl, sl, #1
 100a2c6:	f022 0203 	bic.w	r2, r2, #3
 100a2ca:	ea42 020a 	orr.w	r2, r2, sl
	return 0;
 100a2ce:	2000      	movs	r0, #0
	e->is_abort_cb = is_abort_cb;
 100a2d0:	e9c4 9804 	strd	r9, r8, [r4, #16]
	e->abort_cb = abort_cb;
 100a2d4:	61a7      	str	r7, [r4, #24]
	e->prio = prio;
 100a2d6:	61e3      	str	r3, [r4, #28]
	*last = idx; /* Commit: Update write index */
 100a2d8:	70f5      	strb	r5, [r6, #3]
	e->is_resume = is_resume;
 100a2da:	f884 2020 	strb.w	r2, [r4, #32]
}
 100a2de:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return -ENOBUFS;
 100a2e2:	f06f 0036 	mvn.w	r0, #54	; 0x36
}
 100a2e6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 100a2ea:	bf00      	nop
 100a2ec:	21000104 	.word	0x21000104

0100a2f0 <ull_prepare_dequeue_get>:
	return MFIFO_DEQUEUE_GET(prep);
 100a2f0:	4b05      	ldr	r3, [pc, #20]	; (100a308 <ull_prepare_dequeue_get+0x18>)
 100a2f2:	7898      	ldrb	r0, [r3, #2]
	if (first == last) {
 100a2f4:	78da      	ldrb	r2, [r3, #3]
 100a2f6:	7819      	ldrb	r1, [r3, #0]
 100a2f8:	4282      	cmp	r2, r0
	return (void *)(fifo + first * size);
 100a2fa:	bf1a      	itte	ne
 100a2fc:	3304      	addne	r3, #4
 100a2fe:	fb01 3000 	mlane	r0, r1, r0, r3
		return NULL;
 100a302:	2000      	moveq	r0, #0
}
 100a304:	4770      	bx	lr
 100a306:	bf00      	nop
 100a308:	21000104 	.word	0x21000104

0100a30c <ull_prepare_dequeue_iter>:
{
 100a30c:	b430      	push	{r4, r5}
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
 100a30e:	4a0c      	ldr	r2, [pc, #48]	; (100a340 <ull_prepare_dequeue_iter+0x34>)
	if (*idx >= count) {
 100a310:	7803      	ldrb	r3, [r0, #0]
 100a312:	7851      	ldrb	r1, [r2, #1]
 100a314:	78d4      	ldrb	r4, [r2, #3]
 100a316:	4299      	cmp	r1, r3
 100a318:	bf98      	it	ls
 100a31a:	7893      	ldrbls	r3, [r2, #2]
 100a31c:	7815      	ldrb	r5, [r2, #0]
		*idx = first;
 100a31e:	bf98      	it	ls
 100a320:	7003      	strbls	r3, [r0, #0]
	if (*idx == last) {
 100a322:	429c      	cmp	r4, r3
 100a324:	d00a      	beq.n	100a33c <ull_prepare_dequeue_iter+0x30>
	i = *idx + 1;
 100a326:	1c5a      	adds	r2, r3, #1
 100a328:	b2d2      	uxtb	r2, r2
		i = 0U;
 100a32a:	4291      	cmp	r1, r2
 100a32c:	bf08      	it	eq
 100a32e:	2200      	moveq	r2, #0
	p = (void *)(fifo + (*idx) * size);
 100a330:	4904      	ldr	r1, [pc, #16]	; (100a344 <ull_prepare_dequeue_iter+0x38>)
	*idx = i;
 100a332:	7002      	strb	r2, [r0, #0]
	p = (void *)(fifo + (*idx) * size);
 100a334:	fb05 1003 	mla	r0, r5, r3, r1
}
 100a338:	bc30      	pop	{r4, r5}
 100a33a:	4770      	bx	lr
		return NULL;
 100a33c:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE_ITER_GET(prep, idx);
 100a33e:	e7fb      	b.n	100a338 <ull_prepare_dequeue_iter+0x2c>
 100a340:	21000104 	.word	0x21000104
 100a344:	21000108 	.word	0x21000108

0100a348 <ull_event_done_extra_get>:
	evdone = MFIFO_DEQUEUE_PEEK(done);
 100a348:	4b06      	ldr	r3, [pc, #24]	; (100a364 <ull_event_done_extra_get+0x1c>)
 100a34a:	789a      	ldrb	r2, [r3, #2]
	if (first == last) {
 100a34c:	78d9      	ldrb	r1, [r3, #3]
 100a34e:	7818      	ldrb	r0, [r3, #0]
 100a350:	4291      	cmp	r1, r2
 100a352:	d005      	beq.n	100a360 <ull_event_done_extra_get+0x18>
	return *((void **)(fifo + first * size));
 100a354:	fb00 3302 	mla	r3, r0, r2, r3
 100a358:	6858      	ldr	r0, [r3, #4]
	if (!evdone) {
 100a35a:	b110      	cbz	r0, 100a362 <ull_event_done_extra_get+0x1a>
	return &evdone->extra;
 100a35c:	3024      	adds	r0, #36	; 0x24
 100a35e:	4770      	bx	lr
		return NULL;
 100a360:	2000      	movs	r0, #0
}
 100a362:	4770      	bx	lr
 100a364:	210000b0 	.word	0x210000b0

0100a368 <ull_event_done>:
{
 100a368:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	evdone = MFIFO_DEQUEUE(done);
 100a36a:	4b14      	ldr	r3, [pc, #80]	; (100a3bc <ull_event_done+0x54>)
	u8_t _first = *first; /* Copy read-index */
 100a36c:	7899      	ldrb	r1, [r3, #2]
	if (_first == last) {
 100a36e:	78da      	ldrb	r2, [r3, #3]
 100a370:	781c      	ldrb	r4, [r3, #0]
 100a372:	428a      	cmp	r2, r1
 100a374:	785d      	ldrb	r5, [r3, #1]
 100a376:	d01f      	beq.n	100a3b8 <ull_event_done+0x50>
	_first += 1U;
 100a378:	1c4a      	adds	r2, r1, #1
 100a37a:	b2d2      	uxtb	r2, r2
		_first = 0U;
 100a37c:	4295      	cmp	r5, r2
 100a37e:	bf08      	it	eq
 100a380:	2200      	moveq	r2, #0
	mem = *((void **)(fifo + _first * size));
 100a382:	fb04 3101 	mla	r1, r4, r1, r3
 100a386:	684c      	ldr	r4, [r1, #4]
	*first = _first; /* Write back read-index */
 100a388:	709a      	strb	r2, [r3, #2]
	if (!evdone) {
 100a38a:	b19c      	cbz	r4, 100a3b4 <ull_event_done+0x4c>
	evdone->hdr.type = NODE_RX_TYPE_EVENT_DONE;
 100a38c:	2501      	movs	r5, #1
	evdone->hdr.link = NULL;
 100a38e:	2600      	movs	r6, #0
	link = evdone->hdr.link;
 100a390:	6827      	ldr	r7, [r4, #0]
	evdone->param = param;
 100a392:	6220      	str	r0, [r4, #32]
	evdone->hdr.type = NODE_RX_TYPE_EVENT_DONE;
 100a394:	7125      	strb	r5, [r4, #4]
	evdone->hdr.link = NULL;
 100a396:	6026      	str	r6, [r4, #0]
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
 100a398:	f003 fc00 	bl	100db9c <ull_conn_ack_last_idx_get>
	memq_enqueue(link, rx, &memq_ull_rx.tail);
 100a39c:	4621      	mov	r1, r4
 100a39e:	4a08      	ldr	r2, [pc, #32]	; (100a3c0 <ull_event_done+0x58>)
	rx_hdr->ack_last = ull_conn_ack_last_idx_get();
 100a3a0:	7020      	strb	r0, [r4, #0]
	memq_enqueue(link, rx, &memq_ull_rx.tail);
 100a3a2:	4638      	mov	r0, r7
 100a3a4:	f7fb fca0 	bl	1005ce8 <memq_enqueue>
	mayfly_enqueue(TICKER_USER_ID_LLL, TICKER_USER_ID_ULL_HIGH, 1, &mfy);
 100a3a8:	4630      	mov	r0, r6
 100a3aa:	462a      	mov	r2, r5
 100a3ac:	4629      	mov	r1, r5
 100a3ae:	4b05      	ldr	r3, [pc, #20]	; (100a3c4 <ull_event_done+0x5c>)
 100a3b0:	f7fb fd0e 	bl	1005dd0 <mayfly_enqueue>
}
 100a3b4:	4620      	mov	r0, r4
 100a3b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return NULL;
 100a3b8:	2400      	movs	r4, #0
 100a3ba:	e7fb      	b.n	100a3b4 <ull_event_done+0x4c>
 100a3bc:	210000b0 	.word	0x210000b0
 100a3c0:	21001354 	.word	0x21001354
 100a3c4:	2100028c 	.word	0x2100028c

0100a3c8 <lll_chan_sel_1>:
#endif /* CONFIG_BT_CONN */

#if defined(CONFIG_BT_CONN)
u8_t lll_chan_sel_1(u8_t *chan_use, u8_t hop, u16_t latency, u8_t *chan_map,
		    u8_t chan_count)
{
 100a3c8:	b470      	push	{r4, r5, r6}
 100a3ca:	4604      	mov	r4, r0
	u8_t chan_next;

	chan_next = ((*chan_use) + (hop * (1 + latency))) % 37;
 100a3cc:	fb02 1101 	mla	r1, r2, r1, r1
 100a3d0:	7800      	ldrb	r0, [r0, #0]
 100a3d2:	4a1a      	ldr	r2, [pc, #104]	; (100a43c <lll_chan_sel_1+0x74>)
 100a3d4:	4401      	add	r1, r0
 100a3d6:	fb82 0201 	smull	r0, r2, r2, r1
 100a3da:	440a      	add	r2, r1
 100a3dc:	1152      	asrs	r2, r2, #5
 100a3de:	eb02 00c2 	add.w	r0, r2, r2, lsl #3
 100a3e2:	eb02 0280 	add.w	r2, r2, r0, lsl #2
 100a3e6:	1a8a      	subs	r2, r1, r2
 100a3e8:	b2d0      	uxtb	r0, r2
	*chan_use = chan_next;

	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
 100a3ea:	08c1      	lsrs	r1, r0, #3
	*chan_use = chan_next;
 100a3ec:	7020      	strb	r0, [r4, #0]
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
 100a3ee:	5c5c      	ldrb	r4, [r3, r1]
 100a3f0:	f002 0207 	and.w	r2, r2, #7
 100a3f4:	4114      	asrs	r4, r2
 100a3f6:	f014 0401 	ands.w	r4, r4, #1
{
 100a3fa:	f89d 100c 	ldrb.w	r1, [sp, #12]
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
 100a3fe:	d11b      	bne.n	100a438 <lll_chan_sel_1+0x70>
		u8_t chan_index;

		chan_index = chan_next % chan_count;
 100a400:	fbb0 f2f1 	udiv	r2, r0, r1
 100a404:	fb01 0212 	mls	r2, r1, r2, r0
 100a408:	1e5d      	subs	r5, r3, #1
 100a40a:	b2d2      	uxtb	r2, r2
	u8_t chan_next;
	u8_t byte_count;

	chan_next = 0U;
	byte_count = 5U;
	while (byte_count--) {
 100a40c:	1d1e      	adds	r6, r3, #4
		u8_t bite;
		u8_t bit_count;

		bite = *chan_map;
 100a40e:	f104 0108 	add.w	r1, r4, #8
 100a412:	f815 3f01 	ldrb.w	r3, [r5, #1]!
		bit_count = 8U;
		while (bit_count--) {
 100a416:	4620      	mov	r0, r4
 100a418:	b2cc      	uxtb	r4, r1
			if (bite & 0x01) {
 100a41a:	f013 0f01 	tst.w	r3, #1
				if (chan_index == 0U) {
					break;
				}
				chan_index--;
			}
			chan_next++;
 100a41e:	f100 0101 	add.w	r1, r0, #1
			bite >>= 1;
 100a422:	ea4f 0353 	mov.w	r3, r3, lsr #1
			if (bite & 0x01) {
 100a426:	d002      	beq.n	100a42e <lll_chan_sel_1+0x66>
				if (chan_index == 0U) {
 100a428:	b132      	cbz	r2, 100a438 <lll_chan_sel_1+0x70>
				chan_index--;
 100a42a:	3a01      	subs	r2, #1
 100a42c:	b2d2      	uxtb	r2, r2
			chan_next++;
 100a42e:	b2c8      	uxtb	r0, r1
		while (bit_count--) {
 100a430:	4284      	cmp	r4, r0
 100a432:	d1f2      	bne.n	100a41a <lll_chan_sel_1+0x52>
	while (byte_count--) {
 100a434:	42b5      	cmp	r5, r6
 100a436:	d1ea      	bne.n	100a40e <lll_chan_sel_1+0x46>
}
 100a438:	bc70      	pop	{r4, r5, r6}
 100a43a:	4770      	bx	lr
 100a43c:	dd67c8a7 	.word	0xdd67c8a7

0100a440 <lll_chan_sel_2>:
{
 100a440:	b5f0      	push	{r4, r5, r6, r7, lr}
static u16_t chan_prn(u16_t counter, u16_t chan_id)
{
	u8_t iterate;
	u16_t prn_e;

	prn_e = counter ^ chan_id;
 100a442:	2403      	movs	r4, #3
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
 100a444:	4f2e      	ldr	r7, [pc, #184]	; (100a500 <lll_chan_sel_2+0xc0>)
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
 100a446:	4e2f      	ldr	r6, [pc, #188]	; (100a504 <lll_chan_sel_2+0xc4>)
	prn_e = counter ^ chan_id;
 100a448:	ea80 0501 	eor.w	r5, r0, r1
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
 100a44c:	0a28      	lsrs	r0, r5, #8
 100a44e:	b2ed      	uxtb	r5, r5
 100a450:	eb00 2080 	add.w	r0, r0, r0, lsl #10
 100a454:	eb05 2585 	add.w	r5, r5, r5, lsl #10
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
 100a458:	ea06 1e40 	and.w	lr, r6, r0, lsl #5
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
 100a45c:	ea07 0c40 	and.w	ip, r7, r0, lsl #1
 100a460:	ea07 0045 	and.w	r0, r7, r5, lsl #1
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
 100a464:	ea06 1545 	and.w	r5, r6, r5, lsl #5
	b = (((u32_t)b * 0x0802LU & 0x22110LU) |
 100a468:	ea4c 0c0e 	orr.w	ip, ip, lr
 100a46c:	4328      	orrs	r0, r5
	     ((u32_t)b * 0x8020LU & 0x88440LU)) * 0x10101LU >> 16;
 100a46e:	eb00 2500 	add.w	r5, r0, r0, lsl #8
 100a472:	eb0c 2e0c 	add.w	lr, ip, ip, lsl #8
 100a476:	eb00 2005 	add.w	r0, r0, r5, lsl #8
 100a47a:	eb0c 2c0e 	add.w	ip, ip, lr, lsl #8
 100a47e:	ea4f 4c1c 	mov.w	ip, ip, lsr #16
	return (chan_rev_8((i >> 8) & 0xFF) << 8) | chan_rev_8(i & 0xFF);
 100a482:	f3c0 4007 	ubfx	r0, r0, #16, #8
 100a486:	ea40 200c 	orr.w	r0, r0, ip, lsl #8
	return ((u32_t)a * 17U + b) & 0xFFFF;
 100a48a:	eb00 1000 	add.w	r0, r0, r0, lsl #4
 100a48e:	3c01      	subs	r4, #1
 100a490:	4408      	add	r0, r1

	for (iterate = 0U; iterate < 3; iterate++) {
 100a492:	f014 04ff 	ands.w	r4, r4, #255	; 0xff
	return ((u32_t)a * 17U + b) & 0xFFFF;
 100a496:	b285      	uxth	r5, r0
	for (iterate = 0U; iterate < 3; iterate++) {
 100a498:	d1d8      	bne.n	100a44c <lll_chan_sel_2+0xc>
	chan_next = prn_e % 37;
 100a49a:	481b      	ldr	r0, [pc, #108]	; (100a508 <lll_chan_sel_2+0xc8>)
		prn_e = chan_perm(prn_e);
		prn_e = chan_mam(prn_e, chan_id);
	}

	prn_e ^= chan_id;
 100a49c:	4069      	eors	r1, r5
	chan_next = prn_e % 37;
 100a49e:	fba0 5001 	umull	r5, r0, r0, r1
 100a4a2:	1a0d      	subs	r5, r1, r0
 100a4a4:	eb00 0055 	add.w	r0, r0, r5, lsr #1
 100a4a8:	0940      	lsrs	r0, r0, #5
 100a4aa:	eb00 05c0 	add.w	r5, r0, r0, lsl #3
 100a4ae:	eb00 0085 	add.w	r0, r0, r5, lsl #2
 100a4b2:	1a08      	subs	r0, r1, r0
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
 100a4b4:	f3c0 05c4 	ubfx	r5, r0, #3, #5
 100a4b8:	5d55      	ldrb	r5, [r2, r5]
 100a4ba:	f000 0607 	and.w	r6, r0, #7
 100a4be:	4135      	asrs	r5, r6
 100a4c0:	07ed      	lsls	r5, r5, #31
	chan_next = prn_e % 37;
 100a4c2:	b2c0      	uxtb	r0, r0
	if ((chan_map[chan_next >> 3] & (1 << (chan_next % 8))) == 0U) {
 100a4c4:	d41a      	bmi.n	100a4fc <lll_chan_sel_2+0xbc>
		chan_index = ((u32_t)chan_count * prn_e) >> 16;
 100a4c6:	fb01 f303 	mul.w	r3, r1, r3
 100a4ca:	1e56      	subs	r6, r2, #1
 100a4cc:	f3c3 4307 	ubfx	r3, r3, #16, #8
	while (byte_count--) {
 100a4d0:	3204      	adds	r2, #4
		bite = *chan_map;
 100a4d2:	f104 0508 	add.w	r5, r4, #8
 100a4d6:	f816 1f01 	ldrb.w	r1, [r6, #1]!
		while (bit_count--) {
 100a4da:	4620      	mov	r0, r4
 100a4dc:	b2ec      	uxtb	r4, r5
			if (bite & 0x01) {
 100a4de:	f011 0f01 	tst.w	r1, #1
			chan_next++;
 100a4e2:	f100 0501 	add.w	r5, r0, #1
			bite >>= 1;
 100a4e6:	ea4f 0151 	mov.w	r1, r1, lsr #1
			if (bite & 0x01) {
 100a4ea:	d002      	beq.n	100a4f2 <lll_chan_sel_2+0xb2>
				if (chan_index == 0U) {
 100a4ec:	b133      	cbz	r3, 100a4fc <lll_chan_sel_2+0xbc>
				chan_index--;
 100a4ee:	3b01      	subs	r3, #1
 100a4f0:	b2db      	uxtb	r3, r3
			chan_next++;
 100a4f2:	b2e8      	uxtb	r0, r5
		while (bit_count--) {
 100a4f4:	42a0      	cmp	r0, r4
 100a4f6:	d1f2      	bne.n	100a4de <lll_chan_sel_2+0x9e>
	while (byte_count--) {
 100a4f8:	42b2      	cmp	r2, r6
 100a4fa:	d1ea      	bne.n	100a4d2 <lll_chan_sel_2+0x92>
}
 100a4fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 100a4fe:	bf00      	nop
 100a500:	00022110 	.word	0x00022110
 100a504:	00088440 	.word	0x00088440
 100a508:	bacf914d 	.word	0xbacf914d

0100a50c <disabled_cb>:
{
 100a50c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	adv = ((struct lll_hdr *)param)->parent;
 100a50e:	6805      	ldr	r5, [r0, #0]
{
 100a510:	4606      	mov	r6, r0
	LL_ASSERT(adv->link_cc_free);
 100a512:	f8d5 70d0 	ldr.w	r7, [r5, #208]	; 0xd0
 100a516:	b1f7      	cbz	r7, 100a556 <disabled_cb+0x4a>
	adv->link_cc_free = NULL;
 100a518:	2300      	movs	r3, #0
	LL_ASSERT(adv->node_rx_cc_free);
 100a51a:	f8d5 40d4 	ldr.w	r4, [r5, #212]	; 0xd4
	adv->link_cc_free = NULL;
 100a51e:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0
	LL_ASSERT(adv->node_rx_cc_free);
 100a522:	b334      	cbz	r4, 100a572 <disabled_cb+0x66>
	adv->node_rx_cc_free = NULL;
 100a524:	2100      	movs	r1, #0
	rx->hdr.handle = 0xffff;
 100a526:	f64f 73ff 	movw	r3, #65535	; 0xffff
	rx->hdr.type = NODE_RX_TYPE_CONNECTION;
 100a52a:	2208      	movs	r2, #8
	adv->node_rx_cc_free = NULL;
 100a52c:	f8c5 10d4 	str.w	r1, [r5, #212]	; 0xd4
	memset(cc, 0x00, sizeof(struct node_rx_cc));
 100a530:	f104 0020 	add.w	r0, r4, #32
	rx->hdr.type = NODE_RX_TYPE_CONNECTION;
 100a534:	7122      	strb	r2, [r4, #4]
	rx->hdr.handle = 0xffff;
 100a536:	80e3      	strh	r3, [r4, #6]
	memset(cc, 0x00, sizeof(struct node_rx_cc));
 100a538:	221e      	movs	r2, #30
 100a53a:	f00c f9e8 	bl	101690e <memset>
	cc->status = BT_HCI_ERR_ADV_TIMEOUT;
 100a53e:	233c      	movs	r3, #60	; 0x3c
	ll_rx_put(link, rx);
 100a540:	4638      	mov	r0, r7
 100a542:	4621      	mov	r1, r4
	ftr->param = param;
 100a544:	60a6      	str	r6, [r4, #8]
	cc->status = BT_HCI_ERR_ADV_TIMEOUT;
 100a546:	f884 3020 	strb.w	r3, [r4, #32]
	ll_rx_put(link, rx);
 100a54a:	f7ff fd5f 	bl	100a00c <ll_rx_put>
}
 100a54e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	ll_rx_sched();
 100a552:	f7ff bd65 	b.w	100a020 <ll_rx_sched>
	LL_ASSERT(adv->link_cc_free);
 100a556:	f240 41b2 	movw	r1, #1202	; 0x4b2
 100a55a:	480a      	ldr	r0, [pc, #40]	; (100a584 <disabled_cb+0x78>)
 100a55c:	f7f9 f814 	bl	1003588 <bt_ctlr_assert_handle>
	adv->link_cc_free = NULL;
 100a560:	2300      	movs	r3, #0
	LL_ASSERT(adv->node_rx_cc_free);
 100a562:	f8d5 40d4 	ldr.w	r4, [r5, #212]	; 0xd4
 100a566:	f8d5 70d0 	ldr.w	r7, [r5, #208]	; 0xd0
	adv->link_cc_free = NULL;
 100a56a:	f8c5 30d0 	str.w	r3, [r5, #208]	; 0xd0
	LL_ASSERT(adv->node_rx_cc_free);
 100a56e:	2c00      	cmp	r4, #0
 100a570:	d1d8      	bne.n	100a524 <disabled_cb+0x18>
 100a572:	f240 41b6 	movw	r1, #1206	; 0x4b6
 100a576:	4803      	ldr	r0, [pc, #12]	; (100a584 <disabled_cb+0x78>)
 100a578:	f7f9 f806 	bl	1003588 <bt_ctlr_assert_handle>
 100a57c:	f8d5 40d4 	ldr.w	r4, [r5, #212]	; 0xd4
 100a580:	e7d0      	b.n	100a524 <disabled_cb+0x18>
 100a582:	bf00      	nop
 100a584:	01018740 	.word	0x01018740

0100a588 <ticker_op_stop_cb>:
	if (status != TICKER_STATUS_SUCCESS) {
 100a588:	bb60      	cbnz	r0, 100a5e4 <ticker_op_stop_cb+0x5c>
{
 100a58a:	b570      	push	{r4, r5, r6, lr}
	mfy.param = &adv->lll;
 100a58c:	4d19      	ldr	r5, [pc, #100]	; (100a5f4 <ticker_op_stop_cb+0x6c>)
	if (hdr->ref) {
 100a58e:	7c0a      	ldrb	r2, [r1, #16]
	mfy.param = &adv->lll;
 100a590:	f101 031c 	add.w	r3, r1, #28
 100a594:	460c      	mov	r4, r1
 100a596:	60ab      	str	r3, [r5, #8]
	if (hdr->ref) {
 100a598:	b1a2      	cbz	r2, 100a5c4 <ticker_op_stop_cb+0x3c>
		LL_ASSERT(!hdr->disabled_cb);
 100a59a:	694a      	ldr	r2, [r1, #20]
 100a59c:	b12a      	cbz	r2, 100a5aa <ticker_op_stop_cb+0x22>
 100a59e:	f44f 6193 	mov.w	r1, #1176	; 0x498
 100a5a2:	4815      	ldr	r0, [pc, #84]	; (100a5f8 <ticker_op_stop_cb+0x70>)
 100a5a4:	f7f8 fff0 	bl	1003588 <bt_ctlr_assert_handle>
 100a5a8:	68ab      	ldr	r3, [r5, #8]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
 100a5aa:	2200      	movs	r2, #0
		hdr->disabled_cb = disabled_cb;
 100a5ac:	4813      	ldr	r0, [pc, #76]	; (100a5fc <ticker_op_stop_cb+0x74>)
		mfy.fp = lll_disable;
 100a5ae:	4e14      	ldr	r6, [pc, #80]	; (100a600 <ticker_op_stop_cb+0x78>)
		hdr->disabled_param = mfy.param;
 100a5b0:	61a3      	str	r3, [r4, #24]
		hdr->disabled_cb = disabled_cb;
 100a5b2:	6160      	str	r0, [r4, #20]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
 100a5b4:	4611      	mov	r1, r2
 100a5b6:	2002      	movs	r0, #2
 100a5b8:	4b0e      	ldr	r3, [pc, #56]	; (100a5f4 <ticker_op_stop_cb+0x6c>)
		mfy.fp = lll_disable;
 100a5ba:	60ee      	str	r6, [r5, #12]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
 100a5bc:	f7fb fc08 	bl	1005dd0 <mayfly_enqueue>
		LL_ASSERT(!ret);
 100a5c0:	b988      	cbnz	r0, 100a5e6 <ticker_op_stop_cb+0x5e>
}
 100a5c2:	bd70      	pop	{r4, r5, r6, pc}
		mfy.fp = disabled_cb;
 100a5c4:	4c0d      	ldr	r4, [pc, #52]	; (100a5fc <ticker_op_stop_cb+0x74>)
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
 100a5c6:	462b      	mov	r3, r5
 100a5c8:	2101      	movs	r1, #1
 100a5ca:	2002      	movs	r0, #2
		mfy.fp = disabled_cb;
 100a5cc:	60ec      	str	r4, [r5, #12]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_LOW,
 100a5ce:	f7fb fbff 	bl	1005dd0 <mayfly_enqueue>
		LL_ASSERT(!ret);
 100a5d2:	2800      	cmp	r0, #0
 100a5d4:	d0f5      	beq.n	100a5c2 <ticker_op_stop_cb+0x3a>
}
 100a5d6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		LL_ASSERT(!ret);
 100a5da:	f240 41a4 	movw	r1, #1188	; 0x4a4
 100a5de:	4806      	ldr	r0, [pc, #24]	; (100a5f8 <ticker_op_stop_cb+0x70>)
 100a5e0:	f7f8 bfd2 	b.w	1003588 <bt_ctlr_assert_handle>
 100a5e4:	4770      	bx	lr
		LL_ASSERT(!ret);
 100a5e6:	f240 419f 	movw	r1, #1183	; 0x49f
}
 100a5ea:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		LL_ASSERT(!ret);
 100a5ee:	4802      	ldr	r0, [pc, #8]	; (100a5f8 <ticker_op_stop_cb+0x70>)
 100a5f0:	f7f8 bfca 	b.w	1003588 <bt_ctlr_assert_handle>
 100a5f4:	210002bc 	.word	0x210002bc
 100a5f8:	01018740 	.word	0x01018740
 100a5fc:	0100a50d 	.word	0x0100a50d
 100a600:	0100fded 	.word	0x0100fded

0100a604 <ticker_op_update_cb>:
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
 100a604:	b900      	cbnz	r0, 100a608 <ticker_op_update_cb+0x4>
 100a606:	4770      	bx	lr
{
 100a608:	b510      	push	{r4, lr}
 100a60a:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
 100a60c:	f7ff fd94 	bl	100a138 <ull_disable_mark_get>
 100a610:	4284      	cmp	r4, r0
 100a612:	d006      	beq.n	100a622 <ticker_op_update_cb+0x1e>
}
 100a614:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
 100a618:	f240 4159 	movw	r1, #1113	; 0x459
 100a61c:	4801      	ldr	r0, [pc, #4]	; (100a624 <ticker_op_update_cb+0x20>)
 100a61e:	f7f8 bfb3 	b.w	1003588 <bt_ctlr_assert_handle>
}
 100a622:	bd10      	pop	{r4, pc}
 100a624:	01018740 	.word	0x01018740

0100a628 <ticker_stop_cb>:
{
 100a628:	b530      	push	{r4, r5, lr}
 100a62a:	461d      	mov	r5, r3
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
 100a62c:	4a12      	ldr	r2, [pc, #72]	; (100a678 <ticker_stop_cb+0x50>)
 100a62e:	4b13      	ldr	r3, [pc, #76]	; (100a67c <ticker_stop_cb+0x54>)
 100a630:	1aaa      	subs	r2, r5, r2
 100a632:	0892      	lsrs	r2, r2, #2
 100a634:	fba3 3202 	umull	r3, r2, r3, r2
	LL_ASSERT(handle < BT_CTLR_ADV_MAX);
 100a638:	f3c2 034f 	ubfx	r3, r2, #1, #16
{
 100a63c:	b083      	sub	sp, #12
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
 100a63e:	0854      	lsrs	r4, r2, #1
	LL_ASSERT(handle < BT_CTLR_ADV_MAX);
 100a640:	b9a3      	cbnz	r3, 100a66c <ticker_stop_cb+0x44>
			  TICKER_ID_ADV_BASE + handle,
 100a642:	1ca2      	adds	r2, r4, #2
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_ULL_HIGH,
 100a644:	4b0e      	ldr	r3, [pc, #56]	; (100a680 <ticker_stop_cb+0x58>)
 100a646:	2101      	movs	r1, #1
 100a648:	2000      	movs	r0, #0
 100a64a:	b2d2      	uxtb	r2, r2
 100a64c:	9500      	str	r5, [sp, #0]
 100a64e:	f7fc fdf1 	bl	1007234 <ticker_stop>
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 100a652:	f030 0302 	bics.w	r3, r0, #2
 100a656:	d007      	beq.n	100a668 <ticker_stop_cb+0x40>
 100a658:	f240 417a 	movw	r1, #1146	; 0x47a
 100a65c:	4809      	ldr	r0, [pc, #36]	; (100a684 <ticker_stop_cb+0x5c>)
}
 100a65e:	b003      	add	sp, #12
 100a660:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 100a664:	f7f8 bf90 	b.w	1003588 <bt_ctlr_assert_handle>
}
 100a668:	b003      	add	sp, #12
 100a66a:	bd30      	pop	{r4, r5, pc}
	LL_ASSERT(handle < BT_CTLR_ADV_MAX);
 100a66c:	f240 4175 	movw	r1, #1141	; 0x475
 100a670:	4804      	ldr	r0, [pc, #16]	; (100a684 <ticker_stop_cb+0x5c>)
 100a672:	f7f8 ff89 	bl	1003588 <bt_ctlr_assert_handle>
 100a676:	e7e4      	b.n	100a642 <ticker_stop_cb+0x1a>
 100a678:	210019d0 	.word	0x210019d0
 100a67c:	08fb823f 	.word	0x08fb823f
 100a680:	0100a589 	.word	0x0100a589
 100a684:	01018740 	.word	0x01018740

0100a688 <ticker_cb>:
{
 100a688:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100a68c:	4615      	mov	r5, r2
	if (IS_ENABLED(CONFIG_BT_TICKER_COMPATIBILITY_MODE) ||
 100a68e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 100a692:	4295      	cmp	r5, r2
{
 100a694:	461c      	mov	r4, r3
 100a696:	b08a      	sub	sp, #40	; 0x28
	if (IS_ENABLED(CONFIG_BT_TICKER_COMPATIBILITY_MODE) ||
 100a698:	d017      	beq.n	100a6ca <ticker_cb+0x42>
	return ++hdr->ref;
 100a69a:	7c1b      	ldrb	r3, [r3, #16]
 100a69c:	4680      	mov	r8, r0
 100a69e:	3301      	adds	r3, #1
 100a6a0:	b2db      	uxtb	r3, r3
 100a6a2:	460f      	mov	r7, r1
 100a6a4:	7423      	strb	r3, [r4, #16]
		LL_ASSERT(ref);
 100a6a6:	2b00      	cmp	r3, #0
 100a6a8:	d051      	beq.n	100a74e <ticker_cb+0xc6>
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 100a6aa:	2200      	movs	r2, #0
		p.ticks_at_expire = ticks_at_expire;
 100a6ac:	4e2b      	ldr	r6, [pc, #172]	; (100a75c <ticker_cb+0xd4>)
		mfy.param = &p;
 100a6ae:	4b2c      	ldr	r3, [pc, #176]	; (100a760 <ticker_cb+0xd8>)
	lll = &adv->lll;
 100a6b0:	f104 0c1c 	add.w	ip, r4, #28
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 100a6b4:	4611      	mov	r1, r2
 100a6b6:	2001      	movs	r0, #1
		p.remainder = remainder;
 100a6b8:	e9c6 8700 	strd	r8, r7, [r6]
		mfy.param = &p;
 100a6bc:	609e      	str	r6, [r3, #8]
		p.lazy = lazy;
 100a6be:	8135      	strh	r5, [r6, #8]
		p.param = lll;
 100a6c0:	f8c6 c00c 	str.w	ip, [r6, #12]
		ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 100a6c4:	f7fb fb84 	bl	1005dd0 <mayfly_enqueue>
		LL_ASSERT(!ret);
 100a6c8:	b938      	cbnz	r0, 100a6da <ticker_cb+0x52>
	if (!lll->is_hdcd)
 100a6ca:	f894 5028 	ldrb.w	r5, [r4, #40]	; 0x28
 100a6ce:	f015 0501 	ands.w	r5, r5, #1
 100a6d2:	d00c      	beq.n	100a6ee <ticker_cb+0x66>
}
 100a6d4:	b00a      	add	sp, #40	; 0x28
 100a6d6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		LL_ASSERT(!ret);
 100a6da:	f240 413a 	movw	r1, #1082	; 0x43a
 100a6de:	4821      	ldr	r0, [pc, #132]	; (100a764 <ticker_cb+0xdc>)
 100a6e0:	f7f8 ff52 	bl	1003588 <bt_ctlr_assert_handle>
	if (!lll->is_hdcd)
 100a6e4:	f894 5028 	ldrb.w	r5, [r4, #40]	; 0x28
 100a6e8:	f015 0501 	ands.w	r5, r5, #1
 100a6ec:	d1f2      	bne.n	100a6d4 <ticker_cb+0x4c>
		random_delay %= ULL_ADV_RANDOM_DELAY;
 100a6ee:	f240 1647 	movw	r6, #327	; 0x147
		lll_rng_isr_get(&random_delay, sizeof(random_delay));
 100a6f2:	2104      	movs	r1, #4
 100a6f4:	a809      	add	r0, sp, #36	; 0x24
 100a6f6:	f005 fb4d 	bl	100fd94 <lll_rng_isr_get>
		random_delay %= ULL_ADV_RANDOM_DELAY;
 100a6fa:	9809      	ldr	r0, [sp, #36]	; 0x24
 100a6fc:	491a      	ldr	r1, [pc, #104]	; (100a768 <ticker_cb+0xe0>)
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
 100a6fe:	4a1b      	ldr	r2, [pc, #108]	; (100a76c <ticker_cb+0xe4>)
		random_delay %= ULL_ADV_RANDOM_DELAY;
 100a700:	fba1 3100 	umull	r3, r1, r1, r0
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
 100a704:	9406      	str	r4, [sp, #24]
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
 100a706:	1aa2      	subs	r2, r4, r2
 100a708:	4c19      	ldr	r4, [pc, #100]	; (100a770 <ticker_cb+0xe8>)
		random_delay %= ULL_ADV_RANDOM_DELAY;
 100a70a:	1a43      	subs	r3, r0, r1
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
 100a70c:	0892      	lsrs	r2, r2, #2
		random_delay %= ULL_ADV_RANDOM_DELAY;
 100a70e:	eb01 0353 	add.w	r3, r1, r3, lsr #1
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
 100a712:	fba4 1202 	umull	r1, r2, r4, r2
		random_delay %= ULL_ADV_RANDOM_DELAY;
 100a716:	0a1b      	lsrs	r3, r3, #8
 100a718:	fb06 0313 	mls	r3, r6, r3, r0
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
 100a71c:	4915      	ldr	r1, [pc, #84]	; (100a774 <ticker_cb+0xec>)
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
 100a71e:	0852      	lsrs	r2, r2, #1
				    (TICKER_ID_ADV_BASE +
 100a720:	3202      	adds	r2, #2
		random_delay += 1;
 100a722:	3301      	adds	r3, #1
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
 100a724:	9105      	str	r1, [sp, #20]
 100a726:	4628      	mov	r0, r5
 100a728:	2101      	movs	r1, #1
 100a72a:	e9cd 5503 	strd	r5, r5, [sp, #12]
 100a72e:	e9cd 5501 	strd	r5, r5, [sp, #4]
 100a732:	9500      	str	r5, [sp, #0]
 100a734:	b2d2      	uxtb	r2, r2
		random_delay += 1;
 100a736:	9309      	str	r3, [sp, #36]	; 0x24
		ret = ticker_update(TICKER_INSTANCE_ID_CTLR,
 100a738:	f7fc fd32 	bl	10071a0 <ticker_update>
		LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 100a73c:	f030 0302 	bics.w	r3, r0, #2
 100a740:	d0c8      	beq.n	100a6d4 <ticker_cb+0x4c>
 100a742:	f44f 618a 	mov.w	r1, #1104	; 0x450
 100a746:	4807      	ldr	r0, [pc, #28]	; (100a764 <ticker_cb+0xdc>)
 100a748:	f7f8 ff1e 	bl	1003588 <bt_ctlr_assert_handle>
}
 100a74c:	e7c2      	b.n	100a6d4 <ticker_cb+0x4c>
		LL_ASSERT(ref);
 100a74e:	f240 412e 	movw	r1, #1070	; 0x42e
 100a752:	4804      	ldr	r0, [pc, #16]	; (100a764 <ticker_cb+0xdc>)
 100a754:	f7f8 ff18 	bl	1003588 <bt_ctlr_assert_handle>
 100a758:	e7a7      	b.n	100a6aa <ticker_cb+0x22>
 100a75a:	bf00      	nop
 100a75c:	21001ac0 	.word	0x21001ac0
 100a760:	210002ac 	.word	0x210002ac
 100a764:	01018740 	.word	0x01018740
 100a768:	90d4f121 	.word	0x90d4f121
 100a76c:	210019d0 	.word	0x210019d0
 100a770:	08fb823f 	.word	0x08fb823f
 100a774:	0100a605 	.word	0x0100a605

0100a778 <conn_release.constprop.0>:
static void conn_release(struct ll_adv_set *adv)
 100a778:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct lll_conn *lll = adv->lll.conn;
 100a77a:	4c15      	ldr	r4, [pc, #84]	; (100a7d0 <conn_release.constprop.0+0x58>)
 100a77c:	6a65      	ldr	r5, [r4, #36]	; 0x24
	LL_ASSERT(!lll->link_tx_free);
 100a77e:	6deb      	ldr	r3, [r5, #92]	; 0x5c
 100a780:	b123      	cbz	r3, 100a78c <conn_release.constprop.0+0x14>
 100a782:	f240 41cd 	movw	r1, #1229	; 0x4cd
 100a786:	4813      	ldr	r0, [pc, #76]	; (100a7d4 <conn_release.constprop.0+0x5c>)
 100a788:	f7f8 fefe 	bl	1003588 <bt_ctlr_assert_handle>
	link = memq_deinit(&lll->memq_tx.head, &lll->memq_tx.tail);
 100a78c:	f105 0150 	add.w	r1, r5, #80	; 0x50
 100a790:	f105 004c 	add.w	r0, r5, #76	; 0x4c
 100a794:	f7fb fa9e 	bl	1005cd4 <memq_deinit>
	LL_ASSERT(link);
 100a798:	4606      	mov	r6, r0
 100a79a:	b190      	cbz	r0, 100a7c2 <conn_release.constprop.0+0x4a>
	adv->lll.conn = NULL;
 100a79c:	2700      	movs	r7, #0
	ll_conn_release(lll->hdr.parent);
 100a79e:	6828      	ldr	r0, [r5, #0]
	lll->link_tx_free = link;
 100a7a0:	65ee      	str	r6, [r5, #92]	; 0x5c
	ll_conn_release(lll->hdr.parent);
 100a7a2:	f000 fec7 	bl	100b534 <ll_conn_release>
	ll_rx_release(adv->node_rx_cc_free);
 100a7a6:	f8d4 00d4 	ldr.w	r0, [r4, #212]	; 0xd4
	adv->lll.conn = NULL;
 100a7aa:	6267      	str	r7, [r4, #36]	; 0x24
	ll_rx_release(adv->node_rx_cc_free);
 100a7ac:	f7ff fc28 	bl	100a000 <ll_rx_release>
	ll_rx_link_release(adv->link_cc_free);
 100a7b0:	f8d4 00d0 	ldr.w	r0, [r4, #208]	; 0xd0
	adv->node_rx_cc_free = NULL;
 100a7b4:	f8c4 70d4 	str.w	r7, [r4, #212]	; 0xd4
	ll_rx_link_release(adv->link_cc_free);
 100a7b8:	f7ff fc16 	bl	1009fe8 <ll_rx_link_release>
	adv->link_cc_free = NULL;
 100a7bc:	f8c4 70d0 	str.w	r7, [r4, #208]	; 0xd0
}
 100a7c0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	LL_ASSERT(link);
 100a7c2:	f240 41cf 	movw	r1, #1231	; 0x4cf
 100a7c6:	4803      	ldr	r0, [pc, #12]	; (100a7d4 <conn_release.constprop.0+0x5c>)
 100a7c8:	f7f8 fede 	bl	1003588 <bt_ctlr_assert_handle>
 100a7cc:	e7e6      	b.n	100a79c <conn_release.constprop.0+0x24>
 100a7ce:	bf00      	nop
 100a7d0:	210019d0 	.word	0x210019d0
 100a7d4:	01018740 	.word	0x01018740

0100a7d8 <ll_adv_params_set>:
{
 100a7d8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (!adv || adv->is_enabled) {
 100a7dc:	4c49      	ldr	r4, [pc, #292]	; (100a904 <ll_adv_params_set+0x12c>)
{
 100a7de:	460e      	mov	r6, r1
	if (!adv || adv->is_enabled) {
 100a7e0:	f894 70cc 	ldrb.w	r7, [r4, #204]	; 0xcc
	u8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
 100a7e4:	4948      	ldr	r1, [pc, #288]	; (100a908 <ll_adv_params_set+0x130>)
{
 100a7e6:	b083      	sub	sp, #12
	if (!adv || adv->is_enabled) {
 100a7e8:	f017 0701 	ands.w	r7, r7, #1
{
 100a7ec:	4684      	mov	ip, r0
	u8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
 100a7ee:	c903      	ldmia	r1, {r0, r1}
{
 100a7f0:	4615      	mov	r5, r2
 100a7f2:	4698      	mov	r8, r3
 100a7f4:	f89d 202c 	ldrb.w	r2, [sp, #44]	; 0x2c
 100a7f8:	f89d 3030 	ldrb.w	r3, [sp, #48]	; 0x30
	u8_t const pdu_adv_type[] = {PDU_ADV_TYPE_ADV_IND,
 100a7fc:	9000      	str	r0, [sp, #0]
 100a7fe:	f88d 1004 	strb.w	r1, [sp, #4]
	if (!adv || adv->is_enabled) {
 100a802:	d16d      	bne.n	100a8e0 <ll_adv_params_set+0x108>
	pdu->type = pdu_adv_type[adv_type];
 100a804:	a902      	add	r1, sp, #8
 100a806:	4431      	add	r1, r6
 100a808:	f811 0c08 	ldrb.w	r0, [r1, #-8]
		adv->interval = 0;
 100a80c:	2e01      	cmp	r6, #1
 100a80e:	bf08      	it	eq
 100a810:	f04f 0c00 	moveq.w	ip, #0
	if (IS_ENABLED(CONFIG_BT_CTLR_CHAN_SEL_2) &&
 100a814:	f010 0f0e 	tst.w	r0, #14
 100a818:	bf0c      	ite	eq
 100a81a:	2101      	moveq	r1, #1
 100a81c:	2100      	movne	r1, #0
 100a81e:	f894 602c 	ldrb.w	r6, [r4, #44]	; 0x2c
	adv->lll.chan_map = chan_map;
 100a822:	f002 0207 	and.w	r2, r2, #7
 100a826:	eb06 0e86 	add.w	lr, r6, r6, lsl #2
 100a82a:	f003 0303 	and.w	r3, r3, #3
 100a82e:	0052      	lsls	r2, r2, #1
 100a830:	ebc6 06ce 	rsb	r6, r6, lr, lsl #3
 100a834:	ea42 2203 	orr.w	r2, r2, r3, lsl #8
 100a838:	8d23      	ldrh	r3, [r4, #40]	; 0x28
 100a83a:	362d      	adds	r6, #45	; 0x2d
	pdu->type = pdu_adv_type[adv_type];
 100a83c:	f814 e006 	ldrb.w	lr, [r4, r6]
	adv->lll.chan_map = chan_map;
 100a840:	f423 7343 	bic.w	r3, r3, #780	; 0x30c
 100a844:	f023 0302 	bic.w	r3, r3, #2
 100a848:	431a      	orrs	r2, r3
	pdu->type = pdu_adv_type[adv_type];
 100a84a:	f000 000f 	and.w	r0, r0, #15
	adv->own_addr_type = own_addr_type;
 100a84e:	f894 30da 	ldrb.w	r3, [r4, #218]	; 0xda
	pdu->type = pdu_adv_type[adv_type];
 100a852:	f02e 0e1f 	bic.w	lr, lr, #31
 100a856:	ea40 000e 	orr.w	r0, r0, lr
	adv->own_addr_type = own_addr_type;
 100a85a:	f365 0301 	bfi	r3, r5, #0, #2
 100a85e:	f361 1045 	bfi	r0, r1, #5, #1
	adv->lll.chan_map = chan_map;
 100a862:	8522      	strh	r2, [r4, #40]	; 0x28
 100a864:	f8a4 c0d8 	strh.w	ip, [r4, #216]	; 0xd8
	if (adv->own_addr_type == BT_ADDR_LE_PUBLIC_ID ||
 100a868:	b2da      	uxtb	r2, r3
 100a86a:	55a0      	strb	r0, [r4, r6]
	adv->own_addr_type = own_addr_type;
 100a86c:	f884 30da 	strb.w	r3, [r4, #218]	; 0xda
	if (adv->own_addr_type == BT_ADDR_LE_PUBLIC_ID ||
 100a870:	079b      	lsls	r3, r3, #30
 100a872:	eb04 0906 	add.w	r9, r4, r6
 100a876:	d427      	bmi.n	100a8c8 <ll_adv_params_set+0xf0>
	pdu->tx_addr = own_addr_type & 0x1;
 100a878:	5da3      	ldrb	r3, [r4, r6]
 100a87a:	f365 1386 	bfi	r3, r5, #6, #1
	pdu->rx_addr = 0;
 100a87e:	f36f 13c7 	bfc	r3, #7, #1
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
 100a882:	f003 020f 	and.w	r2, r3, #15
 100a886:	2a01      	cmp	r2, #1
	pdu->rx_addr = 0;
 100a888:	55a3      	strb	r3, [r4, r6]
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
 100a88a:	b2db      	uxtb	r3, r3
 100a88c:	d02d      	beq.n	100a8ea <ll_adv_params_set+0x112>
	} else if (pdu->len == 0) {
 100a88e:	f899 3001 	ldrb.w	r3, [r9, #1]
 100a892:	b913      	cbnz	r3, 100a89a <ll_adv_params_set+0xc2>
		pdu->len = BDADDR_SIZE;
 100a894:	2306      	movs	r3, #6
 100a896:	f889 3001 	strb.w	r3, [r9, #1]
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 100a89a:	f894 307c 	ldrb.w	r3, [r4, #124]	; 0x7c
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
 100a89e:	01ad      	lsls	r5, r5, #6
 100a8a0:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 100a8a4:	f005 0540 	and.w	r5, r5, #64	; 0x40
 100a8a8:	ebc3 03c2 	rsb	r3, r3, r2, lsl #3
 100a8ac:	337d      	adds	r3, #125	; 0x7d
 100a8ae:	f045 0504 	orr.w	r5, r5, #4
 100a8b2:	54e5      	strb	r5, [r4, r3]
 100a8b4:	441c      	add	r4, r3
	if (pdu->len == 0) {
 100a8b6:	7863      	ldrb	r3, [r4, #1]
 100a8b8:	b913      	cbnz	r3, 100a8c0 <ll_adv_params_set+0xe8>
		pdu->len = BDADDR_SIZE;
 100a8ba:	2206      	movs	r2, #6
	return 0;
 100a8bc:	461f      	mov	r7, r3
		pdu->len = BDADDR_SIZE;
 100a8be:	7062      	strb	r2, [r4, #1]
}
 100a8c0:	4638      	mov	r0, r7
 100a8c2:	b003      	add	sp, #12
 100a8c4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		adv->id_addr_type = direct_addr_type;
 100a8c8:	4613      	mov	r3, r2
 100a8ca:	f368 0382 	bfi	r3, r8, #2, #1
		memcpy(&adv->id_addr, direct_addr, BDADDR_SIZE);
 100a8ce:	2206      	movs	r2, #6
 100a8d0:	990a      	ldr	r1, [sp, #40]	; 0x28
 100a8d2:	f104 00db 	add.w	r0, r4, #219	; 0xdb
		adv->id_addr_type = direct_addr_type;
 100a8d6:	f884 30da 	strb.w	r3, [r4, #218]	; 0xda
		memcpy(&adv->id_addr, direct_addr, BDADDR_SIZE);
 100a8da:	f00b ffed 	bl	10168b8 <memcpy>
 100a8de:	e7cb      	b.n	100a878 <ll_adv_params_set+0xa0>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100a8e0:	270c      	movs	r7, #12
}
 100a8e2:	4638      	mov	r0, r7
 100a8e4:	b003      	add	sp, #12
 100a8e6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		pdu->rx_addr = direct_addr_type;
 100a8ea:	f368 13c7 	bfi	r3, r8, #7, #1
 100a8ee:	55a3      	strb	r3, [r4, r6]
		memcpy(&pdu->direct_ind.tgt_addr[0], direct_addr, BDADDR_SIZE);
 100a8f0:	2206      	movs	r2, #6
 100a8f2:	990a      	ldr	r1, [sp, #40]	; 0x28
 100a8f4:	f109 0008 	add.w	r0, r9, #8
 100a8f8:	f00b ffde 	bl	10168b8 <memcpy>
		pdu->len = sizeof(struct pdu_adv_direct_ind);
 100a8fc:	230c      	movs	r3, #12
 100a8fe:	f889 3001 	strb.w	r3, [r9, #1]
 100a902:	e7ca      	b.n	100a89a <ll_adv_params_set+0xc2>
 100a904:	210019d0 	.word	0x210019d0
 100a908:	010181f8 	.word	0x010181f8

0100a90c <ll_adv_data_set>:
{
 100a90c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 100a910:	4e23      	ldr	r6, [pc, #140]	; (100a9a0 <ll_adv_data_set+0x94>)
 100a912:	460f      	mov	r7, r1
 100a914:	f896 402c 	ldrb.w	r4, [r6, #44]	; 0x2c
 100a918:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 100a91c:	ebc4 03c3 	rsb	r3, r4, r3, lsl #3
 100a920:	332d      	adds	r3, #45	; 0x2d
	if ((prev->type == PDU_ADV_TYPE_DIRECT_IND) ||
 100a922:	5cf2      	ldrb	r2, [r6, r3]
 100a924:	4433      	add	r3, r6
 100a926:	f002 010f 	and.w	r1, r2, #15
 100a92a:	2901      	cmp	r1, #1
 100a92c:	d024      	beq.n	100a978 <ll_adv_data_set+0x6c>
	if (pdu->first == pdu->last) {
 100a92e:	f896 102b 	ldrb.w	r1, [r6, #43]	; 0x2b
 100a932:	4605      	mov	r5, r0
 100a934:	42a1      	cmp	r1, r4
 100a936:	d022      	beq.n	100a97e <ll_adv_data_set+0x72>
 100a938:	4698      	mov	r8, r3
	pdu->type = prev->type;
 100a93a:	4640      	mov	r0, r8
		pdu->chan_sel = prev->chan_sel;
 100a93c:	f3c2 1c40 	ubfx	ip, r2, #5, #1
	pdu->type = prev->type;
 100a940:	f3c2 0103 	ubfx	r1, r2, #0, #4
 100a944:	ea41 114c 	orr.w	r1, r1, ip, lsl #5
	pdu->tx_addr = prev->tx_addr;
 100a948:	f3c2 1c80 	ubfx	ip, r2, #6, #1
	pdu->type = prev->type;
 100a94c:	ea41 118c 	orr.w	r1, r1, ip, lsl #6
 100a950:	f002 0280 	and.w	r2, r2, #128	; 0x80
 100a954:	430a      	orrs	r2, r1
 100a956:	f800 2b02 	strb.w	r2, [r0], #2
	memcpy(&pdu->adv_ind.addr[0], &prev->adv_ind.addr[0], BDADDR_SIZE);
 100a95a:	1c99      	adds	r1, r3, #2
 100a95c:	2206      	movs	r2, #6
 100a95e:	f00b ffab 	bl	10168b8 <memcpy>
	memcpy(&pdu->adv_ind.data[0], data, len);
 100a962:	462a      	mov	r2, r5
 100a964:	4639      	mov	r1, r7
 100a966:	f108 0008 	add.w	r0, r8, #8
	pdu->len = BDADDR_SIZE + len;
 100a96a:	3506      	adds	r5, #6
	memcpy(&pdu->adv_ind.data[0], data, len);
 100a96c:	f00b ffa4 	bl	10168b8 <memcpy>
	pdu->len = BDADDR_SIZE + len;
 100a970:	f888 5001 	strb.w	r5, [r8, #1]
	pdu->last = idx;
 100a974:	f886 402c 	strb.w	r4, [r6, #44]	; 0x2c
}
 100a978:	2000      	movs	r0, #0
 100a97a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		last = pdu->last + 1;
 100a97e:	3401      	adds	r4, #1
 100a980:	b2e4      	uxtb	r4, r4
		if (last == DOUBLE_BUFFER_SIZE) {
 100a982:	2c02      	cmp	r4, #2
 100a984:	d007      	beq.n	100a996 <ll_adv_data_set+0x8a>
 100a986:	eb04 0884 	add.w	r8, r4, r4, lsl #2
 100a98a:	ebc4 08c8 	rsb	r8, r4, r8, lsl #3
 100a98e:	f108 082d 	add.w	r8, r8, #45	; 0x2d
 100a992:	44b0      	add	r8, r6
 100a994:	e7d1      	b.n	100a93a <ll_adv_data_set+0x2e>
			last = 0U;
 100a996:	2400      	movs	r4, #0
 100a998:	f106 082d 	add.w	r8, r6, #45	; 0x2d
 100a99c:	e7cd      	b.n	100a93a <ll_adv_data_set+0x2e>
 100a99e:	bf00      	nop
 100a9a0:	210019d0 	.word	0x210019d0

0100a9a4 <ll_adv_scan_rsp_set>:
{
 100a9a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 100a9a8:	4e1d      	ldr	r6, [pc, #116]	; (100aa20 <ll_adv_scan_rsp_set+0x7c>)
 100a9aa:	4688      	mov	r8, r1
 100a9ac:	f896 407c 	ldrb.w	r4, [r6, #124]	; 0x7c
	if (pdu->first == pdu->last) {
 100a9b0:	f896 207b 	ldrb.w	r2, [r6, #123]	; 0x7b
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 100a9b4:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 100a9b8:	ebc4 03c3 	rsb	r3, r4, r3, lsl #3
 100a9bc:	337d      	adds	r3, #125	; 0x7d
	if (pdu->first == pdu->last) {
 100a9be:	42a2      	cmp	r2, r4
 100a9c0:	4607      	mov	r7, r0
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 100a9c2:	eb06 0103 	add.w	r1, r6, r3
	if (pdu->first == pdu->last) {
 100a9c6:	d01b      	beq.n	100aa00 <ll_adv_scan_rsp_set+0x5c>
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.last];
 100a9c8:	460d      	mov	r5, r1
	pdu->tx_addr = prev->tx_addr;
 100a9ca:	5cf3      	ldrb	r3, [r6, r3]
	pdu->len = BDADDR_SIZE + len;
 100a9cc:	f107 0c06 	add.w	ip, r7, #6
	pdu->tx_addr = prev->tx_addr;
 100a9d0:	f3c3 1380 	ubfx	r3, r3, #6, #1
	pdu->type = PDU_ADV_TYPE_SCAN_RSP;
 100a9d4:	019b      	lsls	r3, r3, #6
 100a9d6:	f043 0304 	orr.w	r3, r3, #4
 100a9da:	702b      	strb	r3, [r5, #0]
	pdu->len = BDADDR_SIZE + len;
 100a9dc:	f885 c001 	strb.w	ip, [r5, #1]
	memcpy(&pdu->scan_rsp.addr[0], &prev->scan_rsp.addr[0], BDADDR_SIZE);
 100a9e0:	2206      	movs	r2, #6
 100a9e2:	3102      	adds	r1, #2
 100a9e4:	1ca8      	adds	r0, r5, #2
 100a9e6:	f00b ff67 	bl	10168b8 <memcpy>
	memcpy(&pdu->scan_rsp.data[0], data, len);
 100a9ea:	463a      	mov	r2, r7
 100a9ec:	4641      	mov	r1, r8
 100a9ee:	f105 0008 	add.w	r0, r5, #8
 100a9f2:	f00b ff61 	bl	10168b8 <memcpy>
}
 100a9f6:	2000      	movs	r0, #0
	pdu->last = idx;
 100a9f8:	f886 407c 	strb.w	r4, [r6, #124]	; 0x7c
 100a9fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		last = pdu->last + 1;
 100aa00:	3401      	adds	r4, #1
 100aa02:	b2e4      	uxtb	r4, r4
		if (last == DOUBLE_BUFFER_SIZE) {
 100aa04:	2c02      	cmp	r4, #2
 100aa06:	d006      	beq.n	100aa16 <ll_adv_scan_rsp_set+0x72>
 100aa08:	eb04 0584 	add.w	r5, r4, r4, lsl #2
 100aa0c:	ebc4 05c5 	rsb	r5, r4, r5, lsl #3
 100aa10:	357d      	adds	r5, #125	; 0x7d
 100aa12:	4435      	add	r5, r6
 100aa14:	e7d9      	b.n	100a9ca <ll_adv_scan_rsp_set+0x26>
			last = 0U;
 100aa16:	2400      	movs	r4, #0
 100aa18:	f106 057d 	add.w	r5, r6, #125	; 0x7d
 100aa1c:	e7d5      	b.n	100a9ca <ll_adv_scan_rsp_set+0x26>
 100aa1e:	bf00      	nop
 100aa20:	210019d0 	.word	0x210019d0

0100aa24 <ull_adv_init>:
}
 100aa24:	2000      	movs	r0, #0
 100aa26:	4770      	bx	lr

0100aa28 <ull_adv_reset>:
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 100aa28:	2302      	movs	r3, #2
{
 100aa2a:	b530      	push	{r4, r5, lr}
	if (!adv || !adv->is_enabled) {
 100aa2c:	4c39      	ldr	r4, [pc, #228]	; (100ab14 <ull_adv_reset+0xec>)
{
 100aa2e:	b085      	sub	sp, #20
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 100aa30:	9303      	str	r3, [sp, #12]
	if (!adv || !adv->is_enabled) {
 100aa32:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
 100aa36:	07da      	lsls	r2, r3, #31
 100aa38:	d543      	bpl.n	100aac2 <ull_adv_reset+0x9a>
	mark = ull_disable_mark(adv);
 100aa3a:	4620      	mov	r0, r4
 100aa3c:	f7ff fb64 	bl	100a108 <ull_disable_mark>
	LL_ASSERT(mark == adv);
 100aa40:	4284      	cmp	r4, r0
 100aa42:	d004      	beq.n	100aa4e <ull_adv_reset+0x26>
 100aa44:	f240 41e9 	movw	r1, #1257	; 0x4e9
 100aa48:	4833      	ldr	r0, [pc, #204]	; (100ab18 <ull_adv_reset+0xf0>)
 100aa4a:	f7f8 fd9d 	bl	1003588 <bt_ctlr_assert_handle>
	if (adv->lll.is_hdcd) {
 100aa4e:	f894 3028 	ldrb.w	r3, [r4, #40]	; 0x28
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 100aa52:	ad03      	add	r5, sp, #12
	if (adv->lll.is_hdcd) {
 100aa54:	07db      	lsls	r3, r3, #31
 100aa56:	d50d      	bpl.n	100aa74 <ull_adv_reset+0x4c>
		ret = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 100aa58:	2103      	movs	r1, #3
 100aa5a:	2201      	movs	r2, #1
 100aa5c:	2000      	movs	r0, #0
 100aa5e:	4b2f      	ldr	r3, [pc, #188]	; (100ab1c <ull_adv_reset+0xf4>)
 100aa60:	9500      	str	r5, [sp, #0]
 100aa62:	f7fc fbe7 	bl	1007234 <ticker_stop>
		ret = ull_ticker_status_take(ret, &ret_cb);
 100aa66:	4629      	mov	r1, r5
 100aa68:	f7ff fb40 	bl	100a0ec <ull_ticker_status_take>
		if (ret) {
 100aa6c:	2800      	cmp	r0, #0
 100aa6e:	d146      	bne.n	100aafe <ull_adv_reset+0xd6>
		ret_cb = TICKER_STATUS_BUSY;
 100aa70:	2302      	movs	r3, #2
 100aa72:	9303      	str	r3, [sp, #12]
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
 100aa74:	2103      	movs	r1, #3
 100aa76:	2202      	movs	r2, #2
 100aa78:	2000      	movs	r0, #0
 100aa7a:	4b28      	ldr	r3, [pc, #160]	; (100ab1c <ull_adv_reset+0xf4>)
 100aa7c:	9500      	str	r5, [sp, #0]
 100aa7e:	f7fc fbd9 	bl	1007234 <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
 100aa82:	4629      	mov	r1, r5
 100aa84:	f7ff fb32 	bl	100a0ec <ull_ticker_status_take>
	if (ret) {
 100aa88:	bb48      	cbnz	r0, 100aade <ull_adv_reset+0xb6>
	ret = ull_disable(&adv->lll);
 100aa8a:	4825      	ldr	r0, [pc, #148]	; (100ab20 <ull_adv_reset+0xf8>)
 100aa8c:	f7ff fb78 	bl	100a180 <ull_disable>
	LL_ASSERT(!ret);
 100aa90:	b9d0      	cbnz	r0, 100aac8 <ull_adv_reset+0xa0>
	mark = ull_disable_unmark(adv);
 100aa92:	4820      	ldr	r0, [pc, #128]	; (100ab14 <ull_adv_reset+0xec>)
 100aa94:	f7ff fb42 	bl	100a11c <ull_disable_unmark>
	LL_ASSERT(mark == adv);
 100aa98:	4284      	cmp	r4, r0
 100aa9a:	d004      	beq.n	100aaa6 <ull_adv_reset+0x7e>
 100aa9c:	f240 510b 	movw	r1, #1291	; 0x50b
 100aaa0:	481d      	ldr	r0, [pc, #116]	; (100ab18 <ull_adv_reset+0xf0>)
 100aaa2:	f7f8 fd71 	bl	1003588 <bt_ctlr_assert_handle>
	if (adv->lll.conn) {
 100aaa6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 100aaa8:	b10b      	cbz	r3, 100aaae <ull_adv_reset+0x86>
		conn_release(adv);
 100aaaa:	f7ff fe65 	bl	100a778 <conn_release.constprop.0>
	adv->is_enabled = 0U;
 100aaae:	f894 30cc 	ldrb.w	r3, [r4, #204]	; 0xcc
	if (IS_ENABLED(CONFIG_BT_OBSERVER) && !ull_scan_is_enabled_get(0)) {
 100aab2:	2000      	movs	r0, #0
	adv->is_enabled = 0U;
 100aab4:	f36f 0300 	bfc	r3, #0, #1
 100aab8:	f884 30cc 	strb.w	r3, [r4, #204]	; 0xcc
	if (IS_ENABLED(CONFIG_BT_OBSERVER) && !ull_scan_is_enabled_get(0)) {
 100aabc:	f000 f98e 	bl	100addc <ull_scan_is_enabled_get>
 100aac0:	b1c0      	cbz	r0, 100aaf4 <ull_adv_reset+0xcc>
}
 100aac2:	2000      	movs	r0, #0
 100aac4:	b005      	add	sp, #20
 100aac6:	bd30      	pop	{r4, r5, pc}
	LL_ASSERT(!ret);
 100aac8:	f44f 61a1 	mov.w	r1, #1288	; 0x508
 100aacc:	4812      	ldr	r0, [pc, #72]	; (100ab18 <ull_adv_reset+0xf0>)
 100aace:	f7f8 fd5b 	bl	1003588 <bt_ctlr_assert_handle>
	mark = ull_disable_unmark(adv);
 100aad2:	4810      	ldr	r0, [pc, #64]	; (100ab14 <ull_adv_reset+0xec>)
 100aad4:	f7ff fb22 	bl	100a11c <ull_disable_unmark>
	LL_ASSERT(mark == adv);
 100aad8:	4284      	cmp	r4, r0
 100aada:	d1df      	bne.n	100aa9c <ull_adv_reset+0x74>
 100aadc:	e7e3      	b.n	100aaa6 <ull_adv_reset+0x7e>
		mark = ull_disable_mark(adv);
 100aade:	480d      	ldr	r0, [pc, #52]	; (100ab14 <ull_adv_reset+0xec>)
 100aae0:	f7ff fb12 	bl	100a108 <ull_disable_mark>
		LL_ASSERT(mark == adv);
 100aae4:	4284      	cmp	r4, r0
 100aae6:	d0ec      	beq.n	100aac2 <ull_adv_reset+0x9a>
 100aae8:	f240 5102 	movw	r1, #1282	; 0x502
 100aaec:	480a      	ldr	r0, [pc, #40]	; (100ab18 <ull_adv_reset+0xf0>)
 100aaee:	f7f8 fd4b 	bl	1003588 <bt_ctlr_assert_handle>
 100aaf2:	e7e6      	b.n	100aac2 <ull_adv_reset+0x9a>
		ull_filter_adv_scan_state_cb(0);
 100aaf4:	f004 f946 	bl	100ed84 <ull_filter_adv_scan_state_cb>
}
 100aaf8:	2000      	movs	r0, #0
 100aafa:	b005      	add	sp, #20
 100aafc:	bd30      	pop	{r4, r5, pc}
			mark = ull_disable_mark(adv);
 100aafe:	4805      	ldr	r0, [pc, #20]	; (100ab14 <ull_adv_reset+0xec>)
 100ab00:	f7ff fb02 	bl	100a108 <ull_disable_mark>
			LL_ASSERT(mark == adv);
 100ab04:	4284      	cmp	r4, r0
 100ab06:	d0dc      	beq.n	100aac2 <ull_adv_reset+0x9a>
 100ab08:	f240 41f3 	movw	r1, #1267	; 0x4f3
 100ab0c:	4802      	ldr	r0, [pc, #8]	; (100ab18 <ull_adv_reset+0xf0>)
 100ab0e:	f7f8 fd3b 	bl	1003588 <bt_ctlr_assert_handle>
 100ab12:	e7d6      	b.n	100aac2 <ull_adv_reset+0x9a>
 100ab14:	210019d0 	.word	0x210019d0
 100ab18:	01018740 	.word	0x01018740
 100ab1c:	0100a0e1 	.word	0x0100a0e1
 100ab20:	210019ec 	.word	0x210019ec

0100ab24 <ull_adv_handle_get>:
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
 100ab24:	4a04      	ldr	r2, [pc, #16]	; (100ab38 <ull_adv_handle_get+0x14>)
 100ab26:	4b05      	ldr	r3, [pc, #20]	; (100ab3c <ull_adv_handle_get+0x18>)
 100ab28:	1a80      	subs	r0, r0, r2
 100ab2a:	0880      	lsrs	r0, r0, #2
 100ab2c:	fba3 3000 	umull	r3, r0, r3, r0
}
 100ab30:	f3c0 004f 	ubfx	r0, r0, #1, #16
 100ab34:	4770      	bx	lr
 100ab36:	bf00      	nop
 100ab38:	210019d0 	.word	0x210019d0
 100ab3c:	08fb823f 	.word	0x08fb823f

0100ab40 <ull_adv_lll_handle_get>:
	return ((u8_t *)adv - (u8_t *)ll_adv) / sizeof(*adv);
 100ab40:	4a04      	ldr	r2, [pc, #16]	; (100ab54 <ull_adv_lll_handle_get+0x14>)
 100ab42:	6800      	ldr	r0, [r0, #0]
 100ab44:	4b04      	ldr	r3, [pc, #16]	; (100ab58 <ull_adv_lll_handle_get+0x18>)
 100ab46:	1a80      	subs	r0, r0, r2
 100ab48:	0880      	lsrs	r0, r0, #2
 100ab4a:	fba3 3000 	umull	r3, r0, r3, r0
}
 100ab4e:	f3c0 004f 	ubfx	r0, r0, #1, #16
 100ab52:	4770      	bx	lr
 100ab54:	210019d0 	.word	0x210019d0
 100ab58:	08fb823f 	.word	0x08fb823f

0100ab5c <ull_adv_is_enabled_get>:
	if (handle >= BT_CTLR_ADV_MAX) {
 100ab5c:	b938      	cbnz	r0, 100ab6e <ull_adv_is_enabled_get+0x12>
	if (!adv || !adv->is_enabled) {
 100ab5e:	4805      	ldr	r0, [pc, #20]	; (100ab74 <ull_adv_is_enabled_get+0x18>)
 100ab60:	f890 30cc 	ldrb.w	r3, [r0, #204]	; 0xcc
	return &ll_adv[handle];
 100ab64:	f013 0f01 	tst.w	r3, #1
 100ab68:	bf08      	it	eq
 100ab6a:	2000      	moveq	r0, #0
 100ab6c:	4770      	bx	lr
		return NULL;
 100ab6e:	2000      	movs	r0, #0
}
 100ab70:	4770      	bx	lr
 100ab72:	bf00      	nop
 100ab74:	210019d0 	.word	0x210019d0

0100ab78 <ull_adv_is_enabled>:
	if (handle >= BT_CTLR_ADV_MAX) {
 100ab78:	b928      	cbnz	r0, 100ab86 <ull_adv_is_enabled+0xe>
	if (!adv || !adv->is_enabled) {
 100ab7a:	4b04      	ldr	r3, [pc, #16]	; (100ab8c <ull_adv_is_enabled+0x14>)
 100ab7c:	f893 00cc 	ldrb.w	r0, [r3, #204]	; 0xcc
 100ab80:	f000 0001 	and.w	r0, r0, #1
 100ab84:	4770      	bx	lr
		return 0;
 100ab86:	2000      	movs	r0, #0
}
 100ab88:	4770      	bx	lr
 100ab8a:	bf00      	nop
 100ab8c:	210019d0 	.word	0x210019d0

0100ab90 <ull_adv_filter_pol_get>:
	if (handle >= BT_CTLR_ADV_MAX) {
 100ab90:	b950      	cbnz	r0, 100aba8 <ull_adv_filter_pol_get+0x18>
	if (!adv || !adv->is_enabled) {
 100ab92:	4b06      	ldr	r3, [pc, #24]	; (100abac <ull_adv_filter_pol_get+0x1c>)
 100ab94:	f893 00cc 	ldrb.w	r0, [r3, #204]	; 0xcc
 100ab98:	f010 0001 	ands.w	r0, r0, #1
 100ab9c:	d005      	beq.n	100abaa <ull_adv_filter_pol_get+0x1a>
	return adv->lll.filter_policy;
 100ab9e:	f893 0029 	ldrb.w	r0, [r3, #41]	; 0x29
 100aba2:	f000 0003 	and.w	r0, r0, #3
 100aba6:	4770      	bx	lr
		return 0;
 100aba8:	2000      	movs	r0, #0
}
 100abaa:	4770      	bx	lr
 100abac:	210019d0 	.word	0x210019d0

0100abb0 <ticker_cb>:
	return 0;
}

static void ticker_cb(u32_t ticks_at_expire, u32_t remainder, u16_t lazy,
		      void *param)
{
 100abb0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100abb4:	461c      	mov	r4, r3
 100abb6:	7c1b      	ldrb	r3, [r3, #16]
 100abb8:	4607      	mov	r7, r0
 100abba:	3301      	adds	r3, #1
 100abbc:	b2db      	uxtb	r3, r3
 100abbe:	4688      	mov	r8, r1
 100abc0:	4616      	mov	r6, r2
 100abc2:	7423      	strb	r3, [r4, #16]

	DEBUG_RADIO_PREPARE_O(1);

	/* Increment prepare reference count */
	ref = ull_ref_inc(&scan->ull);
	LL_ASSERT(ref);
 100abc4:	b30b      	cbz	r3, 100ac0a <ticker_cb+0x5a>
	p.lazy = lazy;
	p.param = &scan->lll;
	mfy.param = &p;

	/* Kick LLL prepare */
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100abc6:	2200      	movs	r2, #0
	p.ticks_at_expire = ticks_at_expire;
 100abc8:	4d16      	ldr	r5, [pc, #88]	; (100ac24 <ticker_cb+0x74>)
	mfy.param = &p;
 100abca:	4b17      	ldr	r3, [pc, #92]	; (100ac28 <ticker_cb+0x78>)
	p.param = &scan->lll;
 100abcc:	f104 0c1c 	add.w	ip, r4, #28
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100abd0:	4611      	mov	r1, r2
 100abd2:	2001      	movs	r0, #1
	p.remainder = remainder;
 100abd4:	e9c5 7800 	strd	r7, r8, [r5]
	mfy.param = &p;
 100abd8:	609d      	str	r5, [r3, #8]
	p.lazy = lazy;
 100abda:	812e      	strh	r6, [r5, #8]
	p.param = &scan->lll;
 100abdc:	f8c5 c00c 	str.w	ip, [r5, #12]
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100abe0:	f7fb f8f6 	bl	1005dd0 <mayfly_enqueue>
			     0, &mfy);
	LL_ASSERT(!ret);
 100abe4:	b958      	cbnz	r0, 100abfe <ticker_cb+0x4e>

#if defined(CONFIG_BT_CENTRAL) && defined(CONFIG_BT_CTLR_SCHED_ADVANCED)
	/* calc next group in us for the anchor where first connection event
	 * to be placed
	 */
	if (scan->lll.conn) {
 100abe6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 100abe8:	b13b      	cbz	r3, 100abfa <ticker_cb+0x4a>
			ull_sched_mfy_after_mstr_offset_get};
		u32_t retval;

		s_mfy_sched_after_mstr_offset_get.param = (void *)scan;

		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 100abea:	2201      	movs	r2, #1
		s_mfy_sched_after_mstr_offset_get.param = (void *)scan;
 100abec:	4b0f      	ldr	r3, [pc, #60]	; (100ac2c <ticker_cb+0x7c>)
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 100abee:	4610      	mov	r0, r2
 100abf0:	2102      	movs	r1, #2
		s_mfy_sched_after_mstr_offset_get.param = (void *)scan;
 100abf2:	609c      	str	r4, [r3, #8]
		retval = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH,
 100abf4:	f7fb f8ec 	bl	1005dd0 <mayfly_enqueue>
				TICKER_USER_ID_ULL_LOW, 1,
				&s_mfy_sched_after_mstr_offset_get);
		LL_ASSERT(!retval);
 100abf8:	b968      	cbnz	r0, 100ac16 <ticker_cb+0x66>
	}
#endif /* CONFIG_BT_CENTRAL && CONFIG_BT_CTLR_SCHED_ADVANCED */

	DEBUG_RADIO_PREPARE_O(1);
}
 100abfa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	LL_ASSERT(!ret);
 100abfe:	f44f 71ca 	mov.w	r1, #404	; 0x194
 100ac02:	480b      	ldr	r0, [pc, #44]	; (100ac30 <ticker_cb+0x80>)
 100ac04:	f7f8 fcc0 	bl	1003588 <bt_ctlr_assert_handle>
 100ac08:	e7ed      	b.n	100abe6 <ticker_cb+0x36>
	LL_ASSERT(ref);
 100ac0a:	f44f 71c4 	mov.w	r1, #392	; 0x188
 100ac0e:	4808      	ldr	r0, [pc, #32]	; (100ac30 <ticker_cb+0x80>)
 100ac10:	f7f8 fcba 	bl	1003588 <bt_ctlr_assert_handle>
 100ac14:	e7d7      	b.n	100abc6 <ticker_cb+0x16>
		LL_ASSERT(!retval);
 100ac16:	f44f 71d3 	mov.w	r1, #422	; 0x1a6
}
 100ac1a:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		LL_ASSERT(!retval);
 100ac1e:	4804      	ldr	r0, [pc, #16]	; (100ac30 <ticker_cb+0x80>)
 100ac20:	f7f8 bcb2 	b.w	1003588 <bt_ctlr_assert_handle>
 100ac24:	21001b24 	.word	0x21001b24
 100ac28:	210002cc 	.word	0x210002cc
 100ac2c:	210002dc 	.word	0x210002dc
 100ac30:	01018790 	.word	0x01018790

0100ac34 <ull_scan_init>:
}
 100ac34:	2000      	movs	r0, #0
 100ac36:	4770      	bx	lr

0100ac38 <ull_scan_disable>:
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 100ac38:	2302      	movs	r3, #2
{
 100ac3a:	b530      	push	{r4, r5, lr}
 100ac3c:	4605      	mov	r5, r0
 100ac3e:	b085      	sub	sp, #20
	mark = ull_disable_mark(scan);
 100ac40:	4608      	mov	r0, r1
{
 100ac42:	460c      	mov	r4, r1
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 100ac44:	9303      	str	r3, [sp, #12]
	mark = ull_disable_mark(scan);
 100ac46:	f7ff fa5f 	bl	100a108 <ull_disable_mark>
	LL_ASSERT(mark == scan);
 100ac4a:	4284      	cmp	r4, r0
 100ac4c:	d004      	beq.n	100ac58 <ull_scan_disable+0x20>
 100ac4e:	f240 1113 	movw	r1, #275	; 0x113
 100ac52:	481d      	ldr	r0, [pc, #116]	; (100acc8 <ull_scan_disable+0x90>)
 100ac54:	f7f8 fc98 	bl	1003588 <bt_ctlr_assert_handle>
			  TICKER_ID_SCAN_BASE + handle,
 100ac58:	1d2a      	adds	r2, r5, #4
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
 100ac5a:	ad03      	add	r5, sp, #12
 100ac5c:	2103      	movs	r1, #3
 100ac5e:	2000      	movs	r0, #0
 100ac60:	4b1a      	ldr	r3, [pc, #104]	; (100accc <ull_scan_disable+0x94>)
 100ac62:	b2d2      	uxtb	r2, r2
 100ac64:	9500      	str	r5, [sp, #0]
 100ac66:	f7fc fae5 	bl	1007234 <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
 100ac6a:	4629      	mov	r1, r5
 100ac6c:	f7ff fa3e 	bl	100a0ec <ull_ticker_status_take>
	if (ret) {
 100ac70:	b9d0      	cbnz	r0, 100aca8 <ull_scan_disable+0x70>
	ret = ull_disable(&scan->lll);
 100ac72:	f104 001c 	add.w	r0, r4, #28
 100ac76:	f7ff fa83 	bl	100a180 <ull_disable>
	LL_ASSERT(!ret);
 100ac7a:	b978      	cbnz	r0, 100ac9c <ull_scan_disable+0x64>
	mark = ull_disable_unmark(scan);
 100ac7c:	4620      	mov	r0, r4
 100ac7e:	f7ff fa4d 	bl	100a11c <ull_disable_unmark>
	LL_ASSERT(mark == scan);
 100ac82:	4284      	cmp	r4, r0
 100ac84:	d007      	beq.n	100ac96 <ull_scan_disable+0x5e>
 100ac86:	f240 1125 	movw	r1, #293	; 0x125
 100ac8a:	480f      	ldr	r0, [pc, #60]	; (100acc8 <ull_scan_disable+0x90>)
 100ac8c:	f7f8 fc7c 	bl	1003588 <bt_ctlr_assert_handle>
	return 0;
 100ac90:	2000      	movs	r0, #0
}
 100ac92:	b005      	add	sp, #20
 100ac94:	bd30      	pop	{r4, r5, pc}
	return 0;
 100ac96:	2000      	movs	r0, #0
}
 100ac98:	b005      	add	sp, #20
 100ac9a:	bd30      	pop	{r4, r5, pc}
	LL_ASSERT(!ret);
 100ac9c:	f44f 7191 	mov.w	r1, #290	; 0x122
 100aca0:	4809      	ldr	r0, [pc, #36]	; (100acc8 <ull_scan_disable+0x90>)
 100aca2:	f7f8 fc71 	bl	1003588 <bt_ctlr_assert_handle>
 100aca6:	e7e9      	b.n	100ac7c <ull_scan_disable+0x44>
		mark = ull_disable_unmark(scan);
 100aca8:	4620      	mov	r0, r4
 100acaa:	f7ff fa37 	bl	100a11c <ull_disable_unmark>
		LL_ASSERT(mark == scan);
 100acae:	4284      	cmp	r4, r0
 100acb0:	d007      	beq.n	100acc2 <ull_scan_disable+0x8a>
 100acb2:	f44f 718e 	mov.w	r1, #284	; 0x11c
 100acb6:	4804      	ldr	r0, [pc, #16]	; (100acc8 <ull_scan_disable+0x90>)
 100acb8:	f7f8 fc66 	bl	1003588 <bt_ctlr_assert_handle>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100acbc:	200c      	movs	r0, #12
}
 100acbe:	b005      	add	sp, #20
 100acc0:	bd30      	pop	{r4, r5, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100acc2:	200c      	movs	r0, #12
}
 100acc4:	b005      	add	sp, #20
 100acc6:	bd30      	pop	{r4, r5, pc}
 100acc8:	01018790 	.word	0x01018790
 100accc:	0100a0e1 	.word	0x0100a0e1

0100acd0 <disable.constprop.0>:

static u8_t disable(u16_t handle)
 100acd0:	b538      	push	{r3, r4, r5, lr}
	if (!scan || !scan->is_enabled) {
 100acd2:	4c0e      	ldr	r4, [pc, #56]	; (100ad0c <disable.constprop.0+0x3c>)
 100acd4:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 100acd8:	07db      	lsls	r3, r3, #31
 100acda:	d501      	bpl.n	100ace0 <disable.constprop.0+0x10>
	if (!scan) {
		return BT_HCI_ERR_CMD_DISALLOWED;
	}

#if defined(CONFIG_BT_CENTRAL)
	if (scan->lll.conn) {
 100acdc:	6a60      	ldr	r0, [r4, #36]	; 0x24
 100acde:	b110      	cbz	r0, 100ace6 <disable.constprop.0+0x16>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100ace0:	250c      	movs	r5, #12
		ull_filter_adv_scan_state_cb(0);
	}
#endif

	return 0;
}
 100ace2:	4628      	mov	r0, r5
 100ace4:	bd38      	pop	{r3, r4, r5, pc}
	ret = ull_scan_disable(handle, scan);
 100ace6:	4621      	mov	r1, r4
 100ace8:	f7ff ffa6 	bl	100ac38 <ull_scan_disable>
	if (ret) {
 100acec:	4605      	mov	r5, r0
 100acee:	2800      	cmp	r0, #0
 100acf0:	d1f7      	bne.n	100ace2 <disable.constprop.0+0x12>
	scan->is_enabled = 0U;
 100acf2:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 100acf6:	f360 0300 	bfi	r3, r0, #0, #1
 100acfa:	f884 3048 	strb.w	r3, [r4, #72]	; 0x48
	if (!ull_adv_is_enabled_get(0))
 100acfe:	f7ff ff2d 	bl	100ab5c <ull_adv_is_enabled_get>
 100ad02:	2800      	cmp	r0, #0
 100ad04:	d1ed      	bne.n	100ace2 <disable.constprop.0+0x12>
		ull_filter_adv_scan_state_cb(0);
 100ad06:	f004 f83d 	bl	100ed84 <ull_filter_adv_scan_state_cb>
 100ad0a:	e7ea      	b.n	100ace2 <disable.constprop.0+0x12>
 100ad0c:	21001ad8 	.word	0x21001ad8

0100ad10 <ll_scan_enable>:
	if (!enable) {
 100ad10:	b358      	cbz	r0, 100ad6a <ll_scan_enable+0x5a>
{
 100ad12:	b510      	push	{r4, lr}
	if (!scan || scan->is_enabled) {
 100ad14:	4c1f      	ldr	r4, [pc, #124]	; (100ad94 <ll_scan_enable+0x84>)
 100ad16:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 100ad1a:	f013 0101 	ands.w	r1, r3, #1
 100ad1e:	d136      	bne.n	100ad8e <ll_scan_enable+0x7e>
	if (scan->own_addr_type & 0x1) {
 100ad20:	079a      	lsls	r2, r3, #30
 100ad22:	d506      	bpl.n	100ad32 <ll_scan_enable+0x22>
		if (!mem_nz(ll_addr_get(1, NULL), BDADDR_SIZE)) {
 100ad24:	2001      	movs	r0, #1
 100ad26:	f7fc fac5 	bl	10072b4 <ll_addr_get>
 100ad2a:	2106      	movs	r1, #6
 100ad2c:	f7fa ffc2 	bl	1005cb4 <mem_nz>
 100ad30:	b1e8      	cbz	r0, 100ad6e <ll_scan_enable+0x5e>
	ull_filter_scan_update(lll->filter_policy);
 100ad32:	f894 0032 	ldrb.w	r0, [r4, #50]	; 0x32
 100ad36:	f3c0 00c1 	ubfx	r0, r0, #3, #2
 100ad3a:	f004 f867 	bl	100ee0c <ull_filter_scan_update>
	lll->rl_idx = FILTER_IDX_NONE;
 100ad3e:	21ff      	movs	r1, #255	; 0xff
	lll->rpa_gen = 0;
 100ad40:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
	if ((lll->type & 0x1) &&
 100ad44:	f894 2032 	ldrb.w	r2, [r4, #50]	; 0x32
	lll->rpa_gen = 0;
 100ad48:	f36f 0300 	bfc	r3, #0, #1
 100ad4c:	f884 3033 	strb.w	r3, [r4, #51]	; 0x33
	if ((lll->type & 0x1) &&
 100ad50:	09d3      	lsrs	r3, r2, #7
	lll->rl_idx = FILTER_IDX_NONE;
 100ad52:	f884 1034 	strb.w	r1, [r4, #52]	; 0x34
	if ((lll->type & 0x1) &&
 100ad56:	d003      	beq.n	100ad60 <ll_scan_enable+0x50>
 100ad58:	f894 3048 	ldrb.w	r3, [r4, #72]	; 0x48
 100ad5c:	075b      	lsls	r3, r3, #29
 100ad5e:	d408      	bmi.n	100ad72 <ll_scan_enable+0x62>
}
 100ad60:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return ull_scan_enable(scan);
 100ad64:	480b      	ldr	r0, [pc, #44]	; (100ad94 <ll_scan_enable+0x84>)
 100ad66:	f7f5 be73 	b.w	1000a50 <ull_scan_enable>
		return disable(0);
 100ad6a:	f7ff bfb1 	b.w	100acd0 <disable.constprop.0>
			return BT_HCI_ERR_INVALID_PARAM;
 100ad6e:	2012      	movs	r0, #18
}
 100ad70:	bd10      	pop	{r4, pc}
		ull_filter_rpa_update(false);
 100ad72:	2000      	movs	r0, #0
 100ad74:	f004 f8ee 	bl	100ef54 <ull_filter_rpa_update>
		lll->rpa_gen = 1;
 100ad78:	f894 3033 	ldrb.w	r3, [r4, #51]	; 0x33
	return ull_scan_enable(scan);
 100ad7c:	4805      	ldr	r0, [pc, #20]	; (100ad94 <ll_scan_enable+0x84>)
		lll->rpa_gen = 1;
 100ad7e:	f043 0301 	orr.w	r3, r3, #1
 100ad82:	f884 3033 	strb.w	r3, [r4, #51]	; 0x33
}
 100ad86:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	return ull_scan_enable(scan);
 100ad8a:	f7f5 be61 	b.w	1000a50 <ull_scan_enable>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100ad8e:	200c      	movs	r0, #12
}
 100ad90:	bd10      	pop	{r4, pc}
 100ad92:	bf00      	nop
 100ad94:	21001ad8 	.word	0x21001ad8

0100ad98 <ull_scan_reset>:
{
 100ad98:	b508      	push	{r3, lr}
		(void)disable(handle);
 100ad9a:	f7ff ff99 	bl	100acd0 <disable.constprop.0>
}
 100ad9e:	2000      	movs	r0, #0
 100ada0:	bd08      	pop	{r3, pc}
 100ada2:	bf00      	nop

0100ada4 <ull_scan_handle_get>:
	return ((u8_t *)scan - (u8_t *)ll_scan) / sizeof(*scan);
 100ada4:	4a04      	ldr	r2, [pc, #16]	; (100adb8 <ull_scan_handle_get+0x14>)
 100ada6:	4b05      	ldr	r3, [pc, #20]	; (100adbc <ull_scan_handle_get+0x18>)
 100ada8:	1a80      	subs	r0, r0, r2
 100adaa:	0880      	lsrs	r0, r0, #2
 100adac:	fba3 3000 	umull	r3, r0, r3, r0
}
 100adb0:	f3c0 004f 	ubfx	r0, r0, #1, #16
 100adb4:	4770      	bx	lr
 100adb6:	bf00      	nop
 100adb8:	21001ad8 	.word	0x21001ad8
 100adbc:	1af286bd 	.word	0x1af286bd

0100adc0 <ull_scan_lll_handle_get>:
	return ((u8_t *)scan - (u8_t *)ll_scan) / sizeof(*scan);
 100adc0:	4a04      	ldr	r2, [pc, #16]	; (100add4 <ull_scan_lll_handle_get+0x14>)
 100adc2:	6800      	ldr	r0, [r0, #0]
 100adc4:	4b04      	ldr	r3, [pc, #16]	; (100add8 <ull_scan_lll_handle_get+0x18>)
 100adc6:	1a80      	subs	r0, r0, r2
 100adc8:	0880      	lsrs	r0, r0, #2
 100adca:	fba3 3000 	umull	r3, r0, r3, r0
}
 100adce:	f3c0 004f 	ubfx	r0, r0, #1, #16
 100add2:	4770      	bx	lr
 100add4:	21001ad8 	.word	0x21001ad8
 100add8:	1af286bd 	.word	0x1af286bd

0100addc <ull_scan_is_enabled_get>:
	if (handle >= BT_CTLR_SCAN_MAX) {
 100addc:	b938      	cbnz	r0, 100adee <ull_scan_is_enabled_get+0x12>
	if (!scan || !scan->is_enabled) {
 100adde:	4805      	ldr	r0, [pc, #20]	; (100adf4 <ull_scan_is_enabled_get+0x18>)
 100ade0:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
	return &ll_scan[handle];
 100ade4:	f013 0f01 	tst.w	r3, #1
 100ade8:	bf08      	it	eq
 100adea:	2000      	moveq	r0, #0
 100adec:	4770      	bx	lr
		return NULL;
 100adee:	2000      	movs	r0, #0
}
 100adf0:	4770      	bx	lr
 100adf2:	bf00      	nop
 100adf4:	21001ad8 	.word	0x21001ad8

0100adf8 <ull_scan_is_disabled_get>:
	if (handle >= BT_CTLR_SCAN_MAX) {
 100adf8:	b938      	cbnz	r0, 100ae0a <ull_scan_is_disabled_get+0x12>
	if (!scan || scan->is_enabled) {
 100adfa:	4805      	ldr	r0, [pc, #20]	; (100ae10 <ull_scan_is_disabled_get+0x18>)
 100adfc:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
	return &ll_scan[handle];
 100ae00:	f013 0f01 	tst.w	r3, #1
 100ae04:	bf18      	it	ne
 100ae06:	2000      	movne	r0, #0
 100ae08:	4770      	bx	lr
		return NULL;
 100ae0a:	2000      	movs	r0, #0
}
 100ae0c:	4770      	bx	lr
 100ae0e:	bf00      	nop
 100ae10:	21001ad8 	.word	0x21001ad8

0100ae14 <ull_scan_is_enabled>:
	if (handle >= BT_CTLR_SCAN_MAX) {
 100ae14:	b988      	cbnz	r0, 100ae3a <ull_scan_is_enabled+0x26>
	if (!scan || !scan->is_enabled) {
 100ae16:	4a0a      	ldr	r2, [pc, #40]	; (100ae40 <ull_scan_is_enabled+0x2c>)
 100ae18:	f892 3048 	ldrb.w	r3, [r2, #72]	; 0x48
 100ae1c:	f013 0001 	ands.w	r0, r3, #1
 100ae20:	d00c      	beq.n	100ae3c <ull_scan_is_enabled+0x28>
	return (((u32_t)scan->is_enabled << scan->lll.type) |
 100ae22:	f892 0032 	ldrb.w	r0, [r2, #50]	; 0x32
		(scan->lll.conn ? BIT(2) : 0) |
 100ae26:	6a52      	ldr	r2, [r2, #36]	; 0x24
	return (((u32_t)scan->is_enabled << scan->lll.type) |
 100ae28:	f003 0301 	and.w	r3, r3, #1
 100ae2c:	09c0      	lsrs	r0, r0, #7
 100ae2e:	fa03 f000 	lsl.w	r0, r3, r0
		(scan->lll.conn ? BIT(2) : 0) |
 100ae32:	b11a      	cbz	r2, 100ae3c <ull_scan_is_enabled+0x28>
 100ae34:	f040 0004 	orr.w	r0, r0, #4
 100ae38:	4770      	bx	lr
		return 0;
 100ae3a:	2000      	movs	r0, #0
}
 100ae3c:	4770      	bx	lr
 100ae3e:	bf00      	nop
 100ae40:	21001ad8 	.word	0x21001ad8

0100ae44 <ull_scan_filter_pol_get>:
	if (handle >= BT_CTLR_SCAN_MAX) {
 100ae44:	b950      	cbnz	r0, 100ae5c <ull_scan_filter_pol_get+0x18>
	if (!scan || !scan->is_enabled) {
 100ae46:	4b06      	ldr	r3, [pc, #24]	; (100ae60 <ull_scan_filter_pol_get+0x1c>)
 100ae48:	f893 0048 	ldrb.w	r0, [r3, #72]	; 0x48
 100ae4c:	f010 0001 	ands.w	r0, r0, #1
 100ae50:	d005      	beq.n	100ae5e <ull_scan_filter_pol_get+0x1a>
	return scan->lll.filter_policy;
 100ae52:	f893 0032 	ldrb.w	r0, [r3, #50]	; 0x32
 100ae56:	f3c0 00c1 	ubfx	r0, r0, #3, #2
 100ae5a:	4770      	bx	lr
		return 0;
 100ae5c:	2000      	movs	r0, #0
}
 100ae5e:	4770      	bx	lr
 100ae60:	21001ad8 	.word	0x21001ad8

0100ae64 <tx_ull_dequeue>:
	if (!conn->tx_ctrl && (conn->tx_head != conn->tx_data)) {
 100ae64:	f8d0 21b4 	ldr.w	r2, [r0, #436]	; 0x1b4
{
 100ae68:	4603      	mov	r3, r0
 100ae6a:	b410      	push	{r4}
 100ae6c:	4608      	mov	r0, r1
	if (!conn->tx_ctrl && (conn->tx_head != conn->tx_data)) {
 100ae6e:	b172      	cbz	r2, 100ae8e <tx_ull_dequeue+0x2a>
	if (conn->tx_head == conn->tx_ctrl) {
 100ae70:	f8d3 11b0 	ldr.w	r1, [r3, #432]	; 0x1b0
 100ae74:	428a      	cmp	r2, r1
 100ae76:	d02b      	beq.n	100aed0 <tx_ull_dequeue+0x6c>
 100ae78:	f8d3 21bc 	ldr.w	r2, [r3, #444]	; 0x1bc
		if (conn->tx_head == conn->tx_data) {
 100ae7c:	4291      	cmp	r1, r2
 100ae7e:	d01a      	beq.n	100aeb6 <tx_ull_dequeue+0x52>
		tx->next = NULL;
 100ae80:	2200      	movs	r2, #0
		conn->tx_head = conn->tx_head->next;
 100ae82:	6809      	ldr	r1, [r1, #0]
}
 100ae84:	bc10      	pop	{r4}
		conn->tx_head = conn->tx_head->next;
 100ae86:	f8c3 11b0 	str.w	r1, [r3, #432]	; 0x1b0
		tx->next = NULL;
 100ae8a:	6002      	str	r2, [r0, #0]
}
 100ae8c:	4770      	bx	lr
	if (!conn->tx_ctrl && (conn->tx_head != conn->tx_data)) {
 100ae8e:	f8d3 21b0 	ldr.w	r2, [r3, #432]	; 0x1b0
 100ae92:	f8d3 11bc 	ldr.w	r1, [r3, #444]	; 0x1bc
 100ae96:	428a      	cmp	r2, r1
 100ae98:	d025      	beq.n	100aee6 <tx_ull_dequeue+0x82>
		if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
 100ae9a:	7911      	ldrb	r1, [r2, #4]
 100ae9c:	f001 0103 	and.w	r1, r1, #3
 100aea0:	2903      	cmp	r1, #3
 100aea2:	d00e      	beq.n	100aec2 <tx_ull_dequeue+0x5e>
		conn->tx_head = conn->tx_head->next;
 100aea4:	6812      	ldr	r2, [r2, #0]
 100aea6:	f8c3 21b0 	str.w	r2, [r3, #432]	; 0x1b0
			conn->tx_ctrl = NULL;
 100aeaa:	2200      	movs	r2, #0
			conn->tx_ctrl_last = NULL;
 100aeac:	e9c3 226d 	strd	r2, r2, [r3, #436]	; 0x1b4
}
 100aeb0:	bc10      	pop	{r4}
		tx->next = tx;
 100aeb2:	6000      	str	r0, [r0, #0]
}
 100aeb4:	4770      	bx	lr
 100aeb6:	4611      	mov	r1, r2
			conn->tx_data = conn->tx_data->next;
 100aeb8:	680c      	ldr	r4, [r1, #0]
 100aeba:	4611      	mov	r1, r2
 100aebc:	f8c3 41bc 	str.w	r4, [r3, #444]	; 0x1bc
 100aec0:	e7de      	b.n	100ae80 <tx_ull_dequeue+0x1c>
		    ((pdu_data_tx->llctrl.opcode !=
 100aec2:	79d1      	ldrb	r1, [r2, #7]
		if ((pdu_data_tx->ll_id != PDU_DATA_LLID_CTRL) ||
 100aec4:	2903      	cmp	r1, #3
 100aec6:	d001      	beq.n	100aecc <tx_ull_dequeue+0x68>
		      PDU_DATA_LLCTRL_TYPE_ENC_REQ) &&
 100aec8:	290a      	cmp	r1, #10
 100aeca:	d1eb      	bne.n	100aea4 <tx_ull_dequeue+0x40>
 100aecc:	4611      	mov	r1, r2
 100aece:	e7d7      	b.n	100ae80 <tx_ull_dequeue+0x1c>
 100aed0:	f8d3 41b8 	ldr.w	r4, [r3, #440]	; 0x1b8
		conn->tx_head = conn->tx_head->next;
 100aed4:	6809      	ldr	r1, [r1, #0]
		if (conn->tx_ctrl == conn->tx_ctrl_last) {
 100aed6:	4294      	cmp	r4, r2
		conn->tx_head = conn->tx_head->next;
 100aed8:	f8c3 11b0 	str.w	r1, [r3, #432]	; 0x1b0
			conn->tx_ctrl = conn->tx_head;
 100aedc:	bf18      	it	ne
 100aede:	f8c3 11b4 	strne.w	r1, [r3, #436]	; 0x1b4
		if (conn->tx_ctrl == conn->tx_ctrl_last) {
 100aee2:	d1e5      	bne.n	100aeb0 <tx_ull_dequeue+0x4c>
 100aee4:	e7e1      	b.n	100aeaa <tx_ull_dequeue+0x46>
	if (conn->tx_head == conn->tx_ctrl) {
 100aee6:	2a00      	cmp	r2, #0
 100aee8:	d1e6      	bne.n	100aeb8 <tx_ull_dequeue+0x54>
 100aeea:	4611      	mov	r1, r2
 100aeec:	f8d3 41b8 	ldr.w	r4, [r3, #440]	; 0x1b8
 100aef0:	e7f0      	b.n	100aed4 <tx_ull_dequeue+0x70>
 100aef2:	bf00      	nop

0100aef4 <calc_eff_time>:
	u16_t time = PKT_US(max_octets, phy);
 100aef4:	074b      	lsls	r3, r1, #29
 100aef6:	d50c      	bpl.n	100af12 <calc_eff_time+0x1e>
 100aef8:	0181      	lsls	r1, r0, #6
	eff_time = MIN(eff_time, default_time);
 100aefa:	f501 7074 	add.w	r0, r1, #976	; 0x3d0
 100aefe:	4290      	cmp	r0, r2
 100af00:	bf28      	it	cs
 100af02:	4610      	movcs	r0, r2
	eff_time = MAX(eff_time, PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, phy));
 100af04:	f44f 6329 	mov.w	r3, #2704	; 0xa90
 100af08:	4298      	cmp	r0, r3
 100af0a:	bf38      	it	cc
 100af0c:	4618      	movcc	r0, r3
}
 100af0e:	b280      	uxth	r0, r0
 100af10:	4770      	bx	lr
{
 100af12:	b430      	push	{r4, r5}
	u16_t time = PKT_US(max_octets, phy);
 100af14:	f001 0503 	and.w	r5, r1, #3
 100af18:	f100 040d 	add.w	r4, r0, #13
 100af1c:	442c      	add	r4, r5
 100af1e:	f3c1 0140 	ubfx	r1, r1, #1, #1
 100af22:	00e4      	lsls	r4, r4, #3
 100af24:	40cc      	lsrs	r4, r1
	eff_time = MAX(PDU_DC_PAYLOAD_TIME_MIN, time);
 100af26:	b2a3      	uxth	r3, r4
 100af28:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
 100af2c:	bf38      	it	cc
 100af2e:	f44f 73a4 	movcc.w	r3, #328	; 0x148
	eff_time = MIN(eff_time, default_time);
 100af32:	429a      	cmp	r2, r3
 100af34:	bf28      	it	cs
 100af36:	461a      	movcs	r2, r3
	eff_time = MAX(eff_time, PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, phy));
 100af38:	f105 0328 	add.w	r3, r5, #40	; 0x28
 100af3c:	00db      	lsls	r3, r3, #3
 100af3e:	40cb      	lsrs	r3, r1
 100af40:	429a      	cmp	r2, r3
	eff_time = MIN(eff_time, default_time);
 100af42:	4610      	mov	r0, r2
}
 100af44:	bc30      	pop	{r4, r5}
	eff_time = MAX(eff_time, PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, phy));
 100af46:	bf38      	it	cc
 100af48:	4618      	movcc	r0, r3
}
 100af4a:	b280      	uxth	r0, r0
 100af4c:	4770      	bx	lr
 100af4e:	bf00      	nop

0100af50 <ticker_update_latency_cancel_op_cb>:
{
 100af50:	b510      	push	{r4, lr}
 100af52:	460c      	mov	r4, r1
	LL_ASSERT(ticker_status == TICKER_STATUS_SUCCESS);
 100af54:	b930      	cbnz	r0, 100af64 <ticker_update_latency_cancel_op_cb+0x14>
	conn->slave.latency_cancel = 0U;
 100af56:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
 100af5a:	f36f 0341 	bfc	r3, #1, #1
 100af5e:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
}
 100af62:	bd10      	pop	{r4, pc}
	LL_ASSERT(ticker_status == TICKER_STATUS_SUCCESS);
 100af64:	f44f 61cb 	mov.w	r1, #1624	; 0x658
 100af68:	4804      	ldr	r0, [pc, #16]	; (100af7c <ticker_update_latency_cancel_op_cb+0x2c>)
 100af6a:	f7f8 fb0d 	bl	1003588 <bt_ctlr_assert_handle>
	conn->slave.latency_cancel = 0U;
 100af6e:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
 100af72:	f36f 0341 	bfc	r3, #1, #1
 100af76:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
}
 100af7a:	bd10      	pop	{r4, pc}
 100af7c:	010187e4 	.word	0x010187e4

0100af80 <ctrl_tx_pause_enqueue>:
{
 100af80:	b538      	push	{r3, r4, r5, lr}
	    conn->tx_head &&
 100af82:	f8d0 31b0 	ldr.w	r3, [r0, #432]	; 0x1b0
{
 100af86:	4604      	mov	r4, r0
 100af88:	460d      	mov	r5, r1
	if (
 100af8a:	b11b      	cbz	r3, 100af94 <ctrl_tx_pause_enqueue+0x14>
	    !conn->llcp_enc.pause_tx &&
 100af8c:	f890 1152 	ldrb.w	r1, [r0, #338]	; 0x152
	    conn->tx_head &&
 100af90:	0788      	lsls	r0, r1, #30
 100af92:	d50d      	bpl.n	100afb0 <ctrl_tx_pause_enqueue+0x30>
		if (!conn->tx_ctrl) {
 100af94:	f8d4 11b4 	ldr.w	r1, [r4, #436]	; 0x1b4
 100af98:	b319      	cbz	r1, 100afe2 <ctrl_tx_pause_enqueue+0x62>
			LL_ASSERT(!pause);
 100af9a:	bb62      	cbnz	r2, 100aff6 <ctrl_tx_pause_enqueue+0x76>
	tx->next = conn->tx_ctrl_last->next;
 100af9c:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 100afa0:	681a      	ldr	r2, [r3, #0]
 100afa2:	602a      	str	r2, [r5, #0]
	conn->tx_ctrl_last->next = tx;
 100afa4:	601d      	str	r5, [r3, #0]
	conn->tx_ctrl_last = tx;
 100afa6:	f8c4 51b8 	str.w	r5, [r4, #440]	; 0x1b8
 100afaa:	682b      	ldr	r3, [r5, #0]
	if (!tx->next) {
 100afac:	b1b3      	cbz	r3, 100afdc <ctrl_tx_pause_enqueue+0x5c>
}
 100afae:	bd38      	pop	{r3, r4, r5, pc}
	    !conn->llcp_phy.pause_tx &&
 100afb0:	f894 11ab 	ldrb.w	r1, [r4, #427]	; 0x1ab
 100afb4:	07c9      	lsls	r1, r1, #31
 100afb6:	d4ed      	bmi.n	100af94 <ctrl_tx_pause_enqueue+0x14>
		if (conn->tx_head == conn->tx_data) {
 100afb8:	f8d4 11bc 	ldr.w	r1, [r4, #444]	; 0x1bc
 100afbc:	428b      	cmp	r3, r1
			conn->tx_data = conn->tx_data->next;
 100afbe:	bf04      	itt	eq
 100afc0:	6819      	ldreq	r1, [r3, #0]
 100afc2:	f8c4 11bc 	streq.w	r1, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 100afc6:	f8d4 11b4 	ldr.w	r1, [r4, #436]	; 0x1b4
 100afca:	b1d1      	cbz	r1, 100b002 <ctrl_tx_pause_enqueue+0x82>
			LL_ASSERT(!pause);
 100afcc:	2a00      	cmp	r2, #0
 100afce:	d0e5      	beq.n	100af9c <ctrl_tx_pause_enqueue+0x1c>
 100afd0:	f240 716a 	movw	r1, #1898	; 0x76a
 100afd4:	4810      	ldr	r0, [pc, #64]	; (100b018 <ctrl_tx_pause_enqueue+0x98>)
 100afd6:	f7f8 fad7 	bl	1003588 <bt_ctlr_assert_handle>
	tx->next = conn->tx_ctrl_last->next;
 100afda:	e7df      	b.n	100af9c <ctrl_tx_pause_enqueue+0x1c>
		conn->tx_data_last = tx;
 100afdc:	f8c4 51c0 	str.w	r5, [r4, #448]	; 0x1c0
}
 100afe0:	bd38      	pop	{r3, r4, r5, pc}
			tx->next = conn->tx_head;
 100afe2:	602b      	str	r3, [r5, #0]
			conn->tx_head = tx;
 100afe4:	f8c4 51b0 	str.w	r5, [r4, #432]	; 0x1b0
			if (!pause) {
 100afe8:	2a00      	cmp	r2, #0
 100afea:	d1df      	bne.n	100afac <ctrl_tx_pause_enqueue+0x2c>
				conn->tx_ctrl_last = tx;
 100afec:	e9c4 556d 	strd	r5, r5, [r4, #436]	; 0x1b4
	if (!tx->next) {
 100aff0:	2b00      	cmp	r3, #0
 100aff2:	d1dc      	bne.n	100afae <ctrl_tx_pause_enqueue+0x2e>
 100aff4:	e7f2      	b.n	100afdc <ctrl_tx_pause_enqueue+0x5c>
			LL_ASSERT(!pause);
 100aff6:	f240 717c 	movw	r1, #1916	; 0x77c
 100affa:	4807      	ldr	r0, [pc, #28]	; (100b018 <ctrl_tx_pause_enqueue+0x98>)
 100affc:	f7f8 fac4 	bl	1003588 <bt_ctlr_assert_handle>
 100b000:	e7cc      	b.n	100af9c <ctrl_tx_pause_enqueue+0x1c>
			tx->next = conn->tx_head->next;
 100b002:	6819      	ldr	r1, [r3, #0]
 100b004:	6029      	str	r1, [r5, #0]
			conn->tx_head->next = tx;
 100b006:	601d      	str	r5, [r3, #0]
			if (!pause) {
 100b008:	2a00      	cmp	r2, #0
 100b00a:	d1ce      	bne.n	100afaa <ctrl_tx_pause_enqueue+0x2a>
				conn->tx_ctrl_last = tx;
 100b00c:	e9c4 556d 	strd	r5, r5, [r4, #436]	; 0x1b4
 100b010:	682b      	ldr	r3, [r5, #0]
	if (!tx->next) {
 100b012:	2b00      	cmp	r3, #0
 100b014:	d1cb      	bne.n	100afae <ctrl_tx_pause_enqueue+0x2e>
 100b016:	e7e1      	b.n	100afdc <ctrl_tx_pause_enqueue+0x5c>
 100b018:	010187e4 	.word	0x010187e4

0100b01c <init_reset>:
{
 100b01c:	b538      	push	{r3, r4, r5, lr}
	mem_init(conn_pool, sizeof(struct ll_conn),
 100b01e:	2210      	movs	r2, #16
 100b020:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100b024:	4b11      	ldr	r3, [pc, #68]	; (100b06c <init_reset+0x50>)
 100b026:	4812      	ldr	r0, [pc, #72]	; (100b070 <init_reset+0x54>)
 100b028:	f7fa fdcc 	bl	1005bc4 <mem_init>
	mem_init(mem_conn_tx.pool, CONN_TX_BUF_SIZE, CONFIG_BT_CTLR_TX_BUFFERS,
 100b02c:	4b11      	ldr	r3, [pc, #68]	; (100b074 <init_reset+0x58>)
 100b02e:	2207      	movs	r2, #7
 100b030:	1d18      	adds	r0, r3, #4
 100b032:	2124      	movs	r1, #36	; 0x24
 100b034:	f7fa fdc6 	bl	1005bc4 <mem_init>
	mem_init(mem_conn_tx_ctrl.pool, CONN_TX_CTRL_BUF_SIZE,
 100b038:	2204      	movs	r2, #4
 100b03a:	4b0f      	ldr	r3, [pc, #60]	; (100b078 <init_reset+0x5c>)
 100b03c:	2120      	movs	r1, #32
 100b03e:	1898      	adds	r0, r3, r2
 100b040:	f7fa fdc0 	bl	1005bc4 <mem_init>
	mem_init(mem_link_tx.pool, sizeof(memq_link_t),
 100b044:	4b0d      	ldr	r3, [pc, #52]	; (100b07c <init_reset+0x60>)
	default_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
 100b046:	251b      	movs	r5, #27
	mem_init(mem_link_tx.pool, sizeof(memq_link_t),
 100b048:	1d18      	adds	r0, r3, #4
 100b04a:	220b      	movs	r2, #11
 100b04c:	2108      	movs	r1, #8
 100b04e:	f7fa fdb9 	bl	1005bc4 <mem_init>
	default_phy_tx |= BIT(2);
 100b052:	2307      	movs	r3, #7
	default_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M);
 100b054:	f44f 74a4 	mov.w	r4, #328	; 0x148
	default_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
 100b058:	4a09      	ldr	r2, [pc, #36]	; (100b080 <init_reset+0x64>)
	default_phy_tx |= BIT(2);
 100b05a:	490a      	ldr	r1, [pc, #40]	; (100b084 <init_reset+0x68>)
	default_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
 100b05c:	8015      	strh	r5, [r2, #0]
	default_phy_rx |= BIT(2);
 100b05e:	4a0a      	ldr	r2, [pc, #40]	; (100b088 <init_reset+0x6c>)
	default_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M);
 100b060:	480a      	ldr	r0, [pc, #40]	; (100b08c <init_reset+0x70>)
	default_phy_tx |= BIT(2);
 100b062:	700b      	strb	r3, [r1, #0]
	default_phy_rx |= BIT(2);
 100b064:	7013      	strb	r3, [r2, #0]
	default_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M);
 100b066:	8004      	strh	r4, [r0, #0]
}
 100b068:	2000      	movs	r0, #0
 100b06a:	bd38      	pop	{r3, r4, r5, pc}
 100b06c:	21001b3c 	.word	0x21001b3c
 100b070:	21001b40 	.word	0x21001b40
 100b074:	210037cc 	.word	0x210037cc
 100b078:	210038cc 	.word	0x210038cc
 100b07c:	21003950 	.word	0x21003950
 100b080:	21006686 	.word	0x21006686
 100b084:	210066f1 	.word	0x210066f1
 100b088:	210066f0 	.word	0x210066f0
 100b08c:	21006688 	.word	0x21006688

0100b090 <tx_lll_flush>:
{
 100b090:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 100b094:	4605      	mov	r5, r0
	struct ll_conn *conn = (void *)HDR_LLL2EVT(param);
 100b096:	f8d0 8000 	ldr.w	r8, [r0]
{
 100b09a:	b083      	sub	sp, #12
	return mem_index_get(conn, conn_pool, sizeof(struct ll_conn));
 100b09c:	f44f 72e4 	mov.w	r2, #456	; 0x1c8
 100b0a0:	492b      	ldr	r1, [pc, #172]	; (100b150 <tx_lll_flush+0xc0>)
 100b0a2:	4640      	mov	r0, r8
 100b0a4:	f7fa fdf2 	bl	1005c8c <mem_index_get>
	link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
 100b0a8:	f105 064c 	add.w	r6, r5, #76	; 0x4c
	lll_conn_flush(handle, lll);
 100b0ac:	4629      	mov	r1, r5
 100b0ae:	f006 fa4f 	bl	1011550 <lll_conn_flush>
	link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
 100b0b2:	4631      	mov	r1, r6
 100b0b4:	6d28      	ldr	r0, [r5, #80]	; 0x50
 100b0b6:	aa01      	add	r2, sp, #4
 100b0b8:	f7fa fe26 	bl	1005d08 <memq_dequeue>
	while (link) {
 100b0bc:	b338      	cbz	r0, 100b10e <tx_lll_flush+0x7e>
		lll_tx->handle = 0xFFFF;
 100b0be:	f64f 77ff 	movw	r7, #65535	; 0xffff
 100b0c2:	4c24      	ldr	r4, [pc, #144]	; (100b154 <tx_lll_flush+0xc4>)
	*mem = (void *)(fifo + last * size); /* preceding buffer */
 100b0c4:	f104 0904 	add.w	r9, r4, #4
		idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
 100b0c8:	78e2      	ldrb	r2, [r4, #3]
	if (last == count) {
 100b0ca:	7861      	ldrb	r1, [r4, #1]
	last = last + 1;
 100b0cc:	1c53      	adds	r3, r2, #1
 100b0ce:	b2db      	uxtb	r3, r3
		last = 0U;
 100b0d0:	4299      	cmp	r1, r3
 100b0d2:	bf08      	it	eq
 100b0d4:	2300      	moveq	r3, #0
 100b0d6:	78a1      	ldrb	r1, [r4, #2]
	if (last == first) {
 100b0d8:	4299      	cmp	r1, r3
 100b0da:	d030      	beq.n	100b13e <tx_lll_flush+0xae>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
 100b0dc:	7821      	ldrb	r1, [r4, #0]
 100b0de:	fb02 f201 	mul.w	r2, r2, r1
		LL_ASSERT(lll_tx);
 100b0e2:	eb19 0e02 	adds.w	lr, r9, r2
 100b0e6:	d02a      	beq.n	100b13e <tx_lll_flush+0xae>
		lll_tx->node = tx;
 100b0e8:	f8dd c004 	ldr.w	ip, [sp, #4]
		lll_tx->handle = 0xFFFF;
 100b0ec:	f829 7002 	strh.w	r7, [r9, r2]
		link->next = tx->next; /* Indicates ctrl pool or data pool */
 100b0f0:	f8dc 1000 	ldr.w	r1, [ip]
		link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
 100b0f4:	aa01      	add	r2, sp, #4
		lll_tx->node = tx;
 100b0f6:	f8ce c004 	str.w	ip, [lr, #4]
		link->next = tx->next; /* Indicates ctrl pool or data pool */
 100b0fa:	6001      	str	r1, [r0, #0]
		tx->next = link;
 100b0fc:	f8cc 0000 	str.w	r0, [ip]
		link = memq_dequeue(lll->memq_tx.tail, &lll->memq_tx.head,
 100b100:	4631      	mov	r1, r6
 100b102:	6d28      	ldr	r0, [r5, #80]	; 0x50
	*last = idx; /* Commit: Update write index */
 100b104:	70e3      	strb	r3, [r4, #3]
 100b106:	f7fa fdff 	bl	1005d08 <memq_dequeue>
	while (link) {
 100b10a:	2800      	cmp	r0, #0
 100b10c:	d1dc      	bne.n	100b0c8 <tx_lll_flush+0x38>
	LL_ASSERT(rx->hdr.link);
 100b10e:	f8d8 012c 	ldr.w	r0, [r8, #300]	; 0x12c
	rx = (void *)&conn->llcp_terminate.node_rx;
 100b112:	f508 7496 	add.w	r4, r8, #300	; 0x12c
	LL_ASSERT(rx->hdr.link);
 100b116:	b150      	cbz	r0, 100b12e <tx_lll_flush+0x9e>
	rx->hdr.link = NULL;
 100b118:	2300      	movs	r3, #0
	ull_rx_put(link, rx);
 100b11a:	4621      	mov	r1, r4
	rx->hdr.link = NULL;
 100b11c:	f8c8 312c 	str.w	r3, [r8, #300]	; 0x12c
	ull_rx_put(link, rx);
 100b120:	f7ff f896 	bl	100a250 <ull_rx_put>
	ull_rx_sched();
 100b124:	f7ff f8a4 	bl	100a270 <ull_rx_sched>
}
 100b128:	b003      	add	sp, #12
 100b12a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	LL_ASSERT(rx->hdr.link);
 100b12e:	480a      	ldr	r0, [pc, #40]	; (100b158 <tx_lll_flush+0xc8>)
 100b130:	f240 710f 	movw	r1, #1807	; 0x70f
 100b134:	f7f8 fa28 	bl	1003588 <bt_ctlr_assert_handle>
 100b138:	f8d8 012c 	ldr.w	r0, [r8, #300]	; 0x12c
 100b13c:	e7ec      	b.n	100b118 <tx_lll_flush+0x88>
		LL_ASSERT(lll_tx);
 100b13e:	f240 61fb 	movw	r1, #1787	; 0x6fb
 100b142:	4805      	ldr	r0, [pc, #20]	; (100b158 <tx_lll_flush+0xc8>)
 100b144:	f7f8 fa20 	bl	1003588 <bt_ctlr_assert_handle>
		lll_tx->handle = 0xFFFF;
 100b148:	2300      	movs	r3, #0
 100b14a:	801b      	strh	r3, [r3, #0]
 100b14c:	deff      	udf	#255	; 0xff
 100b14e:	bf00      	nop
 100b150:	21001b40 	.word	0x21001b40
 100b154:	210002f4 	.word	0x210002f4
 100b158:	010187e4 	.word	0x010187e4

0100b15c <ticker_op_stop_cb>:
{
 100b15c:	b510      	push	{r4, lr}
 100b15e:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 100b160:	b940      	cbnz	r0, 100b174 <ticker_op_stop_cb+0x18>
	retval = mayfly_enqueue(TICKER_USER_ID_ULL_LOW, TICKER_USER_ID_LLL, 0,
 100b162:	2200      	movs	r2, #0
	mfy.param = param;
 100b164:	4b0a      	ldr	r3, [pc, #40]	; (100b190 <ticker_op_stop_cb+0x34>)
	retval = mayfly_enqueue(TICKER_USER_ID_ULL_LOW, TICKER_USER_ID_LLL, 0,
 100b166:	4611      	mov	r1, r2
 100b168:	2002      	movs	r0, #2
	mfy.param = param;
 100b16a:	609c      	str	r4, [r3, #8]
	retval = mayfly_enqueue(TICKER_USER_ID_ULL_LOW, TICKER_USER_ID_LLL, 0,
 100b16c:	f7fa fe30 	bl	1005dd0 <mayfly_enqueue>
	LL_ASSERT(!retval);
 100b170:	b930      	cbnz	r0, 100b180 <ticker_op_stop_cb+0x24>
}
 100b172:	bd10      	pop	{r4, pc}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 100b174:	f240 6181 	movw	r1, #1665	; 0x681
 100b178:	4806      	ldr	r0, [pc, #24]	; (100b194 <ticker_op_stop_cb+0x38>)
 100b17a:	f7f8 fa05 	bl	1003588 <bt_ctlr_assert_handle>
 100b17e:	e7f0      	b.n	100b162 <ticker_op_stop_cb+0x6>
	LL_ASSERT(!retval);
 100b180:	f44f 61d1 	mov.w	r1, #1672	; 0x688
}
 100b184:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LL_ASSERT(!retval);
 100b188:	4802      	ldr	r0, [pc, #8]	; (100b194 <ticker_op_stop_cb+0x38>)
 100b18a:	f7f8 b9fd 	b.w	1003588 <bt_ctlr_assert_handle>
 100b18e:	bf00      	nop
 100b190:	2100039c 	.word	0x2100039c
 100b194:	010187e4 	.word	0x010187e4

0100b198 <ticker_start_conn_op_cb>:
{
 100b198:	b510      	push	{r4, lr}
 100b19a:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 100b19c:	b960      	cbnz	r0, 100b1b8 <ticker_start_conn_op_cb+0x20>
	void *p = ull_update_unmark(param);
 100b19e:	4620      	mov	r0, r4
 100b1a0:	f7fe ffda 	bl	100a158 <ull_update_unmark>
	LL_ASSERT(p == param);
 100b1a4:	4284      	cmp	r4, r0
 100b1a6:	d006      	beq.n	100b1b6 <ticker_start_conn_op_cb+0x1e>
}
 100b1a8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LL_ASSERT(p == param);
 100b1ac:	f44f 61cf 	mov.w	r1, #1656	; 0x678
 100b1b0:	4804      	ldr	r0, [pc, #16]	; (100b1c4 <ticker_start_conn_op_cb+0x2c>)
 100b1b2:	f7f8 b9e9 	b.w	1003588 <bt_ctlr_assert_handle>
}
 100b1b6:	bd10      	pop	{r4, pc}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 100b1b8:	f240 6174 	movw	r1, #1652	; 0x674
 100b1bc:	4801      	ldr	r0, [pc, #4]	; (100b1c4 <ticker_start_conn_op_cb+0x2c>)
 100b1be:	f7f8 f9e3 	bl	1003588 <bt_ctlr_assert_handle>
 100b1c2:	e7ec      	b.n	100b19e <ticker_start_conn_op_cb+0x6>
 100b1c4:	010187e4 	.word	0x010187e4

0100b1c8 <ticker_stop_conn_op_cb>:
{
 100b1c8:	b510      	push	{r4, lr}
 100b1ca:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 100b1cc:	b960      	cbnz	r0, 100b1e8 <ticker_stop_conn_op_cb+0x20>
	void *p = ull_update_mark(param);
 100b1ce:	4620      	mov	r0, r4
 100b1d0:	f7fe ffb8 	bl	100a144 <ull_update_mark>
	LL_ASSERT(p == param);
 100b1d4:	4284      	cmp	r4, r0
 100b1d6:	d006      	beq.n	100b1e6 <ticker_stop_conn_op_cb+0x1e>
}
 100b1d8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LL_ASSERT(p == param);
 100b1dc:	f240 616f 	movw	r1, #1647	; 0x66f
 100b1e0:	4804      	ldr	r0, [pc, #16]	; (100b1f4 <ticker_stop_conn_op_cb+0x2c>)
 100b1e2:	f7f8 b9d1 	b.w	1003588 <bt_ctlr_assert_handle>
}
 100b1e6:	bd10      	pop	{r4, pc}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 100b1e8:	f240 616b 	movw	r1, #1643	; 0x66b
 100b1ec:	4801      	ldr	r0, [pc, #4]	; (100b1f4 <ticker_stop_conn_op_cb+0x2c>)
 100b1ee:	f7f8 f9cb 	bl	1003588 <bt_ctlr_assert_handle>
 100b1f2:	e7ec      	b.n	100b1ce <ticker_stop_conn_op_cb+0x6>
 100b1f4:	010187e4 	.word	0x010187e4

0100b1f8 <ticker_update_conn_op_cb>:
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
 100b1f8:	b900      	cbnz	r0, 100b1fc <ticker_update_conn_op_cb+0x4>
 100b1fa:	4770      	bx	lr
{
 100b1fc:	b510      	push	{r4, lr}
 100b1fe:	460c      	mov	r4, r1
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
 100b200:	f7fe ffb8 	bl	100a174 <ull_update_mark_get>
 100b204:	4284      	cmp	r4, r0
 100b206:	d00a      	beq.n	100b21e <ticker_update_conn_op_cb+0x26>
 100b208:	f7fe ff96 	bl	100a138 <ull_disable_mark_get>
 100b20c:	4284      	cmp	r4, r0
 100b20e:	d006      	beq.n	100b21e <ticker_update_conn_op_cb+0x26>
}
 100b210:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LL_ASSERT(status == TICKER_STATUS_SUCCESS ||
 100b214:	f240 6164 	movw	r1, #1636	; 0x664
 100b218:	4801      	ldr	r0, [pc, #4]	; (100b220 <ticker_update_conn_op_cb+0x28>)
 100b21a:	f7f8 b9b5 	b.w	1003588 <bt_ctlr_assert_handle>
}
 100b21e:	bd10      	pop	{r4, pc}
 100b220:	010187e4 	.word	0x010187e4

0100b224 <reject_ext_ind_send.isra.0>:

	return 0;
}

#if defined(CONFIG_BT_CTLR_CONN_PARAM_REQ) || defined(CONFIG_BT_CTLR_PHY)
static int reject_ext_ind_send(struct ll_conn *conn, struct node_rx_pdu *rx,
 100b224:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100b228:	4605      	mov	r5, r0
{
	struct pdu_data *pdu_ctrl_tx;
	struct node_tx *tx;

	/* acquire tx mem */
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100b22a:	4827      	ldr	r0, [pc, #156]	; (100b2c8 <reject_ext_ind_send.isra.0+0xa4>)
static int reject_ext_ind_send(struct ll_conn *conn, struct node_rx_pdu *rx,
 100b22c:	460e      	mov	r6, r1
 100b22e:	4690      	mov	r8, r2
 100b230:	461f      	mov	r7, r3
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100b232:	f7fa fcf5 	bl	1005c20 <mem_acquire>
	if (!tx) {
 100b236:	2800      	cmp	r0, #0
 100b238:	d042      	beq.n	100b2c0 <reject_ext_ind_send.isra.0+0x9c>
		return -ENOBUFS;
	}

	pdu_ctrl_tx = (void *)tx->pdu;
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
 100b23a:	2303      	movs	r3, #3
		sizeof(struct pdu_data_llctrl_reject_ext_ind);
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
 100b23c:	2111      	movs	r1, #17
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b23e:	7904      	ldrb	r4, [r0, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, reject_ext_ind) +
 100b240:	7143      	strb	r3, [r0, #5]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b242:	ea44 0203 	orr.w	r2, r4, r3
	    conn->tx_head &&
 100b246:	f8d5 31b0 	ldr.w	r3, [r5, #432]	; 0x1b0
	pdu_ctrl_tx->llctrl.reject_ext_ind.reject_opcode = reject_opcode;
 100b24a:	f880 8008 	strb.w	r8, [r0, #8]
	pdu_ctrl_tx->llctrl.reject_ext_ind.error_code = error_code;
 100b24e:	7247      	strb	r7, [r0, #9]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b250:	7102      	strb	r2, [r0, #4]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND;
 100b252:	71c1      	strb	r1, [r0, #7]
	if (
 100b254:	b11b      	cbz	r3, 100b25e <reject_ext_ind_send.isra.0+0x3a>
	    !conn->llcp_enc.pause_tx &&
 100b256:	f895 2152 	ldrb.w	r2, [r5, #338]	; 0x152
	    conn->tx_head &&
 100b25a:	0791      	lsls	r1, r2, #30
 100b25c:	d510      	bpl.n	100b280 <reject_ext_ind_send.isra.0+0x5c>
		if (!conn->tx_ctrl) {
 100b25e:	f8d5 21b4 	ldr.w	r2, [r5, #436]	; 0x1b4
 100b262:	b33a      	cbz	r2, 100b2b4 <reject_ext_ind_send.isra.0+0x90>
	tx->next = conn->tx_ctrl_last->next;
 100b264:	f8d5 31b8 	ldr.w	r3, [r5, #440]	; 0x1b8
 100b268:	681a      	ldr	r2, [r3, #0]
 100b26a:	6002      	str	r2, [r0, #0]
	conn->tx_ctrl_last->next = tx;
 100b26c:	6018      	str	r0, [r3, #0]
	conn->tx_ctrl_last = tx;
 100b26e:	f8c5 01b8 	str.w	r0, [r5, #440]	; 0x1b8
 100b272:	6803      	ldr	r3, [r0, #0]
	if (!tx->next) {
 100b274:	b1db      	cbz	r3, 100b2ae <reject_ext_ind_send.isra.0+0x8a>

	ctrl_tx_enqueue(conn, tx);

	/* Mark for buffer for release */
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100b276:	2303      	movs	r3, #3

	return 0;
 100b278:	2000      	movs	r0, #0
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100b27a:	7033      	strb	r3, [r6, #0]
}
 100b27c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	    !conn->llcp_phy.pause_tx &&
 100b280:	f895 21ab 	ldrb.w	r2, [r5, #427]	; 0x1ab
 100b284:	07d2      	lsls	r2, r2, #31
 100b286:	d4ea      	bmi.n	100b25e <reject_ext_ind_send.isra.0+0x3a>
		if (conn->tx_head == conn->tx_data) {
 100b288:	f8d5 21bc 	ldr.w	r2, [r5, #444]	; 0x1bc
 100b28c:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 100b28e:	bf04      	itt	eq
 100b290:	681a      	ldreq	r2, [r3, #0]
 100b292:	f8c5 21bc 	streq.w	r2, [r5, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 100b296:	f8d5 21b4 	ldr.w	r2, [r5, #436]	; 0x1b4
 100b29a:	2a00      	cmp	r2, #0
 100b29c:	d1e2      	bne.n	100b264 <reject_ext_ind_send.isra.0+0x40>
			tx->next = conn->tx_head->next;
 100b29e:	681a      	ldr	r2, [r3, #0]
 100b2a0:	6002      	str	r2, [r0, #0]
			conn->tx_head->next = tx;
 100b2a2:	6018      	str	r0, [r3, #0]
				conn->tx_ctrl = tx;
 100b2a4:	6803      	ldr	r3, [r0, #0]
				conn->tx_ctrl_last = tx;
 100b2a6:	e9c5 006d 	strd	r0, r0, [r5, #436]	; 0x1b4
	if (!tx->next) {
 100b2aa:	2b00      	cmp	r3, #0
 100b2ac:	d1e3      	bne.n	100b276 <reject_ext_ind_send.isra.0+0x52>
		conn->tx_data_last = tx;
 100b2ae:	f8c5 01c0 	str.w	r0, [r5, #448]	; 0x1c0
 100b2b2:	e7e0      	b.n	100b276 <reject_ext_ind_send.isra.0+0x52>
			tx->next = conn->tx_head;
 100b2b4:	6003      	str	r3, [r0, #0]
				conn->tx_ctrl = tx;
 100b2b6:	e9c5 006c 	strd	r0, r0, [r5, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 100b2ba:	f8c5 01b8 	str.w	r0, [r5, #440]	; 0x1b8
 100b2be:	e7d9      	b.n	100b274 <reject_ext_ind_send.isra.0+0x50>
		return -ENOBUFS;
 100b2c0:	f06f 0036 	mvn.w	r0, #54	; 0x36
 100b2c4:	e7da      	b.n	100b27c <reject_ext_ind_send.isra.0+0x58>
 100b2c6:	bf00      	nop
 100b2c8:	210038cc 	.word	0x210038cc

0100b2cc <start_enc_rsp_send>:
{
 100b2cc:	b570      	push	{r4, r5, r6, lr}
 100b2ce:	4604      	mov	r4, r0
	if (!pdu_ctrl_tx) {
 100b2d0:	b179      	cbz	r1, 100b2f2 <start_enc_rsp_send+0x26>
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
 100b2d2:	2601      	movs	r6, #1
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_START_ENC_RSP;
 100b2d4:	2506      	movs	r5, #6
	conn->lll.enc_tx = 1;
 100b2d6:	f890 207e 	ldrb.w	r2, [r0, #126]	; 0x7e
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b2da:	780b      	ldrb	r3, [r1, #0]
	conn->lll.enc_tx = 1;
 100b2dc:	f042 0210 	orr.w	r2, r2, #16
 100b2e0:	f880 207e 	strb.w	r2, [r0, #126]	; 0x7e
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b2e4:	f043 0303 	orr.w	r3, r3, #3
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
 100b2e8:	704e      	strb	r6, [r1, #1]
	return 0;
 100b2ea:	2000      	movs	r0, #0
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b2ec:	700b      	strb	r3, [r1, #0]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_START_ENC_RSP;
 100b2ee:	70cd      	strb	r5, [r1, #3]
}
 100b2f0:	bd70      	pop	{r4, r5, r6, pc}
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100b2f2:	4826      	ldr	r0, [pc, #152]	; (100b38c <start_enc_rsp_send+0xc0>)
 100b2f4:	f7fa fc94 	bl	1005c20 <mem_acquire>
		if (!tx) {
 100b2f8:	2800      	cmp	r0, #0
 100b2fa:	d043      	beq.n	100b384 <start_enc_rsp_send+0xb8>
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
 100b2fc:	2501      	movs	r5, #1
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_START_ENC_RSP;
 100b2fe:	2106      	movs	r1, #6
	conn->lll.enc_tx = 1;
 100b300:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b304:	7902      	ldrb	r2, [r0, #4]
	conn->lll.enc_tx = 1;
 100b306:	f043 0310 	orr.w	r3, r3, #16
 100b30a:	f884 307e 	strb.w	r3, [r4, #126]	; 0x7e
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
 100b30e:	7145      	strb	r5, [r0, #5]
	    conn->tx_head &&
 100b310:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b314:	f042 0203 	orr.w	r2, r2, #3
 100b318:	7102      	strb	r2, [r0, #4]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_START_ENC_RSP;
 100b31a:	71c1      	strb	r1, [r0, #7]
	if (
 100b31c:	b1e3      	cbz	r3, 100b358 <start_enc_rsp_send+0x8c>
	    !conn->llcp_enc.pause_tx &&
 100b31e:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
	    conn->tx_head &&
 100b322:	0791      	lsls	r1, r2, #30
 100b324:	d418      	bmi.n	100b358 <start_enc_rsp_send+0x8c>
	    !conn->llcp_phy.pause_tx &&
 100b326:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
 100b32a:	07d2      	lsls	r2, r2, #31
 100b32c:	d414      	bmi.n	100b358 <start_enc_rsp_send+0x8c>
		if (conn->tx_head == conn->tx_data) {
 100b32e:	f8d4 21bc 	ldr.w	r2, [r4, #444]	; 0x1bc
 100b332:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 100b334:	bf04      	itt	eq
 100b336:	681a      	ldreq	r2, [r3, #0]
 100b338:	f8c4 21bc 	streq.w	r2, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 100b33c:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 100b340:	b1ca      	cbz	r2, 100b376 <start_enc_rsp_send+0xaa>
	tx->next = conn->tx_ctrl_last->next;
 100b342:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 100b346:	681a      	ldr	r2, [r3, #0]
 100b348:	6002      	str	r2, [r0, #0]
	conn->tx_ctrl_last->next = tx;
 100b34a:	6018      	str	r0, [r3, #0]
	conn->tx_ctrl_last = tx;
 100b34c:	f8c4 01b8 	str.w	r0, [r4, #440]	; 0x1b8
 100b350:	6803      	ldr	r3, [r0, #0]
	if (!tx->next) {
 100b352:	b163      	cbz	r3, 100b36e <start_enc_rsp_send+0xa2>
	return 0;
 100b354:	2000      	movs	r0, #0
}
 100b356:	bd70      	pop	{r4, r5, r6, pc}
		if (!conn->tx_ctrl) {
 100b358:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 100b35c:	2a00      	cmp	r2, #0
 100b35e:	d1f0      	bne.n	100b342 <start_enc_rsp_send+0x76>
			tx->next = conn->tx_head;
 100b360:	6003      	str	r3, [r0, #0]
				conn->tx_ctrl = tx;
 100b362:	e9c4 006c 	strd	r0, r0, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 100b366:	f8c4 01b8 	str.w	r0, [r4, #440]	; 0x1b8
	if (!tx->next) {
 100b36a:	2b00      	cmp	r3, #0
 100b36c:	d1f2      	bne.n	100b354 <start_enc_rsp_send+0x88>
		conn->tx_data_last = tx;
 100b36e:	f8c4 01c0 	str.w	r0, [r4, #448]	; 0x1c0
	return 0;
 100b372:	4618      	mov	r0, r3
}
 100b374:	bd70      	pop	{r4, r5, r6, pc}
			tx->next = conn->tx_head->next;
 100b376:	681a      	ldr	r2, [r3, #0]
 100b378:	6002      	str	r2, [r0, #0]
			conn->tx_head->next = tx;
 100b37a:	6018      	str	r0, [r3, #0]
				conn->tx_ctrl = tx;
 100b37c:	6803      	ldr	r3, [r0, #0]
				conn->tx_ctrl_last = tx;
 100b37e:	e9c4 006d 	strd	r0, r0, [r4, #436]	; 0x1b4
 100b382:	e7e6      	b.n	100b352 <start_enc_rsp_send+0x86>
			return -ENOBUFS;
 100b384:	f06f 0036 	mvn.w	r0, #54	; 0x36
}
 100b388:	bd70      	pop	{r4, r5, r6, pc}
 100b38a:	bf00      	nop
 100b38c:	210038cc 	.word	0x210038cc

0100b390 <ctrl_tx_sec_enqueue>:
{
 100b390:	b538      	push	{r3, r4, r5, lr}
	if (conn->llcp_enc.pause_tx) {
 100b392:	f890 3152 	ldrb.w	r3, [r0, #338]	; 0x152
{
 100b396:	4604      	mov	r4, r0
	if (conn->llcp_enc.pause_tx) {
 100b398:	079a      	lsls	r2, r3, #30
{
 100b39a:	460d      	mov	r5, r1
	if (conn->llcp_enc.pause_tx) {
 100b39c:	d50b      	bpl.n	100b3b6 <ctrl_tx_sec_enqueue+0x26>
		if (!conn->tx_ctrl) {
 100b39e:	f8d0 31b4 	ldr.w	r3, [r0, #436]	; 0x1b4
 100b3a2:	2b00      	cmp	r3, #0
 100b3a4:	d045      	beq.n	100b432 <ctrl_tx_sec_enqueue+0xa2>
			tx->next = conn->tx_ctrl_last->next;
 100b3a6:	f8d0 31b8 	ldr.w	r3, [r0, #440]	; 0x1b8
 100b3aa:	681a      	ldr	r2, [r3, #0]
 100b3ac:	600a      	str	r2, [r1, #0]
			conn->tx_ctrl_last->next = tx;
 100b3ae:	6019      	str	r1, [r3, #0]
		if (!tx->next) {
 100b3b0:	682b      	ldr	r3, [r5, #0]
 100b3b2:	b363      	cbz	r3, 100b40e <ctrl_tx_sec_enqueue+0x7e>
}
 100b3b4:	bd38      	pop	{r3, r4, r5, pc}
		if (conn->tx_head) {
 100b3b6:	f8d0 21b0 	ldr.w	r2, [r0, #432]	; 0x1b0
 100b3ba:	b302      	cbz	r2, 100b3fe <ctrl_tx_sec_enqueue+0x6e>
			if ((conn->llcp_req != conn->llcp_ack) &&
 100b3bc:	f890 10e8 	ldrb.w	r1, [r0, #232]	; 0xe8
 100b3c0:	f890 30e9 	ldrb.w	r3, [r0, #233]	; 0xe9
 100b3c4:	4299      	cmp	r1, r3
 100b3c6:	d003      	beq.n	100b3d0 <ctrl_tx_sec_enqueue+0x40>
 100b3c8:	f890 30ea 	ldrb.w	r3, [r0, #234]	; 0xea
 100b3cc:	2b03      	cmp	r3, #3
 100b3ce:	d038      	beq.n	100b442 <ctrl_tx_sec_enqueue+0xb2>
	    !conn->llcp_phy.pause_tx &&
 100b3d0:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
 100b3d4:	f013 0301 	ands.w	r3, r3, #1
 100b3d8:	d11c      	bne.n	100b414 <ctrl_tx_sec_enqueue+0x84>
		if (conn->tx_head == conn->tx_data) {
 100b3da:	f8d4 11bc 	ldr.w	r1, [r4, #444]	; 0x1bc
 100b3de:	428a      	cmp	r2, r1
			conn->tx_data = conn->tx_data->next;
 100b3e0:	bf04      	itt	eq
 100b3e2:	6811      	ldreq	r1, [r2, #0]
 100b3e4:	f8c4 11bc 	streq.w	r1, [r4, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 100b3e8:	f8d4 11b4 	ldr.w	r1, [r4, #436]	; 0x1b4
 100b3ec:	2900      	cmp	r1, #0
 100b3ee:	d043      	beq.n	100b478 <ctrl_tx_sec_enqueue+0xe8>
			LL_ASSERT(!pause);
 100b3f0:	b1a3      	cbz	r3, 100b41c <ctrl_tx_sec_enqueue+0x8c>
 100b3f2:	f240 716a 	movw	r1, #1898	; 0x76a
 100b3f6:	482a      	ldr	r0, [pc, #168]	; (100b4a0 <ctrl_tx_sec_enqueue+0x110>)
 100b3f8:	f7f8 f8c6 	bl	1003588 <bt_ctlr_assert_handle>
	tx->next = conn->tx_ctrl_last->next;
 100b3fc:	e00e      	b.n	100b41c <ctrl_tx_sec_enqueue+0x8c>
		if (!conn->tx_ctrl) {
 100b3fe:	f8d0 31b4 	ldr.w	r3, [r0, #436]	; 0x1b4
 100b402:	b95b      	cbnz	r3, 100b41c <ctrl_tx_sec_enqueue+0x8c>
			tx->next = conn->tx_head;
 100b404:	600b      	str	r3, [r1, #0]
				conn->tx_ctrl = tx;
 100b406:	e9c0 116c 	strd	r1, r1, [r0, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 100b40a:	f8c4 11b8 	str.w	r1, [r4, #440]	; 0x1b8
			conn->tx_data_last = tx;
 100b40e:	f8c4 51c0 	str.w	r5, [r4, #448]	; 0x1c0
}
 100b412:	bd38      	pop	{r3, r4, r5, pc}
		if (!conn->tx_ctrl) {
 100b414:	f8d4 31b4 	ldr.w	r3, [r4, #436]	; 0x1b4
 100b418:	2b00      	cmp	r3, #0
 100b41a:	d038      	beq.n	100b48e <ctrl_tx_sec_enqueue+0xfe>
	tx->next = conn->tx_ctrl_last->next;
 100b41c:	f8d4 31b8 	ldr.w	r3, [r4, #440]	; 0x1b8
 100b420:	681a      	ldr	r2, [r3, #0]
 100b422:	602a      	str	r2, [r5, #0]
	conn->tx_ctrl_last->next = tx;
 100b424:	601d      	str	r5, [r3, #0]
	conn->tx_ctrl_last = tx;
 100b426:	f8c4 51b8 	str.w	r5, [r4, #440]	; 0x1b8
 100b42a:	682b      	ldr	r3, [r5, #0]
		if (!tx->next) {
 100b42c:	2b00      	cmp	r3, #0
 100b42e:	d1c1      	bne.n	100b3b4 <ctrl_tx_sec_enqueue+0x24>
 100b430:	e7ed      	b.n	100b40e <ctrl_tx_sec_enqueue+0x7e>
			tx->next = conn->tx_head;
 100b432:	f8d0 31b0 	ldr.w	r3, [r0, #432]	; 0x1b0
 100b436:	600b      	str	r3, [r1, #0]
			conn->tx_head = tx;
 100b438:	f8c4 11b0 	str.w	r1, [r4, #432]	; 0x1b0
		if (!tx->next) {
 100b43c:	2b00      	cmp	r3, #0
 100b43e:	d1b9      	bne.n	100b3b4 <ctrl_tx_sec_enqueue+0x24>
 100b440:	e7e5      	b.n	100b40e <ctrl_tx_sec_enqueue+0x7e>
			    (pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
 100b442:	7913      	ldrb	r3, [r2, #4]
			    (conn->llcp_type == LLCP_ENCRYPTION) &&
 100b444:	f003 0303 	and.w	r3, r3, #3
 100b448:	2b03      	cmp	r3, #3
 100b44a:	d1c1      	bne.n	100b3d0 <ctrl_tx_sec_enqueue+0x40>
			    ((pdu_data_tx->llctrl.opcode ==
 100b44c:	79d3      	ldrb	r3, [r2, #7]
			    (pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
 100b44e:	2b03      	cmp	r3, #3
 100b450:	d001      	beq.n	100b456 <ctrl_tx_sec_enqueue+0xc6>
			      PDU_DATA_LLCTRL_TYPE_ENC_REQ) ||
 100b452:	2b0a      	cmp	r3, #10
 100b454:	d1bc      	bne.n	100b3d0 <ctrl_tx_sec_enqueue+0x40>
	    !conn->llcp_phy.pause_tx &&
 100b456:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
 100b45a:	07db      	lsls	r3, r3, #31
 100b45c:	d51d      	bpl.n	100b49a <ctrl_tx_sec_enqueue+0x10a>
		if (!conn->tx_ctrl) {
 100b45e:	f8d4 31b4 	ldr.w	r3, [r4, #436]	; 0x1b4
 100b462:	b12b      	cbz	r3, 100b470 <ctrl_tx_sec_enqueue+0xe0>
			LL_ASSERT(!pause);
 100b464:	f240 717c 	movw	r1, #1916	; 0x77c
 100b468:	480d      	ldr	r0, [pc, #52]	; (100b4a0 <ctrl_tx_sec_enqueue+0x110>)
 100b46a:	f7f8 f88d 	bl	1003588 <bt_ctlr_assert_handle>
 100b46e:	e7d5      	b.n	100b41c <ctrl_tx_sec_enqueue+0x8c>
			tx->next = conn->tx_head;
 100b470:	602a      	str	r2, [r5, #0]
			conn->tx_head = tx;
 100b472:	f8c4 51b0 	str.w	r5, [r4, #432]	; 0x1b0
}
 100b476:	bd38      	pop	{r3, r4, r5, pc}
			tx->next = conn->tx_head->next;
 100b478:	6811      	ldr	r1, [r2, #0]
 100b47a:	6029      	str	r1, [r5, #0]
			conn->tx_head->next = tx;
 100b47c:	6015      	str	r5, [r2, #0]
			if (!pause) {
 100b47e:	2b00      	cmp	r3, #0
 100b480:	d196      	bne.n	100b3b0 <ctrl_tx_sec_enqueue+0x20>
				conn->tx_ctrl_last = tx;
 100b482:	e9c4 556d 	strd	r5, r5, [r4, #436]	; 0x1b4
 100b486:	682b      	ldr	r3, [r5, #0]
		if (!tx->next) {
 100b488:	2b00      	cmp	r3, #0
 100b48a:	d193      	bne.n	100b3b4 <ctrl_tx_sec_enqueue+0x24>
 100b48c:	e7bf      	b.n	100b40e <ctrl_tx_sec_enqueue+0x7e>
			tx->next = conn->tx_head;
 100b48e:	602a      	str	r2, [r5, #0]
				conn->tx_ctrl = tx;
 100b490:	e9c4 556c 	strd	r5, r5, [r4, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 100b494:	f8c4 51b8 	str.w	r5, [r4, #440]	; 0x1b8
}
 100b498:	bd38      	pop	{r3, r4, r5, pc}
				pause = true;
 100b49a:	2301      	movs	r3, #1
 100b49c:	e79d      	b.n	100b3da <ctrl_tx_sec_enqueue+0x4a>
 100b49e:	bf00      	nop
 100b4a0:	010187e4 	.word	0x010187e4

0100b4a4 <feature_rsp_send.isra.0>:
static int feature_rsp_send(struct ll_conn *conn, struct node_rx_pdu *rx,
 100b4a4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 100b4a6:	4606      	mov	r6, r0
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100b4a8:	481d      	ldr	r0, [pc, #116]	; (100b520 <feature_rsp_send.isra.0+0x7c>)
static int feature_rsp_send(struct ll_conn *conn, struct node_rx_pdu *rx,
 100b4aa:	460d      	mov	r5, r1
 100b4ac:	4617      	mov	r7, r2
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100b4ae:	f7fa fbb7 	bl	1005c20 <mem_acquire>
	if (!tx) {
 100b4b2:	b390      	cbz	r0, 100b51a <feature_rsp_send.isra.0+0x76>
	return feat;
 100b4b4:	4604      	mov	r4, r0
	       (features[1] << 8) | (features[2] << 16);
 100b4b6:	79bb      	ldrb	r3, [r7, #6]
 100b4b8:	797a      	ldrb	r2, [r7, #5]
	feat = ~LL_FEAT_BIT_MASK_VALID | features[0] |
 100b4ba:	7939      	ldrb	r1, [r7, #4]
	       (features[1] << 8) | (features[2] << 16);
 100b4bc:	041b      	lsls	r3, r3, #16
 100b4be:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 100b4c2:	4a18      	ldr	r2, [pc, #96]	; (100b524 <feature_rsp_send.isra.0+0x80>)
 100b4c4:	430b      	orrs	r3, r1
 100b4c6:	4313      	orrs	r3, r2
	conn->common.fex_valid = 1U;
 100b4c8:	f896 20dc 	ldrb.w	r2, [r6, #220]	; 0xdc
	conn->llcp_feature.features &= feat_get(&req->features[0]);
 100b4cc:	f8d6 111c 	ldr.w	r1, [r6, #284]	; 0x11c
	conn->common.fex_valid = 1U;
 100b4d0:	f042 0201 	orr.w	r2, r2, #1
	pdu_tx->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
 100b4d4:	2009      	movs	r0, #9
	conn->llcp_feature.features &= feat_get(&req->features[0]);
 100b4d6:	400b      	ands	r3, r1
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b4d8:	7921      	ldrb	r1, [r4, #4]
	conn->common.fex_valid = 1U;
 100b4da:	f886 20dc 	strb.w	r2, [r6, #220]	; 0xdc
	(void)memset(&pdu_tx->llctrl.feature_rsp.features[0], 0x00,
 100b4de:	2208      	movs	r2, #8
	conn->llcp_feature.features &= feat_get(&req->features[0]);
 100b4e0:	f3c3 0310 	ubfx	r3, r3, #0, #17
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b4e4:	f041 0103 	orr.w	r1, r1, #3
	conn->llcp_feature.features &= feat_get(&req->features[0]);
 100b4e8:	f8c6 311c 	str.w	r3, [r6, #284]	; 0x11c
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100b4ec:	7121      	strb	r1, [r4, #4]
	pdu_tx->len = offsetof(struct pdu_data_llctrl, feature_rsp) +
 100b4ee:	7160      	strb	r0, [r4, #5]
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_FEATURE_RSP;
 100b4f0:	71e0      	strb	r0, [r4, #7]
	(void)memset(&pdu_tx->llctrl.feature_rsp.features[0], 0x00,
 100b4f2:	2100      	movs	r1, #0
 100b4f4:	18a0      	adds	r0, r4, r2
 100b4f6:	f00b fa0a 	bl	101690e <memset>
	sys_put_le24(conn->llcp_feature.features,
 100b4fa:	f8d6 311c 	ldr.w	r3, [r6, #284]	; 0x11c
	ctrl_tx_sec_enqueue(conn, tx);
 100b4fe:	4630      	mov	r0, r6
	dst[1] = val >> 8;
 100b500:	f3c3 2107 	ubfx	r1, r3, #8, #8
	dst[2] = val >> 16;
 100b504:	0c1a      	lsrs	r2, r3, #16
	dst[0] = val;
 100b506:	7223      	strb	r3, [r4, #8]
	dst[1] = val >> 8;
 100b508:	7261      	strb	r1, [r4, #9]
	dst[2] = val >> 16;
 100b50a:	72a2      	strb	r2, [r4, #10]
 100b50c:	4621      	mov	r1, r4
 100b50e:	f7ff ff3f 	bl	100b390 <ctrl_tx_sec_enqueue>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100b512:	2303      	movs	r3, #3
 100b514:	702b      	strb	r3, [r5, #0]
	return 0;
 100b516:	2000      	movs	r0, #0
}
 100b518:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return -ENOBUFS;
 100b51a:	f06f 0036 	mvn.w	r0, #54	; 0x36
}
 100b51e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 100b520:	210038cc 	.word	0x210038cc
 100b524:	fffe30d0 	.word	0xfffe30d0

0100b528 <ll_conn_acquire>:
	return mem_acquire(&conn_free);
 100b528:	4801      	ldr	r0, [pc, #4]	; (100b530 <ll_conn_acquire+0x8>)
 100b52a:	f7fa bb79 	b.w	1005c20 <mem_acquire>
 100b52e:	bf00      	nop
 100b530:	21001b3c 	.word	0x21001b3c

0100b534 <ll_conn_release>:
	mem_release(conn, &conn_free);
 100b534:	4901      	ldr	r1, [pc, #4]	; (100b53c <ll_conn_release+0x8>)
 100b536:	f7fa bb8d 	b.w	1005c54 <mem_release>
 100b53a:	bf00      	nop
 100b53c:	21001b3c 	.word	0x21001b3c

0100b540 <ll_conn_handle_get>:
	return mem_index_get(conn, conn_pool, sizeof(struct ll_conn));
 100b540:	f44f 72e4 	mov.w	r2, #456	; 0x1c8
 100b544:	4901      	ldr	r1, [pc, #4]	; (100b54c <ll_conn_handle_get+0xc>)
 100b546:	f7fa bba1 	b.w	1005c8c <mem_index_get>
 100b54a:	bf00      	nop
 100b54c:	21001b40 	.word	0x21001b40

0100b550 <ll_conn_get>:
{
 100b550:	4602      	mov	r2, r0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b552:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100b556:	4801      	ldr	r0, [pc, #4]	; (100b55c <ll_conn_get+0xc>)
 100b558:	f7fa bb94 	b.w	1005c84 <mem_get>
 100b55c:	21001b40 	.word	0x21001b40

0100b560 <ll_connected_get>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100b560:	280f      	cmp	r0, #15
 100b562:	d80c      	bhi.n	100b57e <ll_connected_get+0x1e>
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b564:	4602      	mov	r2, r0
{
 100b566:	b510      	push	{r4, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b568:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100b56c:	4604      	mov	r4, r0
 100b56e:	4805      	ldr	r0, [pc, #20]	; (100b584 <ll_connected_get+0x24>)
 100b570:	f7fa fb88 	bl	1005c84 <mem_get>
	if (conn->lll.handle != handle) {
 100b574:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
 100b576:	42a3      	cmp	r3, r4
		return NULL;
 100b578:	bf18      	it	ne
 100b57a:	2000      	movne	r0, #0
}
 100b57c:	bd10      	pop	{r4, pc}
		return NULL;
 100b57e:	2000      	movs	r0, #0
}
 100b580:	4770      	bx	lr
 100b582:	bf00      	nop
 100b584:	21001b40 	.word	0x21001b40

0100b588 <ll_tx_mem_acquire>:
	return mem_acquire(&mem_conn_tx.free);
 100b588:	4801      	ldr	r0, [pc, #4]	; (100b590 <ll_tx_mem_acquire+0x8>)
 100b58a:	f7fa bb49 	b.w	1005c20 <mem_acquire>
 100b58e:	bf00      	nop
 100b590:	210037cc 	.word	0x210037cc

0100b594 <ll_tx_mem_release>:
	mem_release(tx, &mem_conn_tx.free);
 100b594:	4901      	ldr	r1, [pc, #4]	; (100b59c <ll_tx_mem_release+0x8>)
 100b596:	f7fa bb5d 	b.w	1005c54 <mem_release>
 100b59a:	bf00      	nop
 100b59c:	210037cc 	.word	0x210037cc

0100b5a0 <ll_tx_mem_enqueue>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100b5a0:	280f      	cmp	r0, #15
 100b5a2:	d852      	bhi.n	100b64a <ll_tx_mem_enqueue+0xaa>
{
 100b5a4:	b5f0      	push	{r4, r5, r6, r7, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b5a6:	4602      	mov	r2, r0
 100b5a8:	4604      	mov	r4, r0
 100b5aa:	460d      	mov	r5, r1
 100b5ac:	482a      	ldr	r0, [pc, #168]	; (100b658 <ll_tx_mem_enqueue+0xb8>)
 100b5ae:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
{
 100b5b2:	b089      	sub	sp, #36	; 0x24
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b5b4:	f7fa fb66 	bl	1005c84 <mem_get>
	if (conn->lll.handle != handle) {
 100b5b8:	8d86      	ldrh	r6, [r0, #44]	; 0x2c
 100b5ba:	42a6      	cmp	r6, r4
 100b5bc:	d11c      	bne.n	100b5f8 <ll_tx_mem_enqueue+0x58>
	idx = MFIFO_ENQUEUE_GET(conn_tx, (void **) &lll_tx);
 100b5be:	4927      	ldr	r1, [pc, #156]	; (100b65c <ll_tx_mem_enqueue+0xbc>)
 100b5c0:	78ca      	ldrb	r2, [r1, #3]
	if (last == count) {
 100b5c2:	784c      	ldrb	r4, [r1, #1]
	last = last + 1;
 100b5c4:	1c53      	adds	r3, r2, #1
 100b5c6:	b2db      	uxtb	r3, r3
		last = 0U;
 100b5c8:	429c      	cmp	r4, r3
 100b5ca:	bf08      	it	eq
 100b5cc:	2300      	moveq	r3, #0
 100b5ce:	788c      	ldrb	r4, [r1, #2]
	if (last == first) {
 100b5d0:	429c      	cmp	r4, r3
 100b5d2:	d03d      	beq.n	100b650 <ll_tx_mem_enqueue+0xb0>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
 100b5d4:	460c      	mov	r4, r1
 100b5d6:	f814 7b04 	ldrb.w	r7, [r4], #4
 100b5da:	fb02 f207 	mul.w	r2, r2, r7
	if (!lll_tx) {
 100b5de:	18a7      	adds	r7, r4, r2
 100b5e0:	d036      	beq.n	100b650 <ll_tx_mem_enqueue+0xb0>
	if (conn->lll.role && conn->lll.latency_event &&
 100b5e2:	f990 c03d 	ldrsb.w	ip, [r0, #61]	; 0x3d
	lll_tx->handle = handle;
 100b5e6:	52a6      	strh	r6, [r4, r2]
	if (conn->lll.role && conn->lll.latency_event &&
 100b5e8:	f1bc 0f00 	cmp.w	ip, #0
	lll_tx->node = tx;
 100b5ec:	607d      	str	r5, [r7, #4]
	*last = idx; /* Commit: Update write index */
 100b5ee:	70cb      	strb	r3, [r1, #3]
	if (conn->lll.role && conn->lll.latency_event &&
 100b5f0:	db06      	blt.n	100b600 <ll_tx_mem_enqueue+0x60>
	return 0;
 100b5f2:	2000      	movs	r0, #0
}
 100b5f4:	b009      	add	sp, #36	; 0x24
 100b5f6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -EINVAL;
 100b5f8:	f06f 0015 	mvn.w	r0, #21
}
 100b5fc:	b009      	add	sp, #36	; 0x24
 100b5fe:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (conn->lll.role && conn->lll.latency_event &&
 100b600:	8e83      	ldrh	r3, [r0, #52]	; 0x34
 100b602:	2b00      	cmp	r3, #0
 100b604:	d0f5      	beq.n	100b5f2 <ll_tx_mem_enqueue+0x52>
	    !conn->slave.latency_cancel) {
 100b606:	f890 30dc 	ldrb.w	r3, [r0, #220]	; 0xdc
	if (conn->lll.role && conn->lll.latency_event &&
 100b60a:	f013 0402 	ands.w	r4, r3, #2
 100b60e:	d1f0      	bne.n	100b5f2 <ll_tx_mem_enqueue+0x52>
			ticker_update(TICKER_INSTANCE_ID_CTLR,
 100b610:	2501      	movs	r5, #1
 100b612:	4913      	ldr	r1, [pc, #76]	; (100b660 <ll_tx_mem_enqueue+0xc0>)
		conn->slave.latency_cancel = 1U;
 100b614:	f043 0302 	orr.w	r3, r3, #2
				      (TICKER_ID_CONN_BASE + handle),
 100b618:	1d72      	adds	r2, r6, #5
		conn->slave.latency_cancel = 1U;
 100b61a:	f880 30dc 	strb.w	r3, [r0, #220]	; 0xdc
			ticker_update(TICKER_INSTANCE_ID_CTLR,
 100b61e:	b2d2      	uxtb	r2, r2
 100b620:	4623      	mov	r3, r4
 100b622:	9006      	str	r0, [sp, #24]
 100b624:	9105      	str	r1, [sp, #20]
 100b626:	4620      	mov	r0, r4
 100b628:	2103      	movs	r1, #3
 100b62a:	e9cd 4401 	strd	r4, r4, [sp, #4]
 100b62e:	9404      	str	r4, [sp, #16]
 100b630:	9400      	str	r4, [sp, #0]
 100b632:	9503      	str	r5, [sp, #12]
 100b634:	f7fb fdb4 	bl	10071a0 <ticker_update>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 100b638:	f030 0302 	bics.w	r3, r0, #2
 100b63c:	d0d9      	beq.n	100b5f2 <ll_tx_mem_enqueue+0x52>
 100b63e:	4809      	ldr	r0, [pc, #36]	; (100b664 <ll_tx_mem_enqueue+0xc4>)
 100b640:	21fd      	movs	r1, #253	; 0xfd
 100b642:	f7f7 ffa1 	bl	1003588 <bt_ctlr_assert_handle>
	return 0;
 100b646:	4620      	mov	r0, r4
 100b648:	e7d4      	b.n	100b5f4 <ll_tx_mem_enqueue+0x54>
		return -EINVAL;
 100b64a:	f06f 0015 	mvn.w	r0, #21
}
 100b64e:	4770      	bx	lr
		return -ENOBUFS;
 100b650:	f06f 0036 	mvn.w	r0, #54	; 0x36
}
 100b654:	b009      	add	sp, #36	; 0x24
 100b656:	bdf0      	pop	{r4, r5, r6, r7, pc}
 100b658:	21001b40 	.word	0x21001b40
 100b65c:	21000358 	.word	0x21000358
 100b660:	0100af51 	.word	0x0100af51
 100b664:	010187e4 	.word	0x010187e4

0100b668 <ll_conn_update>:
{
 100b668:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (handle >= CONFIG_BT_MAX_CONN) {
 100b66c:	280f      	cmp	r0, #15
{
 100b66e:	f8bd a020 	ldrh.w	sl, [sp, #32]
 100b672:	f8bd 9024 	ldrh.w	r9, [sp, #36]	; 0x24
 100b676:	f8bd 8028 	ldrh.w	r8, [sp, #40]	; 0x28
	if (handle >= CONFIG_BT_MAX_CONN) {
 100b67a:	d83f      	bhi.n	100b6fc <ll_conn_update+0x94>
 100b67c:	4604      	mov	r4, r0
 100b67e:	460d      	mov	r5, r1
 100b680:	4617      	mov	r7, r2
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b682:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100b686:	4602      	mov	r2, r0
 100b688:	483a      	ldr	r0, [pc, #232]	; (100b774 <ll_conn_update+0x10c>)
 100b68a:	461e      	mov	r6, r3
 100b68c:	f7fa fafa 	bl	1005c84 <mem_get>
	if (conn->lll.handle != handle) {
 100b690:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
 100b692:	42a3      	cmp	r3, r4
 100b694:	d132      	bne.n	100b6fc <ll_conn_update+0x94>
	if (!cmd) {
 100b696:	bb3d      	cbnz	r5, 100b6e8 <ll_conn_update+0x80>
		if (!conn->llcp_conn_param.disabled &&
 100b698:	f890 3172 	ldrb.w	r3, [r0, #370]	; 0x172
 100b69c:	06d9      	lsls	r1, r3, #27
 100b69e:	d530      	bpl.n	100b702 <ll_conn_update+0x9a>
		} else if (conn->lll.role) {
 100b6a0:	f990 303d 	ldrsb.w	r3, [r0, #61]	; 0x3d
 100b6a4:	2b00      	cmp	r3, #0
 100b6a6:	db62      	blt.n	100b76e <ll_conn_update+0x106>
		if (conn->llcp_cu.req != conn->llcp_cu.ack) {
 100b6a8:	f890 3104 	ldrb.w	r3, [r0, #260]	; 0x104
 100b6ac:	f890 2105 	ldrb.w	r2, [r0, #261]	; 0x105
 100b6b0:	429a      	cmp	r2, r3
 100b6b2:	d123      	bne.n	100b6fc <ll_conn_update+0x94>
		conn->llcp_cu.win_size = 1U;
 100b6b4:	2401      	movs	r4, #1
		conn->llcp_cu.win_offset_us = 0U;
 100b6b6:	2300      	movs	r3, #0
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
 100b6b8:	f890 1106 	ldrb.w	r1, [r0, #262]	; 0x106
		conn->llcp_cu.req++;
 100b6bc:	4422      	add	r2, r4
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
 100b6be:	f021 0107 	bic.w	r1, r1, #7
 100b6c2:	f041 0105 	orr.w	r1, r1, #5
		conn->llcp_cu.req++;
 100b6c6:	f880 2104 	strb.w	r2, [r0, #260]	; 0x104
		conn->llcp_cu.win_size = 1U;
 100b6ca:	f880 4114 	strb.w	r4, [r0, #276]	; 0x114
		conn->llcp_cu.interval = interval_max;
 100b6ce:	f8a0 a108 	strh.w	sl, [r0, #264]	; 0x108
		conn->llcp_cu.latency = latency;
 100b6d2:	f8a0 910a 	strh.w	r9, [r0, #266]	; 0x10a
		conn->llcp_cu.timeout = timeout;
 100b6d6:	f8a0 810c 	strh.w	r8, [r0, #268]	; 0x10c
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
 100b6da:	f880 1106 	strb.w	r1, [r0, #262]	; 0x106
		conn->llcp_cu.win_offset_us = 0U;
 100b6de:	f8c0 3110 	str.w	r3, [r0, #272]	; 0x110
	return 0;
 100b6e2:	4618      	mov	r0, r3
}
 100b6e4:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		cmd--;
 100b6e8:	3d01      	subs	r5, #1
		if (cmd) {
 100b6ea:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
 100b6ee:	d010      	beq.n	100b712 <ll_conn_update+0xaa>
			if ((conn->llcp_conn_param.req ==
 100b6f0:	f890 2170 	ldrb.w	r2, [r0, #368]	; 0x170
 100b6f4:	f890 3171 	ldrb.w	r3, [r0, #369]	; 0x171
 100b6f8:	429a      	cmp	r2, r3
 100b6fa:	d125      	bne.n	100b748 <ll_conn_update+0xe0>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100b6fc:	200c      	movs	r0, #12
}
 100b6fe:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		    (!conn->common.fex_valid ||
 100b702:	f890 30dc 	ldrb.w	r3, [r0, #220]	; 0xdc
		if (!conn->llcp_conn_param.disabled &&
 100b706:	07da      	lsls	r2, r3, #31
 100b708:	d503      	bpl.n	100b712 <ll_conn_update+0xaa>
		     (conn->llcp_feature.features &
 100b70a:	f8d0 311c 	ldr.w	r3, [r0, #284]	; 0x11c
		    (!conn->common.fex_valid ||
 100b70e:	079b      	lsls	r3, r3, #30
 100b710:	d5c6      	bpl.n	100b6a0 <ll_conn_update+0x38>
			if (conn->llcp_conn_param.req !=
 100b712:	f890 2170 	ldrb.w	r2, [r0, #368]	; 0x170
 100b716:	f890 3171 	ldrb.w	r3, [r0, #369]	; 0x171
 100b71a:	4293      	cmp	r3, r2
 100b71c:	d1ee      	bne.n	100b6fc <ll_conn_update+0x94>
			conn->llcp_conn_param.state = cmd;
 100b71e:	f8b0 2172 	ldrh.w	r2, [r0, #370]	; 0x172
			conn->llcp_conn_param.req++;
 100b722:	3301      	adds	r3, #1
			conn->llcp_conn_param.state = cmd;
 100b724:	f002 02f0 	and.w	r2, r2, #240	; 0xf0
 100b728:	f042 0208 	orr.w	r2, r2, #8
			conn->llcp_conn_param.req++;
 100b72c:	f880 3170 	strb.w	r3, [r0, #368]	; 0x170
			conn->llcp_conn_param.interval_min = interval_min;
 100b730:	f8a0 6174 	strh.w	r6, [r0, #372]	; 0x174
			conn->llcp_conn_param.interval_max = interval_max;
 100b734:	f8a0 a176 	strh.w	sl, [r0, #374]	; 0x176
			conn->llcp_conn_param.latency = latency;
 100b738:	f8a0 9178 	strh.w	r9, [r0, #376]	; 0x178
			conn->llcp_conn_param.timeout = timeout;
 100b73c:	f8a0 817a 	strh.w	r8, [r0, #378]	; 0x17a
			conn->llcp_conn_param.state = cmd;
 100b740:	f8a0 2172 	strh.w	r2, [r0, #370]	; 0x172
	return 0;
 100b744:	2000      	movs	r0, #0
 100b746:	e7da      	b.n	100b6fe <ll_conn_update+0x96>
			    (conn->llcp_conn_param.state !=
 100b748:	f890 3172 	ldrb.w	r3, [r0, #370]	; 0x172
			     conn->llcp_conn_param.ack) ||
 100b74c:	f003 0207 	and.w	r2, r3, #7
 100b750:	2a03      	cmp	r2, #3
 100b752:	d1d3      	bne.n	100b6fc <ll_conn_update+0x94>
			conn->llcp_conn_param.state = cmd;
 100b754:	f005 0507 	and.w	r5, r5, #7
 100b758:	f045 0508 	orr.w	r5, r5, #8
 100b75c:	f023 030f 	bic.w	r3, r3, #15
 100b760:	431d      	orrs	r5, r3
 100b762:	f880 5172 	strb.w	r5, [r0, #370]	; 0x172
			conn->llcp_conn_param.status = status;
 100b766:	f880 7173 	strb.w	r7, [r0, #371]	; 0x173
	return 0;
 100b76a:	2000      	movs	r0, #0
 100b76c:	e7c7      	b.n	100b6fe <ll_conn_update+0x96>
			return BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
 100b76e:	201a      	movs	r0, #26
 100b770:	e7c5      	b.n	100b6fe <ll_conn_update+0x96>
 100b772:	bf00      	nop
 100b774:	21001b40 	.word	0x21001b40

0100b778 <ll_chm_get>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100b778:	280f      	cmp	r0, #15
 100b77a:	d81d      	bhi.n	100b7b8 <ll_chm_get+0x40>
{
 100b77c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b77e:	4602      	mov	r2, r0
 100b780:	4606      	mov	r6, r0
 100b782:	460d      	mov	r5, r1
 100b784:	480d      	ldr	r0, [pc, #52]	; (100b7bc <ll_chm_get+0x44>)
 100b786:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100b78a:	f7fa fa7b 	bl	1005c84 <mem_get>
	if (conn->lll.handle != handle) {
 100b78e:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b790:	4604      	mov	r4, r0
	if (conn->lll.handle != handle) {
 100b792:	42b3      	cmp	r3, r6
 100b794:	d10e      	bne.n	100b7b4 <ll_chm_get+0x3c>
		conn->chm_updated = 0U;
 100b796:	2700      	movs	r7, #0
 100b798:	f100 0638 	add.w	r6, r0, #56	; 0x38
		memcpy(chm, conn->lll.data_chan_map,
 100b79c:	2205      	movs	r2, #5
 100b79e:	4631      	mov	r1, r6
 100b7a0:	4628      	mov	r0, r5
		conn->chm_updated = 0U;
 100b7a2:	f884 71c4 	strb.w	r7, [r4, #452]	; 0x1c4
		memcpy(chm, conn->lll.data_chan_map,
 100b7a6:	f00b f887 	bl	10168b8 <memcpy>
	} while (conn->chm_updated);
 100b7aa:	f894 01c4 	ldrb.w	r0, [r4, #452]	; 0x1c4
 100b7ae:	2800      	cmp	r0, #0
 100b7b0:	d1f4      	bne.n	100b79c <ll_chm_get+0x24>
}
 100b7b2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100b7b4:	200c      	movs	r0, #12
}
 100b7b6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100b7b8:	200c      	movs	r0, #12
}
 100b7ba:	4770      	bx	lr
 100b7bc:	21001b40 	.word	0x21001b40

0100b7c0 <ll_terminate_ind_send>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100b7c0:	280f      	cmp	r0, #15
 100b7c2:	d817      	bhi.n	100b7f4 <ll_terminate_ind_send+0x34>
{
 100b7c4:	b538      	push	{r3, r4, r5, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b7c6:	4602      	mov	r2, r0
 100b7c8:	4604      	mov	r4, r0
 100b7ca:	460d      	mov	r5, r1
 100b7cc:	480a      	ldr	r0, [pc, #40]	; (100b7f8 <ll_terminate_ind_send+0x38>)
 100b7ce:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100b7d2:	f7fa fa57 	bl	1005c84 <mem_get>
	if (conn->lll.handle != handle) {
 100b7d6:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b7d8:	4603      	mov	r3, r0
	if (conn->lll.handle != handle) {
 100b7da:	42a2      	cmp	r2, r4
 100b7dc:	d108      	bne.n	100b7f0 <ll_terminate_ind_send+0x30>
	conn->llcp_terminate.req++;
 100b7de:	f893 2128 	ldrb.w	r2, [r3, #296]	; 0x128
	conn->llcp_terminate.reason_own = reason;
 100b7e2:	f883 512a 	strb.w	r5, [r3, #298]	; 0x12a
	conn->llcp_terminate.req++;
 100b7e6:	3201      	adds	r2, #1
 100b7e8:	f883 2128 	strb.w	r2, [r3, #296]	; 0x128
	return 0;
 100b7ec:	2000      	movs	r0, #0
}
 100b7ee:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100b7f0:	200c      	movs	r0, #12
}
 100b7f2:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100b7f4:	200c      	movs	r0, #12
}
 100b7f6:	4770      	bx	lr
 100b7f8:	21001b40 	.word	0x21001b40

0100b7fc <ll_feature_req_send>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100b7fc:	280f      	cmp	r0, #15
 100b7fe:	d818      	bhi.n	100b832 <ll_feature_req_send+0x36>
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b800:	4602      	mov	r2, r0
{
 100b802:	b510      	push	{r4, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b804:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100b808:	4604      	mov	r4, r0
 100b80a:	480b      	ldr	r0, [pc, #44]	; (100b838 <ll_feature_req_send+0x3c>)
 100b80c:	f7fa fa3a 	bl	1005c84 <mem_get>
	if (conn->lll.handle != handle) {
 100b810:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b812:	4603      	mov	r3, r0
	if (conn->lll.handle != handle) {
 100b814:	42a2      	cmp	r2, r4
 100b816:	d10a      	bne.n	100b82e <ll_feature_req_send+0x32>
	if (conn->llcp_feature.req != conn->llcp_feature.ack) {
 100b818:	f890 1118 	ldrb.w	r1, [r0, #280]	; 0x118
 100b81c:	f890 2119 	ldrb.w	r2, [r0, #281]	; 0x119
 100b820:	428a      	cmp	r2, r1
 100b822:	d104      	bne.n	100b82e <ll_feature_req_send+0x32>
	conn->llcp_feature.req++;
 100b824:	3201      	adds	r2, #1
 100b826:	f883 2118 	strb.w	r2, [r3, #280]	; 0x118
	return 0;
 100b82a:	2000      	movs	r0, #0
}
 100b82c:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100b82e:	200c      	movs	r0, #12
}
 100b830:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100b832:	200c      	movs	r0, #12
}
 100b834:	4770      	bx	lr
 100b836:	bf00      	nop
 100b838:	21001b40 	.word	0x21001b40

0100b83c <ll_version_ind_send>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100b83c:	280f      	cmp	r0, #15
 100b83e:	d818      	bhi.n	100b872 <ll_version_ind_send+0x36>
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b840:	4602      	mov	r2, r0
{
 100b842:	b510      	push	{r4, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b844:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100b848:	4604      	mov	r4, r0
 100b84a:	480b      	ldr	r0, [pc, #44]	; (100b878 <ll_version_ind_send+0x3c>)
 100b84c:	f7fa fa1a 	bl	1005c84 <mem_get>
	if (conn->lll.handle != handle) {
 100b850:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b852:	4603      	mov	r3, r0
	if (conn->lll.handle != handle) {
 100b854:	42a2      	cmp	r2, r4
 100b856:	d10a      	bne.n	100b86e <ll_version_ind_send+0x32>
	if (conn->llcp_version.req != conn->llcp_version.ack) {
 100b858:	f890 1120 	ldrb.w	r1, [r0, #288]	; 0x120
 100b85c:	f890 2121 	ldrb.w	r2, [r0, #289]	; 0x121
 100b860:	428a      	cmp	r2, r1
 100b862:	d104      	bne.n	100b86e <ll_version_ind_send+0x32>
	conn->llcp_version.req++;
 100b864:	3201      	adds	r2, #1
 100b866:	f883 2120 	strb.w	r2, [r3, #288]	; 0x120
	return 0;
 100b86a:	2000      	movs	r0, #0
}
 100b86c:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100b86e:	200c      	movs	r0, #12
}
 100b870:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100b872:	200c      	movs	r0, #12
}
 100b874:	4770      	bx	lr
 100b876:	bf00      	nop
 100b878:	21001b40 	.word	0x21001b40

0100b87c <ll_length_req_send>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100b87c:	280f      	cmp	r0, #15
 100b87e:	d836      	bhi.n	100b8ee <ll_length_req_send+0x72>
{
 100b880:	b570      	push	{r4, r5, r6, lr}
 100b882:	4604      	mov	r4, r0
 100b884:	460e      	mov	r6, r1
 100b886:	4615      	mov	r5, r2
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b888:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100b88c:	4602      	mov	r2, r0
 100b88e:	4820      	ldr	r0, [pc, #128]	; (100b910 <ll_length_req_send+0x94>)
 100b890:	f7fa f9f8 	bl	1005c84 <mem_get>
	if (conn->lll.handle != handle) {
 100b894:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
 100b896:	42a3      	cmp	r3, r4
 100b898:	d11f      	bne.n	100b8da <ll_length_req_send+0x5e>
	if (conn->llcp_length.disabled ||
 100b89a:	f890 319a 	ldrb.w	r3, [r0, #410]	; 0x19a
 100b89e:	071c      	lsls	r4, r3, #28
 100b8a0:	d421      	bmi.n	100b8e6 <ll_length_req_send+0x6a>
	    (conn->common.fex_valid &&
 100b8a2:	f890 20dc 	ldrb.w	r2, [r0, #220]	; 0xdc
	if (conn->llcp_length.disabled ||
 100b8a6:	07d1      	lsls	r1, r2, #31
 100b8a8:	d419      	bmi.n	100b8de <ll_length_req_send+0x62>
	if (conn->llcp_length.req != conn->llcp_length.ack) {
 100b8aa:	f890 1198 	ldrb.w	r1, [r0, #408]	; 0x198
 100b8ae:	f890 2199 	ldrb.w	r2, [r0, #409]	; 0x199
 100b8b2:	428a      	cmp	r2, r1
 100b8b4:	d01d      	beq.n	100b8f2 <ll_length_req_send+0x76>
		switch (conn->llcp_length.state) {
 100b8b6:	f003 0307 	and.w	r3, r3, #7
 100b8ba:	2b03      	cmp	r3, #3
 100b8bc:	d004      	beq.n	100b8c8 <ll_length_req_send+0x4c>
 100b8be:	3303      	adds	r3, #3
 100b8c0:	f003 0307 	and.w	r3, r3, #7
 100b8c4:	2b01      	cmp	r3, #1
 100b8c6:	d810      	bhi.n	100b8ea <ll_length_req_send+0x6e>
			if (!conn->llcp_length.cache.tx_octets) {
 100b8c8:	f8b0 31a4 	ldrh.w	r3, [r0, #420]	; 0x1a4
 100b8cc:	b96b      	cbnz	r3, 100b8ea <ll_length_req_send+0x6e>
				conn->llcp_length.cache.tx_octets = tx_octets;
 100b8ce:	f8a0 61a4 	strh.w	r6, [r0, #420]	; 0x1a4
				conn->llcp_length.cache.tx_time = tx_time;
 100b8d2:	f8a0 51a6 	strh.w	r5, [r0, #422]	; 0x1a6
				return 0;
 100b8d6:	4618      	mov	r0, r3
}
 100b8d8:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100b8da:	2002      	movs	r0, #2
}
 100b8dc:	bd70      	pop	{r4, r5, r6, pc}
	     !(conn->llcp_feature.features & BIT(BT_LE_FEAT_BIT_DLE)))) {
 100b8de:	f8d0 211c 	ldr.w	r2, [r0, #284]	; 0x11c
	    (conn->common.fex_valid &&
 100b8e2:	0692      	lsls	r2, r2, #26
 100b8e4:	d4e1      	bmi.n	100b8aa <ll_length_req_send+0x2e>
		return BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
 100b8e6:	201a      	movs	r0, #26
}
 100b8e8:	bd70      	pop	{r4, r5, r6, pc}
			return BT_HCI_ERR_CMD_DISALLOWED;
 100b8ea:	200c      	movs	r0, #12
}
 100b8ec:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100b8ee:	2002      	movs	r0, #2
}
 100b8f0:	4770      	bx	lr
	conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
 100b8f2:	f890 319a 	ldrb.w	r3, [r0, #410]	; 0x19a
	conn->llcp_length.req++;
 100b8f6:	3201      	adds	r2, #1
	conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
 100b8f8:	f36f 0302 	bfc	r3, #0, #3
	conn->llcp_length.req++;
 100b8fc:	f880 2198 	strb.w	r2, [r0, #408]	; 0x198
	conn->llcp_length.tx_octets = tx_octets;
 100b900:	f8a0 619e 	strh.w	r6, [r0, #414]	; 0x19e
	conn->llcp_length.tx_time = tx_time;
 100b904:	f8a0 51a2 	strh.w	r5, [r0, #418]	; 0x1a2
	conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
 100b908:	f880 319a 	strb.w	r3, [r0, #410]	; 0x19a
	return 0;
 100b90c:	2000      	movs	r0, #0
}
 100b90e:	bd70      	pop	{r4, r5, r6, pc}
 100b910:	21001b40 	.word	0x21001b40

0100b914 <ll_length_default_get>:
	*max_tx_octets = default_tx_octets;
 100b914:	4a03      	ldr	r2, [pc, #12]	; (100b924 <ll_length_default_get+0x10>)
	*max_tx_time = default_tx_time;
 100b916:	4b04      	ldr	r3, [pc, #16]	; (100b928 <ll_length_default_get+0x14>)
	*max_tx_octets = default_tx_octets;
 100b918:	8812      	ldrh	r2, [r2, #0]
	*max_tx_time = default_tx_time;
 100b91a:	881b      	ldrh	r3, [r3, #0]
	*max_tx_octets = default_tx_octets;
 100b91c:	8002      	strh	r2, [r0, #0]
	*max_tx_time = default_tx_time;
 100b91e:	800b      	strh	r3, [r1, #0]
}
 100b920:	4770      	bx	lr
 100b922:	bf00      	nop
 100b924:	21006686 	.word	0x21006686
 100b928:	21006688 	.word	0x21006688

0100b92c <ll_length_default_set>:
	default_tx_octets = max_tx_octets;
 100b92c:	4a02      	ldr	r2, [pc, #8]	; (100b938 <ll_length_default_set+0xc>)
	default_tx_time = max_tx_time;
 100b92e:	4b03      	ldr	r3, [pc, #12]	; (100b93c <ll_length_default_set+0x10>)
	default_tx_octets = max_tx_octets;
 100b930:	8010      	strh	r0, [r2, #0]
	default_tx_time = max_tx_time;
 100b932:	8019      	strh	r1, [r3, #0]
}
 100b934:	2000      	movs	r0, #0
 100b936:	4770      	bx	lr
 100b938:	21006686 	.word	0x21006686
 100b93c:	21006688 	.word	0x21006688

0100b940 <ll_length_max_get>:
{
 100b940:	b430      	push	{r4, r5}
	*max_tx_octets = LL_LENGTH_OCTETS_RX_MAX;
 100b942:	251b      	movs	r5, #27
	*max_tx_time = PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_CODED);
 100b944:	f44f 6429 	mov.w	r4, #2704	; 0xa90
	*max_tx_octets = LL_LENGTH_OCTETS_RX_MAX;
 100b948:	8005      	strh	r5, [r0, #0]
	*max_rx_octets = LL_LENGTH_OCTETS_RX_MAX;
 100b94a:	8015      	strh	r5, [r2, #0]
	*max_tx_time = PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_CODED);
 100b94c:	800c      	strh	r4, [r1, #0]
	*max_rx_time = PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_CODED);
 100b94e:	801c      	strh	r4, [r3, #0]
}
 100b950:	bc30      	pop	{r4, r5}
 100b952:	4770      	bx	lr

0100b954 <ll_phy_get>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100b954:	280f      	cmp	r0, #15
 100b956:	d81b      	bhi.n	100b990 <ll_phy_get+0x3c>
{
 100b958:	b570      	push	{r4, r5, r6, lr}
 100b95a:	4604      	mov	r4, r0
 100b95c:	460e      	mov	r6, r1
 100b95e:	4615      	mov	r5, r2
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b960:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100b964:	4602      	mov	r2, r0
 100b966:	480b      	ldr	r0, [pc, #44]	; (100b994 <ll_phy_get+0x40>)
 100b968:	f7fa f98c 	bl	1005c84 <mem_get>
	if (conn->lll.handle != handle) {
 100b96c:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b96e:	4603      	mov	r3, r0
	if (conn->lll.handle != handle) {
 100b970:	42a2      	cmp	r2, r4
 100b972:	d10b      	bne.n	100b98c <ll_phy_get+0x38>
	*tx = conn->lll.phy_tx;
 100b974:	f893 2064 	ldrb.w	r2, [r3, #100]	; 0x64
	return 0;
 100b978:	2000      	movs	r0, #0
	*tx = conn->lll.phy_tx;
 100b97a:	f3c2 0202 	ubfx	r2, r2, #0, #3
 100b97e:	7032      	strb	r2, [r6, #0]
	*rx = conn->lll.phy_rx;
 100b980:	f893 3065 	ldrb.w	r3, [r3, #101]	; 0x65
 100b984:	f3c3 0302 	ubfx	r3, r3, #0, #3
 100b988:	702b      	strb	r3, [r5, #0]
}
 100b98a:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100b98c:	2002      	movs	r0, #2
}
 100b98e:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100b990:	2002      	movs	r0, #2
}
 100b992:	4770      	bx	lr
 100b994:	21001b40 	.word	0x21001b40

0100b998 <ll_phy_default_set>:
	default_phy_tx = tx;
 100b998:	4a02      	ldr	r2, [pc, #8]	; (100b9a4 <ll_phy_default_set+0xc>)
	default_phy_rx = rx;
 100b99a:	4b03      	ldr	r3, [pc, #12]	; (100b9a8 <ll_phy_default_set+0x10>)
	default_phy_tx = tx;
 100b99c:	7010      	strb	r0, [r2, #0]
	default_phy_rx = rx;
 100b99e:	7019      	strb	r1, [r3, #0]
}
 100b9a0:	2000      	movs	r0, #0
 100b9a2:	4770      	bx	lr
 100b9a4:	210066f1 	.word	0x210066f1
 100b9a8:	210066f0 	.word	0x210066f0

0100b9ac <ll_phy_req_send>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100b9ac:	280f      	cmp	r0, #15
 100b9ae:	d84d      	bhi.n	100ba4c <ll_phy_req_send+0xa0>
{
 100b9b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100b9b4:	4605      	mov	r5, r0
 100b9b6:	4688      	mov	r8, r1
 100b9b8:	4616      	mov	r6, r2
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b9ba:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100b9be:	4602      	mov	r2, r0
 100b9c0:	4823      	ldr	r0, [pc, #140]	; (100ba50 <ll_phy_req_send+0xa4>)
 100b9c2:	461f      	mov	r7, r3
 100b9c4:	f7fa f95e 	bl	1005c84 <mem_get>
	if (conn->lll.handle != handle) {
 100b9c8:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100b9ca:	4604      	mov	r4, r0
	if (conn->lll.handle != handle) {
 100b9cc:	42ab      	cmp	r3, r5
 100b9ce:	d12f      	bne.n	100ba30 <ll_phy_req_send+0x84>
	if (conn->llcp_phy.disabled ||
 100b9d0:	f890 01ab 	ldrb.w	r0, [r0, #427]	; 0x1ab
 100b9d4:	f010 0008 	ands.w	r0, r0, #8
 100b9d8:	d135      	bne.n	100ba46 <ll_phy_req_send+0x9a>
	    (conn->common.fex_valid &&
 100b9da:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
	if (conn->llcp_phy.disabled ||
 100b9de:	07db      	lsls	r3, r3, #31
 100b9e0:	d42c      	bmi.n	100ba3c <ll_phy_req_send+0x90>
	if ((conn->llcp_req != conn->llcp_ack) ||
 100b9e2:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
 100b9e6:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
 100b9ea:	429a      	cmp	r2, r3
 100b9ec:	d123      	bne.n	100ba36 <ll_phy_req_send+0x8a>
	    (conn->llcp_phy.req != conn->llcp_phy.ack)) {
 100b9ee:	f894 31a8 	ldrb.w	r3, [r4, #424]	; 0x1a8
	if ((conn->llcp_req != conn->llcp_ack) ||
 100b9f2:	f894 21a9 	ldrb.w	r2, [r4, #425]	; 0x1a9
 100b9f6:	429a      	cmp	r2, r3
 100b9f8:	d11d      	bne.n	100ba36 <ll_phy_req_send+0x8a>
	conn->llcp_phy.state = LLCP_PHY_STATE_REQ;
 100b9fa:	f008 0107 	and.w	r1, r8, #7
 100b9fe:	f8b4 51aa 	ldrh.w	r5, [r4, #426]	; 0x1aa
 100ba02:	0089      	lsls	r1, r1, #2
 100ba04:	f441 6180 	orr.w	r1, r1, #1024	; 0x400
 100ba08:	f007 0307 	and.w	r3, r7, #7
 100ba0c:	ea41 1343 	orr.w	r3, r1, r3, lsl #5
 100ba10:	f006 0601 	and.w	r6, r6, #1
 100ba14:	f425 61df 	bic.w	r1, r5, #1784	; 0x6f8
 100ba18:	ea43 2346 	orr.w	r3, r3, r6, lsl #9
 100ba1c:	f021 0107 	bic.w	r1, r1, #7
	conn->llcp_phy.req++;
 100ba20:	3201      	adds	r2, #1
	conn->llcp_phy.state = LLCP_PHY_STATE_REQ;
 100ba22:	430b      	orrs	r3, r1
	conn->llcp_phy.req++;
 100ba24:	f884 21a8 	strb.w	r2, [r4, #424]	; 0x1a8
	conn->llcp_phy.state = LLCP_PHY_STATE_REQ;
 100ba28:	f8a4 31aa 	strh.w	r3, [r4, #426]	; 0x1aa
}
 100ba2c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100ba30:	2002      	movs	r0, #2
}
 100ba32:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100ba36:	200c      	movs	r0, #12
}
 100ba38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	     !(conn->llcp_feature.features & BIT(BT_LE_FEAT_BIT_PHY_2M)) &&
 100ba3c:	f8d4 311c 	ldr.w	r3, [r4, #284]	; 0x11c
 100ba40:	f413 6f10 	tst.w	r3, #2304	; 0x900
 100ba44:	d1cd      	bne.n	100b9e2 <ll_phy_req_send+0x36>
		return BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
 100ba46:	201a      	movs	r0, #26
}
 100ba48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100ba4c:	2002      	movs	r0, #2
}
 100ba4e:	4770      	bx	lr
 100ba50:	21001b40 	.word	0x21001b40

0100ba54 <ll_rssi_get>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100ba54:	280f      	cmp	r0, #15
 100ba56:	d813      	bhi.n	100ba80 <ll_rssi_get+0x2c>
{
 100ba58:	b538      	push	{r3, r4, r5, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100ba5a:	4602      	mov	r2, r0
 100ba5c:	4604      	mov	r4, r0
 100ba5e:	460d      	mov	r5, r1
 100ba60:	4808      	ldr	r0, [pc, #32]	; (100ba84 <ll_rssi_get+0x30>)
 100ba62:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100ba66:	f7fa f90d 	bl	1005c84 <mem_get>
	if (conn->lll.handle != handle) {
 100ba6a:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100ba6c:	4603      	mov	r3, r0
	if (conn->lll.handle != handle) {
 100ba6e:	42a2      	cmp	r2, r4
 100ba70:	d104      	bne.n	100ba7c <ll_rssi_get+0x28>
	*rssi = conn->lll.rssi_latest;
 100ba72:	f893 30c1 	ldrb.w	r3, [r3, #193]	; 0xc1
	return 0;
 100ba76:	2000      	movs	r0, #0
	*rssi = conn->lll.rssi_latest;
 100ba78:	702b      	strb	r3, [r5, #0]
}
 100ba7a:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100ba7c:	200c      	movs	r0, #12
}
 100ba7e:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100ba80:	200c      	movs	r0, #12
}
 100ba82:	4770      	bx	lr
 100ba84:	21001b40 	.word	0x21001b40

0100ba88 <ll_apto_get>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100ba88:	280f      	cmp	r0, #15
 100ba8a:	d81e      	bhi.n	100baca <ll_apto_get+0x42>
{
 100ba8c:	b538      	push	{r3, r4, r5, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100ba8e:	4602      	mov	r2, r0
 100ba90:	4604      	mov	r4, r0
 100ba92:	460d      	mov	r5, r1
 100ba94:	480e      	ldr	r0, [pc, #56]	; (100bad0 <ll_apto_get+0x48>)
 100ba96:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100ba9a:	f7fa f8f3 	bl	1005c84 <mem_get>
	if (conn->lll.handle != handle) {
 100ba9e:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100baa0:	4602      	mov	r2, r0
	if (conn->lll.handle != handle) {
 100baa2:	42a3      	cmp	r3, r4
 100baa4:	d10f      	bne.n	100bac6 <ll_apto_get+0x3e>
	*apto = conn->apto_reload * conn->lll.interval * 125U / 1000;
 100baa6:	f8b2 10d2 	ldrh.w	r1, [r2, #210]	; 0xd2
 100baaa:	8dd3      	ldrh	r3, [r2, #46]	; 0x2e
 100baac:	4a09      	ldr	r2, [pc, #36]	; (100bad4 <ll_apto_get+0x4c>)
 100baae:	fb03 f301 	mul.w	r3, r3, r1
 100bab2:	ebc3 1143 	rsb	r1, r3, r3, lsl #5
 100bab6:	eb03 0381 	add.w	r3, r3, r1, lsl #2
 100baba:	fba2 2303 	umull	r2, r3, r2, r3
 100babe:	099b      	lsrs	r3, r3, #6
	return 0;
 100bac0:	2000      	movs	r0, #0
	*apto = conn->apto_reload * conn->lll.interval * 125U / 1000;
 100bac2:	802b      	strh	r3, [r5, #0]
}
 100bac4:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100bac6:	2002      	movs	r0, #2
}
 100bac8:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100baca:	2002      	movs	r0, #2
}
 100bacc:	4770      	bx	lr
 100bace:	bf00      	nop
 100bad0:	21001b40 	.word	0x21001b40
 100bad4:	10624dd3 	.word	0x10624dd3

0100bad8 <ll_apto_set>:
	if (handle >= CONFIG_BT_MAX_CONN) {
 100bad8:	280f      	cmp	r0, #15
 100bada:	d81e      	bhi.n	100bb1a <ll_apto_set+0x42>
{
 100badc:	b538      	push	{r3, r4, r5, lr}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100bade:	4602      	mov	r2, r0
 100bae0:	4604      	mov	r4, r0
 100bae2:	460d      	mov	r5, r1
 100bae4:	480e      	ldr	r0, [pc, #56]	; (100bb20 <ll_apto_set+0x48>)
 100bae6:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100baea:	f7fa f8cb 	bl	1005c84 <mem_get>
	if (conn->lll.handle != handle) {
 100baee:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100baf0:	4602      	mov	r2, r0
	if (conn->lll.handle != handle) {
 100baf2:	42a3      	cmp	r3, r4
 100baf4:	d10f      	bne.n	100bb16 <ll_apto_set+0x3e>
	conn->apto_reload = RADIO_CONN_EVENTS(apto * 10U * 1000U,
 100baf6:	f240 44e2 	movw	r4, #1250	; 0x4e2
 100bafa:	f242 7310 	movw	r3, #10000	; 0x2710
 100bafe:	8dc1      	ldrh	r1, [r0, #46]	; 0x2e
	return 0;
 100bb00:	2000      	movs	r0, #0
	conn->apto_reload = RADIO_CONN_EVENTS(apto * 10U * 1000U,
 100bb02:	fb04 f401 	mul.w	r4, r4, r1
 100bb06:	fb03 4305 	mla	r3, r3, r5, r4
 100bb0a:	3b01      	subs	r3, #1
 100bb0c:	fbb3 f3f4 	udiv	r3, r3, r4
 100bb10:	f8a2 30d2 	strh.w	r3, [r2, #210]	; 0xd2
}
 100bb14:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100bb16:	2002      	movs	r0, #2
}
 100bb18:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100bb1a:	2002      	movs	r0, #2
}
 100bb1c:	4770      	bx	lr
 100bb1e:	bf00      	nop
 100bb20:	21001b40 	.word	0x21001b40

0100bb24 <ull_conn_init>:
	err = init_reset();
 100bb24:	f7ff ba7a 	b.w	100b01c <init_reset>

0100bb28 <ull_conn_reset>:
{
 100bb28:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 100bb2c:	b085      	sub	sp, #20
 100bb2e:	2500      	movs	r5, #0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100bb30:	f8df 90c0 	ldr.w	r9, [pc, #192]	; 100bbf4 <ull_conn_reset+0xcc>
	LL_ASSERT(mark == conn);
 100bb34:	4f29      	ldr	r7, [pc, #164]	; (100bbdc <ull_conn_reset+0xb4>)
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
 100bb36:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 100bbf8 <ull_conn_reset+0xd0>
 100bb3a:	ae03      	add	r6, sp, #12
 100bb3c:	e00d      	b.n	100bb5a <ull_conn_reset+0x32>
	conn->lll.link_tx_free = NULL;
 100bb3e:	2300      	movs	r3, #0
	mark = ull_disable_unmark(conn);
 100bb40:	4620      	mov	r0, r4
	conn->lll.link_tx_free = NULL;
 100bb42:	67a3      	str	r3, [r4, #120]	; 0x78
	mark = ull_disable_unmark(conn);
 100bb44:	f7fe faea 	bl	100a11c <ull_disable_unmark>
	LL_ASSERT(mark == conn);
 100bb48:	4284      	cmp	r4, r0
 100bb4a:	d004      	beq.n	100bb56 <ull_conn_reset+0x2e>
 100bb4c:	f240 61a4 	movw	r1, #1700	; 0x6a4
 100bb50:	4638      	mov	r0, r7
 100bb52:	f7f7 fd19 	bl	1003588 <bt_ctlr_assert_handle>
	for (handle = 0U; handle < CONFIG_BT_MAX_CONN; handle++) {
 100bb56:	2d10      	cmp	r5, #16
 100bb58:	d02b      	beq.n	100bbb2 <ull_conn_reset+0x8a>
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 100bb5a:	2302      	movs	r3, #2
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100bb5c:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100bb60:	b2aa      	uxth	r2, r5
 100bb62:	4648      	mov	r0, r9
	volatile u32_t ret_cb = TICKER_STATUS_BUSY;
 100bb64:	9303      	str	r3, [sp, #12]
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100bb66:	f7fa f88d 	bl	1005c84 <mem_get>
 100bb6a:	4604      	mov	r4, r0
	mark = ull_disable_mark(conn);
 100bb6c:	f7fe facc 	bl	100a108 <ull_disable_mark>
	LL_ASSERT(mark == conn);
 100bb70:	4284      	cmp	r4, r0
 100bb72:	d004      	beq.n	100bb7e <ull_conn_reset+0x56>
 100bb74:	f240 6195 	movw	r1, #1685	; 0x695
 100bb78:	4638      	mov	r0, r7
 100bb7a:	f7f7 fd05 	bl	1003588 <bt_ctlr_assert_handle>
	ret = ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_THREAD,
 100bb7e:	1d6a      	adds	r2, r5, #5
 100bb80:	4643      	mov	r3, r8
 100bb82:	2103      	movs	r1, #3
 100bb84:	b2d2      	uxtb	r2, r2
 100bb86:	2000      	movs	r0, #0
 100bb88:	9600      	str	r6, [sp, #0]
 100bb8a:	f7fb fb53 	bl	1007234 <ticker_stop>
	ret = ull_ticker_status_take(ret, &ret_cb);
 100bb8e:	4631      	mov	r1, r6
 100bb90:	f7fe faac 	bl	100a0ec <ull_ticker_status_take>
	if (!ret) {
 100bb94:	3501      	adds	r5, #1
 100bb96:	2800      	cmp	r0, #0
 100bb98:	d1d1      	bne.n	100bb3e <ull_conn_reset+0x16>
		ret = ull_disable(&conn->lll);
 100bb9a:	f104 001c 	add.w	r0, r4, #28
 100bb9e:	f7fe faef 	bl	100a180 <ull_disable>
		LL_ASSERT(!ret);
 100bba2:	2800      	cmp	r0, #0
 100bba4:	d0cb      	beq.n	100bb3e <ull_conn_reset+0x16>
 100bba6:	f240 619e 	movw	r1, #1694	; 0x69e
 100bbaa:	4638      	mov	r0, r7
 100bbac:	f7f7 fcec 	bl	1003588 <bt_ctlr_assert_handle>
 100bbb0:	e7c5      	b.n	100bb3e <ull_conn_reset+0x16>
	data_chan_map[0] = 0xFF;
 100bbb2:	f04f 30ff 	mov.w	r0, #4294967295
	data_chan_map[4] = 0x1F;
 100bbb6:	211f      	movs	r1, #31
	MFIFO_INIT(conn_tx);
 100bbb8:	2300      	movs	r3, #0
	data_chan_count = 37U;
 100bbba:	2525      	movs	r5, #37	; 0x25
	data_chan_map[0] = 0xFF;
 100bbbc:	4a08      	ldr	r2, [pc, #32]	; (100bbe0 <ull_conn_reset+0xb8>)
	data_chan_count = 37U;
 100bbbe:	4c09      	ldr	r4, [pc, #36]	; (100bbe4 <ull_conn_reset+0xbc>)
	data_chan_map[0] = 0xFF;
 100bbc0:	6010      	str	r0, [r2, #0]
	data_chan_map[4] = 0x1F;
 100bbc2:	7111      	strb	r1, [r2, #4]
	MFIFO_INIT(conn_tx);
 100bbc4:	4808      	ldr	r0, [pc, #32]	; (100bbe8 <ull_conn_reset+0xc0>)
	MFIFO_INIT(conn_ack);
 100bbc6:	4909      	ldr	r1, [pc, #36]	; (100bbec <ull_conn_reset+0xc4>)
	conn_upd_curr = NULL;
 100bbc8:	4a09      	ldr	r2, [pc, #36]	; (100bbf0 <ull_conn_reset+0xc8>)
	MFIFO_INIT(conn_tx);
 100bbca:	8043      	strh	r3, [r0, #2]
	MFIFO_INIT(conn_ack);
 100bbcc:	804b      	strh	r3, [r1, #2]
	data_chan_count = 37U;
 100bbce:	7025      	strb	r5, [r4, #0]
	conn_upd_curr = NULL;
 100bbd0:	6013      	str	r3, [r2, #0]
	err = init_reset();
 100bbd2:	f7ff fa23 	bl	100b01c <init_reset>
}
 100bbd6:	b005      	add	sp, #20
 100bbd8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 100bbdc:	010187e4 	.word	0x010187e4
 100bbe0:	210002ec 	.word	0x210002ec
 100bbe4:	210004a8 	.word	0x210004a8
 100bbe8:	21000358 	.word	0x21000358
 100bbec:	210002f4 	.word	0x210002f4
 100bbf0:	210037c0 	.word	0x210037c0
 100bbf4:	21001b40 	.word	0x21001b40
 100bbf8:	0100a0e1 	.word	0x0100a0e1

0100bbfc <ull_conn_chan_map_cpy>:
{
 100bbfc:	b508      	push	{r3, lr}
	memcpy(chan_map, data_chan_map, sizeof(data_chan_map));
 100bbfe:	2205      	movs	r2, #5
 100bc00:	4902      	ldr	r1, [pc, #8]	; (100bc0c <ull_conn_chan_map_cpy+0x10>)
 100bc02:	f00a fe59 	bl	10168b8 <memcpy>
	return data_chan_count;
 100bc06:	4b02      	ldr	r3, [pc, #8]	; (100bc10 <ull_conn_chan_map_cpy+0x14>)
}
 100bc08:	7818      	ldrb	r0, [r3, #0]
 100bc0a:	bd08      	pop	{r3, pc}
 100bc0c:	210002ec 	.word	0x210002ec
 100bc10:	210004a8 	.word	0x210004a8

0100bc14 <ull_conn_chan_map_set>:
{
 100bc14:	b510      	push	{r4, lr}
	memcpy(data_chan_map, chan_map, sizeof(data_chan_map));
 100bc16:	4c06      	ldr	r4, [pc, #24]	; (100bc30 <ull_conn_chan_map_set+0x1c>)
{
 100bc18:	4601      	mov	r1, r0
	memcpy(data_chan_map, chan_map, sizeof(data_chan_map));
 100bc1a:	2205      	movs	r2, #5
 100bc1c:	4620      	mov	r0, r4
 100bc1e:	f00a fe4b 	bl	10168b8 <memcpy>
	data_chan_count = util_ones_count_get(data_chan_map,
 100bc22:	4620      	mov	r0, r4
 100bc24:	2105      	movs	r1, #5
 100bc26:	f7fa f9c7 	bl	1005fb8 <util_ones_count_get>
 100bc2a:	4b02      	ldr	r3, [pc, #8]	; (100bc34 <ull_conn_chan_map_set+0x20>)
 100bc2c:	7018      	strb	r0, [r3, #0]
}
 100bc2e:	bd10      	pop	{r4, pc}
 100bc30:	210002ec 	.word	0x210002ec
 100bc34:	210004a8 	.word	0x210004a8

0100bc38 <ull_conn_default_tx_octets_get>:
	return default_tx_octets;
 100bc38:	4b01      	ldr	r3, [pc, #4]	; (100bc40 <ull_conn_default_tx_octets_get+0x8>)
}
 100bc3a:	8818      	ldrh	r0, [r3, #0]
 100bc3c:	4770      	bx	lr
 100bc3e:	bf00      	nop
 100bc40:	21006686 	.word	0x21006686

0100bc44 <ull_conn_default_tx_time_get>:
	return default_tx_time;
 100bc44:	4b01      	ldr	r3, [pc, #4]	; (100bc4c <ull_conn_default_tx_time_get+0x8>)
}
 100bc46:	8818      	ldrh	r0, [r3, #0]
 100bc48:	4770      	bx	lr
 100bc4a:	bf00      	nop
 100bc4c:	21006688 	.word	0x21006688

0100bc50 <ull_conn_default_phy_tx_get>:
	return default_phy_tx;
 100bc50:	4b01      	ldr	r3, [pc, #4]	; (100bc58 <ull_conn_default_phy_tx_get+0x8>)
}
 100bc52:	7818      	ldrb	r0, [r3, #0]
 100bc54:	4770      	bx	lr
 100bc56:	bf00      	nop
 100bc58:	210066f1 	.word	0x210066f1

0100bc5c <ull_conn_default_phy_rx_get>:
	return default_phy_rx;
 100bc5c:	4b01      	ldr	r3, [pc, #4]	; (100bc64 <ull_conn_default_phy_rx_get+0x8>)
}
 100bc5e:	7818      	ldrb	r0, [r3, #0]
 100bc60:	4770      	bx	lr
 100bc62:	bf00      	nop
 100bc64:	210066f0 	.word	0x210066f0

0100bc68 <ull_conn_setup>:
{
 100bc68:	460a      	mov	r2, r1
	lll = *((struct lll_conn **)((u8_t *)ftr->param +
 100bc6a:	688b      	ldr	r3, [r1, #8]
{
 100bc6c:	b410      	push	{r4}
	lll = *((struct lll_conn **)((u8_t *)ftr->param +
 100bc6e:	689b      	ldr	r3, [r3, #8]
	ftr = &(rx->rx_ftr);
 100bc70:	3208      	adds	r2, #8
	switch (lll->role) {
 100bc72:	f893 4021 	ldrb.w	r4, [r3, #33]	; 0x21
 100bc76:	09e4      	lsrs	r4, r4, #7
 100bc78:	d002      	beq.n	100bc80 <ull_conn_setup+0x18>
}
 100bc7a:	bc10      	pop	{r4}
		ull_slave_setup(link, rx, ftr, lll);
 100bc7c:	f7f6 bcb0 	b.w	10025e0 <ull_slave_setup>
}
 100bc80:	bc10      	pop	{r4}
		ull_master_setup(link, rx, ftr, lll);
 100bc82:	f7f6 bf01 	b.w	1002a88 <ull_master_setup>
 100bc86:	bf00      	nop

0100bc88 <ull_conn_rx>:
{
 100bc88:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	conn = ll_connected_get((*rx)->hdr.handle);
 100bc8c:	680b      	ldr	r3, [r1, #0]
{
 100bc8e:	b085      	sub	sp, #20
	conn = ll_connected_get((*rx)->hdr.handle);
 100bc90:	88de      	ldrh	r6, [r3, #6]
	if (handle >= CONFIG_BT_MAX_CONN) {
 100bc92:	2e0f      	cmp	r6, #15
 100bc94:	d85e      	bhi.n	100bd54 <ull_conn_rx+0xcc>
 100bc96:	460c      	mov	r4, r1
 100bc98:	4607      	mov	r7, r0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100bc9a:	4632      	mov	r2, r6
 100bc9c:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100bca0:	48ba      	ldr	r0, [pc, #744]	; (100bf8c <ull_conn_rx+0x304>)
 100bca2:	f7f9 ffef 	bl	1005c84 <mem_get>
	if (conn->lll.handle != handle) {
 100bca6:	8d83      	ldrh	r3, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100bca8:	4605      	mov	r5, r0
	if (conn->lll.handle != handle) {
 100bcaa:	42b3      	cmp	r3, r6
 100bcac:	d151      	bne.n	100bd52 <ull_conn_rx+0xca>
	pdu_rx = (void *)(*rx)->pdu;
 100bcae:	6822      	ldr	r2, [r4, #0]
	switch (pdu_rx->ll_id) {
 100bcb0:	f892 3020 	ldrb.w	r3, [r2, #32]
	pdu_rx = (void *)(*rx)->pdu;
 100bcb4:	4616      	mov	r6, r2
	switch (pdu_rx->ll_id) {
 100bcb6:	f003 0303 	and.w	r3, r3, #3
 100bcba:	2b03      	cmp	r3, #3
 100bcbc:	d150      	bne.n	100bd60 <ull_conn_rx+0xd8>

	opcode = pdu_rx->llctrl.opcode;

#if defined(CONFIG_BT_CTLR_LE_ENC)
	/* FIXME: do check in individual case to reduce CPU time */
	if (conn->llcp_enc.pause_rx && ctrl_is_unexpected(conn, opcode)) {
 100bcbe:	f890 3152 	ldrb.w	r3, [r0, #338]	; 0x152
	opcode = pdu_rx->llctrl.opcode;
 100bcc2:	f892 a023 	ldrb.w	sl, [r2, #35]	; 0x23
	if (conn->llcp_enc.pause_rx && ctrl_is_unexpected(conn, opcode)) {
 100bcc6:	07d8      	lsls	r0, r3, #31
 100bcc8:	d55a      	bpl.n	100bd80 <ull_conn_rx+0xf8>
		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)))) ||
 100bcca:	f995 203d 	ldrsb.w	r2, [r5, #61]	; 0x3d
 100bcce:	2a00      	cmp	r2, #0
 100bcd0:	f2c0 80e8 	blt.w	100bea4 <ull_conn_rx+0x21c>
	return (!conn->lll.role &&
 100bcd4:	0759      	lsls	r1, r3, #29
 100bcd6:	f140 8688 	bpl.w	100c9ea <ull_conn_rx+0xd62>
		 (conn->llcp_enc.refresh &&
 100bcda:	f1ba 0f02 	cmp.w	sl, #2
 100bcde:	f000 8389 	beq.w	100c3f4 <ull_conn_rx+0x76c>
		  (opcode != PDU_DATA_LLCTRL_TYPE_TERMINATE_IND) &&
 100bce2:	f1ba 0f0b 	cmp.w	sl, #11
 100bce6:	f000 868c 	beq.w	100ca02 <ull_conn_rx+0xd7a>
		  (opcode != PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP) &&
 100bcea:	f1ba 0f04 	cmp.w	sl, #4
 100bcee:	f000 856a 	beq.w	100c7c6 <ull_conn_rx+0xb3e>
		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)) ||
 100bcf2:	f1ba 0f05 	cmp.w	sl, #5
 100bcf6:	f000 858a 	beq.w	100c80e <ull_conn_rx+0xb86>
 100bcfa:	f1ba 0f06 	cmp.w	sl, #6
 100bcfe:	f000 808b 	beq.w	100be18 <ull_conn_rx+0x190>
		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)) ||
 100bd02:	f1ba 0f0d 	cmp.w	sl, #13
 100bd06:	f000 839b 	beq.w	100c440 <ull_conn_rx+0x7b8>
 100bd0a:	f1ba 0f11 	cmp.w	sl, #17
 100bd0e:	d179      	bne.n	100be04 <ull_conn_rx+0x17c>

		break;
#endif /* CONFIG_BT_CTLR_CONN_PARAM_REQ */

	case PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND:
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND,
 100bd10:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100bd14:	2b03      	cmp	r3, #3
 100bd16:	f040 8083 	bne.w	100be20 <ull_conn_rx+0x198>
	switch (rej_ext_ind->reject_opcode) {
 100bd1a:	f896 3024 	ldrb.w	r3, [r6, #36]	; 0x24
 100bd1e:	3b03      	subs	r3, #3
 100bd20:	2b13      	cmp	r3, #19
 100bd22:	f200 80ab 	bhi.w	100be7c <ull_conn_rx+0x1f4>
 100bd26:	e8df f013 	tbh	[pc, r3, lsl #1]
 100bd2a:	061c      	.short	0x061c
 100bd2c:	00a900a9 	.word	0x00a900a9
 100bd30:	00a900a9 	.word	0x00a900a9
 100bd34:	00a900a9 	.word	0x00a900a9
 100bd38:	00a900a9 	.word	0x00a900a9
 100bd3c:	00a900a9 	.word	0x00a900a9
 100bd40:	05e800a9 	.word	0x05e800a9
 100bd44:	00a900a9 	.word	0x00a900a9
 100bd48:	00a900a9 	.word	0x00a900a9
 100bd4c:	00a9063c 	.word	0x00a9063c
 100bd50:	05b1      	.short	0x05b1
 100bd52:	6823      	ldr	r3, [r4, #0]
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100bd54:	2203      	movs	r2, #3
		return 0;
 100bd56:	2000      	movs	r0, #0
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100bd58:	711a      	strb	r2, [r3, #4]
}
 100bd5a:	b005      	add	sp, #20
 100bd5c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	switch (pdu_rx->ll_id) {
 100bd60:	2b00      	cmp	r3, #0
 100bd62:	d149      	bne.n	100bdf8 <ull_conn_rx+0x170>
		if (conn->llcp_enc.pause_rx) {
 100bd64:	f890 3152 	ldrb.w	r3, [r0, #338]	; 0x152
 100bd68:	07db      	lsls	r3, r3, #31
 100bd6a:	d503      	bpl.n	100bd74 <ull_conn_rx+0xec>
			conn->llcp_terminate.reason_peer =
 100bd6c:	233d      	movs	r3, #61	; 0x3d
 100bd6e:	f880 312b 	strb.w	r3, [r0, #299]	; 0x12b
 100bd72:	6822      	ldr	r2, [r4, #0]
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100bd74:	2303      	movs	r3, #3
	return 0;
 100bd76:	2000      	movs	r0, #0
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100bd78:	7113      	strb	r3, [r2, #4]
}
 100bd7a:	b005      	add	sp, #20
 100bd7c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	pdu_rx = (void *)(*rx)->pdu;
 100bd80:	3220      	adds	r2, #32
	switch (opcode) {
 100bd82:	f1ba 0f19 	cmp.w	sl, #25
 100bd86:	d84b      	bhi.n	100be20 <ull_conn_rx+0x198>
 100bd88:	a101      	add	r1, pc, #4	; (adr r1, 100bd90 <ull_conn_rx+0x108>)
 100bd8a:	f851 f02a 	ldr.w	pc, [r1, sl, lsl #2]
 100bd8e:	bf00      	nop
 100bd90:	0100c4d1 	.word	0x0100c4d1
 100bd94:	0100c5b1 	.word	0x0100c5b1
 100bd98:	0100c3f5 	.word	0x0100c3f5
 100bd9c:	0100c6c1 	.word	0x0100c6c1
 100bda0:	0100c7bd 	.word	0x0100c7bd
 100bda4:	0100c805 	.word	0x0100c805
 100bda8:	0100c845 	.word	0x0100c845
 100bdac:	0100c61f 	.word	0x0100c61f
 100bdb0:	0100c4c7 	.word	0x0100c4c7
 100bdb4:	0100c147 	.word	0x0100c147
 100bdb8:	0100c0a9 	.word	0x0100c0a9
 100bdbc:	0100c85d 	.word	0x0100c85d
 100bdc0:	0100c467 	.word	0x0100c467
 100bdc4:	0100c441 	.word	0x0100c441
 100bdc8:	0100c40f 	.word	0x0100c40f
 100bdcc:	0100c3bd 	.word	0x0100c3bd
 100bdd0:	0100c293 	.word	0x0100c293
 100bdd4:	0100bd11 	.word	0x0100bd11
 100bdd8:	0100c075 	.word	0x0100c075
 100bddc:	0100bf77 	.word	0x0100bf77
 100bde0:	0100bf0b 	.word	0x0100bf0b
 100bde4:	0100bf0b 	.word	0x0100bf0b
 100bde8:	0100c011 	.word	0x0100c011
 100bdec:	0100bf95 	.word	0x0100bf95
 100bdf0:	0100c203 	.word	0x0100c203
 100bdf4:	0100c193 	.word	0x0100c193
		if (conn->llcp_enc.pause_rx) {
 100bdf8:	f890 3152 	ldrb.w	r3, [r0, #338]	; 0x152
 100bdfc:	07da      	lsls	r2, r3, #31
 100bdfe:	d401      	bmi.n	100be04 <ull_conn_rx+0x17c>
	int nack = 0;
 100be00:	2000      	movs	r0, #0
 100be02:	e7aa      	b.n	100bd5a <ull_conn_rx+0xd2>
		conn->llcp_terminate.reason_peer =
 100be04:	233d      	movs	r3, #61	; 0x3d
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100be06:	2203      	movs	r2, #3
		return 0;
 100be08:	2000      	movs	r0, #0
		conn->llcp_terminate.reason_peer =
 100be0a:	f885 312b 	strb.w	r3, [r5, #299]	; 0x12b
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100be0e:	6823      	ldr	r3, [r4, #0]
 100be10:	711a      	strb	r2, [r3, #4]
}
 100be12:	b005      	add	sp, #20
 100be14:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_START_ENC_RSP,
 100be18:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100be1c:	2b01      	cmp	r3, #1
 100be1e:	d05f      	beq.n	100bee0 <ull_conn_rx+0x258>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100be20:	485b      	ldr	r0, [pc, #364]	; (100bf90 <ull_conn_rx+0x308>)
 100be22:	f7f9 fefd 	bl	1005c20 <mem_acquire>
	if (!tx) {
 100be26:	2800      	cmp	r0, #0
 100be28:	f000 869c 	beq.w	100cb64 <ull_conn_rx+0xedc>
	pdu->len = offsetof(struct pdu_data_llctrl, unknown_rsp) +
 100be2c:	2302      	movs	r3, #2
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP;
 100be2e:	2107      	movs	r1, #7
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 100be30:	7902      	ldrb	r2, [r0, #4]
	pdu->len = offsetof(struct pdu_data_llctrl, unknown_rsp) +
 100be32:	7143      	strb	r3, [r0, #5]
	    conn->tx_head &&
 100be34:	f8d5 31b0 	ldr.w	r3, [r5, #432]	; 0x1b0
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 100be38:	f042 0203 	orr.w	r2, r2, #3
	pdu->llctrl.unknown_rsp.type = type;
 100be3c:	f880 a008 	strb.w	sl, [r0, #8]
	pdu->ll_id = PDU_DATA_LLID_CTRL;
 100be40:	7102      	strb	r2, [r0, #4]
	pdu->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP;
 100be42:	71c1      	strb	r1, [r0, #7]
	if (
 100be44:	b303      	cbz	r3, 100be88 <ull_conn_rx+0x200>
	    !conn->llcp_enc.pause_tx &&
 100be46:	f895 2152 	ldrb.w	r2, [r5, #338]	; 0x152
	    conn->tx_head &&
 100be4a:	0794      	lsls	r4, r2, #30
 100be4c:	d41c      	bmi.n	100be88 <ull_conn_rx+0x200>
	    !conn->llcp_phy.pause_tx &&
 100be4e:	f895 21ab 	ldrb.w	r2, [r5, #427]	; 0x1ab
 100be52:	07d1      	lsls	r1, r2, #31
 100be54:	d418      	bmi.n	100be88 <ull_conn_rx+0x200>
		if (conn->tx_head == conn->tx_data) {
 100be56:	f8d5 21bc 	ldr.w	r2, [r5, #444]	; 0x1bc
 100be5a:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 100be5c:	bf04      	itt	eq
 100be5e:	681a      	ldreq	r2, [r3, #0]
 100be60:	f8c5 21bc 	streq.w	r2, [r5, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 100be64:	f8d5 21b4 	ldr.w	r2, [r5, #436]	; 0x1b4
 100be68:	b99a      	cbnz	r2, 100be92 <ull_conn_rx+0x20a>
			tx->next = conn->tx_head->next;
 100be6a:	681a      	ldr	r2, [r3, #0]
 100be6c:	6002      	str	r2, [r0, #0]
			conn->tx_head->next = tx;
 100be6e:	6018      	str	r0, [r3, #0]
				conn->tx_ctrl = tx;
 100be70:	6803      	ldr	r3, [r0, #0]
				conn->tx_ctrl_last = tx;
 100be72:	e9c5 006d 	strd	r0, r0, [r5, #436]	; 0x1b4
	if (!tx->next) {
 100be76:	2b00      	cmp	r3, #0
 100be78:	f000 85b3 	beq.w	100c9e2 <ull_conn_rx+0xd5a>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100be7c:	2303      	movs	r3, #3
	return 0;
 100be7e:	2000      	movs	r0, #0
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100be80:	7133      	strb	r3, [r6, #4]
}
 100be82:	b005      	add	sp, #20
 100be84:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (!conn->tx_ctrl) {
 100be88:	f8d5 21b4 	ldr.w	r2, [r5, #436]	; 0x1b4
 100be8c:	2a00      	cmp	r2, #0
 100be8e:	f000 85b1 	beq.w	100c9f4 <ull_conn_rx+0xd6c>
	tx->next = conn->tx_ctrl_last->next;
 100be92:	f8d5 31b8 	ldr.w	r3, [r5, #440]	; 0x1b8
 100be96:	681a      	ldr	r2, [r3, #0]
 100be98:	6002      	str	r2, [r0, #0]
	conn->tx_ctrl_last->next = tx;
 100be9a:	6018      	str	r0, [r3, #0]
	conn->tx_ctrl_last = tx;
 100be9c:	f8c5 01b8 	str.w	r0, [r5, #440]	; 0x1b8
 100bea0:	6803      	ldr	r3, [r0, #0]
}
 100bea2:	e7e8      	b.n	100be76 <ull_conn_rx+0x1ee>
	       (conn->lll.role &&
 100bea4:	075a      	lsls	r2, r3, #29
 100bea6:	f140 829d 	bpl.w	100c3e4 <ull_conn_rx+0x75c>
		 (conn->llcp_enc.refresh &&
 100beaa:	f1ba 0f02 	cmp.w	sl, #2
 100beae:	f000 82a1 	beq.w	100c3f4 <ull_conn_rx+0x76c>
		  (opcode != PDU_DATA_LLCTRL_TYPE_TERMINATE_IND) &&
 100beb2:	f1ba 0f0b 	cmp.w	sl, #11
 100beb6:	f000 864f 	beq.w	100cb58 <ull_conn_rx+0xed0>
		  (opcode != PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP) &&
 100beba:	f1ba 0f03 	cmp.w	sl, #3
 100bebe:	f000 8404 	beq.w	100c6ca <ull_conn_rx+0xa42>
		  (opcode != PDU_DATA_LLCTRL_TYPE_REJECT_EXT_IND)) ||
 100bec2:	f1ba 0f06 	cmp.w	sl, #6
 100bec6:	f47f af1c 	bne.w	100bd02 <ull_conn_rx+0x7a>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_START_ENC_RSP,
 100beca:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100bece:	2b01      	cmp	r3, #1
 100bed0:	d1a6      	bne.n	100be20 <ull_conn_rx+0x198>
			nack = start_enc_rsp_send(conn, NULL);
 100bed2:	2100      	movs	r1, #0
 100bed4:	4628      	mov	r0, r5
 100bed6:	f7ff f9f9 	bl	100b2cc <start_enc_rsp_send>
			if (nack) {
 100beda:	2800      	cmp	r0, #0
 100bedc:	f47f af3d 	bne.w	100bd5a <ull_conn_rx+0xd2>
			conn->llcp_enc.pause_rx = 0U;
 100bee0:	f895 3152 	ldrb.w	r3, [r5, #338]	; 0x152
 100bee4:	f023 0303 	bic.w	r3, r3, #3
 100bee8:	f885 3152 	strb.w	r3, [r5, #338]	; 0x152
		if (conn->llcp_enc.refresh) {
 100beec:	f895 3152 	ldrb.w	r3, [r5, #338]	; 0x152
 100bef0:	075a      	lsls	r2, r3, #29
 100bef2:	d506      	bpl.n	100bf02 <ull_conn_rx+0x27a>
			(*rx)->hdr.type = NODE_RX_TYPE_ENC_REFRESH;
 100bef4:	210b      	movs	r1, #11
 100bef6:	6822      	ldr	r2, [r4, #0]
			conn->llcp_enc.refresh = 0U;
 100bef8:	f36f 0382 	bfc	r3, #2, #1
 100befc:	f885 3152 	strb.w	r3, [r5, #338]	; 0x152
			(*rx)->hdr.type = NODE_RX_TYPE_ENC_REFRESH;
 100bf00:	7111      	strb	r1, [r2, #4]
				break;
			}
		}

		/* Procedure complete */
		conn->procedure_expire = 0U;
 100bf02:	2000      	movs	r0, #0
 100bf04:	f8a5 00cc 	strh.w	r0, [r5, #204]	; 0xcc
		break;
 100bf08:	e727      	b.n	100bd5a <ull_conn_rx+0xd2>

#if defined(CONFIG_BT_CTLR_DATA_LENGTH)
	case PDU_DATA_LLCTRL_TYPE_LENGTH_RSP:
	case PDU_DATA_LLCTRL_TYPE_LENGTH_REQ:
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_LENGTH_REQ,
 100bf0a:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100bf0e:	2b09      	cmp	r3, #9
 100bf10:	d186      	bne.n	100be20 <ull_conn_rx+0x198>
	if (pdu_rx->llctrl.opcode == PDU_DATA_LLCTRL_TYPE_LENGTH_REQ) {
 100bf12:	f1ba 0f14 	cmp.w	sl, #20
 100bf16:	f000 8629 	beq.w	100cb6c <ull_conn_rx+0xee4>
	eff_rx_octets = conn->lll.max_rx_octets;
 100bf1a:	f8b5 305e 	ldrh.w	r3, [r5, #94]	; 0x5e
	    ((conn->llcp_length.req == conn->llcp_length.ack) && tx) ||
 100bf1e:	f895 1198 	ldrb.w	r1, [r5, #408]	; 0x198
	if (/* Local idle, and Peer request then complete the Peer procedure
 100bf22:	f895 2199 	ldrb.w	r2, [r5, #409]	; 0x199
	eff_rx_octets = conn->lll.max_rx_octets;
 100bf26:	9301      	str	r3, [sp, #4]
	eff_tx_octets = conn->lll.max_tx_octets;
 100bf28:	f8b5 305c 	ldrh.w	r3, [r5, #92]	; 0x5c
	if (/* Local idle, and Peer request then complete the Peer procedure
 100bf2c:	428a      	cmp	r2, r1
	eff_rx_time = conn->lll.max_rx_time;
 100bf2e:	f8b5 8062 	ldrh.w	r8, [r5, #98]	; 0x62
	eff_tx_time = conn->lll.max_tx_time;
 100bf32:	f8b5 9060 	ldrh.w	r9, [r5, #96]	; 0x60
	    ((conn->llcp_length.req == conn->llcp_length.ack) && tx) ||
 100bf36:	9100      	str	r1, [sp, #0]
	eff_tx_octets = conn->lll.max_tx_octets;
 100bf38:	9302      	str	r3, [sp, #8]
	if (/* Local idle, and Peer request then complete the Peer procedure
 100bf3a:	f001 8131 	beq.w	100d1a0 <ull_conn_rx+0x1518>
	struct node_tx *tx = NULL;
 100bf3e:	2100      	movs	r1, #0
	     ((((conn->llcp_length.state == LLCP_LENGTH_STATE_REQ) ||
 100bf40:	f895 219a 	ldrb.w	r2, [r5, #410]	; 0x19a
	       tx) ||
 100bf44:	f002 0207 	and.w	r2, r2, #7
 100bf48:	2a02      	cmp	r2, #2
 100bf4a:	f000 8627 	beq.w	100cb9c <ull_conn_rx+0xf14>
 100bf4e:	f896 a023 	ldrb.w	sl, [r6, #35]	; 0x23
		if (pdu_rx->llctrl.opcode != PDU_DATA_LLCTRL_TYPE_LENGTH_RSP) {
 100bf52:	f1ba 0f15 	cmp.w	sl, #21
 100bf56:	f43f af53 	beq.w	100be00 <ull_conn_rx+0x178>
			mem_release(tx, &mem_conn_tx_ctrl.free);
 100bf5a:	4608      	mov	r0, r1
 100bf5c:	490c      	ldr	r1, [pc, #48]	; (100bf90 <ull_conn_rx+0x308>)
 100bf5e:	f7f9 fe79 	bl	1005c54 <mem_release>
			if (conn->llcp_length.state ==
 100bf62:	f895 319a 	ldrb.w	r3, [r5, #410]	; 0x19a
 100bf66:	f003 0307 	and.w	r3, r3, #7
 100bf6a:	2b04      	cmp	r3, #4
 100bf6c:	f47f af48 	bne.w	100be00 <ull_conn_rx+0x178>
				return -EBUSY;
 100bf70:	f06f 000f 	mvn.w	r0, #15
 100bf74:	e6f1      	b.n	100bd5a <ull_conn_rx+0xd2>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PING_RSP, pdu_rx->len)) {
 100bf76:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100bf7a:	2b01      	cmp	r3, #1
 100bf7c:	f47f af50 	bne.w	100be20 <ull_conn_rx+0x198>
		conn->procedure_expire = 0U;
 100bf80:	2000      	movs	r0, #0
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100bf82:	2303      	movs	r3, #3
		conn->procedure_expire = 0U;
 100bf84:	f8a5 00cc 	strh.w	r0, [r5, #204]	; 0xcc
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100bf88:	7133      	strb	r3, [r6, #4]
		break;
 100bf8a:	e6e6      	b.n	100bd5a <ull_conn_rx+0xd2>
 100bf8c:	21001b40 	.word	0x21001b40
 100bf90:	210038cc 	.word	0x210038cc
			nack = phy_rsp_send(conn, *rx, pdu_rx);
		}
		break;

	case PDU_DATA_LLCTRL_TYPE_PHY_RSP:
		if (conn->lll.role ||
 100bf94:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100bf98:	2b00      	cmp	r3, #0
 100bf9a:	f6ff af41 	blt.w	100be20 <ull_conn_rx+0x198>
 100bf9e:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100bfa2:	2b03      	cmp	r3, #3
 100bfa4:	f47f af3c 	bne.w	100be20 <ull_conn_rx+0x198>
		    !pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PHY_RSP, pdu_rx->len)) {
			goto ull_conn_rx_unknown_rsp_send;
		}

		if (!conn->lll.role &&
 100bfa8:	f895 21a9 	ldrb.w	r2, [r5, #425]	; 0x1a9
 100bfac:	f895 31a8 	ldrb.w	r3, [r5, #424]	; 0x1a8
 100bfb0:	429a      	cmp	r2, r3
 100bfb2:	f43f af63 	beq.w	100be7c <ull_conn_rx+0x1f4>
		    (conn->llcp_phy.ack != conn->llcp_phy.req) &&
		    (conn->llcp_phy.state == LLCP_PHY_STATE_RSP_WAIT)) {
 100bfb6:	f895 11aa 	ldrb.w	r1, [r5, #426]	; 0x1aa
		    (conn->llcp_phy.ack != conn->llcp_phy.req) &&
 100bfba:	f001 0303 	and.w	r3, r1, #3
 100bfbe:	2b02      	cmp	r3, #2
 100bfc0:	f47f af5c 	bne.w	100be7c <ull_conn_rx+0x1f4>
			struct pdu_data_llctrl_phy_rsp *p =
				&pdu_rx->llctrl.phy_rsp;

			conn->llcp_phy.state = LLCP_PHY_STATE_UPD;

			conn->llcp_phy.tx &= p->rx_phys;
 100bfc4:	f896 3025 	ldrb.w	r3, [r6, #37]	; 0x25
 100bfc8:	f3c1 0282 	ubfx	r2, r1, #2, #3
 100bfcc:	4013      	ands	r3, r2
			conn->llcp_phy.rx &= p->tx_phys;
 100bfce:	f896 2024 	ldrb.w	r2, [r6, #36]	; 0x24
			conn->llcp_phy.state = LLCP_PHY_STATE_UPD;
 100bfd2:	009b      	lsls	r3, r3, #2
 100bfd4:	f043 0303 	orr.w	r3, r3, #3
			conn->llcp_phy.rx &= p->tx_phys;
 100bfd8:	ea02 1251 	and.w	r2, r2, r1, lsr #5
			conn->llcp_phy.state = LLCP_PHY_STATE_UPD;
 100bfdc:	ea43 1342 	orr.w	r3, r3, r2, lsl #5

			if (!conn->llcp_phy.tx || !conn->llcp_phy.rx) {
 100bfe0:	f013 0f1c 	tst.w	r3, #28
			conn->llcp_phy.state = LLCP_PHY_STATE_UPD;
 100bfe4:	f885 31aa 	strb.w	r3, [r5, #426]	; 0x1aa
			if (!conn->llcp_phy.tx || !conn->llcp_phy.rx) {
 100bfe8:	d002      	beq.n	100bff0 <ull_conn_rx+0x368>
 100bfea:	f013 0fe0 	tst.w	r3, #224	; 0xe0
 100bfee:	d105      	bne.n	100bffc <ull_conn_rx+0x374>
				conn->llcp_phy.tx = 0;
 100bff0:	f895 31aa 	ldrb.w	r3, [r5, #426]	; 0x1aa
 100bff4:	f003 0303 	and.w	r3, r3, #3
 100bff8:	f885 31aa 	strb.w	r3, [r5, #426]	; 0x1aa

			/* pause data packet tx */
			conn->llcp_phy.pause_tx = 1U;

			/* Procedure timeout is stopped */
			conn->procedure_expire = 0U;
 100bffc:	2200      	movs	r2, #0
			conn->llcp_phy.pause_tx = 1U;
 100bffe:	f895 31ab 	ldrb.w	r3, [r5, #427]	; 0x1ab
			conn->procedure_expire = 0U;
 100c002:	f8a5 20cc 	strh.w	r2, [r5, #204]	; 0xcc
			conn->llcp_phy.pause_tx = 1U;
 100c006:	f043 0301 	orr.w	r3, r3, #1
 100c00a:	f885 31ab 	strb.w	r3, [r5, #427]	; 0x1ab
		}

		/* Mark for buffer for release */
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c00e:	e735      	b.n	100be7c <ull_conn_rx+0x1f4>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PHY_REQ, pdu_rx->len)) {
 100c010:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c014:	2b03      	cmp	r3, #3
 100c016:	f47f af03 	bne.w	100be20 <ull_conn_rx+0x198>
		if (!conn->lll.role) {
 100c01a:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c01e:	2b00      	cmp	r3, #0
 100c020:	f2c0 850c 	blt.w	100ca3c <ull_conn_rx+0xdb4>
			if ((conn->llcp_phy.ack !=
 100c024:	f895 21a9 	ldrb.w	r2, [r5, #425]	; 0x1a9
			     conn->llcp_phy.req) &&
 100c028:	f895 11a8 	ldrb.w	r1, [r5, #424]	; 0x1a8
			if ((conn->llcp_phy.ack !=
 100c02c:	428a      	cmp	r2, r1
 100c02e:	d007      	beq.n	100c040 <ull_conn_rx+0x3b8>
			      LLCP_PHY_STATE_RSP_WAIT) ||
 100c030:	f895 31aa 	ldrb.w	r3, [r5, #426]	; 0x1aa
 100c034:	f003 0303 	and.w	r3, r3, #3
			     conn->llcp_phy.req) &&
 100c038:	3b01      	subs	r3, #1
 100c03a:	2b02      	cmp	r3, #2
 100c03c:	f240 87f2 	bls.w	100d024 <ull_conn_rx+0x139c>
			} else if (((((conn->llcp_req - conn->llcp_ack) &
 100c040:	f895 30e8 	ldrb.w	r3, [r5, #232]	; 0xe8
 100c044:	f895 00e9 	ldrb.w	r0, [r5, #233]	; 0xe9
 100c048:	1a1b      	subs	r3, r3, r0
 100c04a:	f003 0303 	and.w	r3, r3, #3
 100c04e:	2b02      	cmp	r3, #2
 100c050:	f000 875e 	beq.w	100cf10 <ull_conn_rx+0x1288>
				     LLCP_ENCRYPTION)) ||
 100c054:	f895 0170 	ldrb.w	r0, [r5, #368]	; 0x170
 100c058:	f895 3171 	ldrb.w	r3, [r5, #369]	; 0x171
 100c05c:	4298      	cmp	r0, r3
 100c05e:	f000 87ed 	beq.w	100d03c <ull_conn_rx+0x13b4>
				nack = reject_ext_ind_send(conn, *rx,
 100c062:	4628      	mov	r0, r5
 100c064:	232a      	movs	r3, #42	; 0x2a
 100c066:	1d31      	adds	r1, r6, #4
 100c068:	2216      	movs	r2, #22
}
 100c06a:	b005      	add	sp, #20
 100c06c:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
				nack = reject_ext_ind_send(conn, *rx,
 100c070:	f7ff b8d8 	b.w	100b224 <reject_ext_ind_send.isra.0>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PING_REQ, pdu_rx->len)) {
 100c074:	f896 4021 	ldrb.w	r4, [r6, #33]	; 0x21
 100c078:	2c01      	cmp	r4, #1
 100c07a:	f47f aed1 	bne.w	100be20 <ull_conn_rx+0x198>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100c07e:	48ec      	ldr	r0, [pc, #944]	; (100c430 <ull_conn_rx+0x7a8>)
 100c080:	f7f9 fdce 	bl	1005c20 <mem_acquire>
	if (!tx) {
 100c084:	4601      	mov	r1, r0
 100c086:	2800      	cmp	r0, #0
 100c088:	f000 856c 	beq.w	100cb64 <ull_conn_rx+0xedc>
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_RSP;
 100c08c:	2213      	movs	r2, #19
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100c08e:	7903      	ldrb	r3, [r0, #4]
	pdu_tx->len = offsetof(struct pdu_data_llctrl, ping_rsp) +
 100c090:	7144      	strb	r4, [r0, #5]
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100c092:	f043 0303 	orr.w	r3, r3, #3
	ctrl_tx_sec_enqueue(conn, tx);
 100c096:	4628      	mov	r0, r5
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100c098:	710b      	strb	r3, [r1, #4]
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PING_RSP;
 100c09a:	71ca      	strb	r2, [r1, #7]
	ctrl_tx_sec_enqueue(conn, tx);
 100c09c:	f7ff f978 	bl	100b390 <ctrl_tx_sec_enqueue>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c0a0:	2303      	movs	r3, #3
	return 0;
 100c0a2:	2000      	movs	r0, #0
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c0a4:	7133      	strb	r3, [r6, #4]
	return 0;
 100c0a6:	e658      	b.n	100bd5a <ull_conn_rx+0xd2>
		if (!conn->lll.role ||
 100c0a8:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c0ac:	2b00      	cmp	r3, #0
 100c0ae:	f6bf aeb7 	bge.w	100be20 <ull_conn_rx+0x198>
 100c0b2:	f896 4021 	ldrb.w	r4, [r6, #33]	; 0x21
 100c0b6:	2c01      	cmp	r4, #1
 100c0b8:	f47f aeb2 	bne.w	100be20 <ull_conn_rx+0x198>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100c0bc:	48dc      	ldr	r0, [pc, #880]	; (100c430 <ull_conn_rx+0x7a8>)
 100c0be:	f7f9 fdaf 	bl	1005c20 <mem_acquire>
		if (!tx) {
 100c0c2:	4603      	mov	r3, r0
 100c0c4:	2800      	cmp	r0, #0
 100c0c6:	f000 854d 	beq.w	100cb64 <ull_conn_rx+0xedc>
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP;
 100c0ca:	200b      	movs	r0, #11
	conn->llcp_enc.pause_rx = 1U;
 100c0cc:	f895 2152 	ldrb.w	r2, [r5, #338]	; 0x152
	conn->lll.enc_rx = 0;
 100c0d0:	f895 107e 	ldrb.w	r1, [r5, #126]	; 0x7e
	conn->llcp_enc.pause_rx = 1U;
 100c0d4:	f022 0205 	bic.w	r2, r2, #5
	conn->lll.enc_rx = 0;
 100c0d8:	f36f 01c3 	bfc	r1, #3, #1
 100c0dc:	f885 107e 	strb.w	r1, [r5, #126]	; 0x7e
	conn->llcp_enc.pause_rx = 1U;
 100c0e0:	f042 0205 	orr.w	r2, r2, #5
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100c0e4:	7919      	ldrb	r1, [r3, #4]
	conn->llcp_enc.pause_rx = 1U;
 100c0e6:	f885 2152 	strb.w	r2, [r5, #338]	; 0x152
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
 100c0ea:	715c      	strb	r4, [r3, #5]
	    conn->tx_head &&
 100c0ec:	f8d5 21b0 	ldr.w	r2, [r5, #432]	; 0x1b0
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100c0f0:	f041 0103 	orr.w	r1, r1, #3
 100c0f4:	7119      	strb	r1, [r3, #4]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP;
 100c0f6:	71d8      	strb	r0, [r3, #7]
	if (
 100c0f8:	2a00      	cmp	r2, #0
 100c0fa:	f000 84f3 	beq.w	100cae4 <ull_conn_rx+0xe5c>
	    !conn->llcp_enc.pause_tx &&
 100c0fe:	f895 1152 	ldrb.w	r1, [r5, #338]	; 0x152
	    conn->tx_head &&
 100c102:	0788      	lsls	r0, r1, #30
 100c104:	f100 84ee 	bmi.w	100cae4 <ull_conn_rx+0xe5c>
	    !conn->llcp_phy.pause_tx &&
 100c108:	f895 11ab 	ldrb.w	r1, [r5, #427]	; 0x1ab
 100c10c:	07c9      	lsls	r1, r1, #31
 100c10e:	f100 84e9 	bmi.w	100cae4 <ull_conn_rx+0xe5c>
		if (conn->tx_head == conn->tx_data) {
 100c112:	f8d5 11bc 	ldr.w	r1, [r5, #444]	; 0x1bc
 100c116:	428a      	cmp	r2, r1
			conn->tx_data = conn->tx_data->next;
 100c118:	bf04      	itt	eq
 100c11a:	6811      	ldreq	r1, [r2, #0]
 100c11c:	f8c5 11bc 	streq.w	r1, [r5, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 100c120:	f8d5 11b4 	ldr.w	r1, [r5, #436]	; 0x1b4
 100c124:	2900      	cmp	r1, #0
 100c126:	f001 8125 	beq.w	100d374 <ull_conn_rx+0x16ec>
	tx->next = conn->tx_ctrl_last->next;
 100c12a:	f8d5 21b8 	ldr.w	r2, [r5, #440]	; 0x1b8
 100c12e:	6811      	ldr	r1, [r2, #0]
 100c130:	6019      	str	r1, [r3, #0]
	conn->tx_ctrl_last->next = tx;
 100c132:	6013      	str	r3, [r2, #0]
	conn->tx_ctrl_last = tx;
 100c134:	f8c5 31b8 	str.w	r3, [r5, #440]	; 0x1b8
	if (!tx->next) {
 100c138:	681a      	ldr	r2, [r3, #0]
 100c13a:	2a00      	cmp	r2, #0
 100c13c:	f47f ae9e 	bne.w	100be7c <ull_conn_rx+0x1f4>
		conn->tx_data_last = tx;
 100c140:	f8c5 31c0 	str.w	r3, [r5, #448]	; 0x1c0
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c144:	e69a      	b.n	100be7c <ull_conn_rx+0x1f4>
		if ((!IS_ENABLED(CONFIG_BT_CTLR_SLAVE_FEAT_REQ) &&
 100c146:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c14a:	2b09      	cmp	r3, #9
 100c14c:	f47f ae68 	bne.w	100be20 <ull_conn_rx+0x198>
	conn->procedure_expire = 0U;
 100c150:	2000      	movs	r0, #0
	       (features[1] << 8) | (features[2] << 16);
 100c152:	f896 3026 	ldrb.w	r3, [r6, #38]	; 0x26
 100c156:	f896 2025 	ldrb.w	r2, [r6, #37]	; 0x25
	feat = ~LL_FEAT_BIT_MASK_VALID | features[0] |
 100c15a:	f896 1024 	ldrb.w	r1, [r6, #36]	; 0x24
	       (features[1] << 8) | (features[2] << 16);
 100c15e:	041b      	lsls	r3, r3, #16
 100c160:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 100c164:	4ab3      	ldr	r2, [pc, #716]	; (100c434 <ull_conn_rx+0x7ac>)
 100c166:	430b      	orrs	r3, r1
	conn->llcp_feature.features &= feat_get(&rsp->features[0]);
 100c168:	f8d5 111c 	ldr.w	r1, [r5, #284]	; 0x11c
	       (features[1] << 8) | (features[2] << 16);
 100c16c:	4313      	orrs	r3, r2
	conn->common.fex_valid = 1U;
 100c16e:	f895 20dc 	ldrb.w	r2, [r5, #220]	; 0xdc
	conn->llcp_feature.features &= feat_get(&rsp->features[0]);
 100c172:	400b      	ands	r3, r1
	conn->llcp_feature.ack = conn->llcp_feature.req;
 100c174:	f895 1118 	ldrb.w	r1, [r5, #280]	; 0x118
	conn->llcp_feature.features &= feat_get(&rsp->features[0]);
 100c178:	f3c3 0310 	ubfx	r3, r3, #0, #17
	conn->common.fex_valid = 1U;
 100c17c:	f042 0201 	orr.w	r2, r2, #1
	conn->llcp_feature.features &= feat_get(&rsp->features[0]);
 100c180:	f8c5 311c 	str.w	r3, [r5, #284]	; 0x11c
	conn->common.fex_valid = 1U;
 100c184:	f885 20dc 	strb.w	r2, [r5, #220]	; 0xdc
	conn->procedure_expire = 0U;
 100c188:	f8a5 00cc 	strh.w	r0, [r5, #204]	; 0xcc
	conn->llcp_feature.ack = conn->llcp_feature.req;
 100c18c:	f885 1119 	strb.w	r1, [r5, #281]	; 0x119
}
 100c190:	e5e3      	b.n	100bd5a <ull_conn_rx+0xd2>
	break;
#endif /* CONFIG_BT_CTLR_PHY */

#if defined(CONFIG_BT_CTLR_MIN_USED_CHAN)
	case PDU_DATA_LLCTRL_TYPE_MIN_USED_CHAN_IND:
		if (conn->lll.role ||
 100c192:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c196:	2b00      	cmp	r3, #0
 100c198:	f6ff ae42 	blt.w	100be20 <ull_conn_rx+0x198>
 100c19c:	f896 7021 	ldrb.w	r7, [r6, #33]	; 0x21
 100c1a0:	2f03      	cmp	r7, #3
 100c1a2:	f47f ae3d 	bne.w	100be20 <ull_conn_rx+0x198>
		if (!conn->lll.role) {
			struct pdu_data_llctrl_min_used_chans_ind *p =
				&pdu_rx->llctrl.min_used_chans_ind;

#if defined(CONFIG_BT_CTLR_PHY)
			if (!(p->phys & (conn->lll.phy_tx |
 100c1a6:	f895 1064 	ldrb.w	r1, [r5, #100]	; 0x64
					 conn->lll.phy_rx))) {
 100c1aa:	f895 3065 	ldrb.w	r3, [r5, #101]	; 0x65
			if (!(p->phys & (conn->lll.phy_tx |
 100c1ae:	f896 2024 	ldrb.w	r2, [r6, #36]	; 0x24
 100c1b2:	430b      	orrs	r3, r1
 100c1b4:	f003 0307 	and.w	r3, r3, #7
 100c1b8:	4213      	tst	r3, r2
 100c1ba:	f43f ae21 	beq.w	100be00 <ull_conn_rx+0x178>
			if (!(p->phys & 0x01)) {
#endif /* !CONFIG_BT_CTLR_PHY */
				break;
			}

			if (((conn->llcp_req - conn->llcp_ack) & 0x03) ==
 100c1be:	f895 30e8 	ldrb.w	r3, [r5, #232]	; 0xe8
 100c1c2:	f895 20e9 	ldrb.w	r2, [r5, #233]	; 0xe9
 100c1c6:	1a9b      	subs	r3, r3, r2
 100c1c8:	f003 0303 	and.w	r3, r3, #3
 100c1cc:	2b02      	cmp	r3, #2
 100c1ce:	f43f ae17 	beq.w	100be00 <ull_conn_rx+0x178>
			    0x02) {
				break;
			}

			memcpy(&conn->llcp.chan_map.chm[0], data_chan_map,
 100c1d2:	2205      	movs	r2, #5
 100c1d4:	4998      	ldr	r1, [pc, #608]	; (100c438 <ull_conn_rx+0x7b0>)
 100c1d6:	f105 00ed 	add.w	r0, r5, #237	; 0xed
 100c1da:	f00a fb6d 	bl	10168b8 <memcpy>
			       sizeof(conn->llcp.chan_map.chm));
			/* conn->llcp.chan_map.instant     = 0; */
			conn->llcp.chan_map.initiate = 1U;

			conn->llcp_type = LLCP_CHAN_MAP;
 100c1de:	2202      	movs	r2, #2
			conn->llcp_ack -= 2U;
 100c1e0:	f895 30e9 	ldrb.w	r3, [r5, #233]	; 0xe9
			conn->llcp_type = LLCP_CHAN_MAP;
 100c1e4:	f885 20ea 	strb.w	r2, [r5, #234]	; 0xea
			conn->llcp_ack -= 2U;
 100c1e8:	3b02      	subs	r3, #2
 100c1ea:	f885 30e9 	strb.w	r3, [r5, #233]	; 0xe9
			conn->llcp.chan_map.initiate = 1U;
 100c1ee:	f895 30ec 	ldrb.w	r3, [r5, #236]	; 0xec
		}

		/* Mark for buffer for release */
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c1f2:	6822      	ldr	r2, [r4, #0]
			conn->llcp.chan_map.initiate = 1U;
 100c1f4:	f043 0301 	orr.w	r3, r3, #1
 100c1f8:	f885 30ec 	strb.w	r3, [r5, #236]	; 0xec
	int nack = 0;
 100c1fc:	2000      	movs	r0, #0
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c1fe:	7117      	strb	r7, [r2, #4]

		break;
 100c200:	e5ab      	b.n	100bd5a <ull_conn_rx+0xd2>
		if (!conn->lll.role ||
 100c202:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c206:	2b00      	cmp	r3, #0
 100c208:	f6bf ae0a 	bge.w	100be20 <ull_conn_rx+0x198>
 100c20c:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c210:	2b05      	cmp	r3, #5
 100c212:	f47f ae05 	bne.w	100be20 <ull_conn_rx+0x198>
	if (!((ind->m_to_s_phy | ind->s_to_m_phy) & 0x07)) {
 100c216:	f896 0024 	ldrb.w	r0, [r6, #36]	; 0x24
 100c21a:	f896 3025 	ldrb.w	r3, [r6, #37]	; 0x25
 100c21e:	ea40 0203 	orr.w	r2, r0, r3
 100c222:	f012 0207 	ands.w	r2, r2, #7
 100c226:	f040 8680 	bne.w	100cf2a <ull_conn_rx+0x12a2>
		if ((conn->llcp_phy.ack == conn->llcp_phy.req) ||
 100c22a:	f895 71a8 	ldrb.w	r7, [r5, #424]	; 0x1a8
 100c22e:	f895 31a9 	ldrb.w	r3, [r5, #425]	; 0x1a9
 100c232:	42bb      	cmp	r3, r7
 100c234:	f43f ae22 	beq.w	100be7c <ull_conn_rx+0x1f4>
		    (conn->llcp_phy.state != LLCP_PHY_STATE_RSP_WAIT)) {
 100c238:	f895 31aa 	ldrb.w	r3, [r5, #426]	; 0x1aa
		if ((conn->llcp_phy.ack == conn->llcp_phy.req) ||
 100c23c:	f003 0303 	and.w	r3, r3, #3
 100c240:	2b02      	cmp	r3, #2
 100c242:	f47f ae1b 	bne.w	100be7c <ull_conn_rx+0x1f4>
		conn->lll.phy_tx_time = conn->lll.phy_tx;
 100c246:	f895 1064 	ldrb.w	r1, [r5, #100]	; 0x64
		conn->llcp_phy.pause_tx = 0U;
 100c24a:	f895 31ab 	ldrb.w	r3, [r5, #427]	; 0x1ab
		conn->lll.phy_tx_time = conn->lll.phy_tx;
 100c24e:	4608      	mov	r0, r1
		conn->llcp_phy.pause_tx = 0U;
 100c250:	f362 0300 	bfi	r3, r2, #0, #1
		conn->lll.phy_tx_time = conn->lll.phy_tx;
 100c254:	f361 1006 	bfi	r0, r1, #4, #3
		conn->llcp_phy.pause_tx = 0U;
 100c258:	f885 31ab 	strb.w	r3, [r5, #427]	; 0x1ab
		if (!conn->llcp_phy.cmd) {
 100c25c:	f013 0304 	ands.w	r3, r3, #4
		conn->llcp_phy.ack = conn->llcp_phy.req;
 100c260:	f885 71a9 	strb.w	r7, [r5, #425]	; 0x1a9
		conn->procedure_expire = 0U;
 100c264:	f8a5 20cc 	strh.w	r2, [r5, #204]	; 0xcc
		conn->lll.phy_tx_time = conn->lll.phy_tx;
 100c268:	f885 0064 	strb.w	r0, [r5, #100]	; 0x64
 100c26c:	f3c1 0102 	ubfx	r1, r1, #0, #3
		if (!conn->llcp_phy.cmd) {
 100c270:	f000 8655 	beq.w	100cf1e <ull_conn_rx+0x1296>
		(*rx)->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
 100c274:	270e      	movs	r7, #14
 100c276:	6823      	ldr	r3, [r4, #0]
	int nack = 0;
 100c278:	4610      	mov	r0, r2
		(*rx)->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
 100c27a:	711f      	strb	r7, [r3, #4]
		p->status = 0U;
 100c27c:	f886 2020 	strb.w	r2, [r6, #32]
		p->tx = conn->lll.phy_tx;
 100c280:	f886 1021 	strb.w	r1, [r6, #33]	; 0x21
		p->rx = conn->lll.phy_rx;
 100c284:	f895 3065 	ldrb.w	r3, [r5, #101]	; 0x65
 100c288:	f3c3 0302 	ubfx	r3, r3, #0, #3
 100c28c:	f886 3022 	strb.w	r3, [r6, #34]	; 0x22
		if (err) {
 100c290:	e563      	b.n	100bd5a <ull_conn_rx+0xd2>
		if (conn->lll.role ||
 100c292:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c296:	2b00      	cmp	r3, #0
 100c298:	f6ff adc2 	blt.w	100be20 <ull_conn_rx+0x198>
 100c29c:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c2a0:	2b18      	cmp	r3, #24
 100c2a2:	f47f adbd 	bne.w	100be20 <ull_conn_rx+0x198>
		if (!conn->lll.role &&
 100c2a6:	f895 2170 	ldrb.w	r2, [r5, #368]	; 0x170
 100c2aa:	f895 3171 	ldrb.w	r3, [r5, #369]	; 0x171
 100c2ae:	429a      	cmp	r2, r3
 100c2b0:	f43f ade4 	beq.w	100be7c <ull_conn_rx+0x1f4>
		    (conn->llcp_conn_param.state ==
 100c2b4:	f895 3172 	ldrb.w	r3, [r5, #370]	; 0x172
		     conn->llcp_conn_param.ack) &&
 100c2b8:	f003 0307 	and.w	r3, r3, #7
 100c2bc:	2b04      	cmp	r3, #4
 100c2be:	f47f addd 	bne.w	100be7c <ull_conn_rx+0x1f4>
			u16_t interval_min = sys_le16_to_cpu(cpr->interval_min);
 100c2c2:	f8b6 e024 	ldrh.w	lr, [r6, #36]	; 0x24
 100c2c6:	fa1f f28e 	uxth.w	r2, lr
			if ((interval_min < 6) ||
 100c2ca:	2a05      	cmp	r2, #5
 100c2cc:	f240 86fe 	bls.w	100d0cc <ull_conn_rx+0x1444>
			u16_t interval_max = sys_le16_to_cpu(cpr->interval_max);
 100c2d0:	f8b6 c026 	ldrh.w	ip, [r6, #38]	; 0x26
 100c2d4:	fa1f f38c 	uxth.w	r3, ip
			if ((interval_min < 6) ||
 100c2d8:	f5b3 6f48 	cmp.w	r3, #3200	; 0xc80
 100c2dc:	f200 86f6 	bhi.w	100d0cc <ull_conn_rx+0x1444>
			    (interval_max > 3200) ||
 100c2e0:	429a      	cmp	r2, r3
 100c2e2:	f200 86f3 	bhi.w	100d0cc <ull_conn_rx+0x1444>
			u16_t latency = sys_le16_to_cpu(cpr->latency);
 100c2e6:	8d37      	ldrh	r7, [r6, #40]	; 0x28
 100c2e8:	b2ba      	uxth	r2, r7
			    (interval_min > interval_max) ||
 100c2ea:	f5b2 7ffa 	cmp.w	r2, #500	; 0x1f4
 100c2ee:	f080 86ed 	bcs.w	100d0cc <ull_conn_rx+0x1444>
			    (latency > 499) ||
 100c2f2:	f640 4976 	movw	r9, #3190	; 0xc76
			u16_t timeout = sys_le16_to_cpu(cpr->timeout);
 100c2f6:	8d70      	ldrh	r0, [r6, #42]	; 0x2a
 100c2f8:	fa1f f880 	uxth.w	r8, r0
			    (latency > 499) ||
 100c2fc:	f1a8 010a 	sub.w	r1, r8, #10
 100c300:	b289      	uxth	r1, r1
 100c302:	4549      	cmp	r1, r9
 100c304:	f200 86e2 	bhi.w	100d0cc <ull_conn_rx+0x1444>
			     ((latency + 1) * interval_max)) ||
 100c308:	fb02 3203 	mla	r2, r2, r3, r3
			    (timeout < 10) || (timeout > 3200) ||
 100c30c:	ebb2 0f88 	cmp.w	r2, r8, lsl #2
 100c310:	f080 86dc 	bcs.w	100d0cc <ull_conn_rx+0x1444>
			     ((latency + 1) * interval_max)) ||
 100c314:	f896 102c 	ldrb.w	r1, [r6, #44]	; 0x2c
 100c318:	428b      	cmp	r3, r1
 100c31a:	f0c0 86d7 	bcc.w	100d0cc <ull_conn_rx+0x1444>
			conn->procedure_expire = 0U;
 100c31e:	2300      	movs	r3, #0
			conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP;
 100c320:	f04f 0801 	mov.w	r8, #1
			conn->llcp_conn_param.preferred_periodicity =
 100c324:	f885 117c 	strb.w	r1, [r5, #380]	; 0x17c
			conn->llcp_conn_param.interval_min = interval_min;
 100c328:	f8a5 e174 	strh.w	lr, [r5, #372]	; 0x174
			conn->llcp_conn_param.interval_max = interval_max;
 100c32c:	f8a5 c176 	strh.w	ip, [r5, #374]	; 0x176
			conn->llcp_conn_param.latency =	latency;
 100c330:	f8a5 7178 	strh.w	r7, [r5, #376]	; 0x178
			conn->llcp_conn_param.timeout =	timeout;
 100c334:	f8a5 017a 	strh.w	r0, [r5, #378]	; 0x17a
			conn->procedure_expire = 0U;
 100c338:	f8a5 30cc 	strh.w	r3, [r5, #204]	; 0xcc
				sys_le16_to_cpu(cpr->reference_conn_event_count);
 100c33c:	f896 102e 	ldrb.w	r1, [r6, #46]	; 0x2e
 100c340:	f896 302d 	ldrb.w	r3, [r6, #45]	; 0x2d
			conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP;
 100c344:	f895 2172 	ldrb.w	r2, [r5, #370]	; 0x172
				sys_le16_to_cpu(cpr->reference_conn_event_count);
 100c348:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
			conn->llcp_conn_param.reference_conn_event_count =
 100c34c:	f8a5 317e 	strh.w	r3, [r5, #382]	; 0x17e
				sys_le16_to_cpu(cpr->offset0);
 100c350:	f896 1030 	ldrb.w	r1, [r6, #48]	; 0x30
 100c354:	f896 302f 	ldrb.w	r3, [r6, #47]	; 0x2f
			conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP;
 100c358:	f368 0202 	bfi	r2, r8, #0, #3
				sys_le16_to_cpu(cpr->offset0);
 100c35c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
			conn->llcp_conn_param.offset0 =
 100c360:	f8a5 3180 	strh.w	r3, [r5, #384]	; 0x180
				sys_le16_to_cpu(cpr->offset1);
 100c364:	f896 1032 	ldrb.w	r1, [r6, #50]	; 0x32
 100c368:	f896 3031 	ldrb.w	r3, [r6, #49]	; 0x31
 100c36c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
			conn->llcp_conn_param.offset1 =
 100c370:	f8a5 3182 	strh.w	r3, [r5, #386]	; 0x182
				sys_le16_to_cpu(cpr->offset2);
 100c374:	f896 1034 	ldrb.w	r1, [r6, #52]	; 0x34
 100c378:	f896 3033 	ldrb.w	r3, [r6, #51]	; 0x33
 100c37c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
			conn->llcp_conn_param.offset2 =
 100c380:	f8a5 3184 	strh.w	r3, [r5, #388]	; 0x184
				sys_le16_to_cpu(cpr->offset3);
 100c384:	f896 1036 	ldrb.w	r1, [r6, #54]	; 0x36
 100c388:	f896 3035 	ldrb.w	r3, [r6, #53]	; 0x35
 100c38c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
			conn->llcp_conn_param.offset3 =
 100c390:	f8a5 3186 	strh.w	r3, [r5, #390]	; 0x186
				sys_le16_to_cpu(cpr->offset4);
 100c394:	f896 1038 	ldrb.w	r1, [r6, #56]	; 0x38
 100c398:	f896 3037 	ldrb.w	r3, [r6, #55]	; 0x37
 100c39c:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
			conn->llcp_conn_param.offset4 =
 100c3a0:	f8a5 3188 	strh.w	r3, [r5, #392]	; 0x188
				sys_le16_to_cpu(cpr->offset5);
 100c3a4:	f896 3039 	ldrb.w	r3, [r6, #57]	; 0x39
 100c3a8:	f896 103a 	ldrb.w	r1, [r6, #58]	; 0x3a
 100c3ac:	6826      	ldr	r6, [r4, #0]
 100c3ae:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
			conn->llcp_conn_param.offset5 =
 100c3b2:	f8a5 318a 	strh.w	r3, [r5, #394]	; 0x18a
			conn->llcp_conn_param.state = LLCP_CPR_STATE_RSP;
 100c3b6:	f885 2172 	strb.w	r2, [r5, #370]	; 0x172
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c3ba:	e55f      	b.n	100be7c <ull_conn_rx+0x1f4>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_CONN_PARAM_REQ,
 100c3bc:	f896 2021 	ldrb.w	r2, [r6, #33]	; 0x21
 100c3c0:	2a18      	cmp	r2, #24
 100c3c2:	f47f ad2d 	bne.w	100be20 <ull_conn_rx+0x198>
		if (conn_upd_curr && (conn_upd_curr != conn)) {
 100c3c6:	4f1d      	ldr	r7, [pc, #116]	; (100c43c <ull_conn_rx+0x7b4>)
 100c3c8:	f8d7 9000 	ldr.w	r9, [r7]
 100c3cc:	f1b9 0f00 	cmp.w	r9, #0
 100c3d0:	f000 8394 	beq.w	100cafc <ull_conn_rx+0xe74>
 100c3d4:	454d      	cmp	r5, r9
 100c3d6:	f000 8391 	beq.w	100cafc <ull_conn_rx+0xe74>
			nack = reject_ext_ind_send(conn, *rx,
 100c3da:	4628      	mov	r0, r5
 100c3dc:	2320      	movs	r3, #32
 100c3de:	220f      	movs	r2, #15
 100c3e0:	1d31      	adds	r1, r6, #4
 100c3e2:	e642      	b.n	100c06a <ull_conn_rx+0x3e2>
		((!conn->llcp_enc.refresh &&
 100c3e4:	f1ba 0f07 	cmp.w	sl, #7
 100c3e8:	f000 8119 	beq.w	100c61e <ull_conn_rx+0x996>
		  (opcode != PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP) &&
 100c3ec:	f1ba 0f02 	cmp.w	sl, #2
 100c3f0:	f47f ad67 	bne.w	100bec2 <ull_conn_rx+0x23a>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_TERMINATE_IND,
 100c3f4:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c3f8:	2b02      	cmp	r3, #2
 100c3fa:	f47f ad11 	bne.w	100be20 <ull_conn_rx+0x198>
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c3fe:	2303      	movs	r3, #3
		terminate_ind_recv(conn, *rx, pdu_rx);
 100c400:	f896 2024 	ldrb.w	r2, [r6, #36]	; 0x24
	int nack = 0;
 100c404:	2000      	movs	r0, #0
	conn->llcp_terminate.reason_peer = pdu->llctrl.terminate_ind.error_code;
 100c406:	f885 212b 	strb.w	r2, [r5, #299]	; 0x12b
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c40a:	7133      	strb	r3, [r6, #4]
}
 100c40c:	e4a5      	b.n	100bd5a <ull_conn_rx+0xd2>
		if (conn->lll.role ||
 100c40e:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c412:	2b00      	cmp	r3, #0
 100c414:	f6ff ad04 	blt.w	100be20 <ull_conn_rx+0x198>
 100c418:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c41c:	2b09      	cmp	r3, #9
 100c41e:	f47f acff 	bne.w	100be20 <ull_conn_rx+0x198>
		nack = feature_rsp_send(conn, *rx, pdu_rx);
 100c422:	4628      	mov	r0, r5
 100c424:	1d31      	adds	r1, r6, #4
}
 100c426:	b005      	add	sp, #20
 100c428:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
		nack = feature_rsp_send(conn, *rx, pdu_rx);
 100c42c:	f7ff b83a 	b.w	100b4a4 <feature_rsp_send.isra.0>
 100c430:	210038cc 	.word	0x210038cc
 100c434:	fffe30d0 	.word	0xfffe30d0
 100c438:	210002ec 	.word	0x210002ec
 100c43c:	210037c0 	.word	0x210037c0
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_REJECT_IND, pdu_rx->len)) {
 100c440:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c444:	2b02      	cmp	r3, #2
 100c446:	f47f aceb 	bne.w	100be20 <ull_conn_rx+0x198>
		conn->procedure_expire = 0U;
 100c44a:	2000      	movs	r0, #0
		conn->llcp_enc.pause_rx = 0U;
 100c44c:	f895 3152 	ldrb.w	r3, [r5, #338]	; 0x152
		conn->llcp_ack = conn->llcp_req;
 100c450:	f895 20e8 	ldrb.w	r2, [r5, #232]	; 0xe8
		conn->llcp_enc.pause_rx = 0U;
 100c454:	f023 0303 	bic.w	r3, r3, #3
 100c458:	f885 3152 	strb.w	r3, [r5, #338]	; 0x152
		conn->procedure_expire = 0U;
 100c45c:	f8a5 00cc 	strh.w	r0, [r5, #204]	; 0xcc
		conn->llcp_ack = conn->llcp_req;
 100c460:	f885 20e9 	strb.w	r2, [r5, #233]	; 0xe9
		break;
 100c464:	e479      	b.n	100bd5a <ull_conn_rx+0xd2>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_VERSION_IND,
 100c466:	f896 4021 	ldrb.w	r4, [r6, #33]	; 0x21
 100c46a:	2c06      	cmp	r4, #6
 100c46c:	f47f acd8 	bne.w	100be20 <ull_conn_rx+0x198>
	if (!conn->llcp_version.tx) {
 100c470:	f895 3122 	ldrb.w	r3, [r5, #290]	; 0x122
 100c474:	07df      	lsls	r7, r3, #31
 100c476:	f140 8495 	bpl.w	100cda4 <ull_conn_rx+0x111c>
	} else if (!conn->llcp_version.rx) {
 100c47a:	f013 0302 	ands.w	r3, r3, #2
 100c47e:	f47f acfd 	bne.w	100be7c <ull_conn_rx+0x1f4>
		conn->llcp_version.ack = conn->llcp_version.req;
 100c482:	f895 2120 	ldrb.w	r2, [r5, #288]	; 0x120
		conn->procedure_expire = 0U;
 100c486:	f8a5 30cc 	strh.w	r3, [r5, #204]	; 0xcc
		conn->llcp_version.ack = conn->llcp_version.req;
 100c48a:	f885 2121 	strb.w	r2, [r5, #289]	; 0x121
	conn->llcp_version.version_number = v->version_number;
 100c48e:	f896 2024 	ldrb.w	r2, [r6, #36]	; 0x24
	conn->llcp_version.rx = 1U;
 100c492:	f895 3122 	ldrb.w	r3, [r5, #290]	; 0x122
	conn->llcp_version.version_number = v->version_number;
 100c496:	f885 2123 	strb.w	r2, [r5, #291]	; 0x123
	conn->llcp_version.company_id = sys_le16_to_cpu(v->company_id);
 100c49a:	f896 1026 	ldrb.w	r1, [r6, #38]	; 0x26
 100c49e:	f896 2025 	ldrb.w	r2, [r6, #37]	; 0x25
	conn->llcp_version.rx = 1U;
 100c4a2:	f043 0302 	orr.w	r3, r3, #2
	conn->llcp_version.company_id = sys_le16_to_cpu(v->company_id);
 100c4a6:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 100c4aa:	f8a5 2124 	strh.w	r2, [r5, #292]	; 0x124
		sys_le16_to_cpu(v->sub_version_number);
 100c4ae:	f896 2027 	ldrb.w	r2, [r6, #39]	; 0x27
 100c4b2:	f896 1028 	ldrb.w	r1, [r6, #40]	; 0x28
	return 0;
 100c4b6:	2000      	movs	r0, #0
		sys_le16_to_cpu(v->sub_version_number);
 100c4b8:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
	conn->llcp_version.sub_version_number =
 100c4bc:	f8a5 2126 	strh.w	r2, [r5, #294]	; 0x126
	conn->llcp_version.rx = 1U;
 100c4c0:	f885 3122 	strb.w	r3, [r5, #290]	; 0x122
	return 0;
 100c4c4:	e449      	b.n	100bd5a <ull_conn_rx+0xd2>
		if (!conn->lll.role ||
 100c4c6:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c4ca:	2b00      	cmp	r3, #0
 100c4cc:	dba4      	blt.n	100c418 <ull_conn_rx+0x790>
 100c4ce:	e4a7      	b.n	100be20 <ull_conn_rx+0x198>
		if (!conn->lll.role ||
 100c4d0:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c4d4:	2b00      	cmp	r3, #0
 100c4d6:	f6bf aca3 	bge.w	100be20 <ull_conn_rx+0x198>
 100c4da:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c4de:	2b0c      	cmp	r3, #12
 100c4e0:	f47f ac9e 	bne.w	100be20 <ull_conn_rx+0x198>
	instant = sys_le16_to_cpu(pdu->llctrl.conn_update_ind.instant);
 100c4e4:	f8b6 002d 	ldrh.w	r0, [r6, #45]	; 0x2d
	if (((instant - conn->lll.event_counter) & 0xFFFF) > 0x7FFF) {
 100c4e8:	8eeb      	ldrh	r3, [r5, #54]	; 0x36
 100c4ea:	1ac3      	subs	r3, r0, r3
 100c4ec:	041b      	lsls	r3, r3, #16
 100c4ee:	f100 859e 	bmi.w	100d02e <ull_conn_rx+0x13a6>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
 100c4f2:	f895 30e8 	ldrb.w	r3, [r5, #232]	; 0xe8
 100c4f6:	f895 20e9 	ldrb.w	r2, [r5, #233]	; 0xe9
 100c4fa:	1a9b      	subs	r3, r3, r2
 100c4fc:	f003 0303 	and.w	r3, r3, #3
 100c500:	2b02      	cmp	r3, #2
 100c502:	f000 8616 	beq.w	100d132 <ull_conn_rx+0x14aa>
	if (!conn_upd_curr) {
 100c506:	4bde      	ldr	r3, [pc, #888]	; (100c880 <ull_conn_rx+0xbf8>)
 100c508:	681a      	ldr	r2, [r3, #0]
 100c50a:	2a00      	cmp	r2, #0
 100c50c:	f000 864b 	beq.w	100d1a6 <ull_conn_rx+0x151e>
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.win_offset) * 1250;
 100c510:	f240 43e2 	movw	r3, #1250	; 0x4e2
	*rx = NULL;
 100c514:	f04f 0c00 	mov.w	ip, #0
	conn->llcp_cu.win_size = pdu->llctrl.conn_update_ind.win_size;
 100c518:	f896 2024 	ldrb.w	r2, [r6, #36]	; 0x24
 100c51c:	f885 2114 	strb.w	r2, [r5, #276]	; 0x114
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.win_offset) * 1250;
 100c520:	f8b6 2025 	ldrh.w	r2, [r6, #37]	; 0x25
 100c524:	fb03 f302 	mul.w	r3, r3, r2
	conn->llcp_cu.win_offset_us =
 100c528:	f8c5 3110 	str.w	r3, [r5, #272]	; 0x110
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.interval);
 100c52c:	f896 2028 	ldrb.w	r2, [r6, #40]	; 0x28
 100c530:	f896 3027 	ldrb.w	r3, [r6, #39]	; 0x27
 100c534:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	conn->llcp_cu.interval =
 100c538:	f8a5 3108 	strh.w	r3, [r5, #264]	; 0x108
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.latency);
 100c53c:	f896 202a 	ldrb.w	r2, [r6, #42]	; 0x2a
 100c540:	f896 3029 	ldrb.w	r3, [r6, #41]	; 0x29
 100c544:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
	conn->llcp_cu.latency =
 100c548:	f8a5 310a 	strh.w	r3, [r5, #266]	; 0x10a
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.timeout);
 100c54c:	f896 202c 	ldrb.w	r2, [r6, #44]	; 0x2c
 100c550:	f896 102b 	ldrb.w	r1, [r6, #43]	; 0x2b
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
 100c554:	f895 3106 	ldrb.w	r3, [r5, #262]	; 0x106
		sys_le16_to_cpu(pdu->llctrl.conn_update_ind.timeout);
 100c558:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
	conn->llcp_cu.ack--;
 100c55c:	f895 2105 	ldrb.w	r2, [r5, #261]	; 0x105
	conn->llcp_cu.timeout =
 100c560:	f8a5 110c 	strh.w	r1, [r5, #268]	; 0x10c
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
 100c564:	f023 0307 	bic.w	r3, r3, #7
	link->mem = conn->llcp_rx;
 100c568:	f8d5 1100 	ldr.w	r1, [r5, #256]	; 0x100
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
 100c56c:	f043 0304 	orr.w	r3, r3, #4
	conn->llcp_cu.ack--;
 100c570:	3a01      	subs	r2, #1
 100c572:	f885 2105 	strb.w	r2, [r5, #261]	; 0x105
	conn->llcp_cu.state = LLCP_CUI_STATE_INPROG;
 100c576:	f885 3106 	strb.w	r3, [r5, #262]	; 0x106
	conn->llcp.conn_upd.instant = instant;
 100c57a:	f8a5 00ec 	strh.w	r0, [r5, #236]	; 0xec
	link->mem = conn->llcp_rx;
 100c57e:	6079      	str	r1, [r7, #4]
	(*rx)->hdr.link = link;
 100c580:	6823      	ldr	r3, [r4, #0]
 100c582:	601f      	str	r7, [r3, #0]
	conn->llcp_rx = *rx;
 100c584:	6823      	ldr	r3, [r4, #0]
 100c586:	f8c5 3100 	str.w	r3, [r5, #256]	; 0x100
	*rx = NULL;
 100c58a:	f8c4 c000 	str.w	ip, [r4]
	if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
 100c58e:	f895 2170 	ldrb.w	r2, [r5, #368]	; 0x170
 100c592:	f895 3171 	ldrb.w	r3, [r5, #369]	; 0x171
 100c596:	4293      	cmp	r3, r2
 100c598:	f43f acb3 	beq.w	100bf02 <ull_conn_rx+0x27a>
	    (conn->llcp_conn_param.state == LLCP_CPR_STATE_RSP_WAIT)) {
 100c59c:	f895 3172 	ldrb.w	r3, [r5, #370]	; 0x172
	if ((conn->llcp_conn_param.req != conn->llcp_conn_param.ack) &&
 100c5a0:	f003 0307 	and.w	r3, r3, #7
 100c5a4:	2b04      	cmp	r3, #4
 100c5a6:	f47f acac 	bne.w	100bf02 <ull_conn_rx+0x27a>
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
 100c5aa:	f885 2171 	strb.w	r2, [r5, #369]	; 0x171
		if (err) {
 100c5ae:	e4a8      	b.n	100bf02 <ull_conn_rx+0x27a>
		if (!conn->lll.role ||
 100c5b0:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c5b4:	2b00      	cmp	r3, #0
 100c5b6:	f6bf ac33 	bge.w	100be20 <ull_conn_rx+0x198>
 100c5ba:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c5be:	2b08      	cmp	r3, #8
 100c5c0:	f47f ac2e 	bne.w	100be20 <ull_conn_rx+0x198>
	instant = sys_le16_to_cpu(pdu->llctrl.chan_map_ind.instant);
 100c5c4:	f8b6 4029 	ldrh.w	r4, [r6, #41]	; 0x29
	if (((instant - conn->lll.event_counter) & 0xffff) > 0x7fff) {
 100c5c8:	8eeb      	ldrh	r3, [r5, #54]	; 0x36
 100c5ca:	1ae3      	subs	r3, r4, r3
 100c5cc:	041f      	lsls	r7, r3, #16
 100c5ce:	f100 852e 	bmi.w	100d02e <ull_conn_rx+0x13a6>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
 100c5d2:	f895 30e8 	ldrb.w	r3, [r5, #232]	; 0xe8
 100c5d6:	f895 20e9 	ldrb.w	r2, [r5, #233]	; 0xe9
 100c5da:	1a9b      	subs	r3, r3, r2
 100c5dc:	f003 0303 	and.w	r3, r3, #3
 100c5e0:	2b02      	cmp	r3, #2
 100c5e2:	f000 85a6 	beq.w	100d132 <ull_conn_rx+0x14aa>
	memcpy(&conn->llcp.chan_map.chm[0], &pdu->llctrl.chan_map_ind.chm[0],
 100c5e6:	2205      	movs	r2, #5
 100c5e8:	f106 0124 	add.w	r1, r6, #36	; 0x24
 100c5ec:	f105 00ed 	add.w	r0, r5, #237	; 0xed
 100c5f0:	f00a f962 	bl	10168b8 <memcpy>
	conn->llcp_type = LLCP_CHAN_MAP;
 100c5f4:	2002      	movs	r0, #2
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c5f6:	2103      	movs	r1, #3
	conn->llcp.chan_map.initiate = 0U;
 100c5f8:	f895 20ec 	ldrb.w	r2, [r5, #236]	; 0xec
	conn->llcp_ack -= 2U;
 100c5fc:	f895 30e9 	ldrb.w	r3, [r5, #233]	; 0xe9
	conn->llcp.chan_map.initiate = 0U;
 100c600:	f36f 0200 	bfc	r2, #0, #1
	conn->llcp_ack -= 2U;
 100c604:	3b02      	subs	r3, #2
	conn->llcp_type = LLCP_CHAN_MAP;
 100c606:	f885 00ea 	strb.w	r0, [r5, #234]	; 0xea
	conn->llcp.chan_map.instant = instant;
 100c60a:	f8a5 40f2 	strh.w	r4, [r5, #242]	; 0xf2
	conn->llcp.chan_map.initiate = 0U;
 100c60e:	f885 20ec 	strb.w	r2, [r5, #236]	; 0xec
	conn->llcp_ack -= 2U;
 100c612:	f885 30e9 	strb.w	r3, [r5, #233]	; 0xe9
	int nack = 0;
 100c616:	2000      	movs	r0, #0
	rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c618:	7131      	strb	r1, [r6, #4]
		if (err) {
 100c61a:	f7ff bb9e 	b.w	100bd5a <ull_conn_rx+0xd2>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_UNKNOWN_RSP,
 100c61e:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c622:	2b02      	cmp	r3, #2
 100c624:	f47f abfc 	bne.w	100be20 <ull_conn_rx+0x198>
		} else if (conn->llcp_conn_param.ack !=
 100c628:	f895 2171 	ldrb.w	r2, [r5, #369]	; 0x171
 100c62c:	f895 3170 	ldrb.w	r3, [r5, #368]	; 0x170
 100c630:	429a      	cmp	r2, r3
 100c632:	f000 8356 	beq.w	100cce2 <ull_conn_rx+0x105a>
			conn->llcp_conn_param.disabled = 1U;
 100c636:	f895 2172 	ldrb.w	r2, [r5, #370]	; 0x172
			if (!conn->lll.role) {
 100c63a:	f995 103d 	ldrsb.w	r1, [r5, #61]	; 0x3d
			conn->llcp_conn_param.disabled = 1U;
 100c63e:	f042 0210 	orr.w	r2, r2, #16
			if (!conn->lll.role) {
 100c642:	2900      	cmp	r1, #0
			conn->llcp_conn_param.disabled = 1U;
 100c644:	f885 2172 	strb.w	r2, [r5, #370]	; 0x172
			if (!conn->lll.role) {
 100c648:	f2c0 8379 	blt.w	100cd3e <ull_conn_rx+0x10b6>
				LL_ASSERT(conn->llcp_cu.req ==
 100c64c:	f895 2104 	ldrb.w	r2, [r5, #260]	; 0x104
 100c650:	f895 3105 	ldrb.w	r3, [r5, #261]	; 0x105
 100c654:	429a      	cmp	r2, r3
 100c656:	d006      	beq.n	100c666 <ull_conn_rx+0x9de>
 100c658:	f241 61d4 	movw	r1, #5844	; 0x16d4
 100c65c:	4889      	ldr	r0, [pc, #548]	; (100c884 <ull_conn_rx+0xbfc>)
 100c65e:	f7f6 ff93 	bl	1003588 <bt_ctlr_assert_handle>
 100c662:	f895 3105 	ldrb.w	r3, [r5, #261]	; 0x105
				conn->llcp_conn_param.state =
 100c666:	2705      	movs	r7, #5
				conn->llcp_cu.win_size = 1U;
 100c668:	2101      	movs	r1, #1
				conn->llcp_cu.win_offset_us = 0U;
 100c66a:	2000      	movs	r0, #0
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c66c:	2603      	movs	r6, #3
				conn->llcp_conn_param.state =
 100c66e:	f895 2172 	ldrb.w	r2, [r5, #370]	; 0x172
				conn->llcp_cu.ack--;
 100c672:	3b01      	subs	r3, #1
				conn->llcp_conn_param.state =
 100c674:	f367 0202 	bfi	r2, r7, #0, #3
				conn->llcp_cu.ack--;
 100c678:	f885 3105 	strb.w	r3, [r5, #261]	; 0x105
				conn->llcp_cu.win_size = 1U;
 100c67c:	f885 1114 	strb.w	r1, [r5, #276]	; 0x114
				conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
 100c680:	f3c2 03c0 	ubfx	r3, r2, #3, #1
				conn->llcp_cu.state = LLCP_CUI_STATE_USE;
 100c684:	f895 1106 	ldrb.w	r1, [r5, #262]	; 0x106
 100c688:	009b      	lsls	r3, r3, #2
 100c68a:	f021 0107 	bic.w	r1, r1, #7
 100c68e:	f043 0301 	orr.w	r3, r3, #1
 100c692:	430b      	orrs	r3, r1
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c694:	6824      	ldr	r4, [r4, #0]
				conn->llcp_cu.interval =
 100c696:	f8b5 1176 	ldrh.w	r1, [r5, #374]	; 0x176
				conn->llcp_conn_param.state =
 100c69a:	f885 2172 	strb.w	r2, [r5, #370]	; 0x172
				conn->llcp_cu.state = LLCP_CUI_STATE_USE;
 100c69e:	f885 3106 	strb.w	r3, [r5, #262]	; 0x106
				conn->llcp_cu.latency =
 100c6a2:	f8b5 2178 	ldrh.w	r2, [r5, #376]	; 0x178
				conn->llcp_cu.timeout =
 100c6a6:	f8b5 317a 	ldrh.w	r3, [r5, #378]	; 0x17a
				conn->llcp_cu.win_offset_us = 0U;
 100c6aa:	f8c5 0110 	str.w	r0, [r5, #272]	; 0x110
				conn->llcp_cu.interval =
 100c6ae:	f8a5 1108 	strh.w	r1, [r5, #264]	; 0x108
				conn->llcp_cu.latency =
 100c6b2:	f8a5 210a 	strh.w	r2, [r5, #266]	; 0x10a
				conn->llcp_cu.timeout =
 100c6b6:	f8a5 310c 	strh.w	r3, [r5, #268]	; 0x10c
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c6ba:	7126      	strb	r6, [r4, #4]
				break;
 100c6bc:	f7ff bb4d 	b.w	100bd5a <ull_conn_rx+0xd2>
		if (!conn->lll.role ||
 100c6c0:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c6c4:	2b00      	cmp	r3, #0
 100c6c6:	f6bf abab 	bge.w	100be20 <ull_conn_rx+0x198>
 100c6ca:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c6ce:	2b17      	cmp	r3, #23
 100c6d0:	f47f aba6 	bne.w	100be20 <ull_conn_rx+0x198>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100c6d4:	486c      	ldr	r0, [pc, #432]	; (100c888 <ull_conn_rx+0xc00>)
 100c6d6:	f7f9 faa3 	bl	1005c20 <mem_acquire>
	if (!tx) {
 100c6da:	4604      	mov	r4, r0
 100c6dc:	2800      	cmp	r0, #0
 100c6de:	f000 8241 	beq.w	100cb64 <ull_conn_rx+0xedc>
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp) +
 100c6e2:	220d      	movs	r2, #13
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_RSP;
 100c6e4:	f04f 0804 	mov.w	r8, #4
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100c6e8:	7903      	ldrb	r3, [r0, #4]
	lll_trng_isr_get(pdu_ctrl_tx->llctrl.enc_rsp.skds,
 100c6ea:	f100 0708 	add.w	r7, r0, #8
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100c6ee:	f043 0303 	orr.w	r3, r3, #3
 100c6f2:	7103      	strb	r3, [r0, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp) +
 100c6f4:	7142      	strb	r2, [r0, #5]
	lll_trng_isr_get(pdu_ctrl_tx->llctrl.enc_rsp.skds,
 100c6f6:	210c      	movs	r1, #12
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_RSP;
 100c6f8:	f880 8007 	strb.w	r8, [r0, #7]
	lll_trng_isr_get(pdu_ctrl_tx->llctrl.enc_rsp.skds,
 100c6fc:	4638      	mov	r0, r7
 100c6fe:	f003 fb35 	bl	100fd6c <lll_trng_isr_get>
	memcpy(&conn->llcp.encryption.skd[8],
 100c702:	4639      	mov	r1, r7
 100c704:	2208      	movs	r2, #8
 100c706:	f105 00f6 	add.w	r0, r5, #246	; 0xf6
 100c70a:	f00a f8d5 	bl	10168b8 <memcpy>
	memcpy(&conn->lll.ccm_rx.iv[4],
 100c70e:	4642      	mov	r2, r8
 100c710:	f104 0110 	add.w	r1, r4, #16
 100c714:	f105 009c 	add.w	r0, r5, #156	; 0x9c
 100c718:	f00a f8ce 	bl	10168b8 <memcpy>
	    conn->tx_head &&
 100c71c:	f8d5 31b0 	ldr.w	r3, [r5, #432]	; 0x1b0
	if (
 100c720:	2b00      	cmp	r3, #0
 100c722:	f000 82ef 	beq.w	100cd04 <ull_conn_rx+0x107c>
	    !conn->llcp_enc.pause_tx &&
 100c726:	f895 2152 	ldrb.w	r2, [r5, #338]	; 0x152
	    conn->tx_head &&
 100c72a:	0790      	lsls	r0, r2, #30
 100c72c:	f100 82ea 	bmi.w	100cd04 <ull_conn_rx+0x107c>
	    !conn->llcp_phy.pause_tx &&
 100c730:	f895 21ab 	ldrb.w	r2, [r5, #427]	; 0x1ab
 100c734:	07d1      	lsls	r1, r2, #31
 100c736:	f100 82e5 	bmi.w	100cd04 <ull_conn_rx+0x107c>
		if (conn->tx_head == conn->tx_data) {
 100c73a:	f8d5 21bc 	ldr.w	r2, [r5, #444]	; 0x1bc
 100c73e:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 100c740:	bf04      	itt	eq
 100c742:	681a      	ldreq	r2, [r3, #0]
 100c744:	f8c5 21bc 	streq.w	r2, [r5, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 100c748:	f8d5 21b4 	ldr.w	r2, [r5, #436]	; 0x1b4
 100c74c:	2a00      	cmp	r2, #0
 100c74e:	f000 85f5 	beq.w	100d33c <ull_conn_rx+0x16b4>
	tx->next = conn->tx_ctrl_last->next;
 100c752:	f8d5 31b8 	ldr.w	r3, [r5, #440]	; 0x1b8
 100c756:	681a      	ldr	r2, [r3, #0]
 100c758:	6022      	str	r2, [r4, #0]
	conn->tx_ctrl_last->next = tx;
 100c75a:	601c      	str	r4, [r3, #0]
	conn->tx_ctrl_last = tx;
 100c75c:	f8c5 41b8 	str.w	r4, [r5, #440]	; 0x1b8
	if (!tx->next) {
 100c760:	6823      	ldr	r3, [r4, #0]
 100c762:	2b00      	cmp	r3, #0
 100c764:	f000 84e1 	beq.w	100d12a <ull_conn_rx+0x14a2>
		conn->llcp.encryption.state = LLCP_ENC_STATE_LTK_WAIT;
 100c768:	2002      	movs	r0, #2
		conn->llcp_type = LLCP_ENCRYPTION;
 100c76a:	2103      	movs	r1, #3
		conn->llcp.encryption.state = LLCP_ENC_STATE_LTK_WAIT;
 100c76c:	f895 20ec 	ldrb.w	r2, [r5, #236]	; 0xec
		conn->llcp_ack -= 2U;
 100c770:	f895 30e9 	ldrb.w	r3, [r5, #233]	; 0xe9
		conn->llcp.encryption.state = LLCP_ENC_STATE_LTK_WAIT;
 100c774:	f360 0201 	bfi	r2, r0, #0, #2
		conn->llcp_ack -= 2U;
 100c778:	3b02      	subs	r3, #2
 100c77a:	f885 30e9 	strb.w	r3, [r5, #233]	; 0xe9
		conn->llcp.encryption.state = LLCP_ENC_STATE_LTK_WAIT;
 100c77e:	f885 20ec 	strb.w	r2, [r5, #236]	; 0xec
		conn->llcp_type = LLCP_ENCRYPTION;
 100c782:	f885 10ea 	strb.w	r1, [r5, #234]	; 0xea
		memcpy(&conn->llcp.encryption.skd[0],
 100c786:	2208      	movs	r2, #8
 100c788:	f106 012e 	add.w	r1, r6, #46	; 0x2e
 100c78c:	f105 00ee 	add.w	r0, r5, #238	; 0xee
 100c790:	f00a f892 	bl	10168b8 <memcpy>
		memcpy(&conn->lll.ccm_rx.iv[0],
 100c794:	2204      	movs	r2, #4
 100c796:	f106 0136 	add.w	r1, r6, #54	; 0x36
 100c79a:	f105 0098 	add.w	r0, r5, #152	; 0x98
 100c79e:	f00a f88b 	bl	10168b8 <memcpy>
		conn->llcp_enc.pause_rx = 1U;
 100c7a2:	f895 3152 	ldrb.w	r3, [r5, #338]	; 0x152
		conn->procedure_expire = conn->procedure_reload;
 100c7a6:	f8b5 20ca 	ldrh.w	r2, [r5, #202]	; 0xca
		conn->llcp_enc.pause_rx = 1U;
 100c7aa:	f043 0301 	orr.w	r3, r3, #1
		nack = enc_rsp_send(conn);
 100c7ae:	2000      	movs	r0, #0
		conn->llcp_enc.pause_rx = 1U;
 100c7b0:	f885 3152 	strb.w	r3, [r5, #338]	; 0x152
		conn->procedure_expire = conn->procedure_reload;
 100c7b4:	f8a5 20cc 	strh.w	r2, [r5, #204]	; 0xcc
		break;
 100c7b8:	f7ff bacf 	b.w	100bd5a <ull_conn_rx+0xd2>
		if (conn->lll.role ||
 100c7bc:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c7c0:	2b00      	cmp	r3, #0
 100c7c2:	f6ff ab2d 	blt.w	100be20 <ull_conn_rx+0x198>
 100c7c6:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c7ca:	2b0d      	cmp	r3, #13
 100c7cc:	f47f ab28 	bne.w	100be20 <ull_conn_rx+0x198>
		memcpy(&conn->llcp.encryption.skd[8],
 100c7d0:	2208      	movs	r2, #8
 100c7d2:	f106 0124 	add.w	r1, r6, #36	; 0x24
 100c7d6:	f105 00f6 	add.w	r0, r5, #246	; 0xf6
 100c7da:	f00a f86d 	bl	10168b8 <memcpy>
		memcpy(&conn->lll.ccm_rx.iv[4],
 100c7de:	2204      	movs	r2, #4
 100c7e0:	f106 012c 	add.w	r1, r6, #44	; 0x2c
 100c7e4:	f105 009c 	add.w	r0, r5, #156	; 0x9c
 100c7e8:	f00a f866 	bl	10168b8 <memcpy>
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c7ec:	2103      	movs	r1, #3
		conn->llcp_enc.pause_rx = 1U;
 100c7ee:	f895 3152 	ldrb.w	r3, [r5, #338]	; 0x152
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c7f2:	6822      	ldr	r2, [r4, #0]
		conn->llcp_enc.pause_rx = 1U;
 100c7f4:	f043 0301 	orr.w	r3, r3, #1
 100c7f8:	f885 3152 	strb.w	r3, [r5, #338]	; 0x152
	int nack = 0;
 100c7fc:	2000      	movs	r0, #0
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c7fe:	7111      	strb	r1, [r2, #4]
		break;
 100c800:	f7ff baab 	b.w	100bd5a <ull_conn_rx+0xd2>
		if (conn->lll.role || (conn->llcp_req == conn->llcp_ack) ||
 100c804:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c808:	2b00      	cmp	r3, #0
 100c80a:	f6ff ab09 	blt.w	100be20 <ull_conn_rx+0x198>
 100c80e:	f895 20e8 	ldrb.w	r2, [r5, #232]	; 0xe8
 100c812:	f895 30e9 	ldrb.w	r3, [r5, #233]	; 0xe9
 100c816:	429a      	cmp	r2, r3
 100c818:	f43f ab02 	beq.w	100be20 <ull_conn_rx+0x198>
 100c81c:	f895 30ea 	ldrb.w	r3, [r5, #234]	; 0xea
 100c820:	2b03      	cmp	r3, #3
 100c822:	f47f aafd 	bne.w	100be20 <ull_conn_rx+0x198>
		    (conn->llcp_type != LLCP_ENCRYPTION) ||
 100c826:	f896 2021 	ldrb.w	r2, [r6, #33]	; 0x21
 100c82a:	2a01      	cmp	r2, #1
 100c82c:	f47f aaf8 	bne.w	100be20 <ull_conn_rx+0x198>
		conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
 100c830:	f895 20ec 	ldrb.w	r2, [r5, #236]	; 0xec
	int nack = 0;
 100c834:	2000      	movs	r0, #0
		conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
 100c836:	f36f 0201 	bfc	r2, #0, #2
 100c83a:	f885 20ec 	strb.w	r2, [r5, #236]	; 0xec
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100c83e:	7133      	strb	r3, [r6, #4]
		break;
 100c840:	f7ff ba8b 	b.w	100bd5a <ull_conn_rx+0xd2>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_START_ENC_RSP,
 100c844:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c848:	2b01      	cmp	r3, #1
 100c84a:	f47f aae9 	bne.w	100be20 <ull_conn_rx+0x198>
		if (conn->lll.role) {
 100c84e:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c852:	2b00      	cmp	r3, #0
 100c854:	f6ff ab3d 	blt.w	100bed2 <ull_conn_rx+0x24a>
 100c858:	f7ff bb42 	b.w	100bee0 <ull_conn_rx+0x258>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP,
 100c85c:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100c860:	2b01      	cmp	r3, #1
 100c862:	f47f aadd 	bne.w	100be20 <ull_conn_rx+0x198>
	} else if (!conn->lll.role) {
 100c866:	f995 303d 	ldrsb.w	r3, [r5, #61]	; 0x3d
 100c86a:	2b00      	cmp	r3, #0
 100c86c:	f280 80ce 	bge.w	100ca0c <ull_conn_rx+0xd84>
		conn->lll.enc_tx = 0;
 100c870:	f895 307e 	ldrb.w	r3, [r5, #126]	; 0x7e
 100c874:	f36f 1304 	bfc	r3, #4, #1
 100c878:	f885 307e 	strb.w	r3, [r5, #126]	; 0x7e
		goto pause_enc_rsp_send_exit;
 100c87c:	f7ff bafe 	b.w	100be7c <ull_conn_rx+0x1f4>
 100c880:	210037c0 	.word	0x210037c0
 100c884:	010187e4 	.word	0x010187e4
 100c888:	210038cc 	.word	0x210038cc
		if (conn->llcp_phy.ack != conn->llcp_phy.req) {
 100c88c:	f895 01a8 	ldrb.w	r0, [r5, #424]	; 0x1a8
 100c890:	f895 31a9 	ldrb.w	r3, [r5, #425]	; 0x1a9
 100c894:	4283      	cmp	r3, r0
 100c896:	f43f aaf1 	beq.w	100be7c <ull_conn_rx+0x1f4>
	if (rej_ext_ind->error_code != BT_HCI_ERR_LL_PROC_COLLISION) {
 100c89a:	f896 2025 	ldrb.w	r2, [r6, #37]	; 0x25
 100c89e:	2a23      	cmp	r2, #35	; 0x23
 100c8a0:	d013      	beq.n	100c8ca <ull_conn_rx+0xc42>
		conn->lll.phy_tx_time = conn->lll.phy_tx;
 100c8a2:	f895 3064 	ldrb.w	r3, [r5, #100]	; 0x64
		conn->procedure_expire = 0U;
 100c8a6:	2400      	movs	r4, #0
		conn->lll.phy_tx_time = conn->lll.phy_tx;
 100c8a8:	4619      	mov	r1, r3
 100c8aa:	f3c3 0302 	ubfx	r3, r3, #0, #3
 100c8ae:	f363 1106 	bfi	r1, r3, #4, #3
		conn->llcp_phy.pause_tx = 0U;
 100c8b2:	f895 31ab 	ldrb.w	r3, [r5, #427]	; 0x1ab
		conn->llcp_phy.ack = conn->llcp_phy.req;
 100c8b6:	f885 01a9 	strb.w	r0, [r5, #425]	; 0x1a9
		conn->llcp_phy.pause_tx = 0U;
 100c8ba:	f36f 0300 	bfc	r3, #0, #1
		conn->lll.phy_tx_time = conn->lll.phy_tx;
 100c8be:	f885 1064 	strb.w	r1, [r5, #100]	; 0x64
		conn->llcp_phy.pause_tx = 0U;
 100c8c2:	f885 31ab 	strb.w	r3, [r5, #427]	; 0x1ab
		conn->procedure_expire = 0U;
 100c8c6:	f8a5 40cc 	strh.w	r4, [r5, #204]	; 0xcc
	if (!conn->llcp_phy.cmd) {
 100c8ca:	f895 31ab 	ldrb.w	r3, [r5, #427]	; 0x1ab
 100c8ce:	0759      	lsls	r1, r3, #29
 100c8d0:	f57f aad4 	bpl.w	100be7c <ull_conn_rx+0x1f4>
	rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
 100c8d4:	230e      	movs	r3, #14
	p->status = rej_ext_ind->error_code;
 100c8d6:	f886 2020 	strb.w	r2, [r6, #32]
	rx->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
 100c8da:	7133      	strb	r3, [r6, #4]
	p->tx = conn->lll.phy_tx;
 100c8dc:	f895 3064 	ldrb.w	r3, [r5, #100]	; 0x64
	int nack = 0;
 100c8e0:	2000      	movs	r0, #0
	p->tx = conn->lll.phy_tx;
 100c8e2:	f3c3 0302 	ubfx	r3, r3, #0, #3
 100c8e6:	f886 3021 	strb.w	r3, [r6, #33]	; 0x21
	p->rx = conn->lll.phy_rx;
 100c8ea:	f895 3065 	ldrb.w	r3, [r5, #101]	; 0x65
 100c8ee:	f3c3 0302 	ubfx	r3, r3, #0, #3
 100c8f2:	f886 3022 	strb.w	r3, [r6, #34]	; 0x22
	if (err) {
 100c8f6:	f7ff ba30 	b.w	100bd5a <ull_conn_rx+0xd2>
		if (conn->llcp_conn_param.ack != conn->llcp_conn_param.req) {
 100c8fa:	f895 2171 	ldrb.w	r2, [r5, #369]	; 0x171
 100c8fe:	f895 3170 	ldrb.w	r3, [r5, #368]	; 0x170
 100c902:	429a      	cmp	r2, r3
 100c904:	f43f aaba 	beq.w	100be7c <ull_conn_rx+0x1f4>
	if (!lll->role && (rej_ext_ind->error_code ==
 100c908:	f995 203d 	ldrsb.w	r2, [r5, #61]	; 0x3d
 100c90c:	2a00      	cmp	r2, #0
 100c90e:	f896 2025 	ldrb.w	r2, [r6, #37]	; 0x25
 100c912:	f2c0 84fb 	blt.w	100d30c <ull_conn_rx+0x1684>
 100c916:	2a1a      	cmp	r2, #26
 100c918:	f000 8571 	beq.w	100d3fe <ull_conn_rx+0x1776>
	if (conn->llcp_conn_param.state == LLCP_CPR_STATE_RSP_WAIT) {
 100c91c:	f895 2172 	ldrb.w	r2, [r5, #370]	; 0x172
 100c920:	f002 0107 	and.w	r1, r2, #7
 100c924:	2904      	cmp	r1, #4
 100c926:	f000 8510 	beq.w	100d34a <ull_conn_rx+0x16c2>
	if (!conn->llcp_conn_param.cmd) {
 100c92a:	0713      	lsls	r3, r2, #28
 100c92c:	f57f aaa6 	bpl.w	100be7c <ull_conn_rx+0x1f4>
	rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
 100c930:	210a      	movs	r1, #10
		      lll->interval * 125U / 1000;
 100c932:	237d      	movs	r3, #125	; 0x7d
 100c934:	f44f 747a 	mov.w	r4, #1000	; 0x3e8
	cu->status = rej_ext_ind->error_code;
 100c938:	f896 2025 	ldrb.w	r2, [r6, #37]	; 0x25
	rx->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
 100c93c:	7131      	strb	r1, [r6, #4]
	cu->status = rej_ext_ind->error_code;
 100c93e:	f886 2020 	strb.w	r2, [r6, #32]
	cu->interval = lll->interval;
 100c942:	8de9      	ldrh	r1, [r5, #46]	; 0x2e
	cu->timeout = conn->supervision_reload *
 100c944:	f8b5 20c6 	ldrh.w	r2, [r5, #198]	; 0xc6
	cu->latency = lll->latency;
 100c948:	8e28      	ldrh	r0, [r5, #48]	; 0x30
	cu->timeout = conn->supervision_reload *
 100c94a:	fb01 f202 	mul.w	r2, r1, r2
		      lll->interval * 125U / 1000;
 100c94e:	fb03 f302 	mul.w	r3, r3, r2
 100c952:	fbb3 f3f4 	udiv	r3, r3, r4
	cu->latency = lll->latency;
 100c956:	84b0      	strh	r0, [r6, #36]	; 0x24
	cu->interval = lll->interval;
 100c958:	8471      	strh	r1, [r6, #34]	; 0x22
	int nack = 0;
 100c95a:	2000      	movs	r0, #0
	cu->timeout = conn->supervision_reload *
 100c95c:	84f3      	strh	r3, [r6, #38]	; 0x26
	if (err) {
 100c95e:	f7ff b9fc 	b.w	100bd5a <ull_conn_rx+0xd2>
		if ((conn->llcp_ack != conn->llcp_req) &&
 100c962:	f895 20e8 	ldrb.w	r2, [r5, #232]	; 0xe8
 100c966:	f895 30e9 	ldrb.w	r3, [r5, #233]	; 0xe9
 100c96a:	4293      	cmp	r3, r2
 100c96c:	f43f aa86 	beq.w	100be7c <ull_conn_rx+0x1f4>
 100c970:	f895 30ea 	ldrb.w	r3, [r5, #234]	; 0xea
 100c974:	2b03      	cmp	r3, #3
 100c976:	f47f aa81 	bne.w	100be7c <ull_conn_rx+0x1f4>
	conn->procedure_expire = 0U;
 100c97a:	2000      	movs	r0, #0
	pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_IND;
 100c97c:	210d      	movs	r1, #13
	conn->llcp_enc.pause_rx = 0U;
 100c97e:	f895 3152 	ldrb.w	r3, [r5, #338]	; 0x152
	conn->llcp_ack = conn->llcp_req;
 100c982:	f885 20e9 	strb.w	r2, [r5, #233]	; 0xe9
	conn->llcp_enc.pause_rx = 0U;
 100c986:	f023 0303 	bic.w	r3, r3, #3
 100c98a:	f885 3152 	strb.w	r3, [r5, #338]	; 0x152
	conn->procedure_expire = 0U;
 100c98e:	f8a5 00cc 	strh.w	r0, [r5, #204]	; 0xcc
	pdu_rx->llctrl.reject_ind.error_code = rej_ext_ind->error_code;
 100c992:	f896 3025 	ldrb.w	r3, [r6, #37]	; 0x25
	pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_REJECT_IND;
 100c996:	f886 1023 	strb.w	r1, [r6, #35]	; 0x23
	pdu_rx->llctrl.reject_ind.error_code = rej_ext_ind->error_code;
 100c99a:	f886 3024 	strb.w	r3, [r6, #36]	; 0x24
 100c99e:	f7ff b9dc 	b.w	100bd5a <ull_conn_rx+0xd2>
		if (conn->llcp_length.ack != conn->llcp_length.req) {
 100c9a2:	f895 3198 	ldrb.w	r3, [r5, #408]	; 0x198
 100c9a6:	f895 2199 	ldrb.w	r2, [r5, #409]	; 0x199
 100c9aa:	429a      	cmp	r2, r3
 100c9ac:	f43f aa66 	beq.w	100be7c <ull_conn_rx+0x1f4>
	pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
 100c9b0:	2109      	movs	r1, #9
	conn->procedure_expire = 0U;
 100c9b2:	2000      	movs	r0, #0
	pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 100c9b4:	2215      	movs	r2, #21
	conn->llcp_length.ack = conn->llcp_length.req;
 100c9b6:	f885 3199 	strb.w	r3, [r5, #409]	; 0x199
	conn->procedure_expire = 0U;
 100c9ba:	f8a5 00cc 	strh.w	r0, [r5, #204]	; 0xcc
	pdu_rx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
 100c9be:	f886 1021 	strb.w	r1, [r6, #33]	; 0x21
	lr->max_rx_octets = sys_cpu_to_le16(conn->lll.max_rx_octets);
 100c9c2:	f8b5 305e 	ldrh.w	r3, [r5, #94]	; 0x5e
	lr->max_tx_octets = sys_cpu_to_le16(conn->lll.max_tx_octets);
 100c9c6:	f8b5 405c 	ldrh.w	r4, [r5, #92]	; 0x5c
	lr->max_rx_time = sys_cpu_to_le16(conn->lll.max_rx_time);
 100c9ca:	f8b5 1062 	ldrh.w	r1, [r5, #98]	; 0x62
	lr->max_rx_octets = sys_cpu_to_le16(conn->lll.max_rx_octets);
 100c9ce:	84b3      	strh	r3, [r6, #36]	; 0x24
	lr->max_tx_time = sys_cpu_to_le16(conn->lll.max_tx_time);
 100c9d0:	f8b5 3060 	ldrh.w	r3, [r5, #96]	; 0x60
	lr->max_tx_octets = sys_cpu_to_le16(conn->lll.max_tx_octets);
 100c9d4:	8534      	strh	r4, [r6, #40]	; 0x28
	lr->max_rx_time = sys_cpu_to_le16(conn->lll.max_rx_time);
 100c9d6:	84f1      	strh	r1, [r6, #38]	; 0x26
	lr->max_tx_time = sys_cpu_to_le16(conn->lll.max_tx_time);
 100c9d8:	8573      	strh	r3, [r6, #42]	; 0x2a
	pdu_rx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 100c9da:	f886 2023 	strb.w	r2, [r6, #35]	; 0x23
	if (err) {
 100c9de:	f7ff b9bc 	b.w	100bd5a <ull_conn_rx+0xd2>
		conn->tx_data_last = tx;
 100c9e2:	f8c5 01c0 	str.w	r0, [r5, #448]	; 0x1c0
 100c9e6:	f7ff ba49 	b.w	100be7c <ull_conn_rx+0x1f4>
		((!conn->llcp_enc.refresh &&
 100c9ea:	f1ba 0f02 	cmp.w	sl, #2
 100c9ee:	f47f a980 	bne.w	100bcf2 <ull_conn_rx+0x6a>
 100c9f2:	e4ff      	b.n	100c3f4 <ull_conn_rx+0x76c>
			tx->next = conn->tx_head;
 100c9f4:	6003      	str	r3, [r0, #0]
				conn->tx_ctrl = tx;
 100c9f6:	e9c5 006c 	strd	r0, r0, [r5, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 100c9fa:	f8c5 01b8 	str.w	r0, [r5, #440]	; 0x1b8
 100c9fe:	f7ff ba3a 	b.w	100be76 <ull_conn_rx+0x1ee>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP,
 100ca02:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100ca06:	2b01      	cmp	r3, #1
 100ca08:	f47f aa0a 	bne.w	100be20 <ull_conn_rx+0x198>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100ca0c:	48e2      	ldr	r0, [pc, #904]	; (100cd98 <ull_conn_rx+0x1110>)
 100ca0e:	f7f9 f907 	bl	1005c20 <mem_acquire>
		if (!tx) {
 100ca12:	4603      	mov	r3, r0
 100ca14:	2800      	cmp	r0, #0
 100ca16:	f000 80a5 	beq.w	100cb64 <ull_conn_rx+0xedc>
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
 100ca1a:	2401      	movs	r4, #1
	conn->llcp_enc.pause_rx = 1U;
 100ca1c:	f895 1152 	ldrb.w	r1, [r5, #338]	; 0x152
	conn->lll.enc_rx = 0;
 100ca20:	f895 207e 	ldrb.w	r2, [r5, #126]	; 0x7e
	conn->llcp_enc.pause_rx = 1U;
 100ca24:	4321      	orrs	r1, r4
	conn->lll.enc_rx = 0;
 100ca26:	f022 0218 	bic.w	r2, r2, #24
	conn->llcp_enc.pause_rx = 1U;
 100ca2a:	f885 1152 	strb.w	r1, [r5, #338]	; 0x152
	conn->lll.enc_rx = 0;
 100ca2e:	f885 207e 	strb.w	r2, [r5, #126]	; 0x7e
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP;
 100ca32:	200b      	movs	r0, #11
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100ca34:	7919      	ldrb	r1, [r3, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_rsp);
 100ca36:	715c      	strb	r4, [r3, #5]
 100ca38:	f7ff bb58 	b.w	100c0ec <ull_conn_rx+0x464>
	tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100ca3c:	48d6      	ldr	r0, [pc, #856]	; (100cd98 <ull_conn_rx+0x1110>)
 100ca3e:	f7f9 f8ef 	bl	1005c20 <mem_acquire>
	if (!tx) {
 100ca42:	4603      	mov	r3, r0
 100ca44:	2800      	cmp	r0, #0
 100ca46:	f000 808d 	beq.w	100cb64 <ull_conn_rx+0xedc>
	conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
 100ca4a:	2002      	movs	r0, #2
 100ca4c:	f895 21aa 	ldrb.w	r2, [r5, #426]	; 0x1aa
	if (conn->llcp_phy.ack ==
 100ca50:	f895 11a9 	ldrb.w	r1, [r5, #425]	; 0x1a9
	conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
 100ca54:	f360 0201 	bfi	r2, r0, #0, #2
	if (conn->llcp_phy.ack ==
 100ca58:	f895 01a8 	ldrb.w	r0, [r5, #424]	; 0x1a8
	conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
 100ca5c:	f885 21aa 	strb.w	r2, [r5, #426]	; 0x1aa
	if (conn->llcp_phy.ack ==
 100ca60:	4288      	cmp	r0, r1
 100ca62:	d118      	bne.n	100ca96 <ull_conn_rx+0xe0e>
			conn->phy_pref_rx;
 100ca64:	f895 41ac 	ldrb.w	r4, [r5, #428]	; 0x1ac
		conn->llcp_phy.tx =
 100ca68:	f8b5 11aa 	ldrh.w	r1, [r5, #426]	; 0x1aa
 100ca6c:	f004 0207 	and.w	r2, r4, #7
 100ca70:	0092      	lsls	r2, r2, #2
 100ca72:	f3c4 1402 	ubfx	r4, r4, #4, #3
 100ca76:	f421 619f 	bic.w	r1, r1, #1272	; 0x4f8
 100ca7a:	f021 0104 	bic.w	r1, r1, #4
 100ca7e:	ea42 1244 	orr.w	r2, r2, r4, lsl #5
 100ca82:	430a      	orrs	r2, r1
		conn->procedure_expire =
 100ca84:	f8b5 10ca 	ldrh.w	r1, [r5, #202]	; 0xca
		conn->llcp_phy.ack--;
 100ca88:	3801      	subs	r0, #1
 100ca8a:	f885 01a9 	strb.w	r0, [r5, #425]	; 0x1a9
		conn->llcp_phy.tx =
 100ca8e:	f8a5 21aa 	strh.w	r2, [r5, #426]	; 0x1aa
		conn->procedure_expire =
 100ca92:	f8a5 10cc 	strh.w	r1, [r5, #204]	; 0xcc
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, phy_rsp) +
 100ca96:	2703      	movs	r7, #3
	conn->llcp_phy.rx &= p->tx_phys;
 100ca98:	f895 11aa 	ldrb.w	r1, [r5, #426]	; 0x1aa
	conn->llcp_phy.tx &= p->rx_phys;
 100ca9c:	f896 2025 	ldrb.w	r2, [r6, #37]	; 0x25
 100caa0:	f3c1 0482 	ubfx	r4, r1, #2, #3
 100caa4:	4022      	ands	r2, r4
	conn->llcp_phy.rx &= p->tx_phys;
 100caa6:	f896 4024 	ldrb.w	r4, [r6, #36]	; 0x24
	conn->llcp_phy.tx &= p->rx_phys;
 100caaa:	0092      	lsls	r2, r2, #2
	conn->llcp_phy.rx &= p->tx_phys;
 100caac:	ea04 1451 	and.w	r4, r4, r1, lsr #5
	conn->llcp_phy.tx &= p->rx_phys;
 100cab0:	ea42 1244 	orr.w	r2, r2, r4, lsl #5
 100cab4:	4039      	ands	r1, r7
 100cab6:	430a      	orrs	r2, r1
 100cab8:	f885 21aa 	strb.w	r2, [r5, #426]	; 0x1aa
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, phy_rsp) +
 100cabc:	715f      	strb	r7, [r3, #5]
	pdu_ctrl_tx->llctrl.phy_rsp.tx_phys = conn->phy_pref_tx;
 100cabe:	f895 21ac 	ldrb.w	r2, [r5, #428]	; 0x1ac
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_RSP;
 100cac2:	2017      	movs	r0, #23
	pdu_ctrl_tx->llctrl.phy_rsp.rx_phys = conn->phy_pref_rx;
 100cac4:	4614      	mov	r4, r2
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100cac6:	7919      	ldrb	r1, [r3, #4]
	pdu_ctrl_tx->llctrl.phy_rsp.tx_phys = conn->phy_pref_tx;
 100cac8:	f3c2 0202 	ubfx	r2, r2, #0, #3
 100cacc:	721a      	strb	r2, [r3, #8]
	    conn->tx_head &&
 100cace:	f8d5 21b0 	ldr.w	r2, [r5, #432]	; 0x1b0
	pdu_ctrl_tx->llctrl.phy_rsp.rx_phys = conn->phy_pref_rx;
 100cad2:	f3c4 1402 	ubfx	r4, r4, #4, #3
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100cad6:	4339      	orrs	r1, r7
	pdu_ctrl_tx->llctrl.phy_rsp.rx_phys = conn->phy_pref_rx;
 100cad8:	725c      	strb	r4, [r3, #9]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100cada:	7119      	strb	r1, [r3, #4]
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_PHY_RSP;
 100cadc:	71d8      	strb	r0, [r3, #7]
	if (
 100cade:	2a00      	cmp	r2, #0
 100cae0:	f47f ab0d 	bne.w	100c0fe <ull_conn_rx+0x476>
		if (!conn->tx_ctrl) {
 100cae4:	f8d5 11b4 	ldr.w	r1, [r5, #436]	; 0x1b4
 100cae8:	2900      	cmp	r1, #0
 100caea:	f47f ab1e 	bne.w	100c12a <ull_conn_rx+0x4a2>
			tx->next = conn->tx_head;
 100caee:	601a      	str	r2, [r3, #0]
				conn->tx_ctrl = tx;
 100caf0:	e9c5 336c 	strd	r3, r3, [r5, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 100caf4:	f8c5 31b8 	str.w	r3, [r5, #440]	; 0x1b8
 100caf8:	f7ff bb1e 	b.w	100c138 <ull_conn_rx+0x4b0>
		if (!conn->lll.role) {
 100cafc:	f995 203d 	ldrsb.w	r2, [r5, #61]	; 0x3d
 100cb00:	2a00      	cmp	r2, #0
 100cb02:	f2c0 810a 	blt.w	100cd1a <ull_conn_rx+0x1092>
					conn->llcp_conn_param.ack) &&
 100cb06:	f895 2171 	ldrb.w	r2, [r5, #369]	; 0x171
 100cb0a:	4611      	mov	r1, r2
 100cb0c:	9200      	str	r2, [sp, #0]
			if ((conn->llcp_conn_param.req !=
 100cb0e:	f895 2170 	ldrb.w	r2, [r5, #368]	; 0x170
 100cb12:	428a      	cmp	r2, r1
 100cb14:	d009      	beq.n	100cb2a <ull_conn_rx+0xea2>
			    ((conn->llcp_conn_param.state ==
 100cb16:	f895 2172 	ldrb.w	r2, [r5, #370]	; 0x172
					conn->llcp_conn_param.ack) &&
 100cb1a:	f012 0207 	ands.w	r2, r2, #7
 100cb1e:	f000 8279 	beq.w	100d014 <ull_conn_rx+0x138c>
			      LLCP_CPR_STATE_REQ) ||
 100cb22:	3a04      	subs	r2, #4
 100cb24:	2a01      	cmp	r2, #1
 100cb26:	f240 8275 	bls.w	100d014 <ull_conn_rx+0x138c>
			} else if (((((conn->llcp_req - conn->llcp_ack) &
 100cb2a:	f895 20e8 	ldrb.w	r2, [r5, #232]	; 0xe8
 100cb2e:	f895 10e9 	ldrb.w	r1, [r5, #233]	; 0xe9
 100cb32:	1a52      	subs	r2, r2, r1
 100cb34:	f002 0203 	and.w	r2, r2, #3
 100cb38:	2a02      	cmp	r2, #2
 100cb3a:	f000 834f 	beq.w	100d1dc <ull_conn_rx+0x1554>
				    (conn->llcp_type != LLCP_ENCRYPTION)) ||
 100cb3e:	f895 11a8 	ldrb.w	r1, [r5, #424]	; 0x1a8
 100cb42:	f895 21a9 	ldrb.w	r2, [r5, #425]	; 0x1a9
 100cb46:	4291      	cmp	r1, r2
 100cb48:	f000 834e 	beq.w	100d1e8 <ull_conn_rx+0x1560>
				nack = reject_ext_ind_send(conn, *rx,
 100cb4c:	4628      	mov	r0, r5
 100cb4e:	232a      	movs	r3, #42	; 0x2a
 100cb50:	220f      	movs	r2, #15
 100cb52:	1d31      	adds	r1, r6, #4
 100cb54:	f7ff ba89 	b.w	100c06a <ull_conn_rx+0x3e2>
		if (!pdu_len_cmp(PDU_DATA_LLCTRL_TYPE_PAUSE_ENC_RSP,
 100cb58:	f896 3021 	ldrb.w	r3, [r6, #33]	; 0x21
 100cb5c:	2b01      	cmp	r3, #1
 100cb5e:	f47f a95f 	bne.w	100be20 <ull_conn_rx+0x198>
 100cb62:	e685      	b.n	100c870 <ull_conn_rx+0xbe8>
		return -ENOBUFS;
 100cb64:	f06f 0036 	mvn.w	r0, #54	; 0x36
 100cb68:	f7ff b8f7 	b.w	100bd5a <ull_conn_rx+0xd2>
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100cb6c:	488a      	ldr	r0, [pc, #552]	; (100cd98 <ull_conn_rx+0x1110>)
 100cb6e:	f7f9 f857 	bl	1005c20 <mem_acquire>
		if (!tx) {
 100cb72:	4601      	mov	r1, r0
 100cb74:	2800      	cmp	r0, #0
 100cb76:	d0f5      	beq.n	100cb64 <ull_conn_rx+0xedc>
	eff_rx_octets = conn->lll.max_rx_octets;
 100cb78:	f8b5 305e 	ldrh.w	r3, [r5, #94]	; 0x5e
	    ((conn->llcp_length.req == conn->llcp_length.ack) && tx) ||
 100cb7c:	f895 0198 	ldrb.w	r0, [r5, #408]	; 0x198
 100cb80:	f895 2199 	ldrb.w	r2, [r5, #409]	; 0x199
	eff_rx_octets = conn->lll.max_rx_octets;
 100cb84:	9301      	str	r3, [sp, #4]
	eff_tx_octets = conn->lll.max_tx_octets;
 100cb86:	f8b5 305c 	ldrh.w	r3, [r5, #92]	; 0x5c
	if (/* Local idle, and Peer request then complete the Peer procedure
 100cb8a:	4290      	cmp	r0, r2
	eff_rx_time = conn->lll.max_rx_time;
 100cb8c:	f8b5 8062 	ldrh.w	r8, [r5, #98]	; 0x62
	eff_tx_time = conn->lll.max_tx_time;
 100cb90:	f8b5 9060 	ldrh.w	r9, [r5, #96]	; 0x60
	    ((conn->llcp_length.req == conn->llcp_length.ack) && tx) ||
 100cb94:	9000      	str	r0, [sp, #0]
	eff_tx_octets = conn->lll.max_tx_octets;
 100cb96:	9302      	str	r3, [sp, #8]
	if (/* Local idle, and Peer request then complete the Peer procedure
 100cb98:	f040 8408 	bne.w	100d3ac <ull_conn_rx+0x1724>
		max_rx_octets = sys_le16_to_cpu(lr->max_rx_octets);
 100cb9c:	8cb2      	ldrh	r2, [r6, #36]	; 0x24
		if (max_rx_octets >= PDU_DC_PAYLOAD_SIZE_MIN) {
 100cb9e:	2a1a      	cmp	r2, #26
 100cba0:	f240 8236 	bls.w	100d010 <ull_conn_rx+0x1388>
			eff_tx_octets = MIN(max_rx_octets,
 100cba4:	f8b5 00d6 	ldrh.w	r0, [r5, #214]	; 0xd6
 100cba8:	4282      	cmp	r2, r0
 100cbaa:	bf28      	it	cs
 100cbac:	4602      	movcs	r2, r0
		if (max_tx_octets >= PDU_DC_PAYLOAD_SIZE_MIN) {
 100cbae:	f8b6 c028 	ldrh.w	ip, [r6, #40]	; 0x28
	if (!conn->common.fex_valid ||
 100cbb2:	f895 00dc 	ldrb.w	r0, [r5, #220]	; 0xdc
			eff_rx_octets = MIN(max_tx_octets,
 100cbb6:	9b01      	ldr	r3, [sp, #4]
 100cbb8:	f1bc 0f1b 	cmp.w	ip, #27
 100cbbc:	bf34      	ite	cc
 100cbbe:	469e      	movcc	lr, r3
 100cbc0:	f04f 0e1b 	movcs.w	lr, #27
	if (!conn->common.fex_valid ||
 100cbc4:	07c0      	lsls	r0, r0, #31
 100cbc6:	f140 821f 	bpl.w	100d008 <ull_conn_rx+0x1380>
	feature_coded_phy = (conn->llcp_feature.features &
 100cbca:	f8d5 011c 	ldr.w	r0, [r5, #284]	; 0x11c
	if (!conn->common.fex_valid ||
 100cbce:	0503      	lsls	r3, r0, #20
 100cbd0:	f140 82ec 	bpl.w	100d1ac <ull_conn_rx+0x1524>
		rx_time = MAX(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_CODED),
 100cbd4:	f44f 6c29 	mov.w	ip, #2704	; 0xa90
		tx_time = MIN(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_CODED),
 100cbd8:	f8b5 00d8 	ldrh.w	r0, [r5, #216]	; 0xd8
 100cbdc:	4560      	cmp	r0, ip
 100cbde:	bf28      	it	cs
 100cbe0:	4660      	movcs	r0, ip
		tx_time = MAX(PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M), tx_time);
 100cbe2:	f5b0 7fa4 	cmp.w	r0, #328	; 0x148
 100cbe6:	bf38      	it	cc
 100cbe8:	f44f 70a4 	movcc.w	r0, #328	; 0x148
		lr_rx_time = sys_le16_to_cpu(lr->max_rx_time);
 100cbec:	f8b6 b026 	ldrh.w	fp, [r6, #38]	; 0x26
		lr_tx_time = sys_le16_to_cpu(lr->max_tx_time);
 100cbf0:	8d73      	ldrh	r3, [r6, #42]	; 0x2a
		if (lr_rx_time >= PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M)) {
 100cbf2:	f5bb 7fa4 	cmp.w	fp, #328	; 0x148
		lr_tx_time = sys_le16_to_cpu(lr->max_tx_time);
 100cbf6:	9303      	str	r3, [sp, #12]
		if (lr_rx_time >= PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M)) {
 100cbf8:	f0c0 8212 	bcc.w	100d020 <ull_conn_rx+0x1398>
			eff_tx_time = MAX(eff_tx_time,
 100cbfc:	f895 a064 	ldrb.w	sl, [r5, #100]	; 0x64
			eff_tx_time = MIN(lr_rx_time, max_tx_time);
 100cc00:	4583      	cmp	fp, r0
 100cc02:	bf28      	it	cs
 100cc04:	4683      	movcs	fp, r0
			eff_tx_time = MAX(eff_tx_time,
 100cc06:	f01a 0f04 	tst.w	sl, #4
 100cc0a:	f00a 0007 	and.w	r0, sl, #7
 100cc0e:	f040 82d6 	bne.w	100d1be <ull_conn_rx+0x1536>
 100cc12:	f100 0a28 	add.w	sl, r0, #40	; 0x28
 100cc16:	ea4f 0aca 	mov.w	sl, sl, lsl #3
 100cc1a:	1040      	asrs	r0, r0, #1
 100cc1c:	fa2a f000 	lsr.w	r0, sl, r0
 100cc20:	4558      	cmp	r0, fp
 100cc22:	bf38      	it	cc
 100cc24:	4658      	movcc	r0, fp
 100cc26:	b280      	uxth	r0, r0
		if (lr_tx_time >= PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M)) {
 100cc28:	9b03      	ldr	r3, [sp, #12]
 100cc2a:	f5b3 7fa4 	cmp.w	r3, #328	; 0x148
 100cc2e:	f0c0 81e9 	bcc.w	100d004 <ull_conn_rx+0x137c>
			eff_rx_time = MIN(lr_tx_time, max_rx_time);
 100cc32:	f5bc 7fa4 	cmp.w	ip, #328	; 0x148
 100cc36:	bf38      	it	cc
 100cc38:	f44f 7ca4 	movcc.w	ip, #328	; 0x148
			eff_rx_time = MAX(eff_rx_time,
 100cc3c:	f895 b065 	ldrb.w	fp, [r5, #101]	; 0x65
			eff_rx_time = MIN(lr_tx_time, max_rx_time);
 100cc40:	4563      	cmp	r3, ip
 100cc42:	bf28      	it	cs
 100cc44:	4663      	movcs	r3, ip
			eff_rx_time = MAX(eff_rx_time,
 100cc46:	f01b 0f04 	tst.w	fp, #4
 100cc4a:	f00b 0a07 	and.w	sl, fp, #7
 100cc4e:	f040 82a4 	bne.w	100d19a <ull_conn_rx+0x1512>
 100cc52:	f10a 0c28 	add.w	ip, sl, #40	; 0x28
 100cc56:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 100cc5a:	ea4f 0a6a 	mov.w	sl, sl, asr #1
 100cc5e:	fa2c fa0a 	lsr.w	sl, ip, sl
 100cc62:	4553      	cmp	r3, sl
 100cc64:	bf38      	it	cc
 100cc66:	4653      	movcc	r3, sl
 100cc68:	fa1f fc83 	uxth.w	ip, r3
		if (eff_rx_octets != conn->lll.max_rx_octets) {
 100cc6c:	9b01      	ldr	r3, [sp, #4]
 100cc6e:	459e      	cmp	lr, r3
 100cc70:	f000 8232 	beq.w	100d0d8 <ull_conn_rx+0x1450>
			conn->llcp_length.ack = conn->llcp_length.req - 1;
 100cc74:	9b00      	ldr	r3, [sp, #0]
			conn->llcp_length.rx_octets = eff_rx_octets;
 100cc76:	f8a5 e19c 	strh.w	lr, [r5, #412]	; 0x19c
			conn->llcp_length.ack = conn->llcp_length.req - 1;
 100cc7a:	3b01      	subs	r3, #1
 100cc7c:	f885 3199 	strb.w	r3, [r5, #409]	; 0x199
			conn->llcp_length.tx_octets = eff_tx_octets;
 100cc80:	f8a5 219e 	strh.w	r2, [r5, #414]	; 0x19e
			conn->llcp_length.rx_time = eff_rx_time;
 100cc84:	f8a5 c1a0 	strh.w	ip, [r5, #416]	; 0x1a0
			conn->llcp_length.tx_time = eff_tx_time;
 100cc88:	f8a5 01a2 	strh.w	r0, [r5, #418]	; 0x1a2
			if (tx) {
 100cc8c:	2900      	cmp	r1, #0
 100cc8e:	f000 8299 	beq.w	100d1c4 <ull_conn_rx+0x153c>
				conn->llcp_length.state =
 100cc92:	2605      	movs	r6, #5
 100cc94:	f895 319a 	ldrb.w	r3, [r5, #410]	; 0x19a
 100cc98:	f366 0302 	bfi	r3, r6, #0, #3
 100cc9c:	f885 319a 	strb.w	r3, [r5, #410]	; 0x19a
			*rx = NULL;
 100cca0:	2600      	movs	r6, #0
			link->mem = conn->llcp_rx;
 100cca2:	f8d5 3100 	ldr.w	r3, [r5, #256]	; 0x100
 100cca6:	607b      	str	r3, [r7, #4]
			(*rx)->hdr.link = link;
 100cca8:	6823      	ldr	r3, [r4, #0]
 100ccaa:	601f      	str	r7, [r3, #0]
			conn->llcp_rx = *rx;
 100ccac:	6823      	ldr	r3, [r4, #0]
 100ccae:	f8c5 3100 	str.w	r3, [r5, #256]	; 0x100
			*rx = NULL;
 100ccb2:	6026      	str	r6, [r4, #0]
	if (tx) {
 100ccb4:	2900      	cmp	r1, #0
 100ccb6:	f43f a8a3 	beq.w	100be00 <ull_conn_rx+0x178>
	pdu_tx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
 100ccba:	2609      	movs	r6, #9
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 100ccbc:	2415      	movs	r4, #21
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100ccbe:	790b      	ldrb	r3, [r1, #4]
	pdu_tx->llctrl.length_rsp.max_tx_time = sys_cpu_to_le16(eff_tx_time);
 100ccc0:	81c8      	strh	r0, [r1, #14]
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100ccc2:	f043 0303 	orr.w	r3, r3, #3
	ctrl_tx_sec_enqueue(conn, tx);
 100ccc6:	4628      	mov	r0, r5
	pdu_tx->llctrl.length_rsp.max_rx_octets =
 100ccc8:	f8a1 e008 	strh.w	lr, [r1, #8]
	pdu_tx->llctrl.length_rsp.max_tx_octets =
 100cccc:	818a      	strh	r2, [r1, #12]
	pdu_tx->llctrl.length_rsp.max_rx_time = sys_cpu_to_le16(eff_rx_time);
 100ccce:	f8a1 c00a 	strh.w	ip, [r1, #10]
	pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100ccd2:	710b      	strb	r3, [r1, #4]
	pdu_tx->len = offsetof(struct pdu_data_llctrl, length_rsp) +
 100ccd4:	714e      	strb	r6, [r1, #5]
	pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_LENGTH_RSP;
 100ccd6:	71cc      	strb	r4, [r1, #7]
	ctrl_tx_sec_enqueue(conn, tx);
 100ccd8:	f7fe fb5a 	bl	100b390 <ctrl_tx_sec_enqueue>
	return 0;
 100ccdc:	2000      	movs	r0, #0
}
 100ccde:	f7ff b83c 	b.w	100bd5a <ull_conn_rx+0xd2>
		} else if (conn->llcp_length.req != conn->llcp_length.ack) {
 100cce2:	f895 2198 	ldrb.w	r2, [r5, #408]	; 0x198
 100cce6:	f895 3199 	ldrb.w	r3, [r5, #409]	; 0x199
 100ccea:	4293      	cmp	r3, r2
 100ccec:	f000 8228 	beq.w	100d140 <ull_conn_rx+0x14b8>
			conn->llcp_length.disabled = 1U;
 100ccf0:	f895 319a 	ldrb.w	r3, [r5, #410]	; 0x19a
			conn->llcp_length.ack = conn->llcp_length.req;
 100ccf4:	f885 2199 	strb.w	r2, [r5, #409]	; 0x199
			conn->llcp_length.disabled = 1U;
 100ccf8:	f043 0308 	orr.w	r3, r3, #8
 100ccfc:	f885 319a 	strb.w	r3, [r5, #410]	; 0x19a
			conn->llcp_length.ack = conn->llcp_length.req;
 100cd00:	f7ff b8ff 	b.w	100bf02 <ull_conn_rx+0x27a>
		if (!conn->tx_ctrl) {
 100cd04:	f8d5 21b4 	ldr.w	r2, [r5, #436]	; 0x1b4
 100cd08:	2a00      	cmp	r2, #0
 100cd0a:	f47f ad22 	bne.w	100c752 <ull_conn_rx+0xaca>
			tx->next = conn->tx_head;
 100cd0e:	6023      	str	r3, [r4, #0]
				conn->tx_ctrl = tx;
 100cd10:	e9c5 446c 	strd	r4, r4, [r5, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 100cd14:	f8c5 41b8 	str.w	r4, [r5, #440]	; 0x1b8
 100cd18:	e522      	b.n	100c760 <ull_conn_rx+0xad8>
			    conn->llcp_conn_param.ack) ||
 100cd1a:	f895 1171 	ldrb.w	r1, [r5, #369]	; 0x171
		} else if ((conn->llcp_conn_param.req ==
 100cd1e:	f895 3170 	ldrb.w	r3, [r5, #368]	; 0x170
 100cd22:	428b      	cmp	r3, r1
 100cd24:	d068      	beq.n	100cdf8 <ull_conn_rx+0x1170>
			    conn->llcp_conn_param.ack) ||
 100cd26:	f895 3172 	ldrb.w	r3, [r5, #370]	; 0x172
 100cd2a:	0798      	lsls	r0, r3, #30
 100cd2c:	d064      	beq.n	100cdf8 <ull_conn_rx+0x1170>
			LL_ASSERT(0);
 100cd2e:	481b      	ldr	r0, [pc, #108]	; (100cd9c <ull_conn_rx+0x1114>)
 100cd30:	f241 6154 	movw	r1, #5716	; 0x1654
 100cd34:	f7f6 fc28 	bl	1003588 <bt_ctlr_assert_handle>
	int nack = 0;
 100cd38:	2000      	movs	r0, #0
 100cd3a:	f7ff b80e 	b.w	100bd5a <ull_conn_rx+0xd2>
			LL_ASSERT(conn_upd_curr == conn);
 100cd3e:	4f18      	ldr	r7, [pc, #96]	; (100cda0 <ull_conn_rx+0x1118>)
 100cd40:	683a      	ldr	r2, [r7, #0]
 100cd42:	4295      	cmp	r5, r2
 100cd44:	d006      	beq.n	100cd54 <ull_conn_rx+0x10cc>
 100cd46:	f241 61ec 	movw	r1, #5868	; 0x16ec
 100cd4a:	4814      	ldr	r0, [pc, #80]	; (100cd9c <ull_conn_rx+0x1114>)
 100cd4c:	f7f6 fc1c 	bl	1003588 <bt_ctlr_assert_handle>
 100cd50:	f895 3170 	ldrb.w	r3, [r5, #368]	; 0x170
			conn_upd_curr = NULL;
 100cd54:	2200      	movs	r2, #0
			conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
 100cd56:	f885 3171 	strb.w	r3, [r5, #369]	; 0x171
			if (!conn->llcp_conn_param.cmd) {
 100cd5a:	f895 3172 	ldrb.w	r3, [r5, #370]	; 0x172
			conn_upd_curr = NULL;
 100cd5e:	603a      	str	r2, [r7, #0]
			if (!conn->llcp_conn_param.cmd) {
 100cd60:	f013 0308 	ands.w	r3, r3, #8
 100cd64:	f000 80db 	beq.w	100cf1e <ull_conn_rx+0x1296>
			cu->status = BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
 100cd68:	221a      	movs	r2, #26
			(*rx)->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
 100cd6a:	270a      	movs	r7, #10
				      lll->interval * 125U / 1000;
 100cd6c:	237d      	movs	r3, #125	; 0x7d
 100cd6e:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
			(*rx)->hdr.type = NODE_RX_TYPE_CONN_UPDATE;
 100cd72:	6820      	ldr	r0, [r4, #0]
 100cd74:	7107      	strb	r7, [r0, #4]
			cu->status = BT_HCI_ERR_UNSUPP_REMOTE_FEATURE;
 100cd76:	f886 2020 	strb.w	r2, [r6, #32]
			cu->interval = lll->interval;
 100cd7a:	8dea      	ldrh	r2, [r5, #46]	; 0x2e
			cu->timeout = conn->supervision_reload *
 100cd7c:	f8b5 00c6 	ldrh.w	r0, [r5, #198]	; 0xc6
			cu->interval = lll->interval;
 100cd80:	8472      	strh	r2, [r6, #34]	; 0x22
			cu->timeout = conn->supervision_reload *
 100cd82:	fb02 f200 	mul.w	r2, r2, r0
				      lll->interval * 125U / 1000;
 100cd86:	fb03 f302 	mul.w	r3, r3, r2
 100cd8a:	fbb3 f3f1 	udiv	r3, r3, r1
			cu->latency = lll->latency;
 100cd8e:	8e2a      	ldrh	r2, [r5, #48]	; 0x30
			cu->timeout = conn->supervision_reload *
 100cd90:	84f3      	strh	r3, [r6, #38]	; 0x26
			cu->latency = lll->latency;
 100cd92:	84b2      	strh	r2, [r6, #36]	; 0x24
			cu->timeout = conn->supervision_reload *
 100cd94:	f7ff b8b5 	b.w	100bf02 <ull_conn_rx+0x27a>
 100cd98:	210038cc 	.word	0x210038cc
 100cd9c:	010187e4 	.word	0x010187e4
 100cda0:	210037c0 	.word	0x210037c0
		tx = mem_acquire(&mem_conn_tx_ctrl.free);
 100cda4:	48e5      	ldr	r0, [pc, #916]	; (100d13c <ull_conn_rx+0x14b4>)
 100cda6:	f7f8 ff3b 	bl	1005c20 <mem_acquire>
		if (!tx) {
 100cdaa:	4601      	mov	r1, r0
 100cdac:	2800      	cmp	r0, #0
 100cdae:	f43f aed9 	beq.w	100cb64 <ull_conn_rx+0xedc>
		v->sub_version_number =
 100cdb2:	f04f 32ff 	mov.w	r2, #4294967295
		pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
 100cdb6:	f04f 0e0c 	mov.w	lr, #12
		v->version_number = LL_VERSION_NUMBER;
 100cdba:	f04f 0c0b 	mov.w	ip, #11
		v->company_id =	sys_cpu_to_le16(ll_settings_company_id());
 100cdbe:	2005      	movs	r0, #5
 100cdc0:	f06f 070e 	mvn.w	r7, #14
		conn->llcp_version.tx = 1U;
 100cdc4:	f895 3122 	ldrb.w	r3, [r5, #290]	; 0x122
 100cdc8:	f043 0301 	orr.w	r3, r3, #1
 100cdcc:	f885 3122 	strb.w	r3, [r5, #290]	; 0x122
		pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100cdd0:	790b      	ldrb	r3, [r1, #4]
		v->company_id =	sys_cpu_to_le16(ll_settings_company_id());
 100cdd2:	7288      	strb	r0, [r1, #10]
		pdu_tx->ll_id = PDU_DATA_LLID_CTRL;
 100cdd4:	f043 0303 	orr.w	r3, r3, #3
 100cdd8:	710b      	strb	r3, [r1, #4]
		ctrl_tx_sec_enqueue(conn, tx);
 100cdda:	4628      	mov	r0, r5
		pdu_tx->len =
 100cddc:	714c      	strb	r4, [r1, #5]
		pdu_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_VERSION_IND;
 100cdde:	f881 e007 	strb.w	lr, [r1, #7]
		v->version_number = LL_VERSION_NUMBER;
 100cde2:	f881 c008 	strb.w	ip, [r1, #8]
		v->company_id =	sys_cpu_to_le16(ll_settings_company_id());
 100cde6:	724f      	strb	r7, [r1, #9]
		v->sub_version_number =
 100cde8:	72ca      	strb	r2, [r1, #11]
 100cdea:	730a      	strb	r2, [r1, #12]
		ctrl_tx_sec_enqueue(conn, tx);
 100cdec:	f7fe fad0 	bl	100b390 <ctrl_tx_sec_enqueue>
		rx->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100cdf0:	2303      	movs	r3, #3
 100cdf2:	7133      	strb	r3, [r6, #4]
 100cdf4:	f7ff bb4b 	b.w	100c48e <ull_conn_rx+0x806>
			u16_t interval_min = sys_le16_to_cpu(cpr->interval_min);
 100cdf8:	f8b6 a024 	ldrh.w	sl, [r6, #36]	; 0x24
 100cdfc:	fa1f f38a 	uxth.w	r3, sl
			if ((interval_min < 6) ||
 100ce00:	2b05      	cmp	r3, #5
 100ce02:	d97f      	bls.n	100cf04 <ull_conn_rx+0x127c>
			u16_t interval_max = sys_le16_to_cpu(cpr->interval_max);
 100ce04:	8cf2      	ldrh	r2, [r6, #38]	; 0x26
 100ce06:	f8ad 2000 	strh.w	r2, [sp]
 100ce0a:	b292      	uxth	r2, r2
			if ((interval_min < 6) ||
 100ce0c:	f5b2 6f48 	cmp.w	r2, #3200	; 0xc80
 100ce10:	d878      	bhi.n	100cf04 <ull_conn_rx+0x127c>
			    (interval_max > 3200) ||
 100ce12:	4293      	cmp	r3, r2
 100ce14:	d876      	bhi.n	100cf04 <ull_conn_rx+0x127c>
			u16_t latency = sys_le16_to_cpu(cpr->latency);
 100ce16:	f8b6 8028 	ldrh.w	r8, [r6, #40]	; 0x28
 100ce1a:	fa1f f088 	uxth.w	r0, r8
			    (interval_min > interval_max) ||
 100ce1e:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
 100ce22:	d26f      	bcs.n	100cf04 <ull_conn_rx+0x127c>
			    (latency > 499) ||
 100ce24:	f640 4b76 	movw	fp, #3190	; 0xc76
			u16_t timeout = sys_le16_to_cpu(cpr->timeout);
 100ce28:	f8b6 e02a 	ldrh.w	lr, [r6, #42]	; 0x2a
 100ce2c:	fa1f f38e 	uxth.w	r3, lr
			    (latency > 499) ||
 100ce30:	f1a3 0c0a 	sub.w	ip, r3, #10
 100ce34:	fa1f fc8c 	uxth.w	ip, ip
 100ce38:	45dc      	cmp	ip, fp
 100ce3a:	d863      	bhi.n	100cf04 <ull_conn_rx+0x127c>
			     ((latency + 1) * interval_max)) ||
 100ce3c:	fb00 2c02 	mla	ip, r0, r2, r2
			    (timeout < 10) || (timeout > 3200) ||
 100ce40:	ebbc 0f83 	cmp.w	ip, r3, lsl #2
 100ce44:	d25e      	bcs.n	100cf04 <ull_conn_rx+0x127c>
			     ((latency + 1) * interval_max)) ||
 100ce46:	f896 b02c 	ldrb.w	fp, [r6, #44]	; 0x2c
 100ce4a:	455a      	cmp	r2, fp
 100ce4c:	d35a      	bcc.n	100cf04 <ull_conn_rx+0x127c>
			conn->llcp_conn_param.interval_min = interval_min;
 100ce4e:	f8a5 a174 	strh.w	sl, [r5, #372]	; 0x174
			conn->llcp_conn_param.interval_max = interval_max;
 100ce52:	f8bd a000 	ldrh.w	sl, [sp]
			conn->llcp_conn_param.timeout =	timeout;
 100ce56:	f8a5 e17a 	strh.w	lr, [r5, #378]	; 0x17a
			conn->llcp_conn_param.interval_max = interval_max;
 100ce5a:	f8a5 a176 	strh.w	sl, [r5, #374]	; 0x176
			conn->llcp_conn_param.latency =	latency;
 100ce5e:	f8a5 8178 	strh.w	r8, [r5, #376]	; 0x178
			conn->llcp_conn_param.preferred_periodicity =
 100ce62:	f885 b17c 	strb.w	fp, [r5, #380]	; 0x17c
				sys_le16_to_cpu(cpr->reference_conn_event_count);
 100ce66:	f896 802e 	ldrb.w	r8, [r6, #46]	; 0x2e
 100ce6a:	f896 c02d 	ldrb.w	ip, [r6, #45]	; 0x2d
			     lll->interval) ||
 100ce6e:	f8b5 e02e 	ldrh.w	lr, [r5, #46]	; 0x2e
				sys_le16_to_cpu(cpr->reference_conn_event_count);
 100ce72:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
			conn->llcp_conn_param.reference_conn_event_count =
 100ce76:	f8a5 c17e 	strh.w	ip, [r5, #382]	; 0x17e
				sys_le16_to_cpu(cpr->offset0);
 100ce7a:	f896 8030 	ldrb.w	r8, [r6, #48]	; 0x30
 100ce7e:	f896 c02f 	ldrb.w	ip, [r6, #47]	; 0x2f
			if ((conn->llcp_conn_param.interval_max !=
 100ce82:	4572      	cmp	r2, lr
				sys_le16_to_cpu(cpr->offset0);
 100ce84:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
			conn->llcp_conn_param.offset0 =
 100ce88:	f8a5 c180 	strh.w	ip, [r5, #384]	; 0x180
				sys_le16_to_cpu(cpr->offset1);
 100ce8c:	f896 8032 	ldrb.w	r8, [r6, #50]	; 0x32
 100ce90:	f896 c031 	ldrb.w	ip, [r6, #49]	; 0x31
 100ce94:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
			conn->llcp_conn_param.offset1 =
 100ce98:	f8a5 c182 	strh.w	ip, [r5, #386]	; 0x182
				sys_le16_to_cpu(cpr->offset2);
 100ce9c:	f896 8034 	ldrb.w	r8, [r6, #52]	; 0x34
 100cea0:	f896 c033 	ldrb.w	ip, [r6, #51]	; 0x33
 100cea4:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
			conn->llcp_conn_param.offset2 =
 100cea8:	f8a5 c184 	strh.w	ip, [r5, #388]	; 0x184
				sys_le16_to_cpu(cpr->offset3);
 100ceac:	f896 8036 	ldrb.w	r8, [r6, #54]	; 0x36
 100ceb0:	f896 c035 	ldrb.w	ip, [r6, #53]	; 0x35
 100ceb4:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
			conn->llcp_conn_param.offset3 =
 100ceb8:	f8a5 c186 	strh.w	ip, [r5, #390]	; 0x186
				sys_le16_to_cpu(cpr->offset4);
 100cebc:	f896 c037 	ldrb.w	ip, [r6, #55]	; 0x37
 100cec0:	f896 8038 	ldrb.w	r8, [r6, #56]	; 0x38
 100cec4:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
			conn->llcp_conn_param.offset4 =
 100cec8:	f8a5 c188 	strh.w	ip, [r5, #392]	; 0x188
				sys_le16_to_cpu(cpr->offset5);
 100cecc:	f896 c039 	ldrb.w	ip, [r6, #57]	; 0x39
 100ced0:	f896 603a 	ldrb.w	r6, [r6, #58]	; 0x3a
 100ced4:	ea4c 2606 	orr.w	r6, ip, r6, lsl #8
			conn->llcp_conn_param.offset5 =
 100ced8:	f8a5 618a 	strh.w	r6, [r5, #394]	; 0x18a
			if ((conn->llcp_conn_param.interval_max !=
 100cedc:	f000 826e 	beq.w	100d3bc <ull_conn_rx+0x1734>
				conn->llcp_conn_param.state =
 100cee0:	2203      	movs	r2, #3
 100cee2:	f895 3172 	ldrb.w	r3, [r5, #370]	; 0x172
 100cee6:	f362 0302 	bfi	r3, r2, #0, #3
 100ceea:	f885 3172 	strb.w	r3, [r5, #370]	; 0x172
			conn->llcp_conn_param.ack--;
 100ceee:	3901      	subs	r1, #1
 100cef0:	f885 1171 	strb.w	r1, [r5, #369]	; 0x171
			if (!conn_upd_curr) {
 100cef4:	f1b9 0f00 	cmp.w	r9, #0
 100cef8:	f47e af82 	bne.w	100be00 <ull_conn_rx+0x178>
	int nack = 0;
 100cefc:	4648      	mov	r0, r9
				conn_upd_curr = conn;
 100cefe:	603d      	str	r5, [r7, #0]
 100cf00:	f7fe bf2b 	b.w	100bd5a <ull_conn_rx+0xd2>
				nack = reject_ext_ind_send(conn, *rx,
 100cf04:	4628      	mov	r0, r5
 100cf06:	231e      	movs	r3, #30
 100cf08:	220f      	movs	r2, #15
 100cf0a:	1d31      	adds	r1, r6, #4
 100cf0c:	f7ff b8ad 	b.w	100c06a <ull_conn_rx+0x3e2>
				      0x03) == 0x02) &&
 100cf10:	f895 30ea 	ldrb.w	r3, [r5, #234]	; 0xea
 100cf14:	2b03      	cmp	r3, #3
 100cf16:	f47f a8a4 	bne.w	100c062 <ull_conn_rx+0x3da>
 100cf1a:	f7ff b89b 	b.w	100c054 <ull_conn_rx+0x3cc>
			(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100cf1e:	2103      	movs	r1, #3
 100cf20:	6822      	ldr	r2, [r4, #0]
	int nack = 0;
 100cf22:	4618      	mov	r0, r3
			(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100cf24:	7111      	strb	r1, [r2, #4]
		if (err) {
 100cf26:	f7fe bf18 	b.w	100bd5a <ull_conn_rx+0xd2>
	instant = sys_le16_to_cpu(ind->instant);
 100cf2a:	8cf1      	ldrh	r1, [r6, #38]	; 0x26
	if (((instant - conn->lll.event_counter) & 0xffff) > 0x7fff) {
 100cf2c:	8eea      	ldrh	r2, [r5, #54]	; 0x36
 100cf2e:	1a8a      	subs	r2, r1, r2
 100cf30:	0412      	lsls	r2, r2, #16
 100cf32:	d47c      	bmi.n	100d02e <ull_conn_rx+0x13a6>
	if (((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) {
 100cf34:	f895 20e8 	ldrb.w	r2, [r5, #232]	; 0xe8
 100cf38:	f895 c0e9 	ldrb.w	ip, [r5, #233]	; 0xe9
 100cf3c:	eba2 020c 	sub.w	r2, r2, ip
 100cf40:	f002 0203 	and.w	r2, r2, #3
 100cf44:	2a02      	cmp	r2, #2
 100cf46:	f000 80f4 	beq.w	100d132 <ull_conn_rx+0x14aa>
	if ((conn->llcp_phy.ack != conn->llcp_phy.req) &&
 100cf4a:	f895 61a8 	ldrb.w	r6, [r5, #424]	; 0x1a8
 100cf4e:	f895 21a9 	ldrb.w	r2, [r5, #425]	; 0x1a9
 100cf52:	42b2      	cmp	r2, r6
 100cf54:	d019      	beq.n	100cf8a <ull_conn_rx+0x1302>
	    (conn->llcp_phy.state == LLCP_PHY_STATE_RSP_WAIT)) {
 100cf56:	f895 21aa 	ldrb.w	r2, [r5, #426]	; 0x1aa
	if ((conn->llcp_phy.ack != conn->llcp_phy.req) &&
 100cf5a:	f002 0203 	and.w	r2, r2, #3
 100cf5e:	2a02      	cmp	r2, #2
 100cf60:	d113      	bne.n	100cf8a <ull_conn_rx+0x1302>
		conn->procedure_expire = 0U;
 100cf62:	f04f 0c00 	mov.w	ip, #0
		conn->llcp_phy.pause_tx = 0U;
 100cf66:	f895 21ab 	ldrb.w	r2, [r5, #427]	; 0x1ab
		conn->llcp_phy.ack = conn->llcp_phy.req;
 100cf6a:	f885 61a9 	strb.w	r6, [r5, #425]	; 0x1a9
		conn->llcp_phy.pause_tx = 0U;
 100cf6e:	f36f 0200 	bfc	r2, #0, #1
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
 100cf72:	f895 60ec 	ldrb.w	r6, [r5, #236]	; 0xec
		conn->llcp_phy.pause_tx = 0U;
 100cf76:	f885 21ab 	strb.w	r2, [r5, #427]	; 0x1ab
		conn->llcp.phy_upd_ind.cmd = conn->llcp_phy.cmd;
 100cf7a:	f3c2 0280 	ubfx	r2, r2, #2, #1
 100cf7e:	f362 0641 	bfi	r6, r2, #1, #1
 100cf82:	f885 60ec 	strb.w	r6, [r5, #236]	; 0xec
		conn->procedure_expire = 0U;
 100cf86:	f8a5 c0cc 	strh.w	ip, [r5, #204]	; 0xcc
	*rx = NULL;
 100cf8a:	2600      	movs	r6, #0
	conn->llcp.phy_upd_ind.initiate = 0U;
 100cf8c:	f895 20ec 	ldrb.w	r2, [r5, #236]	; 0xec
 100cf90:	009b      	lsls	r3, r3, #2
 100cf92:	f003 031c 	and.w	r3, r3, #28
	conn->llcp.phy_upd_ind.instant = instant;
 100cf96:	f8a5 10ee 	strh.w	r1, [r5, #238]	; 0xee
	conn->llcp.phy_upd_ind.initiate = 0U;
 100cf9a:	ea43 1340 	orr.w	r3, r3, r0, lsl #5
	link->mem = conn->llcp_rx;
 100cf9e:	f8d5 1100 	ldr.w	r1, [r5, #256]	; 0x100
	conn->llcp.phy_upd_ind.initiate = 0U;
 100cfa2:	f002 0202 	and.w	r2, r2, #2
 100cfa6:	4313      	orrs	r3, r2
 100cfa8:	f885 30ec 	strb.w	r3, [r5, #236]	; 0xec
	link->mem = conn->llcp_rx;
 100cfac:	6079      	str	r1, [r7, #4]
	(*rx)->hdr.link = link;
 100cfae:	6823      	ldr	r3, [r4, #0]
 100cfb0:	601f      	str	r7, [r3, #0]
	conn->llcp_rx = *rx;
 100cfb2:	6823      	ldr	r3, [r4, #0]
 100cfb4:	f8c5 3100 	str.w	r3, [r5, #256]	; 0x100
	*rx = NULL;
 100cfb8:	6026      	str	r6, [r4, #0]
	struct node_rx_pdu *rx_dle = ll_pdu_rx_alloc();
 100cfba:	f7fd f855 	bl	100a068 <ll_pdu_rx_alloc>
	LL_ASSERT(rx_dle);
 100cfbe:	4604      	mov	r4, r0
 100cfc0:	2800      	cmp	r0, #0
 100cfc2:	f000 81eb 	beq.w	100d39c <ull_conn_rx+0x1714>
	conn->llcp_type = LLCP_PHY_UPD;
 100cfc6:	2106      	movs	r1, #6
	rx_dle->hdr.link->mem = conn->llcp_rx;
 100cfc8:	6823      	ldr	r3, [r4, #0]
 100cfca:	f8d5 2100 	ldr.w	r2, [r5, #256]	; 0x100
 100cfce:	605a      	str	r2, [r3, #4]
	conn->llcp_ack -= 2U;
 100cfd0:	f895 20e9 	ldrb.w	r2, [r5, #233]	; 0xe9
	if (conn->llcp.phy_upd_ind.tx) {
 100cfd4:	f895 30ec 	ldrb.w	r3, [r5, #236]	; 0xec
	conn->llcp_ack -= 2U;
 100cfd8:	3a02      	subs	r2, #2
	if (conn->llcp.phy_upd_ind.tx) {
 100cfda:	f013 0f1c 	tst.w	r3, #28
	conn->llcp_rx = rx_dle;
 100cfde:	f8c5 4100 	str.w	r4, [r5, #256]	; 0x100
	conn->llcp_ack -= 2U;
 100cfe2:	f885 20e9 	strb.w	r2, [r5, #233]	; 0xe9
	conn->llcp_type = LLCP_PHY_UPD;
 100cfe6:	f885 10ea 	strb.w	r1, [r5, #234]	; 0xea
	if (conn->llcp.phy_upd_ind.tx) {
 100cfea:	f43e af09 	beq.w	100be00 <ull_conn_rx+0x178>
		conn->lll.phy_tx_time = conn->llcp.phy_upd_ind.tx;
 100cfee:	f895 2064 	ldrb.w	r2, [r5, #100]	; 0x64
 100cff2:	f3c3 0382 	ubfx	r3, r3, #2, #3
 100cff6:	f363 1206 	bfi	r2, r3, #4, #3
	int nack = 0;
 100cffa:	2000      	movs	r0, #0
		conn->lll.phy_tx_time = conn->llcp.phy_upd_ind.tx;
 100cffc:	f885 2064 	strb.w	r2, [r5, #100]	; 0x64
		if (err) {
 100d000:	f7fe beab 	b.w	100bd5a <ull_conn_rx+0xd2>
 100d004:	46c4      	mov	ip, r8
 100d006:	e631      	b.n	100cc6c <ull_conn_rx+0xfe4>
		tx_time = MAX(MIN(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_1M),
 100d008:	f44f 70a4 	mov.w	r0, #328	; 0x148
		rx_time = PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_1M);
 100d00c:	4684      	mov	ip, r0
 100d00e:	e5ed      	b.n	100cbec <ull_conn_rx+0xf64>
 100d010:	9a02      	ldr	r2, [sp, #8]
 100d012:	e5cc      	b.n	100cbae <ull_conn_rx+0xf26>
				nack = reject_ext_ind_send(conn, *rx,
 100d014:	4628      	mov	r0, r5
 100d016:	2323      	movs	r3, #35	; 0x23
 100d018:	220f      	movs	r2, #15
 100d01a:	1d31      	adds	r1, r6, #4
 100d01c:	f7ff b825 	b.w	100c06a <ull_conn_rx+0x3e2>
 100d020:	4648      	mov	r0, r9
 100d022:	e601      	b.n	100cc28 <ull_conn_rx+0xfa0>
				nack = reject_ext_ind_send(conn, *rx,
 100d024:	4628      	mov	r0, r5
 100d026:	2323      	movs	r3, #35	; 0x23
 100d028:	1d31      	adds	r1, r6, #4
 100d02a:	f7ff b81d 	b.w	100c068 <ull_conn_rx+0x3e0>
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d02e:	2203      	movs	r2, #3
		return BT_HCI_ERR_INSTANT_PASSED;
 100d030:	2328      	movs	r3, #40	; 0x28
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d032:	7132      	strb	r2, [r6, #4]
			conn->llcp_terminate.reason_peer = err;
 100d034:	f885 312b 	strb.w	r3, [r5, #299]	; 0x12b
 100d038:	f7fe bee2 	b.w	100be00 <ull_conn_rx+0x178>
				conn->llcp_phy.state =
 100d03c:	f895 31aa 	ldrb.w	r3, [r5, #426]	; 0x1aa
				if (conn->llcp_phy.ack ==
 100d040:	428a      	cmp	r2, r1
				conn->llcp_phy.state =
 100d042:	f043 0303 	orr.w	r3, r3, #3
 100d046:	f885 31aa 	strb.w	r3, [r5, #426]	; 0x1aa
				if (conn->llcp_phy.ack ==
 100d04a:	d114      	bne.n	100d076 <ull_conn_rx+0x13ee>
						conn->phy_pref_rx;
 100d04c:	f895 01ac 	ldrb.w	r0, [r5, #428]	; 0x1ac
					conn->llcp_phy.tx =
 100d050:	f8b5 11aa 	ldrh.w	r1, [r5, #426]	; 0x1aa
 100d054:	f000 0307 	and.w	r3, r0, #7
 100d058:	009b      	lsls	r3, r3, #2
 100d05a:	f3c0 1002 	ubfx	r0, r0, #4, #3
 100d05e:	f421 619f 	bic.w	r1, r1, #1272	; 0x4f8
 100d062:	ea43 1340 	orr.w	r3, r3, r0, lsl #5
 100d066:	f021 0104 	bic.w	r1, r1, #4
					conn->llcp_phy.ack--;
 100d06a:	3a01      	subs	r2, #1
					conn->llcp_phy.tx =
 100d06c:	430b      	orrs	r3, r1
					conn->llcp_phy.ack--;
 100d06e:	f885 21a9 	strb.w	r2, [r5, #425]	; 0x1a9
					conn->llcp_phy.tx =
 100d072:	f8a5 31aa 	strh.w	r3, [r5, #426]	; 0x1aa
				conn->llcp_phy.rx &= p->tx_phys;
 100d076:	f895 21aa 	ldrb.w	r2, [r5, #426]	; 0x1aa
				conn->llcp_phy.tx &= p->rx_phys;
 100d07a:	f896 3025 	ldrb.w	r3, [r6, #37]	; 0x25
				conn->llcp_phy.rx &= p->tx_phys;
 100d07e:	f896 1024 	ldrb.w	r1, [r6, #36]	; 0x24
				conn->llcp_phy.tx &= p->rx_phys;
 100d082:	f3c2 0082 	ubfx	r0, r2, #2, #3
 100d086:	4003      	ands	r3, r0
				conn->llcp_phy.rx &= p->tx_phys;
 100d088:	ea01 1152 	and.w	r1, r1, r2, lsr #5
				conn->llcp_phy.tx &= p->rx_phys;
 100d08c:	009b      	lsls	r3, r3, #2
 100d08e:	ea43 1341 	orr.w	r3, r3, r1, lsl #5
 100d092:	f002 0203 	and.w	r2, r2, #3
 100d096:	4313      	orrs	r3, r2
				if (!conn->llcp_phy.tx || !conn->llcp_phy.rx) {
 100d098:	f013 0f1c 	tst.w	r3, #28
				conn->llcp_phy.tx &= p->rx_phys;
 100d09c:	f885 31aa 	strb.w	r3, [r5, #426]	; 0x1aa
				if (!conn->llcp_phy.tx || !conn->llcp_phy.rx) {
 100d0a0:	d002      	beq.n	100d0a8 <ull_conn_rx+0x1420>
 100d0a2:	f013 0fe0 	tst.w	r3, #224	; 0xe0
 100d0a6:	d105      	bne.n	100d0b4 <ull_conn_rx+0x142c>
					conn->llcp_phy.tx = 0;
 100d0a8:	f895 31aa 	ldrb.w	r3, [r5, #426]	; 0x1aa
 100d0ac:	f003 0303 	and.w	r3, r3, #3
 100d0b0:	f885 31aa 	strb.w	r3, [r5, #426]	; 0x1aa
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d0b4:	2203      	movs	r2, #3
				conn->llcp_phy.pause_tx = 1U;
 100d0b6:	f895 31ab 	ldrb.w	r3, [r5, #427]	; 0x1ab
	int nack = 0;
 100d0ba:	2000      	movs	r0, #0
				conn->llcp_phy.pause_tx = 1U;
 100d0bc:	f043 0301 	orr.w	r3, r3, #1
 100d0c0:	f885 31ab 	strb.w	r3, [r5, #427]	; 0x1ab
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d0c4:	6823      	ldr	r3, [r4, #0]
 100d0c6:	711a      	strb	r2, [r3, #4]
 100d0c8:	f7fe be47 	b.w	100bd5a <ull_conn_rx+0xd2>
				nack = reject_ext_ind_send(conn, *rx,
 100d0cc:	4628      	mov	r0, r5
 100d0ce:	231e      	movs	r3, #30
 100d0d0:	2210      	movs	r2, #16
 100d0d2:	1d31      	adds	r1, r6, #4
 100d0d4:	f7fe bfc9 	b.w	100c06a <ull_conn_rx+0x3e2>
			conn->procedure_expire = 0U;
 100d0d8:	2700      	movs	r7, #0
			conn->llcp_length.ack = conn->llcp_length.req;
 100d0da:	9b00      	ldr	r3, [sp, #0]
			conn->procedure_expire = 0U;
 100d0dc:	f8a5 70cc 	strh.w	r7, [r5, #204]	; 0xcc
			conn->llcp_length.ack = conn->llcp_length.req;
 100d0e0:	f885 3199 	strb.w	r3, [r5, #409]	; 0x199
			if (eff_tx_octets == conn->lll.max_tx_octets &&
 100d0e4:	9b02      	ldr	r3, [sp, #8]
 100d0e6:	429a      	cmp	r2, r3
 100d0e8:	f000 811e 	beq.w	100d328 <ull_conn_rx+0x16a0>
			conn->lll.max_rx_time = eff_rx_time;
 100d0ec:	f8a5 c062 	strh.w	ip, [r5, #98]	; 0x62
			if (tx) {
 100d0f0:	2900      	cmp	r1, #0
 100d0f2:	f000 8114 	beq.w	100d31e <ull_conn_rx+0x1696>
				conn->llcp_length.state =
 100d0f6:	2703      	movs	r7, #3
 100d0f8:	f895 419a 	ldrb.w	r4, [r5, #410]	; 0x19a
					(conn->llcp_length.req - 1);
 100d0fc:	9b00      	ldr	r3, [sp, #0]
				conn->llcp_length.state =
 100d0fe:	f367 0402 	bfi	r4, r7, #0, #3
					(conn->llcp_length.req - 1);
 100d102:	3b01      	subs	r3, #1
				conn->llcp_length.ack =
 100d104:	f885 3199 	strb.w	r3, [r5, #409]	; 0x199
				conn->llcp_length.rx_octets = eff_rx_octets;
 100d108:	f8a5 e19c 	strh.w	lr, [r5, #412]	; 0x19c
				conn->llcp_length.tx_octets = eff_tx_octets;
 100d10c:	f8a5 219e 	strh.w	r2, [r5, #414]	; 0x19e
				conn->llcp_length.rx_time = eff_rx_time;
 100d110:	f8a5 c1a0 	strh.w	ip, [r5, #416]	; 0x1a0
				conn->llcp_length.tx_time = eff_tx_time;
 100d114:	f8a5 01a2 	strh.w	r0, [r5, #418]	; 0x1a2
				conn->llcp_length.state =
 100d118:	f885 419a 	strb.w	r4, [r5, #410]	; 0x19a
			lr->max_rx_octets = sys_cpu_to_le16(eff_rx_octets);
 100d11c:	f8a6 e024 	strh.w	lr, [r6, #36]	; 0x24
			lr->max_tx_octets = sys_cpu_to_le16(eff_tx_octets);
 100d120:	8532      	strh	r2, [r6, #40]	; 0x28
			lr->max_rx_time = sys_cpu_to_le16(eff_rx_time);
 100d122:	f8a6 c026 	strh.w	ip, [r6, #38]	; 0x26
			lr->max_tx_time = sys_cpu_to_le16(eff_tx_time);
 100d126:	8570      	strh	r0, [r6, #42]	; 0x2a
 100d128:	e5c4      	b.n	100ccb4 <ull_conn_rx+0x102c>
		conn->tx_data_last = tx;
 100d12a:	f8c5 41c0 	str.w	r4, [r5, #448]	; 0x1c0
		if (nack) {
 100d12e:	f7ff bb1b 	b.w	100c768 <ull_conn_rx+0xae0>
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d132:	2203      	movs	r2, #3
		return BT_HCI_ERR_DIFF_TRANS_COLLISION;
 100d134:	232a      	movs	r3, #42	; 0x2a
		(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d136:	7132      	strb	r2, [r6, #4]
		if (err) {
 100d138:	e77c      	b.n	100d034 <ull_conn_rx+0x13ac>
 100d13a:	bf00      	nop
 100d13c:	210038cc 	.word	0x210038cc
		} else if (conn->llcp_phy.req !=
 100d140:	f895 01a8 	ldrb.w	r0, [r5, #424]	; 0x1a8
 100d144:	f895 31a9 	ldrb.w	r3, [r5, #425]	; 0x1a9
 100d148:	4283      	cmp	r3, r0
 100d14a:	f000 811f 	beq.w	100d38c <ull_conn_rx+0x1704>
			lll->phy_tx_time = lll->phy_tx;
 100d14e:	f895 2064 	ldrb.w	r2, [r5, #100]	; 0x64
			conn->llcp_phy.pause_tx = 0U;
 100d152:	f895 31ab 	ldrb.w	r3, [r5, #427]	; 0x1ab
			lll->phy_tx_time = lll->phy_tx;
 100d156:	4611      	mov	r1, r2
			conn->llcp_phy.pause_tx = 0U;
 100d158:	f023 0309 	bic.w	r3, r3, #9
 100d15c:	f043 0308 	orr.w	r3, r3, #8
			lll->phy_tx_time = lll->phy_tx;
 100d160:	f362 1106 	bfi	r1, r2, #4, #3
			if (conn->llcp_phy.cmd) {
 100d164:	075f      	lsls	r7, r3, #29
			conn->llcp_phy.ack = conn->llcp_phy.req;
 100d166:	f885 01a9 	strb.w	r0, [r5, #425]	; 0x1a9
			lll->phy_tx_time = lll->phy_tx;
 100d16a:	f885 1064 	strb.w	r1, [r5, #100]	; 0x64
 100d16e:	f3c2 0202 	ubfx	r2, r2, #0, #3
			conn->llcp_phy.pause_tx = 0U;
 100d172:	f885 31ab 	strb.w	r3, [r5, #427]	; 0x1ab
			if (conn->llcp_phy.cmd) {
 100d176:	f140 8104 	bpl.w	100d382 <ull_conn_rx+0x16fa>
				p->status = 0U;
 100d17a:	2300      	movs	r3, #0
				(*rx)->hdr.type = NODE_RX_TYPE_PHY_UPDATE;
 100d17c:	200e      	movs	r0, #14
 100d17e:	6821      	ldr	r1, [r4, #0]
 100d180:	7108      	strb	r0, [r1, #4]
				p->tx = lll->phy_tx;
 100d182:	f886 2021 	strb.w	r2, [r6, #33]	; 0x21
				p->status = 0U;
 100d186:	f886 3020 	strb.w	r3, [r6, #32]
				p->rx = lll->phy_rx;
 100d18a:	f895 3065 	ldrb.w	r3, [r5, #101]	; 0x65
 100d18e:	f3c3 0302 	ubfx	r3, r3, #0, #3
 100d192:	f886 3022 	strb.w	r3, [r6, #34]	; 0x22
 100d196:	f7fe beb4 	b.w	100bf02 <ull_conn_rx+0x27a>
			eff_rx_time = MAX(eff_rx_time,
 100d19a:	f44f 6a29 	mov.w	sl, #2704	; 0xa90
 100d19e:	e560      	b.n	100cc62 <ull_conn_rx+0xfda>
	struct node_tx *tx = NULL;
 100d1a0:	2100      	movs	r1, #0
 100d1a2:	f7fe bed6 	b.w	100bf52 <ull_conn_rx+0x2ca>
		conn_upd_curr = conn;
 100d1a6:	601d      	str	r5, [r3, #0]
 100d1a8:	f7ff b9b2 	b.w	100c510 <ull_conn_rx+0x888>
	    (!feature_coded_phy && !feature_phy_2m)) {
 100d1ac:	f410 7f80 	tst.w	r0, #256	; 0x100
		tx_time = MAX(MIN(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_1M),
 100d1b0:	f44f 70a4 	mov.w	r0, #328	; 0x148
	    (!feature_coded_phy && !feature_phy_2m)) {
 100d1b4:	f000 80f8 	beq.w	100d3a8 <ull_conn_rx+0x1720>
		rx_time = MAX(PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_2M),
 100d1b8:	f04f 0ca8 	mov.w	ip, #168	; 0xa8
 100d1bc:	e516      	b.n	100cbec <ull_conn_rx+0xf64>
			eff_tx_time = MAX(eff_tx_time,
 100d1be:	f44f 6029 	mov.w	r0, #2704	; 0xa90
 100d1c2:	e52d      	b.n	100cc20 <ull_conn_rx+0xf98>
				conn->llcp_length.state =
 100d1c4:	2604      	movs	r6, #4
 100d1c6:	f895 319a 	ldrb.w	r3, [r5, #410]	; 0x19a
				conn->lll.max_tx_octets = eff_tx_octets;
 100d1ca:	f8a5 205c 	strh.w	r2, [r5, #92]	; 0x5c
				conn->llcp_length.state =
 100d1ce:	f366 0302 	bfi	r3, r6, #0, #3
				conn->lll.max_tx_time = eff_tx_time;
 100d1d2:	f8a5 0060 	strh.w	r0, [r5, #96]	; 0x60
				conn->llcp_length.state =
 100d1d6:	f885 319a 	strb.w	r3, [r5, #410]	; 0x19a
 100d1da:	e561      	b.n	100cca0 <ull_conn_rx+0x1018>
				      0x03) == 0x02) &&
 100d1dc:	f895 20ea 	ldrb.w	r2, [r5, #234]	; 0xea
 100d1e0:	2a03      	cmp	r2, #3
 100d1e2:	f47f acb3 	bne.w	100cb4c <ull_conn_rx+0xec4>
 100d1e6:	e4aa      	b.n	100cb3e <ull_conn_rx+0xeb6>
				u16_t interval_min =
 100d1e8:	8cb2      	ldrh	r2, [r6, #36]	; 0x24
 100d1ea:	f8ad 2004 	strh.w	r2, [sp, #4]
 100d1ee:	b292      	uxth	r2, r2
				if ((interval_min < 6) ||
 100d1f0:	2a05      	cmp	r2, #5
 100d1f2:	f67f ae87 	bls.w	100cf04 <ull_conn_rx+0x127c>
				u16_t interval_max =
 100d1f6:	f8b6 8026 	ldrh.w	r8, [r6, #38]	; 0x26
 100d1fa:	fa1f f188 	uxth.w	r1, r8
				if ((interval_min < 6) ||
 100d1fe:	f5b1 6f48 	cmp.w	r1, #3200	; 0xc80
 100d202:	f63f ae7f 	bhi.w	100cf04 <ull_conn_rx+0x127c>
				    (interval_max > 3200) ||
 100d206:	428a      	cmp	r2, r1
 100d208:	f63f ae7c 	bhi.w	100cf04 <ull_conn_rx+0x127c>
				u16_t latency =
 100d20c:	f8b6 e028 	ldrh.w	lr, [r6, #40]	; 0x28
 100d210:	fa1f f08e 	uxth.w	r0, lr
				    (interval_min > interval_max) ||
 100d214:	f5b0 7ffa 	cmp.w	r0, #500	; 0x1f4
 100d218:	f4bf ae74 	bcs.w	100cf04 <ull_conn_rx+0x127c>
				    (latency > 499) ||
 100d21c:	f640 4a76 	movw	sl, #3190	; 0xc76
				u16_t timeout =
 100d220:	f8b6 b02a 	ldrh.w	fp, [r6, #42]	; 0x2a
 100d224:	fa1f f28b 	uxth.w	r2, fp
				    (latency > 499) ||
 100d228:	f1a2 0c0a 	sub.w	ip, r2, #10
 100d22c:	fa1f fc8c 	uxth.w	ip, ip
 100d230:	45d4      	cmp	ip, sl
 100d232:	f63f ae67 	bhi.w	100cf04 <ull_conn_rx+0x127c>
				     ((latency + 1) * interval_max)) ||
 100d236:	fb00 1c01 	mla	ip, r0, r1, r1
				    (timeout > 3200) ||
 100d23a:	ebbc 0f82 	cmp.w	ip, r2, lsl #2
 100d23e:	f4bf ae61 	bcs.w	100cf04 <ull_conn_rx+0x127c>
				     ((latency + 1) * interval_max)) ||
 100d242:	f896 a02c 	ldrb.w	sl, [r6, #44]	; 0x2c
 100d246:	4551      	cmp	r1, sl
					cpr->preferred_periodicity;
 100d248:	46d4      	mov	ip, sl
				     ((latency + 1) * interval_max)) ||
 100d24a:	f4ff ae5b 	bcc.w	100cf04 <ull_conn_rx+0x127c>
				conn->llcp_conn_param.interval_min =
 100d24e:	f8bd a004 	ldrh.w	sl, [sp, #4]
				conn->llcp_conn_param.latency =	latency;
 100d252:	f8a5 e178 	strh.w	lr, [r5, #376]	; 0x178
				conn->llcp_conn_param.interval_min =
 100d256:	f8a5 a174 	strh.w	sl, [r5, #372]	; 0x174
				conn->llcp_conn_param.interval_max =
 100d25a:	f8a5 8176 	strh.w	r8, [r5, #374]	; 0x176
				conn->llcp_conn_param.timeout =	timeout;
 100d25e:	f8a5 b17a 	strh.w	fp, [r5, #378]	; 0x17a
				conn->llcp_conn_param.preferred_periodicity =
 100d262:	f885 c17c 	strb.w	ip, [r5, #380]	; 0x17c
					sys_le16_to_cpu(cpr->reference_conn_event_count);
 100d266:	f896 802e 	ldrb.w	r8, [r6, #46]	; 0x2e
 100d26a:	f896 c02d 	ldrb.w	ip, [r6, #45]	; 0x2d
				     lll->interval) ||
 100d26e:	f8b5 e02e 	ldrh.w	lr, [r5, #46]	; 0x2e
					sys_le16_to_cpu(cpr->reference_conn_event_count);
 100d272:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
				conn->llcp_conn_param.reference_conn_event_count =
 100d276:	f8a5 c17e 	strh.w	ip, [r5, #382]	; 0x17e
					sys_le16_to_cpu(cpr->offset0);
 100d27a:	f896 8030 	ldrb.w	r8, [r6, #48]	; 0x30
 100d27e:	f896 c02f 	ldrb.w	ip, [r6, #47]	; 0x2f
				if ((conn->llcp_conn_param.interval_max !=
 100d282:	4571      	cmp	r1, lr
					sys_le16_to_cpu(cpr->offset0);
 100d284:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
				conn->llcp_conn_param.offset0 =
 100d288:	f8a5 c180 	strh.w	ip, [r5, #384]	; 0x180
					sys_le16_to_cpu(cpr->offset1);
 100d28c:	f896 8032 	ldrb.w	r8, [r6, #50]	; 0x32
 100d290:	f896 c031 	ldrb.w	ip, [r6, #49]	; 0x31
 100d294:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
				conn->llcp_conn_param.offset1 =
 100d298:	f8a5 c182 	strh.w	ip, [r5, #386]	; 0x182
					sys_le16_to_cpu(cpr->offset2);
 100d29c:	f896 8034 	ldrb.w	r8, [r6, #52]	; 0x34
 100d2a0:	f896 c033 	ldrb.w	ip, [r6, #51]	; 0x33
 100d2a4:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
				conn->llcp_conn_param.offset2 =
 100d2a8:	f8a5 c184 	strh.w	ip, [r5, #388]	; 0x184
					sys_le16_to_cpu(cpr->offset3);
 100d2ac:	f896 8036 	ldrb.w	r8, [r6, #54]	; 0x36
 100d2b0:	f896 c035 	ldrb.w	ip, [r6, #53]	; 0x35
 100d2b4:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
				conn->llcp_conn_param.offset3 =
 100d2b8:	f8a5 c186 	strh.w	ip, [r5, #390]	; 0x186
					sys_le16_to_cpu(cpr->offset4);
 100d2bc:	f896 c037 	ldrb.w	ip, [r6, #55]	; 0x37
 100d2c0:	f896 8038 	ldrb.w	r8, [r6, #56]	; 0x38
 100d2c4:	ea4c 2c08 	orr.w	ip, ip, r8, lsl #8
				conn->llcp_conn_param.offset4 =
 100d2c8:	f8a5 c188 	strh.w	ip, [r5, #392]	; 0x188
					sys_le16_to_cpu(cpr->offset5);
 100d2cc:	f896 c039 	ldrb.w	ip, [r6, #57]	; 0x39
 100d2d0:	f896 603a 	ldrb.w	r6, [r6, #58]	; 0x3a
 100d2d4:	ea4c 2606 	orr.w	r6, ip, r6, lsl #8
				conn->llcp_conn_param.offset5 =
 100d2d8:	f8a5 618a 	strh.w	r6, [r5, #394]	; 0x18a
				if ((conn->llcp_conn_param.interval_max !=
 100d2dc:	f000 80cd 	beq.w	100d47a <ull_conn_rx+0x17f2>
					if (conn->llcp_enc.pause_tx) {
 100d2e0:	079e      	lsls	r6, r3, #30
 100d2e2:	f140 80c2 	bpl.w	100d46a <ull_conn_rx+0x17e2>
						conn->llcp_conn_param.state =
 100d2e6:	2002      	movs	r0, #2
						(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d2e8:	2103      	movs	r1, #3
						conn->llcp_conn_param.state =
 100d2ea:	f895 3172 	ldrb.w	r3, [r5, #370]	; 0x172
						(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d2ee:	6822      	ldr	r2, [r4, #0]
						conn->llcp_conn_param.state =
 100d2f0:	f360 0302 	bfi	r3, r0, #0, #3
 100d2f4:	f885 3172 	strb.w	r3, [r5, #370]	; 0x172
						(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d2f8:	7111      	strb	r1, [r2, #4]
				conn->llcp_conn_param.ack--;
 100d2fa:	9b00      	ldr	r3, [sp, #0]
 100d2fc:	3b01      	subs	r3, #1
 100d2fe:	f885 3171 	strb.w	r3, [r5, #369]	; 0x171
				if (!conn_upd_curr) {
 100d302:	f1b9 0f00 	cmp.w	r9, #0
 100d306:	f47e ad7b 	bne.w	100be00 <ull_conn_rx+0x178>
 100d30a:	e5f7      	b.n	100cefc <ull_conn_rx+0x1274>
	else if (rej_ext_ind->error_code != BT_HCI_ERR_LL_PROC_COLLISION) {
 100d30c:	2a23      	cmp	r2, #35	; 0x23
 100d30e:	f43f ab05 	beq.w	100c91c <ull_conn_rx+0xc94>
			conn->slave.ticks_to_offset =
 100d312:	f8d5 2194 	ldr.w	r2, [r5, #404]	; 0x194
 100d316:	f8c5 20e4 	str.w	r2, [r5, #228]	; 0xe4
 100d31a:	f7ff baff 	b.w	100c91c <ull_conn_rx+0xc94>
				conn->lll.max_tx_octets = eff_tx_octets;
 100d31e:	f8a5 205c 	strh.w	r2, [r5, #92]	; 0x5c
				conn->lll.max_tx_time = eff_tx_time;
 100d322:	f8a5 0060 	strh.w	r0, [r5, #96]	; 0x60
 100d326:	e6f9      	b.n	100d11c <ull_conn_rx+0x1494>
			if (eff_tx_octets == conn->lll.max_tx_octets &&
 100d328:	4548      	cmp	r0, r9
 100d32a:	f47f aedf 	bne.w	100d0ec <ull_conn_rx+0x1464>
			    eff_rx_time == conn->lll.max_rx_time &&
 100d32e:	45c4      	cmp	ip, r8
 100d330:	f47f aedc 	bne.w	100d0ec <ull_conn_rx+0x1464>
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d334:	2603      	movs	r6, #3
 100d336:	6823      	ldr	r3, [r4, #0]
 100d338:	711e      	strb	r6, [r3, #4]
				goto send_length_resp;
 100d33a:	e4bb      	b.n	100ccb4 <ull_conn_rx+0x102c>
			tx->next = conn->tx_head->next;
 100d33c:	681a      	ldr	r2, [r3, #0]
 100d33e:	6022      	str	r2, [r4, #0]
			conn->tx_head->next = tx;
 100d340:	601c      	str	r4, [r3, #0]
				conn->tx_ctrl_last = tx;
 100d342:	e9c5 446d 	strd	r4, r4, [r5, #436]	; 0x1b4
 100d346:	f7ff ba0b 	b.w	100c760 <ull_conn_rx+0xad8>
		LL_ASSERT(conn_upd_curr == conn);
 100d34a:	4f5c      	ldr	r7, [pc, #368]	; (100d4bc <ull_conn_rx+0x1834>)
 100d34c:	6839      	ldr	r1, [r7, #0]
 100d34e:	428d      	cmp	r5, r1
 100d350:	d008      	beq.n	100d364 <ull_conn_rx+0x16dc>
 100d352:	f241 019b 	movw	r1, #4251	; 0x109b
 100d356:	485a      	ldr	r0, [pc, #360]	; (100d4c0 <ull_conn_rx+0x1838>)
 100d358:	f7f6 f916 	bl	1003588 <bt_ctlr_assert_handle>
 100d35c:	f895 3170 	ldrb.w	r3, [r5, #368]	; 0x170
 100d360:	f895 2172 	ldrb.w	r2, [r5, #370]	; 0x172
		conn_upd_curr = NULL;
 100d364:	2100      	movs	r1, #0
		conn->llcp_conn_param.ack = conn->llcp_conn_param.req;
 100d366:	f885 3171 	strb.w	r3, [r5, #369]	; 0x171
		conn_upd_curr = NULL;
 100d36a:	6039      	str	r1, [r7, #0]
		conn->procedure_expire = 0U;
 100d36c:	f8a5 10cc 	strh.w	r1, [r5, #204]	; 0xcc
 100d370:	f7ff badb 	b.w	100c92a <ull_conn_rx+0xca2>
			tx->next = conn->tx_head->next;
 100d374:	6811      	ldr	r1, [r2, #0]
 100d376:	6019      	str	r1, [r3, #0]
			conn->tx_head->next = tx;
 100d378:	6013      	str	r3, [r2, #0]
				conn->tx_ctrl_last = tx;
 100d37a:	e9c5 336d 	strd	r3, r3, [r5, #436]	; 0x1b4
 100d37e:	f7fe bedb 	b.w	100c138 <ull_conn_rx+0x4b0>
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d382:	2203      	movs	r2, #3
 100d384:	6823      	ldr	r3, [r4, #0]
 100d386:	711a      	strb	r2, [r3, #4]
 100d388:	f7fe bdbb 	b.w	100bf02 <ull_conn_rx+0x27a>
			switch (llctrl->unknown_rsp.type) {
 100d38c:	f896 3024 	ldrb.w	r3, [r6, #36]	; 0x24
 100d390:	2b12      	cmp	r3, #18
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d392:	bf04      	itt	eq
 100d394:	2303      	moveq	r3, #3
 100d396:	7133      	strbeq	r3, [r6, #4]
				break;
 100d398:	f7fe bdb3 	b.w	100bf02 <ull_conn_rx+0x27a>
	LL_ASSERT(rx_dle);
 100d39c:	f241 3113 	movw	r1, #4883	; 0x1313
 100d3a0:	4847      	ldr	r0, [pc, #284]	; (100d4c0 <ull_conn_rx+0x1838>)
 100d3a2:	f7f6 f8f1 	bl	1003588 <bt_ctlr_assert_handle>
 100d3a6:	e60e      	b.n	100cfc6 <ull_conn_rx+0x133e>
		rx_time = PKT_US(LL_LENGTH_OCTETS_RX_MAX, PHY_1M);
 100d3a8:	4684      	mov	ip, r0
 100d3aa:	e41f      	b.n	100cbec <ull_conn_rx+0xf64>
	     ((((conn->llcp_length.state == LLCP_LENGTH_STATE_REQ) ||
 100d3ac:	f895 219a 	ldrb.w	r2, [r5, #410]	; 0x19a
	    ((conn->llcp_length.req != conn->llcp_length.ack) &&
 100d3b0:	f012 0f06 	tst.w	r2, #6
 100d3b4:	f43f abf2 	beq.w	100cb9c <ull_conn_rx+0xf14>
 100d3b8:	f7fe bdc4 	b.w	100bf44 <ull_conn_rx+0x2bc>
			     lll->interval) ||
 100d3bc:	8e2e      	ldrh	r6, [r5, #48]	; 0x30
 100d3be:	4286      	cmp	r6, r0
 100d3c0:	f47f ad8e 	bne.w	100cee0 <ull_conn_rx+0x1258>
			    (RADIO_CONN_EVENTS(conn->llcp_conn_param.timeout *
 100d3c4:	f240 40e2 	movw	r0, #1250	; 0x4e2
 100d3c8:	f242 7610 	movw	r6, #10000	; 0x2710
 100d3cc:	fb00 f202 	mul.w	r2, r0, r2
 100d3d0:	fb06 2303 	mla	r3, r6, r3, r2
 100d3d4:	3b01      	subs	r3, #1
 100d3d6:	fbb3 f3f2 	udiv	r3, r3, r2
			    (conn->llcp_conn_param.latency != lll->latency) ||
 100d3da:	f8b5 20c6 	ldrh.w	r2, [r5, #198]	; 0xc6
 100d3de:	b29b      	uxth	r3, r3
 100d3e0:	429a      	cmp	r2, r3
 100d3e2:	f47f ad7d 	bne.w	100cee0 <ull_conn_rx+0x1258>
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d3e6:	2203      	movs	r2, #3
				conn->llcp_conn_param.state =
 100d3e8:	f8b5 3172 	ldrh.w	r3, [r5, #370]	; 0x172
 100d3ec:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 100d3f0:	f043 0301 	orr.w	r3, r3, #1
 100d3f4:	f8a5 3172 	strh.w	r3, [r5, #370]	; 0x172
				(*rx)->hdr.type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d3f8:	6823      	ldr	r3, [r4, #0]
 100d3fa:	711a      	strb	r2, [r3, #4]
 100d3fc:	e577      	b.n	100ceee <ull_conn_rx+0x1266>
		LL_ASSERT(conn->llcp_cu.req == conn->llcp_cu.ack);
 100d3fe:	f895 2104 	ldrb.w	r2, [r5, #260]	; 0x104
 100d402:	f895 3105 	ldrb.w	r3, [r5, #261]	; 0x105
 100d406:	429a      	cmp	r2, r3
 100d408:	d006      	beq.n	100d418 <ull_conn_rx+0x1790>
 100d40a:	f44f 5184 	mov.w	r1, #4224	; 0x1080
 100d40e:	482c      	ldr	r0, [pc, #176]	; (100d4c0 <ull_conn_rx+0x1838>)
 100d410:	f7f6 f8ba 	bl	1003588 <bt_ctlr_assert_handle>
 100d414:	f895 3105 	ldrb.w	r3, [r5, #261]	; 0x105
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
 100d418:	2105      	movs	r1, #5
		conn->llcp_cu.win_size = 1U;
 100d41a:	2401      	movs	r4, #1
		conn->llcp_cu.win_offset_us = 0U;
 100d41c:	2000      	movs	r0, #0
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
 100d41e:	f895 2172 	ldrb.w	r2, [r5, #370]	; 0x172
		conn->llcp_cu.ack--;
 100d422:	1e5f      	subs	r7, r3, #1
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
 100d424:	f361 0202 	bfi	r2, r1, #0, #3
		conn->llcp_cu.cmd = conn->llcp_conn_param.cmd;
 100d428:	f3c2 03c0 	ubfx	r3, r2, #3, #1
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
 100d42c:	f895 1106 	ldrb.w	r1, [r5, #262]	; 0x106
 100d430:	009b      	lsls	r3, r3, #2
 100d432:	f021 0107 	bic.w	r1, r1, #7
 100d436:	4323      	orrs	r3, r4
 100d438:	430b      	orrs	r3, r1
		conn->llcp_conn_param.state = LLCP_CPR_STATE_UPD;
 100d43a:	f885 2172 	strb.w	r2, [r5, #370]	; 0x172
		conn->llcp_cu.interval = conn->llcp_conn_param.interval_max;
 100d43e:	f8b5 1176 	ldrh.w	r1, [r5, #374]	; 0x176
		conn->llcp_cu.latency = conn->llcp_conn_param.latency;
 100d442:	f8b5 2178 	ldrh.w	r2, [r5, #376]	; 0x178
		conn->llcp_cu.state = LLCP_CUI_STATE_USE;
 100d446:	f885 3106 	strb.w	r3, [r5, #262]	; 0x106
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
 100d44a:	f8b5 317a 	ldrh.w	r3, [r5, #378]	; 0x17a
		conn->llcp_cu.ack--;
 100d44e:	f885 7105 	strb.w	r7, [r5, #261]	; 0x105
		conn->llcp_cu.win_size = 1U;
 100d452:	f885 4114 	strb.w	r4, [r5, #276]	; 0x114
		conn->llcp_cu.win_offset_us = 0U;
 100d456:	f8c5 0110 	str.w	r0, [r5, #272]	; 0x110
		conn->llcp_cu.interval = conn->llcp_conn_param.interval_max;
 100d45a:	f8a5 1108 	strh.w	r1, [r5, #264]	; 0x108
		conn->llcp_cu.latency = conn->llcp_conn_param.latency;
 100d45e:	f8a5 210a 	strh.w	r2, [r5, #266]	; 0x10a
		conn->llcp_cu.timeout = conn->llcp_conn_param.timeout;
 100d462:	f8a5 310c 	strh.w	r3, [r5, #268]	; 0x10c
	if (err) {
 100d466:	f7fe bd09 	b.w	100be7c <ull_conn_rx+0x1f4>
						conn->llcp_conn_param.state =
 100d46a:	2203      	movs	r2, #3
 100d46c:	f895 3172 	ldrb.w	r3, [r5, #370]	; 0x172
 100d470:	f362 0302 	bfi	r3, r2, #0, #3
 100d474:	f885 3172 	strb.w	r3, [r5, #370]	; 0x172
 100d478:	e73f      	b.n	100d2fa <ull_conn_rx+0x1672>
				     lll->interval) ||
 100d47a:	8e29      	ldrh	r1, [r5, #48]	; 0x30
 100d47c:	4281      	cmp	r1, r0
 100d47e:	f47f af2f 	bne.w	100d2e0 <ull_conn_rx+0x1658>
				    (RADIO_CONN_EVENTS(conn->llcp_conn_param.timeout *
 100d482:	f240 41e2 	movw	r1, #1250	; 0x4e2
 100d486:	f242 7010 	movw	r0, #10000	; 0x2710
 100d48a:	fb01 f10e 	mul.w	r1, r1, lr
 100d48e:	fb00 1202 	mla	r2, r0, r2, r1
 100d492:	3a01      	subs	r2, #1
 100d494:	fbb2 f2f1 	udiv	r2, r2, r1
				     lll->latency) ||
 100d498:	f8b5 10c6 	ldrh.w	r1, [r5, #198]	; 0xc6
 100d49c:	b292      	uxth	r2, r2
 100d49e:	4291      	cmp	r1, r2
 100d4a0:	f47f af1e 	bne.w	100d2e0 <ull_conn_rx+0x1658>
					(*rx)->hdr.type =
 100d4a4:	2203      	movs	r2, #3
					conn->llcp_conn_param.state =
 100d4a6:	f8b5 3172 	ldrh.w	r3, [r5, #370]	; 0x172
 100d4aa:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 100d4ae:	f043 0301 	orr.w	r3, r3, #1
 100d4b2:	f8a5 3172 	strh.w	r3, [r5, #370]	; 0x172
					(*rx)->hdr.type =
 100d4b6:	6823      	ldr	r3, [r4, #0]
 100d4b8:	711a      	strb	r2, [r3, #4]
 100d4ba:	e71e      	b.n	100d2fa <ull_conn_rx+0x1672>
 100d4bc:	210037c0 	.word	0x210037c0
 100d4c0:	010187e4 	.word	0x010187e4

0100d4c4 <ull_conn_tx_demux>:
{
 100d4c4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 100d4c8:	4c3d      	ldr	r4, [pc, #244]	; (100d5c0 <ull_conn_tx_demux+0xfc>)
 100d4ca:	4605      	mov	r5, r0
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100d4cc:	4f3d      	ldr	r7, [pc, #244]	; (100d5c4 <ull_conn_tx_demux+0x100>)
 100d4ce:	78e1      	ldrb	r1, [r4, #3]
	return (void *)(fifo + first * size);
 100d4d0:	1d26      	adds	r6, r4, #4
 100d4d2:	e02e      	b.n	100d532 <ull_conn_tx_demux+0x6e>
 100d4d4:	4642      	mov	r2, r8
 100d4d6:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100d4da:	4638      	mov	r0, r7
 100d4dc:	f7f8 fbd2 	bl	1005c84 <mem_get>
	if (conn->lll.handle != handle) {
 100d4e0:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100d4e2:	4603      	mov	r3, r0
	if (conn->lll.handle != handle) {
 100d4e4:	4590      	cmp	r8, r2
 100d4e6:	d132      	bne.n	100d54e <ull_conn_tx_demux+0x8a>
			struct node_tx *tx = lll_tx->node;
 100d4e8:	f8d9 1004 	ldr.w	r1, [r9, #4]
	if ((p->ll_id == PDU_DATA_LLID_DATA_START) && !p->len) {
 100d4ec:	790a      	ldrb	r2, [r1, #4]
 100d4ee:	7948      	ldrb	r0, [r1, #5]
 100d4f0:	f002 0203 	and.w	r2, r2, #3
 100d4f4:	2a02      	cmp	r2, #2
 100d4f6:	d035      	beq.n	100d564 <ull_conn_tx_demux+0xa0>
	} else if (p->len && conn->start_empty) {
 100d4f8:	2800      	cmp	r0, #0
 100d4fa:	d134      	bne.n	100d566 <ull_conn_tx_demux+0xa2>
			tx->next = NULL;
 100d4fc:	2000      	movs	r0, #0
			if (!conn->tx_data) {
 100d4fe:	f8d3 21bc 	ldr.w	r2, [r3, #444]	; 0x1bc
			tx->next = NULL;
 100d502:	6008      	str	r0, [r1, #0]
			if (!conn->tx_data) {
 100d504:	2a00      	cmp	r2, #0
 100d506:	d045      	beq.n	100d594 <ull_conn_tx_demux+0xd0>
			if (conn->tx_data_last) {
 100d508:	f8d3 21c0 	ldr.w	r2, [r3, #448]	; 0x1c0
 100d50c:	b102      	cbz	r2, 100d510 <ull_conn_tx_demux+0x4c>
				conn->tx_data_last->next = tx;
 100d50e:	6011      	str	r1, [r2, #0]
			conn->tx_data_last = tx;
 100d510:	f8c3 11c0 	str.w	r1, [r3, #448]	; 0x1c0
		MFIFO_DEQUEUE(conn_tx);
 100d514:	78e1      	ldrb	r1, [r4, #3]
	u8_t _first = *first; /* Copy read-index */
 100d516:	78a3      	ldrb	r3, [r4, #2]
 100d518:	7862      	ldrb	r2, [r4, #1]
	if (_first == last) {
 100d51a:	4299      	cmp	r1, r3
 100d51c:	d005      	beq.n	100d52a <ull_conn_tx_demux+0x66>
	_first += 1U;
 100d51e:	3301      	adds	r3, #1
 100d520:	b2db      	uxtb	r3, r3
		_first = 0U;
 100d522:	429a      	cmp	r2, r3
 100d524:	bf08      	it	eq
 100d526:	2300      	moveq	r3, #0
	*first = _first; /* Write back read-index */
 100d528:	70a3      	strb	r3, [r4, #2]
	} while (--count);
 100d52a:	3d01      	subs	r5, #1
 100d52c:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
 100d530:	d039      	beq.n	100d5a6 <ull_conn_tx_demux+0xe2>
		lll_tx = MFIFO_DEQUEUE_GET(conn_tx);
 100d532:	78a2      	ldrb	r2, [r4, #2]
 100d534:	7823      	ldrb	r3, [r4, #0]
	if (first == last) {
 100d536:	428a      	cmp	r2, r1
 100d538:	d035      	beq.n	100d5a6 <ull_conn_tx_demux+0xe2>
	return (void *)(fifo + first * size);
 100d53a:	fb03 f302 	mul.w	r3, r3, r2
		if (!lll_tx) {
 100d53e:	eb16 0903 	adds.w	r9, r6, r3
 100d542:	d030      	beq.n	100d5a6 <ull_conn_tx_demux+0xe2>
		conn = ll_connected_get(lll_tx->handle);
 100d544:	f836 8003 	ldrh.w	r8, [r6, r3]
	if (handle >= CONFIG_BT_MAX_CONN) {
 100d548:	f1b8 0f0f 	cmp.w	r8, #15
 100d54c:	d9c2      	bls.n	100d4d4 <ull_conn_tx_demux+0x10>
			struct node_tx *tx = lll_tx->node;
 100d54e:	f8d9 1004 	ldr.w	r1, [r9, #4]
			ll_tx_ack_put(0xFFFF, tx);
 100d552:	f64f 70ff 	movw	r0, #65535	; 0xffff
			p->ll_id = PDU_DATA_LLID_RESV;
 100d556:	790b      	ldrb	r3, [r1, #4]
 100d558:	f36f 0301 	bfc	r3, #0, #2
 100d55c:	710b      	strb	r3, [r1, #4]
			ll_tx_ack_put(0xFFFF, tx);
 100d55e:	f7fc fd9b 	bl	100a098 <ll_tx_ack_put>
 100d562:	e7d7      	b.n	100d514 <ull_conn_tx_demux+0x50>
	if ((p->ll_id == PDU_DATA_LLID_DATA_START) && !p->len) {
 100d564:	b308      	cbz	r0, 100d5aa <ull_conn_tx_demux+0xe6>
	} else if (p->len && conn->start_empty) {
 100d566:	f993 01ac 	ldrsb.w	r0, [r3, #428]	; 0x1ac
 100d56a:	2800      	cmp	r0, #0
 100d56c:	dac6      	bge.n	100d4fc <ull_conn_tx_demux+0x38>
		conn->start_empty = 0U;
 100d56e:	f893 01ac 	ldrb.w	r0, [r3, #428]	; 0x1ac
		if (p->ll_id == PDU_DATA_LLID_DATA_CONTINUE) {
 100d572:	2a01      	cmp	r2, #1
		conn->start_empty = 0U;
 100d574:	f36f 10c7 	bfc	r0, #7, #1
 100d578:	f883 01ac 	strb.w	r0, [r3, #428]	; 0x1ac
		if (p->ll_id == PDU_DATA_LLID_DATA_CONTINUE) {
 100d57c:	d1be      	bne.n	100d4fc <ull_conn_tx_demux+0x38>
			p->ll_id = PDU_DATA_LLID_DATA_START;
 100d57e:	2002      	movs	r0, #2
 100d580:	790a      	ldrb	r2, [r1, #4]
 100d582:	f360 0201 	bfi	r2, r0, #0, #2
			tx->next = NULL;
 100d586:	2000      	movs	r0, #0
			p->ll_id = PDU_DATA_LLID_DATA_START;
 100d588:	710a      	strb	r2, [r1, #4]
			if (!conn->tx_data) {
 100d58a:	f8d3 21bc 	ldr.w	r2, [r3, #444]	; 0x1bc
			tx->next = NULL;
 100d58e:	6008      	str	r0, [r1, #0]
			if (!conn->tx_data) {
 100d590:	2a00      	cmp	r2, #0
 100d592:	d1b9      	bne.n	100d508 <ull_conn_tx_demux+0x44>
				if (!conn->tx_head) {
 100d594:	f8d3 21b0 	ldr.w	r2, [r3, #432]	; 0x1b0
				conn->tx_data = tx;
 100d598:	f8c3 11bc 	str.w	r1, [r3, #444]	; 0x1bc
				if (!conn->tx_head) {
 100d59c:	2a00      	cmp	r2, #0
 100d59e:	d1b3      	bne.n	100d508 <ull_conn_tx_demux+0x44>
					conn->tx_head = tx;
 100d5a0:	f8c3 11b0 	str.w	r1, [r3, #432]	; 0x1b0
			if (conn->tx_data_last) {
 100d5a4:	e7b4      	b.n	100d510 <ull_conn_tx_demux+0x4c>
}
 100d5a6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		conn->start_empty = 1U;
 100d5aa:	f893 21ac 	ldrb.w	r2, [r3, #428]	; 0x1ac
		ll_tx_ack_put(conn->lll.handle, tx);
 100d5ae:	4640      	mov	r0, r8
		conn->start_empty = 1U;
 100d5b0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 100d5b4:	f883 21ac 	strb.w	r2, [r3, #428]	; 0x1ac
		ll_tx_ack_put(conn->lll.handle, tx);
 100d5b8:	f7fc fd6e 	bl	100a098 <ll_tx_ack_put>
		return -EINVAL;
 100d5bc:	e7aa      	b.n	100d514 <ull_conn_tx_demux+0x50>
 100d5be:	bf00      	nop
 100d5c0:	21000358 	.word	0x21000358
 100d5c4:	21001b40 	.word	0x21001b40

0100d5c8 <conn_cleanup>:
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
 100d5c8:	2309      	movs	r3, #9
{
 100d5ca:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	rx->hdr.handle = conn->lll.handle;
 100d5ce:	8d82      	ldrh	r2, [r0, #44]	; 0x2c
	rx = conn->llcp_rx;
 100d5d0:	f8d0 4100 	ldr.w	r4, [r0, #256]	; 0x100
{
 100d5d4:	4606      	mov	r6, r0
 100d5d6:	b082      	sub	sp, #8
	*((u8_t *)rx->pdu) = reason;
 100d5d8:	f880 114c 	strb.w	r1, [r0, #332]	; 0x14c
	rx->hdr.handle = conn->lll.handle;
 100d5dc:	f8a0 2132 	strh.w	r2, [r0, #306]	; 0x132
	rx->hdr.type = NODE_RX_TYPE_TERMINATE;
 100d5e0:	f880 3130 	strb.w	r3, [r0, #304]	; 0x130
	struct lll_conn *lll = &conn->lll;
 100d5e4:	f100 0a1c 	add.w	sl, r0, #28
	while (rx) {
 100d5e8:	b144      	cbz	r4, 100d5fc <conn_cleanup+0x34>
		hdr->type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d5ea:	2503      	movs	r5, #3
		hdr = &rx->hdr;
 100d5ec:	4621      	mov	r1, r4
		rx = hdr->link->mem;
 100d5ee:	6820      	ldr	r0, [r4, #0]
 100d5f0:	6844      	ldr	r4, [r0, #4]
		hdr->type = NODE_RX_TYPE_DC_PDU_RELEASE;
 100d5f2:	710d      	strb	r5, [r1, #4]
		ll_rx_put(hdr->link, hdr);
 100d5f4:	f7fc fd0a 	bl	100a00c <ll_rx_put>
	while (rx) {
 100d5f8:	2c00      	cmp	r4, #0
 100d5fa:	d1f7      	bne.n	100d5ec <conn_cleanup+0x24>
	while (conn->tx_head) {
 100d5fc:	f8d6 11b0 	ldr.w	r1, [r6, #432]	; 0x1b0
 100d600:	b331      	cbz	r1, 100d650 <conn_cleanup+0x88>
		link = mem_acquire(&mem_link_tx.free);
 100d602:	f8df 808c 	ldr.w	r8, [pc, #140]	; 100d690 <conn_cleanup+0xc8>
		LL_ASSERT(link);
 100d606:	f8df 9084 	ldr.w	r9, [pc, #132]	; 100d68c <conn_cleanup+0xc4>
 100d60a:	f106 076c 	add.w	r7, r6, #108	; 0x6c
 100d60e:	e007      	b.n	100d620 <conn_cleanup+0x58>
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
 100d610:	4629      	mov	r1, r5
 100d612:	4620      	mov	r0, r4
 100d614:	463a      	mov	r2, r7
 100d616:	f7f8 fb67 	bl	1005ce8 <memq_enqueue>
	while (conn->tx_head) {
 100d61a:	f8d6 11b0 	ldr.w	r1, [r6, #432]	; 0x1b0
 100d61e:	b1b9      	cbz	r1, 100d650 <conn_cleanup+0x88>
		tx = tx_ull_dequeue(conn, conn->tx_head);
 100d620:	4630      	mov	r0, r6
 100d622:	f7fd fc1f 	bl	100ae64 <tx_ull_dequeue>
 100d626:	4605      	mov	r5, r0
		link = mem_acquire(&mem_link_tx.free);
 100d628:	4640      	mov	r0, r8
 100d62a:	f7f8 faf9 	bl	1005c20 <mem_acquire>
		LL_ASSERT(link);
 100d62e:	4604      	mov	r4, r0
 100d630:	2800      	cmp	r0, #0
 100d632:	d1ed      	bne.n	100d610 <conn_cleanup+0x48>
 100d634:	f240 61e3 	movw	r1, #1763	; 0x6e3
 100d638:	4648      	mov	r0, r9
 100d63a:	f7f5 ffa5 	bl	1003588 <bt_ctlr_assert_handle>
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
 100d63e:	4629      	mov	r1, r5
 100d640:	4620      	mov	r0, r4
 100d642:	463a      	mov	r2, r7
 100d644:	f7f8 fb50 	bl	1005ce8 <memq_enqueue>
	while (conn->tx_head) {
 100d648:	f8d6 11b0 	ldr.w	r1, [r6, #432]	; 0x1b0
 100d64c:	2900      	cmp	r1, #0
 100d64e:	d1e7      	bne.n	100d620 <conn_cleanup+0x58>
				    TICKER_ID_CONN_BASE + lll->handle,
 100d650:	f896 202c 	ldrb.w	r2, [r6, #44]	; 0x2c
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 100d654:	4b0c      	ldr	r3, [pc, #48]	; (100d688 <conn_cleanup+0xc0>)
				    TICKER_ID_CONN_BASE + lll->handle,
 100d656:	3205      	adds	r2, #5
	ticker_status = ticker_stop(TICKER_INSTANCE_ID_CTLR,
 100d658:	2101      	movs	r1, #1
 100d65a:	2000      	movs	r0, #0
 100d65c:	f8cd a000 	str.w	sl, [sp]
 100d660:	b2d2      	uxtb	r2, r2
 100d662:	f7f9 fde7 	bl	1007234 <ticker_stop>
	LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 100d666:	f030 0302 	bics.w	r3, r0, #2
 100d66a:	d004      	beq.n	100d676 <conn_cleanup+0xae>
 100d66c:	f44f 61da 	mov.w	r1, #1744	; 0x6d0
 100d670:	4806      	ldr	r0, [pc, #24]	; (100d68c <conn_cleanup+0xc4>)
 100d672:	f7f5 ff89 	bl	1003588 <bt_ctlr_assert_handle>
	lll->handle = 0xFFFF;
 100d676:	f64f 73ff 	movw	r3, #65535	; 0xffff
	ull_conn_tx_demux(UINT8_MAX);
 100d67a:	20ff      	movs	r0, #255	; 0xff
	lll->handle = 0xFFFF;
 100d67c:	85b3      	strh	r3, [r6, #44]	; 0x2c
}
 100d67e:	b002      	add	sp, #8
 100d680:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	ull_conn_tx_demux(UINT8_MAX);
 100d684:	f7ff bf1e 	b.w	100d4c4 <ull_conn_tx_demux>
 100d688:	0100b15d 	.word	0x0100b15d
 100d68c:	010187e4 	.word	0x010187e4
 100d690:	21003950 	.word	0x21003950

0100d694 <ull_conn_done>:
	if (lll->handle == 0xFFFF) {
 100d694:	f64f 73ff 	movw	r3, #65535	; 0xffff
{
 100d698:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct lll_conn *lll = (void *)HDR_ULL2LLL(done->param);
 100d69c:	6a06      	ldr	r6, [r0, #32]
{
 100d69e:	b08a      	sub	sp, #40	; 0x28
	if (lll->handle == 0xFFFF) {
 100d6a0:	8bb2      	ldrh	r2, [r6, #28]
 100d6a2:	429a      	cmp	r2, r3
 100d6a4:	d054      	beq.n	100d750 <ull_conn_done+0xbc>
	switch (done->extra.mic_state) {
 100d6a6:	f890 302b 	ldrb.w	r3, [r0, #43]	; 0x2b
 100d6aa:	4605      	mov	r5, r0
 100d6ac:	2b01      	cmp	r3, #1
	struct ll_conn *conn = (void *)HDR_LLL2EVT(lll);
 100d6ae:	68f4      	ldr	r4, [r6, #12]
	switch (done->extra.mic_state) {
 100d6b0:	f000 8138 	beq.w	100d924 <ull_conn_done+0x290>
 100d6b4:	2b02      	cmp	r3, #2
 100d6b6:	d045      	beq.n	100d744 <ull_conn_done+0xb0>
 100d6b8:	2b00      	cmp	r3, #0
 100d6ba:	f000 8114 	beq.w	100d8e6 <ull_conn_done+0x252>
	reason_peer = conn->llcp_terminate.reason_peer;
 100d6be:	f894 112b 	ldrb.w	r1, [r4, #299]	; 0x12b
	if (reason_peer && (
 100d6c2:	2900      	cmp	r1, #0
 100d6c4:	f040 80b5 	bne.w	100d832 <ull_conn_done+0x19e>
	latency_event = lll->latency_event;
 100d6c8:	8cb7      	ldrh	r7, [r6, #36]	; 0x24
	if (done->extra.trx_cnt) {
 100d6ca:	8d2b      	ldrh	r3, [r5, #40]	; 0x28
	elapsed_event = latency_event + 1;
 100d6cc:	f107 0801 	add.w	r8, r7, #1
	ticks_drift_minus = 0U;
 100d6d0:	e9cd 1108 	strd	r1, r1, [sp, #32]
	elapsed_event = latency_event + 1;
 100d6d4:	fa1f f888 	uxth.w	r8, r8
	if (done->extra.trx_cnt) {
 100d6d8:	2b00      	cmp	r3, #0
 100d6da:	d03c      	beq.n	100d756 <ull_conn_done+0xc2>
		} else if (lll->role) {
 100d6dc:	f996 302d 	ldrsb.w	r3, [r6, #45]	; 0x2d
 100d6e0:	2b00      	cmp	r3, #0
 100d6e2:	f2c0 812f 	blt.w	100d944 <ull_conn_done+0x2b0>
		conn->connect_expire = 0U;
 100d6e6:	2200      	movs	r2, #0
	if (done->extra.crc_valid) {
 100d6e8:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
		conn->connect_expire = 0U;
 100d6ec:	f8a4 20c4 	strh.w	r2, [r4, #196]	; 0xc4
	if (done->extra.crc_valid) {
 100d6f0:	bbb3      	cbnz	r3, 100d760 <ull_conn_done+0xcc>
		if (!conn->supervision_expire) {
 100d6f2:	f8b4 30c8 	ldrh.w	r3, [r4, #200]	; 0xc8
 100d6f6:	b933      	cbnz	r3, 100d706 <ull_conn_done+0x72>
			conn->supervision_expire = conn->supervision_reload;
 100d6f8:	f8b4 30c6 	ldrh.w	r3, [r4, #198]	; 0xc6
 100d6fc:	f8a4 30c8 	strh.w	r3, [r4, #200]	; 0xc8
	if (conn->supervision_expire) {
 100d700:	2b00      	cmp	r3, #0
 100d702:	f000 8157 	beq.w	100d9b4 <ull_conn_done+0x320>
		if (conn->supervision_expire > elapsed_event) {
 100d706:	4543      	cmp	r3, r8
 100d708:	f240 8127 	bls.w	100d95a <ull_conn_done+0x2c6>
			lll->latency_event = 0;
 100d70c:	2500      	movs	r5, #0
			conn->supervision_expire -= elapsed_event;
 100d70e:	eba3 0308 	sub.w	r3, r3, r8
 100d712:	b29b      	uxth	r3, r3
			if (conn->supervision_expire <= 6U) {
 100d714:	2b06      	cmp	r3, #6
			conn->supervision_expire -= elapsed_event;
 100d716:	f8a4 30c8 	strh.w	r3, [r4, #200]	; 0xc8
			lll->latency_event = 0;
 100d71a:	84b5      	strh	r5, [r6, #36]	; 0x24
			if (conn->supervision_expire <= 6U) {
 100d71c:	f240 8108 	bls.w	100d930 <ull_conn_done+0x29c>
			else if (lll->role) {
 100d720:	f996 302d 	ldrsb.w	r3, [r6, #45]	; 0x2d
 100d724:	42ab      	cmp	r3, r5
 100d726:	da1e      	bge.n	100d766 <ull_conn_done+0xd2>
				if (latency_event) {
 100d728:	2f00      	cmp	r7, #0
 100d72a:	f040 8101 	bne.w	100d930 <ull_conn_done+0x29c>
					force = conn->slave.force & 0x01;
 100d72e:	f8d4 50e0 	ldr.w	r5, [r4, #224]	; 0xe0
					conn->slave.force >>= 1;
 100d732:	086b      	lsrs	r3, r5, #1
					if (force) {
 100d734:	f015 0501 	ands.w	r5, r5, #1
						conn->slave.force |= BIT(31);
 100d738:	bf18      	it	ne
 100d73a:	f043 4300 	orrne.w	r3, r3, #2147483648	; 0x80000000
 100d73e:	f8c4 30e0 	str.w	r3, [r4, #224]	; 0xe0
 100d742:	e010      	b.n	100d766 <ull_conn_done+0xd2>
		conn->llcp_terminate.reason_peer =
 100d744:	213d      	movs	r1, #61	; 0x3d
 100d746:	f884 112b 	strb.w	r1, [r4, #299]	; 0x12b
		conn_cleanup(conn, reason_peer);
 100d74a:	4620      	mov	r0, r4
 100d74c:	f7ff ff3c 	bl	100d5c8 <conn_cleanup>
}
 100d750:	b00a      	add	sp, #40	; 0x28
 100d752:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	if (done->extra.crc_valid) {
 100d756:	f895 302a 	ldrb.w	r3, [r5, #42]	; 0x2a
 100d75a:	2b00      	cmp	r3, #0
 100d75c:	f000 8084 	beq.w	100d868 <ull_conn_done+0x1d4>
		conn->supervision_expire = 0U;
 100d760:	2500      	movs	r5, #0
 100d762:	f8a4 50c8 	strh.w	r5, [r4, #200]	; 0xc8
	if (conn->procedure_expire != 0U) {
 100d766:	f8b4 30cc 	ldrh.w	r3, [r4, #204]	; 0xcc
 100d76a:	b133      	cbz	r3, 100d77a <ull_conn_done+0xe6>
		if (conn->procedure_expire > elapsed_event) {
 100d76c:	4543      	cmp	r3, r8
 100d76e:	f240 80f9 	bls.w	100d964 <ull_conn_done+0x2d0>
			conn->procedure_expire -= elapsed_event;
 100d772:	eba3 0308 	sub.w	r3, r3, r8
 100d776:	f8a4 30cc 	strh.w	r3, [r4, #204]	; 0xcc
	if (conn->apto_expire != 0U) {
 100d77a:	f8b4 30d4 	ldrh.w	r3, [r4, #212]	; 0xd4
 100d77e:	b133      	cbz	r3, 100d78e <ull_conn_done+0xfa>
		if (conn->apto_expire > elapsed_event) {
 100d780:	4543      	cmp	r3, r8
 100d782:	f240 809e 	bls.w	100d8c2 <ull_conn_done+0x22e>
			conn->apto_expire -= elapsed_event;
 100d786:	eba3 0308 	sub.w	r3, r3, r8
 100d78a:	f8a4 30d4 	strh.w	r3, [r4, #212]	; 0xd4
	if (conn->appto_expire != 0U) {
 100d78e:	f8b4 30d0 	ldrh.w	r3, [r4, #208]	; 0xd0
 100d792:	b1a3      	cbz	r3, 100d7be <ull_conn_done+0x12a>
		if (conn->appto_expire > elapsed_event) {
 100d794:	4543      	cmp	r3, r8
 100d796:	d87a      	bhi.n	100d88e <ull_conn_done+0x1fa>
			conn->appto_expire = 0U;
 100d798:	2200      	movs	r2, #0
			if ((conn->procedure_expire == 0U) &&
 100d79a:	f8b4 30cc 	ldrh.w	r3, [r4, #204]	; 0xcc
			conn->appto_expire = 0U;
 100d79e:	f8a4 20d0 	strh.w	r2, [r4, #208]	; 0xd0
			if ((conn->procedure_expire == 0U) &&
 100d7a2:	b963      	cbnz	r3, 100d7be <ull_conn_done+0x12a>
			    (conn->llcp_req == conn->llcp_ack)) {
 100d7a4:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 100d7a8:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
			if ((conn->procedure_expire == 0U) &&
 100d7ac:	4293      	cmp	r3, r2
 100d7ae:	d10a      	bne.n	100d7c6 <ull_conn_done+0x132>
				conn->llcp_type = LLCP_PING;
 100d7b0:	2205      	movs	r2, #5
				conn->llcp_ack -= 2U;
 100d7b2:	3b02      	subs	r3, #2
 100d7b4:	f884 30e9 	strb.w	r3, [r4, #233]	; 0xe9
				conn->llcp_type = LLCP_PING;
 100d7b8:	f884 20ea 	strb.w	r2, [r4, #234]	; 0xea
	if (((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
 100d7bc:	e008      	b.n	100d7d0 <ull_conn_done+0x13c>
 100d7be:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
 100d7c2:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
 100d7c6:	1a9b      	subs	r3, r3, r2
 100d7c8:	f003 0303 	and.w	r3, r3, #3
 100d7cc:	2b02      	cmp	r3, #2
 100d7ce:	d06b      	beq.n	100d8a8 <ull_conn_done+0x214>
	      (conn->llcp_type == LLCP_CHAN_MAP))) ||
 100d7d0:	f894 2104 	ldrb.w	r2, [r4, #260]	; 0x104
 100d7d4:	f894 3105 	ldrb.w	r3, [r4, #261]	; 0x105
 100d7d8:	429a      	cmp	r2, r3
 100d7da:	f000 80ab 	beq.w	100d934 <ull_conn_done+0x2a0>
		lll->latency_event = 0;
 100d7de:	2300      	movs	r3, #0
 100d7e0:	461a      	mov	r2, r3
 100d7e2:	84b3      	strh	r3, [r6, #36]	; 0x24
	if ((ticks_drift_plus != 0U) || (ticks_drift_minus != 0U) ||
 100d7e4:	9b09      	ldr	r3, [sp, #36]	; 0x24
	if ((force) || (latency_event != lll->latency_event)) {
 100d7e6:	b90d      	cbnz	r5, 100d7ec <ull_conn_done+0x158>
 100d7e8:	42ba      	cmp	r2, r7
 100d7ea:	d063      	beq.n	100d8b4 <ull_conn_done+0x220>
		lazy = lll->latency_event + 1;
 100d7ec:	3201      	adds	r2, #1
 100d7ee:	9c08      	ldr	r4, [sp, #32]
 100d7f0:	b291      	uxth	r1, r2
	if ((ticks_drift_plus != 0U) || (ticks_drift_minus != 0U) ||
 100d7f2:	b90b      	cbnz	r3, 100d7f8 <ull_conn_done+0x164>
 100d7f4:	2c00      	cmp	r4, #0
 100d7f6:	d046      	beq.n	100d886 <ull_conn_done+0x1f2>
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
 100d7f8:	2000      	movs	r0, #0
		u8_t ticker_id = TICKER_ID_CONN_BASE + lll->handle;
 100d7fa:	7f32      	ldrb	r2, [r6, #28]
		struct ll_conn *conn = lll->hdr.parent;
 100d7fc:	68f6      	ldr	r6, [r6, #12]
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
 100d7fe:	9504      	str	r5, [sp, #16]
 100d800:	4d6d      	ldr	r5, [pc, #436]	; (100d9b8 <ull_conn_done+0x324>)
		u8_t ticker_id = TICKER_ID_CONN_BASE + lll->handle;
 100d802:	3205      	adds	r2, #5
		ticker_status = ticker_update(TICKER_INSTANCE_ID_CTLR,
 100d804:	9103      	str	r1, [sp, #12]
 100d806:	e9cd 0001 	strd	r0, r0, [sp, #4]
 100d80a:	2101      	movs	r1, #1
 100d80c:	b2d2      	uxtb	r2, r2
 100d80e:	9606      	str	r6, [sp, #24]
 100d810:	9400      	str	r4, [sp, #0]
 100d812:	9505      	str	r5, [sp, #20]
 100d814:	f7f9 fcc4 	bl	10071a0 <ticker_update>
		LL_ASSERT((ticker_status == TICKER_STATUS_SUCCESS) ||
 100d818:	f030 0302 	bics.w	r3, r0, #2
 100d81c:	d098      	beq.n	100d750 <ull_conn_done+0xbc>
 100d81e:	f7fc fc8b 	bl	100a138 <ull_disable_mark_get>
 100d822:	4286      	cmp	r6, r0
 100d824:	d094      	beq.n	100d750 <ull_conn_done+0xbc>
 100d826:	f240 41e7 	movw	r1, #1255	; 0x4e7
 100d82a:	4864      	ldr	r0, [pc, #400]	; (100d9bc <ull_conn_done+0x328>)
 100d82c:	f7f5 feac 	bl	1003588 <bt_ctlr_assert_handle>
			  ((void *)conn == ull_disable_mark_get()));
 100d830:	e78e      	b.n	100d750 <ull_conn_done+0xbc>
	if (reason_peer && (
 100d832:	f996 302d 	ldrsb.w	r3, [r6, #45]	; 0x2d
 100d836:	2b00      	cmp	r3, #0
 100d838:	db87      	blt.n	100d74a <ull_conn_done+0xb6>
			    lll->role ||
 100d83a:	f894 30dc 	ldrb.w	r3, [r4, #220]	; 0xdc
 100d83e:	f013 0202 	ands.w	r2, r3, #2
 100d842:	d182      	bne.n	100d74a <ull_conn_done+0xb6>
			    conn->master.terminate_ack ||
 100d844:	293d      	cmp	r1, #61	; 0x3d
 100d846:	d080      	beq.n	100d74a <ull_conn_done+0xb6>
	latency_event = lll->latency_event;
 100d848:	8cb7      	ldrh	r7, [r6, #36]	; 0x24
	if (done->extra.trx_cnt) {
 100d84a:	8d29      	ldrh	r1, [r5, #40]	; 0x28
	elapsed_event = latency_event + 1;
 100d84c:	f107 0801 	add.w	r8, r7, #1
	ticks_drift_minus = 0U;
 100d850:	e9cd 2208 	strd	r2, r2, [sp, #32]
	elapsed_event = latency_event + 1;
 100d854:	fa1f f888 	uxth.w	r8, r8
	if (done->extra.trx_cnt) {
 100d858:	2900      	cmp	r1, #0
 100d85a:	f43f af7c 	beq.w	100d756 <ull_conn_done+0xc2>
			conn->master.terminate_ack = 1;
 100d85e:	f043 0302 	orr.w	r3, r3, #2
 100d862:	f884 30dc 	strb.w	r3, [r4, #220]	; 0xdc
 100d866:	e73e      	b.n	100d6e6 <ull_conn_done+0x52>
	else if (conn->connect_expire) {
 100d868:	f8b4 30c4 	ldrh.w	r3, [r4, #196]	; 0xc4
 100d86c:	2b00      	cmp	r3, #0
 100d86e:	f43f af40 	beq.w	100d6f2 <ull_conn_done+0x5e>
		if (conn->connect_expire > elapsed_event) {
 100d872:	4543      	cmp	r3, r8
 100d874:	f240 8084 	bls.w	100d980 <ull_conn_done+0x2ec>
			conn->connect_expire -= elapsed_event;
 100d878:	eba3 0308 	sub.w	r3, r3, r8
 100d87c:	f8a4 30c4 	strh.w	r3, [r4, #196]	; 0xc4
 100d880:	f8b4 30c8 	ldrh.w	r3, [r4, #200]	; 0xc8
 100d884:	e73c      	b.n	100d700 <ull_conn_done+0x6c>
	if ((ticks_drift_plus != 0U) || (ticks_drift_minus != 0U) ||
 100d886:	2900      	cmp	r1, #0
 100d888:	d075      	beq.n	100d976 <ull_conn_done+0x2e2>
 100d88a:	4623      	mov	r3, r4
 100d88c:	e7b4      	b.n	100d7f8 <ull_conn_done+0x164>
			conn->appto_expire -= elapsed_event;
 100d88e:	eba3 0808 	sub.w	r8, r3, r8
 100d892:	f894 20e9 	ldrb.w	r2, [r4, #233]	; 0xe9
	if (((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
 100d896:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
			conn->appto_expire -= elapsed_event;
 100d89a:	f8a4 80d0 	strh.w	r8, [r4, #208]	; 0xd0
	if (((((conn->llcp_req - conn->llcp_ack) & 0x03) == 0x02) &&
 100d89e:	1a9b      	subs	r3, r3, r2
 100d8a0:	f003 0303 	and.w	r3, r3, #3
 100d8a4:	2b02      	cmp	r3, #2
 100d8a6:	d193      	bne.n	100d7d0 <ull_conn_done+0x13c>
 100d8a8:	f894 30ea 	ldrb.w	r3, [r4, #234]	; 0xea
 100d8ac:	3b01      	subs	r3, #1
 100d8ae:	2b01      	cmp	r3, #1
 100d8b0:	d88e      	bhi.n	100d7d0 <ull_conn_done+0x13c>
 100d8b2:	e794      	b.n	100d7de <ull_conn_done+0x14a>
	if ((ticks_drift_plus != 0U) || (ticks_drift_minus != 0U) ||
 100d8b4:	9c08      	ldr	r4, [sp, #32]
 100d8b6:	b913      	cbnz	r3, 100d8be <ull_conn_done+0x22a>
 100d8b8:	2c00      	cmp	r4, #0
 100d8ba:	f43f af49 	beq.w	100d750 <ull_conn_done+0xbc>
	lazy = 0U;
 100d8be:	4629      	mov	r1, r5
 100d8c0:	e79a      	b.n	100d7f8 <ull_conn_done+0x164>
			rx = ll_pdu_rx_alloc();
 100d8c2:	f7fc fbd1 	bl	100a068 <ll_pdu_rx_alloc>
			if (rx) {
 100d8c6:	4601      	mov	r1, r0
 100d8c8:	2800      	cmp	r0, #0
 100d8ca:	d050      	beq.n	100d96e <ull_conn_done+0x2da>
				rx->type = NODE_RX_TYPE_APTO;
 100d8cc:	220c      	movs	r2, #12
				conn->apto_expire = 0U;
 100d8ce:	2000      	movs	r0, #0
				rx->handle = lll->handle;
 100d8d0:	8bb3      	ldrh	r3, [r6, #28]
				conn->apto_expire = 0U;
 100d8d2:	f8a4 00d4 	strh.w	r0, [r4, #212]	; 0xd4
				ll_rx_put(rx->link, rx);
 100d8d6:	6808      	ldr	r0, [r1, #0]
				rx->type = NODE_RX_TYPE_APTO;
 100d8d8:	710a      	strb	r2, [r1, #4]
				rx->handle = lll->handle;
 100d8da:	80cb      	strh	r3, [r1, #6]
				ll_rx_put(rx->link, rx);
 100d8dc:	f7fc fb96 	bl	100a00c <ll_rx_put>
				ll_rx_sched();
 100d8e0:	f7fc fb9e 	bl	100a020 <ll_rx_sched>
 100d8e4:	e753      	b.n	100d78e <ull_conn_done+0xfa>
		if (lll->enc_rx || conn->llcp_enc.pause_rx) {
 100d8e6:	f896 306e 	ldrb.w	r3, [r6, #110]	; 0x6e
 100d8ea:	0719      	lsls	r1, r3, #28
 100d8ec:	d404      	bmi.n	100d8f8 <ull_conn_done+0x264>
 100d8ee:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
 100d8f2:	07da      	lsls	r2, r3, #31
 100d8f4:	f57f aee3 	bpl.w	100d6be <ull_conn_done+0x2a>
					    (lll->latency + 6)) ?
 100d8f8:	8c33      	ldrh	r3, [r6, #32]
			appto_reload_new = (conn->apto_reload >
 100d8fa:	f8b4 20d2 	ldrh.w	r2, [r4, #210]	; 0xd2
					    (lll->latency + 6)) ?
 100d8fe:	1d99      	adds	r1, r3, #6
			appto_reload_new = (conn->apto_reload >
 100d900:	428a      	cmp	r2, r1
 100d902:	bfd2      	itee	le
 100d904:	4613      	movle	r3, r2
					   (conn->apto_reload -
 100d906:	1ad3      	subgt	r3, r2, r3
 100d908:	3b06      	subgt	r3, #6
			if (conn->appto_reload != appto_reload_new) {
 100d90a:	f8b4 10ce 	ldrh.w	r1, [r4, #206]	; 0xce
			appto_reload_new = (conn->apto_reload >
 100d90e:	bfc8      	it	gt
 100d910:	b29b      	uxthgt	r3, r3
			if (conn->appto_reload != appto_reload_new) {
 100d912:	4299      	cmp	r1, r3
 100d914:	d010      	beq.n	100d938 <ull_conn_done+0x2a4>
				conn->appto_reload = appto_reload_new;
 100d916:	f8a4 30ce 	strh.w	r3, [r4, #206]	; 0xce
				conn->appto_expire = conn->appto_reload;
 100d91a:	f8a4 30d0 	strh.w	r3, [r4, #208]	; 0xd0
				conn->apto_expire = conn->apto_reload;
 100d91e:	f8a4 20d4 	strh.w	r2, [r4, #212]	; 0xd4
 100d922:	e6cc      	b.n	100d6be <ull_conn_done+0x2a>
		conn->appto_expire = conn->apto_expire = 0U;
 100d924:	2300      	movs	r3, #0
 100d926:	f8a4 30d4 	strh.w	r3, [r4, #212]	; 0xd4
 100d92a:	f8a4 30d0 	strh.w	r3, [r4, #208]	; 0xd0
		break;
 100d92e:	e6c6      	b.n	100d6be <ull_conn_done+0x2a>
					force = 1U;
 100d930:	2501      	movs	r5, #1
 100d932:	e718      	b.n	100d766 <ull_conn_done+0xd2>
 100d934:	8cb2      	ldrh	r2, [r6, #36]	; 0x24
 100d936:	e755      	b.n	100d7e4 <ull_conn_done+0x150>
			if (conn->apto_expire == 0U) {
 100d938:	f8b4 10d4 	ldrh.w	r1, [r4, #212]	; 0xd4
 100d93c:	2900      	cmp	r1, #0
 100d93e:	f47f aebe 	bne.w	100d6be <ull_conn_done+0x2a>
 100d942:	e7ea      	b.n	100d91a <ull_conn_done+0x286>
			ull_slave_done(done, &ticks_drift_plus,
 100d944:	4628      	mov	r0, r5
 100d946:	aa08      	add	r2, sp, #32
 100d948:	a909      	add	r1, sp, #36	; 0x24
 100d94a:	f7f5 f855 	bl	10029f8 <ull_slave_done>
			if (!conn->tx_head) {
 100d94e:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
 100d952:	b1d3      	cbz	r3, 100d98a <ull_conn_done+0x2f6>
				lll->latency_event = 0;
 100d954:	2300      	movs	r3, #0
 100d956:	84b3      	strh	r3, [r6, #36]	; 0x24
 100d958:	e6c5      	b.n	100d6e6 <ull_conn_done+0x52>
			conn_cleanup(conn, BT_HCI_ERR_CONN_TIMEOUT);
 100d95a:	4620      	mov	r0, r4
 100d95c:	2108      	movs	r1, #8
 100d95e:	f7ff fe33 	bl	100d5c8 <conn_cleanup>
			return;
 100d962:	e6f5      	b.n	100d750 <ull_conn_done+0xbc>
			conn_cleanup(conn, BT_HCI_ERR_LL_RESP_TIMEOUT);
 100d964:	4620      	mov	r0, r4
 100d966:	2122      	movs	r1, #34	; 0x22
 100d968:	f7ff fe2e 	bl	100d5c8 <conn_cleanup>
			return;
 100d96c:	e6f0      	b.n	100d750 <ull_conn_done+0xbc>
				conn->apto_expire = 1U;
 100d96e:	2301      	movs	r3, #1
 100d970:	f8a4 30d4 	strh.w	r3, [r4, #212]	; 0xd4
 100d974:	e70b      	b.n	100d78e <ull_conn_done+0xfa>
	    (lazy != 0U) || (force != 0U)) {
 100d976:	2d00      	cmp	r5, #0
 100d978:	f43f aeea 	beq.w	100d750 <ull_conn_done+0xbc>
 100d97c:	460b      	mov	r3, r1
 100d97e:	e73b      	b.n	100d7f8 <ull_conn_done+0x164>
			conn_cleanup(conn, BT_HCI_ERR_CONN_FAIL_TO_ESTAB);
 100d980:	4620      	mov	r0, r4
 100d982:	213e      	movs	r1, #62	; 0x3e
 100d984:	f7ff fe20 	bl	100d5c8 <conn_cleanup>
			return;
 100d988:	e6e2      	b.n	100d750 <ull_conn_done+0xbc>
				ull_conn_tx_demux(UINT8_MAX);
 100d98a:	20ff      	movs	r0, #255	; 0xff
 100d98c:	f7ff fd9a 	bl	100d4c4 <ull_conn_tx_demux>
			if (conn->tx_head || memq_peek(lll->memq_tx.head,
 100d990:	f8d4 21b0 	ldr.w	r2, [r4, #432]	; 0x1b0
 100d994:	2a00      	cmp	r2, #0
 100d996:	d1dd      	bne.n	100d954 <ull_conn_done+0x2c0>
 100d998:	e9d6 0116 	ldrd	r0, r1, [r6, #88]	; 0x58
 100d99c:	f7f8 f9ac 	bl	1005cf8 <memq_peek>
 100d9a0:	2800      	cmp	r0, #0
 100d9a2:	d1d7      	bne.n	100d954 <ull_conn_done+0x2c0>
			} else if (lll->slave.latency_enabled) {
 100d9a4:	f896 3030 	ldrb.w	r3, [r6, #48]	; 0x30
 100d9a8:	07db      	lsls	r3, r3, #31
 100d9aa:	f57f ae9c 	bpl.w	100d6e6 <ull_conn_done+0x52>
				lll->latency_event = lll->latency;
 100d9ae:	8c33      	ldrh	r3, [r6, #32]
 100d9b0:	84b3      	strh	r3, [r6, #36]	; 0x24
 100d9b2:	e698      	b.n	100d6e6 <ull_conn_done+0x52>
	force = 0U;
 100d9b4:	461d      	mov	r5, r3
 100d9b6:	e6d6      	b.n	100d766 <ull_conn_done+0xd2>
 100d9b8:	0100b1f9 	.word	0x0100b1f9
 100d9bc:	010187e4 	.word	0x010187e4

0100d9c0 <ull_conn_tx_lll_enqueue>:
	while (conn->tx_head &&
 100d9c0:	f8d0 31b0 	ldr.w	r3, [r0, #432]	; 0x1b0
 100d9c4:	2b00      	cmp	r3, #0
 100d9c6:	f000 80de 	beq.w	100db86 <ull_conn_tx_lll_enqueue+0x1c6>
 100d9ca:	3901      	subs	r1, #1
{
 100d9cc:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 100d9d0:	4604      	mov	r4, r0
			conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
 100d9d2:	f04f 0a01 	mov.w	sl, #1
		link = mem_acquire(&mem_link_tx.free);
 100d9d6:	f8df 81b0 	ldr.w	r8, [pc, #432]	; 100db88 <ull_conn_tx_lll_enqueue+0x1c8>
		LL_ASSERT(link);
 100d9da:	f8df 91b0 	ldr.w	r9, [pc, #432]	; 100db8c <ull_conn_tx_lll_enqueue+0x1cc>
 100d9de:	b2cd      	uxtb	r5, r1
 100d9e0:	e012      	b.n	100da08 <ull_conn_tx_lll_enqueue+0x48>
		link = mem_acquire(&mem_link_tx.free);
 100d9e2:	4640      	mov	r0, r8
 100d9e4:	f7f8 f91c 	bl	1005c20 <mem_acquire>
		LL_ASSERT(link);
 100d9e8:	4607      	mov	r7, r0
 100d9ea:	2800      	cmp	r0, #0
 100d9ec:	d066      	beq.n	100dabc <ull_conn_tx_lll_enqueue+0xfc>
		memq_enqueue(link, tx, &conn->lll.memq_tx.tail);
 100d9ee:	4631      	mov	r1, r6
 100d9f0:	4638      	mov	r0, r7
 100d9f2:	f104 026c 	add.w	r2, r4, #108	; 0x6c
 100d9f6:	f7f8 f977 	bl	1005ce8 <memq_enqueue>
	while (conn->tx_head &&
 100d9fa:	f8d4 31b0 	ldr.w	r3, [r4, #432]	; 0x1b0
 100d9fe:	3d01      	subs	r5, #1
 100da00:	b2ed      	uxtb	r5, r5
 100da02:	2b00      	cmp	r3, #0
 100da04:	f000 8081 	beq.w	100db0a <ull_conn_tx_lll_enqueue+0x14a>
		 !conn->llcp_phy.pause_tx &&
 100da08:	f894 21ab 	ldrb.w	r2, [r4, #427]	; 0x1ab
	while (conn->tx_head &&
 100da0c:	07d1      	lsls	r1, r2, #31
 100da0e:	d403      	bmi.n	100da18 <ull_conn_tx_lll_enqueue+0x58>
		 !conn->llcp_enc.pause_tx &&
 100da10:	f894 2152 	ldrb.w	r2, [r4, #338]	; 0x152
		 !conn->llcp_phy.pause_tx &&
 100da14:	0792      	lsls	r2, r2, #30
 100da16:	d55e      	bpl.n	100dad6 <ull_conn_tx_lll_enqueue+0x116>
		(!pause_tx && (conn->tx_head == conn->tx_ctrl))) && count--) {
 100da18:	f8d4 21b4 	ldr.w	r2, [r4, #436]	; 0x1b4
 100da1c:	4293      	cmp	r3, r2
 100da1e:	d174      	bne.n	100db0a <ull_conn_tx_lll_enqueue+0x14a>
 100da20:	2dff      	cmp	r5, #255	; 0xff
 100da22:	d072      	beq.n	100db0a <ull_conn_tx_lll_enqueue+0x14a>
		tx = tx_ull_dequeue(conn, conn->tx_head);
 100da24:	4620      	mov	r0, r4
 100da26:	f8d4 11b0 	ldr.w	r1, [r4, #432]	; 0x1b0
 100da2a:	f7fd fa1b 	bl	100ae64 <tx_ull_dequeue>
		if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
 100da2e:	7903      	ldrb	r3, [r0, #4]
		tx = tx_ull_dequeue(conn, conn->tx_head);
 100da30:	4606      	mov	r6, r0
		if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
 100da32:	f003 0303 	and.w	r3, r3, #3
 100da36:	2b03      	cmp	r3, #3
 100da38:	d1d3      	bne.n	100d9e2 <ull_conn_tx_lll_enqueue+0x22>
	switch (pdu_tx->llctrl.opcode) {
 100da3a:	79c3      	ldrb	r3, [r0, #7]
 100da3c:	3b03      	subs	r3, #3
 100da3e:	2b14      	cmp	r3, #20
 100da40:	d8cf      	bhi.n	100d9e2 <ull_conn_tx_lll_enqueue+0x22>
 100da42:	a201      	add	r2, pc, #4	; (adr r2, 100da48 <ull_conn_tx_lll_enqueue+0x88>)
 100da44:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 100da48:	0100daa5 	.word	0x0100daa5
 100da4c:	0100daa5 	.word	0x0100daa5
 100da50:	0100d9e3 	.word	0x0100d9e3
 100da54:	0100d9e3 	.word	0x0100d9e3
 100da58:	0100d9e3 	.word	0x0100d9e3
 100da5c:	0100d9e3 	.word	0x0100d9e3
 100da60:	0100d9e3 	.word	0x0100d9e3
 100da64:	0100daa5 	.word	0x0100daa5
 100da68:	0100da9d 	.word	0x0100da9d
 100da6c:	0100d9e3 	.word	0x0100d9e3
 100da70:	0100d9e3 	.word	0x0100d9e3
 100da74:	0100d9e3 	.word	0x0100d9e3
 100da78:	0100d9e3 	.word	0x0100d9e3
 100da7c:	0100d9e3 	.word	0x0100d9e3
 100da80:	0100d9e3 	.word	0x0100d9e3
 100da84:	0100d9e3 	.word	0x0100d9e3
 100da88:	0100d9e3 	.word	0x0100d9e3
 100da8c:	0100d9e3 	.word	0x0100d9e3
 100da90:	0100d9e3 	.word	0x0100d9e3
 100da94:	0100dac9 	.word	0x0100dac9
 100da98:	0100dac9 	.word	0x0100dac9
		if (!conn->lll.role) {
 100da9c:	f994 303d 	ldrsb.w	r3, [r4, #61]	; 0x3d
 100daa0:	2b00      	cmp	r3, #0
 100daa2:	da9e      	bge.n	100d9e2 <ull_conn_tx_lll_enqueue+0x22>
		conn->llcp_enc.pause_tx = 1U;
 100daa4:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
		link = mem_acquire(&mem_link_tx.free);
 100daa8:	4640      	mov	r0, r8
		conn->llcp_enc.pause_tx = 1U;
 100daaa:	f043 0302 	orr.w	r3, r3, #2
 100daae:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
		link = mem_acquire(&mem_link_tx.free);
 100dab2:	f7f8 f8b5 	bl	1005c20 <mem_acquire>
		LL_ASSERT(link);
 100dab6:	4607      	mov	r7, r0
 100dab8:	2800      	cmp	r0, #0
 100daba:	d198      	bne.n	100d9ee <ull_conn_tx_lll_enqueue+0x2e>
 100dabc:	f240 5163 	movw	r1, #1379	; 0x563
 100dac0:	4648      	mov	r0, r9
 100dac2:	f7f5 fd61 	bl	1003588 <bt_ctlr_assert_handle>
 100dac6:	e792      	b.n	100d9ee <ull_conn_tx_lll_enqueue+0x2e>
		conn->llcp_phy.pause_tx = 1U;
 100dac8:	f894 31ab 	ldrb.w	r3, [r4, #427]	; 0x1ab
 100dacc:	f043 0301 	orr.w	r3, r3, #1
 100dad0:	f884 31ab 	strb.w	r3, [r4, #427]	; 0x1ab
		break;
 100dad4:	e785      	b.n	100d9e2 <ull_conn_tx_lll_enqueue+0x22>
	if ((pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
 100dad6:	791a      	ldrb	r2, [r3, #4]
 100dad8:	f002 0203 	and.w	r2, r2, #3
 100dadc:	2a03      	cmp	r2, #3
 100dade:	d19f      	bne.n	100da20 <ull_conn_tx_lll_enqueue+0x60>
	    ((pdu_data_tx->llctrl.opcode ==
 100dae0:	79da      	ldrb	r2, [r3, #7]
	if ((pdu_data_tx->ll_id == PDU_DATA_LLID_CTRL) &&
 100dae2:	2a03      	cmp	r2, #3
 100dae4:	d001      	beq.n	100daea <ull_conn_tx_lll_enqueue+0x12a>
	      PDU_DATA_LLCTRL_TYPE_ENC_REQ) ||
 100dae6:	2a0a      	cmp	r2, #10
 100dae8:	d19a      	bne.n	100da20 <ull_conn_tx_lll_enqueue+0x60>
		if (((conn->llcp_req != conn->llcp_ack) &&
 100daea:	f894 10e9 	ldrb.w	r1, [r4, #233]	; 0xe9
 100daee:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
 100daf2:	428a      	cmp	r2, r1
 100daf4:	d00b      	beq.n	100db0e <ull_conn_tx_lll_enqueue+0x14e>
 100daf6:	f894 20ea 	ldrb.w	r2, [r4, #234]	; 0xea
 100dafa:	2a03      	cmp	r2, #3
 100dafc:	d090      	beq.n	100da20 <ull_conn_tx_lll_enqueue+0x60>
			if ((tx->next != NULL) &&
 100dafe:	681a      	ldr	r2, [r3, #0]
 100db00:	b11a      	cbz	r2, 100db0a <ull_conn_tx_lll_enqueue+0x14a>
 100db02:	f8d4 11b4 	ldr.w	r1, [r4, #436]	; 0x1b4
 100db06:	428a      	cmp	r2, r1
 100db08:	d02c      	beq.n	100db64 <ull_conn_tx_lll_enqueue+0x1a4>
}
 100db0a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		    ((conn->llcp_req == conn->llcp_ack) &&
 100db0e:	f894 0119 	ldrb.w	r0, [r4, #281]	; 0x119
 100db12:	f894 1118 	ldrb.w	r1, [r4, #280]	; 0x118
 100db16:	4288      	cmp	r0, r1
 100db18:	d1f1      	bne.n	100dafe <ull_conn_tx_lll_enqueue+0x13e>
		     ((conn->llcp_feature.ack != conn->llcp_feature.req) ||
 100db1a:	f894 0121 	ldrb.w	r0, [r4, #289]	; 0x121
 100db1e:	f894 1120 	ldrb.w	r1, [r4, #288]	; 0x120
 100db22:	4288      	cmp	r0, r1
 100db24:	d1eb      	bne.n	100dafe <ull_conn_tx_lll_enqueue+0x13e>
		      (conn->llcp_version.ack != conn->llcp_version.req) ||
 100db26:	f894 0171 	ldrb.w	r0, [r4, #369]	; 0x171
 100db2a:	f894 1170 	ldrb.w	r1, [r4, #368]	; 0x170
 100db2e:	4288      	cmp	r0, r1
 100db30:	d1e5      	bne.n	100dafe <ull_conn_tx_lll_enqueue+0x13e>
		       conn->llcp_conn_param.req) ||
 100db32:	f894 0199 	ldrb.w	r0, [r4, #409]	; 0x199
 100db36:	f894 1198 	ldrb.w	r1, [r4, #408]	; 0x198
 100db3a:	4288      	cmp	r0, r1
 100db3c:	d1df      	bne.n	100dafe <ull_conn_tx_lll_enqueue+0x13e>
		      (conn->llcp_phy.ack != conn->llcp_phy.req) ||
 100db3e:	f894 01a9 	ldrb.w	r0, [r4, #425]	; 0x1a9
 100db42:	f894 11a8 	ldrb.w	r1, [r4, #424]	; 0x1a8
 100db46:	4288      	cmp	r0, r1
 100db48:	d1d9      	bne.n	100dafe <ull_conn_tx_lll_enqueue+0x13e>
			conn->llcp_type = LLCP_ENCRYPTION;
 100db4a:	2103      	movs	r1, #3
			conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
 100db4c:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
			conn->llcp_ack -= 2U;
 100db50:	3a02      	subs	r2, #2
			conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
 100db52:	f36a 0301 	bfi	r3, sl, #0, #2
			conn->llcp_ack -= 2U;
 100db56:	f884 20e9 	strb.w	r2, [r4, #233]	; 0xe9
			conn->llcp.encryption.state = LLCP_ENC_STATE_INIT;
 100db5a:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
			conn->llcp_type = LLCP_ENCRYPTION;
 100db5e:	f884 10ea 	strb.w	r1, [r4, #234]	; 0xea
			conn->llcp_ack -= 2U;
 100db62:	e75d      	b.n	100da20 <ull_conn_tx_lll_enqueue+0x60>
				tx->next = conn->tx_ctrl_last->next;
 100db64:	f8d4 11b8 	ldr.w	r1, [r4, #440]	; 0x1b8
				conn->tx_head = tx->next;
 100db68:	f8c4 21b0 	str.w	r2, [r4, #432]	; 0x1b0
				if (!conn->tx_data_last) {
 100db6c:	f8d4 01c0 	ldr.w	r0, [r4, #448]	; 0x1c0
				tx->next = conn->tx_ctrl_last->next;
 100db70:	680a      	ldr	r2, [r1, #0]
 100db72:	601a      	str	r2, [r3, #0]
				conn->tx_ctrl_last->next = tx;
 100db74:	600b      	str	r3, [r1, #0]
				conn->tx_data = tx;
 100db76:	f8c4 31bc 	str.w	r3, [r4, #444]	; 0x1bc
				if (!conn->tx_data_last) {
 100db7a:	2800      	cmp	r0, #0
 100db7c:	f47f af50 	bne.w	100da20 <ull_conn_tx_lll_enqueue+0x60>
					conn->tx_data_last = tx;
 100db80:	f8c4 31c0 	str.w	r3, [r4, #448]	; 0x1c0
 100db84:	e74c      	b.n	100da20 <ull_conn_tx_lll_enqueue+0x60>
 100db86:	4770      	bx	lr
 100db88:	21003950 	.word	0x21003950
 100db8c:	010187e4 	.word	0x010187e4

0100db90 <ull_conn_link_tx_release>:
	mem_release(link, &mem_link_tx.free);
 100db90:	4901      	ldr	r1, [pc, #4]	; (100db98 <ull_conn_link_tx_release+0x8>)
 100db92:	f7f8 b85f 	b.w	1005c54 <mem_release>
 100db96:	bf00      	nop
 100db98:	21003950 	.word	0x21003950

0100db9c <ull_conn_ack_last_idx_get>:
	return mfifo_conn_ack.l;
 100db9c:	4b01      	ldr	r3, [pc, #4]	; (100dba4 <ull_conn_ack_last_idx_get+0x8>)
}
 100db9e:	78d8      	ldrb	r0, [r3, #3]
 100dba0:	4770      	bx	lr
 100dba2:	bf00      	nop
 100dba4:	210002f4 	.word	0x210002f4

0100dba8 <ull_conn_ack_peek>:
{
 100dba8:	b470      	push	{r4, r5, r6}
	lll_tx = MFIFO_DEQUEUE_GET(conn_ack);
 100dbaa:	4b0b      	ldr	r3, [pc, #44]	; (100dbd8 <ull_conn_ack_peek+0x30>)
{
 100dbac:	4605      	mov	r5, r0
	lll_tx = MFIFO_DEQUEUE_GET(conn_ack);
 100dbae:	78de      	ldrb	r6, [r3, #3]
 100dbb0:	7898      	ldrb	r0, [r3, #2]
 100dbb2:	781c      	ldrb	r4, [r3, #0]
	if (first == last) {
 100dbb4:	42b0      	cmp	r0, r6
 100dbb6:	d00c      	beq.n	100dbd2 <ull_conn_ack_peek+0x2a>
	return (void *)(fifo + first * size);
 100dbb8:	fb04 f400 	mul.w	r4, r4, r0
 100dbbc:	3304      	adds	r3, #4
	if (!lll_tx) {
 100dbbe:	1918      	adds	r0, r3, r4
 100dbc0:	d005      	beq.n	100dbce <ull_conn_ack_peek+0x26>
	*ack_last = mfifo_conn_ack.l;
 100dbc2:	702e      	strb	r6, [r5, #0]
	*handle = lll_tx->handle;
 100dbc4:	5b1c      	ldrh	r4, [r3, r4]
	*tx = lll_tx->node;
 100dbc6:	6843      	ldr	r3, [r0, #4]
	*handle = lll_tx->handle;
 100dbc8:	800c      	strh	r4, [r1, #0]
	*tx = lll_tx->node;
 100dbca:	6013      	str	r3, [r2, #0]
	return (*tx)->link;
 100dbcc:	6818      	ldr	r0, [r3, #0]
}
 100dbce:	bc70      	pop	{r4, r5, r6}
 100dbd0:	4770      	bx	lr
		return NULL;
 100dbd2:	2000      	movs	r0, #0
 100dbd4:	e7fb      	b.n	100dbce <ull_conn_ack_peek+0x26>
 100dbd6:	bf00      	nop
 100dbd8:	210002f4 	.word	0x210002f4

0100dbdc <ull_conn_ack_by_last_peek>:
{
 100dbdc:	b430      	push	{r4, r5}
	lll_tx = mfifo_dequeue_get(mfifo_conn_ack.m, mfifo_conn_ack.s,
 100dbde:	4b09      	ldr	r3, [pc, #36]	; (100dc04 <ull_conn_ack_by_last_peek+0x28>)
 100dbe0:	789d      	ldrb	r5, [r3, #2]
 100dbe2:	781c      	ldrb	r4, [r3, #0]
	if (first == last) {
 100dbe4:	4285      	cmp	r5, r0
 100dbe6:	d00b      	beq.n	100dc00 <ull_conn_ack_by_last_peek+0x24>
	return (void *)(fifo + first * size);
 100dbe8:	fb04 f405 	mul.w	r4, r4, r5
 100dbec:	3304      	adds	r3, #4
	if (!lll_tx) {
 100dbee:	1918      	adds	r0, r3, r4
 100dbf0:	d004      	beq.n	100dbfc <ull_conn_ack_by_last_peek+0x20>
	*handle = lll_tx->handle;
 100dbf2:	5b1c      	ldrh	r4, [r3, r4]
	*tx = lll_tx->node;
 100dbf4:	6843      	ldr	r3, [r0, #4]
	*handle = lll_tx->handle;
 100dbf6:	800c      	strh	r4, [r1, #0]
	*tx = lll_tx->node;
 100dbf8:	6013      	str	r3, [r2, #0]
	return (*tx)->link;
 100dbfa:	6818      	ldr	r0, [r3, #0]
}
 100dbfc:	bc30      	pop	{r4, r5}
 100dbfe:	4770      	bx	lr
		return NULL;
 100dc00:	2000      	movs	r0, #0
 100dc02:	e7fb      	b.n	100dbfc <ull_conn_ack_by_last_peek+0x20>
 100dc04:	210002f4 	.word	0x210002f4

0100dc08 <ull_conn_ack_dequeue>:
{
 100dc08:	b410      	push	{r4}
	return MFIFO_DEQUEUE(conn_ack);
 100dc0a:	4b0a      	ldr	r3, [pc, #40]	; (100dc34 <ull_conn_ack_dequeue+0x2c>)
	u8_t _first = *first; /* Copy read-index */
 100dc0c:	7899      	ldrb	r1, [r3, #2]
	if (_first == last) {
 100dc0e:	78da      	ldrb	r2, [r3, #3]
 100dc10:	7818      	ldrb	r0, [r3, #0]
 100dc12:	428a      	cmp	r2, r1
 100dc14:	785c      	ldrb	r4, [r3, #1]
 100dc16:	d00a      	beq.n	100dc2e <ull_conn_ack_dequeue+0x26>
	_first += 1U;
 100dc18:	1c4a      	adds	r2, r1, #1
 100dc1a:	b2d2      	uxtb	r2, r2
		_first = 0U;
 100dc1c:	4294      	cmp	r4, r2
 100dc1e:	bf08      	it	eq
 100dc20:	2200      	moveq	r2, #0
	mem = *((void **)(fifo + _first * size));
 100dc22:	fb00 3101 	mla	r1, r0, r1, r3
 100dc26:	6848      	ldr	r0, [r1, #4]
	*first = _first; /* Write back read-index */
 100dc28:	709a      	strb	r2, [r3, #2]
}
 100dc2a:	bc10      	pop	{r4}
 100dc2c:	4770      	bx	lr
		return NULL;
 100dc2e:	2000      	movs	r0, #0
	return MFIFO_DEQUEUE(conn_ack);
 100dc30:	e7fb      	b.n	100dc2a <ull_conn_ack_dequeue+0x22>
 100dc32:	bf00      	nop
 100dc34:	210002f4 	.word	0x210002f4

0100dc38 <ull_conn_lll_ack_enqueue>:
{
 100dc38:	b570      	push	{r4, r5, r6, lr}
	idx = MFIFO_ENQUEUE_GET(conn_ack, (void **)&lll_tx);
 100dc3a:	4c0f      	ldr	r4, [pc, #60]	; (100dc78 <ull_conn_lll_ack_enqueue+0x40>)
 100dc3c:	78e2      	ldrb	r2, [r4, #3]
	if (last == count) {
 100dc3e:	7865      	ldrb	r5, [r4, #1]
	last = last + 1;
 100dc40:	1c53      	adds	r3, r2, #1
 100dc42:	b2db      	uxtb	r3, r3
		last = 0U;
 100dc44:	429d      	cmp	r5, r3
 100dc46:	bf08      	it	eq
 100dc48:	2300      	moveq	r3, #0
 100dc4a:	78a5      	ldrb	r5, [r4, #2]
	if (last == first) {
 100dc4c:	429d      	cmp	r5, r3
 100dc4e:	d00a      	beq.n	100dc66 <ull_conn_lll_ack_enqueue+0x2e>
	*mem = (void *)(fifo + last * size); /* preceding buffer */
 100dc50:	4625      	mov	r5, r4
 100dc52:	f815 6b04 	ldrb.w	r6, [r5], #4
 100dc56:	fb02 f206 	mul.w	r2, r2, r6
	LL_ASSERT(lll_tx);
 100dc5a:	18ae      	adds	r6, r5, r2
 100dc5c:	d003      	beq.n	100dc66 <ull_conn_lll_ack_enqueue+0x2e>
	lll_tx->handle = handle;
 100dc5e:	52a8      	strh	r0, [r5, r2]
	lll_tx->node = tx;
 100dc60:	6071      	str	r1, [r6, #4]
	*last = idx; /* Commit: Update write index */
 100dc62:	70e3      	strb	r3, [r4, #3]
}
 100dc64:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(lll_tx);
 100dc66:	f240 51a1 	movw	r1, #1441	; 0x5a1
 100dc6a:	4804      	ldr	r0, [pc, #16]	; (100dc7c <ull_conn_lll_ack_enqueue+0x44>)
 100dc6c:	f7f5 fc8c 	bl	1003588 <bt_ctlr_assert_handle>
	lll_tx->handle = handle;
 100dc70:	2300      	movs	r3, #0
 100dc72:	801b      	strh	r3, [r3, #0]
 100dc74:	deff      	udf	#255	; 0xff
 100dc76:	bf00      	nop
 100dc78:	210002f4 	.word	0x210002f4
 100dc7c:	010187e4 	.word	0x010187e4

0100dc80 <ull_conn_tx_ack>:
{
 100dc80:	b5f0      	push	{r4, r5, r6, r7, lr}
	LL_ASSERT(pdu_tx->len);
 100dc82:	7953      	ldrb	r3, [r2, #5]
{
 100dc84:	4614      	mov	r4, r2
 100dc86:	4605      	mov	r5, r0
 100dc88:	460f      	mov	r7, r1
 100dc8a:	b083      	sub	sp, #12
	LL_ASSERT(pdu_tx->len);
 100dc8c:	b35b      	cbz	r3, 100dce6 <ull_conn_tx_ack+0x66>
	if (pdu_tx->ll_id == PDU_DATA_LLID_CTRL) {
 100dc8e:	7923      	ldrb	r3, [r4, #4]
 100dc90:	f003 0203 	and.w	r2, r3, #3
 100dc94:	2a03      	cmp	r2, #3
 100dc96:	d016      	beq.n	100dcc6 <ull_conn_tx_ack+0x46>
	} else if (handle != 0xFFFF) {
 100dc98:	f64f 72ff 	movw	r2, #65535	; 0xffff
 100dc9c:	4295      	cmp	r5, r2
 100dc9e:	d10a      	bne.n	100dcb6 <ull_conn_tx_ack+0x36>
	struct ll_conn *conn = NULL;
 100dca0:	2600      	movs	r6, #0
		pdu_tx->ll_id = PDU_DATA_LLID_RESV;
 100dca2:	f36f 0301 	bfc	r3, #0, #2
 100dca6:	7123      	strb	r3, [r4, #4]
	ll_tx_ack_put(handle, tx);
 100dca8:	4621      	mov	r1, r4
 100dcaa:	4628      	mov	r0, r5
 100dcac:	f7fc f9f4 	bl	100a098 <ll_tx_ack_put>
}
 100dcb0:	4630      	mov	r0, r6
 100dcb2:	b003      	add	sp, #12
 100dcb4:	bdf0      	pop	{r4, r5, r6, r7, pc}
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100dcb6:	462a      	mov	r2, r5
 100dcb8:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100dcbc:	48b9      	ldr	r0, [pc, #740]	; (100dfa4 <ull_conn_tx_ack+0x324>)
 100dcbe:	f7f7 ffe1 	bl	1005c84 <mem_get>
 100dcc2:	4606      	mov	r6, r0
 100dcc4:	e7f0      	b.n	100dca8 <ull_conn_tx_ack+0x28>
		if (handle != 0xFFFF) {
 100dcc6:	f64f 73ff 	movw	r3, #65535	; 0xffff
 100dcca:	429d      	cmp	r5, r3
 100dccc:	d111      	bne.n	100dcf2 <ull_conn_tx_ack+0x72>
	struct ll_conn *conn = NULL;
 100dcce:	2600      	movs	r6, #0
		if (link->next == (void *)tx) {
 100dcd0:	6838      	ldr	r0, [r7, #0]
 100dcd2:	4284      	cmp	r4, r0
 100dcd4:	d07d      	beq.n	100ddd2 <ull_conn_tx_ack+0x152>
			LL_ASSERT(!link->next);
 100dcd6:	2800      	cmp	r0, #0
 100dcd8:	d0e6      	beq.n	100dca8 <ull_conn_tx_ack+0x28>
 100dcda:	f240 51c3 	movw	r1, #1475	; 0x5c3
 100dcde:	48b2      	ldr	r0, [pc, #712]	; (100dfa8 <ull_conn_tx_ack+0x328>)
 100dce0:	f7f5 fc52 	bl	1003588 <bt_ctlr_assert_handle>
 100dce4:	e7e0      	b.n	100dca8 <ull_conn_tx_ack+0x28>
	LL_ASSERT(pdu_tx->len);
 100dce6:	f44f 61b6 	mov.w	r1, #1456	; 0x5b0
 100dcea:	48af      	ldr	r0, [pc, #700]	; (100dfa8 <ull_conn_tx_ack+0x328>)
 100dcec:	f7f5 fc4c 	bl	1003588 <bt_ctlr_assert_handle>
 100dcf0:	e7cd      	b.n	100dc8e <ull_conn_tx_ack+0xe>
	return mem_get(conn_pool, sizeof(struct ll_conn), handle);
 100dcf2:	462a      	mov	r2, r5
 100dcf4:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 100dcf8:	48aa      	ldr	r0, [pc, #680]	; (100dfa4 <ull_conn_tx_ack+0x324>)
 100dcfa:	f7f7 ffc3 	bl	1005c84 <mem_get>
 100dcfe:	79e3      	ldrb	r3, [r4, #7]
 100dd00:	4606      	mov	r6, r0
	switch (pdu_tx->llctrl.opcode) {
 100dd02:	3b02      	subs	r3, #2
 100dd04:	2b16      	cmp	r3, #22
 100dd06:	d868      	bhi.n	100ddda <ull_conn_tx_ack+0x15a>
 100dd08:	e8df f013 	tbh	[pc, r3, lsl #1]
 100dd0c:	00d400f0 	.word	0x00d400f0
 100dd10:	00670095 	.word	0x00670095
 100dd14:	00670067 	.word	0x00670067
 100dd18:	00670067 	.word	0x00670067
 100dd1c:	001700c3 	.word	0x001700c3
 100dd20:	00a00067 	.word	0x00a00067
 100dd24:	00670067 	.word	0x00670067
 100dd28:	009c0067 	.word	0x009c0067
 100dd2c:	00670067 	.word	0x00670067
 100dd30:	00f700aa 	.word	0x00f700aa
 100dd34:	0074006d 	.word	0x0074006d
 100dd38:	00b2      	.short	0x00b2
		if (!conn->lll.role) {
 100dd3a:	f990 303d 	ldrsb.w	r3, [r0, #61]	; 0x3d
 100dd3e:	2b00      	cmp	r3, #0
 100dd40:	db79      	blt.n	100de36 <ull_conn_tx_ack+0x1b6>
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
 100dd42:	2203      	movs	r2, #3
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100dd44:	7923      	ldrb	r3, [r4, #4]
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_req) +
 100dd46:	2117      	movs	r1, #23
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100dd48:	4313      	orrs	r3, r2
	pdu_ctrl_tx->llctrl.opcode = PDU_DATA_LLCTRL_TYPE_ENC_REQ;
 100dd4a:	71e2      	strb	r2, [r4, #7]
	memcpy(&pdu_ctrl_tx->llctrl.enc_req.rand[0], &conn->llcp_enc.rand[0],
 100dd4c:	2208      	movs	r2, #8
	pdu_ctrl_tx->len = offsetof(struct pdu_data_llctrl, enc_req) +
 100dd4e:	7161      	strb	r1, [r4, #5]
	pdu_ctrl_tx->ll_id = PDU_DATA_LLID_CTRL;
 100dd50:	7123      	strb	r3, [r4, #4]
	memcpy(&pdu_ctrl_tx->llctrl.enc_req.rand[0], &conn->llcp_enc.rand[0],
 100dd52:	f200 1155 	addw	r1, r0, #341	; 0x155
 100dd56:	18a0      	adds	r0, r4, r2
 100dd58:	f008 fdae 	bl	10168b8 <memcpy>
	pdu_ctrl_tx->llctrl.enc_req.ediv[0] = conn->llcp_enc.ediv[0];
 100dd5c:	f896 3153 	ldrb.w	r3, [r6, #339]	; 0x153
	lll_trng_isr_get(pdu_ctrl_tx->llctrl.enc_req.skdm,
 100dd60:	210c      	movs	r1, #12
	pdu_ctrl_tx->llctrl.enc_req.ediv[0] = conn->llcp_enc.ediv[0];
 100dd62:	7423      	strb	r3, [r4, #16]
	pdu_ctrl_tx->llctrl.enc_req.ediv[1] = conn->llcp_enc.ediv[1];
 100dd64:	f896 3154 	ldrb.w	r3, [r6, #340]	; 0x154
	lll_trng_isr_get(pdu_ctrl_tx->llctrl.enc_req.skdm,
 100dd68:	f104 0012 	add.w	r0, r4, #18
	pdu_ctrl_tx->llctrl.enc_req.ediv[1] = conn->llcp_enc.ediv[1];
 100dd6c:	7463      	strb	r3, [r4, #17]
	lll_trng_isr_get(pdu_ctrl_tx->llctrl.enc_req.skdm,
 100dd6e:	f001 fffd 	bl	100fd6c <lll_trng_isr_get>
	    conn->tx_head &&
 100dd72:	f8d6 31b0 	ldr.w	r3, [r6, #432]	; 0x1b0
	if (
 100dd76:	2b00      	cmp	r3, #0
 100dd78:	f000 80e6 	beq.w	100df48 <ull_conn_tx_ack+0x2c8>
	    !conn->llcp_enc.pause_tx &&
 100dd7c:	f896 2152 	ldrb.w	r2, [r6, #338]	; 0x152
	    conn->tx_head &&
 100dd80:	0791      	lsls	r1, r2, #30
 100dd82:	f100 80e1 	bmi.w	100df48 <ull_conn_tx_ack+0x2c8>
	    !conn->llcp_phy.pause_tx &&
 100dd86:	f896 21ab 	ldrb.w	r2, [r6, #427]	; 0x1ab
 100dd8a:	07d2      	lsls	r2, r2, #31
 100dd8c:	f100 80dc 	bmi.w	100df48 <ull_conn_tx_ack+0x2c8>
		if (conn->tx_head == conn->tx_data) {
 100dd90:	f8d6 21bc 	ldr.w	r2, [r6, #444]	; 0x1bc
 100dd94:	4293      	cmp	r3, r2
			conn->tx_data = conn->tx_data->next;
 100dd96:	bf04      	itt	eq
 100dd98:	681a      	ldreq	r2, [r3, #0]
 100dd9a:	f8c6 21bc 	streq.w	r2, [r6, #444]	; 0x1bc
		if (!conn->tx_ctrl) {
 100dd9e:	f8d6 21b4 	ldr.w	r2, [r6, #436]	; 0x1b4
 100dda2:	2a00      	cmp	r2, #0
 100dda4:	f000 80f6 	beq.w	100df94 <ull_conn_tx_ack+0x314>
	tx->next = conn->tx_ctrl_last->next;
 100dda8:	f8d6 31b8 	ldr.w	r3, [r6, #440]	; 0x1b8
 100ddac:	681a      	ldr	r2, [r3, #0]
 100ddae:	6022      	str	r2, [r4, #0]
	conn->tx_ctrl_last->next = tx;
 100ddb0:	601c      	str	r4, [r3, #0]
	conn->tx_ctrl_last = tx;
 100ddb2:	f8c6 41b8 	str.w	r4, [r6, #440]	; 0x1b8
 100ddb6:	6823      	ldr	r3, [r4, #0]
	if (!tx->next) {
 100ddb8:	2b00      	cmp	r3, #0
 100ddba:	f000 80d0 	beq.w	100df5e <ull_conn_tx_ack+0x2de>
		if (link->next == (void *)tx) {
 100ddbe:	683b      	ldr	r3, [r7, #0]
 100ddc0:	2b00      	cmp	r3, #0
 100ddc2:	f47f af75 	bne.w	100dcb0 <ull_conn_tx_ack+0x30>
			LL_ASSERT(link->next);
 100ddc6:	4878      	ldr	r0, [pc, #480]	; (100dfa8 <ull_conn_tx_ack+0x328>)
 100ddc8:	f240 51bc 	movw	r1, #1468	; 0x5bc
 100ddcc:	f7f5 fbdc 	bl	1003588 <bt_ctlr_assert_handle>
 100ddd0:	2000      	movs	r0, #0
			mem_release(tx, &mem_conn_tx_ctrl.free);
 100ddd2:	4976      	ldr	r1, [pc, #472]	; (100dfac <ull_conn_tx_ack+0x32c>)
 100ddd4:	f7f7 ff3e 	bl	1005c54 <mem_release>
			return conn;
 100ddd8:	e76a      	b.n	100dcb0 <ull_conn_tx_ack+0x30>
		if (link->next == (void *)tx) {
 100ddda:	6838      	ldr	r0, [r7, #0]
 100dddc:	42a0      	cmp	r0, r4
 100ddde:	f47f af7a 	bne.w	100dcd6 <ull_conn_tx_ack+0x56>
 100dde2:	4620      	mov	r0, r4
 100dde4:	e7f5      	b.n	100ddd2 <ull_conn_tx_ack+0x152>
		conn->llcp_phy.state = LLCP_PHY_STATE_RSP_WAIT;
 100dde6:	2202      	movs	r2, #2
 100dde8:	f890 31aa 	ldrb.w	r3, [r0, #426]	; 0x1aa
 100ddec:	f362 0301 	bfi	r3, r2, #0, #2
 100ddf0:	f880 31aa 	strb.w	r3, [r0, #426]	; 0x1aa
		if (conn->lll.role) {
 100ddf4:	f996 303d 	ldrsb.w	r3, [r6, #61]	; 0x3d
 100ddf8:	2b00      	cmp	r3, #0
 100ddfa:	da15      	bge.n	100de28 <ull_conn_tx_ack+0x1a8>
			phys = conn->llcp_phy.tx | lll->phy_tx;
 100ddfc:	f896 3064 	ldrb.w	r3, [r6, #100]	; 0x64
 100de00:	f896 01aa 	ldrb.w	r0, [r6, #426]	; 0x1aa
			lll->phy_tx_time = phy_tx_time[phys];
 100de04:	461a      	mov	r2, r3
			u8_t phy_tx_time[8] = {BIT(0), BIT(0), BIT(1), BIT(0),
 100de06:	496a      	ldr	r1, [pc, #424]	; (100dfb0 <ull_conn_tx_ack+0x330>)
 100de08:	f10d 0c08 	add.w	ip, sp, #8
			phys = conn->llcp_phy.tx | lll->phy_tx;
 100de0c:	ea43 0390 	orr.w	r3, r3, r0, lsr #2
			u8_t phy_tx_time[8] = {BIT(0), BIT(0), BIT(1), BIT(0),
 100de10:	c903      	ldmia	r1, {r0, r1}
 100de12:	e90c 0003 	stmdb	ip, {r0, r1}
			lll->phy_tx_time = phy_tx_time[phys];
 100de16:	f003 0307 	and.w	r3, r3, #7
 100de1a:	4463      	add	r3, ip
 100de1c:	f813 3c08 	ldrb.w	r3, [r3, #-8]
 100de20:	f363 1206 	bfi	r2, r3, #4, #3
 100de24:	f886 2064 	strb.w	r2, [r6, #100]	; 0x64
		conn->llcp_phy.pause_tx = 0U;
 100de28:	f896 31ab 	ldrb.w	r3, [r6, #427]	; 0x1ab
 100de2c:	f36f 0300 	bfc	r3, #0, #1
 100de30:	f886 31ab 	strb.w	r3, [r6, #427]	; 0x1ab
		break;
 100de34:	e74c      	b.n	100dcd0 <ull_conn_tx_ack+0x50>
			conn->llcp_enc.pause_tx = 1U;
 100de36:	f896 3152 	ldrb.w	r3, [r6, #338]	; 0x152
 100de3a:	f043 0302 	orr.w	r3, r3, #2
 100de3e:	f886 3152 	strb.w	r3, [r6, #338]	; 0x152
 100de42:	e745      	b.n	100dcd0 <ull_conn_tx_ack+0x50>
		if (pdu_tx->llctrl.reject_ext_ind.reject_opcode !=
 100de44:	7a23      	ldrb	r3, [r4, #8]
 100de46:	2b03      	cmp	r3, #3
 100de48:	f47f af42 	bne.w	100dcd0 <ull_conn_tx_ack+0x50>
		conn->procedure_expire = 0U;
 100de4c:	2200      	movs	r2, #0
		conn->llcp_enc.pause_rx = 0U;
 100de4e:	f896 3152 	ldrb.w	r3, [r6, #338]	; 0x152
		conn->procedure_expire = 0U;
 100de52:	f8a6 20cc 	strh.w	r2, [r6, #204]	; 0xcc
		conn->llcp_enc.pause_rx = 0U;
 100de56:	f023 0303 	bic.w	r3, r3, #3
 100de5a:	f886 3152 	strb.w	r3, [r6, #338]	; 0x152
		break;
 100de5e:	e737      	b.n	100dcd0 <ull_conn_tx_ack+0x50>
		conn->llcp_length.state = LLCP_LENGTH_STATE_RSP_WAIT;
 100de60:	2202      	movs	r2, #2
 100de62:	f890 319a 	ldrb.w	r3, [r0, #410]	; 0x19a
 100de66:	f362 0302 	bfi	r3, r2, #0, #3
 100de6a:	f880 319a 	strb.w	r3, [r0, #410]	; 0x19a
		break;
 100de6e:	e72f      	b.n	100dcd0 <ull_conn_tx_ack+0x50>
		conn->lll.phy_tx_time = conn->llcp.phy_upd_ind.tx;
 100de70:	f890 30ec 	ldrb.w	r3, [r0, #236]	; 0xec
 100de74:	f890 1064 	ldrb.w	r1, [r0, #100]	; 0x64
		conn->llcp_phy.pause_tx = 0U;
 100de78:	f890 21ab 	ldrb.w	r2, [r0, #427]	; 0x1ab
		conn->lll.phy_tx_time = conn->llcp.phy_upd_ind.tx;
 100de7c:	f3c3 0382 	ubfx	r3, r3, #2, #3
 100de80:	f363 1106 	bfi	r1, r3, #4, #3
		conn->llcp_phy.pause_tx = 0U;
 100de84:	f36f 0200 	bfc	r2, #0, #1
		conn->lll.phy_tx_time = conn->llcp.phy_upd_ind.tx;
 100de88:	f880 1064 	strb.w	r1, [r0, #100]	; 0x64
		conn->llcp_phy.pause_tx = 0U;
 100de8c:	f880 21ab 	strb.w	r2, [r0, #427]	; 0x1ab
		break;
 100de90:	e71e      	b.n	100dcd0 <ull_conn_tx_ack+0x50>
		conn->llcp_enc.pause_tx = 1U;
 100de92:	f890 3152 	ldrb.w	r3, [r0, #338]	; 0x152
		conn->procedure_expire = conn->procedure_reload;
 100de96:	f8b0 20ca 	ldrh.w	r2, [r0, #202]	; 0xca
		conn->llcp_enc.pause_tx = 1U;
 100de9a:	f023 0306 	bic.w	r3, r3, #6
 100de9e:	f043 0306 	orr.w	r3, r3, #6
 100dea2:	f880 3152 	strb.w	r3, [r0, #338]	; 0x152
		conn->llcp_enc.ack = conn->llcp_enc.req;
 100dea6:	f890 3150 	ldrb.w	r3, [r0, #336]	; 0x150
		conn->procedure_expire = conn->procedure_reload;
 100deaa:	f8a0 20cc 	strh.w	r2, [r0, #204]	; 0xcc
		conn->llcp_enc.ack = conn->llcp_enc.req;
 100deae:	f880 3151 	strb.w	r3, [r0, #337]	; 0x151
		break;
 100deb2:	e70d      	b.n	100dcd0 <ull_conn_tx_ack+0x50>
		memcpy(&conn->llcp.encryption.skd[0],
 100deb4:	2208      	movs	r2, #8
 100deb6:	f104 0112 	add.w	r1, r4, #18
 100deba:	30ee      	adds	r0, #238	; 0xee
 100debc:	f008 fcfc 	bl	10168b8 <memcpy>
		memcpy(&conn->lll.ccm_rx.iv[0],
 100dec0:	2204      	movs	r2, #4
 100dec2:	f104 011a 	add.w	r1, r4, #26
 100dec6:	f106 0098 	add.w	r0, r6, #152	; 0x98
 100deca:	f008 fcf5 	bl	10168b8 <memcpy>
		conn->llcp_enc.pause_tx = 1U;
 100dece:	f896 3152 	ldrb.w	r3, [r6, #338]	; 0x152
		conn->procedure_expire = conn->procedure_reload;
 100ded2:	f8b6 10ca 	ldrh.w	r1, [r6, #202]	; 0xca
		conn->llcp_enc.ack = conn->llcp_enc.req;
 100ded6:	f896 2150 	ldrb.w	r2, [r6, #336]	; 0x150
		conn->llcp_enc.pause_tx = 1U;
 100deda:	f043 0302 	orr.w	r3, r3, #2
 100dede:	f886 3152 	strb.w	r3, [r6, #338]	; 0x152
		conn->procedure_expire = conn->procedure_reload;
 100dee2:	f8a6 10cc 	strh.w	r1, [r6, #204]	; 0xcc
		conn->llcp_enc.ack = conn->llcp_enc.req;
 100dee6:	f886 2151 	strb.w	r2, [r6, #337]	; 0x151
		break;
 100deea:	e6f1      	b.n	100dcd0 <ull_conn_tx_ack+0x50>
		u8_t reason = (pdu_tx->llctrl.terminate_ind.error_code ==
 100deec:	7a21      	ldrb	r1, [r4, #8]
 100deee:	2913      	cmp	r1, #19
		conn_cleanup(conn, reason);
 100def0:	bf08      	it	eq
 100def2:	2116      	moveq	r1, #22
 100def4:	f7ff fb68 	bl	100d5c8 <conn_cleanup>
	break;
 100def8:	e6ea      	b.n	100dcd0 <ull_conn_tx_ack+0x50>
		if (conn->llcp_length.req != conn->llcp_length.ack) {
 100defa:	f890 1198 	ldrb.w	r1, [r0, #408]	; 0x198
 100defe:	f890 3199 	ldrb.w	r3, [r0, #409]	; 0x199
 100df02:	428b      	cmp	r3, r1
 100df04:	f43f aee4 	beq.w	100dcd0 <ull_conn_tx_ack+0x50>
			switch (conn->llcp_length.state) {
 100df08:	f890 219a 	ldrb.w	r2, [r0, #410]	; 0x19a
 100df0c:	f002 0307 	and.w	r3, r2, #7
 100df10:	2b03      	cmp	r3, #3
 100df12:	d005      	beq.n	100df20 <ull_conn_tx_ack+0x2a0>
 100df14:	3303      	adds	r3, #3
 100df16:	f003 0307 	and.w	r3, r3, #7
 100df1a:	2b01      	cmp	r3, #1
 100df1c:	f63f af5d 	bhi.w	100ddda <ull_conn_tx_ack+0x15a>
				conn->lll.max_tx_octets =
 100df20:	f8b6 319e 	ldrh.w	r3, [r6, #414]	; 0x19e
				conn->lll.max_tx_time =
 100df24:	f8b6 01a2 	ldrh.w	r0, [r6, #418]	; 0x1a2
				conn->lll.max_tx_octets =
 100df28:	f8a6 305c 	strh.w	r3, [r6, #92]	; 0x5c
				if (conn->llcp_length.state ==
 100df2c:	f002 0307 	and.w	r3, r2, #7
 100df30:	2b05      	cmp	r3, #5
				conn->lll.max_tx_time =
 100df32:	f8a6 0060 	strh.w	r0, [r6, #96]	; 0x60
				if (conn->llcp_length.state ==
 100df36:	d027      	beq.n	100df88 <ull_conn_tx_ack+0x308>
				if (!conn->llcp_length.cache.tx_octets) {
 100df38:	f8b6 31a4 	ldrh.w	r3, [r6, #420]	; 0x1a4
 100df3c:	b9b3      	cbnz	r3, 100df6c <ull_conn_tx_ack+0x2ec>
					conn->llcp_length.ack =
 100df3e:	f886 1199 	strb.w	r1, [r6, #409]	; 0x199
					conn->procedure_expire = 0U;
 100df42:	f8a6 30cc 	strh.w	r3, [r6, #204]	; 0xcc
					break;
 100df46:	e6c3      	b.n	100dcd0 <ull_conn_tx_ack+0x50>
		if (!conn->tx_ctrl) {
 100df48:	f8d6 21b4 	ldr.w	r2, [r6, #436]	; 0x1b4
 100df4c:	2a00      	cmp	r2, #0
 100df4e:	f47f af2b 	bne.w	100dda8 <ull_conn_tx_ack+0x128>
			tx->next = conn->tx_head;
 100df52:	6023      	str	r3, [r4, #0]
				conn->tx_ctrl = tx;
 100df54:	e9c6 446c 	strd	r4, r4, [r6, #432]	; 0x1b0
				conn->tx_ctrl_last = tx;
 100df58:	f8c6 41b8 	str.w	r4, [r6, #440]	; 0x1b8
 100df5c:	e72c      	b.n	100ddb8 <ull_conn_tx_ack+0x138>
		if (link->next == (void *)tx) {
 100df5e:	683b      	ldr	r3, [r7, #0]
		conn->tx_data_last = tx;
 100df60:	f8c6 41c0 	str.w	r4, [r6, #448]	; 0x1c0
		if (link->next == (void *)tx) {
 100df64:	2b00      	cmp	r3, #0
 100df66:	f47f aea3 	bne.w	100dcb0 <ull_conn_tx_ack+0x30>
 100df6a:	e72c      	b.n	100ddc6 <ull_conn_tx_ack+0x146>
				conn->llcp_length.cache.tx_octets = 0;
 100df6c:	2100      	movs	r1, #0
				conn->llcp_length.tx_octets =
 100df6e:	f8a6 319e 	strh.w	r3, [r6, #414]	; 0x19e
				conn->llcp_length.tx_time =
 100df72:	f8b6 31a6 	ldrh.w	r3, [r6, #422]	; 0x1a6
				conn->llcp_length.state = LLCP_LENGTH_STATE_REQ;
 100df76:	f361 0202 	bfi	r2, r1, #0, #3
 100df7a:	f886 219a 	strb.w	r2, [r6, #410]	; 0x19a
				conn->llcp_length.cache.tx_octets = 0;
 100df7e:	f8a6 11a4 	strh.w	r1, [r6, #420]	; 0x1a4
				conn->llcp_length.tx_time =
 100df82:	f8a6 31a2 	strh.w	r3, [r6, #418]	; 0x1a2
				break;
 100df86:	e6a3      	b.n	100dcd0 <ull_conn_tx_ack+0x50>
					conn->llcp_length.state =
 100df88:	2304      	movs	r3, #4
 100df8a:	f363 0202 	bfi	r2, r3, #0, #3
 100df8e:	f886 219a 	strb.w	r2, [r6, #410]	; 0x19a
					break;
 100df92:	e69d      	b.n	100dcd0 <ull_conn_tx_ack+0x50>
			tx->next = conn->tx_head->next;
 100df94:	681a      	ldr	r2, [r3, #0]
 100df96:	6022      	str	r2, [r4, #0]
			conn->tx_head->next = tx;
 100df98:	601c      	str	r4, [r3, #0]
				conn->tx_ctrl = tx;
 100df9a:	6823      	ldr	r3, [r4, #0]
				conn->tx_ctrl_last = tx;
 100df9c:	e9c6 446d 	strd	r4, r4, [r6, #436]	; 0x1b4
 100dfa0:	e70a      	b.n	100ddb8 <ull_conn_tx_ack+0x138>
 100dfa2:	bf00      	nop
 100dfa4:	21001b40 	.word	0x21001b40
 100dfa8:	010187e4 	.word	0x010187e4
 100dfac:	210038cc 	.word	0x210038cc
 100dfb0:	01018824 	.word	0x01018824

0100dfb4 <ull_conn_llcp_req>:
	if (conn_hdr->llcp_req != conn_hdr->llcp_ack) {
 100dfb4:	f890 30e9 	ldrb.w	r3, [r0, #233]	; 0xe9
 100dfb8:	f890 20e8 	ldrb.w	r2, [r0, #232]	; 0xe8
 100dfbc:	4293      	cmp	r3, r2
	conn_hdr->llcp_req++;
 100dfbe:	bf03      	ittte	eq
 100dfc0:	3301      	addeq	r3, #1
 100dfc2:	f880 30e8 	strbeq.w	r3, [r0, #232]	; 0xe8
	return 0;
 100dfc6:	2000      	moveq	r0, #0
		return BT_HCI_ERR_CMD_DISALLOWED;
 100dfc8:	200c      	movne	r0, #12
}
 100dfca:	4770      	bx	lr

0100dfcc <ull_conn_lll_max_tx_octets_get>:
	switch (lll->phy_tx_time) {
 100dfcc:	f890 2048 	ldrb.w	r2, [r0, #72]	; 0x48
 100dfd0:	f3c2 1302 	ubfx	r3, r2, #4, #3
 100dfd4:	2b02      	cmp	r3, #2
 100dfd6:	d012      	beq.n	100dffe <ull_conn_lll_max_tx_octets_get+0x32>
 100dfd8:	2b04      	cmp	r3, #4
		max_tx_octets = (lll->max_tx_time >> 3) - 10;
 100dfda:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
	switch (lll->phy_tx_time) {
 100dfde:	d014      	beq.n	100e00a <ull_conn_lll_max_tx_octets_get+0x3e>
		max_tx_octets = (lll->max_tx_time >> 3) - 10;
 100dfe0:	08db      	lsrs	r3, r3, #3
 100dfe2:	3b0a      	subs	r3, #10
 100dfe4:	b29b      	uxth	r3, r3
	if (lll->enc_tx) {
 100dfe6:	f890 2062 	ldrb.w	r2, [r0, #98]	; 0x62
	return max_tx_octets;
 100dfea:	f8b0 0040 	ldrh.w	r0, [r0, #64]	; 0x40
	if (lll->enc_tx) {
 100dfee:	06d2      	lsls	r2, r2, #27
		max_tx_octets -= 4U;
 100dff0:	bf44      	itt	mi
 100dff2:	3b04      	submi	r3, #4
 100dff4:	b29b      	uxthmi	r3, r3
}
 100dff6:	4298      	cmp	r0, r3
 100dff8:	bf28      	it	cs
 100dffa:	4618      	movcs	r0, r3
 100dffc:	4770      	bx	lr
		max_tx_octets = (lll->max_tx_time >> 2) - 11;
 100dffe:	f8b0 3044 	ldrh.w	r3, [r0, #68]	; 0x44
 100e002:	089b      	lsrs	r3, r3, #2
 100e004:	3b0b      	subs	r3, #11
 100e006:	b29b      	uxth	r3, r3
		break;
 100e008:	e7ed      	b.n	100dfe6 <ull_conn_lll_max_tx_octets_get+0x1a>
		if (lll->phy_flags & 0x01) {
 100e00a:	0711      	lsls	r1, r2, #28
			max_tx_octets = ((lll->max_tx_time - 592) >>
 100e00c:	bf4b      	itete	mi
 100e00e:	f5a3 7314 	submi.w	r3, r3, #592	; 0x250
			max_tx_octets = ((lll->max_tx_time - 430) >>
 100e012:	f5a3 73d7 	subpl.w	r3, r3, #430	; 0x1ae
			max_tx_octets = ((lll->max_tx_time - 592) >>
 100e016:	119b      	asrmi	r3, r3, #6
			max_tx_octets = ((lll->max_tx_time - 430) >>
 100e018:	111b      	asrpl	r3, r3, #4
					  4) - 2;
 100e01a:	3b02      	subs	r3, #2
			max_tx_octets = ((lll->max_tx_time - 430) >>
 100e01c:	b29b      	uxth	r3, r3
 100e01e:	e7e2      	b.n	100dfe6 <ull_conn_lll_max_tx_octets_get+0x1a>

0100e020 <ticker_op_cb>:

static void ticker_op_cb(u32_t status, void *param)
{
	ARG_UNUSED(param);

	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 100e020:	b900      	cbnz	r0, 100e024 <ticker_op_cb+0x4>
}
 100e022:	4770      	bx	lr
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 100e024:	f44f 71e2 	mov.w	r1, #452	; 0x1c4
 100e028:	4801      	ldr	r0, [pc, #4]	; (100e030 <ticker_op_cb+0x10>)
 100e02a:	f7f5 baad 	b.w	1003588 <bt_ctlr_assert_handle>
 100e02e:	bf00      	nop
 100e030:	01018844 	.word	0x01018844

0100e034 <ull_slave_ticker_cb>:
{
 100e034:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100e038:	4605      	mov	r5, r0
 100e03a:	4688      	mov	r8, r1
		ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
 100e03c:	4601      	mov	r1, r0
 100e03e:	4618      	mov	r0, r3
{
 100e040:	461c      	mov	r4, r3
 100e042:	4617      	mov	r7, r2
		ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
 100e044:	f7f2 fdb8 	bl	1000bb8 <ull_conn_llcp>
		if (ret) {
 100e048:	bb48      	cbnz	r0, 100e09e <ull_slave_ticker_cb+0x6a>
 100e04a:	7c23      	ldrb	r3, [r4, #16]
 100e04c:	3301      	adds	r3, #1
 100e04e:	b2db      	uxtb	r3, r3
 100e050:	7423      	strb	r3, [r4, #16]
	LL_ASSERT(ref);
 100e052:	b1f3      	cbz	r3, 100e092 <ull_slave_ticker_cb+0x5e>
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100e054:	2200      	movs	r2, #0
	p.ticks_at_expire = ticks_at_expire;
 100e056:	4e13      	ldr	r6, [pc, #76]	; (100e0a4 <ull_slave_ticker_cb+0x70>)
	mfy.param = &p;
 100e058:	4b13      	ldr	r3, [pc, #76]	; (100e0a8 <ull_slave_ticker_cb+0x74>)
	p.param = &conn->lll;
 100e05a:	f104 0c1c 	add.w	ip, r4, #28
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100e05e:	4611      	mov	r1, r2
 100e060:	2001      	movs	r0, #1
	p.remainder = remainder;
 100e062:	e9c6 5800 	strd	r5, r8, [r6]
	mfy.param = &p;
 100e066:	609e      	str	r6, [r3, #8]
	p.lazy = lazy;
 100e068:	8137      	strh	r7, [r6, #8]
	p.param = &conn->lll;
 100e06a:	f8c6 c00c 	str.w	ip, [r6, #12]
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100e06e:	f7f7 feaf 	bl	1005dd0 <mayfly_enqueue>
	LL_ASSERT(!err);
 100e072:	b940      	cbnz	r0, 100e086 <ull_slave_ticker_cb+0x52>
	ull_conn_tx_demux(UINT8_MAX);
 100e074:	20ff      	movs	r0, #255	; 0xff
 100e076:	f7ff fa25 	bl	100d4c4 <ull_conn_tx_demux>
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
 100e07a:	4620      	mov	r0, r4
}
 100e07c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
 100e080:	21ff      	movs	r1, #255	; 0xff
 100e082:	f7ff bc9d 	b.w	100d9c0 <ull_conn_tx_lll_enqueue>
	LL_ASSERT(!err);
 100e086:	f44f 71c0 	mov.w	r1, #384	; 0x180
 100e08a:	4808      	ldr	r0, [pc, #32]	; (100e0ac <ull_slave_ticker_cb+0x78>)
 100e08c:	f7f5 fa7c 	bl	1003588 <bt_ctlr_assert_handle>
 100e090:	e7f0      	b.n	100e074 <ull_slave_ticker_cb+0x40>
	LL_ASSERT(ref);
 100e092:	f44f 71ba 	mov.w	r1, #372	; 0x174
 100e096:	4805      	ldr	r0, [pc, #20]	; (100e0ac <ull_slave_ticker_cb+0x78>)
 100e098:	f7f5 fa76 	bl	1003588 <bt_ctlr_assert_handle>
 100e09c:	e7da      	b.n	100e054 <ull_slave_ticker_cb+0x20>
}
 100e09e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 100e0a2:	bf00      	nop
 100e0a4:	210039c4 	.word	0x210039c4
 100e0a8:	210003cc 	.word	0x210003cc
 100e0ac:	01018844 	.word	0x01018844

0100e0b0 <ticker_op_stop_adv_cb>:
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
 100e0b0:	2801      	cmp	r0, #1
 100e0b2:	d000      	beq.n	100e0b6 <ticker_op_stop_adv_cb+0x6>
 100e0b4:	4770      	bx	lr
{
 100e0b6:	b510      	push	{r4, lr}
 100e0b8:	460c      	mov	r4, r1
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
 100e0ba:	f7fc f83d 	bl	100a138 <ull_disable_mark_get>
 100e0be:	4284      	cmp	r4, r0
 100e0c0:	d006      	beq.n	100e0d0 <ticker_op_stop_adv_cb+0x20>
}
 100e0c2:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LL_ASSERT(status != TICKER_STATUS_FAILURE ||
 100e0c6:	f44f 71de 	mov.w	r1, #444	; 0x1bc
 100e0ca:	4802      	ldr	r0, [pc, #8]	; (100e0d4 <ticker_op_stop_adv_cb+0x24>)
 100e0cc:	f7f5 ba5c 	b.w	1003588 <bt_ctlr_assert_handle>
}
 100e0d0:	bd10      	pop	{r4, pc}
 100e0d2:	bf00      	nop
 100e0d4:	01018844 	.word	0x01018844

0100e0d8 <ll_start_enc_req_send>:
{
 100e0d8:	b570      	push	{r4, r5, r6, lr}
 100e0da:	460e      	mov	r6, r1
 100e0dc:	4615      	mov	r5, r2
	conn = ll_connected_get(handle);
 100e0de:	f7fd fa3f 	bl	100b560 <ll_connected_get>
	if (!conn) {
 100e0e2:	2800      	cmp	r0, #0
 100e0e4:	d040      	beq.n	100e168 <ll_start_enc_req_send+0x90>
	if (error_code) {
 100e0e6:	4604      	mov	r4, r0
 100e0e8:	b95e      	cbnz	r6, 100e102 <ll_start_enc_req_send+0x2a>
		if ((conn->llcp_req == conn->llcp_ack) ||
 100e0ea:	f890 20e8 	ldrb.w	r2, [r0, #232]	; 0xe8
 100e0ee:	f890 30e9 	ldrb.w	r3, [r0, #233]	; 0xe9
 100e0f2:	429a      	cmp	r2, r3
 100e0f4:	d003      	beq.n	100e0fe <ll_start_enc_req_send+0x26>
 100e0f6:	f890 30ea 	ldrb.w	r3, [r0, #234]	; 0xea
 100e0fa:	2b03      	cmp	r3, #3
 100e0fc:	d026      	beq.n	100e14c <ll_start_enc_req_send+0x74>
				return BT_HCI_ERR_CMD_DISALLOWED;
 100e0fe:	200c      	movs	r0, #12
}
 100e100:	bd70      	pop	{r4, r5, r6, pc}
		if (conn->llcp_enc.refresh == 0U) {
 100e102:	f890 0152 	ldrb.w	r0, [r0, #338]	; 0x152
 100e106:	f010 0004 	ands.w	r0, r0, #4
 100e10a:	d112      	bne.n	100e132 <ll_start_enc_req_send+0x5a>
			if ((conn->llcp_req == conn->llcp_ack) ||
 100e10c:	f894 20e8 	ldrb.w	r2, [r4, #232]	; 0xe8
 100e110:	f894 30e9 	ldrb.w	r3, [r4, #233]	; 0xe9
 100e114:	429a      	cmp	r2, r3
 100e116:	d0f2      	beq.n	100e0fe <ll_start_enc_req_send+0x26>
 100e118:	f894 30ea 	ldrb.w	r3, [r4, #234]	; 0xea
 100e11c:	2b03      	cmp	r3, #3
 100e11e:	d1ee      	bne.n	100e0fe <ll_start_enc_req_send+0x26>
			conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
 100e120:	f894 30ec 	ldrb.w	r3, [r4, #236]	; 0xec
			conn->llcp.encryption.error_code = error_code;
 100e124:	f884 60ed 	strb.w	r6, [r4, #237]	; 0xed
			conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
 100e128:	f360 0301 	bfi	r3, r0, #0, #2
 100e12c:	f884 30ec 	strb.w	r3, [r4, #236]	; 0xec
}
 100e130:	bd70      	pop	{r4, r5, r6, pc}
			    conn->llcp_terminate.req) {
 100e132:	f894 2128 	ldrb.w	r2, [r4, #296]	; 0x128
			if (conn->llcp_terminate.ack !=
 100e136:	f894 3129 	ldrb.w	r3, [r4, #297]	; 0x129
 100e13a:	4293      	cmp	r3, r2
 100e13c:	d1df      	bne.n	100e0fe <ll_start_enc_req_send+0x26>
			conn->llcp_terminate.req++;
 100e13e:	3301      	adds	r3, #1
 100e140:	f884 3128 	strb.w	r3, [r4, #296]	; 0x128
			conn->llcp_terminate.reason_own = error_code;
 100e144:	f884 612a 	strb.w	r6, [r4, #298]	; 0x12a
	return 0;
 100e148:	2000      	movs	r0, #0
}
 100e14a:	bd70      	pop	{r4, r5, r6, pc}
		memcpy(&conn->llcp_enc.ltk[0], ltk,
 100e14c:	4629      	mov	r1, r5
 100e14e:	2210      	movs	r2, #16
 100e150:	f200 105d 	addw	r0, r0, #349	; 0x15d
 100e154:	f008 fbb0 	bl	10168b8 <memcpy>
		conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
 100e158:	f8b4 30ec 	ldrh.w	r3, [r4, #236]	; 0xec
	return 0;
 100e15c:	4630      	mov	r0, r6
		conn->llcp.encryption.state = LLCP_ENC_STATE_INPROG;
 100e15e:	f003 03fc 	and.w	r3, r3, #252	; 0xfc
 100e162:	f8a4 30ec 	strh.w	r3, [r4, #236]	; 0xec
}
 100e166:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100e168:	2002      	movs	r0, #2
}
 100e16a:	bd70      	pop	{r4, r5, r6, pc}

0100e16c <ticker_op_stop_scan_cb>:
}

static void ticker_op_stop_scan_cb(u32_t status, void *params)
{
	/* TODO: */
}
 100e16c:	4770      	bx	lr
 100e16e:	bf00      	nop

0100e170 <ticker_op_cb>:

static void ticker_op_cb(u32_t status, void *params)
{
	ARG_UNUSED(params);

	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 100e170:	b900      	cbnz	r0, 100e174 <ticker_op_cb+0x4>
}
 100e172:	4770      	bx	lr
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 100e174:	f240 21b2 	movw	r1, #690	; 0x2b2
 100e178:	4801      	ldr	r0, [pc, #4]	; (100e180 <ticker_op_cb+0x10>)
 100e17a:	f7f5 ba05 	b.w	1003588 <bt_ctlr_assert_handle>
 100e17e:	bf00      	nop
 100e180:	0101889c 	.word	0x0101889c

0100e184 <ull_master_ticker_cb>:
{
 100e184:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100e188:	4605      	mov	r5, r0
 100e18a:	4688      	mov	r8, r1
		ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
 100e18c:	4601      	mov	r1, r0
 100e18e:	4618      	mov	r0, r3
{
 100e190:	461c      	mov	r4, r3
 100e192:	4617      	mov	r7, r2
		ret = ull_conn_llcp(conn, ticks_at_expire, lazy);
 100e194:	f7f2 fd10 	bl	1000bb8 <ull_conn_llcp>
		if (ret) {
 100e198:	bb80      	cbnz	r0, 100e1fc <ull_master_ticker_cb+0x78>
 100e19a:	7c23      	ldrb	r3, [r4, #16]
 100e19c:	3301      	adds	r3, #1
 100e19e:	b2db      	uxtb	r3, r3
 100e1a0:	7423      	strb	r3, [r4, #16]
	LL_ASSERT(ref);
 100e1a2:	b32b      	cbz	r3, 100e1f0 <ull_master_ticker_cb+0x6c>
	ull_conn_tx_demux(1);
 100e1a4:	2001      	movs	r0, #1
 100e1a6:	f7ff f98d 	bl	100d4c4 <ull_conn_tx_demux>
	ull_conn_tx_lll_enqueue(conn, 1);
 100e1aa:	2101      	movs	r1, #1
 100e1ac:	4620      	mov	r0, r4
 100e1ae:	f7ff fc07 	bl	100d9c0 <ull_conn_tx_lll_enqueue>
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100e1b2:	2200      	movs	r2, #0
	p.ticks_at_expire = ticks_at_expire;
 100e1b4:	4e12      	ldr	r6, [pc, #72]	; (100e200 <ull_master_ticker_cb+0x7c>)
	mfy.param = &p;
 100e1b6:	4b13      	ldr	r3, [pc, #76]	; (100e204 <ull_master_ticker_cb+0x80>)
	p.param = &conn->lll;
 100e1b8:	f104 0c1c 	add.w	ip, r4, #28
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100e1bc:	4611      	mov	r1, r2
 100e1be:	2001      	movs	r0, #1
	p.remainder = remainder;
 100e1c0:	e9c6 5800 	strd	r5, r8, [r6]
	mfy.param = &p;
 100e1c4:	609e      	str	r6, [r3, #8]
	p.lazy = lazy;
 100e1c6:	8137      	strh	r7, [r6, #8]
	p.param = &conn->lll;
 100e1c8:	f8c6 c00c 	str.w	ip, [r6, #12]
	err = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100e1cc:	f7f7 fe00 	bl	1005dd0 <mayfly_enqueue>
	LL_ASSERT(!err);
 100e1d0:	b940      	cbnz	r0, 100e1e4 <ull_master_ticker_cb+0x60>
	ull_conn_tx_demux(UINT8_MAX);
 100e1d2:	20ff      	movs	r0, #255	; 0xff
 100e1d4:	f7ff f976 	bl	100d4c4 <ull_conn_tx_demux>
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
 100e1d8:	4620      	mov	r0, r4
}
 100e1da:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	ull_conn_tx_lll_enqueue(conn, UINT8_MAX);
 100e1de:	21ff      	movs	r1, #255	; 0xff
 100e1e0:	f7ff bbee 	b.w	100d9c0 <ull_conn_tx_lll_enqueue>
	LL_ASSERT(!err);
 100e1e4:	f240 219e 	movw	r1, #670	; 0x29e
 100e1e8:	4807      	ldr	r0, [pc, #28]	; (100e208 <ull_master_ticker_cb+0x84>)
 100e1ea:	f7f5 f9cd 	bl	1003588 <bt_ctlr_assert_handle>
 100e1ee:	e7f0      	b.n	100e1d2 <ull_master_ticker_cb+0x4e>
	LL_ASSERT(ref);
 100e1f0:	f44f 7123 	mov.w	r1, #652	; 0x28c
 100e1f4:	4804      	ldr	r0, [pc, #16]	; (100e208 <ull_master_ticker_cb+0x84>)
 100e1f6:	f7f5 f9c7 	bl	1003588 <bt_ctlr_assert_handle>
 100e1fa:	e7d3      	b.n	100e1a4 <ull_master_ticker_cb+0x20>
}
 100e1fc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 100e200:	210039dc 	.word	0x210039dc
 100e204:	210003dc 	.word	0x210003dc
 100e208:	0101889c 	.word	0x0101889c

0100e20c <ll_create_connection>:
{
 100e20c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100e210:	b08d      	sub	sp, #52	; 0x34
 100e212:	9306      	str	r3, [sp, #24]
 100e214:	f89d 305c 	ldrb.w	r3, [sp, #92]	; 0x5c
 100e218:	4605      	mov	r5, r0
 100e21a:	9302      	str	r3, [sp, #8]
 100e21c:	f8bd 3060 	ldrh.w	r3, [sp, #96]	; 0x60
	scan = ull_scan_is_disabled_get(0);
 100e220:	2000      	movs	r0, #0
{
 100e222:	9304      	str	r3, [sp, #16]
 100e224:	f8bd 3064 	ldrh.w	r3, [sp, #100]	; 0x64
 100e228:	460e      	mov	r6, r1
 100e22a:	9307      	str	r3, [sp, #28]
 100e22c:	f8bd 3068 	ldrh.w	r3, [sp, #104]	; 0x68
 100e230:	9203      	str	r2, [sp, #12]
 100e232:	9305      	str	r3, [sp, #20]
	scan = ull_scan_is_disabled_get(0);
 100e234:	f7fc fde0 	bl	100adf8 <ull_scan_is_disabled_get>
	if (!scan) {
 100e238:	b128      	cbz	r0, 100e246 <ll_create_connection+0x3a>
	if (lll->conn) {
 100e23a:	f8d0 8024 	ldr.w	r8, [r0, #36]	; 0x24
 100e23e:	4607      	mov	r7, r0
 100e240:	f1b8 0f00 	cmp.w	r8, #0
 100e244:	d003      	beq.n	100e24e <ll_create_connection+0x42>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100e246:	200c      	movs	r0, #12
}
 100e248:	b00d      	add	sp, #52	; 0x34
 100e24a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	link = ll_rx_link_alloc();
 100e24e:	f7fb fec5 	bl	1009fdc <ll_rx_link_alloc>
	if (!link) {
 100e252:	9008      	str	r0, [sp, #32]
 100e254:	2800      	cmp	r0, #0
 100e256:	f000 8230 	beq.w	100e6ba <ll_create_connection+0x4ae>
	conn = ll_conn_acquire();
 100e25a:	f7fd f965 	bl	100b528 <ll_conn_acquire>
	if (!conn) {
 100e25e:	4604      	mov	r4, r0
 100e260:	2800      	cmp	r0, #0
 100e262:	f000 8276 	beq.w	100e752 <ll_create_connection+0x546>
	ull_scan_params_set(lll, 0, scan_interval, scan_window, filter_policy);
 100e266:	9b03      	ldr	r3, [sp, #12]
 100e268:	4641      	mov	r1, r8
 100e26a:	462a      	mov	r2, r5
 100e26c:	9300      	str	r3, [sp, #0]
 100e26e:	f107 001c 	add.w	r0, r7, #28
 100e272:	4633      	mov	r3, r6
 100e274:	f7f2 fbc4 	bl	1000a00 <ull_scan_params_set>
	lll->adv_addr_type = peer_addr_type;
 100e278:	f897 3032 	ldrb.w	r3, [r7, #50]	; 0x32
 100e27c:	9906      	ldr	r1, [sp, #24]
	memcpy(lll->adv_addr, peer_addr, BDADDR_SIZE);
 100e27e:	2206      	movs	r2, #6
	lll->adv_addr_type = peer_addr_type;
 100e280:	f361 1345 	bfi	r3, r1, #5, #1
 100e284:	f887 3032 	strb.w	r3, [r7, #50]	; 0x32
	memcpy(lll->adv_addr, peer_addr, BDADDR_SIZE);
 100e288:	9916      	ldr	r1, [sp, #88]	; 0x58
 100e28a:	f107 003b 	add.w	r0, r7, #59	; 0x3b
 100e28e:	f008 fb13 	bl	10168b8 <memcpy>
	lll_trng_get(access_addr, 4);
	aa = sys_get_le32(access_addr);

	bit_idx = 31U;
	transitions = 0U;
	consecutive_cnt = 1U;
 100e292:	f04f 0901 	mov.w	r9, #1
	lll->conn_ticks_slot = 0; /* TODO: */
 100e296:	f8c7 8028 	str.w	r8, [r7, #40]	; 0x28
	retry = 3U;
 100e29a:	f04f 0803 	mov.w	r8, #3
	conn_lll = &conn->lll;
 100e29e:	f104 031c 	add.w	r3, r4, #28
 100e2a2:	9309      	str	r3, [sp, #36]	; 0x24
	lll->conn_timeout = timeout;
 100e2a4:	9b05      	ldr	r3, [sp, #20]
 100e2a6:	863b      	strh	r3, [r7, #48]	; 0x30
	lll_trng_get(access_addr, 4);
 100e2a8:	2104      	movs	r1, #4
 100e2aa:	a80a      	add	r0, sp, #40	; 0x28
 100e2ac:	f001 fd52 	bl	100fd54 <lll_trng_get>
#if defined(CONFIG_BT_CTLR_PHY_CODED)
	ones_count_lsb8 = 0U;
 100e2b0:	f04f 0c00 	mov.w	ip, #0
	return ((u16_t)src[1] << 8) | src[0];
 100e2b4:	f89d 502b 	ldrb.w	r5, [sp, #43]	; 0x2b
 100e2b8:	f89d 202a 	ldrb.w	r2, [sp, #42]	; 0x2a
 100e2bc:	f89d 1029 	ldrb.w	r1, [sp, #41]	; 0x29
	return ((u32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
 100e2c0:	ea42 2205 	orr.w	r2, r2, r5, lsl #8
	return ((u16_t)src[1] << 8) | src[0];
 100e2c4:	f89d 5028 	ldrb.w	r5, [sp, #40]	; 0x28
	retry--;
 100e2c8:	f108 38ff 	add.w	r8, r8, #4294967295
	return ((u32_t)sys_get_le16(&src[2]) << 16) | sys_get_le16(&src[0]);
 100e2cc:	ea45 2501 	orr.w	r5, r5, r1, lsl #8
 100e2d0:	ea45 4502 	orr.w	r5, r5, r2, lsl #16
	transitions_lsb16 = 0U;
#endif /* CONFIG_BT_CTLR_PHY_CODED */
	consecutive_bit = (aa >> bit_idx) & 0x01;
 100e2d4:	231e      	movs	r3, #30
	transitions_lsb16 = 0U;
 100e2d6:	4660      	mov	r0, ip
	transitions = 0U;
 100e2d8:	4666      	mov	r6, ip
	consecutive_cnt = 1U;
 100e2da:	f04f 0e01 	mov.w	lr, #1
	retry--;
 100e2de:	fa5f f888 	uxtb.w	r8, r8
	consecutive_bit = (aa >> bit_idx) & 0x01;
 100e2e2:	0bd2      	lsrs	r2, r2, #15
	while (bit_idx--) {
 100e2e4:	e01d      	b.n	100e322 <ll_create_connection+0x116>
		if (bit == consecutive_bit) {
			consecutive_cnt++;
		} else {
			consecutive_cnt = 1U;
			consecutive_bit = bit;
			transitions++;
 100e2e6:	f106 0a01 	add.w	sl, r6, #1

#if defined(CONFIG_BT_CTLR_PHY_CODED)
			if (bit_idx < 15) {
 100e2ea:	2b0e      	cmp	r3, #14
			transitions++;
 100e2ec:	fa5f fa8a 	uxtb.w	sl, sl
			if (bit_idx < 15) {
 100e2f0:	b2da      	uxtb	r2, r3
 100e2f2:	f240 81c4 	bls.w	100e67e <ll_create_connection+0x472>

		/* It shall have no more than six consecutive zeros or ones. */
		/* It shall have a minimum of two transitions in the most
		 * significant six bits.
		 */
		if ((consecutive_cnt > 6) ||
 100e2f6:	2900      	cmp	r1, #0
 100e2f8:	f000 81ab 	beq.w	100e652 <ll_create_connection+0x446>
 100e2fc:	460a      	mov	r2, r1
 100e2fe:	4683      	mov	fp, r0
					  ((bit_idx < 5) &&
					   (ones_count_lsb8 < 2)) ||
					  ((bit_idx < 4) &&
					   (ones_count_lsb8 < 3)))) ||
#endif /* CONFIG_BT_CTLR_PHY_CODED */
		    ((consecutive_cnt < 6) &&
 100e300:	2b1c      	cmp	r3, #28
 100e302:	f240 824a 	bls.w	100e79a <ll_create_connection+0x58e>
		     (((bit_idx < 29) && (transitions < 1)) ||
 100e306:	2b1b      	cmp	r3, #27
 100e308:	f240 825c 	bls.w	100e7c4 <ll_create_connection+0x5b8>

		/* It shall have no more than 24 transitions
		 * It shall have no more than eleven transitions in the least
		 * significant 16 bits.
		 */
		if ((transitions > 24) ||
 100e30c:	f1ba 0f19 	cmp.w	sl, #25
 100e310:	d032      	beq.n	100e378 <ll_create_connection+0x16c>
					   (ones_count_lsb8 < 3)))) ||
 100e312:	468e      	mov	lr, r1
 100e314:	4656      	mov	r6, sl
#if defined(CONFIG_BT_CTLR_PHY_CODED)
		    (transitions_lsb16 > 11) ||
 100e316:	f1bb 0f0c 	cmp.w	fp, #12
					   (ones_count_lsb8 < 3)))) ||
 100e31a:	4658      	mov	r0, fp
		    (transitions_lsb16 > 11) ||
 100e31c:	d02c      	beq.n	100e378 <ll_create_connection+0x16c>
	while (bit_idx--) {
 100e31e:	3b01      	subs	r3, #1
 100e320:	d332      	bcc.n	100e388 <ll_create_connection+0x17c>
		bit = (aa >> bit_idx) & 0x01;
 100e322:	fa25 f103 	lsr.w	r1, r5, r3
 100e326:	f001 0101 	and.w	r1, r1, #1
		if (bit == consecutive_bit) {
 100e32a:	4291      	cmp	r1, r2
 100e32c:	d1db      	bne.n	100e2e6 <ll_create_connection+0xda>
			consecutive_cnt++;
 100e32e:	f10e 0101 	add.w	r1, lr, #1
		if ((bit_idx < 8) && consecutive_bit) {
 100e332:	2b07      	cmp	r3, #7
			consecutive_cnt++;
 100e334:	b2c9      	uxtb	r1, r1
		if ((bit_idx < 8) && consecutive_bit) {
 100e336:	f240 824a 	bls.w	100e7ce <ll_create_connection+0x5c2>
		if ((consecutive_cnt > 6) ||
 100e33a:	2906      	cmp	r1, #6
 100e33c:	f240 8180 	bls.w	100e640 <ll_create_connection+0x434>
			if (consecutive_bit) {
 100e340:	2a00      	cmp	r2, #0
 100e342:	f000 8167 	beq.w	100e614 <ll_create_connection+0x408>
				aa &= ~BIT(bit_idx);
 100e346:	fa09 f203 	lsl.w	r2, r9, r3
 100e34a:	ea25 0502 	bic.w	r5, r5, r2
 100e34e:	46b2      	mov	sl, r6
 100e350:	4683      	mov	fp, r0
				consecutive_bit = 0U;
 100e352:	2200      	movs	r2, #0
				transitions++;
 100e354:	f10a 0a01 	add.w	sl, sl, #1
			if (bit_idx < 15) {
 100e358:	2b0e      	cmp	r3, #14
				consecutive_cnt = 1U;
 100e35a:	bf88      	it	hi
 100e35c:	2101      	movhi	r1, #1
				transitions++;
 100e35e:	fa5f fa8a 	uxtb.w	sl, sl
			if (bit_idx < 15) {
 100e362:	d8d3      	bhi.n	100e30c <ll_create_connection+0x100>
				if (transitions_lsb16 !=
 100e364:	4558      	cmp	r0, fp
 100e366:	f000 8262 	beq.w	100e82e <ll_create_connection+0x622>
		if ((transitions > 24) ||
 100e36a:	f1ba 0f19 	cmp.w	sl, #25
 100e36e:	d003      	beq.n	100e378 <ll_create_connection+0x16c>
 100e370:	4656      	mov	r6, sl
				consecutive_cnt = 1U;
 100e372:	f04f 0e01 	mov.w	lr, #1
 100e376:	e7d2      	b.n	100e31e <ll_create_connection+0x112>
#endif /* CONFIG_BT_CTLR_PHY_CODED */
		    0) {
			if (consecutive_bit) {
				aa &= ~(BIT(bit_idx + 1) - 1);
 100e378:	3301      	adds	r3, #1
 100e37a:	fa09 f303 	lsl.w	r3, r9, r3
			if (consecutive_bit) {
 100e37e:	2a00      	cmp	r2, #0
 100e380:	f000 8188 	beq.w	100e694 <ll_create_connection+0x488>
				aa &= ~(BIT(bit_idx + 1) - 1);
 100e384:	425b      	negs	r3, r3
 100e386:	401d      	ands	r5, r3

	/* It shall not be the advertising channel packets Access Address.
	 * It shall not be a sequence that differs from the advertising channel
	 * packets Access Address by only one bit.
	 */
	adv_aa_check = aa ^ PDU_AC_ACCESS_ADDR;
 100e388:	4bd4      	ldr	r3, [pc, #848]	; (100e6dc <ll_create_connection+0x4d0>)
	if (util_ones_count_get((u8_t *)&adv_aa_check,
 100e38a:	2104      	movs	r1, #4
	adv_aa_check = aa ^ PDU_AC_ACCESS_ADDR;
 100e38c:	406b      	eors	r3, r5
	if (util_ones_count_get((u8_t *)&adv_aa_check,
 100e38e:	a80b      	add	r0, sp, #44	; 0x2c
	adv_aa_check = aa ^ PDU_AC_ACCESS_ADDR;
 100e390:	930b      	str	r3, [sp, #44]	; 0x2c
	if (util_ones_count_get((u8_t *)&adv_aa_check,
 100e392:	f7f7 fe11 	bl	1005fb8 <util_ones_count_get>
 100e396:	2801      	cmp	r0, #1
 100e398:	d907      	bls.n	100e3aa <ll_create_connection+0x19e>
				sizeof(adv_aa_check)) <= 1) {
		goto again;
	}

	/* It shall not have all four octets equal. */
	if (!((aa & 0xFFFF) ^ (aa >> 16)) &&
 100e39a:	b2ab      	uxth	r3, r5
 100e39c:	ebb3 4f15 	cmp.w	r3, r5, lsr #16
 100e3a0:	d10d      	bne.n	100e3be <ll_create_connection+0x1b2>
	    !((aa & 0xFF) ^ (aa >> 24))) {
 100e3a2:	b2eb      	uxtb	r3, r5
	if (!((aa & 0xFFFF) ^ (aa >> 16)) &&
 100e3a4:	ebb3 6f15 	cmp.w	r3, r5, lsr #24
 100e3a8:	d109      	bne.n	100e3be <ll_create_connection+0x1b2>
	LL_ASSERT(retry);
 100e3aa:	f1b8 0f00 	cmp.w	r8, #0
 100e3ae:	f47f af7b 	bne.w	100e2a8 <ll_create_connection+0x9c>
 100e3b2:	f240 21d5 	movw	r1, #725	; 0x2d5
 100e3b6:	48ca      	ldr	r0, [pc, #808]	; (100e6e0 <ll_create_connection+0x4d4>)
 100e3b8:	f7f5 f8e6 	bl	1003588 <bt_ctlr_assert_handle>
 100e3bc:	e774      	b.n	100e2a8 <ll_create_connection+0x9c>
	memcpy(conn_lll->access_addr, &access_addr,
 100e3be:	2204      	movs	r2, #4
 100e3c0:	a90a      	add	r1, sp, #40	; 0x28
 100e3c2:	f104 0024 	add.w	r0, r4, #36	; 0x24
	dst[0] = val;
 100e3c6:	950a      	str	r5, [sp, #40]	; 0x28
 100e3c8:	f008 fa76 	bl	10168b8 <memcpy>
	lll_trng_get(&conn_lll->crc_init[0], 3);
 100e3cc:	2103      	movs	r1, #3
 100e3ce:	f104 0028 	add.w	r0, r4, #40	; 0x28
 100e3d2:	f001 fcbf 	bl	100fd54 <lll_trng_get>
	conn_lll->handle = 0xFFFF;
 100e3d6:	f64f 73ff 	movw	r3, #65535	; 0xffff
	conn_lll->interval = interval;
 100e3da:	9a04      	ldr	r2, [sp, #16]
	if (!conn_lll->link_tx_free) {
 100e3dc:	6fa0      	ldr	r0, [r4, #120]	; 0x78
	conn_lll->interval = interval;
 100e3de:	85e2      	strh	r2, [r4, #46]	; 0x2e
	conn_lll->latency = latency;
 100e3e0:	9a07      	ldr	r2, [sp, #28]
	conn_lll->handle = 0xFFFF;
 100e3e2:	85a3      	strh	r3, [r4, #44]	; 0x2c
	conn_lll->latency = latency;
 100e3e4:	8622      	strh	r2, [r4, #48]	; 0x30
	if (!conn_lll->link_tx_free) {
 100e3e6:	2800      	cmp	r0, #0
 100e3e8:	f000 8163 	beq.w	100e6b2 <ll_create_connection+0x4a6>
	memq_init(conn_lll->link_tx_free, &conn_lll->memq_tx.head,
 100e3ec:	f104 026c 	add.w	r2, r4, #108	; 0x6c
 100e3f0:	f104 0168 	add.w	r1, r4, #104	; 0x68
 100e3f4:	f7f7 fc6a 	bl	1005ccc <memq_init>
	conn_lll->link_tx_free = NULL;
 100e3f8:	2500      	movs	r5, #0
	conn_lll->max_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
 100e3fa:	f04f 111b 	mov.w	r1, #1769499	; 0x1b001b
	conn_lll->rssi_latest = 0x7F;
 100e3fe:	227f      	movs	r2, #127	; 0x7f
	conn_lll->phy_tx = BIT(0);
 100e400:	f8b4 3064 	ldrh.w	r3, [r4, #100]	; 0x64
	conn_lll->sn = 0;
 100e404:	f894 007e 	ldrb.w	r0, [r4, #126]	; 0x7e
	conn_lll->phy_tx = BIT(0);
 100e408:	f423 63ef 	bic.w	r3, r3, #1912	; 0x778
 100e40c:	f023 0307 	bic.w	r3, r3, #7
 100e410:	f443 7388 	orr.w	r3, r3, #272	; 0x110
 100e414:	f043 0301 	orr.w	r3, r3, #1
 100e418:	f8a4 3064 	strh.w	r3, [r4, #100]	; 0x64
	conn_lll->max_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M);
 100e41c:	4bb1      	ldr	r3, [pc, #708]	; (100e6e4 <ll_create_connection+0x4d8>)
	conn_lll->sn = 0;
 100e41e:	f020 0007 	bic.w	r0, r0, #7
 100e422:	f884 007e 	strb.w	r0, [r4, #126]	; 0x7e
	conn_lll->max_tx_octets = PDU_DC_PAYLOAD_SIZE_MIN;
 100e426:	65e1      	str	r1, [r4, #92]	; 0x5c
	conn_lll->rssi_latest = 0x7F;
 100e428:	f884 20c1 	strb.w	r2, [r4, #193]	; 0xc1
	conn_lll->max_tx_time = PKT_US(PDU_DC_PAYLOAD_SIZE_MIN, PHY_1M);
 100e42c:	6623      	str	r3, [r4, #96]	; 0x60
	conn_lll->link_tx_free = NULL;
 100e42e:	67a5      	str	r5, [r4, #120]	; 0x78
	conn_lll->packet_tx_head_len = 0;
 100e430:	f8a4 507c 	strh.w	r5, [r4, #124]	; 0x7c
	conn_lll->latency_prepare = 0;
 100e434:	8665      	strh	r5, [r4, #50]	; 0x32
	conn_lll->latency_event = 0;
 100e436:	6365      	str	r5, [r4, #52]	; 0x34
		ull_conn_chan_map_cpy(conn_lll->data_chan_map);
 100e438:	f104 0038 	add.w	r0, r4, #56	; 0x38
 100e43c:	f7fd fbde 	bl	100bbfc <ull_conn_chan_map_cpy>
 100e440:	4602      	mov	r2, r0
	conn_lll->data_chan_count =
 100e442:	f894 303d 	ldrb.w	r3, [r4, #61]	; 0x3d
	lll_trng_get(&hop, sizeof(u8_t));
 100e446:	2101      	movs	r1, #1
	conn_lll->data_chan_count =
 100e448:	f362 0305 	bfi	r3, r2, #0, #6
 100e44c:	f884 303d 	strb.w	r3, [r4, #61]	; 0x3d
	lll_trng_get(&hop, sizeof(u8_t));
 100e450:	a80b      	add	r0, sp, #44	; 0x2c
 100e452:	f001 fc7f 	bl	100fd54 <lll_trng_get>
	conn_interval_us = (u32_t)interval * 1250U;
 100e456:	f240 40e2 	movw	r0, #1250	; 0x4e2
	conn->supervision_reload = RADIO_CONN_EVENTS(timeout * 10000U,
 100e45a:	f242 7210 	movw	r2, #10000	; 0x2710
	conn_interval_us = (u32_t)interval * 1250U;
 100e45e:	9904      	ldr	r1, [sp, #16]
	conn->connect_expire = 6U;
 100e460:	f04f 0e06 	mov.w	lr, #6
	conn_interval_us = (u32_t)interval * 1250U;
 100e464:	fb00 f101 	mul.w	r1, r0, r1
	conn->supervision_reload = RADIO_CONN_EVENTS(timeout * 10000U,
 100e468:	9805      	ldr	r0, [sp, #20]
 100e46a:	1e4b      	subs	r3, r1, #1
 100e46c:	fb02 3300 	mla	r3, r2, r0, r3
	conn->apto_reload = RADIO_CONN_EVENTS((30000000), conn_interval_us);
 100e470:	4a9d      	ldr	r2, [pc, #628]	; (100e6e8 <ll_create_connection+0x4dc>)
	conn->procedure_reload = RADIO_CONN_EVENTS(40000000,
 100e472:	489e      	ldr	r0, [pc, #632]	; (100e6ec <ll_create_connection+0x4e0>)
	conn->apto_reload = RADIO_CONN_EVENTS((30000000), conn_interval_us);
 100e474:	440a      	add	r2, r1
	conn->supervision_reload = RADIO_CONN_EVENTS(timeout * 10000U,
 100e476:	fbb3 f3f1 	udiv	r3, r3, r1
	conn->apto_reload = RADIO_CONN_EVENTS((30000000), conn_interval_us);
 100e47a:	fbb2 f2f1 	udiv	r2, r2, r1
	conn->procedure_reload = RADIO_CONN_EVENTS(40000000,
 100e47e:	4408      	add	r0, r1
 100e480:	fbb0 f0f1 	udiv	r0, r0, r1
	conn_lll->data_chan_hop = 5 + (hop % 12);
 100e484:	4e9a      	ldr	r6, [pc, #616]	; (100e6f0 <ll_create_connection+0x4e4>)
 100e486:	f89d 102c 	ldrb.w	r1, [sp, #44]	; 0x2c
	conn->supervision_reload = RADIO_CONN_EVENTS(timeout * 10000U,
 100e48a:	f8a4 30c6 	strh.w	r3, [r4, #198]	; 0xc6
	conn_lll->data_chan_hop = 5 + (hop % 12);
 100e48e:	fba6 c601 	umull	ip, r6, r6, r1
 100e492:	08f6      	lsrs	r6, r6, #3
 100e494:	eb06 0646 	add.w	r6, r6, r6, lsl #1
 100e498:	eba1 0186 	sub.w	r1, r1, r6, lsl #2
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
 100e49c:	8e26      	ldrh	r6, [r4, #48]	; 0x30
	conn_lll->data_chan_sel = 0;
 100e49e:	f894 c03d 	ldrb.w	ip, [r4, #61]	; 0x3d
	conn_lll->data_chan_hop = 5 + (hop % 12);
 100e4a2:	3105      	adds	r1, #5
 100e4a4:	f884 103e 	strb.w	r1, [r4, #62]	; 0x3e
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
 100e4a8:	eb06 030e 	add.w	r3, r6, lr
	conn->apto_reload = RADIO_CONN_EVENTS((30000000), conn_interval_us);
 100e4ac:	b291      	uxth	r1, r2
	conn_lll->data_chan_sel = 0;
 100e4ae:	f00c 0c3f 	and.w	ip, ip, #63	; 0x3f
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
 100e4b2:	4299      	cmp	r1, r3
	conn_lll->data_chan_use = 0;
 100e4b4:	f884 503f 	strb.w	r5, [r4, #63]	; 0x3f
	conn->supervision_expire = 0U;
 100e4b8:	f8a4 50c8 	strh.w	r5, [r4, #200]	; 0xc8
	conn->procedure_expire = 0U;
 100e4bc:	f8a4 50cc 	strh.w	r5, [r4, #204]	; 0xcc
	conn->apto_expire = 0U;
 100e4c0:	f8a4 50d4 	strh.w	r5, [r4, #212]	; 0xd4
	conn->appto_expire = 0U;
 100e4c4:	f8a4 50d0 	strh.w	r5, [r4, #208]	; 0xd0
	conn->apto_reload = RADIO_CONN_EVENTS((30000000), conn_interval_us);
 100e4c8:	f8a4 10d2 	strh.w	r1, [r4, #210]	; 0xd2
	conn->procedure_reload = RADIO_CONN_EVENTS(40000000,
 100e4cc:	f8a4 00ca 	strh.w	r0, [r4, #202]	; 0xca
	conn_lll->data_chan_sel = 0;
 100e4d0:	f884 c03d 	strb.w	ip, [r4, #61]	; 0x3d
	conn->connect_expire = 6U;
 100e4d4:	f8a4 e0c4 	strh.w	lr, [r4, #196]	; 0xc4
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
 100e4d8:	dd02      	ble.n	100e4e0 <ll_create_connection+0x2d4>
			     (conn->apto_reload - (conn_lll->latency + 6)) :
 100e4da:	1b89      	subs	r1, r1, r6
 100e4dc:	3906      	subs	r1, #6
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
 100e4de:	b289      	uxth	r1, r1
	conn->llcp_req = conn->llcp_ack = conn->llcp_type = 0U;
 100e4e0:	2500      	movs	r5, #0
	conn->appto_reload = (conn->apto_reload > (conn_lll->latency + 6)) ?
 100e4e2:	f8a4 10ce 	strh.w	r1, [r4, #206]	; 0xce
	conn->llcp_terminate.node_rx.hdr.link = link;
 100e4e6:	9908      	ldr	r1, [sp, #32]
	conn->llcp_conn_param.disabled = 0U;
 100e4e8:	f894 2172 	ldrb.w	r2, [r4, #370]	; 0x172
	conn->llcp_length.disabled = 0U;
 100e4ec:	f894 319a 	ldrb.w	r3, [r4, #410]	; 0x19a
	conn->llcp_terminate.node_rx.hdr.link = link;
 100e4f0:	f8c4 112c 	str.w	r1, [r4, #300]	; 0x12c
	conn->llcp_version.tx = conn->llcp_version.rx = 0U;
 100e4f4:	f894 1122 	ldrb.w	r1, [r4, #290]	; 0x122
	conn->llcp_conn_param.disabled = 0U;
 100e4f8:	f365 1204 	bfi	r2, r5, #4, #1
	conn->llcp_length.disabled = 0U;
 100e4fc:	f365 03c3 	bfi	r3, r5, #3, #1
	conn->common.fex_valid = 0U;
 100e500:	f894 00dc 	ldrb.w	r0, [r4, #220]	; 0xdc
	conn->llcp_conn_param.disabled = 0U;
 100e504:	f884 2172 	strb.w	r2, [r4, #370]	; 0x172
	conn->llcp_length.disabled = 0U;
 100e508:	f884 319a 	strb.w	r3, [r4, #410]	; 0x19a
	conn_lll->enc_rx = conn_lll->enc_tx = 0U;
 100e50c:	f894 207e 	ldrb.w	r2, [r4, #126]	; 0x7e
	conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
 100e510:	f894 3152 	ldrb.w	r3, [r4, #338]	; 0x152
	conn->llcp_version.tx = conn->llcp_version.rx = 0U;
 100e514:	f021 0103 	bic.w	r1, r1, #3
 100e518:	f884 1122 	strb.w	r1, [r4, #290]	; 0x122
	conn->llcp_feature.features = LL_FEAT;
 100e51c:	4975      	ldr	r1, [pc, #468]	; (100e6f4 <ll_create_connection+0x4e8>)
	conn_lll->enc_rx = conn_lll->enc_tx = 0U;
 100e51e:	f022 0218 	bic.w	r2, r2, #24
	conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
 100e522:	f023 0307 	bic.w	r3, r3, #7
	conn->common.fex_valid = 0U;
 100e526:	f020 0003 	bic.w	r0, r0, #3
	conn->llcp_feature.features = LL_FEAT;
 100e52a:	f8c4 111c 	str.w	r1, [r4, #284]	; 0x11c
	conn_lll->enc_rx = conn_lll->enc_tx = 0U;
 100e52e:	f884 207e 	strb.w	r2, [r4, #126]	; 0x7e
	conn->llcp_enc.pause_tx = conn->llcp_enc.pause_rx = 0U;
 100e532:	f884 3152 	strb.w	r3, [r4, #338]	; 0x152
	conn->llcp_req = conn->llcp_ack = conn->llcp_type = 0U;
 100e536:	f8a4 50e8 	strh.w	r5, [r4, #232]	; 0xe8
 100e53a:	f884 50ea 	strb.w	r5, [r4, #234]	; 0xea
	conn->llcp_rx = NULL;
 100e53e:	f8c4 5100 	str.w	r5, [r4, #256]	; 0x100
	conn->llcp_cu.req = conn->llcp_cu.ack = 0;
 100e542:	f8a4 5104 	strh.w	r5, [r4, #260]	; 0x104
	conn->llcp_feature.req = conn->llcp_feature.ack = 0;
 100e546:	f8a4 5118 	strh.w	r5, [r4, #280]	; 0x118
	conn->llcp_version.req = conn->llcp_version.ack = 0;
 100e54a:	f8a4 5120 	strh.w	r5, [r4, #288]	; 0x120
	conn->llcp_terminate.reason_peer = 0U;
 100e54e:	f884 512b 	strb.w	r5, [r4, #299]	; 0x12b
	conn->llcp_enc.req = conn->llcp_enc.ack = 0U;
 100e552:	f8a4 5150 	strh.w	r5, [r4, #336]	; 0x150
	conn->llcp_conn_param.req = 0U;
 100e556:	f8a4 5170 	strh.w	r5, [r4, #368]	; 0x170
	conn->llcp_length.req = conn->llcp_length.ack = 0U;
 100e55a:	f8a4 5198 	strh.w	r5, [r4, #408]	; 0x198
	conn->llcp_length.cache.tx_octets = 0U;
 100e55e:	f8a4 51a4 	strh.w	r5, [r4, #420]	; 0x1a4
	conn->common.fex_valid = 0U;
 100e562:	f884 00dc 	strb.w	r0, [r4, #220]	; 0xdc
	conn->default_tx_octets = ull_conn_default_tx_octets_get();
 100e566:	f7fd fb67 	bl	100bc38 <ull_conn_default_tx_octets_get>
 100e56a:	f8a4 00d6 	strh.w	r0, [r4, #214]	; 0xd6
	conn->default_tx_time = ull_conn_default_tx_time_get();
 100e56e:	f7fd fb69 	bl	100bc44 <ull_conn_default_tx_time_get>
	conn->llcp_phy.req = conn->llcp_phy.ack = 0U;
 100e572:	f8d4 21a8 	ldr.w	r2, [r4, #424]	; 0x1a8
 100e576:	4b60      	ldr	r3, [pc, #384]	; (100e6f8 <ll_create_connection+0x4ec>)
	conn->default_tx_time = ull_conn_default_tx_time_get();
 100e578:	f8a4 00d8 	strh.w	r0, [r4, #216]	; 0xd8
	conn->llcp_phy.req = conn->llcp_phy.ack = 0U;
 100e57c:	4013      	ands	r3, r2
 100e57e:	f8c4 31a8 	str.w	r3, [r4, #424]	; 0x1a8
	conn->phy_pref_tx = ull_conn_default_phy_tx_get();
 100e582:	f7fd fb65 	bl	100bc50 <ull_conn_default_phy_tx_get>
 100e586:	f894 31ac 	ldrb.w	r3, [r4, #428]	; 0x1ac
 100e58a:	f360 0302 	bfi	r3, r0, #0, #3
 100e58e:	f884 31ac 	strb.w	r3, [r4, #428]	; 0x1ac
	conn->phy_pref_rx = ull_conn_default_phy_rx_get();
 100e592:	f7fd fb63 	bl	100bc5c <ull_conn_default_phy_rx_get>
	conn->phy_pref_flags = 0U;
 100e596:	f894 31ac 	ldrb.w	r3, [r4, #428]	; 0x1ac
 100e59a:	0100      	lsls	r0, r0, #4
 100e59c:	f023 0378 	bic.w	r3, r3, #120	; 0x78
 100e5a0:	f000 0070 	and.w	r0, r0, #112	; 0x70
 100e5a4:	4318      	orrs	r0, r3
	lll->conn = conn_lll;
 100e5a6:	9b09      	ldr	r3, [sp, #36]	; 0x24
	conn->phy_pref_flags = 0U;
 100e5a8:	f884 01ac 	strb.w	r0, [r4, #428]	; 0x1ac
	conn->tx_data = conn->tx_data_last = 0;
 100e5ac:	e9c4 556f 	strd	r5, r5, [r4, #444]	; 0x1bc
	conn->tx_head = conn->tx_ctrl = conn->tx_ctrl_last =
 100e5b0:	e9c4 556d 	strd	r5, r5, [r4, #436]	; 0x1b4
 100e5b4:	f8c4 51b0 	str.w	r5, [r4, #432]	; 0x1b0
	lll->conn = conn_lll;
 100e5b8:	627b      	str	r3, [r7, #36]	; 0x24
	hdr->is_stop = 0U;
 100e5ba:	f894 3020 	ldrb.w	r3, [r4, #32]
	hdr->disabled_cb = hdr->disabled_param = NULL;
 100e5be:	61a5      	str	r5, [r4, #24]
 100e5c0:	f365 0300 	bfi	r3, r5, #0, #1
 100e5c4:	f884 3020 	strb.w	r3, [r4, #32]
 100e5c8:	6165      	str	r5, [r4, #20]
	hdr->parent = parent;
 100e5ca:	61e4      	str	r4, [r4, #28]
	ull_filter_scan_update(filter_policy);
 100e5cc:	9c03      	ldr	r4, [sp, #12]
 100e5ce:	4620      	mov	r0, r4
 100e5d0:	f000 fc1c 	bl	100ee0c <ull_filter_scan_update>
	lll->rl_idx = FILTER_IDX_NONE;
 100e5d4:	22ff      	movs	r2, #255	; 0xff
	lll->rpa_gen = 0;
 100e5d6:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
	lll->rl_idx = FILTER_IDX_NONE;
 100e5da:	f887 2034 	strb.w	r2, [r7, #52]	; 0x34
	lll->rpa_gen = 0;
 100e5de:	f365 0300 	bfi	r3, r5, #0, #1
 100e5e2:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
	if (!filter_policy && ull_filter_lll_rl_enabled()) {
 100e5e6:	2c00      	cmp	r4, #0
 100e5e8:	d057      	beq.n	100e69a <ll_create_connection+0x48e>
	if (own_addr_type == BT_ADDR_LE_PUBLIC_ID ||
 100e5ea:	9b02      	ldr	r3, [sp, #8]
 100e5ec:	3b02      	subs	r3, #2
 100e5ee:	2b01      	cmp	r3, #1
 100e5f0:	d965      	bls.n	100e6be <ll_create_connection+0x4b2>
	scan->own_addr_type = own_addr_type;
 100e5f2:	f897 3048 	ldrb.w	r3, [r7, #72]	; 0x48
 100e5f6:	9a02      	ldr	r2, [sp, #8]
 100e5f8:	f362 0342 	bfi	r3, r2, #1, #2
 100e5fc:	f887 3048 	strb.w	r3, [r7, #72]	; 0x48
	err = lll_clock_wait();
 100e600:	f001 fce8 	bl	100ffd4 <lll_clock_wait>
	if (err) {
 100e604:	2800      	cmp	r0, #0
 100e606:	d179      	bne.n	100e6fc <ll_create_connection+0x4f0>
	return ull_scan_enable(scan);
 100e608:	4638      	mov	r0, r7
 100e60a:	f7f2 fa21 	bl	1000a50 <ull_scan_enable>
}
 100e60e:	b00d      	add	sp, #52	; 0x34
 100e610:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				aa |= BIT(bit_idx);
 100e614:	fa09 f203 	lsl.w	r2, r9, r3
 100e618:	4315      	orrs	r5, r2
 100e61a:	4683      	mov	fp, r0
 100e61c:	46b2      	mov	sl, r6
				consecutive_bit = 1U;
 100e61e:	2201      	movs	r2, #1
			if (transitions != transitions_prev) {
 100e620:	4556      	cmp	r6, sl
 100e622:	f43f ae97 	beq.w	100e354 <ll_create_connection+0x148>
			if (bit_idx < 15) {
 100e626:	2b0e      	cmp	r3, #14
 100e628:	f63f ae75 	bhi.w	100e316 <ll_create_connection+0x10a>
				if (transitions_lsb16 !=
 100e62c:	4558      	cmp	r0, fp
 100e62e:	f47f ae76 	bne.w	100e31e <ll_create_connection+0x112>
 100e632:	46b2      	mov	sl, r6
					transitions_lsb16++;
 100e634:	f10b 0b01 	add.w	fp, fp, #1
 100e638:	4671      	mov	r1, lr
 100e63a:	fa5f fb8b 	uxtb.w	fp, fp
 100e63e:	e665      	b.n	100e30c <ll_create_connection+0x100>
		if ((consecutive_cnt > 6) ||
 100e640:	2a00      	cmp	r2, #0
 100e642:	f040 80d2 	bne.w	100e7ea <ll_create_connection+0x5de>
 100e646:	46b2      	mov	sl, r6
 100e648:	4683      	mov	fp, r0
					   (ones_count_lsb8 < 3)))) ||
 100e64a:	2906      	cmp	r1, #6
 100e64c:	d120      	bne.n	100e690 <ll_create_connection+0x484>
 100e64e:	2200      	movs	r2, #0
 100e650:	e65c      	b.n	100e30c <ll_create_connection+0x100>
		if ((consecutive_cnt > 6) ||
 100e652:	4683      	mov	fp, r0
			consecutive_cnt = 1U;
 100e654:	2101      	movs	r1, #1
		    (!consecutive_bit && (((bit_idx < 6) &&
 100e656:	2b05      	cmp	r3, #5
 100e658:	d8f7      	bhi.n	100e64a <ll_create_connection+0x43e>
 100e65a:	f1bc 0f00 	cmp.w	ip, #0
 100e65e:	d00a      	beq.n	100e676 <ll_create_connection+0x46a>
					   (ones_count_lsb8 < 1)) ||
 100e660:	2a04      	cmp	r2, #4
 100e662:	d8f2      	bhi.n	100e64a <ll_create_connection+0x43e>
					  ((bit_idx < 5) &&
 100e664:	f1bc 0f01 	cmp.w	ip, #1
 100e668:	d905      	bls.n	100e676 <ll_create_connection+0x46a>
					   (ones_count_lsb8 < 2)) ||
 100e66a:	2a03      	cmp	r2, #3
 100e66c:	d8ed      	bhi.n	100e64a <ll_create_connection+0x43e>
					  ((bit_idx < 4) &&
 100e66e:	f1bc 0f02 	cmp.w	ip, #2
 100e672:	f200 80c5 	bhi.w	100e800 <ll_create_connection+0x5f4>
				aa |= BIT(bit_idx);
 100e676:	fa09 f203 	lsl.w	r2, r9, r3
 100e67a:	4315      	orrs	r5, r2
				if (bit_idx < 8) {
 100e67c:	e09c      	b.n	100e7b8 <ll_create_connection+0x5ac>
				transitions_lsb16++;
 100e67e:	f100 0b01 	add.w	fp, r0, #1
		if ((bit_idx < 8) && consecutive_bit) {
 100e682:	2a07      	cmp	r2, #7
				transitions_lsb16++;
 100e684:	fa5f fb8b 	uxtb.w	fp, fp
		if ((bit_idx < 8) && consecutive_bit) {
 100e688:	d97e      	bls.n	100e788 <ll_create_connection+0x57c>
		if ((consecutive_cnt > 6) ||
 100e68a:	2900      	cmp	r1, #0
 100e68c:	d166      	bne.n	100e75c <ll_create_connection+0x550>
			consecutive_cnt = 1U;
 100e68e:	2101      	movs	r1, #1
 100e690:	2200      	movs	r2, #0
 100e692:	e635      	b.n	100e300 <ll_create_connection+0xf4>
				aa |= (BIT(bit_idx + 1) - 1);
 100e694:	3b01      	subs	r3, #1
 100e696:	431d      	orrs	r5, r3
 100e698:	e676      	b.n	100e388 <ll_create_connection+0x17c>
	if (!filter_policy && ull_filter_lll_rl_enabled()) {
 100e69a:	f001 f9c1 	bl	100fa20 <ull_filter_lll_rl_enabled>
 100e69e:	2800      	cmp	r0, #0
 100e6a0:	d0a3      	beq.n	100e5ea <ll_create_connection+0x3de>
		lll->rl_idx = ull_filter_rl_find(peer_addr_type, peer_addr,
 100e6a2:	9a03      	ldr	r2, [sp, #12]
 100e6a4:	9806      	ldr	r0, [sp, #24]
 100e6a6:	9916      	ldr	r1, [sp, #88]	; 0x58
 100e6a8:	f000 fd7a 	bl	100f1a0 <ull_filter_rl_find>
 100e6ac:	f887 0034 	strb.w	r0, [r7, #52]	; 0x34
 100e6b0:	e79b      	b.n	100e5ea <ll_create_connection+0x3de>
		conn_lll->link_tx_free = &conn_lll->link_tx;
 100e6b2:	f104 0070 	add.w	r0, r4, #112	; 0x70
 100e6b6:	67a0      	str	r0, [r4, #120]	; 0x78
 100e6b8:	e698      	b.n	100e3ec <ll_create_connection+0x1e0>
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
 100e6ba:	2007      	movs	r0, #7
 100e6bc:	e5c4      	b.n	100e248 <ll_create_connection+0x3c>
		ull_filter_rpa_update(false);
 100e6be:	2000      	movs	r0, #0
 100e6c0:	f000 fc48 	bl	100ef54 <ull_filter_rpa_update>
		lll->rpa_gen = 1;
 100e6c4:	f897 3033 	ldrb.w	r3, [r7, #51]	; 0x33
		own_addr_type &= 0x1;
 100e6c8:	9a02      	ldr	r2, [sp, #8]
		lll->rpa_gen = 1;
 100e6ca:	f043 0301 	orr.w	r3, r3, #1
		own_addr_type &= 0x1;
 100e6ce:	f002 0201 	and.w	r2, r2, #1
 100e6d2:	9202      	str	r2, [sp, #8]
		lll->rpa_gen = 1;
 100e6d4:	f887 3033 	strb.w	r3, [r7, #51]	; 0x33
 100e6d8:	e78b      	b.n	100e5f2 <ll_create_connection+0x3e6>
 100e6da:	bf00      	nop
 100e6dc:	8e89bed6 	.word	0x8e89bed6
 100e6e0:	0101889c 	.word	0x0101889c
 100e6e4:	01480148 	.word	0x01480148
 100e6e8:	01c9c37f 	.word	0x01c9c37f
 100e6ec:	026259ff 	.word	0x026259ff
 100e6f0:	aaaaaaab 	.word	0xaaaaaaab
 100e6f4:	000149ff 	.word	0x000149ff
 100e6f8:	f6ff0000 	.word	0xf6ff0000
	sys_put_le32(aa, access_addr);
}

static inline void conn_release(struct ll_scan_set *scan)
{
	struct lll_conn *lll = scan->lll.conn;
 100e6fc:	6a7c      	ldr	r4, [r7, #36]	; 0x24
	struct node_rx_pdu *cc;
	struct ll_conn *conn;
	memq_link_t *link;

	LL_ASSERT(!lll->link_tx_free);
 100e6fe:	6de3      	ldr	r3, [r4, #92]	; 0x5c
 100e700:	b123      	cbz	r3, 100e70c <ll_create_connection+0x500>
 100e702:	f44f 7159 	mov.w	r1, #868	; 0x364
 100e706:	484b      	ldr	r0, [pc, #300]	; (100e834 <ll_create_connection+0x628>)
 100e708:	f7f4 ff3e 	bl	1003588 <bt_ctlr_assert_handle>
	link = memq_deinit(&lll->memq_tx.head, &lll->memq_tx.tail);
 100e70c:	f104 0150 	add.w	r1, r4, #80	; 0x50
 100e710:	f104 004c 	add.w	r0, r4, #76	; 0x4c
 100e714:	f7f7 fade 	bl	1005cd4 <memq_deinit>
	LL_ASSERT(link);
 100e718:	4605      	mov	r5, r0
 100e71a:	b1a0      	cbz	r0, 100e746 <ll_create_connection+0x53a>
	lll->link_tx_free = link;

	conn = (void *)HDR_LLL2EVT(lll);
 100e71c:	6826      	ldr	r6, [r4, #0]
	lll->link_tx_free = link;
 100e71e:	65e5      	str	r5, [r4, #92]	; 0x5c

	cc = (void *)&conn->llcp_terminate.node_rx;
	link = cc->hdr.link;
 100e720:	f8d6 412c 	ldr.w	r4, [r6, #300]	; 0x12c
	LL_ASSERT(link);
 100e724:	b14c      	cbz	r4, 100e73a <ll_create_connection+0x52e>

	ll_rx_link_release(link);
 100e726:	4620      	mov	r0, r4
 100e728:	f7fb fc5e 	bl	1009fe8 <ll_rx_link_release>

	ll_conn_release(conn);
 100e72c:	4630      	mov	r0, r6
 100e72e:	f7fc ff01 	bl	100b534 <ll_conn_release>
	scan->lll.conn = NULL;
 100e732:	2300      	movs	r3, #0
		return BT_HCI_ERR_HW_FAILURE;
 100e734:	2003      	movs	r0, #3
	scan->lll.conn = NULL;
 100e736:	627b      	str	r3, [r7, #36]	; 0x24
}
 100e738:	e586      	b.n	100e248 <ll_create_connection+0x3c>
	LL_ASSERT(link);
 100e73a:	f240 316d 	movw	r1, #877	; 0x36d
 100e73e:	483d      	ldr	r0, [pc, #244]	; (100e834 <ll_create_connection+0x628>)
 100e740:	f7f4 ff22 	bl	1003588 <bt_ctlr_assert_handle>
 100e744:	e7ef      	b.n	100e726 <ll_create_connection+0x51a>
	LL_ASSERT(link);
 100e746:	f240 3166 	movw	r1, #870	; 0x366
 100e74a:	483a      	ldr	r0, [pc, #232]	; (100e834 <ll_create_connection+0x628>)
 100e74c:	f7f4 ff1c 	bl	1003588 <bt_ctlr_assert_handle>
 100e750:	e7e4      	b.n	100e71c <ll_create_connection+0x510>
		ll_rx_link_release(link);
 100e752:	9808      	ldr	r0, [sp, #32]
 100e754:	f7fb fc48 	bl	1009fe8 <ll_rx_link_release>
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
 100e758:	2007      	movs	r0, #7
 100e75a:	e575      	b.n	100e248 <ll_create_connection+0x3c>
		      ((bit_idx < 28) && (transitions < 2))))) {
 100e75c:	f1ba 0f01 	cmp.w	sl, #1
 100e760:	d003      	beq.n	100e76a <ll_create_connection+0x55e>
 100e762:	460a      	mov	r2, r1
 100e764:	e5d2      	b.n	100e30c <ll_create_connection+0x100>
		     (((bit_idx < 29) && (transitions < 1)) ||
 100e766:	4683      	mov	fp, r0
 100e768:	46b2      	mov	sl, r6
				aa &= ~BIT(bit_idx);
 100e76a:	fa09 f203 	lsl.w	r2, r9, r3
				if (bit_idx < 8) {
 100e76e:	2b07      	cmp	r3, #7
				aa &= ~BIT(bit_idx);
 100e770:	ea25 0502 	bic.w	r5, r5, r2
				consecutive_bit = 0U;
 100e774:	bf88      	it	hi
 100e776:	2200      	movhi	r2, #0
				if (bit_idx < 8) {
 100e778:	f63f af52 	bhi.w	100e620 <ll_create_connection+0x414>
					ones_count_lsb8--;
 100e77c:	f10c 3cff 	add.w	ip, ip, #4294967295
				consecutive_bit = 0U;
 100e780:	2200      	movs	r2, #0
					ones_count_lsb8--;
 100e782:	fa5f fc8c 	uxtb.w	ip, ip
 100e786:	e74b      	b.n	100e620 <ll_create_connection+0x414>
		if ((bit_idx < 8) && consecutive_bit) {
 100e788:	2900      	cmp	r1, #0
 100e78a:	f43f af63 	beq.w	100e654 <ll_create_connection+0x448>
			ones_count_lsb8++;
 100e78e:	f10c 0c01 	add.w	ip, ip, #1
 100e792:	460a      	mov	r2, r1
 100e794:	fa5f fc8c 	uxtb.w	ip, ip
		if ((consecutive_cnt > 6) ||
 100e798:	e5b5      	b.n	100e306 <ll_create_connection+0xfa>
		     (((bit_idx < 29) && (transitions < 1)) ||
 100e79a:	f1ba 0f00 	cmp.w	sl, #0
 100e79e:	f47f adb2 	bne.w	100e306 <ll_create_connection+0xfa>
			if (consecutive_bit) {
 100e7a2:	2a00      	cmp	r2, #0
 100e7a4:	d1e1      	bne.n	100e76a <ll_create_connection+0x55e>
				aa |= BIT(bit_idx);
 100e7a6:	fa09 f203 	lsl.w	r2, r9, r3
				if (bit_idx < 8) {
 100e7aa:	2b07      	cmp	r3, #7
				aa |= BIT(bit_idx);
 100e7ac:	ea45 0502 	orr.w	r5, r5, r2
				consecutive_bit = 1U;
 100e7b0:	bf88      	it	hi
 100e7b2:	2201      	movhi	r2, #1
				if (bit_idx < 8) {
 100e7b4:	f63f af34 	bhi.w	100e620 <ll_create_connection+0x414>
					ones_count_lsb8++;
 100e7b8:	f10c 0c01 	add.w	ip, ip, #1
				consecutive_bit = 1U;
 100e7bc:	2201      	movs	r2, #1
					ones_count_lsb8++;
 100e7be:	fa5f fc8c 	uxtb.w	ip, ip
 100e7c2:	e72d      	b.n	100e620 <ll_create_connection+0x414>
		      ((bit_idx < 28) && (transitions < 2))))) {
 100e7c4:	f1ba 0f01 	cmp.w	sl, #1
 100e7c8:	f63f ada0 	bhi.w	100e30c <ll_create_connection+0x100>
 100e7cc:	e7e9      	b.n	100e7a2 <ll_create_connection+0x596>
		if ((bit_idx < 8) && consecutive_bit) {
 100e7ce:	b1fa      	cbz	r2, 100e810 <ll_create_connection+0x604>
			ones_count_lsb8++;
 100e7d0:	f10c 0c01 	add.w	ip, ip, #1
		if ((consecutive_cnt > 6) ||
 100e7d4:	2906      	cmp	r1, #6
			ones_count_lsb8++;
 100e7d6:	fa5f fc8c 	uxtb.w	ip, ip
		if ((consecutive_cnt > 6) ||
 100e7da:	d90b      	bls.n	100e7f4 <ll_create_connection+0x5e8>
				aa &= ~BIT(bit_idx);
 100e7dc:	fa09 f203 	lsl.w	r2, r9, r3
 100e7e0:	46b2      	mov	sl, r6
 100e7e2:	4683      	mov	fp, r0
 100e7e4:	ea25 0502 	bic.w	r5, r5, r2
				if (bit_idx < 8) {
 100e7e8:	e7c8      	b.n	100e77c <ll_create_connection+0x570>
					   (ones_count_lsb8 < 3)))) ||
 100e7ea:	2906      	cmp	r1, #6
 100e7ec:	d116      	bne.n	100e81c <ll_create_connection+0x610>
 100e7ee:	4683      	mov	fp, r0
 100e7f0:	46b2      	mov	sl, r6
 100e7f2:	e58e      	b.n	100e312 <ll_create_connection+0x106>
 100e7f4:	d0fb      	beq.n	100e7ee <ll_create_connection+0x5e2>
		     (((bit_idx < 29) && (transitions < 1)) ||
 100e7f6:	2e00      	cmp	r6, #0
 100e7f8:	d0b5      	beq.n	100e766 <ll_create_connection+0x55a>
 100e7fa:	46b2      	mov	sl, r6
 100e7fc:	4683      	mov	fp, r0
 100e7fe:	e582      	b.n	100e306 <ll_create_connection+0xfa>
					   (ones_count_lsb8 < 3)))) ||
 100e800:	2906      	cmp	r1, #6
 100e802:	f43f af24 	beq.w	100e64e <ll_create_connection+0x442>
		     (((bit_idx < 29) && (transitions < 1)) ||
 100e806:	f1ba 0f00 	cmp.w	sl, #0
 100e80a:	d0cc      	beq.n	100e7a6 <ll_create_connection+0x59a>
 100e80c:	2200      	movs	r2, #0
 100e80e:	e57a      	b.n	100e306 <ll_create_connection+0xfa>
		if ((consecutive_cnt > 6) ||
 100e810:	2906      	cmp	r1, #6
 100e812:	d806      	bhi.n	100e822 <ll_create_connection+0x616>
 100e814:	4683      	mov	fp, r0
 100e816:	46b2      	mov	sl, r6
 100e818:	b2da      	uxtb	r2, r3
 100e81a:	e71c      	b.n	100e656 <ll_create_connection+0x44a>
					   (ones_count_lsb8 < 3)))) ||
 100e81c:	46b2      	mov	sl, r6
 100e81e:	4683      	mov	fp, r0
 100e820:	e56e      	b.n	100e300 <ll_create_connection+0xf4>
				aa |= BIT(bit_idx);
 100e822:	fa09 f203 	lsl.w	r2, r9, r3
 100e826:	4683      	mov	fp, r0
 100e828:	46b2      	mov	sl, r6
 100e82a:	4315      	orrs	r5, r2
				if (bit_idx < 8) {
 100e82c:	e7c4      	b.n	100e7b8 <ll_create_connection+0x5ac>
				consecutive_cnt = 1U;
 100e82e:	f04f 0e01 	mov.w	lr, #1
 100e832:	e6ff      	b.n	100e634 <ll_create_connection+0x428>
 100e834:	0101889c 	.word	0x0101889c

0100e838 <ll_connect_disable>:
{
 100e838:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100e83c:	4607      	mov	r7, r0
 100e83e:	b082      	sub	sp, #8
	scan = ull_scan_is_enabled_get(0);
 100e840:	2000      	movs	r0, #0
 100e842:	f7fc facb 	bl	100addc <ull_scan_is_enabled_get>
	if (!scan) {
 100e846:	b320      	cbz	r0, 100e892 <ll_connect_disable+0x5a>
	conn_lll = scan->lll.conn;
 100e848:	6a46      	ldr	r6, [r0, #36]	; 0x24
	if (!conn_lll) {
 100e84a:	4604      	mov	r4, r0
 100e84c:	b30e      	cbz	r6, 100e892 <ll_connect_disable+0x5a>
	status = ull_scan_disable(0, scan);
 100e84e:	4601      	mov	r1, r0
 100e850:	2000      	movs	r0, #0
 100e852:	f7fc f9f1 	bl	100ac38 <ull_scan_disable>
	if (!status) {
 100e856:	4605      	mov	r5, r0
 100e858:	b9b8      	cbnz	r0, 100e88a <ll_connect_disable+0x52>
		struct ll_conn *conn = (void *)HDR_LLL2EVT(conn_lll);
 100e85a:	6836      	ldr	r6, [r6, #0]
		link = cc->hdr.link;
 100e85c:	f8d6 312c 	ldr.w	r3, [r6, #300]	; 0x12c
		cc = (void *)&conn->llcp_terminate.node_rx;
 100e860:	f506 7896 	add.w	r8, r6, #300	; 0x12c
		LL_ASSERT(link);
 100e864:	b1d3      	cbz	r3, 100e89c <ll_connect_disable+0x64>
		ll_rx_link_release(link);
 100e866:	4618      	mov	r0, r3
 100e868:	f7fb fbbe 	bl	1009fe8 <ll_rx_link_release>
		cc->hdr.type = NODE_RX_TYPE_CONNECTION;
 100e86c:	2108      	movs	r1, #8
		cc->hdr.handle = 0xffff;
 100e86e:	f64f 72ff 	movw	r2, #65535	; 0xffff
		*((u8_t *)cc->pdu) = BT_HCI_ERR_UNKNOWN_CONN_ID;
 100e872:	2302      	movs	r3, #2
		ftr->param = &scan->lll;
 100e874:	341c      	adds	r4, #28
 100e876:	f8c6 4134 	str.w	r4, [r6, #308]	; 0x134
		cc->hdr.type = NODE_RX_TYPE_CONNECTION;
 100e87a:	f886 1130 	strb.w	r1, [r6, #304]	; 0x130
		cc->hdr.handle = 0xffff;
 100e87e:	f8a6 2132 	strh.w	r2, [r6, #306]	; 0x132
		*((u8_t *)cc->pdu) = BT_HCI_ERR_UNKNOWN_CONN_ID;
 100e882:	f886 314c 	strb.w	r3, [r6, #332]	; 0x14c
		*rx = cc;
 100e886:	f8c7 8000 	str.w	r8, [r7]
}
 100e88a:	4628      	mov	r0, r5
 100e88c:	b002      	add	sp, #8
 100e88e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100e892:	250c      	movs	r5, #12
}
 100e894:	4628      	mov	r0, r5
 100e896:	b002      	add	sp, #8
 100e898:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		LL_ASSERT(link);
 100e89c:	f240 1139 	movw	r1, #313	; 0x139
 100e8a0:	4802      	ldr	r0, [pc, #8]	; (100e8ac <ll_connect_disable+0x74>)
 100e8a2:	9301      	str	r3, [sp, #4]
 100e8a4:	f7f4 fe70 	bl	1003588 <bt_ctlr_assert_handle>
 100e8a8:	9b01      	ldr	r3, [sp, #4]
 100e8aa:	e7dc      	b.n	100e866 <ll_connect_disable+0x2e>
 100e8ac:	0101889c 	.word	0x0101889c

0100e8b0 <ll_chm_update>:
{
 100e8b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100e8b4:	4607      	mov	r7, r0
	while (handle--) {
 100e8b6:	250f      	movs	r5, #15
		conn->llcp_type = LLCP_CHAN_MAP;
 100e8b8:	f04f 0802 	mov.w	r8, #2
	ull_conn_chan_map_set(chm);
 100e8bc:	f7fd f9aa 	bl	100bc14 <ull_conn_chan_map_set>
	while (handle--) {
 100e8c0:	f64f 76ff 	movw	r6, #65535	; 0xffff
		conn = ll_connected_get(handle);
 100e8c4:	4628      	mov	r0, r5
 100e8c6:	f7fc fe4b 	bl	100b560 <ll_connected_get>
		if (!conn || conn->lll.role) {
 100e8ca:	4604      	mov	r4, r0
 100e8cc:	b1c8      	cbz	r0, 100e902 <ll_chm_update+0x52>
 100e8ce:	f990 303d 	ldrsb.w	r3, [r0, #61]	; 0x3d
 100e8d2:	2b00      	cmp	r3, #0
 100e8d4:	db15      	blt.n	100e902 <ll_chm_update+0x52>
		ret = ull_conn_llcp_req(conn);
 100e8d6:	f7ff fb6d 	bl	100dfb4 <ull_conn_llcp_req>
		if (ret) {
 100e8da:	b9b8      	cbnz	r0, 100e90c <ll_chm_update+0x5c>
		memcpy(conn->llcp.chan_map.chm, chm,
 100e8dc:	2205      	movs	r2, #5
 100e8de:	4639      	mov	r1, r7
 100e8e0:	f104 00ed 	add.w	r0, r4, #237	; 0xed
 100e8e4:	f007 ffe8 	bl	10168b8 <memcpy>
		conn->llcp.chan_map.initiate = 1U;
 100e8e8:	f894 20ec 	ldrb.w	r2, [r4, #236]	; 0xec
		conn->llcp_req++;
 100e8ec:	f894 30e8 	ldrb.w	r3, [r4, #232]	; 0xe8
		conn->llcp.chan_map.initiate = 1U;
 100e8f0:	f042 0201 	orr.w	r2, r2, #1
		conn->llcp_req++;
 100e8f4:	3301      	adds	r3, #1
		conn->llcp_type = LLCP_CHAN_MAP;
 100e8f6:	f884 80ea 	strb.w	r8, [r4, #234]	; 0xea
		conn->llcp.chan_map.initiate = 1U;
 100e8fa:	f884 20ec 	strb.w	r2, [r4, #236]	; 0xec
		conn->llcp_req++;
 100e8fe:	f884 30e8 	strb.w	r3, [r4, #232]	; 0xe8
	while (handle--) {
 100e902:	3d01      	subs	r5, #1
 100e904:	b2ad      	uxth	r5, r5
 100e906:	42b5      	cmp	r5, r6
 100e908:	d1dc      	bne.n	100e8c4 <ll_chm_update+0x14>
	return 0;
 100e90a:	2000      	movs	r0, #0
}
 100e90c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

0100e910 <ll_enc_req_send>:
{
 100e910:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 100e914:	4688      	mov	r8, r1
 100e916:	4616      	mov	r6, r2
 100e918:	4699      	mov	r9, r3
 100e91a:	4607      	mov	r7, r0
	conn = ll_connected_get(handle);
 100e91c:	f7fc fe20 	bl	100b560 <ll_connected_get>
	if (!conn) {
 100e920:	2800      	cmp	r0, #0
 100e922:	d062      	beq.n	100e9ea <ll_enc_req_send+0xda>
	if ((conn->llcp_enc.req != conn->llcp_enc.ack) ||
 100e924:	f890 2150 	ldrb.w	r2, [r0, #336]	; 0x150
 100e928:	f890 3151 	ldrb.w	r3, [r0, #337]	; 0x151
 100e92c:	4604      	mov	r4, r0
 100e92e:	429a      	cmp	r2, r3
 100e930:	d13d      	bne.n	100e9ae <ll_enc_req_send+0x9e>
 100e932:	f890 20e8 	ldrb.w	r2, [r0, #232]	; 0xe8
 100e936:	f890 30e9 	ldrb.w	r3, [r0, #233]	; 0xe9
 100e93a:	429a      	cmp	r2, r3
 100e93c:	d003      	beq.n	100e946 <ll_enc_req_send+0x36>
	    ((conn->llcp_req != conn->llcp_ack) &&
 100e93e:	f890 30ea 	ldrb.w	r3, [r0, #234]	; 0xea
 100e942:	2b03      	cmp	r3, #3
 100e944:	d033      	beq.n	100e9ae <ll_enc_req_send+0x9e>
	tx = ll_tx_mem_acquire();
 100e946:	f7fc fe1f 	bl	100b588 <ll_tx_mem_acquire>
	if (tx) {
 100e94a:	4605      	mov	r5, r0
 100e94c:	b378      	cbz	r0, 100e9ae <ll_enc_req_send+0x9e>
		memcpy(&conn->llcp_enc.ltk[0], ltk, sizeof(conn->llcp_enc.ltk));
 100e94e:	4649      	mov	r1, r9
 100e950:	2210      	movs	r2, #16
 100e952:	f204 105d 	addw	r0, r4, #349	; 0x15d
 100e956:	f007 ffaf 	bl	10168b8 <memcpy>
		if (!conn->lll.enc_rx && !conn->lll.enc_tx) {
 100e95a:	f894 307e 	ldrb.w	r3, [r4, #126]	; 0x7e
 100e95e:	f013 0318 	ands.w	r3, r3, #24
 100e962:	d027      	beq.n	100e9b4 <ll_enc_req_send+0xa4>
		} else if (conn->lll.enc_rx && conn->lll.enc_tx) {
 100e964:	2b18      	cmp	r3, #24
 100e966:	d11f      	bne.n	100e9a8 <ll_enc_req_send+0x98>
			memcpy(&conn->llcp_enc.rand[0], rand,
 100e968:	4641      	mov	r1, r8
 100e96a:	2208      	movs	r2, #8
 100e96c:	f204 1055 	addw	r0, r4, #341	; 0x155
 100e970:	f007 ffa2 	bl	10168b8 <memcpy>
			pdu_data_tx->len = offsetof(struct pdu_data_llctrl,
 100e974:	2101      	movs	r1, #1
			pdu_data_tx->llctrl.opcode =
 100e976:	220a      	movs	r2, #10
			conn->llcp_enc.ediv[0] = ediv[0];
 100e978:	7833      	ldrb	r3, [r6, #0]
 100e97a:	f884 3153 	strb.w	r3, [r4, #339]	; 0x153
			conn->llcp_enc.ediv[1] = ediv[1];
 100e97e:	7873      	ldrb	r3, [r6, #1]
 100e980:	f884 3154 	strb.w	r3, [r4, #340]	; 0x154
			pdu_data_tx->ll_id = PDU_DATA_LLID_CTRL;
 100e984:	792b      	ldrb	r3, [r5, #4]
			pdu_data_tx->len = offsetof(struct pdu_data_llctrl,
 100e986:	7169      	strb	r1, [r5, #5]
			pdu_data_tx->ll_id = PDU_DATA_LLID_CTRL;
 100e988:	f043 0303 	orr.w	r3, r3, #3
 100e98c:	712b      	strb	r3, [r5, #4]
			pdu_data_tx->llctrl.opcode =
 100e98e:	71ea      	strb	r2, [r5, #7]
		if (ll_tx_mem_enqueue(handle, tx)) {
 100e990:	4638      	mov	r0, r7
 100e992:	4629      	mov	r1, r5
 100e994:	f7fc fe04 	bl	100b5a0 <ll_tx_mem_enqueue>
 100e998:	b930      	cbnz	r0, 100e9a8 <ll_enc_req_send+0x98>
		conn->llcp_enc.req++;
 100e99a:	f894 3150 	ldrb.w	r3, [r4, #336]	; 0x150
 100e99e:	3301      	adds	r3, #1
 100e9a0:	f884 3150 	strb.w	r3, [r4, #336]	; 0x150
}
 100e9a4:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			ll_tx_mem_release(tx);
 100e9a8:	4628      	mov	r0, r5
 100e9aa:	f7fc fdf3 	bl	100b594 <ll_tx_mem_release>
			return BT_HCI_ERR_CMD_DISALLOWED;
 100e9ae:	200c      	movs	r0, #12
}
 100e9b0:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			pdu_data_tx->llctrl.opcode =
 100e9b4:	2203      	movs	r2, #3
			pdu_data_tx->ll_id = PDU_DATA_LLID_CTRL;
 100e9b6:	792b      	ldrb	r3, [r5, #4]
			pdu_data_tx->llctrl.opcode =
 100e9b8:	71ea      	strb	r2, [r5, #7]
			pdu_data_tx->ll_id = PDU_DATA_LLID_CTRL;
 100e9ba:	4313      	orrs	r3, r2
			pdu_data_tx->len =
 100e9bc:	2017      	movs	r0, #23
			memcpy(enc_req->rand, rand, sizeof(enc_req->rand));
 100e9be:	2208      	movs	r2, #8
 100e9c0:	4641      	mov	r1, r8
			pdu_data_tx->ll_id = PDU_DATA_LLID_CTRL;
 100e9c2:	712b      	strb	r3, [r5, #4]
			pdu_data_tx->len =
 100e9c4:	7168      	strb	r0, [r5, #5]
			memcpy(enc_req->rand, rand, sizeof(enc_req->rand));
 100e9c6:	18a8      	adds	r0, r5, r2
 100e9c8:	f007 ff76 	bl	10168b8 <memcpy>
			enc_req->ediv[0] = ediv[0];
 100e9cc:	7833      	ldrb	r3, [r6, #0]
			lll_trng_get(enc_req->skdm, sizeof(enc_req->skdm));
 100e9ce:	2108      	movs	r1, #8
			enc_req->ediv[0] = ediv[0];
 100e9d0:	742b      	strb	r3, [r5, #16]
			enc_req->ediv[1] = ediv[1];
 100e9d2:	7873      	ldrb	r3, [r6, #1]
			lll_trng_get(enc_req->skdm, sizeof(enc_req->skdm));
 100e9d4:	f105 0012 	add.w	r0, r5, #18
			enc_req->ediv[1] = ediv[1];
 100e9d8:	746b      	strb	r3, [r5, #17]
			lll_trng_get(enc_req->skdm, sizeof(enc_req->skdm));
 100e9da:	f001 f9bb 	bl	100fd54 <lll_trng_get>
			lll_trng_get(enc_req->ivm, sizeof(enc_req->ivm));
 100e9de:	2104      	movs	r1, #4
 100e9e0:	f105 001a 	add.w	r0, r5, #26
 100e9e4:	f001 f9b6 	bl	100fd54 <lll_trng_get>
 100e9e8:	e7d2      	b.n	100e990 <ll_enc_req_send+0x80>
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100e9ea:	2002      	movs	r0, #2
}
 100e9ec:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0100e9f0 <ull_sched_after_mstr_slot_get>:

void ull_sched_after_mstr_slot_get(u8_t user_id, u32_t ticks_slot_abs,
				   u32_t *ticks_anchor, u32_t *us_offset)
{
	/* TODO: */
}
 100e9f0:	4770      	bx	lr
 100e9f2:	bf00      	nop

0100e9f4 <ull_sched_mfy_after_mstr_offset_get>:
void ull_sched_mfy_after_mstr_offset_get(void *param)
{
	struct ll_scan_set *scan = param;

	/* TODO: */
	scan->lll.conn_win_offset_us = 0;
 100e9f4:	2300      	movs	r3, #0
 100e9f6:	62c3      	str	r3, [r0, #44]	; 0x2c
}
 100e9f8:	4770      	bx	lr
 100e9fa:	bf00      	nop

0100e9fc <ull_sched_mfy_free_win_offset_calc>:

void ull_sched_mfy_free_win_offset_calc(void *param)
{
	/* TODO: */
}
 100e9fc:	4770      	bx	lr
 100e9fe:	bf00      	nop

0100ea00 <ull_sched_mfy_win_offset_use>:
 100ea00:	4770      	bx	lr
 100ea02:	bf00      	nop

0100ea04 <ull_sched_mfy_win_offset_select>:
 100ea04:	4770      	bx	lr
 100ea06:	bf00      	nop

0100ea08 <wl_find>:
		wl[i].taken = 0U;
	}
}

static u8_t wl_find(u8_t addr_type, u8_t *addr, u8_t *free)
{
 100ea08:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 100ea0c:	4688      	mov	r8, r1
	int i;

	if (free) {
 100ea0e:	4615      	mov	r5, r2
 100ea10:	b10a      	cbz	r2, 100ea16 <wl_find+0xe>
		*free = FILTER_IDX_NONE;
 100ea12:	23ff      	movs	r3, #255	; 0xff
 100ea14:	7013      	strb	r3, [r2, #0]
 100ea16:	4e17      	ldr	r6, [pc, #92]	; (100ea74 <wl_find+0x6c>)
{
 100ea18:	2400      	movs	r4, #0
	}

	for (i = 0; i < WL_SIZE; i++) {
		if (LIST_MATCH(wl, i, addr_type, addr)) {
 100ea1a:	f000 0701 	and.w	r7, r0, #1
 100ea1e:	f106 0902 	add.w	r9, r6, #2
 100ea22:	e004      	b.n	100ea2e <wl_find+0x26>
 100ea24:	42ba      	cmp	r2, r7
 100ea26:	d014      	beq.n	100ea52 <wl_find+0x4a>
	for (i = 0; i < WL_SIZE; i++) {
 100ea28:	3401      	adds	r4, #1
 100ea2a:	2c08      	cmp	r4, #8
 100ea2c:	d00e      	beq.n	100ea4c <wl_find+0x44>
		if (LIST_MATCH(wl, i, addr_type, addr)) {
 100ea2e:	f816 3034 	ldrb.w	r3, [r6, r4, lsl #3]
 100ea32:	07d9      	lsls	r1, r3, #31
 100ea34:	f3c3 0240 	ubfx	r2, r3, #1, #1
 100ea38:	d4f4      	bmi.n	100ea24 <wl_find+0x1c>
			return i;
		} else if (free && !wl[i].taken && (*free == FILTER_IDX_NONE)) {
 100ea3a:	2d00      	cmp	r5, #0
 100ea3c:	d0f4      	beq.n	100ea28 <wl_find+0x20>
 100ea3e:	782b      	ldrb	r3, [r5, #0]
 100ea40:	2bff      	cmp	r3, #255	; 0xff
			*free = i;
 100ea42:	bf08      	it	eq
 100ea44:	702c      	strbeq	r4, [r5, #0]
	for (i = 0; i < WL_SIZE; i++) {
 100ea46:	3401      	adds	r4, #1
 100ea48:	2c08      	cmp	r4, #8
 100ea4a:	d1f0      	bne.n	100ea2e <wl_find+0x26>
		}
	}

	return FILTER_IDX_NONE;
 100ea4c:	20ff      	movs	r0, #255	; 0xff
}
 100ea4e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		if (LIST_MATCH(wl, i, addr_type, addr)) {
 100ea52:	2206      	movs	r2, #6
 100ea54:	4641      	mov	r1, r8
 100ea56:	eb09 00c4 	add.w	r0, r9, r4, lsl #3
 100ea5a:	f007 ff1d 	bl	1016898 <memcmp>
 100ea5e:	b130      	cbz	r0, 100ea6e <wl_find+0x66>
		} else if (free && !wl[i].taken && (*free == FILTER_IDX_NONE)) {
 100ea60:	2d00      	cmp	r5, #0
 100ea62:	d0e1      	beq.n	100ea28 <wl_find+0x20>
 100ea64:	f816 3034 	ldrb.w	r3, [r6, r4, lsl #3]
 100ea68:	07db      	lsls	r3, r3, #31
 100ea6a:	d4dd      	bmi.n	100ea28 <wl_find+0x20>
 100ea6c:	e7e7      	b.n	100ea3e <wl_find+0x36>
			return i;
 100ea6e:	b2e0      	uxtb	r0, r4
 100ea70:	e7ed      	b.n	100ea4e <wl_find+0x46>
 100ea72:	bf00      	nop
 100ea74:	21003c3c 	.word	0x21003c3c

0100ea78 <wl_update>:

	return BT_HCI_ERR_UNKNOWN_CONN_ID;
}

static void wl_update(void)
{
 100ea78:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 100ea7c:	2400      	movs	r4, #0
 100ea7e:	4d1c      	ldr	r5, [pc, #112]	; (100eaf0 <wl_update+0x78>)
 100ea80:	f8df a074 	ldr.w	sl, [pc, #116]	; 100eaf8 <wl_update+0x80>
			continue;
		}

		j = wl[i].rl_idx;

		if (!rl_enable || j >= ARRAY_SIZE(rl) || !rl[j].pirk ||
 100ea84:	4f1b      	ldr	r7, [pc, #108]	; (100eaf4 <wl_update+0x7c>)
 100ea86:	f8df 8074 	ldr.w	r8, [pc, #116]	; 100eafc <wl_update+0x84>
#endif /* !CONFIG_BT_CTLR_PRIVACY */

static void filter_insert(struct lll_filter *filter, int index, u8_t addr_type,
			   u8_t *bdaddr)
{
	filter->enable_bitmask |= BIT(index);
 100ea8a:	1eae      	subs	r6, r5, #2
 100ea8c:	f1aa 0902 	sub.w	r9, sl, #2
		if (!wl[i].taken) {
 100ea90:	f819 3034 	ldrb.w	r3, [r9, r4, lsl #3]
 100ea94:	07d9      	lsls	r1, r3, #31
 100ea96:	d522      	bpl.n	100eade <wl_update+0x66>
		if (!rl_enable || j >= ARRAY_SIZE(rl) || !rl[j].pirk ||
 100ea98:	783b      	ldrb	r3, [r7, #0]
 100ea9a:	b15b      	cbz	r3, 100eab4 <wl_update+0x3c>
		j = wl[i].rl_idx;
 100ea9c:	f81a 3c01 	ldrb.w	r3, [sl, #-1]
		if (!rl_enable || j >= ARRAY_SIZE(rl) || !rl[j].pirk ||
 100eaa0:	2b07      	cmp	r3, #7
 100eaa2:	eb03 0283 	add.w	r2, r3, r3, lsl #2
 100eaa6:	d805      	bhi.n	100eab4 <wl_update+0x3c>
 100eaa8:	f818 3032 	ldrb.w	r3, [r8, r2, lsl #3]
 100eaac:	075a      	lsls	r2, r3, #29
 100eaae:	d501      	bpl.n	100eab4 <wl_update+0x3c>
 100eab0:	06db      	lsls	r3, r3, #27
 100eab2:	d514      	bpl.n	100eade <wl_update+0x66>
	filter->enable_bitmask |= BIT(index);
 100eab4:	2101      	movs	r1, #1
			filter_insert(&wl_filter, i, wl[i].id_addr_type,
 100eab6:	f819 3034 	ldrb.w	r3, [r9, r4, lsl #3]
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
 100eaba:	7872      	ldrb	r2, [r6, #1]
	filter->enable_bitmask |= BIT(index);
 100eabc:	f896 c000 	ldrb.w	ip, [r6]
			filter_insert(&wl_filter, i, wl[i].id_addr_type,
 100eac0:	f3c3 0340 	ubfx	r3, r3, #1, #1
	filter->enable_bitmask |= BIT(index);
 100eac4:	40a1      	lsls	r1, r4
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
 100eac6:	40a3      	lsls	r3, r4
 100eac8:	4313      	orrs	r3, r2
	filter->enable_bitmask |= BIT(index);
 100eaca:	ea4c 0c01 	orr.w	ip, ip, r1
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
 100eace:	2206      	movs	r2, #6
 100ead0:	4651      	mov	r1, sl
 100ead2:	4628      	mov	r0, r5
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
 100ead4:	7073      	strb	r3, [r6, #1]
	filter->enable_bitmask |= BIT(index);
 100ead6:	f886 c000 	strb.w	ip, [r6]
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
 100eada:	f007 feed 	bl	10168b8 <memcpy>
	for (i = 0U; i < WL_SIZE; i++) {
 100eade:	3401      	adds	r4, #1
 100eae0:	2c08      	cmp	r4, #8
 100eae2:	f105 0506 	add.w	r5, r5, #6
 100eae6:	f10a 0a08 	add.w	sl, sl, #8
 100eaea:	d1d1      	bne.n	100ea90 <wl_update+0x18>
}
 100eaec:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 100eaf0:	21003c7e 	.word	0x21003c7e
 100eaf4:	210066f3 	.word	0x210066f3
 100eaf8:	21003c3e 	.word	0x21003c3e
 100eafc:	21003aa4 	.word	0x21003aa4

0100eb00 <rl_update>:
{
 100eb00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100eb04:	f8df 8060 	ldr.w	r8, [pc, #96]	; 100eb68 <rl_update+0x68>
	filter->enable_bitmask |= BIT(index);
 100eb08:	4d16      	ldr	r5, [pc, #88]	; (100eb64 <rl_update+0x64>)
{
 100eb0a:	2400      	movs	r4, #0
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
 100eb0c:	f108 0701 	add.w	r7, r8, #1
 100eb10:	1cae      	adds	r6, r5, #2
 100eb12:	e002      	b.n	100eb1a <rl_update+0x1a>
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
 100eb14:	3401      	adds	r4, #1
 100eb16:	2c08      	cmp	r4, #8
 100eb18:	d021      	beq.n	100eb5e <rl_update+0x5e>
		if (rl[i].taken) {
 100eb1a:	eb04 0184 	add.w	r1, r4, r4, lsl #2
 100eb1e:	f818 3031 	ldrb.w	r3, [r8, r1, lsl #3]
 100eb22:	00c9      	lsls	r1, r1, #3
 100eb24:	07da      	lsls	r2, r3, #31
 100eb26:	d5f5      	bpl.n	100eb14 <rl_update+0x14>
	filter->enable_bitmask |= BIT(index);
 100eb28:	f04f 0e01 	mov.w	lr, #1
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
 100eb2c:	786a      	ldrb	r2, [r5, #1]
	filter->enable_bitmask |= BIT(index);
 100eb2e:	f895 c000 	ldrb.w	ip, [r5]
			filter_insert(&rl_filter, i, rl[i].id_addr_type,
 100eb32:	f3c3 1380 	ubfx	r3, r3, #6, #1
	filter->enable_bitmask |= BIT(index);
 100eb36:	fa0e fe04 	lsl.w	lr, lr, r4
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
 100eb3a:	40a3      	lsls	r3, r4
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
 100eb3c:	eb04 0044 	add.w	r0, r4, r4, lsl #1
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
 100eb40:	4313      	orrs	r3, r2
	filter->enable_bitmask |= BIT(index);
 100eb42:	ea4c 0c0e 	orr.w	ip, ip, lr
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
 100eb46:	2206      	movs	r2, #6
 100eb48:	4439      	add	r1, r7
 100eb4a:	eb06 0040 	add.w	r0, r6, r0, lsl #1
 100eb4e:	3401      	adds	r4, #1
	filter->addr_type_bitmask |= ((addr_type & 0x01) << index);
 100eb50:	706b      	strb	r3, [r5, #1]
	filter->enable_bitmask |= BIT(index);
 100eb52:	f885 c000 	strb.w	ip, [r5]
	memcpy(&filter->bdaddr[index][0], bdaddr, BDADDR_SIZE);
 100eb56:	f007 feaf 	bl	10168b8 <memcpy>
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
 100eb5a:	2c08      	cmp	r4, #8
 100eb5c:	d1dd      	bne.n	100eb1a <rl_update+0x1a>
}
 100eb5e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 100eb62:	bf00      	nop
 100eb64:	21003be4 	.word	0x21003be4
 100eb68:	21003aa4 	.word	0x21003aa4

0100eb6c <rl_access_check.part.0>:
static int rl_access_check(bool check_ar)
 100eb6c:	b508      	push	{r3, lr}
		(IS_ENABLED(CONFIG_BT_OBSERVER) && ull_scan_is_enabled(0)))
 100eb6e:	2000      	movs	r0, #0
 100eb70:	f7fc f950 	bl	100ae14 <ull_scan_is_enabled>
}
 100eb74:	fab0 f080 	clz	r0, r0
 100eb78:	0940      	lsrs	r0, r0, #5
 100eb7a:	bd08      	pop	{r3, pc}

0100eb7c <ll_wl_size_get>:
}
 100eb7c:	2008      	movs	r0, #8
 100eb7e:	4770      	bx	lr

0100eb80 <ll_wl_clear>:
{
 100eb80:	b510      	push	{r4, lr}
	if (ull_adv_filter_pol_get(0)) {
 100eb82:	2000      	movs	r0, #0
 100eb84:	f7fc f804 	bl	100ab90 <ull_adv_filter_pol_get>
 100eb88:	bb08      	cbnz	r0, 100ebce <ll_wl_clear+0x4e>
	if (ull_scan_filter_pol_get(0) & 0x1) {
 100eb8a:	f7fc f95b 	bl	100ae44 <ull_scan_filter_pol_get>
 100eb8e:	f010 0001 	ands.w	r0, r0, #1
 100eb92:	d11c      	bne.n	100ebce <ll_wl_clear+0x4e>
 100eb94:	4a0f      	ldr	r2, [pc, #60]	; (100ebd4 <ll_wl_clear+0x54>)
			rl[j].wl = 0U;
 100eb96:	4c10      	ldr	r4, [pc, #64]	; (100ebd8 <ll_wl_clear+0x58>)
		u8_t j = wl[i].rl_idx;
 100eb98:	eb02 03c0 	add.w	r3, r2, r0, lsl #3
 100eb9c:	785b      	ldrb	r3, [r3, #1]
		if (j < ARRAY_SIZE(rl)) {
 100eb9e:	2b07      	cmp	r3, #7
 100eba0:	d807      	bhi.n	100ebb2 <ll_wl_clear+0x32>
			rl[j].wl = 0U;
 100eba2:	eb03 0383 	add.w	r3, r3, r3, lsl #2
 100eba6:	f814 1033 	ldrb.w	r1, [r4, r3, lsl #3]
 100ebaa:	f36f 1145 	bfc	r1, #5, #1
 100ebae:	f804 1033 	strb.w	r1, [r4, r3, lsl #3]
		wl[i].taken = 0U;
 100ebb2:	f812 3030 	ldrb.w	r3, [r2, r0, lsl #3]
 100ebb6:	f36f 0300 	bfc	r3, #0, #1
 100ebba:	f802 3030 	strb.w	r3, [r2, r0, lsl #3]
	for (int i = 0; i < WL_SIZE; i++) {
 100ebbe:	3001      	adds	r0, #1
 100ebc0:	2808      	cmp	r0, #8
 100ebc2:	d1e9      	bne.n	100eb98 <ll_wl_clear+0x18>
	wl_anon = 0U;
 100ebc4:	2300      	movs	r3, #0
 100ebc6:	4a05      	ldr	r2, [pc, #20]	; (100ebdc <ll_wl_clear+0x5c>)
	return 0;
 100ebc8:	4618      	mov	r0, r3
	wl_anon = 0U;
 100ebca:	7013      	strb	r3, [r2, #0]
}
 100ebcc:	bd10      	pop	{r4, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100ebce:	200c      	movs	r0, #12
}
 100ebd0:	bd10      	pop	{r4, pc}
 100ebd2:	bf00      	nop
 100ebd4:	21003c3c 	.word	0x21003c3c
 100ebd8:	21003aa4 	.word	0x21003aa4
 100ebdc:	210066f4 	.word	0x210066f4

0100ebe0 <ll_wl_remove>:
{
 100ebe0:	b538      	push	{r3, r4, r5, lr}
 100ebe2:	4604      	mov	r4, r0
	if (ull_adv_filter_pol_get(0)) {
 100ebe4:	2000      	movs	r0, #0
 100ebe6:	f7fb ffd3 	bl	100ab90 <ull_adv_filter_pol_get>
 100ebea:	b980      	cbnz	r0, 100ec0e <ll_wl_remove+0x2e>
	if (ull_scan_filter_pol_get(0) & 0x1) {
 100ebec:	f7fc f92a 	bl	100ae44 <ull_scan_filter_pol_get>
 100ebf0:	f010 0501 	ands.w	r5, r0, #1
 100ebf4:	d10b      	bne.n	100ec0e <ll_wl_remove+0x2e>
	if (addr->type == ADDR_TYPE_ANON) {
 100ebf6:	7820      	ldrb	r0, [r4, #0]
 100ebf8:	28ff      	cmp	r0, #255	; 0xff
 100ebfa:	d00a      	beq.n	100ec12 <ll_wl_remove+0x32>
	u8_t i = wl_find(id_addr->type, id_addr->a.val, NULL);
 100ebfc:	462a      	mov	r2, r5
 100ebfe:	1c61      	adds	r1, r4, #1
 100ec00:	f7ff ff02 	bl	100ea08 <wl_find>
	if (i < ARRAY_SIZE(wl)) {
 100ec04:	2807      	cmp	r0, #7
	u8_t i = wl_find(id_addr->type, id_addr->a.val, NULL);
 100ec06:	4603      	mov	r3, r0
	if (i < ARRAY_SIZE(wl)) {
 100ec08:	d907      	bls.n	100ec1a <ll_wl_remove+0x3a>
 100ec0a:	2002      	movs	r0, #2
}
 100ec0c:	bd38      	pop	{r3, r4, r5, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100ec0e:	200c      	movs	r0, #12
}
 100ec10:	bd38      	pop	{r3, r4, r5, pc}
		wl_anon = 0U;
 100ec12:	4b0d      	ldr	r3, [pc, #52]	; (100ec48 <ll_wl_remove+0x68>)
		return 0;
 100ec14:	4628      	mov	r0, r5
		wl_anon = 0U;
 100ec16:	701d      	strb	r5, [r3, #0]
}
 100ec18:	bd38      	pop	{r3, r4, r5, pc}
		u8_t j = wl[i].rl_idx;
 100ec1a:	490c      	ldr	r1, [pc, #48]	; (100ec4c <ll_wl_remove+0x6c>)
 100ec1c:	eb01 02c0 	add.w	r2, r1, r0, lsl #3
 100ec20:	7852      	ldrb	r2, [r2, #1]
		if (j < ARRAY_SIZE(rl)) {
 100ec22:	2a07      	cmp	r2, #7
 100ec24:	d808      	bhi.n	100ec38 <ll_wl_remove+0x58>
			rl[j].wl = 0U;
 100ec26:	480a      	ldr	r0, [pc, #40]	; (100ec50 <ll_wl_remove+0x70>)
 100ec28:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 100ec2c:	f810 4032 	ldrb.w	r4, [r0, r2, lsl #3]
 100ec30:	f365 1445 	bfi	r4, r5, #5, #1
 100ec34:	f800 4032 	strb.w	r4, [r0, r2, lsl #3]
		wl[i].taken = 0U;
 100ec38:	f811 2033 	ldrb.w	r2, [r1, r3, lsl #3]
		return 0;
 100ec3c:	2000      	movs	r0, #0
		wl[i].taken = 0U;
 100ec3e:	f36f 0200 	bfc	r2, #0, #1
 100ec42:	f801 2033 	strb.w	r2, [r1, r3, lsl #3]
}
 100ec46:	bd38      	pop	{r3, r4, r5, pc}
 100ec48:	210066f4 	.word	0x210066f4
 100ec4c:	21003c3c 	.word	0x21003c3c
 100ec50:	21003aa4 	.word	0x21003aa4

0100ec54 <ll_rl_id_addr_get>:
	LL_ASSERT(rl_idx < CONFIG_BT_CTLR_RL_SIZE);
 100ec54:	2807      	cmp	r0, #7
{
 100ec56:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 100ec5a:	4604      	mov	r4, r0
 100ec5c:	460f      	mov	r7, r1
 100ec5e:	4690      	mov	r8, r2
	LL_ASSERT(rl_idx < CONFIG_BT_CTLR_RL_SIZE);
 100ec60:	d816      	bhi.n	100ec90 <ll_rl_id_addr_get+0x3c>
	LL_ASSERT(rl[rl_idx].taken);
 100ec62:	4d10      	ldr	r5, [pc, #64]	; (100eca4 <ll_rl_id_addr_get+0x50>)
 100ec64:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 100ec68:	f815 3033 	ldrb.w	r3, [r5, r3, lsl #3]
 100ec6c:	00a6      	lsls	r6, r4, #2
 100ec6e:	07db      	lsls	r3, r3, #31
 100ec70:	d513      	bpl.n	100ec9a <ll_rl_id_addr_get+0x46>
	*id_addr_type = rl[rl_idx].id_addr_type;
 100ec72:	4434      	add	r4, r6
 100ec74:	f815 3034 	ldrb.w	r3, [r5, r4, lsl #3]
	memcpy(id_addr, rl[rl_idx].id_addr.val, BDADDR_SIZE);
 100ec78:	eb05 05c4 	add.w	r5, r5, r4, lsl #3
	*id_addr_type = rl[rl_idx].id_addr_type;
 100ec7c:	f3c3 1380 	ubfx	r3, r3, #6, #1
 100ec80:	703b      	strb	r3, [r7, #0]
	memcpy(id_addr, rl[rl_idx].id_addr.val, BDADDR_SIZE);
 100ec82:	4640      	mov	r0, r8
 100ec84:	1c69      	adds	r1, r5, #1
 100ec86:	2206      	movs	r2, #6
}
 100ec88:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	memcpy(id_addr, rl[rl_idx].id_addr.val, BDADDR_SIZE);
 100ec8c:	f007 be14 	b.w	10168b8 <memcpy>
	LL_ASSERT(rl_idx < CONFIG_BT_CTLR_RL_SIZE);
 100ec90:	21e7      	movs	r1, #231	; 0xe7
 100ec92:	4805      	ldr	r0, [pc, #20]	; (100eca8 <ll_rl_id_addr_get+0x54>)
 100ec94:	f7f4 fc78 	bl	1003588 <bt_ctlr_assert_handle>
 100ec98:	e7e3      	b.n	100ec62 <ll_rl_id_addr_get+0xe>
	LL_ASSERT(rl[rl_idx].taken);
 100ec9a:	21e8      	movs	r1, #232	; 0xe8
 100ec9c:	4802      	ldr	r0, [pc, #8]	; (100eca8 <ll_rl_id_addr_get+0x54>)
 100ec9e:	f7f4 fc73 	bl	1003588 <bt_ctlr_assert_handle>
 100eca2:	e7e6      	b.n	100ec72 <ll_rl_id_addr_get+0x1e>
 100eca4:	21003aa4 	.word	0x21003aa4
 100eca8:	010188f4 	.word	0x010188f4

0100ecac <ll_rl_size_get>:
 100ecac:	2008      	movs	r0, #8
 100ecae:	4770      	bx	lr

0100ecb0 <ll_rl_clear>:
{
 100ecb0:	b570      	push	{r4, r5, r6, lr}
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
 100ecb2:	2000      	movs	r0, #0
 100ecb4:	f7fb ff60 	bl	100ab78 <ull_adv_is_enabled>
		? 0 : 1;
 100ecb8:	b108      	cbz	r0, 100ecbe <ll_rl_clear+0xe>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100ecba:	200c      	movs	r0, #12
}
 100ecbc:	bd70      	pop	{r4, r5, r6, pc}
 100ecbe:	4604      	mov	r4, r0
 100ecc0:	f7ff ff54 	bl	100eb6c <rl_access_check.part.0>
	if (!rl_access_check(false)) {
 100ecc4:	2800      	cmp	r0, #0
 100ecc6:	d0f8      	beq.n	100ecba <ll_rl_clear+0xa>
		rl[i].taken = 0U;
 100ecc8:	4b19      	ldr	r3, [pc, #100]	; (100ed30 <ll_rl_clear+0x80>)
	peer_irk_count = 0U;
 100ecca:	4e1a      	ldr	r6, [pc, #104]	; (100ed34 <ll_rl_clear+0x84>)
		rl[i].taken = 0U;
 100eccc:	7819      	ldrb	r1, [r3, #0]
 100ecce:	f893 2028 	ldrb.w	r2, [r3, #40]	; 0x28
 100ecd2:	f364 0100 	bfi	r1, r4, #0, #1
 100ecd6:	f364 0200 	bfi	r2, r4, #0, #1
 100ecda:	f893 5050 	ldrb.w	r5, [r3, #80]	; 0x50
 100ecde:	7019      	strb	r1, [r3, #0]
 100ece0:	f883 2028 	strb.w	r2, [r3, #40]	; 0x28
 100ece4:	f893 1078 	ldrb.w	r1, [r3, #120]	; 0x78
 100ece8:	f893 20a0 	ldrb.w	r2, [r3, #160]	; 0xa0
 100ecec:	f364 0500 	bfi	r5, r4, #0, #1
 100ecf0:	f364 0100 	bfi	r1, r4, #0, #1
 100ecf4:	f364 0200 	bfi	r2, r4, #0, #1
 100ecf8:	f883 5050 	strb.w	r5, [r3, #80]	; 0x50
 100ecfc:	f883 1078 	strb.w	r1, [r3, #120]	; 0x78
 100ed00:	f893 50c8 	ldrb.w	r5, [r3, #200]	; 0xc8
 100ed04:	f893 10f0 	ldrb.w	r1, [r3, #240]	; 0xf0
 100ed08:	f883 20a0 	strb.w	r2, [r3, #160]	; 0xa0
 100ed0c:	f893 2118 	ldrb.w	r2, [r3, #280]	; 0x118
 100ed10:	f364 0500 	bfi	r5, r4, #0, #1
 100ed14:	f364 0100 	bfi	r1, r4, #0, #1
 100ed18:	f364 0200 	bfi	r2, r4, #0, #1
	return 0;
 100ed1c:	4620      	mov	r0, r4
		rl[i].taken = 0U;
 100ed1e:	f883 50c8 	strb.w	r5, [r3, #200]	; 0xc8
 100ed22:	f883 10f0 	strb.w	r1, [r3, #240]	; 0xf0
 100ed26:	f883 2118 	strb.w	r2, [r3, #280]	; 0x118
	peer_irk_count = 0U;
 100ed2a:	7034      	strb	r4, [r6, #0]
}
 100ed2c:	bd70      	pop	{r4, r5, r6, pc}
 100ed2e:	bf00      	nop
 100ed30:	21003aa4 	.word	0x21003aa4
 100ed34:	210066f2 	.word	0x210066f2

0100ed38 <ll_rl_enable>:
{
 100ed38:	b538      	push	{r3, r4, r5, lr}
 100ed3a:	4605      	mov	r5, r0
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
 100ed3c:	2000      	movs	r0, #0
 100ed3e:	f7fb ff1b 	bl	100ab78 <ull_adv_is_enabled>
		? 0 : 1;
 100ed42:	b108      	cbz	r0, 100ed48 <ll_rl_enable+0x10>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100ed44:	200c      	movs	r0, #12
}
 100ed46:	bd38      	pop	{r3, r4, r5, pc}
 100ed48:	4604      	mov	r4, r0
 100ed4a:	f7ff ff0f 	bl	100eb6c <rl_access_check.part.0>
	if (!rl_access_check(false)) {
 100ed4e:	2800      	cmp	r0, #0
 100ed50:	d0f8      	beq.n	100ed44 <ll_rl_enable+0xc>
	switch (enable) {
 100ed52:	b13d      	cbz	r5, 100ed64 <ll_rl_enable+0x2c>
 100ed54:	2d01      	cmp	r5, #1
 100ed56:	d001      	beq.n	100ed5c <ll_rl_enable+0x24>
 100ed58:	2012      	movs	r0, #18
}
 100ed5a:	bd38      	pop	{r3, r4, r5, pc}
		rl_enable = 1U;
 100ed5c:	4b03      	ldr	r3, [pc, #12]	; (100ed6c <ll_rl_enable+0x34>)
	return 0;
 100ed5e:	4620      	mov	r0, r4
		rl_enable = 1U;
 100ed60:	701d      	strb	r5, [r3, #0]
}
 100ed62:	bd38      	pop	{r3, r4, r5, pc}
		rl_enable = 0U;
 100ed64:	4b01      	ldr	r3, [pc, #4]	; (100ed6c <ll_rl_enable+0x34>)
	return 0;
 100ed66:	4628      	mov	r0, r5
		rl_enable = 0U;
 100ed68:	701d      	strb	r5, [r3, #0]
}
 100ed6a:	bd38      	pop	{r3, r4, r5, pc}
 100ed6c:	210066f3 	.word	0x210066f3

0100ed70 <ll_rl_timeout_set>:
	rpa_timeout_ms = timeout * 1000U;
 100ed70:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 100ed74:	fb03 f300 	mul.w	r3, r3, r0
 100ed78:	4a01      	ldr	r2, [pc, #4]	; (100ed80 <ll_rl_timeout_set+0x10>)
 100ed7a:	6013      	str	r3, [r2, #0]
}
 100ed7c:	4770      	bx	lr
 100ed7e:	bf00      	nop
 100ed80:	21003c18 	.word	0x21003c18

0100ed84 <ull_filter_adv_scan_state_cb>:
	if (bm) {
 100ed84:	b1b0      	cbz	r0, 100edb4 <ull_filter_adv_scan_state_cb+0x30>
{
 100ed86:	b570      	push	{r4, r5, r6, lr}
		} else {
			return t * (to_hz / from_hz);
		}
	} else {
		if (result32) {
			return (u32_t)((t * to_hz + off) / from_hz);
 100ed88:	f240 30e7 	movw	r0, #999	; 0x3e7
 100ed8c:	f44f 4400 	mov.w	r4, #32768	; 0x8000
 100ed90:	2100      	movs	r1, #0
	k_delayed_work_submit(&rpa_work, K_MSEC(rpa_timeout_ms));
 100ed92:	4d0a      	ldr	r5, [pc, #40]	; (100edbc <ull_filter_adv_scan_state_cb+0x38>)
 100ed94:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 100ed98:	682d      	ldr	r5, [r5, #0]
 100ed9a:	2300      	movs	r3, #0
 100ed9c:	fbe4 0105 	umlal	r0, r1, r4, r5
 100eda0:	f7f1 f98a 	bl	10000b8 <__aeabi_uldivmod>
}
 100eda4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 100eda8:	4602      	mov	r2, r0
 * @retval -EADDRINUSE Work item is pending on a different workqueue.
 */
static inline int k_delayed_work_submit(struct k_delayed_work *work,
					k_timeout_t delay)
{
	return k_delayed_work_submit_to_queue(&k_sys_work_q, work, delay);
 100edaa:	2300      	movs	r3, #0
 100edac:	4904      	ldr	r1, [pc, #16]	; (100edc0 <ull_filter_adv_scan_state_cb+0x3c>)
 100edae:	4805      	ldr	r0, [pc, #20]	; (100edc4 <ull_filter_adv_scan_state_cb+0x40>)
 100edb0:	f005 bd8c 	b.w	10148cc <k_delayed_work_submit_to_queue>
	k_delayed_work_cancel(&rpa_work);
 100edb4:	4802      	ldr	r0, [pc, #8]	; (100edc0 <ull_filter_adv_scan_state_cb+0x3c>)
 100edb6:	f008 bf08 	b.w	1017bca <k_delayed_work_cancel>
 100edba:	bf00      	nop
 100edbc:	21003c18 	.word	0x21003c18
 100edc0:	21003c1c 	.word	0x21003c1c
 100edc4:	210065f4 	.word	0x210065f4

0100edc8 <ull_filter_adv_update>:
{
 100edc8:	b508      	push	{r3, lr}
}

static void filter_clear(struct lll_filter *filter)
{
	filter->enable_bitmask = 0;
 100edca:	2300      	movs	r3, #0
 100edcc:	4a0c      	ldr	r2, [pc, #48]	; (100ee00 <ull_filter_adv_update+0x38>)
 100edce:	8013      	strh	r3, [r2, #0]
	if (adv_fp &&
 100edd0:	b970      	cbnz	r0, 100edf0 <ull_filter_adv_update+0x28>
	filter->enable_bitmask = 0;
 100edd2:	2000      	movs	r0, #0
	if (rl_enable &&
 100edd4:	4b0b      	ldr	r3, [pc, #44]	; (100ee04 <ull_filter_adv_update+0x3c>)
	filter->enable_bitmask = 0;
 100edd6:	4a0c      	ldr	r2, [pc, #48]	; (100ee08 <ull_filter_adv_update+0x40>)
	if (rl_enable &&
 100edd8:	781b      	ldrb	r3, [r3, #0]
	filter->enable_bitmask = 0;
 100edda:	8010      	strh	r0, [r2, #0]
	if (rl_enable &&
 100eddc:	b903      	cbnz	r3, 100ede0 <ull_filter_adv_update+0x18>
}
 100edde:	bd08      	pop	{r3, pc}
	    (!IS_ENABLED(CONFIG_BT_OBSERVER) || !ull_scan_is_enabled(0))) {
 100ede0:	f7fc f818 	bl	100ae14 <ull_scan_is_enabled>
	if (rl_enable &&
 100ede4:	2800      	cmp	r0, #0
 100ede6:	d1fa      	bne.n	100edde <ull_filter_adv_update+0x16>
}
 100ede8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		rl_update();
 100edec:	f7ff be88 	b.w	100eb00 <rl_update>
	     !(ull_scan_filter_pol_get(0) & 0x1))) {
 100edf0:	4618      	mov	r0, r3
 100edf2:	f7fc f827 	bl	100ae44 <ull_scan_filter_pol_get>
	if (adv_fp &&
 100edf6:	07c3      	lsls	r3, r0, #31
 100edf8:	d4eb      	bmi.n	100edd2 <ull_filter_adv_update+0xa>
		wl_update();
 100edfa:	f7ff fe3d 	bl	100ea78 <wl_update>
 100edfe:	e7e8      	b.n	100edd2 <ull_filter_adv_update+0xa>
 100ee00:	21003c7c 	.word	0x21003c7c
 100ee04:	210066f3 	.word	0x210066f3
 100ee08:	21003be4 	.word	0x21003be4

0100ee0c <ull_filter_scan_update>:
{
 100ee0c:	b508      	push	{r3, lr}
	filter->enable_bitmask = 0;
 100ee0e:	2300      	movs	r3, #0
 100ee10:	4a0d      	ldr	r2, [pc, #52]	; (100ee48 <ull_filter_scan_update+0x3c>)
 100ee12:	8013      	strh	r3, [r2, #0]
	if ((scan_fp & 0x1) &&
 100ee14:	07c2      	lsls	r2, r0, #31
 100ee16:	d40e      	bmi.n	100ee36 <ull_filter_scan_update+0x2a>
	filter->enable_bitmask = 0;
 100ee18:	2000      	movs	r0, #0
	if (rl_enable &&
 100ee1a:	4b0c      	ldr	r3, [pc, #48]	; (100ee4c <ull_filter_scan_update+0x40>)
	filter->enable_bitmask = 0;
 100ee1c:	4a0c      	ldr	r2, [pc, #48]	; (100ee50 <ull_filter_scan_update+0x44>)
	if (rl_enable &&
 100ee1e:	781b      	ldrb	r3, [r3, #0]
	filter->enable_bitmask = 0;
 100ee20:	8010      	strh	r0, [r2, #0]
	if (rl_enable &&
 100ee22:	b903      	cbnz	r3, 100ee26 <ull_filter_scan_update+0x1a>
}
 100ee24:	bd08      	pop	{r3, pc}
	    (!IS_ENABLED(CONFIG_BT_BROADCASTER) || !ull_adv_is_enabled(0))) {
 100ee26:	f7fb fea7 	bl	100ab78 <ull_adv_is_enabled>
	if (rl_enable &&
 100ee2a:	2800      	cmp	r0, #0
 100ee2c:	d1fa      	bne.n	100ee24 <ull_filter_scan_update+0x18>
}
 100ee2e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
		rl_update();
 100ee32:	f7ff be65 	b.w	100eb00 <rl_update>
	     !ull_adv_filter_pol_get(0))) {
 100ee36:	4618      	mov	r0, r3
 100ee38:	f7fb feaa 	bl	100ab90 <ull_adv_filter_pol_get>
	if ((scan_fp & 0x1) &&
 100ee3c:	2800      	cmp	r0, #0
 100ee3e:	d1eb      	bne.n	100ee18 <ull_filter_scan_update+0xc>
		wl_update();
 100ee40:	f7ff fe1a 	bl	100ea78 <wl_update>
 100ee44:	e7e8      	b.n	100ee18 <ull_filter_scan_update+0xc>
 100ee46:	bf00      	nop
 100ee48:	21003c7c 	.word	0x21003c7c
 100ee4c:	210066f3 	.word	0x210066f3
 100ee50:	21003be4 	.word	0x21003be4

0100ee54 <ull_filter_adv_pdu_update>:
{
 100ee54:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	u8_t idx = adv->lll.rl_idx;
 100ee58:	f890 602a 	ldrb.w	r6, [r0, #42]	; 0x2a
{
 100ee5c:	4607      	mov	r7, r0
	if (idx < ARRAY_SIZE(rl) && rl[idx].lirk) {
 100ee5e:	2e07      	cmp	r6, #7
{
 100ee60:	460c      	mov	r4, r1
				  &pdu->scan_rsp.addr[0] :
 100ee62:	f101 0502 	add.w	r5, r1, #2
	if (idx < ARRAY_SIZE(rl) && rl[idx].lirk) {
 100ee66:	d848      	bhi.n	100eefa <ull_filter_adv_pdu_update+0xa6>
 100ee68:	f8df 90e4 	ldr.w	r9, [pc, #228]	; 100ef50 <ull_filter_adv_pdu_update+0xfc>
 100ee6c:	eb06 0386 	add.w	r3, r6, r6, lsl #2
 100ee70:	f819 3033 	ldrb.w	r3, [r9, r3, lsl #3]
 100ee74:	ea4f 0886 	mov.w	r8, r6, lsl #2
 100ee78:	0719      	lsls	r1, r3, #28
 100ee7a:	d52a      	bpl.n	100eed2 <ull_filter_adv_pdu_update+0x7e>
		LL_ASSERT(rl[idx].rpas_ready);
 100ee7c:	079a      	lsls	r2, r3, #30
 100ee7e:	d55e      	bpl.n	100ef3e <ull_filter_adv_pdu_update+0xea>
		pdu->tx_addr = 1;
 100ee80:	7822      	ldrb	r2, [r4, #0]
		memcpy(adva, rl[idx].local_rpa->val, BDADDR_SIZE);
 100ee82:	eb08 0306 	add.w	r3, r8, r6
 100ee86:	eb09 03c3 	add.w	r3, r9, r3, lsl #3
		pdu->tx_addr = 1;
 100ee8a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
		memcpy(adva, rl[idx].local_rpa->val, BDADDR_SIZE);
 100ee8e:	6a59      	ldr	r1, [r3, #36]	; 0x24
		pdu->tx_addr = 1;
 100ee90:	7022      	strb	r2, [r4, #0]
		memcpy(adva, rl[idx].local_rpa->val, BDADDR_SIZE);
 100ee92:	4628      	mov	r0, r5
 100ee94:	2206      	movs	r2, #6
 100ee96:	f007 fd0f 	bl	10168b8 <memcpy>
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
 100ee9a:	7823      	ldrb	r3, [r4, #0]
 100ee9c:	f003 030f 	and.w	r3, r3, #15
 100eea0:	2b01      	cmp	r3, #1
 100eea2:	d128      	bne.n	100eef6 <ull_filter_adv_pdu_update+0xa2>
		if (idx < ARRAY_SIZE(rl) && rl[idx].pirk) {
 100eea4:	4446      	add	r6, r8
 100eea6:	f819 3036 	ldrb.w	r3, [r9, r6, lsl #3]
 100eeaa:	00f6      	lsls	r6, r6, #3
 100eeac:	075b      	lsls	r3, r3, #29
 100eeae:	d438      	bmi.n	100ef22 <ull_filter_adv_pdu_update+0xce>
			pdu->rx_addr = adv->id_addr_type;
 100eeb0:	4620      	mov	r0, r4
 100eeb2:	f897 30da 	ldrb.w	r3, [r7, #218]	; 0xda
 100eeb6:	7822      	ldrb	r2, [r4, #0]
 100eeb8:	f3c3 0380 	ubfx	r3, r3, #2, #1
 100eebc:	f363 12c7 	bfi	r2, r3, #7, #1
 100eec0:	f800 2b08 	strb.w	r2, [r0], #8
			memcpy(&pdu->direct_ind.tgt_addr[0],
 100eec4:	f107 01db 	add.w	r1, r7, #219	; 0xdb
 100eec8:	2206      	movs	r2, #6
}
 100eeca:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			memcpy(&pdu->direct_ind.tgt_addr[0],
 100eece:	f007 bcf3 	b.w	10168b8 <memcpy>
		pdu->tx_addr = adv->own_addr_type & 0x1;
 100eed2:	f890 00da 	ldrb.w	r0, [r0, #218]	; 0xda
 100eed6:	7823      	ldrb	r3, [r4, #0]
 100eed8:	f000 0003 	and.w	r0, r0, #3
 100eedc:	f360 1386 	bfi	r3, r0, #6, #1
 100eee0:	7023      	strb	r3, [r4, #0]
		ll_addr_get(adv->own_addr_type & 0x1, adva);
 100eee2:	4629      	mov	r1, r5
 100eee4:	f000 0001 	and.w	r0, r0, #1
 100eee8:	f7f8 f9e4 	bl	10072b4 <ll_addr_get>
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
 100eeec:	7823      	ldrb	r3, [r4, #0]
 100eeee:	f003 030f 	and.w	r3, r3, #15
 100eef2:	2b01      	cmp	r3, #1
 100eef4:	d0d6      	beq.n	100eea4 <ull_filter_adv_pdu_update+0x50>
}
 100eef6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
		pdu->tx_addr = adv->own_addr_type & 0x1;
 100eefa:	f890 00da 	ldrb.w	r0, [r0, #218]	; 0xda
 100eefe:	780b      	ldrb	r3, [r1, #0]
 100ef00:	f000 0003 	and.w	r0, r0, #3
 100ef04:	f360 1386 	bfi	r3, r0, #6, #1
 100ef08:	7023      	strb	r3, [r4, #0]
		ll_addr_get(adv->own_addr_type & 0x1, adva);
 100ef0a:	4629      	mov	r1, r5
 100ef0c:	f000 0001 	and.w	r0, r0, #1
 100ef10:	f7f8 f9d0 	bl	10072b4 <ll_addr_get>
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
 100ef14:	7823      	ldrb	r3, [r4, #0]
 100ef16:	f003 030f 	and.w	r3, r3, #15
 100ef1a:	2b01      	cmp	r3, #1
 100ef1c:	d0c8      	beq.n	100eeb0 <ull_filter_adv_pdu_update+0x5c>
}
 100ef1e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
			pdu->rx_addr = 1;
 100ef22:	4620      	mov	r0, r4
 100ef24:	7823      	ldrb	r3, [r4, #0]
			       rl[idx].peer_rpa.val, BDADDR_SIZE);
 100ef26:	361e      	adds	r6, #30
			pdu->rx_addr = 1;
 100ef28:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 100ef2c:	f800 3b08 	strb.w	r3, [r0], #8
			memcpy(&pdu->direct_ind.tgt_addr[0],
 100ef30:	eb09 0106 	add.w	r1, r9, r6
 100ef34:	2206      	movs	r2, #6
}
 100ef36:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
			memcpy(&pdu->direct_ind.tgt_addr[0],
 100ef3a:	f007 bcbd 	b.w	10168b8 <memcpy>
		LL_ASSERT(rl[idx].rpas_ready);
 100ef3e:	f240 214a 	movw	r1, #586	; 0x24a
 100ef42:	4802      	ldr	r0, [pc, #8]	; (100ef4c <ull_filter_adv_pdu_update+0xf8>)
 100ef44:	f7f4 fb20 	bl	1003588 <bt_ctlr_assert_handle>
 100ef48:	e79a      	b.n	100ee80 <ull_filter_adv_pdu_update+0x2c>
 100ef4a:	bf00      	nop
 100ef4c:	010188f4 	.word	0x010188f4
 100ef50:	21003aa4 	.word	0x21003aa4

0100ef54 <ull_filter_rpa_update>:
{
 100ef54:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100ef58:	4682      	mov	sl, r0
 100ef5a:	b087      	sub	sp, #28
	return z_impl_k_uptime_ticks();
 100ef5c:	f008 fe8e 	bl	1017c7c <z_impl_k_uptime_ticks>
		} else {
			return (t * to_hz + off) / from_hz;
 100ef60:	0142      	lsls	r2, r0, #5
 100ef62:	014b      	lsls	r3, r1, #5
 100ef64:	ebb2 0800 	subs.w	r8, r2, r0
 100ef68:	ea43 63d0 	orr.w	r3, r3, r0, lsr #27
 100ef6c:	eb63 0301 	sbc.w	r3, r3, r1
 100ef70:	009b      	lsls	r3, r3, #2
 100ef72:	ea4f 0288 	mov.w	r2, r8, lsl #2
 100ef76:	ea43 7398 	orr.w	r3, r3, r8, lsr #30
 100ef7a:	eb12 0800 	adds.w	r8, r2, r0
 100ef7e:	eb43 0101 	adc.w	r1, r3, r1
 100ef82:	00c9      	lsls	r1, r1, #3
 100ef84:	ea41 7158 	orr.w	r1, r1, r8, lsr #29
 100ef88:	ea4f 03c8 	mov.w	r3, r8, lsl #3
 100ef8c:	ea4f 38d3 	mov.w	r8, r3, lsr #15
 100ef90:	0bc8      	lsrs	r0, r1, #15
 100ef92:	ea48 4841 	orr.w	r8, r8, r1, lsl #17
 100ef96:	9001      	str	r0, [sp, #4]
	bool all = timeout || (rpa_last_ms == -1) ||
 100ef98:	f1ba 0f00 	cmp.w	sl, #0
 100ef9c:	d117      	bne.n	100efce <ull_filter_rpa_update+0x7a>
 100ef9e:	4b6a      	ldr	r3, [pc, #424]	; (100f148 <ull_filter_rpa_update+0x1f4>)
 100efa0:	e9d3 6700 	ldrd	r6, r7, [r3]
 100efa4:	1c79      	adds	r1, r7, #1
 100efa6:	bf08      	it	eq
 100efa8:	f1b6 3fff 	cmpeq.w	r6, #4294967295
 100efac:	d00f      	beq.n	100efce <ull_filter_rpa_update+0x7a>
		   (now - rpa_last_ms >= rpa_timeout_ms);
 100efae:	2300      	movs	r3, #0
 100efb0:	4966      	ldr	r1, [pc, #408]	; (100f14c <ull_filter_rpa_update+0x1f8>)
 100efb2:	ebb8 0406 	subs.w	r4, r8, r6
 100efb6:	680a      	ldr	r2, [r1, #0]
 100efb8:	eb60 0507 	sbc.w	r5, r0, r7
	bool all = timeout || (rpa_last_ms == -1) ||
 100efbc:	4294      	cmp	r4, r2
 100efbe:	eb75 0303 	sbcs.w	r3, r5, r3
 100efc2:	bfac      	ite	ge
 100efc4:	f04f 0901 	movge.w	r9, #1
 100efc8:	f04f 0900 	movlt.w	r9, #0
 100efcc:	e001      	b.n	100efd2 <ull_filter_rpa_update+0x7e>
 100efce:	f04f 0901 	mov.w	r9, #1
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
 100efd2:	4e5f      	ldr	r6, [pc, #380]	; (100f150 <ull_filter_rpa_update+0x1fc>)
	bool all = timeout || (rpa_last_ms == -1) ||
 100efd4:	2400      	movs	r4, #0
 100efd6:	4633      	mov	r3, r6
 100efd8:	f1a6 0724 	sub.w	r7, r6, #36	; 0x24
 100efdc:	464e      	mov	r6, r9
 100efde:	4699      	mov	r9, r3
				LL_ASSERT(!err);
 100efe0:	f8df b178 	ldr.w	fp, [pc, #376]	; 100f15c <ull_filter_rpa_update+0x208>
		if ((rl[i].taken) && (all || !rl[i].rpas_ready)) {
 100efe4:	eb04 0384 	add.w	r3, r4, r4, lsl #2
 100efe8:	f817 3033 	ldrb.w	r3, [r7, r3, lsl #3]
 100efec:	00a5      	lsls	r5, r4, #2
 100efee:	07da      	lsls	r2, r3, #31
 100eff0:	d513      	bpl.n	100f01a <ull_filter_rpa_update+0xc6>
 100eff2:	b90e      	cbnz	r6, 100eff8 <ull_filter_rpa_update+0xa4>
 100eff4:	0798      	lsls	r0, r3, #30
 100eff6:	d410      	bmi.n	100f01a <ull_filter_rpa_update+0xc6>
			if (rl[i].pirk) {
 100eff8:	192b      	adds	r3, r5, r4
 100effa:	f817 3033 	ldrb.w	r3, [r7, r3, lsl #3]
 100effe:	0759      	lsls	r1, r3, #29
 100f000:	d434      	bmi.n	100f06c <ull_filter_rpa_update+0x118>
			if (rl[i].lirk) {
 100f002:	192b      	adds	r3, r5, r4
 100f004:	f817 3033 	ldrb.w	r3, [r7, r3, lsl #3]
 100f008:	071a      	lsls	r2, r3, #28
 100f00a:	d417      	bmi.n	100f03c <ull_filter_rpa_update+0xe8>
			rl[i].rpas_ready = 1U;
 100f00c:	4425      	add	r5, r4
 100f00e:	f817 3035 	ldrb.w	r3, [r7, r5, lsl #3]
 100f012:	f043 0302 	orr.w	r3, r3, #2
 100f016:	f807 3035 	strb.w	r3, [r7, r5, lsl #3]
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
 100f01a:	3401      	adds	r4, #1
 100f01c:	2c08      	cmp	r4, #8
 100f01e:	f109 0928 	add.w	r9, r9, #40	; 0x28
 100f022:	d1df      	bne.n	100efe4 <ull_filter_rpa_update+0x90>
	if (all) {
 100f024:	b126      	cbz	r6, 100f030 <ull_filter_rpa_update+0xdc>
		rpa_last_ms = now;
 100f026:	4b48      	ldr	r3, [pc, #288]	; (100f148 <ull_filter_rpa_update+0x1f4>)
 100f028:	9a01      	ldr	r2, [sp, #4]
 100f02a:	f8c3 8000 	str.w	r8, [r3]
 100f02e:	605a      	str	r2, [r3, #4]
	if (timeout) {
 100f030:	f1ba 0f00 	cmp.w	sl, #0
 100f034:	d137      	bne.n	100f0a6 <ull_filter_rpa_update+0x152>
}
 100f036:	b007      	add	sp, #28
 100f038:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
				err = bt_rpa_create(rl[i].local_irk, &rpa);
 100f03c:	a902      	add	r1, sp, #8
 100f03e:	f1a9 001d 	sub.w	r0, r9, #29
 100f042:	f007 fcba 	bl	10169ba <bt_rpa_create>
				LL_ASSERT(!err);
 100f046:	2800      	cmp	r0, #0
 100f048:	d16c      	bne.n	100f124 <ull_filter_rpa_update+0x1d0>
				rl[i].local_rpa = &rpa;
 100f04a:	4a42      	ldr	r2, [pc, #264]	; (100f154 <ull_filter_rpa_update+0x200>)
 100f04c:	eb04 0344 	add.w	r3, r4, r4, lsl #1
 100f050:	eb02 0343 	add.w	r3, r2, r3, lsl #1
	memcpy(dst, src, sizeof(*dst));
 100f054:	a902      	add	r1, sp, #8
 100f056:	4618      	mov	r0, r3
 100f058:	2206      	movs	r2, #6
 100f05a:	f8c9 1000 	str.w	r1, [r9]
 100f05e:	9300      	str	r3, [sp, #0]
 100f060:	f007 fc2a 	bl	10168b8 <memcpy>
				rl[i].local_rpa = &local_rpas[i];
 100f064:	9b00      	ldr	r3, [sp, #0]
 100f066:	f8c9 3000 	str.w	r3, [r9]
 100f06a:	e7cf      	b.n	100f00c <ull_filter_rpa_update+0xb8>

	__ASSERT(((psrc < pdst && (psrc + length) <= pdst) ||
		  (psrc > pdst && (pdst + length) <= psrc)),
		 "Source and destination buffers must not overlap");

	psrc += length - 1;
 100f06c:	f819 2c0d 	ldrb.w	r2, [r9, #-13]
 100f070:	4939      	ldr	r1, [pc, #228]	; (100f158 <ull_filter_rpa_update+0x204>)
 100f072:	f10d 0307 	add.w	r3, sp, #7
 100f076:	eb01 1202 	add.w	r2, r1, r2, lsl #4
 100f07a:	320f      	adds	r2, #15

	for (; length > 0; length--) {
 100f07c:	f10d 0017 	add.w	r0, sp, #23
		*pdst++ = *psrc--;
 100f080:	f812 1901 	ldrb.w	r1, [r2], #-1
 100f084:	f803 1f01 	strb.w	r1, [r3, #1]!
	for (; length > 0; length--) {
 100f088:	4283      	cmp	r3, r0
 100f08a:	d1f9      	bne.n	100f080 <ull_filter_rpa_update+0x12c>
				err = bt_rpa_create(irk, &rl[i].peer_rpa);
 100f08c:	f1a9 0106 	sub.w	r1, r9, #6
 100f090:	a802      	add	r0, sp, #8
 100f092:	f007 fc92 	bl	10169ba <bt_rpa_create>
				LL_ASSERT(!err);
 100f096:	2800      	cmp	r0, #0
 100f098:	d0b3      	beq.n	100f002 <ull_filter_rpa_update+0xae>
 100f09a:	f44f 7105 	mov.w	r1, #532	; 0x214
 100f09e:	4658      	mov	r0, fp
 100f0a0:	f7f4 fa72 	bl	1003588 <bt_ctlr_assert_handle>
 100f0a4:	e7ad      	b.n	100f002 <ull_filter_rpa_update+0xae>
		adv = ull_adv_is_enabled_get(0);
 100f0a6:	2000      	movs	r0, #0
 100f0a8:	f7fb fd58 	bl	100ab5c <ull_adv_is_enabled_get>
		if (adv) {
 100f0ac:	4604      	mov	r4, r0
 100f0ae:	2800      	cmp	r0, #0
 100f0b0:	d0c1      	beq.n	100f036 <ull_filter_rpa_update+0xe2>
	if (adv->own_addr_type != BT_ADDR_LE_PUBLIC_ID &&
 100f0b2:	f890 30da 	ldrb.w	r3, [r0, #218]	; 0xda
 100f0b6:	079b      	lsls	r3, r3, #30
 100f0b8:	d5bd      	bpl.n	100f036 <ull_filter_rpa_update+0xe2>
	if (adv->lll.rl_idx >= ARRAY_SIZE(rl)) {
 100f0ba:	f890 302a 	ldrb.w	r3, [r0, #42]	; 0x2a
 100f0be:	2b07      	cmp	r3, #7
 100f0c0:	d8b9      	bhi.n	100f036 <ull_filter_rpa_update+0xe2>
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 100f0c2:	f890 502c 	ldrb.w	r5, [r0, #44]	; 0x2c
	if (pdu->first == pdu->last) {
 100f0c6:	f890 002b 	ldrb.w	r0, [r0, #43]	; 0x2b
 100f0ca:	eb05 0385 	add.w	r3, r5, r5, lsl #2
 100f0ce:	ebc5 03c3 	rsb	r3, r5, r3, lsl #3
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 100f0d2:	f103 0211 	add.w	r2, r3, #17
 100f0d6:	f104 011c 	add.w	r1, r4, #28
	if (pdu->first == pdu->last) {
 100f0da:	42a8      	cmp	r0, r5
	return (void *)lll->adv_data.pdu[lll->adv_data.last];
 100f0dc:	eb01 0602 	add.w	r6, r1, r2
	if (pdu->first == pdu->last) {
 100f0e0:	d026      	beq.n	100f130 <ull_filter_rpa_update+0x1dc>
 100f0e2:	3302      	adds	r3, #2
		pdu->chan_sel = prev->chan_sel;
 100f0e4:	5c8a      	ldrb	r2, [r1, r2]
	return (void *)pdu->pdu[last];
 100f0e6:	f104 012b 	add.w	r1, r4, #43	; 0x2b
	pdu->type = prev->type;
 100f0ea:	5cc8      	ldrb	r0, [r1, r3]
		pdu->chan_sel = prev->chan_sel;
 100f0ec:	f3c2 1740 	ubfx	r7, r2, #5, #1
	pdu->type = prev->type;
 100f0f0:	f3c2 0203 	ubfx	r2, r2, #0, #4
 100f0f4:	ea42 1247 	orr.w	r2, r2, r7, lsl #5
 100f0f8:	f020 003f 	bic.w	r0, r0, #63	; 0x3f
 100f0fc:	18cf      	adds	r7, r1, r3
 100f0fe:	4302      	orrs	r2, r0
 100f100:	54ca      	strb	r2, [r1, r3]
	ull_filter_adv_pdu_update(adv, pdu);
 100f102:	4620      	mov	r0, r4
 100f104:	4639      	mov	r1, r7
 100f106:	f7ff fea5 	bl	100ee54 <ull_filter_adv_pdu_update>
	       prev->len - BDADDR_SIZE);
 100f10a:	7872      	ldrb	r2, [r6, #1]
	memcpy(&pdu->adv_ind.data[0], &prev->adv_ind.data[0],
 100f10c:	f107 0008 	add.w	r0, r7, #8
 100f110:	3a06      	subs	r2, #6
 100f112:	f106 0108 	add.w	r1, r6, #8
 100f116:	f007 fbcf 	bl	10168b8 <memcpy>
	pdu->len = prev->len;
 100f11a:	7873      	ldrb	r3, [r6, #1]
 100f11c:	707b      	strb	r3, [r7, #1]
	pdu->last = idx;
 100f11e:	f884 502c 	strb.w	r5, [r4, #44]	; 0x2c
}
 100f122:	e788      	b.n	100f036 <ull_filter_rpa_update+0xe2>
				LL_ASSERT(!err);
 100f124:	f240 2121 	movw	r1, #545	; 0x221
 100f128:	4658      	mov	r0, fp
 100f12a:	f7f4 fa2d 	bl	1003588 <bt_ctlr_assert_handle>
 100f12e:	e78c      	b.n	100f04a <ull_filter_rpa_update+0xf6>
		last = pdu->last + 1;
 100f130:	3501      	adds	r5, #1
 100f132:	b2ed      	uxtb	r5, r5
		if (last == DOUBLE_BUFFER_SIZE) {
 100f134:	2d02      	cmp	r5, #2
 100f136:	d004      	beq.n	100f142 <ull_filter_rpa_update+0x1ee>
 100f138:	eb05 0385 	add.w	r3, r5, r5, lsl #2
 100f13c:	ebc5 03c3 	rsb	r3, r5, r3, lsl #3
 100f140:	e7cf      	b.n	100f0e2 <ull_filter_rpa_update+0x18e>
 100f142:	462b      	mov	r3, r5
			last = 0U;
 100f144:	2500      	movs	r5, #0
 100f146:	e7cd      	b.n	100f0e4 <ull_filter_rpa_update+0x190>
 100f148:	210006c8 	.word	0x210006c8
 100f14c:	21003c18 	.word	0x21003c18
 100f150:	21003ac8 	.word	0x21003ac8
 100f154:	210039ec 	.word	0x210039ec
 100f158:	21003a24 	.word	0x21003a24
 100f15c:	010188f4 	.word	0x010188f4

0100f160 <rpa_timeout>:
{
 100f160:	b570      	push	{r4, r5, r6, lr}
	ull_filter_rpa_update(true);
 100f162:	2001      	movs	r0, #1
 100f164:	f7ff fef6 	bl	100ef54 <ull_filter_rpa_update>
			return (u32_t)((t * to_hz + off) / from_hz);
 100f168:	f44f 4400 	mov.w	r4, #32768	; 0x8000
 100f16c:	f240 30e7 	movw	r0, #999	; 0x3e7
 100f170:	2100      	movs	r1, #0
	k_delayed_work_submit(&rpa_work, K_MSEC(rpa_timeout_ms));
 100f172:	4d08      	ldr	r5, [pc, #32]	; (100f194 <rpa_timeout+0x34>)
 100f174:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 100f178:	682d      	ldr	r5, [r5, #0]
 100f17a:	2300      	movs	r3, #0
 100f17c:	fbe4 0105 	umlal	r0, r1, r4, r5
 100f180:	f7f0 ff9a 	bl	10000b8 <__aeabi_uldivmod>
}
 100f184:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 100f188:	4602      	mov	r2, r0
 100f18a:	2300      	movs	r3, #0
 100f18c:	4902      	ldr	r1, [pc, #8]	; (100f198 <rpa_timeout+0x38>)
 100f18e:	4803      	ldr	r0, [pc, #12]	; (100f19c <rpa_timeout+0x3c>)
 100f190:	f005 bb9c 	b.w	10148cc <k_delayed_work_submit_to_queue>
 100f194:	21003c18 	.word	0x21003c18
 100f198:	21003c1c 	.word	0x21003c1c
 100f19c:	210065f4 	.word	0x210065f4

0100f1a0 <ull_filter_rl_find>:
{
 100f1a0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100f1a4:	468b      	mov	fp, r1
	if (free) {
 100f1a6:	4616      	mov	r6, r2
 100f1a8:	b10a      	cbz	r2, 100f1ae <ull_filter_rl_find+0xe>
		*free = FILTER_IDX_NONE;
 100f1aa:	23ff      	movs	r3, #255	; 0xff
 100f1ac:	7013      	strb	r3, [r2, #0]
 100f1ae:	f8df 8064 	ldr.w	r8, [pc, #100]	; 100f214 <ull_filter_rl_find+0x74>
{
 100f1b2:	2400      	movs	r4, #0
		if (LIST_MATCH(rl, i, id_addr_type, id_addr)) {
 100f1b4:	f000 0901 	and.w	r9, r0, #1
 100f1b8:	f108 0a01 	add.w	sl, r8, #1
 100f1bc:	e004      	b.n	100f1c8 <ull_filter_rl_find+0x28>
 100f1be:	454a      	cmp	r2, r9
 100f1c0:	d019      	beq.n	100f1f6 <ull_filter_rl_find+0x56>
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
 100f1c2:	3401      	adds	r4, #1
 100f1c4:	2c08      	cmp	r4, #8
 100f1c6:	d012      	beq.n	100f1ee <ull_filter_rl_find+0x4e>
		if (LIST_MATCH(rl, i, id_addr_type, id_addr)) {
 100f1c8:	eb04 0584 	add.w	r5, r4, r4, lsl #2
 100f1cc:	f818 3035 	ldrb.w	r3, [r8, r5, lsl #3]
 100f1d0:	00e8      	lsls	r0, r5, #3
 100f1d2:	07d9      	lsls	r1, r3, #31
 100f1d4:	f3c3 1280 	ubfx	r2, r3, #6, #1
 100f1d8:	b2e7      	uxtb	r7, r4
 100f1da:	d4f0      	bmi.n	100f1be <ull_filter_rl_find+0x1e>
		} else if (free && !rl[i].taken && (*free == FILTER_IDX_NONE)) {
 100f1dc:	2e00      	cmp	r6, #0
 100f1de:	d0f0      	beq.n	100f1c2 <ull_filter_rl_find+0x22>
 100f1e0:	7833      	ldrb	r3, [r6, #0]
 100f1e2:	3401      	adds	r4, #1
 100f1e4:	2bff      	cmp	r3, #255	; 0xff
			*free = i;
 100f1e6:	bf08      	it	eq
 100f1e8:	7037      	strbeq	r7, [r6, #0]
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
 100f1ea:	2c08      	cmp	r4, #8
 100f1ec:	d1ec      	bne.n	100f1c8 <ull_filter_rl_find+0x28>
	return FILTER_IDX_NONE;
 100f1ee:	27ff      	movs	r7, #255	; 0xff
}
 100f1f0:	4638      	mov	r0, r7
 100f1f2:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (LIST_MATCH(rl, i, id_addr_type, id_addr)) {
 100f1f6:	2206      	movs	r2, #6
 100f1f8:	4659      	mov	r1, fp
 100f1fa:	4450      	add	r0, sl
 100f1fc:	f007 fb4c 	bl	1016898 <memcmp>
 100f200:	2800      	cmp	r0, #0
 100f202:	d0f5      	beq.n	100f1f0 <ull_filter_rl_find+0x50>
		} else if (free && !rl[i].taken && (*free == FILTER_IDX_NONE)) {
 100f204:	2e00      	cmp	r6, #0
 100f206:	d0dc      	beq.n	100f1c2 <ull_filter_rl_find+0x22>
 100f208:	f818 3035 	ldrb.w	r3, [r8, r5, lsl #3]
 100f20c:	07db      	lsls	r3, r3, #31
 100f20e:	d4d8      	bmi.n	100f1c2 <ull_filter_rl_find+0x22>
 100f210:	e7e6      	b.n	100f1e0 <ull_filter_rl_find+0x40>
 100f212:	bf00      	nop
 100f214:	21003aa4 	.word	0x21003aa4

0100f218 <ll_wl_add>:
{
 100f218:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 100f21c:	4605      	mov	r5, r0
 100f21e:	b083      	sub	sp, #12
	if (ull_adv_filter_pol_get(0)) {
 100f220:	2000      	movs	r0, #0
 100f222:	f7fb fcb5 	bl	100ab90 <ull_adv_filter_pol_get>
 100f226:	2800      	cmp	r0, #0
 100f228:	d142      	bne.n	100f2b0 <ll_wl_add+0x98>
	if (ull_scan_filter_pol_get(0) & 0x1) {
 100f22a:	f7fb fe0b 	bl	100ae44 <ull_scan_filter_pol_get>
 100f22e:	f010 0401 	ands.w	r4, r0, #1
 100f232:	d13d      	bne.n	100f2b0 <ll_wl_add+0x98>
	if (addr->type == ADDR_TYPE_ANON) {
 100f234:	7828      	ldrb	r0, [r5, #0]
 100f236:	28ff      	cmp	r0, #255	; 0xff
 100f238:	d03e      	beq.n	100f2b8 <ll_wl_add+0xa0>
	i = wl_find(id_addr->type, id_addr->a.val, &j);
 100f23a:	f105 0801 	add.w	r8, r5, #1
 100f23e:	4641      	mov	r1, r8
 100f240:	f10d 0207 	add.w	r2, sp, #7
 100f244:	f7ff fbe0 	bl	100ea08 <wl_find>
	if (i < ARRAY_SIZE(wl)) {
 100f248:	2807      	cmp	r0, #7
 100f24a:	d93e      	bls.n	100f2ca <ll_wl_add+0xb2>
	} else if (j >= ARRAY_SIZE(wl)) {
 100f24c:	f89d 6007 	ldrb.w	r6, [sp, #7]
 100f250:	2e07      	cmp	r6, #7
 100f252:	d838      	bhi.n	100f2c6 <ll_wl_add+0xae>
	wl[i].id_addr_type = id_addr->type & 0x1;
 100f254:	4f21      	ldr	r7, [pc, #132]	; (100f2dc <ll_wl_add+0xc4>)
 100f256:	782a      	ldrb	r2, [r5, #0]
 100f258:	f817 3036 	ldrb.w	r3, [r7, r6, lsl #3]
	bt_addr_copy(&wl[i].id_addr, &id_addr->a);
 100f25c:	ea4f 09c6 	mov.w	r9, r6, lsl #3
 100f260:	f109 0002 	add.w	r0, r9, #2
	wl[i].id_addr_type = id_addr->type & 0x1;
 100f264:	f362 0341 	bfi	r3, r2, #1, #1
 100f268:	4641      	mov	r1, r8
 100f26a:	2206      	movs	r2, #6
 100f26c:	4438      	add	r0, r7
 100f26e:	f807 3036 	strb.w	r3, [r7, r6, lsl #3]
 100f272:	f007 fb21 	bl	10168b8 <memcpy>
	j = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
 100f276:	4622      	mov	r2, r4
 100f278:	4641      	mov	r1, r8
 100f27a:	7828      	ldrb	r0, [r5, #0]
 100f27c:	f7ff ff90 	bl	100f1a0 <ull_filter_rl_find>
	if (j < ARRAY_SIZE(rl)) {
 100f280:	2807      	cmp	r0, #7
 100f282:	d826      	bhi.n	100f2d2 <ll_wl_add+0xba>
		rl[j].wl = 1U;
 100f284:	4a16      	ldr	r2, [pc, #88]	; (100f2e0 <ll_wl_add+0xc8>)
 100f286:	eb00 0180 	add.w	r1, r0, r0, lsl #2
 100f28a:	f812 3031 	ldrb.w	r3, [r2, r1, lsl #3]
		wl[i].rl_idx = j;
 100f28e:	44b9      	add	r9, r7
		rl[j].wl = 1U;
 100f290:	f043 0320 	orr.w	r3, r3, #32
		wl[i].rl_idx = j;
 100f294:	f889 0001 	strb.w	r0, [r9, #1]
		rl[j].wl = 1U;
 100f298:	f802 3031 	strb.w	r3, [r2, r1, lsl #3]
	return 0;
 100f29c:	2000      	movs	r0, #0
	wl[i].taken = 1U;
 100f29e:	f817 3036 	ldrb.w	r3, [r7, r6, lsl #3]
 100f2a2:	f043 0301 	orr.w	r3, r3, #1
 100f2a6:	f807 3036 	strb.w	r3, [r7, r6, lsl #3]
}
 100f2aa:	b003      	add	sp, #12
 100f2ac:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		return BT_HCI_ERR_CMD_DISALLOWED;
 100f2b0:	200c      	movs	r0, #12
}
 100f2b2:	b003      	add	sp, #12
 100f2b4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		wl_anon = 1U;
 100f2b8:	2201      	movs	r2, #1
		return 0;
 100f2ba:	4620      	mov	r0, r4
		wl_anon = 1U;
 100f2bc:	4b09      	ldr	r3, [pc, #36]	; (100f2e4 <ll_wl_add+0xcc>)
 100f2be:	701a      	strb	r2, [r3, #0]
}
 100f2c0:	b003      	add	sp, #12
 100f2c2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 100f2c6:	2007      	movs	r0, #7
	return wl_add(addr);
 100f2c8:	e7f3      	b.n	100f2b2 <ll_wl_add+0x9a>
 100f2ca:	4620      	mov	r0, r4
}
 100f2cc:	b003      	add	sp, #12
 100f2ce:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		wl[i].rl_idx = FILTER_IDX_NONE;
 100f2d2:	23ff      	movs	r3, #255	; 0xff
 100f2d4:	44b9      	add	r9, r7
 100f2d6:	f889 3001 	strb.w	r3, [r9, #1]
 100f2da:	e7df      	b.n	100f29c <ll_wl_add+0x84>
 100f2dc:	21003c3c 	.word	0x21003c3c
 100f2e0:	21003aa4 	.word	0x21003aa4
 100f2e4:	210066f4 	.word	0x210066f4

0100f2e8 <ll_rl_add>:
{
 100f2e8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100f2ec:	4607      	mov	r7, r0
 100f2ee:	b083      	sub	sp, #12
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
 100f2f0:	2000      	movs	r0, #0
{
 100f2f2:	460d      	mov	r5, r1
 100f2f4:	4614      	mov	r4, r2
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
 100f2f6:	f7fb fc3f 	bl	100ab78 <ull_adv_is_enabled>
		? 0 : 1;
 100f2fa:	b118      	cbz	r0, 100f304 <ll_rl_add+0x1c>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100f2fc:	200c      	movs	r0, #12
}
 100f2fe:	b003      	add	sp, #12
 100f300:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 100f304:	f7ff fc32 	bl	100eb6c <rl_access_check.part.0>
	if (!rl_access_check(false)) {
 100f308:	2800      	cmp	r0, #0
 100f30a:	d0f7      	beq.n	100f2fc <ll_rl_add+0x14>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, &j);
 100f30c:	46b9      	mov	r9, r7
 100f30e:	f819 0b01 	ldrb.w	r0, [r9], #1
 100f312:	f10d 0207 	add.w	r2, sp, #7
 100f316:	4649      	mov	r1, r9
 100f318:	f7ff ff42 	bl	100f1a0 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
 100f31c:	2807      	cmp	r0, #7
 100f31e:	d97e      	bls.n	100f41e <ll_rl_add+0x136>
	} else if (j >= ARRAY_SIZE(rl)) {
 100f320:	f89d b007 	ldrb.w	fp, [sp, #7]
 100f324:	f1bb 0f07 	cmp.w	fp, #7
 100f328:	d872      	bhi.n	100f410 <ll_rl_add+0x128>
	bt_addr_copy(&rl[i].id_addr, &id_addr->a);
 100f32a:	eb0b 088b 	add.w	r8, fp, fp, lsl #2
 100f32e:	4e44      	ldr	r6, [pc, #272]	; (100f440 <ll_rl_add+0x158>)
 100f330:	ea4f 08c8 	mov.w	r8, r8, lsl #3
 100f334:	f108 0001 	add.w	r0, r8, #1
 100f338:	2206      	movs	r2, #6
 100f33a:	4649      	mov	r1, r9
 100f33c:	4430      	add	r0, r6
 100f33e:	f007 fabb 	bl	10168b8 <memcpy>
	rl[i].id_addr_type = id_addr->type & 0x1;
 100f342:	783a      	ldrb	r2, [r7, #0]
 100f344:	f816 3008 	ldrb.w	r3, [r6, r8]
	rl[i].pirk = mem_nz((u8_t *)pirk, IRK_SIZE);
 100f348:	2110      	movs	r1, #16
	rl[i].id_addr_type = id_addr->type & 0x1;
 100f34a:	f362 1386 	bfi	r3, r2, #6, #1
	rl[i].pirk = mem_nz((u8_t *)pirk, IRK_SIZE);
 100f34e:	4628      	mov	r0, r5
	rl[i].id_addr_type = id_addr->type & 0x1;
 100f350:	f806 3008 	strb.w	r3, [r6, r8]
	rl[i].pirk = mem_nz((u8_t *)pirk, IRK_SIZE);
 100f354:	f7f6 fcae 	bl	1005cb4 <mem_nz>
 100f358:	f816 3008 	ldrb.w	r3, [r6, r8]
	rl[i].lirk = mem_nz((u8_t *)lirk, IRK_SIZE);
 100f35c:	2110      	movs	r1, #16
	rl[i].pirk = mem_nz((u8_t *)pirk, IRK_SIZE);
 100f35e:	f360 0382 	bfi	r3, r0, #2, #1
	rl[i].lirk = mem_nz((u8_t *)lirk, IRK_SIZE);
 100f362:	4620      	mov	r0, r4
	rl[i].pirk = mem_nz((u8_t *)pirk, IRK_SIZE);
 100f364:	f806 3008 	strb.w	r3, [r6, r8]
	rl[i].lirk = mem_nz((u8_t *)lirk, IRK_SIZE);
 100f368:	f7f6 fca4 	bl	1005cb4 <mem_nz>
 100f36c:	f816 3008 	ldrb.w	r3, [r6, r8]
 100f370:	f000 0001 	and.w	r0, r0, #1
 100f374:	f360 03c3 	bfi	r3, r0, #3, #1
 100f378:	f806 3008 	strb.w	r3, [r6, r8]
	if (rl[i].pirk) {
 100f37c:	075b      	lsls	r3, r3, #29
	rl[i].id_addr_type = id_addr->type & 0x1;
 100f37e:	eb06 0108 	add.w	r1, r6, r8
 100f382:	ea4f 0a8b 	mov.w	sl, fp, lsl #2
	if (rl[i].pirk) {
 100f386:	d518      	bpl.n	100f3ba <ll_rl_add+0xd2>
		rl[i].pirk_idx = peer_irk_count;
 100f388:	f8df c0c0 	ldr.w	ip, [pc, #192]	; 100f44c <ll_rl_add+0x164>
 100f38c:	4a2d      	ldr	r2, [pc, #180]	; (100f444 <ll_rl_add+0x15c>)
 100f38e:	f89c 3000 	ldrb.w	r3, [ip]
		peer_irk_rl_ids[peer_irk_count] = i;
 100f392:	f8df e0bc 	ldr.w	lr, [pc, #188]	; 100f450 <ll_rl_add+0x168>
 100f396:	eb02 1203 	add.w	r2, r2, r3, lsl #4
		rl[i].pirk_idx = peer_irk_count;
 100f39a:	75cb      	strb	r3, [r1, #23]
		sys_memcpy_swap(peer_irks[peer_irk_count++], pirk, IRK_SIZE);
 100f39c:	1c59      	adds	r1, r3, #1
 100f39e:	f88c 1000 	strb.w	r1, [ip]
		peer_irk_rl_ids[peer_irk_count] = i;
 100f3a2:	f80e b003 	strb.w	fp, [lr, r3]
	psrc += length - 1;
 100f3a6:	3a01      	subs	r2, #1
 100f3a8:	f105 030f 	add.w	r3, r5, #15
	for (; length > 0; length--) {
 100f3ac:	1e69      	subs	r1, r5, #1
		*pdst++ = *psrc--;
 100f3ae:	f813 5901 	ldrb.w	r5, [r3], #-1
	for (; length > 0; length--) {
 100f3b2:	428b      	cmp	r3, r1
		*pdst++ = *psrc--;
 100f3b4:	f802 5f01 	strb.w	r5, [r2, #1]!
	for (; length > 0; length--) {
 100f3b8:	d1f9      	bne.n	100f3ae <ll_rl_add+0xc6>
	if (rl[i].lirk) {
 100f3ba:	bb90      	cbnz	r0, 100f422 <ll_rl_add+0x13a>
	memset(rl[i].curr_rpa.val, 0x00, sizeof(rl[i].curr_rpa));
 100f3bc:	f108 0018 	add.w	r0, r8, #24
 100f3c0:	2206      	movs	r2, #6
 100f3c2:	2100      	movs	r1, #0
 100f3c4:	eb0a 040b 	add.w	r4, sl, fp
 100f3c8:	4430      	add	r0, r6
 100f3ca:	f007 faa0 	bl	101690e <memset>
	rl[i].rpas_ready = 0U;
 100f3ce:	f816 3034 	ldrb.w	r3, [r6, r4, lsl #3]
 100f3d2:	00e4      	lsls	r4, r4, #3
 100f3d4:	f023 0312 	bic.w	r3, r3, #18
 100f3d8:	5533      	strb	r3, [r6, r4]
	j = wl_find(id_addr->type, id_addr->a.val, NULL);
 100f3da:	4649      	mov	r1, r9
 100f3dc:	2200      	movs	r2, #0
 100f3de:	7838      	ldrb	r0, [r7, #0]
 100f3e0:	f7ff fb12 	bl	100ea08 <wl_find>
	if (j < ARRAY_SIZE(wl)) {
 100f3e4:	2807      	cmp	r0, #7
 100f3e6:	d815      	bhi.n	100f414 <ll_rl_add+0x12c>
		rl[i].wl = 1U;
 100f3e8:	5d33      	ldrb	r3, [r6, r4]
		wl[j].rl_idx = i;
 100f3ea:	4a17      	ldr	r2, [pc, #92]	; (100f448 <ll_rl_add+0x160>)
		rl[i].wl = 1U;
 100f3ec:	f043 0320 	orr.w	r3, r3, #32
		wl[j].rl_idx = i;
 100f3f0:	eb02 00c0 	add.w	r0, r2, r0, lsl #3
 100f3f4:	f880 b001 	strb.w	fp, [r0, #1]
		rl[i].wl = 1U;
 100f3f8:	5533      	strb	r3, [r6, r4]
	return 0;
 100f3fa:	2000      	movs	r0, #0
	rl[i].taken = 1U;
 100f3fc:	44da      	add	sl, fp
 100f3fe:	f816 303a 	ldrb.w	r3, [r6, sl, lsl #3]
 100f402:	f043 0301 	orr.w	r3, r3, #1
 100f406:	f806 303a 	strb.w	r3, [r6, sl, lsl #3]
}
 100f40a:	b003      	add	sp, #12
 100f40c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return BT_HCI_ERR_MEM_CAPACITY_EXCEEDED;
 100f410:	2007      	movs	r0, #7
 100f412:	e774      	b.n	100f2fe <ll_rl_add+0x16>
		rl[i].wl = 0U;
 100f414:	5d33      	ldrb	r3, [r6, r4]
 100f416:	f36f 1345 	bfc	r3, #5, #1
 100f41a:	5533      	strb	r3, [r6, r4]
 100f41c:	e7ed      	b.n	100f3fa <ll_rl_add+0x112>
		return BT_HCI_ERR_INVALID_PARAM;
 100f41e:	2012      	movs	r0, #18
 100f420:	e76d      	b.n	100f2fe <ll_rl_add+0x16>
		memcpy(rl[i].local_irk, lirk, IRK_SIZE);
 100f422:	f108 0007 	add.w	r0, r8, #7
 100f426:	2210      	movs	r2, #16
 100f428:	4621      	mov	r1, r4
 100f42a:	4430      	add	r0, r6
 100f42c:	f007 fa44 	bl	10168b8 <memcpy>
		rl[i].local_rpa = NULL;
 100f430:	2200      	movs	r2, #0
 100f432:	eb0a 030b 	add.w	r3, sl, fp
 100f436:	eb06 03c3 	add.w	r3, r6, r3, lsl #3
 100f43a:	625a      	str	r2, [r3, #36]	; 0x24
 100f43c:	e7be      	b.n	100f3bc <ll_rl_add+0xd4>
 100f43e:	bf00      	nop
 100f440:	21003aa4 	.word	0x21003aa4
 100f444:	21003a24 	.word	0x21003a24
 100f448:	21003c3c 	.word	0x21003c3c
 100f44c:	210066f2 	.word	0x210066f2
 100f450:	21003a1c 	.word	0x21003a1c

0100f454 <ll_rl_remove>:
{
 100f454:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 100f458:	4605      	mov	r5, r0
 100f45a:	b083      	sub	sp, #12
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
 100f45c:	2000      	movs	r0, #0
 100f45e:	f7fb fb8b 	bl	100ab78 <ull_adv_is_enabled>
		? 0 : 1;
 100f462:	b118      	cbz	r0, 100f46c <ll_rl_remove+0x18>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100f464:	200c      	movs	r0, #12
}
 100f466:	b003      	add	sp, #12
 100f468:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 100f46c:	4604      	mov	r4, r0
 100f46e:	f7ff fb7d 	bl	100eb6c <rl_access_check.part.0>
	if (!rl_access_check(false)) {
 100f472:	2800      	cmp	r0, #0
 100f474:	d0f6      	beq.n	100f464 <ll_rl_remove+0x10>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
 100f476:	462f      	mov	r7, r5
 100f478:	f817 0b01 	ldrb.w	r0, [r7], #1
 100f47c:	4622      	mov	r2, r4
 100f47e:	4639      	mov	r1, r7
 100f480:	f7ff fe8e 	bl	100f1a0 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
 100f484:	2807      	cmp	r0, #7
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
 100f486:	4606      	mov	r6, r0
	if (i < ARRAY_SIZE(rl)) {
 100f488:	d903      	bls.n	100f492 <ll_rl_remove+0x3e>
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100f48a:	2002      	movs	r0, #2
}
 100f48c:	b003      	add	sp, #12
 100f48e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if (rl[i].pirk) {
 100f492:	f8df 80bc 	ldr.w	r8, [pc, #188]	; 100f550 <ll_rl_remove+0xfc>
 100f496:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 100f49a:	f818 2033 	ldrb.w	r2, [r8, r3, lsl #3]
 100f49e:	ea4f 0980 	mov.w	r9, r0, lsl #2
 100f4a2:	0752      	lsls	r2, r2, #29
 100f4a4:	eb08 03c3 	add.w	r3, r8, r3, lsl #3
 100f4a8:	d52e      	bpl.n	100f508 <ll_rl_remove+0xb4>
			u8_t pi = rl[i].pirk_idx, pj = peer_irk_count - 1;
 100f4aa:	f8df a0a8 	ldr.w	sl, [pc, #168]	; 100f554 <ll_rl_remove+0x100>
 100f4ae:	f89a 2000 	ldrb.w	r2, [sl]
 100f4b2:	3a01      	subs	r2, #1
			if (pj && pi != pj) {
 100f4b4:	f012 0bff 	ands.w	fp, r2, #255	; 0xff
 100f4b8:	d023      	beq.n	100f502 <ll_rl_remove+0xae>
			u8_t pi = rl[i].pirk_idx, pj = peer_irk_count - 1;
 100f4ba:	7ddb      	ldrb	r3, [r3, #23]
			if (pj && pi != pj) {
 100f4bc:	455b      	cmp	r3, fp
 100f4be:	d021      	beq.n	100f504 <ll_rl_remove+0xb0>
				memcpy(peer_irks[pi], peer_irks[pj], IRK_SIZE);
 100f4c0:	4820      	ldr	r0, [pc, #128]	; (100f544 <ll_rl_remove+0xf0>)
 100f4c2:	2210      	movs	r2, #16
 100f4c4:	eb00 110b 	add.w	r1, r0, fp, lsl #4
 100f4c8:	eb00 1003 	add.w	r0, r0, r3, lsl #4
 100f4cc:	9301      	str	r3, [sp, #4]
 100f4ce:	f007 f9f3 	bl	10168b8 <memcpy>
 100f4d2:	9b01      	ldr	r3, [sp, #4]
					if (rl[k].taken && rl[k].pirk &&
 100f4d4:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 100f4d8:	f818 1032 	ldrb.w	r1, [r8, r2, lsl #3]
 100f4dc:	b2e0      	uxtb	r0, r4
 100f4de:	f011 0f01 	tst.w	r1, #1
 100f4e2:	eb08 02c2 	add.w	r2, r8, r2, lsl #3
 100f4e6:	f104 0401 	add.w	r4, r4, #1
 100f4ea:	d004      	beq.n	100f4f6 <ll_rl_remove+0xa2>
 100f4ec:	0749      	lsls	r1, r1, #29
 100f4ee:	d502      	bpl.n	100f4f6 <ll_rl_remove+0xa2>
 100f4f0:	7dd1      	ldrb	r1, [r2, #23]
 100f4f2:	4559      	cmp	r1, fp
 100f4f4:	d01f      	beq.n	100f536 <ll_rl_remove+0xe2>
				for (k = 0U;
 100f4f6:	2c08      	cmp	r4, #8
 100f4f8:	d1ec      	bne.n	100f4d4 <ll_rl_remove+0x80>
 100f4fa:	f89a 2000 	ldrb.w	r2, [sl]
 100f4fe:	3a01      	subs	r2, #1
 100f500:	e000      	b.n	100f504 <ll_rl_remove+0xb0>
 100f502:	465a      	mov	r2, fp
			peer_irk_count--;
 100f504:	f88a 2000 	strb.w	r2, [sl]
		j = wl_find(id_addr->type, id_addr->a.val, NULL);
 100f508:	4639      	mov	r1, r7
 100f50a:	2200      	movs	r2, #0
 100f50c:	7828      	ldrb	r0, [r5, #0]
 100f50e:	f7ff fa7b 	bl	100ea08 <wl_find>
		if (j < ARRAY_SIZE(wl)) {
 100f512:	2807      	cmp	r0, #7
 100f514:	d804      	bhi.n	100f520 <ll_rl_remove+0xcc>
			wl[j].rl_idx = FILTER_IDX_NONE;
 100f516:	22ff      	movs	r2, #255	; 0xff
 100f518:	4b0b      	ldr	r3, [pc, #44]	; (100f548 <ll_rl_remove+0xf4>)
 100f51a:	eb03 00c0 	add.w	r0, r3, r0, lsl #3
 100f51e:	7042      	strb	r2, [r0, #1]
		return 0;
 100f520:	2000      	movs	r0, #0
		rl[i].taken = 0U;
 100f522:	444e      	add	r6, r9
 100f524:	f818 3036 	ldrb.w	r3, [r8, r6, lsl #3]
 100f528:	f36f 0300 	bfc	r3, #0, #1
 100f52c:	f808 3036 	strb.w	r3, [r8, r6, lsl #3]
}
 100f530:	b003      	add	sp, #12
 100f532:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
						peer_irk_rl_ids[pi] = k;
 100f536:	4905      	ldr	r1, [pc, #20]	; (100f54c <ll_rl_remove+0xf8>)
						rl[k].pirk_idx = pi;
 100f538:	75d3      	strb	r3, [r2, #23]
						peer_irk_rl_ids[pi] = k;
 100f53a:	f89a 2000 	ldrb.w	r2, [sl]
 100f53e:	54c8      	strb	r0, [r1, r3]
						break;
 100f540:	3a01      	subs	r2, #1
 100f542:	e7df      	b.n	100f504 <ll_rl_remove+0xb0>
 100f544:	21003a24 	.word	0x21003a24
 100f548:	21003c3c 	.word	0x21003c3c
 100f54c:	21003a1c 	.word	0x21003a1c
 100f550:	21003aa4 	.word	0x21003aa4
 100f554:	210066f2 	.word	0x210066f2

0100f558 <ll_rl_crpa_set>:
{
 100f558:	b538      	push	{r3, r4, r5, lr}
 100f55a:	461c      	mov	r4, r3
	if ((crpa[5] & 0xc0) == 0x40) {
 100f55c:	795b      	ldrb	r3, [r3, #5]
 100f55e:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 100f562:	2b40      	cmp	r3, #64	; 0x40
 100f564:	d000      	beq.n	100f568 <ll_rl_crpa_set+0x10>
}
 100f566:	bd38      	pop	{r3, r4, r5, pc}
		if (id_addr) {
 100f568:	b119      	cbz	r1, 100f572 <ll_rl_crpa_set+0x1a>
			rl_idx = ull_filter_rl_find(id_addr_type, id_addr, NULL);
 100f56a:	2200      	movs	r2, #0
 100f56c:	f7ff fe18 	bl	100f1a0 <ull_filter_rl_find>
 100f570:	4602      	mov	r2, r0
		if (rl_idx < ARRAY_SIZE(rl) && rl[rl_idx].taken) {
 100f572:	2a07      	cmp	r2, #7
 100f574:	d8f7      	bhi.n	100f566 <ll_rl_crpa_set+0xe>
 100f576:	4808      	ldr	r0, [pc, #32]	; (100f598 <ll_rl_crpa_set+0x40>)
 100f578:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 100f57c:	f810 3032 	ldrb.w	r3, [r0, r2, lsl #3]
 100f580:	00d2      	lsls	r2, r2, #3
 100f582:	07db      	lsls	r3, r3, #31
 100f584:	d5ef      	bpl.n	100f566 <ll_rl_crpa_set+0xe>
			memcpy(rl[rl_idx].curr_rpa.val, crpa,
 100f586:	3218      	adds	r2, #24
 100f588:	4621      	mov	r1, r4
}
 100f58a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			memcpy(rl[rl_idx].curr_rpa.val, crpa,
 100f58e:	4410      	add	r0, r2
 100f590:	2206      	movs	r2, #6
 100f592:	f007 b991 	b.w	10168b8 <memcpy>
 100f596:	bf00      	nop
 100f598:	21003aa4 	.word	0x21003aa4

0100f59c <ll_rl_crpa_get>:
{
 100f59c:	b538      	push	{r3, r4, r5, lr}
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
 100f59e:	4603      	mov	r3, r0
 100f5a0:	f813 0b01 	ldrb.w	r0, [r3], #1
{
 100f5a4:	460c      	mov	r4, r1
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
 100f5a6:	2200      	movs	r2, #0
 100f5a8:	4619      	mov	r1, r3
 100f5aa:	f7ff fdf9 	bl	100f1a0 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl) &&
 100f5ae:	2807      	cmp	r0, #7
 100f5b0:	d901      	bls.n	100f5b6 <ll_rl_crpa_get+0x1a>
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100f5b2:	2002      	movs	r0, #2
}
 100f5b4:	bd38      	pop	{r3, r4, r5, pc}
	    mem_nz(rl[i].curr_rpa.val, sizeof(rl[i].curr_rpa.val))) {
 100f5b6:	4d0a      	ldr	r5, [pc, #40]	; (100f5e0 <ll_rl_crpa_get+0x44>)
 100f5b8:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 100f5bc:	eb05 00c0 	add.w	r0, r5, r0, lsl #3
 100f5c0:	f100 0518 	add.w	r5, r0, #24
 100f5c4:	4628      	mov	r0, r5
 100f5c6:	2106      	movs	r1, #6
 100f5c8:	f7f6 fb74 	bl	1005cb4 <mem_nz>
	if (i < ARRAY_SIZE(rl) &&
 100f5cc:	2800      	cmp	r0, #0
 100f5ce:	d0f0      	beq.n	100f5b2 <ll_rl_crpa_get+0x16>
 100f5d0:	4629      	mov	r1, r5
 100f5d2:	4620      	mov	r0, r4
 100f5d4:	2206      	movs	r2, #6
 100f5d6:	f007 f96f 	bl	10168b8 <memcpy>
		return 0;
 100f5da:	2000      	movs	r0, #0
}
 100f5dc:	bd38      	pop	{r3, r4, r5, pc}
 100f5de:	bf00      	nop
 100f5e0:	21003aa4 	.word	0x21003aa4

0100f5e4 <ll_rl_lrpa_get>:
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
 100f5e4:	4603      	mov	r3, r0
{
 100f5e6:	b510      	push	{r4, lr}
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
 100f5e8:	f813 0b01 	ldrb.w	r0, [r3], #1
{
 100f5ec:	460c      	mov	r4, r1
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
 100f5ee:	2200      	movs	r2, #0
 100f5f0:	4619      	mov	r1, r3
 100f5f2:	f7ff fdd5 	bl	100f1a0 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
 100f5f6:	2807      	cmp	r0, #7
 100f5f8:	d901      	bls.n	100f5fe <ll_rl_lrpa_get+0x1a>
	return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100f5fa:	2002      	movs	r0, #2
}
 100f5fc:	bd10      	pop	{r4, pc}
		bt_addr_copy(lrpa, rl[i].local_rpa);
 100f5fe:	4b06      	ldr	r3, [pc, #24]	; (100f618 <ll_rl_lrpa_get+0x34>)
 100f600:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 100f604:	eb03 03c0 	add.w	r3, r3, r0, lsl #3
 100f608:	2206      	movs	r2, #6
 100f60a:	4620      	mov	r0, r4
 100f60c:	6a59      	ldr	r1, [r3, #36]	; 0x24
 100f60e:	f007 f953 	bl	10168b8 <memcpy>
		return 0;
 100f612:	2000      	movs	r0, #0
}
 100f614:	bd10      	pop	{r4, pc}
 100f616:	bf00      	nop
 100f618:	21003aa4 	.word	0x21003aa4

0100f61c <ll_priv_mode_set>:
{
 100f61c:	b570      	push	{r4, r5, r6, lr}
 100f61e:	4605      	mov	r5, r0
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
 100f620:	2000      	movs	r0, #0
{
 100f622:	460e      	mov	r6, r1
	return ((IS_ENABLED(CONFIG_BT_BROADCASTER) && ull_adv_is_enabled(0)) ||
 100f624:	f7fb faa8 	bl	100ab78 <ull_adv_is_enabled>
		? 0 : 1;
 100f628:	b108      	cbz	r0, 100f62e <ll_priv_mode_set+0x12>
		return BT_HCI_ERR_CMD_DISALLOWED;
 100f62a:	200c      	movs	r0, #12
}
 100f62c:	bd70      	pop	{r4, r5, r6, pc}
 100f62e:	4604      	mov	r4, r0
 100f630:	f7ff fa9c 	bl	100eb6c <rl_access_check.part.0>
	if (!rl_access_check(false)) {
 100f634:	2800      	cmp	r0, #0
 100f636:	d0f8      	beq.n	100f62a <ll_priv_mode_set+0xe>
	i = ull_filter_rl_find(id_addr->type, id_addr->a.val, NULL);
 100f638:	4629      	mov	r1, r5
 100f63a:	4622      	mov	r2, r4
 100f63c:	f811 0b01 	ldrb.w	r0, [r1], #1
 100f640:	f7ff fdae 	bl	100f1a0 <ull_filter_rl_find>
	if (i < ARRAY_SIZE(rl)) {
 100f644:	2807      	cmp	r0, #7
 100f646:	d81a      	bhi.n	100f67e <ll_priv_mode_set+0x62>
		switch (mode) {
 100f648:	b176      	cbz	r6, 100f668 <ll_priv_mode_set+0x4c>
 100f64a:	2e01      	cmp	r6, #1
 100f64c:	d10a      	bne.n	100f664 <ll_priv_mode_set+0x48>
			rl[i].dev = 1U;
 100f64e:	490d      	ldr	r1, [pc, #52]	; (100f684 <ll_priv_mode_set+0x68>)
 100f650:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 100f654:	f811 2033 	ldrb.w	r2, [r1, r3, lsl #3]
	return 0;
 100f658:	4620      	mov	r0, r4
			rl[i].dev = 1U;
 100f65a:	f042 0210 	orr.w	r2, r2, #16
 100f65e:	f801 2033 	strb.w	r2, [r1, r3, lsl #3]
}
 100f662:	bd70      	pop	{r4, r5, r6, pc}
		switch (mode) {
 100f664:	2012      	movs	r0, #18
}
 100f666:	bd70      	pop	{r4, r5, r6, pc}
			rl[i].dev = 0U;
 100f668:	4a06      	ldr	r2, [pc, #24]	; (100f684 <ll_priv_mode_set+0x68>)
 100f66a:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 100f66e:	f812 1033 	ldrb.w	r1, [r2, r3, lsl #3]
	return 0;
 100f672:	4630      	mov	r0, r6
			rl[i].dev = 0U;
 100f674:	f366 1104 	bfi	r1, r6, #4, #1
 100f678:	f802 1033 	strb.w	r1, [r2, r3, lsl #3]
}
 100f67c:	bd70      	pop	{r4, r5, r6, pc}
		return BT_HCI_ERR_UNKNOWN_CONN_ID;
 100f67e:	2002      	movs	r0, #2
}
 100f680:	bd70      	pop	{r4, r5, r6, pc}
 100f682:	bf00      	nop
 100f684:	21003aa4 	.word	0x21003aa4

0100f688 <ull_filter_reset>:
	wl_anon = 0U;
 100f688:	2200      	movs	r2, #0
	for (int i = 0; i < WL_SIZE; i++) {
 100f68a:	4613      	mov	r3, r2
{
 100f68c:	b4f0      	push	{r4, r5, r6, r7}
	wl_anon = 0U;
 100f68e:	4d30      	ldr	r5, [pc, #192]	; (100f750 <ull_filter_reset+0xc8>)
 100f690:	4c30      	ldr	r4, [pc, #192]	; (100f754 <ull_filter_reset+0xcc>)
 100f692:	4931      	ldr	r1, [pc, #196]	; (100f758 <ull_filter_reset+0xd0>)
 100f694:	702a      	strb	r2, [r5, #0]
		u8_t j = wl[i].rl_idx;
 100f696:	eb04 02c3 	add.w	r2, r4, r3, lsl #3
 100f69a:	7852      	ldrb	r2, [r2, #1]
		if (j < ARRAY_SIZE(rl)) {
 100f69c:	2a07      	cmp	r2, #7
 100f69e:	d807      	bhi.n	100f6b0 <ull_filter_reset+0x28>
			rl[j].wl = 0U;
 100f6a0:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 100f6a4:	f811 5032 	ldrb.w	r5, [r1, r2, lsl #3]
 100f6a8:	f36f 1545 	bfc	r5, #5, #1
 100f6ac:	f801 5032 	strb.w	r5, [r1, r2, lsl #3]
		wl[i].taken = 0U;
 100f6b0:	f814 2033 	ldrb.w	r2, [r4, r3, lsl #3]
 100f6b4:	f36f 0200 	bfc	r2, #0, #1
 100f6b8:	f804 2033 	strb.w	r2, [r4, r3, lsl #3]
	for (int i = 0; i < WL_SIZE; i++) {
 100f6bc:	3301      	adds	r3, #1
 100f6be:	2b08      	cmp	r3, #8
 100f6c0:	d1e9      	bne.n	100f696 <ull_filter_reset+0xe>
	rl_enable = 0U;
 100f6c2:	2300      	movs	r3, #0
	rpa_last_ms = -1;
 100f6c4:	f04f 36ff 	mov.w	r6, #4294967295
 100f6c8:	f04f 37ff 	mov.w	r7, #4294967295
	rl_enable = 0U;
 100f6cc:	4a23      	ldr	r2, [pc, #140]	; (100f75c <ull_filter_reset+0xd4>)
		rl[i].taken = 0U;
 100f6ce:	780c      	ldrb	r4, [r1, #0]
	rl_enable = 0U;
 100f6d0:	7013      	strb	r3, [r2, #0]
	peer_irk_count = 0U;
 100f6d2:	4a23      	ldr	r2, [pc, #140]	; (100f760 <ull_filter_reset+0xd8>)
		rl[i].taken = 0U;
 100f6d4:	f363 0400 	bfi	r4, r3, #0, #1
	peer_irk_count = 0U;
 100f6d8:	7013      	strb	r3, [r2, #0]
		rl[i].taken = 0U;
 100f6da:	f891 2028 	ldrb.w	r2, [r1, #40]	; 0x28
 100f6de:	700c      	strb	r4, [r1, #0]
 100f6e0:	f363 0200 	bfi	r2, r3, #0, #1
 100f6e4:	f891 4050 	ldrb.w	r4, [r1, #80]	; 0x50
 100f6e8:	f881 2028 	strb.w	r2, [r1, #40]	; 0x28
 100f6ec:	f891 2078 	ldrb.w	r2, [r1, #120]	; 0x78
 100f6f0:	f363 0400 	bfi	r4, r3, #0, #1
 100f6f4:	f363 0200 	bfi	r2, r3, #0, #1
 100f6f8:	f881 4050 	strb.w	r4, [r1, #80]	; 0x50
 100f6fc:	f881 2078 	strb.w	r2, [r1, #120]	; 0x78
 100f700:	f891 40a0 	ldrb.w	r4, [r1, #160]	; 0xa0
 100f704:	f891 20c8 	ldrb.w	r2, [r1, #200]	; 0xc8
 100f708:	f363 0400 	bfi	r4, r3, #0, #1
 100f70c:	f363 0200 	bfi	r2, r3, #0, #1
 100f710:	f881 40a0 	strb.w	r4, [r1, #160]	; 0xa0
 100f714:	f881 20c8 	strb.w	r2, [r1, #200]	; 0xc8
 100f718:	f891 40f0 	ldrb.w	r4, [r1, #240]	; 0xf0
 100f71c:	f891 2118 	ldrb.w	r2, [r1, #280]	; 0x118
 100f720:	f363 0400 	bfi	r4, r3, #0, #1
 100f724:	f363 0200 	bfi	r2, r3, #0, #1
 100f728:	f881 40f0 	strb.w	r4, [r1, #240]	; 0xf0
	rpa_timeout_ms = DEFAULT_RPA_TIMEOUT_MS;
 100f72c:	4b0d      	ldr	r3, [pc, #52]	; (100f764 <ull_filter_reset+0xdc>)
	rpa_last_ms = -1;
 100f72e:	4c0e      	ldr	r4, [pc, #56]	; (100f768 <ull_filter_reset+0xe0>)
		rl[i].taken = 0U;
 100f730:	f881 2118 	strb.w	r2, [r1, #280]	; 0x118
	rpa_timeout_ms = DEFAULT_RPA_TIMEOUT_MS;
 100f734:	4a0d      	ldr	r2, [pc, #52]	; (100f76c <ull_filter_reset+0xe4>)
	rpa_last_ms = -1;
 100f736:	e9c4 6700 	strd	r6, r7, [r4]
	rpa_timeout_ms = DEFAULT_RPA_TIMEOUT_MS;
 100f73a:	601a      	str	r2, [r3, #0]
	if (init) {
 100f73c:	b120      	cbz	r0, 100f748 <ull_filter_reset+0xc0>
}
 100f73e:	bcf0      	pop	{r4, r5, r6, r7}
		k_delayed_work_init(&rpa_work, rpa_timeout);
 100f740:	490b      	ldr	r1, [pc, #44]	; (100f770 <ull_filter_reset+0xe8>)
 100f742:	480c      	ldr	r0, [pc, #48]	; (100f774 <ull_filter_reset+0xec>)
 100f744:	f008 ba39 	b.w	1017bba <k_delayed_work_init>
		k_delayed_work_cancel(&rpa_work);
 100f748:	480a      	ldr	r0, [pc, #40]	; (100f774 <ull_filter_reset+0xec>)
}
 100f74a:	bcf0      	pop	{r4, r5, r6, r7}
		k_delayed_work_cancel(&rpa_work);
 100f74c:	f008 ba3d 	b.w	1017bca <k_delayed_work_cancel>
 100f750:	210066f4 	.word	0x210066f4
 100f754:	21003c3c 	.word	0x21003c3c
 100f758:	21003aa4 	.word	0x21003aa4
 100f75c:	210066f3 	.word	0x210066f3
 100f760:	210066f2 	.word	0x210066f2
 100f764:	21003c18 	.word	0x21003c18
 100f768:	210006c8 	.word	0x210006c8
 100f76c:	000dbba0 	.word	0x000dbba0
 100f770:	0100f161 	.word	0x0100f161
 100f774:	21003c1c 	.word	0x21003c1c

0100f778 <ull_filter_lll_lrpa_used>:
	return rl_idx < ARRAY_SIZE(rl) && rl[rl_idx].lirk;
 100f778:	2807      	cmp	r0, #7
 100f77a:	d807      	bhi.n	100f78c <ull_filter_lll_lrpa_used+0x14>
 100f77c:	4b04      	ldr	r3, [pc, #16]	; (100f790 <ull_filter_lll_lrpa_used+0x18>)
 100f77e:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 100f782:	f813 0030 	ldrb.w	r0, [r3, r0, lsl #3]
 100f786:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 100f78a:	4770      	bx	lr
 100f78c:	2000      	movs	r0, #0
}
 100f78e:	4770      	bx	lr
 100f790:	21003aa4 	.word	0x21003aa4

0100f794 <ull_filter_lll_lrpa_get>:
	if ((rl_idx >= ARRAY_SIZE(rl)) || !rl[rl_idx].lirk ||
 100f794:	2807      	cmp	r0, #7
 100f796:	d80c      	bhi.n	100f7b2 <ull_filter_lll_lrpa_get+0x1e>
 100f798:	4907      	ldr	r1, [pc, #28]	; (100f7b8 <ull_filter_lll_lrpa_get+0x24>)
 100f79a:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 100f79e:	f811 3030 	ldrb.w	r3, [r1, r0, lsl #3]
 100f7a2:	00c0      	lsls	r0, r0, #3
 100f7a4:	071a      	lsls	r2, r3, #28
 100f7a6:	d504      	bpl.n	100f7b2 <ull_filter_lll_lrpa_get+0x1e>
 100f7a8:	079b      	lsls	r3, r3, #30
 100f7aa:	d502      	bpl.n	100f7b2 <ull_filter_lll_lrpa_get+0x1e>
	return rl[rl_idx].local_rpa;
 100f7ac:	4408      	add	r0, r1
 100f7ae:	6a40      	ldr	r0, [r0, #36]	; 0x24
 100f7b0:	4770      	bx	lr
		return NULL;
 100f7b2:	2000      	movs	r0, #0
 100f7b4:	4770      	bx	lr
 100f7b6:	bf00      	nop
 100f7b8:	21003aa4 	.word	0x21003aa4

0100f7bc <ull_filter_lll_irks_get>:
{
 100f7bc:	4603      	mov	r3, r0
	*count = peer_irk_count;
 100f7be:	4a02      	ldr	r2, [pc, #8]	; (100f7c8 <ull_filter_lll_irks_get+0xc>)
}
 100f7c0:	4802      	ldr	r0, [pc, #8]	; (100f7cc <ull_filter_lll_irks_get+0x10>)
	*count = peer_irk_count;
 100f7c2:	7812      	ldrb	r2, [r2, #0]
 100f7c4:	701a      	strb	r2, [r3, #0]
}
 100f7c6:	4770      	bx	lr
 100f7c8:	210066f2 	.word	0x210066f2
 100f7cc:	21003a24 	.word	0x21003a24

0100f7d0 <ull_filter_lll_rl_idx>:
{
 100f7d0:	b538      	push	{r3, r4, r5, lr}
 100f7d2:	460c      	mov	r4, r1
	if (whitelist) {
 100f7d4:	b150      	cbz	r0, 100f7ec <ull_filter_lll_rl_idx+0x1c>
		LL_ASSERT(devmatch_id < ARRAY_SIZE(wl));
 100f7d6:	2907      	cmp	r1, #7
 100f7d8:	d81a      	bhi.n	100f810 <ull_filter_lll_rl_idx+0x40>
		LL_ASSERT(wl[devmatch_id].taken);
 100f7da:	4d1a      	ldr	r5, [pc, #104]	; (100f844 <ull_filter_lll_rl_idx+0x74>)
 100f7dc:	f815 3034 	ldrb.w	r3, [r5, r4, lsl #3]
 100f7e0:	07da      	lsls	r2, r3, #31
 100f7e2:	d51f      	bpl.n	100f824 <ull_filter_lll_rl_idx+0x54>
		i = wl[devmatch_id].rl_idx;
 100f7e4:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
 100f7e8:	7860      	ldrb	r0, [r4, #1]
}
 100f7ea:	bd38      	pop	{r3, r4, r5, pc}
		LL_ASSERT(devmatch_id < ARRAY_SIZE(rl));
 100f7ec:	2907      	cmp	r1, #7
 100f7ee:	d822      	bhi.n	100f836 <ull_filter_lll_rl_idx+0x66>
		LL_ASSERT(rl[i].taken);
 100f7f0:	4b15      	ldr	r3, [pc, #84]	; (100f848 <ull_filter_lll_rl_idx+0x78>)
 100f7f2:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 100f7f6:	f813 3032 	ldrb.w	r3, [r3, r2, lsl #3]
 100f7fa:	07db      	lsls	r3, r3, #31
 100f7fc:	d501      	bpl.n	100f802 <ull_filter_lll_rl_idx+0x32>
 100f7fe:	4620      	mov	r0, r4
}
 100f800:	bd38      	pop	{r3, r4, r5, pc}
		LL_ASSERT(rl[i].taken);
 100f802:	f240 21b2 	movw	r1, #690	; 0x2b2
 100f806:	4811      	ldr	r0, [pc, #68]	; (100f84c <ull_filter_lll_rl_idx+0x7c>)
 100f808:	f7f3 febe 	bl	1003588 <bt_ctlr_assert_handle>
 100f80c:	4620      	mov	r0, r4
}
 100f80e:	bd38      	pop	{r3, r4, r5, pc}
		LL_ASSERT(wl[devmatch_id].taken);
 100f810:	4d0c      	ldr	r5, [pc, #48]	; (100f844 <ull_filter_lll_rl_idx+0x74>)
		LL_ASSERT(devmatch_id < ARRAY_SIZE(wl));
 100f812:	f44f 712b 	mov.w	r1, #684	; 0x2ac
 100f816:	480d      	ldr	r0, [pc, #52]	; (100f84c <ull_filter_lll_rl_idx+0x7c>)
 100f818:	f7f3 feb6 	bl	1003588 <bt_ctlr_assert_handle>
		LL_ASSERT(wl[devmatch_id].taken);
 100f81c:	f815 3034 	ldrb.w	r3, [r5, r4, lsl #3]
 100f820:	07da      	lsls	r2, r3, #31
 100f822:	d4df      	bmi.n	100f7e4 <ull_filter_lll_rl_idx+0x14>
 100f824:	4809      	ldr	r0, [pc, #36]	; (100f84c <ull_filter_lll_rl_idx+0x7c>)
 100f826:	f240 21ad 	movw	r1, #685	; 0x2ad
		i = wl[devmatch_id].rl_idx;
 100f82a:	eb05 04c4 	add.w	r4, r5, r4, lsl #3
		LL_ASSERT(wl[devmatch_id].taken);
 100f82e:	f7f3 feab 	bl	1003588 <bt_ctlr_assert_handle>
		i = wl[devmatch_id].rl_idx;
 100f832:	7860      	ldrb	r0, [r4, #1]
 100f834:	e7d9      	b.n	100f7ea <ull_filter_lll_rl_idx+0x1a>
		LL_ASSERT(devmatch_id < ARRAY_SIZE(rl));
 100f836:	f44f 712c 	mov.w	r1, #688	; 0x2b0
 100f83a:	4804      	ldr	r0, [pc, #16]	; (100f84c <ull_filter_lll_rl_idx+0x7c>)
 100f83c:	f7f3 fea4 	bl	1003588 <bt_ctlr_assert_handle>
 100f840:	e7d6      	b.n	100f7f0 <ull_filter_lll_rl_idx+0x20>
 100f842:	bf00      	nop
 100f844:	21003c3c 	.word	0x21003c3c
 100f848:	21003aa4 	.word	0x21003aa4
 100f84c:	010188f4 	.word	0x010188f4

0100f850 <ull_filter_lll_rl_irk_idx>:
{
 100f850:	b510      	push	{r4, lr}
	LL_ASSERT(irkmatch_id < peer_irk_count);
 100f852:	4b14      	ldr	r3, [pc, #80]	; (100f8a4 <ull_filter_lll_rl_irk_idx+0x54>)
{
 100f854:	4604      	mov	r4, r0
	LL_ASSERT(irkmatch_id < peer_irk_count);
 100f856:	781b      	ldrb	r3, [r3, #0]
 100f858:	4283      	cmp	r3, r0
 100f85a:	d90c      	bls.n	100f876 <ull_filter_lll_rl_irk_idx+0x26>
	i = peer_irk_rl_ids[irkmatch_id];
 100f85c:	4b12      	ldr	r3, [pc, #72]	; (100f8a8 <ull_filter_lll_rl_irk_idx+0x58>)
 100f85e:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(i < CONFIG_BT_CTLR_RL_SIZE);
 100f860:	2c07      	cmp	r4, #7
 100f862:	d811      	bhi.n	100f888 <ull_filter_lll_rl_irk_idx+0x38>
	LL_ASSERT(rl[i].taken);
 100f864:	4b11      	ldr	r3, [pc, #68]	; (100f8ac <ull_filter_lll_rl_irk_idx+0x5c>)
 100f866:	eb04 0284 	add.w	r2, r4, r4, lsl #2
 100f86a:	f813 3032 	ldrb.w	r3, [r3, r2, lsl #3]
 100f86e:	07db      	lsls	r3, r3, #31
 100f870:	d510      	bpl.n	100f894 <ull_filter_lll_rl_irk_idx+0x44>
}
 100f872:	4620      	mov	r0, r4
 100f874:	bd10      	pop	{r4, pc}
	LL_ASSERT(irkmatch_id < peer_irk_count);
 100f876:	f44f 712f 	mov.w	r1, #700	; 0x2bc
 100f87a:	480d      	ldr	r0, [pc, #52]	; (100f8b0 <ull_filter_lll_rl_irk_idx+0x60>)
 100f87c:	f7f3 fe84 	bl	1003588 <bt_ctlr_assert_handle>
	i = peer_irk_rl_ids[irkmatch_id];
 100f880:	4b09      	ldr	r3, [pc, #36]	; (100f8a8 <ull_filter_lll_rl_irk_idx+0x58>)
 100f882:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(i < CONFIG_BT_CTLR_RL_SIZE);
 100f884:	2c07      	cmp	r4, #7
 100f886:	d9ed      	bls.n	100f864 <ull_filter_lll_rl_irk_idx+0x14>
 100f888:	f240 21be 	movw	r1, #702	; 0x2be
 100f88c:	4808      	ldr	r0, [pc, #32]	; (100f8b0 <ull_filter_lll_rl_irk_idx+0x60>)
 100f88e:	f7f3 fe7b 	bl	1003588 <bt_ctlr_assert_handle>
 100f892:	e7e7      	b.n	100f864 <ull_filter_lll_rl_irk_idx+0x14>
	LL_ASSERT(rl[i].taken);
 100f894:	f240 21bf 	movw	r1, #703	; 0x2bf
 100f898:	4805      	ldr	r0, [pc, #20]	; (100f8b0 <ull_filter_lll_rl_irk_idx+0x60>)
 100f89a:	f7f3 fe75 	bl	1003588 <bt_ctlr_assert_handle>
}
 100f89e:	4620      	mov	r0, r4
 100f8a0:	bd10      	pop	{r4, pc}
 100f8a2:	bf00      	nop
 100f8a4:	210066f2 	.word	0x210066f2
 100f8a8:	21003a1c 	.word	0x21003a1c
 100f8ac:	21003aa4 	.word	0x21003aa4
 100f8b0:	010188f4 	.word	0x010188f4

0100f8b4 <ull_filter_lll_irk_whitelisted>:
	if (rl_idx >= ARRAY_SIZE(rl)) {
 100f8b4:	2807      	cmp	r0, #7
 100f8b6:	d81b      	bhi.n	100f8f0 <ull_filter_lll_irk_whitelisted+0x3c>
{
 100f8b8:	b570      	push	{r4, r5, r6, lr}
	LL_ASSERT(rl[rl_idx].taken);
 100f8ba:	4e0e      	ldr	r6, [pc, #56]	; (100f8f4 <ull_filter_lll_irk_whitelisted+0x40>)
 100f8bc:	eb00 0380 	add.w	r3, r0, r0, lsl #2
 100f8c0:	f816 3033 	ldrb.w	r3, [r6, r3, lsl #3]
 100f8c4:	4604      	mov	r4, r0
 100f8c6:	07db      	lsls	r3, r3, #31
 100f8c8:	ea4f 0580 	mov.w	r5, r0, lsl #2
 100f8cc:	d505      	bpl.n	100f8da <ull_filter_lll_irk_whitelisted+0x26>
	return rl[rl_idx].wl;
 100f8ce:	442c      	add	r4, r5
 100f8d0:	f816 0034 	ldrb.w	r0, [r6, r4, lsl #3]
 100f8d4:	f3c0 1040 	ubfx	r0, r0, #5, #1
}
 100f8d8:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(rl[rl_idx].taken);
 100f8da:	f240 21ca 	movw	r1, #714	; 0x2ca
 100f8de:	4806      	ldr	r0, [pc, #24]	; (100f8f8 <ull_filter_lll_irk_whitelisted+0x44>)
	return rl[rl_idx].wl;
 100f8e0:	442c      	add	r4, r5
	LL_ASSERT(rl[rl_idx].taken);
 100f8e2:	f7f3 fe51 	bl	1003588 <bt_ctlr_assert_handle>
	return rl[rl_idx].wl;
 100f8e6:	f816 0034 	ldrb.w	r0, [r6, r4, lsl #3]
 100f8ea:	f3c0 1040 	ubfx	r0, r0, #5, #1
}
 100f8ee:	bd70      	pop	{r4, r5, r6, pc}
		return false;
 100f8f0:	2000      	movs	r0, #0
}
 100f8f2:	4770      	bx	lr
 100f8f4:	21003aa4 	.word	0x21003aa4
 100f8f8:	010188f4 	.word	0x010188f4

0100f8fc <ull_filter_lll_get>:
		return &wl_filter;
 100f8fc:	4a03      	ldr	r2, [pc, #12]	; (100f90c <ull_filter_lll_get+0x10>)
 100f8fe:	4b04      	ldr	r3, [pc, #16]	; (100f910 <ull_filter_lll_get+0x14>)
}
 100f900:	2800      	cmp	r0, #0
 100f902:	bf0c      	ite	eq
 100f904:	4610      	moveq	r0, r2
 100f906:	4618      	movne	r0, r3
 100f908:	4770      	bx	lr
 100f90a:	bf00      	nop
 100f90c:	21003be4 	.word	0x21003be4
 100f910:	21003c7c 	.word	0x21003c7c

0100f914 <ull_filter_lll_rl_idx_allowed>:
	if (!rl_enable || rl_idx >= ARRAY_SIZE(rl) || irkmatch_ok) {
 100f914:	4b10      	ldr	r3, [pc, #64]	; (100f958 <ull_filter_lll_rl_idx_allowed+0x44>)
 100f916:	781b      	ldrb	r3, [r3, #0]
 100f918:	b19b      	cbz	r3, 100f942 <ull_filter_lll_rl_idx_allowed+0x2e>
 100f91a:	2907      	cmp	r1, #7
{
 100f91c:	b570      	push	{r4, r5, r6, lr}
 100f91e:	460c      	mov	r4, r1
	if (!rl_enable || rl_idx >= ARRAY_SIZE(rl) || irkmatch_ok) {
 100f920:	d80d      	bhi.n	100f93e <ull_filter_lll_rl_idx_allowed+0x2a>
 100f922:	b960      	cbnz	r0, 100f93e <ull_filter_lll_rl_idx_allowed+0x2a>
	LL_ASSERT(rl[rl_idx].taken);
 100f924:	4e0d      	ldr	r6, [pc, #52]	; (100f95c <ull_filter_lll_rl_idx_allowed+0x48>)
 100f926:	eb01 0381 	add.w	r3, r1, r1, lsl #2
 100f92a:	f816 3033 	ldrb.w	r3, [r6, r3, lsl #3]
 100f92e:	008d      	lsls	r5, r1, #2
 100f930:	07da      	lsls	r2, r3, #31
 100f932:	d50b      	bpl.n	100f94c <ull_filter_lll_rl_idx_allowed+0x38>
	return !rl[rl_idx].pirk || rl[rl_idx].dev;
 100f934:	442c      	add	r4, r5
 100f936:	f816 0034 	ldrb.w	r0, [r6, r4, lsl #3]
 100f93a:	0743      	lsls	r3, r0, #29
 100f93c:	d403      	bmi.n	100f946 <ull_filter_lll_rl_idx_allowed+0x32>
		return true;
 100f93e:	2001      	movs	r0, #1
}
 100f940:	bd70      	pop	{r4, r5, r6, pc}
		return true;
 100f942:	2001      	movs	r0, #1
}
 100f944:	4770      	bx	lr
	return !rl[rl_idx].pirk || rl[rl_idx].dev;
 100f946:	f3c0 1000 	ubfx	r0, r0, #4, #1
}
 100f94a:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(rl[rl_idx].taken);
 100f94c:	f240 21f2 	movw	r1, #754	; 0x2f2
 100f950:	4803      	ldr	r0, [pc, #12]	; (100f960 <ull_filter_lll_rl_idx_allowed+0x4c>)
 100f952:	f7f3 fe19 	bl	1003588 <bt_ctlr_assert_handle>
 100f956:	e7ed      	b.n	100f934 <ull_filter_lll_rl_idx_allowed+0x20>
 100f958:	210066f3 	.word	0x210066f3
 100f95c:	21003aa4 	.word	0x21003aa4
 100f960:	010188f4 	.word	0x010188f4

0100f964 <ull_filter_lll_rl_addr_allowed>:
	if (!rl_enable || *rl_idx != FILTER_IDX_NONE) {
 100f964:	4b1c      	ldr	r3, [pc, #112]	; (100f9d8 <ull_filter_lll_rl_addr_allowed+0x74>)
 100f966:	781b      	ldrb	r3, [r3, #0]
 100f968:	b1fb      	cbz	r3, 100f9aa <ull_filter_lll_rl_addr_allowed+0x46>
 100f96a:	7813      	ldrb	r3, [r2, #0]
 100f96c:	2bff      	cmp	r3, #255	; 0xff
 100f96e:	d11c      	bne.n	100f9aa <ull_filter_lll_rl_addr_allowed+0x46>
{
 100f970:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (!rl_enable || *rl_idx != FILTER_IDX_NONE) {
 100f974:	2300      	movs	r3, #0
 100f976:	4606      	mov	r6, r0
 100f978:	4d18      	ldr	r5, [pc, #96]	; (100f9dc <ull_filter_lll_rl_addr_allowed+0x78>)
 100f97a:	1faf      	subs	r7, r5, #6
		if (rl[i].taken && (rl[i].id_addr_type == id_addr_type)) {
 100f97c:	eb03 0483 	add.w	r4, r3, r3, lsl #2
 100f980:	f817 4034 	ldrb.w	r4, [r7, r4, lsl #3]
 100f984:	fa5f fe83 	uxtb.w	lr, r3
 100f988:	f014 0001 	ands.w	r0, r4, #1
 100f98c:	ea4f 0c83 	mov.w	ip, r3, lsl #2
 100f990:	d003      	beq.n	100f99a <ull_filter_lll_rl_addr_allowed+0x36>
 100f992:	f3c4 1480 	ubfx	r4, r4, #6, #1
 100f996:	42b4      	cmp	r4, r6
 100f998:	d009      	beq.n	100f9ae <ull_filter_lll_rl_addr_allowed+0x4a>
	for (i = 0U; i < CONFIG_BT_CTLR_RL_SIZE; i++) {
 100f99a:	3301      	adds	r3, #1
 100f99c:	2b08      	cmp	r3, #8
 100f99e:	f105 0528 	add.w	r5, r5, #40	; 0x28
 100f9a2:	d1eb      	bne.n	100f97c <ull_filter_lll_rl_addr_allowed+0x18>
		return true;
 100f9a4:	2001      	movs	r0, #1
}
 100f9a6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		return true;
 100f9aa:	2001      	movs	r0, #1
}
 100f9ac:	4770      	bx	lr
			for (j = 0U; j < BDADDR_SIZE; j++) {
 100f9ae:	1fac      	subs	r4, r5, #6
 100f9b0:	f101 38ff 	add.w	r8, r1, #4294967295
				if (addr[j] != id_addr[j]) {
 100f9b4:	f814 af01 	ldrb.w	sl, [r4, #1]!
 100f9b8:	f818 9f01 	ldrb.w	r9, [r8, #1]!
 100f9bc:	45ca      	cmp	sl, r9
 100f9be:	d1ec      	bne.n	100f99a <ull_filter_lll_rl_addr_allowed+0x36>
			for (j = 0U; j < BDADDR_SIZE; j++) {
 100f9c0:	42ac      	cmp	r4, r5
 100f9c2:	d1f7      	bne.n	100f9b4 <ull_filter_lll_rl_addr_allowed+0x50>
				*rl_idx = i;
 100f9c4:	f882 e000 	strb.w	lr, [r2]
				return !rl[i].pirk || rl[i].dev;
 100f9c8:	4463      	add	r3, ip
 100f9ca:	f817 3033 	ldrb.w	r3, [r7, r3, lsl #3]
 100f9ce:	075a      	lsls	r2, r3, #29
 100f9d0:	d5e9      	bpl.n	100f9a6 <ull_filter_lll_rl_addr_allowed+0x42>
 100f9d2:	f3c3 1000 	ubfx	r0, r3, #4, #1
 100f9d6:	e7e6      	b.n	100f9a6 <ull_filter_lll_rl_addr_allowed+0x42>
 100f9d8:	210066f3 	.word	0x210066f3
 100f9dc:	21003aaa 	.word	0x21003aaa

0100f9e0 <ull_filter_lll_rl_addr_resolve>:
{
 100f9e0:	b430      	push	{r4, r5}
	if (!rl_enable || rl_idx >= ARRAY_SIZE(rl) || !rl[rl_idx].lirk) {
 100f9e2:	4b0d      	ldr	r3, [pc, #52]	; (100fa18 <ull_filter_lll_rl_addr_resolve+0x38>)
 100f9e4:	781c      	ldrb	r4, [r3, #0]
 100f9e6:	b17c      	cbz	r4, 100fa08 <ull_filter_lll_rl_addr_resolve+0x28>
 100f9e8:	2a07      	cmp	r2, #7
 100f9ea:	d80d      	bhi.n	100fa08 <ull_filter_lll_rl_addr_resolve+0x28>
 100f9ec:	4c0b      	ldr	r4, [pc, #44]	; (100fa1c <ull_filter_lll_rl_addr_resolve+0x3c>)
 100f9ee:	eb02 0282 	add.w	r2, r2, r2, lsl #2
 100f9f2:	f814 5032 	ldrb.w	r5, [r4, r2, lsl #3]
 100f9f6:	00d2      	lsls	r2, r2, #3
 100f9f8:	072b      	lsls	r3, r5, #28
 100f9fa:	d505      	bpl.n	100fa08 <ull_filter_lll_rl_addr_resolve+0x28>
	if ((id_addr_type != 0U) && ((id_addr[5] & 0xc0) == 0x40)) {
 100f9fc:	b120      	cbz	r0, 100fa08 <ull_filter_lll_rl_addr_resolve+0x28>
 100f9fe:	794b      	ldrb	r3, [r1, #5]
 100fa00:	f003 03c0 	and.w	r3, r3, #192	; 0xc0
 100fa04:	2b40      	cmp	r3, #64	; 0x40
 100fa06:	d002      	beq.n	100fa0e <ull_filter_lll_rl_addr_resolve+0x2e>
}
 100fa08:	bc30      	pop	{r4, r5}
 100fa0a:	2000      	movs	r0, #0
 100fa0c:	4770      	bx	lr
		return bt_rpa_irk_matches(rl[rl_idx].local_irk,
 100fa0e:	3207      	adds	r2, #7
 100fa10:	18a0      	adds	r0, r4, r2
}
 100fa12:	bc30      	pop	{r4, r5}
		return bt_rpa_irk_matches(rl[rl_idx].local_irk,
 100fa14:	f006 bfbe 	b.w	1016994 <bt_rpa_irk_matches>
 100fa18:	210066f3 	.word	0x210066f3
 100fa1c:	21003aa4 	.word	0x21003aa4

0100fa20 <ull_filter_lll_rl_enabled>:
	return rl_enable;
 100fa20:	4b02      	ldr	r3, [pc, #8]	; (100fa2c <ull_filter_lll_rl_enabled+0xc>)
 100fa22:	7818      	ldrb	r0, [r3, #0]
}
 100fa24:	3800      	subs	r0, #0
 100fa26:	bf18      	it	ne
 100fa28:	2001      	movne	r0, #1
 100fa2a:	4770      	bx	lr
 100fa2c:	210066f3 	.word	0x210066f3

0100fa30 <radio_nrf5_isr>:
#if (CONFIG_BT_CTLR_LLL_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
static void ticker_op_job_disable(u32_t status, void *op_context);
#endif
#endif /* CONFIG_BT_CTLR_LOW_LAT */

ISR_DIRECT_DECLARE(radio_nrf5_isr)
 100fa30:	4668      	mov	r0, sp
 100fa32:	f020 0107 	bic.w	r1, r0, #7
 100fa36:	468d      	mov	sp, r1
 100fa38:	b501      	push	{r0, lr}
{
	DEBUG_RADIO_ISR(1);

	isr_radio();
 100fa3a:	f002 f8c9 	bl	1011bd0 <isr_radio>

	ISR_DIRECT_PM();
 100fa3e:	f7f5 f9b1 	bl	1004da4 <_arch_isr_direct_pm>
{
#ifdef CONFIG_TRACING
	sys_trace_isr_exit();
#endif
	if (maybe_swap) {
		z_arm_int_exit();
 100fa42:	f7f5 fc93 	bl	100536c <z_arm_exc_exit>
ISR_DIRECT_DECLARE(radio_nrf5_isr)
 100fa46:	e8bd 4001 	ldmia.w	sp!, {r0, lr}
 100fa4a:	4685      	mov	sp, r0
 100fa4c:	4770      	bx	lr
 100fa4e:	bf00      	nop

0100fa50 <rtc0_nrf5_isr>:
	DEBUG_RADIO_ISR(0);
	return 1;
}

static void rtc0_nrf5_isr(void *arg)
{
 100fa50:	b508      	push	{r3, lr}
	DEBUG_TICKER_ISR(1);

	/* On compare0 run ticker worker instance0 */
	if (NRF_RTC0->EVENTS_COMPARE[0]) {
 100fa52:	4b09      	ldr	r3, [pc, #36]	; (100fa78 <rtc0_nrf5_isr+0x28>)
 100fa54:	f8d3 2140 	ldr.w	r2, [r3, #320]	; 0x140
 100fa58:	b93a      	cbnz	r2, 100fa6a <rtc0_nrf5_isr+0x1a>
		NRF_RTC0->EVENTS_COMPARE[0] = 0;

		ticker_trigger(0);
	}

	mayfly_run(TICKER_USER_ID_ULL_HIGH);
 100fa5a:	2001      	movs	r0, #1
 100fa5c:	f7f6 fa0e 	bl	1005e7c <mayfly_run>
	(CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	mayfly_run(TICKER_USER_ID_ULL_LOW);
#endif

	DEBUG_TICKER_ISR(0);
}
 100fa60:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	mayfly_run(TICKER_USER_ID_ULL_LOW);
 100fa64:	2002      	movs	r0, #2
 100fa66:	f7f6 ba09 	b.w	1005e7c <mayfly_run>
		NRF_RTC0->EVENTS_COMPARE[0] = 0;
 100fa6a:	2000      	movs	r0, #0
 100fa6c:	f8c3 0140 	str.w	r0, [r3, #320]	; 0x140
		ticker_trigger(0);
 100fa70:	f7f7 fb1a 	bl	10070a8 <ticker_trigger>
 100fa74:	e7f1      	b.n	100fa5a <rtc0_nrf5_isr+0xa>
 100fa76:	bf00      	nop
 100fa78:	41011000 	.word	0x41011000

0100fa7c <swi_lll_nrf5_isr>:

static void swi_lll_nrf5_isr(void *arg)
{
	DEBUG_RADIO_ISR(1);

	mayfly_run(TICKER_USER_ID_LLL);
 100fa7c:	2000      	movs	r0, #0
 100fa7e:	f7f6 b9fd 	b.w	1005e7c <mayfly_run>
 100fa82:	bf00      	nop

0100fa84 <ticker_start_op_cb>:
	/* NOTE: this callback is present only for addition of debug messages
	 * when needed, else can be dispensed with.
	 */
	ARG_UNUSED(param);

	LL_ASSERT((status == TICKER_STATUS_SUCCESS) ||
 100fa84:	2801      	cmp	r0, #1
 100fa86:	d800      	bhi.n	100fa8a <ticker_start_op_cb+0x6>
		  (status == TICKER_STATUS_FAILURE));
}
 100fa88:	4770      	bx	lr
	LL_ASSERT((status == TICKER_STATUS_SUCCESS) ||
 100fa8a:	f240 2107 	movw	r1, #519	; 0x207
 100fa8e:	4801      	ldr	r0, [pc, #4]	; (100fa94 <ticker_start_op_cb+0x10>)
 100fa90:	f7f3 bd7a 	b.w	1003588 <bt_ctlr_assert_handle>
 100fa94:	0101894c 	.word	0x0101894c

0100fa98 <preempt_ticker_start.isra.0>:
	preempt_to = MAX(evt->ticks_active_to_start,
			 evt->ticks_xtal_to_start) -
			 evt->ticks_preempt_to_start;

	/* Setup pre empt timeout */
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 100fa98:	2200      	movs	r2, #0
static void preempt_ticker_start(struct lll_prepare_param *prepare_param)
 100fa9a:	b530      	push	{r4, r5, lr}
 100fa9c:	b08b      	sub	sp, #44	; 0x2c
	evt = HDR_LLL2EVT(prepare_param->param);
 100fa9e:	680b      	ldr	r3, [r1, #0]
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 100faa0:	4d12      	ldr	r5, [pc, #72]	; (100faec <preempt_ticker_start.isra.0+0x54>)
 100faa2:	e9cd 2203 	strd	r2, r2, [sp, #12]
 100faa6:	e9cd 2201 	strd	r2, r2, [sp, #4]
 100faaa:	4c11      	ldr	r4, [pc, #68]	; (100faf0 <preempt_ticker_start.isra.0+0x58>)
 100faac:	9208      	str	r2, [sp, #32]
 100faae:	9206      	str	r2, [sp, #24]
 100fab0:	9507      	str	r5, [sp, #28]
 100fab2:	9405      	str	r4, [sp, #20]
	preempt_to = MAX(evt->ticks_active_to_start,
 100fab4:	6899      	ldr	r1, [r3, #8]
 100fab6:	e9d3 5400 	ldrd	r5, r4, [r3]
 100faba:	42a5      	cmp	r5, r4
 100fabc:	bf2c      	ite	cs
 100fabe:	ebc1 0105 	rsbcs	r1, r1, r5
 100fac2:	ebc1 0104 	rsbcc	r1, r1, r4
static void preempt_ticker_start(struct lll_prepare_param *prepare_param)
 100fac6:	4603      	mov	r3, r0
	ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 100fac8:	9100      	str	r1, [sp, #0]
 100faca:	4610      	mov	r0, r2
 100facc:	4611      	mov	r1, r2
 100face:	f7f7 fb4b 	bl	1007168 <ticker_start>
			   TICKER_NULL_REMAINDER,
			   TICKER_NULL_LAZY,
			   TICKER_NULL_SLOT,
			   preempt_ticker_cb, NULL,
			   ticker_start_op_cb, NULL);
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 100fad2:	2802      	cmp	r0, #2
 100fad4:	d801      	bhi.n	100fada <preempt_ticker_start.isra.0+0x42>
		  (ret == TICKER_STATUS_FAILURE) ||
		  (ret == TICKER_STATUS_BUSY));
}
 100fad6:	b00b      	add	sp, #44	; 0x2c
 100fad8:	bd30      	pop	{r4, r5, pc}
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 100fada:	f240 2125 	movw	r1, #549	; 0x225
 100fade:	4805      	ldr	r0, [pc, #20]	; (100faf4 <preempt_ticker_start.isra.0+0x5c>)
}
 100fae0:	b00b      	add	sp, #44	; 0x2c
 100fae2:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 100fae6:	f7f3 bd4f 	b.w	1003588 <bt_ctlr_assert_handle>
 100faea:	bf00      	nop
 100faec:	0100fa85 	.word	0x0100fa85
 100faf0:	0100fcc9 	.word	0x0100fcc9
 100faf4:	0101894c 	.word	0x0101894c

0100faf8 <preempt>:
			     0, &mfy);
	LL_ASSERT(!ret);
}

static void preempt(void *param)
{
 100faf8:	b5f0      	push	{r4, r5, r6, r7, lr}
 100fafa:	b08b      	sub	sp, #44	; 0x2c
	struct lll_event *next = ull_prepare_dequeue_get();
 100fafc:	f7fa fbf8 	bl	100a2f0 <ull_prepare_dequeue_get>
	lll_prepare_cb_t resume_cb;
	u8_t idx = UINT8_MAX;
 100fb00:	23ff      	movs	r3, #255	; 0xff
	int resume_prio;
	int ret;

	if (!event.curr.abort_cb || !event.curr.param) {
 100fb02:	4e3f      	ldr	r6, [pc, #252]	; (100fc00 <preempt+0x108>)
	u8_t idx = UINT8_MAX;
 100fb04:	f88d 300e 	strb.w	r3, [sp, #14]
	if (!event.curr.abort_cb || !event.curr.param) {
 100fb08:	68b3      	ldr	r3, [r6, #8]
 100fb0a:	b173      	cbz	r3, 100fb2a <preempt+0x32>
 100fb0c:	6833      	ldr	r3, [r6, #0]
 100fb0e:	b92b      	cbnz	r3, 100fb1c <preempt+0x24>
 100fb10:	e00b      	b.n	100fb2a <preempt+0x32>
	next = ull_prepare_dequeue_iter(&idx);
	if (!next) {
		return;
	}

	while (next && (next->is_aborted || next->is_resume)) {
 100fb12:	f890 0020 	ldrb.w	r0, [r0, #32]
 100fb16:	f010 0503 	ands.w	r5, r0, #3
 100fb1a:	d008      	beq.n	100fb2e <preempt+0x36>
		next = ull_prepare_dequeue_iter(&idx);
 100fb1c:	f10d 000e 	add.w	r0, sp, #14
 100fb20:	f7fa fbf4 	bl	100a30c <ull_prepare_dequeue_iter>
	while (next && (next->is_aborted || next->is_resume)) {
 100fb24:	4604      	mov	r4, r0
 100fb26:	2800      	cmp	r0, #0
 100fb28:	d1f3      	bne.n	100fb12 <preempt+0x1a>
			return;
		}
	} while (next->is_aborted || next->is_resume);

	preempt_ticker_start(&next->prepare_param);
}
 100fb2a:	b00b      	add	sp, #44	; 0x2c
 100fb2c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	ret = event.curr.is_abort_cb(next->prepare_param.param, next->prio,
 100fb2e:	ab05      	add	r3, sp, #20
 100fb30:	69e1      	ldr	r1, [r4, #28]
 100fb32:	68e0      	ldr	r0, [r4, #12]
 100fb34:	6877      	ldr	r7, [r6, #4]
 100fb36:	9300      	str	r3, [sp, #0]
 100fb38:	6832      	ldr	r2, [r6, #0]
 100fb3a:	ab04      	add	r3, sp, #16
 100fb3c:	47b8      	blx	r7
	if (!ret) {
 100fb3e:	4607      	mov	r7, r0
 100fb40:	2800      	cmp	r0, #0
 100fb42:	d052      	beq.n	100fbea <preempt+0xf2>
	event.curr.abort_cb(NULL, event.curr.param);
 100fb44:	4628      	mov	r0, r5
 100fb46:	68b3      	ldr	r3, [r6, #8]
 100fb48:	6831      	ldr	r1, [r6, #0]
 100fb4a:	4798      	blx	r3
	if (ret == -EAGAIN) {
 100fb4c:	f117 0f0b 	cmn.w	r7, #11
 100fb50:	d012      	beq.n	100fb78 <preempt+0x80>
		LL_ASSERT(ret == -ECANCELED);
 100fb52:	3748      	adds	r7, #72	; 0x48
 100fb54:	d009      	beq.n	100fb6a <preempt+0x72>
 100fb56:	f240 216f 	movw	r1, #623	; 0x26f
 100fb5a:	482a      	ldr	r0, [pc, #168]	; (100fc04 <preempt+0x10c>)
 100fb5c:	f7f3 fd14 	bl	1003588 <bt_ctlr_assert_handle>
 100fb60:	e003      	b.n	100fb6a <preempt+0x72>
	} while (next->is_aborted || next->is_resume);
 100fb62:	f890 3020 	ldrb.w	r3, [r0, #32]
 100fb66:	079b      	lsls	r3, r3, #30
 100fb68:	d039      	beq.n	100fbde <preempt+0xe6>
		next = ull_prepare_dequeue_iter(&idx);
 100fb6a:	f10d 000e 	add.w	r0, sp, #14
 100fb6e:	f7fa fbcd 	bl	100a30c <ull_prepare_dequeue_iter>
		if (!next) {
 100fb72:	2800      	cmp	r0, #0
 100fb74:	d1f5      	bne.n	100fb62 <preempt+0x6a>
 100fb76:	e7d8      	b.n	100fb2a <preempt+0x32>
		u8_t iter_idx = UINT8_MAX;
 100fb78:	23ff      	movs	r3, #255	; 0xff
		iter = ull_prepare_dequeue_iter(&iter_idx);
 100fb7a:	f10d 000f 	add.w	r0, sp, #15
		u8_t iter_idx = UINT8_MAX;
 100fb7e:	f88d 300f 	strb.w	r3, [sp, #15]
		iter = ull_prepare_dequeue_iter(&iter_idx);
 100fb82:	f7fa fbc3 	bl	100a30c <ull_prepare_dequeue_iter>
		while (iter) {
 100fb86:	bb08      	cbnz	r0, 100fbcc <preempt+0xd4>
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
 100fb88:	2201      	movs	r2, #1
	event.curr.param = NULL;
 100fb8a:	2100      	movs	r1, #0
		ret = resume_enqueue(resume_cb, resume_prio);
 100fb8c:	9b05      	ldr	r3, [sp, #20]
	prepare_param.param = event.curr.param;
 100fb8e:	6834      	ldr	r4, [r6, #0]
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
 100fb90:	e9cd 3200 	strd	r3, r2, [sp]
	event.curr.param = NULL;
 100fb94:	6031      	str	r1, [r6, #0]
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
 100fb96:	9b04      	ldr	r3, [sp, #16]
 100fb98:	aa06      	add	r2, sp, #24
 100fb9a:	e9d6 0101 	ldrd	r0, r1, [r6, #4]
	prepare_param.param = event.curr.param;
 100fb9e:	9409      	str	r4, [sp, #36]	; 0x24
	return ull_prepare_enqueue(event.curr.is_abort_cb, event.curr.abort_cb,
 100fba0:	f7fa fb6e 	bl	100a280 <ull_prepare_enqueue>
		LL_ASSERT(!ret);
 100fba4:	2800      	cmp	r0, #0
 100fba6:	d0e0      	beq.n	100fb6a <preempt+0x72>
 100fba8:	f240 216d 	movw	r1, #621	; 0x26d
 100fbac:	4815      	ldr	r0, [pc, #84]	; (100fc04 <preempt+0x10c>)
 100fbae:	f7f3 fceb 	bl	1003588 <bt_ctlr_assert_handle>
 100fbb2:	e7da      	b.n	100fb6a <preempt+0x72>
				iter->is_aborted = 1;
 100fbb4:	f043 0302 	orr.w	r3, r3, #2
 100fbb8:	f880 3020 	strb.w	r3, [r0, #32]
				iter->abort_cb(&iter->prepare_param,
 100fbbc:	6983      	ldr	r3, [r0, #24]
 100fbbe:	4798      	blx	r3
			iter = ull_prepare_dequeue_iter(&iter_idx);
 100fbc0:	f10d 000f 	add.w	r0, sp, #15
 100fbc4:	f7fa fba2 	bl	100a30c <ull_prepare_dequeue_iter>
		while (iter) {
 100fbc8:	2800      	cmp	r0, #0
 100fbca:	d0dd      	beq.n	100fb88 <preempt+0x90>
			if (!iter->is_aborted &&
 100fbcc:	f890 3020 	ldrb.w	r3, [r0, #32]
 100fbd0:	079a      	lsls	r2, r3, #30
 100fbd2:	d4f5      	bmi.n	100fbc0 <preempt+0xc8>
			    event.curr.param == iter->prepare_param.param) {
 100fbd4:	68c2      	ldr	r2, [r0, #12]
			if (!iter->is_aborted &&
 100fbd6:	6831      	ldr	r1, [r6, #0]
 100fbd8:	4291      	cmp	r1, r2
 100fbda:	d1f1      	bne.n	100fbc0 <preempt+0xc8>
 100fbdc:	e7ea      	b.n	100fbb4 <preempt+0xbc>
	preempt_ticker_start(&next->prepare_param);
 100fbde:	68c1      	ldr	r1, [r0, #12]
 100fbe0:	6800      	ldr	r0, [r0, #0]
 100fbe2:	f7ff ff59 	bl	100fa98 <preempt_ticker_start.isra.0>
}
 100fbe6:	b00b      	add	sp, #44	; 0x2c
 100fbe8:	bdf0      	pop	{r4, r5, r6, r7, pc}
		next->is_aborted = 1;
 100fbea:	f894 3020 	ldrb.w	r3, [r4, #32]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
 100fbee:	4620      	mov	r0, r4
		next->is_aborted = 1;
 100fbf0:	f043 0302 	orr.w	r3, r3, #2
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
 100fbf4:	69a2      	ldr	r2, [r4, #24]
 100fbf6:	68e1      	ldr	r1, [r4, #12]
		next->is_aborted = 1;
 100fbf8:	f884 3020 	strb.w	r3, [r4, #32]
		next->abort_cb(&next->prepare_param, next->prepare_param.param);
 100fbfc:	4790      	blx	r2
		goto preempt_next;
 100fbfe:	e7b4      	b.n	100fb6a <preempt+0x72>
 100fc00:	21003cb4 	.word	0x21003cb4
 100fc04:	0101894c 	.word	0x0101894c

0100fc08 <prepare>:
	u8_t idx = UINT8_MAX;
 100fc08:	f04f 0cff 	mov.w	ip, #255	; 0xff
{
 100fc0c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 100fc10:	b085      	sub	sp, #20
 100fc12:	4604      	mov	r4, r0
	p = ull_prepare_dequeue_iter(&idx);
 100fc14:	f10d 000f 	add.w	r0, sp, #15
{
 100fc18:	460d      	mov	r5, r1
 100fc1a:	4616      	mov	r6, r2
 100fc1c:	461f      	mov	r7, r3
 100fc1e:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 100fc22:	f89d 9034 	ldrb.w	r9, [sp, #52]	; 0x34
	u8_t idx = UINT8_MAX;
 100fc26:	f88d c00f 	strb.w	ip, [sp, #15]
	p = ull_prepare_dequeue_iter(&idx);
 100fc2a:	f7fa fb6f 	bl	100a30c <ull_prepare_dequeue_iter>
	while (p && (p->is_aborted || p->is_resume)) {
 100fc2e:	b928      	cbnz	r0, 100fc3c <prepare+0x34>
 100fc30:	e01d      	b.n	100fc6e <prepare+0x66>
		p = ull_prepare_dequeue_iter(&idx);
 100fc32:	f10d 000f 	add.w	r0, sp, #15
 100fc36:	f7fa fb69 	bl	100a30c <ull_prepare_dequeue_iter>
	while (p && (p->is_aborted || p->is_resume)) {
 100fc3a:	b1c0      	cbz	r0, 100fc6e <prepare+0x66>
 100fc3c:	f890 3020 	ldrb.w	r3, [r0, #32]
 100fc40:	079b      	lsls	r3, r3, #30
 100fc42:	d1f6      	bne.n	100fc32 <prepare+0x2a>
	if (event.curr.abort_cb || (p && is_resume)) {
 100fc44:	4b1e      	ldr	r3, [pc, #120]	; (100fcc0 <prepare+0xb8>)
 100fc46:	689a      	ldr	r2, [r3, #8]
 100fc48:	b9a2      	cbnz	r2, 100fc74 <prepare+0x6c>
 100fc4a:	f1b9 0f00 	cmp.w	r9, #0
 100fc4e:	d02d      	beq.n	100fcac <prepare+0xa4>
		ret = ull_prepare_enqueue(is_abort_cb, abort_cb, prepare_param,
 100fc50:	2201      	movs	r2, #1
 100fc52:	4633      	mov	r3, r6
 100fc54:	9201      	str	r2, [sp, #4]
 100fc56:	4629      	mov	r1, r5
 100fc58:	4620      	mov	r0, r4
 100fc5a:	4642      	mov	r2, r8
 100fc5c:	9700      	str	r7, [sp, #0]
 100fc5e:	f7fa fb0f 	bl	100a280 <ull_prepare_enqueue>
		LL_ASSERT(!ret);
 100fc62:	b9d0      	cbnz	r0, 100fc9a <prepare+0x92>
		return -EINPROGRESS;
 100fc64:	f06f 0043 	mvn.w	r0, #67	; 0x43
}
 100fc68:	b005      	add	sp, #20
 100fc6a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	if (event.curr.abort_cb || (p && is_resume)) {
 100fc6e:	4b14      	ldr	r3, [pc, #80]	; (100fcc0 <prepare+0xb8>)
 100fc70:	689a      	ldr	r2, [r3, #8]
 100fc72:	b1da      	cbz	r2, 100fcac <prepare+0xa4>
		ret = ull_prepare_enqueue(is_abort_cb, abort_cb, prepare_param,
 100fc74:	4633      	mov	r3, r6
 100fc76:	4629      	mov	r1, r5
 100fc78:	4620      	mov	r0, r4
 100fc7a:	4642      	mov	r2, r8
 100fc7c:	e9cd 7900 	strd	r7, r9, [sp]
 100fc80:	f7fa fafe 	bl	100a280 <ull_prepare_enqueue>
		LL_ASSERT(!ret);
 100fc84:	b948      	cbnz	r0, 100fc9a <prepare+0x92>
		if (is_resume) {
 100fc86:	f1b9 0f00 	cmp.w	r9, #0
 100fc8a:	d1eb      	bne.n	100fc64 <prepare+0x5c>
		preempt_ticker_start(prepare_param);
 100fc8c:	f8d8 100c 	ldr.w	r1, [r8, #12]
 100fc90:	f8d8 0000 	ldr.w	r0, [r8]
 100fc94:	f7ff ff00 	bl	100fa98 <preempt_ticker_start.isra.0>
 100fc98:	e7e4      	b.n	100fc64 <prepare+0x5c>
		LL_ASSERT(!ret);
 100fc9a:	f240 11bb 	movw	r1, #443	; 0x1bb
 100fc9e:	4809      	ldr	r0, [pc, #36]	; (100fcc4 <prepare+0xbc>)
 100fca0:	f7f3 fc72 	bl	1003588 <bt_ctlr_assert_handle>
		if (is_resume) {
 100fca4:	f1b9 0f00 	cmp.w	r9, #0
 100fca8:	d1dc      	bne.n	100fc64 <prepare+0x5c>
 100fcaa:	e7ef      	b.n	100fc8c <prepare+0x84>
	event.curr.param = prepare_param->param;
 100fcac:	f8d8 200c 	ldr.w	r2, [r8, #12]
	err = prepare_cb(prepare_param);
 100fcb0:	4640      	mov	r0, r8
	event.curr.abort_cb = abort_cb;
 100fcb2:	e9c3 4501 	strd	r4, r5, [r3, #4]
	event.curr.param = prepare_param->param;
 100fcb6:	601a      	str	r2, [r3, #0]
	err = prepare_cb(prepare_param);
 100fcb8:	47b0      	blx	r6
}
 100fcba:	b005      	add	sp, #20
 100fcbc:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 100fcc0:	21003cb4 	.word	0x21003cb4
 100fcc4:	0101894c 	.word	0x0101894c

0100fcc8 <preempt_ticker_cb>:
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100fcc8:	2200      	movs	r2, #0
{
 100fcca:	b508      	push	{r3, lr}
	ret = mayfly_enqueue(TICKER_USER_ID_ULL_HIGH, TICKER_USER_ID_LLL,
 100fccc:	4611      	mov	r1, r2
 100fcce:	2001      	movs	r0, #1
 100fcd0:	4b05      	ldr	r3, [pc, #20]	; (100fce8 <preempt_ticker_cb+0x20>)
 100fcd2:	f7f6 f87d 	bl	1005dd0 <mayfly_enqueue>
	LL_ASSERT(!ret);
 100fcd6:	b900      	cbnz	r0, 100fcda <preempt_ticker_cb+0x12>
}
 100fcd8:	bd08      	pop	{r3, pc}
	LL_ASSERT(!ret);
 100fcda:	f240 2133 	movw	r1, #563	; 0x233
}
 100fcde:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	LL_ASSERT(!ret);
 100fce2:	4802      	ldr	r0, [pc, #8]	; (100fcec <preempt_ticker_cb+0x24>)
 100fce4:	f7f3 bc50 	b.w	1003588 <bt_ctlr_assert_handle>
 100fce8:	210003ec 	.word	0x210003ec
 100fcec:	0101894c 	.word	0x0101894c

0100fcf0 <lll_init>:
{
 100fcf0:	b510      	push	{r4, lr}
 100fcf2:	4815      	ldr	r0, [pc, #84]	; (100fd48 <lll_init+0x58>)
 100fcf4:	f003 ff50 	bl	1013b98 <z_impl_device_get_binding>
	dev_entropy = device_get_binding(DT_LABEL(DT_NODELABEL(rng)));
 100fcf8:	4b14      	ldr	r3, [pc, #80]	; (100fd4c <lll_init+0x5c>)
 100fcfa:	6018      	str	r0, [r3, #0]
	if (!dev_entropy) {
 100fcfc:	b300      	cbz	r0, 100fd40 <lll_init+0x50>
	event.curr.abort_cb = NULL;
 100fcfe:	2200      	movs	r2, #0
 100fd00:	4b13      	ldr	r3, [pc, #76]	; (100fd50 <lll_init+0x60>)
 100fd02:	609a      	str	r2, [r3, #8]
	err = lll_clock_init();
 100fd04:	f000 f952 	bl	100ffac <lll_clock_init>
	if (err) {
 100fd08:	4604      	mov	r4, r0
 100fd0a:	b9b8      	cbnz	r0, 100fd3c <lll_init+0x4c>
	IRQ_DIRECT_CONNECT(RADIO_IRQn, CONFIG_BT_CTLR_LLL_PRIO,
 100fd0c:	4602      	mov	r2, r0
 100fd0e:	4601      	mov	r1, r0
 100fd10:	2008      	movs	r0, #8
 100fd12:	f7f5 f831 	bl	1004d78 <z_arm_irq_priority_set>
	IRQ_CONNECT(RTC0_IRQn, CONFIG_BT_CTLR_ULL_HIGH_PRIO,
 100fd16:	4622      	mov	r2, r4
 100fd18:	4621      	mov	r1, r4
 100fd1a:	2011      	movs	r0, #17
 100fd1c:	f7f5 f82c 	bl	1004d78 <z_arm_irq_priority_set>
	IRQ_CONNECT(HAL_SWI_RADIO_IRQ, CONFIG_BT_CTLR_LLL_PRIO,
 100fd20:	4622      	mov	r2, r4
 100fd22:	4621      	mov	r1, r4
 100fd24:	2014      	movs	r0, #20
 100fd26:	f7f5 f827 	bl	1004d78 <z_arm_irq_priority_set>
	irq_enable(RADIO_IRQn);
 100fd2a:	2008      	movs	r0, #8
 100fd2c:	f7f4 fff2 	bl	1004d14 <arch_irq_enable>
	irq_enable(RTC0_IRQn);
 100fd30:	2011      	movs	r0, #17
 100fd32:	f7f4 ffef 	bl	1004d14 <arch_irq_enable>
	irq_enable(HAL_SWI_RADIO_IRQ);
 100fd36:	2014      	movs	r0, #20
 100fd38:	f7f4 ffec 	bl	1004d14 <arch_irq_enable>
}
 100fd3c:	4620      	mov	r0, r4
 100fd3e:	bd10      	pop	{r4, pc}
		return -ENODEV;
 100fd40:	f06f 0412 	mvn.w	r4, #18
 100fd44:	e7fa      	b.n	100fd3c <lll_init+0x4c>
 100fd46:	bf00      	nop
 100fd48:	01018994 	.word	0x01018994
 100fd4c:	21003cb0 	.word	0x21003cb0
 100fd50:	21003cb4 	.word	0x21003cb4

0100fd54 <lll_trng_get>:
	return entropy_get_entropy(dev_entropy, buf, len);
 100fd54:	4a04      	ldr	r2, [pc, #16]	; (100fd68 <lll_trng_get+0x14>)
{
 100fd56:	4603      	mov	r3, r0
 100fd58:	b410      	push	{r4}
	return entropy_get_entropy(dev_entropy, buf, len);
 100fd5a:	6810      	ldr	r0, [r2, #0]
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->driver_api;

	__ASSERT(api->get_entropy != NULL,
		"Callback pointer should not be NULL");
	return api->get_entropy(dev, buffer, length);
 100fd5c:	6884      	ldr	r4, [r0, #8]
 100fd5e:	b28a      	uxth	r2, r1
 100fd60:	4619      	mov	r1, r3
 100fd62:	6823      	ldr	r3, [r4, #0]
}
 100fd64:	bc10      	pop	{r4}
 100fd66:	4718      	bx	r3
 100fd68:	21003cb0 	.word	0x21003cb0

0100fd6c <lll_trng_isr_get>:
	return entropy_get_entropy_isr(dev_entropy, buf, len, 0);
 100fd6c:	4b08      	ldr	r3, [pc, #32]	; (100fd90 <lll_trng_isr_get+0x24>)
{
 100fd6e:	460a      	mov	r2, r1
 100fd70:	4601      	mov	r1, r0
	return entropy_get_entropy_isr(dev_entropy, buf, len, 0);
 100fd72:	6818      	ldr	r0, [r3, #0]
{
 100fd74:	b410      	push	{r4}
					  u32_t flags)
{
	const struct entropy_driver_api *api =
		(const struct entropy_driver_api *)dev->driver_api;

	if (unlikely(!api->get_entropy_isr)) {
 100fd76:	6883      	ldr	r3, [r0, #8]
 100fd78:	685c      	ldr	r4, [r3, #4]
 100fd7a:	b124      	cbz	r4, 100fd86 <lll_trng_isr_get+0x1a>
		return -ENOTSUP;
	}

	return api->get_entropy_isr(dev, buffer, length, flags);
 100fd7c:	46a4      	mov	ip, r4
 100fd7e:	2300      	movs	r3, #0
}
 100fd80:	bc10      	pop	{r4}
 100fd82:	b292      	uxth	r2, r2
 100fd84:	4760      	bx	ip
 100fd86:	f06f 0022 	mvn.w	r0, #34	; 0x22
 100fd8a:	bc10      	pop	{r4}
 100fd8c:	4770      	bx	lr
 100fd8e:	bf00      	nop
 100fd90:	21003cb0 	.word	0x21003cb0

0100fd94 <lll_rng_isr_get>:
 100fd94:	f7ff bfea 	b.w	100fd6c <lll_trng_isr_get>

0100fd98 <lll_reset>:
}
 100fd98:	2000      	movs	r0, #0
 100fd9a:	4770      	bx	lr

0100fd9c <lll_prepare>:
{
 100fd9c:	b530      	push	{r4, r5, lr}
	return prepare(is_abort_cb, abort_cb, prepare_cb, prio, prepare_param,
 100fd9e:	2500      	movs	r5, #0
{
 100fda0:	b083      	sub	sp, #12
 100fda2:	9c06      	ldr	r4, [sp, #24]
	return prepare(is_abort_cb, abort_cb, prepare_cb, prio, prepare_param,
 100fda4:	e9cd 4500 	strd	r4, r5, [sp]
 100fda8:	f7ff ff2e 	bl	100fc08 <prepare>
}
 100fdac:	b003      	add	sp, #12
 100fdae:	bd30      	pop	{r4, r5, pc}

0100fdb0 <lll_resume>:
{
 100fdb0:	b500      	push	{lr}
		      next->prio, &next->prepare_param, next->is_resume);
 100fdb2:	f890 3020 	ldrb.w	r3, [r0, #32]
{
 100fdb6:	b083      	sub	sp, #12
	ret = prepare(next->is_abort_cb, next->abort_cb, next->prepare_cb,
 100fdb8:	f003 0301 	and.w	r3, r3, #1
 100fdbc:	9000      	str	r0, [sp, #0]
 100fdbe:	9301      	str	r3, [sp, #4]
 100fdc0:	69c3      	ldr	r3, [r0, #28]
 100fdc2:	6902      	ldr	r2, [r0, #16]
 100fdc4:	e9d0 0105 	ldrd	r0, r1, [r0, #20]
 100fdc8:	f7ff ff1e 	bl	100fc08 <prepare>
	LL_ASSERT(!ret || ret == -EINPROGRESS);
 100fdcc:	b108      	cbz	r0, 100fdd2 <lll_resume+0x22>
 100fdce:	3044      	adds	r0, #68	; 0x44
 100fdd0:	d102      	bne.n	100fdd8 <lll_resume+0x28>
}
 100fdd2:	b003      	add	sp, #12
 100fdd4:	f85d fb04 	ldr.w	pc, [sp], #4
	LL_ASSERT(!ret || ret == -EINPROGRESS);
 100fdd8:	21e1      	movs	r1, #225	; 0xe1
 100fdda:	4803      	ldr	r0, [pc, #12]	; (100fde8 <lll_resume+0x38>)
}
 100fddc:	b003      	add	sp, #12
 100fdde:	f85d eb04 	ldr.w	lr, [sp], #4
	LL_ASSERT(!ret || ret == -EINPROGRESS);
 100fde2:	f7f3 bbd1 	b.w	1003588 <bt_ctlr_assert_handle>
 100fde6:	bf00      	nop
 100fde8:	0101894c 	.word	0x0101894c

0100fdec <lll_disable>:
{
 100fdec:	b510      	push	{r4, lr}
	if (!param || (param == event.curr.param)) {
 100fdee:	4604      	mov	r4, r0
{
 100fdf0:	b082      	sub	sp, #8
	if (!param || (param == event.curr.param)) {
 100fdf2:	2800      	cmp	r0, #0
 100fdf4:	d033      	beq.n	100fe5e <lll_disable+0x72>
 100fdf6:	4b21      	ldr	r3, [pc, #132]	; (100fe7c <lll_disable+0x90>)
 100fdf8:	681a      	ldr	r2, [r3, #0]
 100fdfa:	4282      	cmp	r2, r0
 100fdfc:	d029      	beq.n	100fe52 <lll_disable+0x66>
		u8_t idx = UINT8_MAX;
 100fdfe:	23ff      	movs	r3, #255	; 0xff
		next = ull_prepare_dequeue_iter(&idx);
 100fe00:	f10d 0007 	add.w	r0, sp, #7
		u8_t idx = UINT8_MAX;
 100fe04:	f88d 3007 	strb.w	r3, [sp, #7]
		next = ull_prepare_dequeue_iter(&idx);
 100fe08:	f7fa fa80 	bl	100a30c <ull_prepare_dequeue_iter>
		while (next) {
 100fe0c:	b940      	cbnz	r0, 100fe20 <lll_disable+0x34>
 100fe0e:	e01c      	b.n	100fe4a <lll_disable+0x5e>
			    (!param || (param == next->prepare_param.param))) {
 100fe10:	68c3      	ldr	r3, [r0, #12]
 100fe12:	42a3      	cmp	r3, r4
 100fe14:	d01b      	beq.n	100fe4e <lll_disable+0x62>
			next = ull_prepare_dequeue_iter(&idx);
 100fe16:	f10d 0007 	add.w	r0, sp, #7
 100fe1a:	f7fa fa77 	bl	100a30c <ull_prepare_dequeue_iter>
		while (next) {
 100fe1e:	b1a0      	cbz	r0, 100fe4a <lll_disable+0x5e>
			if (!next->is_aborted &&
 100fe20:	f890 3020 	ldrb.w	r3, [r0, #32]
 100fe24:	079b      	lsls	r3, r3, #30
 100fe26:	d4f6      	bmi.n	100fe16 <lll_disable+0x2a>
 100fe28:	2c00      	cmp	r4, #0
 100fe2a:	d1f1      	bne.n	100fe10 <lll_disable+0x24>
 100fe2c:	68c1      	ldr	r1, [r0, #12]
				next->is_aborted = 1;
 100fe2e:	f890 3020 	ldrb.w	r3, [r0, #32]
 100fe32:	f043 0302 	orr.w	r3, r3, #2
 100fe36:	f880 3020 	strb.w	r3, [r0, #32]
				next->abort_cb(&next->prepare_param,
 100fe3a:	6983      	ldr	r3, [r0, #24]
 100fe3c:	4798      	blx	r3
			next = ull_prepare_dequeue_iter(&idx);
 100fe3e:	f10d 0007 	add.w	r0, sp, #7
 100fe42:	f7fa fa63 	bl	100a30c <ull_prepare_dequeue_iter>
		while (next) {
 100fe46:	2800      	cmp	r0, #0
 100fe48:	d1ea      	bne.n	100fe20 <lll_disable+0x34>
}
 100fe4a:	b002      	add	sp, #8
 100fe4c:	bd10      	pop	{r4, pc}
 100fe4e:	4621      	mov	r1, r4
 100fe50:	e7ed      	b.n	100fe2e <lll_disable+0x42>
		if (event.curr.abort_cb && event.curr.param) {
 100fe52:	689b      	ldr	r3, [r3, #8]
 100fe54:	b16b      	cbz	r3, 100fe72 <lll_disable+0x86>
 100fe56:	4621      	mov	r1, r4
			event.curr.abort_cb(NULL, event.curr.param);
 100fe58:	2000      	movs	r0, #0
 100fe5a:	4798      	blx	r3
 100fe5c:	e7cf      	b.n	100fdfe <lll_disable+0x12>
		if (event.curr.abort_cb && event.curr.param) {
 100fe5e:	4a07      	ldr	r2, [pc, #28]	; (100fe7c <lll_disable+0x90>)
 100fe60:	6893      	ldr	r3, [r2, #8]
 100fe62:	2b00      	cmp	r3, #0
 100fe64:	d0cb      	beq.n	100fdfe <lll_disable+0x12>
 100fe66:	6811      	ldr	r1, [r2, #0]
 100fe68:	2900      	cmp	r1, #0
 100fe6a:	d0c8      	beq.n	100fdfe <lll_disable+0x12>
			event.curr.abort_cb(NULL, event.curr.param);
 100fe6c:	2000      	movs	r0, #0
 100fe6e:	4798      	blx	r3
 100fe70:	e7c5      	b.n	100fdfe <lll_disable+0x12>
			LL_ASSERT(!param);
 100fe72:	21eb      	movs	r1, #235	; 0xeb
 100fe74:	4802      	ldr	r0, [pc, #8]	; (100fe80 <lll_disable+0x94>)
 100fe76:	f7f3 fb87 	bl	1003588 <bt_ctlr_assert_handle>
 100fe7a:	e7c0      	b.n	100fdfe <lll_disable+0x12>
 100fe7c:	21003cb4 	.word	0x21003cb4
 100fe80:	0101894c 	.word	0x0101894c

0100fe84 <lll_prepare_done>:
}
 100fe84:	2000      	movs	r0, #0
 100fe86:	4770      	bx	lr

0100fe88 <lll_done>:
{
 100fe88:	b510      	push	{r4, lr}
 100fe8a:	4604      	mov	r4, r0
	struct lll_event *next = ull_prepare_dequeue_get();
 100fe8c:	f7fa fa30 	bl	100a2f0 <ull_prepare_dequeue_get>
	LL_ASSERT(!param || next);
 100fe90:	b13c      	cbz	r4, 100fea2 <lll_done+0x1a>
 100fe92:	b1e0      	cbz	r0, 100fece <lll_done+0x46>
		ull = HDR_ULL(((struct lll_hdr *)param)->parent);
 100fe94:	6820      	ldr	r0, [r4, #0]
 100fe96:	3010      	adds	r0, #16
	evdone = ull_event_done(ull);
 100fe98:	f7fa fa66 	bl	100a368 <ull_event_done>
	LL_ASSERT(evdone);
 100fe9c:	b180      	cbz	r0, 100fec0 <lll_done+0x38>
}
 100fe9e:	2000      	movs	r0, #0
 100fea0:	bd10      	pop	{r4, pc}
		LL_ASSERT(event.curr.abort_cb);
 100fea2:	4c11      	ldr	r4, [pc, #68]	; (100fee8 <lll_done+0x60>)
 100fea4:	68a3      	ldr	r3, [r4, #8]
 100fea6:	b1c3      	cbz	r3, 100feda <lll_done+0x52>
		event.curr.abort_cb = NULL;
 100fea8:	2300      	movs	r3, #0
		param = event.curr.param;
 100feaa:	6820      	ldr	r0, [r4, #0]
		event.curr.abort_cb = NULL;
 100feac:	60a3      	str	r3, [r4, #8]
		event.curr.param = NULL;
 100feae:	6023      	str	r3, [r4, #0]
		if (param) {
 100feb0:	2800      	cmp	r0, #0
 100feb2:	d0f1      	beq.n	100fe98 <lll_done+0x10>
			ull = HDR_ULL(((struct lll_hdr *)param)->parent);
 100feb4:	6800      	ldr	r0, [r0, #0]
 100feb6:	3010      	adds	r0, #16
	evdone = ull_event_done(ull);
 100feb8:	f7fa fa56 	bl	100a368 <ull_event_done>
	LL_ASSERT(evdone);
 100febc:	2800      	cmp	r0, #0
 100febe:	d1ee      	bne.n	100fe9e <lll_done+0x16>
 100fec0:	f240 1137 	movw	r1, #311	; 0x137
 100fec4:	4809      	ldr	r0, [pc, #36]	; (100feec <lll_done+0x64>)
 100fec6:	f7f3 fb5f 	bl	1003588 <bt_ctlr_assert_handle>
}
 100feca:	2000      	movs	r0, #0
 100fecc:	bd10      	pop	{r4, pc}
	LL_ASSERT(!param || next);
 100fece:	f44f 718d 	mov.w	r1, #282	; 0x11a
 100fed2:	4806      	ldr	r0, [pc, #24]	; (100feec <lll_done+0x64>)
 100fed4:	f7f3 fb58 	bl	1003588 <bt_ctlr_assert_handle>
 100fed8:	e7dc      	b.n	100fe94 <lll_done+0xc>
		LL_ASSERT(event.curr.abort_cb);
 100feda:	f240 111f 	movw	r1, #287	; 0x11f
 100fede:	4803      	ldr	r0, [pc, #12]	; (100feec <lll_done+0x64>)
 100fee0:	f7f3 fb52 	bl	1003588 <bt_ctlr_assert_handle>
 100fee4:	e7e0      	b.n	100fea8 <lll_done+0x20>
 100fee6:	bf00      	nop
 100fee8:	21003cb4 	.word	0x21003cb4
 100feec:	0101894c 	.word	0x0101894c

0100fef0 <lll_is_done>:
	return !event.curr.abort_cb;
 100fef0:	4b02      	ldr	r3, [pc, #8]	; (100fefc <lll_is_done+0xc>)
 100fef2:	6898      	ldr	r0, [r3, #8]
}
 100fef4:	fab0 f080 	clz	r0, r0
 100fef8:	0940      	lsrs	r0, r0, #5
 100fefa:	4770      	bx	lr
 100fefc:	21003cb4 	.word	0x21003cb4

0100ff00 <lll_evt_offset_get>:
	} else if (evt->ticks_xtal_to_start & XON_BITMASK) {
 100ff00:	6803      	ldr	r3, [r0, #0]
 100ff02:	2b00      	cmp	r3, #0
		return MAX(evt->ticks_active_to_start,
 100ff04:	bfac      	ite	ge
 100ff06:	6840      	ldrge	r0, [r0, #4]
		return MAX(evt->ticks_active_to_start,
 100ff08:	e9d0 0301 	ldrdlt	r0, r3, [r0, #4]
		return MAX(evt->ticks_active_to_start,
 100ff0c:	4298      	cmp	r0, r3
 100ff0e:	bf38      	it	cc
 100ff10:	4618      	movcc	r0, r3
}
 100ff12:	4770      	bx	lr

0100ff14 <lll_preempt_calc>:
{
 100ff14:	b510      	push	{r4, lr}
 100ff16:	4614      	mov	r4, r2
	u32_t ticks_now = ticker_ticks_now_get();
 100ff18:	f7f7 f9c6 	bl	10072a8 <ticker_ticks_now_get>
	diff = ticker_ticks_diff_get(ticks_now, ticks_at_event);
 100ff1c:	4621      	mov	r1, r4
 100ff1e:	f7f7 f9c5 	bl	10072ac <ticker_ticks_diff_get>
	diff += HAL_TICKER_CNTR_CMP_OFFSET_MIN;
 100ff22:	3003      	adds	r0, #3
	if (!(diff & BIT(HAL_TICKER_CNTR_MSBIT)) &&
 100ff24:	0203      	lsls	r3, r0, #8
 100ff26:	d404      	bmi.n	100ff32 <lll_preempt_calc+0x1e>
 100ff28:	2809      	cmp	r0, #9
 100ff2a:	bf94      	ite	ls
 100ff2c:	2000      	movls	r0, #0
 100ff2e:	2001      	movhi	r0, #1
}
 100ff30:	bd10      	pop	{r4, pc}
	return 0;
 100ff32:	2000      	movs	r0, #0
}
 100ff34:	bd10      	pop	{r4, pc}
 100ff36:	bf00      	nop

0100ff38 <lll_chan_set>:
	switch (chan) {
 100ff38:	2826      	cmp	r0, #38	; 0x26
{
 100ff3a:	b510      	push	{r4, lr}
 100ff3c:	4604      	mov	r4, r0
	switch (chan) {
 100ff3e:	d01c      	beq.n	100ff7a <lll_chan_set+0x42>
 100ff40:	2827      	cmp	r0, #39	; 0x27
 100ff42:	d012      	beq.n	100ff6a <lll_chan_set+0x32>
 100ff44:	2825      	cmp	r0, #37	; 0x25
 100ff46:	d008      	beq.n	100ff5a <lll_chan_set+0x22>
		if (chan < 11) {
 100ff48:	280a      	cmp	r0, #10
 100ff4a:	d91e      	bls.n	100ff8a <lll_chan_set+0x52>
		} else if (chan < 40) {
 100ff4c:	2827      	cmp	r0, #39	; 0x27
 100ff4e:	d821      	bhi.n	100ff94 <lll_chan_set+0x5c>
			radio_freq_chan_set(28 + ((chan - 11) * 2U));
 100ff50:	3003      	adds	r0, #3
 100ff52:	0040      	lsls	r0, r0, #1
 100ff54:	f001 feae 	bl	1011cb4 <radio_freq_chan_set>
 100ff58:	e002      	b.n	100ff60 <lll_chan_set+0x28>
		radio_freq_chan_set(2);
 100ff5a:	2002      	movs	r0, #2
 100ff5c:	f001 feaa 	bl	1011cb4 <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
 100ff60:	4620      	mov	r0, r4
}
 100ff62:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_whiten_iv_set(chan);
 100ff66:	f001 beab 	b.w	1011cc0 <radio_whiten_iv_set>
		radio_freq_chan_set(80);
 100ff6a:	2050      	movs	r0, #80	; 0x50
 100ff6c:	f001 fea2 	bl	1011cb4 <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
 100ff70:	4620      	mov	r0, r4
}
 100ff72:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_whiten_iv_set(chan);
 100ff76:	f001 bea3 	b.w	1011cc0 <radio_whiten_iv_set>
		radio_freq_chan_set(26);
 100ff7a:	201a      	movs	r0, #26
 100ff7c:	f001 fe9a 	bl	1011cb4 <radio_freq_chan_set>
	radio_whiten_iv_set(chan);
 100ff80:	4620      	mov	r0, r4
}
 100ff82:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	radio_whiten_iv_set(chan);
 100ff86:	f001 be9b 	b.w	1011cc0 <radio_whiten_iv_set>
			radio_freq_chan_set(4 + (chan * 2U));
 100ff8a:	3002      	adds	r0, #2
 100ff8c:	0040      	lsls	r0, r0, #1
 100ff8e:	f001 fe91 	bl	1011cb4 <radio_freq_chan_set>
 100ff92:	e7e5      	b.n	100ff60 <lll_chan_set+0x28>
			LL_ASSERT(0);
 100ff94:	f240 117b 	movw	r1, #379	; 0x17b
 100ff98:	4801      	ldr	r0, [pc, #4]	; (100ffa0 <lll_chan_set+0x68>)
 100ff9a:	f7f3 faf5 	bl	1003588 <bt_ctlr_assert_handle>
 100ff9e:	e7df      	b.n	100ff60 <lll_chan_set+0x28>
 100ffa0:	0101894c 	.word	0x0101894c

0100ffa4 <clock_ready>:
	return err;
}

static void clock_ready(struct device *dev, clock_control_subsys_t subsys,
			void *user_data)
{
 100ffa4:	4610      	mov	r0, r2
	z_impl_k_sem_give(sem);
 100ffa6:	f004 bb4f 	b.w	1014648 <z_impl_k_sem_give>
 100ffaa:	bf00      	nop

0100ffac <lll_clock_init>:
{
 100ffac:	b510      	push	{r4, lr}
 100ffae:	4807      	ldr	r0, [pc, #28]	; (100ffcc <lll_clock_init+0x20>)
 100ffb0:	f003 fdf2 	bl	1013b98 <z_impl_device_get_binding>
	dev = device_get_binding(DT_LABEL(DT_INST(0, nordic_nrf_clock)));
 100ffb4:	4a06      	ldr	r2, [pc, #24]	; (100ffd0 <lll_clock_init+0x24>)
 100ffb6:	6010      	str	r0, [r2, #0]
	if (!dev) {
 100ffb8:	b128      	cbz	r0, 100ffc6 <lll_clock_init+0x1a>
}
 100ffba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 100ffbe:	6883      	ldr	r3, [r0, #8]
 100ffc0:	2101      	movs	r1, #1
 100ffc2:	681b      	ldr	r3, [r3, #0]
 100ffc4:	4718      	bx	r3
 100ffc6:	f06f 0012 	mvn.w	r0, #18
 100ffca:	bd10      	pop	{r4, pc}
 100ffcc:	010189a4 	.word	0x010189a4
 100ffd0:	21003cc8 	.word	0x21003cc8

0100ffd4 <lll_clock_wait>:
	if (done) {
 100ffd4:	4b12      	ldr	r3, [pc, #72]	; (1010020 <lll_clock_wait+0x4c>)
 100ffd6:	7819      	ldrb	r1, [r3, #0]
 100ffd8:	b109      	cbz	r1, 100ffde <lll_clock_wait+0xa>
		return 0;
 100ffda:	2000      	movs	r0, #0
}
 100ffdc:	4770      	bx	lr
{
 100ffde:	b530      	push	{r4, r5, lr}
	done = true;
 100ffe0:	2401      	movs	r4, #1
{
 100ffe2:	b08b      	sub	sp, #44	; 0x2c
	struct clock_control_async_data async_data = {
 100ffe4:	4a0f      	ldr	r2, [pc, #60]	; (1010024 <lll_clock_wait+0x50>)
 100ffe6:	ad04      	add	r5, sp, #16
 100ffe8:	e9cd 2502 	strd	r2, r5, [sp, #8]
 100ffec:	9101      	str	r1, [sp, #4]
	done = true;
 100ffee:	701c      	strb	r4, [r3, #0]
	return z_impl_k_sem_init(sem, initial_count, limit);
 100fff0:	4622      	mov	r2, r4
 100fff2:	4628      	mov	r0, r5
 100fff4:	f007 fd68 	bl	1017ac8 <z_impl_k_sem_init>
	err = clock_control_async_on(dev, CLOCK_CONTROL_NRF_SUBSYS_LF,
 100fff8:	4b0b      	ldr	r3, [pc, #44]	; (1010028 <lll_clock_wait+0x54>)
 100fffa:	6818      	ldr	r0, [r3, #0]
					 struct clock_control_async_data *data)
{
	const struct clock_control_driver_api *api =
		(const struct clock_control_driver_api *)dev->driver_api;

	if (!api->async_on) {
 100fffc:	6883      	ldr	r3, [r0, #8]
 100fffe:	689b      	ldr	r3, [r3, #8]
 1010000:	b15b      	cbz	r3, 101001a <lll_clock_wait+0x46>
		return -ENOTSUP;
	}

	return api->async_on(dev, sys, data);
 1010002:	4621      	mov	r1, r4
 1010004:	aa01      	add	r2, sp, #4
 1010006:	4798      	blx	r3
	if (err) {
 1010008:	b928      	cbnz	r0, 1010016 <lll_clock_wait+0x42>
	return z_impl_k_sem_take(sem, timeout);
 101000a:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 101000e:	2300      	movs	r3, #0
 1010010:	4628      	mov	r0, r5
 1010012:	f004 fb3f 	bl	1014694 <z_impl_k_sem_take>
}
 1010016:	b00b      	add	sp, #44	; 0x2c
 1010018:	bd30      	pop	{r4, r5, pc}
		return -ENOTSUP;
 101001a:	f06f 0022 	mvn.w	r0, #34	; 0x22
 101001e:	e7fa      	b.n	1010016 <lll_clock_wait+0x42>
 1010020:	210066f5 	.word	0x210066f5
 1010024:	0100ffa5 	.word	0x0100ffa5
 1010028:	21003cc8 	.word	0x21003cc8

0101002c <lll_hfclock_on>:
	err = clock_control_on(dev, CLOCK_CONTROL_NRF_SUBSYS_HF);
 101002c:	4b02      	ldr	r3, [pc, #8]	; (1010038 <lll_hfclock_on+0xc>)
	return api->on(dev, sys);
 101002e:	2100      	movs	r1, #0
 1010030:	6818      	ldr	r0, [r3, #0]
 1010032:	6883      	ldr	r3, [r0, #8]
 1010034:	681b      	ldr	r3, [r3, #0]
 1010036:	4718      	bx	r3
 1010038:	21003cc8 	.word	0x21003cc8

0101003c <lll_hfclock_off>:
	err = clock_control_off(dev, CLOCK_CONTROL_NRF_SUBSYS_HF);
 101003c:	4b02      	ldr	r3, [pc, #8]	; (1010048 <lll_hfclock_off+0xc>)
	return api->off(dev, sys);
 101003e:	2100      	movs	r1, #0
 1010040:	6818      	ldr	r0, [r3, #0]
 1010042:	6883      	ldr	r3, [r0, #8]
 1010044:	685b      	ldr	r3, [r3, #4]
 1010046:	4718      	bx	r3
 1010048:	21003cc8 	.word	0x21003cc8

0101004c <isr_race>:
}

static void isr_race(void *param)
{
	/* NOTE: lll_disable could have a race with ... */
	radio_status_reset();
 101004c:	f001 bee4 	b.w	1011e18 <radio_status_reset>

01010050 <isr_cleanup>:
{
 1010050:	4601      	mov	r1, r0
 1010052:	b508      	push	{r3, lr}
	radio_isr_set(isr_race, param);
 1010054:	480f      	ldr	r0, [pc, #60]	; (1010094 <isr_cleanup+0x44>)
 1010056:	f001 fdcb 	bl	1011bf0 <radio_isr_set>
	if (!radio_is_idle()) {
 101005a:	f001 fefd 	bl	1011e58 <radio_is_idle>
 101005e:	b1a8      	cbz	r0, 101008c <isr_cleanup+0x3c>
	radio_tmr_stop();
 1010060:	f002 f87c 	bl	101215c <radio_tmr_stop>
	err = lll_hfclock_off();
 1010064:	f7ff ffea 	bl	101003c <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
 1010068:	b108      	cbz	r0, 101006e <isr_cleanup+0x1e>
 101006a:	3010      	adds	r0, #16
 101006c:	d104      	bne.n	1010078 <isr_cleanup+0x28>
}
 101006e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
 1010072:	2000      	movs	r0, #0
 1010074:	f7ff bf08 	b.w	100fe88 <lll_done>
	LL_ASSERT(!err || err == -EBUSY);
 1010078:	4807      	ldr	r0, [pc, #28]	; (1010098 <isr_cleanup+0x48>)
 101007a:	f240 2149 	movw	r1, #585	; 0x249
 101007e:	f7f3 fa83 	bl	1003588 <bt_ctlr_assert_handle>
}
 1010082:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
 1010086:	2000      	movs	r0, #0
 1010088:	f7ff befe 	b.w	100fe88 <lll_done>
		radio_disable();
 101008c:	f001 feae 	bl	1011dec <radio_disable>
 1010090:	e7e6      	b.n	1010060 <isr_cleanup+0x10>
 1010092:	bf00      	nop
 1010094:	0101004d 	.word	0x0101004d
 1010098:	010189c0 	.word	0x010189c0

0101009c <isr_abort>:
{
 101009c:	b510      	push	{r4, lr}
 101009e:	4604      	mov	r4, r0
	radio_status_reset();
 10100a0:	f001 feba 	bl	1011e18 <radio_status_reset>
	radio_tmr_status_reset();
 10100a4:	f001 ff90 	bl	1011fc8 <radio_tmr_status_reset>
	radio_filter_status_reset();
 10100a8:	f001 ff76 	bl	1011f98 <radio_filter_status_reset>
	radio_ar_status_reset();
 10100ac:	f002 f9d0 	bl	1012450 <radio_ar_status_reset>
	radio_rssi_status_reset();
 10100b0:	f001 ff3a 	bl	1011f28 <radio_rssi_status_reset>
	radio_filter_disable();
 10100b4:	f001 ff66 	bl	1011f84 <radio_filter_disable>
	isr_cleanup(param);
 10100b8:	4620      	mov	r0, r4
}
 10100ba:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
 10100be:	f7ff bfc7 	b.w	1010050 <isr_cleanup>
 10100c2:	bf00      	nop

010100c4 <isr_tx>:
{
 10100c4:	b530      	push	{r4, r5, lr}
 10100c6:	b083      	sub	sp, #12
 10100c8:	4604      	mov	r4, r0
	radio_status_reset();
 10100ca:	f001 fea5 	bl	1011e18 <radio_status_reset>
	radio_tmr_status_reset();
 10100ce:	f001 ff7b 	bl	1011fc8 <radio_tmr_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
 10100d2:	2096      	movs	r0, #150	; 0x96
 10100d4:	f001 ff88 	bl	1011fe8 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
 10100d8:	2300      	movs	r3, #0
 10100da:	461a      	mov	r2, r3
 10100dc:	4619      	mov	r1, r3
 10100de:	4618      	mov	r0, r3
 10100e0:	f001 fef0 	bl	1011ec4 <radio_switch_complete_and_tx>
	radio_pkt_rx_set(radio_pkt_scratch_get());
 10100e4:	f001 fedc 	bl	1011ea0 <radio_pkt_scratch_get>
 10100e8:	f001 fe4c 	bl	1011d84 <radio_pkt_rx_set>
	LL_ASSERT(!radio_is_ready());
 10100ec:	f001 fea0 	bl	1011e30 <radio_is_ready>
 10100f0:	b9e8      	cbnz	r0, 101012e <isr_tx+0x6a>
	radio_isr_set(isr_rx, param);
 10100f2:	4621      	mov	r1, r4
 10100f4:	4819      	ldr	r0, [pc, #100]	; (101015c <isr_tx+0x98>)
 10100f6:	f001 fd7b 	bl	1011bf0 <radio_isr_set>
	if (ull_filter_lll_rl_enabled()) {
 10100fa:	f7ff fc91 	bl	100fa20 <ull_filter_lll_rl_enabled>
 10100fe:	bb18      	cbnz	r0, 1010148 <isr_tx+0x84>
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
 1010100:	f002 f8b2 	bl	1012268 <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(0, 0);
 1010104:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
 1010106:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(0, 0);
 1010108:	4608      	mov	r0, r1
 101010a:	f001 fe55 	bl	1011db8 <radio_rx_chain_delay_get>
	hcto -= radio_tx_chain_delay_get(0, 0);
 101010e:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(0, 0);
 1010110:	4605      	mov	r5, r0
	hcto -= radio_tx_chain_delay_get(0, 0);
 1010112:	4608      	mov	r0, r1
 1010114:	f001 fe4c 	bl	1011db0 <radio_tx_chain_delay_get>
 1010118:	442c      	add	r4, r5
 101011a:	34c3      	adds	r4, #195	; 0xc3
	radio_tmr_hcto_configure(hcto);
 101011c:	1a20      	subs	r0, r4, r0
 101011e:	f002 f831 	bl	1012184 <radio_tmr_hcto_configure>
	radio_tmr_end_capture();
 1010122:	f002 f885 	bl	1012230 <radio_tmr_end_capture>
		radio_rssi_measure();
 1010126:	f001 feef 	bl	1011f08 <radio_rssi_measure>
}
 101012a:	b003      	add	sp, #12
 101012c:	bd30      	pop	{r4, r5, pc}
	LL_ASSERT(!radio_is_ready());
 101012e:	f240 1157 	movw	r1, #343	; 0x157
 1010132:	480b      	ldr	r0, [pc, #44]	; (1010160 <isr_tx+0x9c>)
 1010134:	f7f3 fa28 	bl	1003588 <bt_ctlr_assert_handle>
	radio_isr_set(isr_rx, param);
 1010138:	4621      	mov	r1, r4
 101013a:	4808      	ldr	r0, [pc, #32]	; (101015c <isr_tx+0x98>)
 101013c:	f001 fd58 	bl	1011bf0 <radio_isr_set>
	if (ull_filter_lll_rl_enabled()) {
 1010140:	f7ff fc6e 	bl	100fa20 <ull_filter_lll_rl_enabled>
 1010144:	2800      	cmp	r0, #0
 1010146:	d0db      	beq.n	1010100 <isr_tx+0x3c>
		u8_t count, *irks = ull_filter_lll_irks_get(&count);
 1010148:	f10d 0007 	add.w	r0, sp, #7
 101014c:	f7ff fb36 	bl	100f7bc <ull_filter_lll_irks_get>
 1010150:	4601      	mov	r1, r0
		radio_ar_configure(count, irks);
 1010152:	f89d 0007 	ldrb.w	r0, [sp, #7]
 1010156:	f002 f93d 	bl	10123d4 <radio_ar_configure>
 101015a:	e7d1      	b.n	1010100 <isr_tx+0x3c>
 101015c:	010104a1 	.word	0x010104a1
 1010160:	010189c0 	.word	0x010189c0

01010164 <chan_prepare>:
}

static void chan_prepare(struct lll_adv *lll)
{
 1010164:	b538      	push	{r3, r4, r5, lr}
static inline struct pdu_adv *lll_adv_pdu_latest_get(struct lll_adv_pdu *pdu,
						     u8_t *is_modified)
{
	u8_t first;

	first = pdu->first;
 1010166:	7bc3      	ldrb	r3, [r0, #15]
	if (first != pdu->last) {
 1010168:	7c05      	ldrb	r5, [r0, #16]
 101016a:	4604      	mov	r4, r0
 101016c:	429d      	cmp	r5, r3
 101016e:	d052      	beq.n	1010216 <chan_prepare+0xb2>
		first += 1U;
 1010170:	3301      	adds	r3, #1
 1010172:	b2db      	uxtb	r3, r3
		if (first == DOUBLE_BUFFER_SIZE) {
 1010174:	2b02      	cmp	r3, #2
 1010176:	d04b      	beq.n	1010210 <chan_prepare+0xac>
 1010178:	eb03 0583 	add.w	r5, r3, r3, lsl #2
 101017c:	ebc3 05c5 	rsb	r5, r3, r5, lsl #3
 1010180:	1ca9      	adds	r1, r5, #2
			first = 0U;
		}
		pdu->first = first;
 1010182:	4625      	mov	r5, r4
 1010184:	f805 3f0f 	strb.w	r3, [r5, #15]!
	first = pdu->first;
 1010188:	f894 305f 	ldrb.w	r3, [r4, #95]	; 0x5f
	if (first != pdu->last) {
 101018c:	f894 2060 	ldrb.w	r2, [r4, #96]	; 0x60
		*is_modified = 1U;
	}

	return (void *)pdu->pdu[first];
 1010190:	440d      	add	r5, r1
	if (first != pdu->last) {
 1010192:	429a      	cmp	r2, r3
 1010194:	d062      	beq.n	101025c <chan_prepare+0xf8>
		first += 1U;
 1010196:	3301      	adds	r3, #1
 1010198:	b2db      	uxtb	r3, r3
		if (first == DOUBLE_BUFFER_SIZE) {
 101019a:	2b02      	cmp	r3, #2
 101019c:	d04c      	beq.n	1010238 <chan_prepare+0xd4>
 101019e:	eb03 0083 	add.w	r0, r3, r3, lsl #2
 10101a2:	ebc3 00c0 	rsb	r0, r3, r0, lsl #3
 10101a6:	1c82      	adds	r2, r0, #2
		pdu->first = first;
 10101a8:	4620      	mov	r0, r4
 10101aa:	f800 3f5f 	strb.w	r3, [r0, #95]!
	return (void *)pdu->pdu[first];
 10101ae:	4410      	add	r0, r2
#if defined(CONFIG_BT_CTLR_PRIVACY)
	if (upd) {
		/* Copy the address from the adv packet we will send into the
		 * scan response.
		 */
		memcpy(&scan_pdu->scan_rsp.addr[0],
 10101b0:	2206      	movs	r2, #6
 10101b2:	3002      	adds	r0, #2
 10101b4:	1ca9      	adds	r1, r5, #2
 10101b6:	f006 fb7f 	bl	10168b8 <memcpy>
#else
	ARG_UNUSED(scan_pdu);
	ARG_UNUSED(upd);
#endif /* !CONFIG_BT_CTLR_PRIVACY */

	radio_pkt_tx_set(pdu);
 10101ba:	4628      	mov	r0, r5
 10101bc:	f001 fde8 	bl	1011d90 <radio_pkt_tx_set>

	if ((pdu->type != PDU_ADV_TYPE_NONCONN_IND) &&
 10101c0:	782b      	ldrb	r3, [r5, #0]
	    (!IS_ENABLED(CONFIG_BT_CTLR_ADV_EXT) ||
	     (pdu->type != PDU_ADV_TYPE_EXT_IND))) {
		radio_isr_set(isr_tx, lll);
 10101c2:	4621      	mov	r1, r4
	if ((pdu->type != PDU_ADV_TYPE_NONCONN_IND) &&
 10101c4:	f003 030f 	and.w	r3, r3, #15
 10101c8:	2b02      	cmp	r3, #2
 10101ca:	d038      	beq.n	101023e <chan_prepare+0xda>
		radio_isr_set(isr_tx, lll);
 10101cc:	4827      	ldr	r0, [pc, #156]	; (101026c <chan_prepare+0x108>)
 10101ce:	f001 fd0f 	bl	1011bf0 <radio_isr_set>
		radio_tmr_tifs_set(EVENT_IFS_US);
 10101d2:	2096      	movs	r0, #150	; 0x96
 10101d4:	f001 ff08 	bl	1011fe8 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(0);
 10101d8:	2000      	movs	r0, #0
 10101da:	f001 fe65 	bl	1011ea8 <radio_switch_complete_and_rx>
	} else {
		radio_isr_set(isr_done, lll);
		radio_switch_complete_and_disable();
	}

	chan = find_lsb_set(lll->chan_map_curr);
 10101de:	7b23      	ldrb	r3, [r4, #12]
 10101e0:	f3c3 1302 	ubfx	r3, r3, #4, #3
 10101e4:	fa93 f0a3 	rbit	r0, r3
 10101e8:	2b00      	cmp	r3, #0
 10101ea:	fab0 f080 	clz	r0, r0
 10101ee:	bf08      	it	eq
 10101f0:	f04f 30ff 	moveq.w	r0, #4294967295
	LL_ASSERT(chan);
 10101f4:	1c45      	adds	r5, r0, #1
 10101f6:	d028      	beq.n	101024a <chan_prepare+0xe6>

	lll->chan_map_curr &= (lll->chan_map_curr - 1);
 10101f8:	7b22      	ldrb	r2, [r4, #12]
 10101fa:	1e59      	subs	r1, r3, #1
 10101fc:	400b      	ands	r3, r1
 10101fe:	f363 1206 	bfi	r2, r3, #4, #3

	lll_chan_set(36 + chan);
 1010202:	f105 0024 	add.w	r0, r5, #36	; 0x24
	lll->chan_map_curr &= (lll->chan_map_curr - 1);
 1010206:	7322      	strb	r2, [r4, #12]
}
 1010208:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	lll_chan_set(36 + chan);
 101020c:	f7ff be94 	b.w	100ff38 <lll_chan_set>
 1010210:	4619      	mov	r1, r3
			first = 0U;
 1010212:	2300      	movs	r3, #0
 1010214:	e7b5      	b.n	1010182 <chan_prepare+0x1e>
	return (void *)pdu->pdu[first];
 1010216:	eb05 0385 	add.w	r3, r5, r5, lsl #2
 101021a:	ebc5 05c3 	rsb	r5, r5, r3, lsl #3
	if (first != pdu->last) {
 101021e:	f890 2060 	ldrb.w	r2, [r0, #96]	; 0x60
	first = pdu->first;
 1010222:	f890 305f 	ldrb.w	r3, [r0, #95]	; 0x5f
	return (void *)pdu->pdu[first];
 1010226:	4405      	add	r5, r0
	if (first != pdu->last) {
 1010228:	429a      	cmp	r2, r3
	return (void *)pdu->pdu[first];
 101022a:	f105 0511 	add.w	r5, r5, #17
	if (first != pdu->last) {
 101022e:	d0c4      	beq.n	10101ba <chan_prepare+0x56>
		first += 1U;
 1010230:	3301      	adds	r3, #1
 1010232:	b2db      	uxtb	r3, r3
		if (first == DOUBLE_BUFFER_SIZE) {
 1010234:	2b02      	cmp	r3, #2
 1010236:	d1b2      	bne.n	101019e <chan_prepare+0x3a>
 1010238:	461a      	mov	r2, r3
			first = 0U;
 101023a:	2300      	movs	r3, #0
 101023c:	e7b4      	b.n	10101a8 <chan_prepare+0x44>
		radio_isr_set(isr_done, lll);
 101023e:	480c      	ldr	r0, [pc, #48]	; (1010270 <chan_prepare+0x10c>)
 1010240:	f001 fcd6 	bl	1011bf0 <radio_isr_set>
		radio_switch_complete_and_disable();
 1010244:	f001 fe4a 	bl	1011edc <radio_switch_complete_and_disable>
 1010248:	e7c9      	b.n	10101de <chan_prepare+0x7a>
	LL_ASSERT(chan);
 101024a:	f240 2179 	movw	r1, #633	; 0x279
 101024e:	4809      	ldr	r0, [pc, #36]	; (1010274 <chan_prepare+0x110>)
 1010250:	f7f3 f99a 	bl	1003588 <bt_ctlr_assert_handle>
 1010254:	7b23      	ldrb	r3, [r4, #12]
 1010256:	f3c3 1302 	ubfx	r3, r3, #4, #3
 101025a:	e7cd      	b.n	10101f8 <chan_prepare+0x94>
	return (void *)pdu->pdu[first];
 101025c:	eb02 0082 	add.w	r0, r2, r2, lsl #2
 1010260:	ebc2 00c0 	rsb	r0, r2, r0, lsl #3
 1010264:	4420      	add	r0, r4
 1010266:	3061      	adds	r0, #97	; 0x61
	if (upd) {
 1010268:	e7a2      	b.n	10101b0 <chan_prepare+0x4c>
 101026a:	bf00      	nop
 101026c:	010100c5 	.word	0x010100c5
 1010270:	01010449 	.word	0x01010449
 1010274:	010189c0 	.word	0x010189c0

01010278 <prepare_cb>:
{
 1010278:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct lll_adv *lll = prepare_param->param;
 101027a:	68c5      	ldr	r5, [r0, #12]
	u32_t aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
 101027c:	4b3c      	ldr	r3, [pc, #240]	; (1010370 <prepare_cb+0xf8>)

static inline int lll_is_stop(void *lll)
{
	struct lll_hdr *hdr = lll;

	return !!hdr->is_stop;
 101027e:	792c      	ldrb	r4, [r5, #4]
{
 1010280:	b083      	sub	sp, #12
	if (lll_is_stop(lll)) {
 1010282:	f014 0401 	ands.w	r4, r4, #1
	u32_t aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
 1010286:	9301      	str	r3, [sp, #4]
	if (lll_is_stop(lll)) {
 1010288:	d154      	bne.n	1010334 <prepare_cb+0xbc>
	radio_reset();
 101028a:	4606      	mov	r6, r0
 101028c:	f001 fcd0 	bl	1011c30 <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
 1010290:	4620      	mov	r0, r4
 1010292:	f001 fd09 	bl	1011ca8 <radio_tx_power_set>
	radio_phy_set(0, 0);
 1010296:	4621      	mov	r1, r4
 1010298:	4620      	mov	r0, r4
 101029a:	f001 fced 	bl	1011c78 <radio_phy_set>
	radio_pkt_configure(8, PDU_AC_PAYLOAD_SIZE_MAX, 0);
 101029e:	4622      	mov	r2, r4
 10102a0:	2125      	movs	r1, #37	; 0x25
 10102a2:	2008      	movs	r0, #8
 10102a4:	f001 fd38 	bl	1011d18 <radio_pkt_configure>
	radio_aa_set((u8_t *)&aa);
 10102a8:	a801      	add	r0, sp, #4
 10102aa:	f001 fd1b 	bl	1011ce4 <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
 10102ae:	f240 605b 	movw	r0, #1627	; 0x65b
 10102b2:	4930      	ldr	r1, [pc, #192]	; (1010374 <prepare_cb+0xfc>)
 10102b4:	f001 fdda 	bl	1011e6c <radio_crc_configure>
	lll->chan_map_curr = lll->chan_map;
 10102b8:	7b2b      	ldrb	r3, [r5, #12]
	chan_prepare(lll);
 10102ba:	4628      	mov	r0, r5
	lll->chan_map_curr = lll->chan_map;
 10102bc:	461a      	mov	r2, r3
 10102be:	f3c3 0342 	ubfx	r3, r3, #1, #3
 10102c2:	f363 1206 	bfi	r2, r3, #4, #3
 10102c6:	732a      	strb	r2, [r5, #12]
	chan_prepare(lll);
 10102c8:	f7ff ff4c 	bl	1010164 <chan_prepare>
	if (ull_filter_lll_rl_enabled()) {
 10102cc:	f7ff fba8 	bl	100fa20 <ull_filter_lll_rl_enabled>
 10102d0:	bb18      	cbnz	r0, 101031a <prepare_cb+0xa2>
	if (IS_ENABLED(CONFIG_BT_CTLR_FILTER) && lll->filter_policy) {
 10102d2:	7b6b      	ldrb	r3, [r5, #13]
 10102d4:	079b      	lsls	r3, r3, #30
 10102d6:	d148      	bne.n	101036a <prepare_cb+0xf2>
	evt = HDR_LLL2EVT(lll);
 10102d8:	682f      	ldr	r7, [r5, #0]
	ticks_at_event = prepare_param->ticks_at_expire;
 10102da:	6834      	ldr	r4, [r6, #0]
	ticks_at_event += lll_evt_offset_get(evt);
 10102dc:	4638      	mov	r0, r7
 10102de:	f7ff fe0f 	bl	100ff00 <lll_evt_offset_get>
 10102e2:	4404      	add	r4, r0
	remainder_us = radio_tmr_start(1, ticks_at_start, remainder);
 10102e4:	6872      	ldr	r2, [r6, #4]
 10102e6:	f104 0109 	add.w	r1, r4, #9
 10102ea:	2001      	movs	r0, #1
 10102ec:	f001 fe88 	bl	1012000 <radio_tmr_start>
	radio_tmr_end_capture();
 10102f0:	f001 ff9e 	bl	1012230 <radio_tmr_end_capture>
				   ull_adv_lll_handle_get(lll)),
 10102f4:	4628      	mov	r0, r5
 10102f6:	f7fa fc23 	bl	100ab40 <ull_adv_lll_handle_get>
	if (lll_preempt_calc(evt, (TICKER_ID_ADV_BASE +
 10102fa:	1c81      	adds	r1, r0, #2
 10102fc:	4622      	mov	r2, r4
 10102fe:	4638      	mov	r0, r7
 1010300:	b2c9      	uxtb	r1, r1
 1010302:	f7ff fe07 	bl	100ff14 <lll_preempt_calc>
 1010306:	b320      	cbz	r0, 1010352 <prepare_cb+0xda>
		radio_isr_set(isr_abort, lll);
 1010308:	4629      	mov	r1, r5
 101030a:	481b      	ldr	r0, [pc, #108]	; (1010378 <prepare_cb+0x100>)
 101030c:	f001 fc70 	bl	1011bf0 <radio_isr_set>
		radio_disable();
 1010310:	f001 fd6c 	bl	1011dec <radio_disable>
}
 1010314:	2000      	movs	r0, #0
 1010316:	b003      	add	sp, #12
 1010318:	bdf0      	pop	{r4, r5, r6, r7, pc}
			ull_filter_lll_get(!!(lll->filter_policy));
 101031a:	7b68      	ldrb	r0, [r5, #13]
 101031c:	f010 0003 	ands.w	r0, r0, #3
 1010320:	bf18      	it	ne
 1010322:	2001      	movne	r0, #1
		struct lll_filter *wl = ull_filter_lll_get(true);
 1010324:	f7ff faea 	bl	100f8fc <ull_filter_lll_get>
		radio_filter_configure(wl->enable_bitmask,
 1010328:	7841      	ldrb	r1, [r0, #1]
 101032a:	1c82      	adds	r2, r0, #2
 101032c:	7800      	ldrb	r0, [r0, #0]
 101032e:	f001 fe0d 	bl	1011f4c <radio_filter_configure>
 1010332:	e7d1      	b.n	10102d8 <prepare_cb+0x60>
		err = lll_hfclock_off();
 1010334:	f7ff fe82 	bl	101003c <lll_hfclock_off>
		LL_ASSERT(!err || err == -EBUSY);
 1010338:	b128      	cbz	r0, 1010346 <prepare_cb+0xce>
 101033a:	3010      	adds	r0, #16
 101033c:	d003      	beq.n	1010346 <prepare_cb+0xce>
 101033e:	218b      	movs	r1, #139	; 0x8b
 1010340:	480e      	ldr	r0, [pc, #56]	; (101037c <prepare_cb+0x104>)
 1010342:	f7f3 f921 	bl	1003588 <bt_ctlr_assert_handle>
		lll_done(NULL);
 1010346:	2000      	movs	r0, #0
 1010348:	f7ff fd9e 	bl	100fe88 <lll_done>
}
 101034c:	2000      	movs	r0, #0
 101034e:	b003      	add	sp, #12
 1010350:	bdf0      	pop	{r4, r5, r6, r7, pc}
		ret = lll_prepare_done(lll);
 1010352:	4628      	mov	r0, r5
 1010354:	f7ff fd96 	bl	100fe84 <lll_prepare_done>
		LL_ASSERT(!ret);
 1010358:	2800      	cmp	r0, #0
 101035a:	d0db      	beq.n	1010314 <prepare_cb+0x9c>
 101035c:	21e9      	movs	r1, #233	; 0xe9
 101035e:	4807      	ldr	r0, [pc, #28]	; (101037c <prepare_cb+0x104>)
 1010360:	f7f3 f912 	bl	1003588 <bt_ctlr_assert_handle>
}
 1010364:	2000      	movs	r0, #0
 1010366:	b003      	add	sp, #12
 1010368:	bdf0      	pop	{r4, r5, r6, r7, pc}
		struct lll_filter *wl = ull_filter_lll_get(true);
 101036a:	2001      	movs	r0, #1
 101036c:	e7da      	b.n	1010324 <prepare_cb+0xac>
 101036e:	bf00      	nop
 1010370:	8e89bed6 	.word	0x8e89bed6
 1010374:	00555555 	.word	0x00555555
 1010378:	0101009d 	.word	0x0101009d
 101037c:	010189c0 	.word	0x010189c0

01010380 <resume_prepare_cb>:
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
 1010380:	68c3      	ldr	r3, [r0, #12]
{
 1010382:	b570      	push	{r4, r5, r6, lr}
 1010384:	4604      	mov	r4, r0
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
 1010386:	681e      	ldr	r6, [r3, #0]
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
 1010388:	f7f6 ff8e 	bl	10072a8 <ticker_ticks_now_get>
 101038c:	4605      	mov	r5, r0
 101038e:	4630      	mov	r0, r6
 1010390:	f7ff fdb6 	bl	100ff00 <lll_evt_offset_get>
	p->remainder = 0;
 1010394:	2300      	movs	r3, #0
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
 1010396:	1a2d      	subs	r5, r5, r0
	p->remainder = 0;
 1010398:	e9c4 5300 	strd	r5, r3, [r4]
	return prepare_cb(p);
 101039c:	4620      	mov	r0, r4
	p->lazy = 0;
 101039e:	8123      	strh	r3, [r4, #8]
}
 10103a0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return prepare_cb(p);
 10103a4:	f7ff bf68 	b.w	1010278 <prepare_cb>

010103a8 <is_abort_cb>:
	if (next != curr) {
 10103a8:	4282      	cmp	r2, r0
{
 10103aa:	b508      	push	{r3, lr}
	if (next != curr) {
 10103ac:	d017      	beq.n	10103de <is_abort_cb+0x36>
		} else if (lll->is_hdcd) {
 10103ae:	7b12      	ldrb	r2, [r2, #12]
 10103b0:	07d2      	lsls	r2, r2, #31
 10103b2:	d402      	bmi.n	10103ba <is_abort_cb+0x12>
			return -ECANCELED;
 10103b4:	f06f 0047 	mvn.w	r0, #71	; 0x47
}
 10103b8:	bd08      	pop	{r3, pc}
			*resume_prio = 0; /* TODO: */
 10103ba:	2200      	movs	r2, #0
			*resume_cb = resume_prepare_cb;
 10103bc:	4911      	ldr	r1, [pc, #68]	; (1010404 <is_abort_cb+0x5c>)
 10103be:	6019      	str	r1, [r3, #0]
			*resume_prio = 0; /* TODO: */
 10103c0:	9b02      	ldr	r3, [sp, #8]
 10103c2:	601a      	str	r2, [r3, #0]
			err = lll_hfclock_on();
 10103c4:	f7ff fe32 	bl	101002c <lll_hfclock_on>
			LL_ASSERT(!err || err == -EINPROGRESS);
 10103c8:	b1c0      	cbz	r0, 10103fc <is_abort_cb+0x54>
 10103ca:	3044      	adds	r0, #68	; 0x44
 10103cc:	d016      	beq.n	10103fc <is_abort_cb+0x54>
 10103ce:	f240 1113 	movw	r1, #275	; 0x113
 10103d2:	480d      	ldr	r0, [pc, #52]	; (1010408 <is_abort_cb+0x60>)
 10103d4:	f7f3 f8d8 	bl	1003588 <bt_ctlr_assert_handle>
 10103d8:	f06f 000a 	mvn.w	r0, #10
}
 10103dc:	bd08      	pop	{r3, pc}
	return lll_adv_pdu_latest_get(&lll->scan_rsp, is_modified);
}

static inline struct pdu_adv *lll_adv_data_curr_get(struct lll_adv *lll)
{
	return (void *)lll->adv_data.pdu[lll->adv_data.first];
 10103de:	7bd3      	ldrb	r3, [r2, #15]
	if (pdu->type == PDU_ADV_TYPE_DIRECT_IND) {
 10103e0:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 10103e4:	ebc3 03c1 	rsb	r3, r3, r1, lsl #3
 10103e8:	441a      	add	r2, r3
 10103ea:	7c53      	ldrb	r3, [r2, #17]
 10103ec:	f003 030f 	and.w	r3, r3, #15
 10103f0:	2b01      	cmp	r3, #1
		return 0;
 10103f2:	bf14      	ite	ne
 10103f4:	f06f 0047 	mvnne.w	r0, #71	; 0x47
 10103f8:	2000      	moveq	r0, #0
}
 10103fa:	bd08      	pop	{r3, pc}
 10103fc:	f06f 000a 	mvn.w	r0, #10
 1010400:	bd08      	pop	{r3, pc}
 1010402:	bf00      	nop
 1010404:	01010381 	.word	0x01010381
 1010408:	010189c0 	.word	0x010189c0

0101040c <abort_cb>:
{
 101040c:	b510      	push	{r4, lr}
	if (!prepare_param) {
 101040e:	b178      	cbz	r0, 1010430 <abort_cb+0x24>
	err = lll_hfclock_off();
 1010410:	460c      	mov	r4, r1
 1010412:	f7ff fe13 	bl	101003c <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
 1010416:	b130      	cbz	r0, 1010426 <abort_cb+0x1a>
 1010418:	3010      	adds	r0, #16
 101041a:	d004      	beq.n	1010426 <abort_cb+0x1a>
 101041c:	f240 1139 	movw	r1, #313	; 0x139
 1010420:	4807      	ldr	r0, [pc, #28]	; (1010440 <abort_cb+0x34>)
 1010422:	f7f3 f8b1 	bl	1003588 <bt_ctlr_assert_handle>
	lll_done(param);
 1010426:	4620      	mov	r0, r4
}
 1010428:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
 101042c:	f7ff bd2c 	b.w	100fe88 <lll_done>
		radio_isr_set(isr_abort, param);
 1010430:	4804      	ldr	r0, [pc, #16]	; (1010444 <abort_cb+0x38>)
 1010432:	f001 fbdd 	bl	1011bf0 <radio_isr_set>
}
 1010436:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_disable();
 101043a:	f001 bcd7 	b.w	1011dec <radio_disable>
 101043e:	bf00      	nop
 1010440:	010189c0 	.word	0x010189c0
 1010444:	0101009d 	.word	0x0101009d

01010448 <isr_done>:
{
 1010448:	b510      	push	{r4, lr}
 101044a:	4604      	mov	r4, r0
	radio_status_reset();
 101044c:	f001 fce4 	bl	1011e18 <radio_status_reset>
	radio_tmr_status_reset();
 1010450:	f001 fdba 	bl	1011fc8 <radio_tmr_status_reset>
	radio_filter_status_reset();
 1010454:	f001 fda0 	bl	1011f98 <radio_filter_status_reset>
	radio_ar_status_reset();
 1010458:	f001 fffa 	bl	1012450 <radio_ar_status_reset>
	radio_rssi_status_reset();
 101045c:	f001 fd64 	bl	1011f28 <radio_rssi_status_reset>
	if (!IS_ENABLED(CONFIG_BT_CTLR_LOW_LAT) && lll->is_hdcd &&
 1010460:	7b23      	ldrb	r3, [r4, #12]
 1010462:	f003 0271 	and.w	r2, r3, #113	; 0x71
 1010466:	2a01      	cmp	r2, #1
 1010468:	d106      	bne.n	1010478 <isr_done+0x30>
		lll->chan_map_curr = lll->chan_map;
 101046a:	461a      	mov	r2, r3
 101046c:	f3c3 0342 	ubfx	r3, r3, #1, #3
 1010470:	f363 1206 	bfi	r2, r3, #4, #3
 1010474:	7322      	strb	r2, [r4, #12]
 1010476:	b2d3      	uxtb	r3, r2
	if (lll->chan_map_curr) {
 1010478:	f013 0f70 	tst.w	r3, #112	; 0x70
 101047c:	d106      	bne.n	101048c <isr_done+0x44>
	radio_filter_disable();
 101047e:	f001 fd81 	bl	1011f84 <radio_filter_disable>
	isr_cleanup(param);
 1010482:	4620      	mov	r0, r4
}
 1010484:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
 1010488:	f7ff bde2 	b.w	1010050 <isr_cleanup>
		chan_prepare(lll);
 101048c:	4620      	mov	r0, r4
 101048e:	f7ff fe69 	bl	1010164 <chan_prepare>
		radio_tx_enable();
 1010492:	f001 fca5 	bl	1011de0 <radio_tx_enable>
}
 1010496:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_tmr_end_capture();
 101049a:	f001 bec9 	b.w	1012230 <radio_tmr_end_capture>
 101049e:	bf00      	nop

010104a0 <isr_rx>:
{
 10104a0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10104a4:	b085      	sub	sp, #20
 10104a6:	4604      	mov	r4, r0
	trx_done = radio_is_done();
 10104a8:	f001 fccc 	bl	1011e44 <radio_is_done>
	if (trx_done) {
 10104ac:	f010 0fff 	tst.w	r0, #255	; 0xff
 10104b0:	d112      	bne.n	10104d8 <isr_rx+0x38>
	radio_status_reset();
 10104b2:	f001 fcb1 	bl	1011e18 <radio_status_reset>
	radio_tmr_status_reset();
 10104b6:	f001 fd87 	bl	1011fc8 <radio_tmr_status_reset>
	radio_filter_status_reset();
 10104ba:	f001 fd6d 	bl	1011f98 <radio_filter_status_reset>
	radio_ar_status_reset();
 10104be:	f001 ffc7 	bl	1012450 <radio_ar_status_reset>
	radio_rssi_status_reset();
 10104c2:	f001 fd31 	bl	1011f28 <radio_rssi_status_reset>
	radio_isr_set(isr_done, param);
 10104c6:	4621      	mov	r1, r4
 10104c8:	48c9      	ldr	r0, [pc, #804]	; (10107f0 <isr_rx+0x350>)
 10104ca:	f001 fb91 	bl	1011bf0 <radio_isr_set>
	radio_disable();
 10104ce:	f001 fc8d 	bl	1011dec <radio_disable>
}
 10104d2:	b005      	add	sp, #20
 10104d4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		crc_ok = radio_crc_is_valid();
 10104d8:	f001 fcd4 	bl	1011e84 <radio_crc_is_valid>
 10104dc:	4605      	mov	r5, r0
		devmatch_ok = radio_filter_has_match();
 10104de:	f001 fd63 	bl	1011fa8 <radio_filter_has_match>
 10104e2:	4607      	mov	r7, r0
		devmatch_id = radio_filter_match_get();
 10104e4:	f001 fd6a 	bl	1011fbc <radio_filter_match_get>
		irkmatch_ok = radio_ar_has_match();
 10104e8:	f001 ffbe 	bl	1012468 <radio_ar_has_match>
 10104ec:	4606      	mov	r6, r0
		irkmatch_id = radio_ar_match_get();
 10104ee:	f001 ffa9 	bl	1012444 <radio_ar_match_get>
 10104f2:	4680      	mov	r8, r0
		rssi_ready = radio_rssi_is_ready();
 10104f4:	f001 fd20 	bl	1011f38 <radio_rssi_is_ready>
 10104f8:	4681      	mov	r9, r0
	radio_status_reset();
 10104fa:	f001 fc8d 	bl	1011e18 <radio_status_reset>
	radio_tmr_status_reset();
 10104fe:	f001 fd63 	bl	1011fc8 <radio_tmr_status_reset>
	radio_filter_status_reset();
 1010502:	f001 fd49 	bl	1011f98 <radio_filter_status_reset>
	radio_ar_status_reset();
 1010506:	f001 ffa3 	bl	1012450 <radio_ar_status_reset>
	radio_rssi_status_reset();
 101050a:	f001 fd0d 	bl	1011f28 <radio_rssi_status_reset>
	if (crc_ok) {
 101050e:	f015 0fff 	tst.w	r5, #255	; 0xff
 1010512:	d0d8      	beq.n	10104c6 <isr_rx+0x26>
{
	struct pdu_adv *pdu_rx, *pdu_adv;

#if defined(CONFIG_BT_CTLR_PRIVACY)
	/* An IRK match implies address resolution enabled */
	u8_t rl_idx = irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
 1010514:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
 1010518:	f040 808f 	bne.w	101063a <isr_rx+0x19a>
 101051c:	20ff      	movs	r0, #255	; 0xff
 101051e:	f88d 000f 	strb.w	r0, [sp, #15]
				    FILTER_IDX_NONE;
#else
	u8_t rl_idx = FILTER_IDX_NONE;
#endif /* CONFIG_BT_CTLR_PRIVACY */

	pdu_rx = (void *)radio_pkt_scratch_get();
 1010522:	f001 fcbd 	bl	1011ea0 <radio_pkt_scratch_get>
 1010526:	7be3      	ldrb	r3, [r4, #15]
 1010528:	4680      	mov	r8, r0
 101052a:	eb03 0583 	add.w	r5, r3, r3, lsl #2
	pdu_adv = lll_adv_data_curr_get(lll);

	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
 101052e:	7800      	ldrb	r0, [r0, #0]
 1010530:	ebc3 03c5 	rsb	r3, r3, r5, lsl #3
 1010534:	f103 0511 	add.w	r5, r3, #17
 1010538:	f000 030f 	and.w	r3, r0, #15
 101053c:	2b03      	cmp	r3, #3
		devmatch_ok = radio_filter_has_match();
 101053e:	b2ff      	uxtb	r7, r7
 1010540:	eb04 0a05 	add.w	sl, r4, r5
	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
 1010544:	f000 808d 	beq.w	1010662 <isr_rx+0x1c2>
					 CONFIG_BT_CTLR_GPIO_PA_OFFSET);
#endif /* CONFIG_BT_CTLR_GPIO_PA_PIN */
		return 0;

#if defined(CONFIG_BT_PERIPHERAL)
	} else if ((pdu_rx->type == PDU_ADV_TYPE_CONNECT_IND) &&
 1010548:	2b05      	cmp	r3, #5
 101054a:	d1bc      	bne.n	10104c6 <isr_rx+0x26>
 101054c:	f898 3001 	ldrb.w	r3, [r8, #1]
 1010550:	2b22      	cmp	r3, #34	; 0x22
 1010552:	d1b8      	bne.n	10104c6 <isr_rx+0x26>
static inline bool isr_rx_ci_check(struct lll_adv *lll, struct pdu_adv *adv,
				   struct pdu_adv *ci, u8_t devmatch_ok,
				   u8_t *rl_idx)
{
	/* LL 4.3.2: filter policy shall be ignored for directed adv */
	if (adv->type == PDU_ADV_TYPE_DIRECT_IND) {
 1010554:	5d63      	ldrb	r3, [r4, r5]
 1010556:	f003 030f 	and.w	r3, r3, #15
 101055a:	2b01      	cmp	r3, #1
 101055c:	f000 80c8 	beq.w	10106f0 <isr_rx+0x250>
		       isr_rx_ci_adva_check(adv, ci) &&
		       isr_rx_ci_tgta_check(lll, adv, ci, *rl_idx);
	}

#if defined(CONFIG_BT_CTLR_PRIVACY)
	return ((((lll->filter_policy & 0x02) == 0) &&
 1010560:	7b63      	ldrb	r3, [r4, #13]
		 ull_filter_lll_rl_addr_allowed(ci->tx_addr,
						ci->connect_ind.init_addr,
						rl_idx)) ||
		(((lll->filter_policy & 0x02) != 0) &&
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
 1010562:	0799      	lsls	r1, r3, #30
 1010564:	d56e      	bpl.n	1010644 <isr_rx+0x1a4>
		(((lll->filter_policy & 0x02) != 0) &&
 1010566:	2f00      	cmp	r7, #0
 1010568:	f000 80ba 	beq.w	10106e0 <isr_rx+0x240>
}

static inline bool isr_rx_ci_adva_check(struct pdu_adv *adv,
					struct pdu_adv *ci)
{
	return (adv->tx_addr == ci->rx_addr) &&
 101056c:	5d63      	ldrb	r3, [r4, r5]
 101056e:	f898 1000 	ldrb.w	r1, [r8]
 1010572:	f3c3 1280 	ubfx	r2, r3, #6, #1
 1010576:	ebb2 1fd1 	cmp.w	r2, r1, lsr #7
 101057a:	d1a4      	bne.n	10104c6 <isr_rx+0x26>
 101057c:	f003 030f 	and.w	r3, r3, #15
 1010580:	2b01      	cmp	r3, #1
		(((adv->type == PDU_ADV_TYPE_DIRECT_IND) &&
		 !memcmp(adv->direct_ind.adv_addr, ci->connect_ind.adv_addr,
 1010582:	f10a 0a02 	add.w	sl, sl, #2
 1010586:	f108 0508 	add.w	r5, r8, #8
	return (adv->tx_addr == ci->rx_addr) &&
 101058a:	f000 80df 	beq.w	101074c <isr_rx+0x2ac>
			 BDADDR_SIZE)) ||
		 (!memcmp(adv->adv_ind.addr, ci->connect_ind.adv_addr,
 101058e:	4629      	mov	r1, r5
 1010590:	4650      	mov	r0, sl
 1010592:	2206      	movs	r2, #6
 1010594:	f006 f980 	bl	1016898 <memcmp>
			 BDADDR_SIZE)) ||
 1010598:	fab0 f080 	clz	r0, r0
 101059c:	0940      	lsrs	r0, r0, #5
		   (pdu_rx->len == sizeof(struct pdu_adv_connect_ind)) &&
 101059e:	2800      	cmp	r0, #0
 10105a0:	d091      	beq.n	10104c6 <isr_rx+0x26>
				   &rl_idx) &&
 10105a2:	68a3      	ldr	r3, [r4, #8]
 10105a4:	2b00      	cmp	r3, #0
 10105a6:	d08e      	beq.n	10104c6 <isr_rx+0x26>
			rx = ull_pdu_rx_alloc_peek(4);
 10105a8:	2004      	movs	r0, #4
 10105aa:	f7f9 fe1b 	bl	100a1e4 <ull_pdu_rx_alloc_peek>
		if (!rx) {
 10105ae:	2800      	cmp	r0, #0
 10105b0:	d089      	beq.n	10104c6 <isr_rx+0x26>
		radio_isr_set(isr_abort, lll);
 10105b2:	4621      	mov	r1, r4
 10105b4:	488f      	ldr	r0, [pc, #572]	; (10107f4 <isr_rx+0x354>)
 10105b6:	f001 fb1b 	bl	1011bf0 <radio_isr_set>
		radio_disable();
 10105ba:	f001 fc17 	bl	1011dec <radio_disable>
		LL_ASSERT(!radio_is_ready());
 10105be:	f001 fc37 	bl	1011e30 <radio_is_ready>
 10105c2:	2800      	cmp	r0, #0
 10105c4:	f040 8086 	bne.w	10106d4 <isr_rx+0x234>
		if (rssi_ready) {
 10105c8:	f019 0fff 	tst.w	r9, #255	; 0xff
 10105cc:	d17c      	bne.n	10106c8 <isr_rx+0x228>
	int ret = !!hdr->is_stop;
 10105ce:	7923      	ldrb	r3, [r4, #4]
	hdr->is_stop = 1U;
 10105d0:	f043 0201 	orr.w	r2, r3, #1
		LL_ASSERT(!ret);
 10105d4:	07db      	lsls	r3, r3, #31
 10105d6:	7122      	strb	r2, [r4, #4]
 10105d8:	d470      	bmi.n	10106bc <isr_rx+0x21c>
		rx = ull_pdu_rx_alloc();
 10105da:	f7f9 fe21 	bl	100a220 <ull_pdu_rx_alloc>
		rx->hdr.handle = 0xffff;
 10105de:	f64f 73ff 	movw	r3, #65535	; 0xffff
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
 10105e2:	2208      	movs	r2, #8
		rx = ull_pdu_rx_alloc();
 10105e4:	4605      	mov	r5, r0
		rx->hdr.handle = 0xffff;
 10105e6:	80c3      	strh	r3, [r0, #6]
		memcpy(rx->pdu, pdu_rx, (offsetof(struct pdu_adv, connect_ind) +
 10105e8:	4641      	mov	r1, r8
		rx->hdr.type = NODE_RX_TYPE_CONNECTION;
 10105ea:	7102      	strb	r2, [r0, #4]
		memcpy(rx->pdu, pdu_rx, (offsetof(struct pdu_adv, connect_ind) +
 10105ec:	2224      	movs	r2, #36	; 0x24
 10105ee:	3020      	adds	r0, #32
 10105f0:	f006 f962 	bl	10168b8 <memcpy>
		ftr->param = lll;
 10105f4:	60ac      	str	r4, [r5, #8]
		ftr->ticks_anchor = radio_tmr_start_get();
 10105f6:	f001 fdab 	bl	1012150 <radio_tmr_start_get>
 10105fa:	6128      	str	r0, [r5, #16]
		ftr->us_radio_end = radio_tmr_end_get() -
 10105fc:	f001 fe2e 	bl	101225c <radio_tmr_end_get>
				    radio_tx_chain_delay_get(0, 0);
 1010600:	2100      	movs	r1, #0
		ftr->us_radio_end = radio_tmr_end_get() -
 1010602:	4604      	mov	r4, r0
				    radio_tx_chain_delay_get(0, 0);
 1010604:	4608      	mov	r0, r1
 1010606:	f001 fbd3 	bl	1011db0 <radio_tx_chain_delay_get>
		ftr->us_radio_rdy = radio_rx_ready_delay_get(0, 0);
 101060a:	2100      	movs	r1, #0
		ftr->us_radio_end = radio_tmr_end_get() -
 101060c:	1a24      	subs	r4, r4, r0
 101060e:	616c      	str	r4, [r5, #20]
		ftr->us_radio_rdy = radio_rx_ready_delay_get(0, 0);
 1010610:	4608      	mov	r0, r1
 1010612:	f001 fbcf 	bl	1011db4 <radio_rx_ready_delay_get>
 1010616:	61a8      	str	r0, [r5, #24]
		ftr->rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
 1010618:	2e00      	cmp	r6, #0
 101061a:	d04d      	beq.n	10106b8 <isr_rx+0x218>
 101061c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 1010620:	77ab      	strb	r3, [r5, #30]
			ftr->extra = ull_pdu_rx_alloc();
 1010622:	f7f9 fdfd 	bl	100a220 <ull_pdu_rx_alloc>
		ull_rx_put(rx->hdr.link, rx);
 1010626:	4629      	mov	r1, r5
			ftr->extra = ull_pdu_rx_alloc();
 1010628:	60e8      	str	r0, [r5, #12]
		ull_rx_put(rx->hdr.link, rx);
 101062a:	6828      	ldr	r0, [r5, #0]
 101062c:	f7f9 fe10 	bl	100a250 <ull_rx_put>
		ull_rx_sched();
 1010630:	f7f9 fe1e 	bl	100a270 <ull_rx_sched>
}
 1010634:	b005      	add	sp, #20
 1010636:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	u8_t rl_idx = irkmatch_ok ? ull_filter_lll_rl_irk_idx(irkmatch_id) :
 101063a:	fa5f f088 	uxtb.w	r0, r8
 101063e:	f7ff f907 	bl	100f850 <ull_filter_lll_rl_irk_idx>
 1010642:	e76c      	b.n	101051e <isr_rx+0x7e>
		 ull_filter_lll_rl_addr_allowed(ci->tx_addr,
 1010644:	f3c0 1080 	ubfx	r0, r0, #6, #1
 1010648:	f10d 020f 	add.w	r2, sp, #15
 101064c:	f108 0102 	add.w	r1, r8, #2
 1010650:	f7ff f988 	bl	100f964 <ull_filter_lll_rl_addr_allowed>
	return ((((lll->filter_policy & 0x02) == 0) &&
 1010654:	2800      	cmp	r0, #0
 1010656:	d189      	bne.n	101056c <isr_rx+0xcc>
		(((lll->filter_policy & 0x02) != 0) &&
 1010658:	7b63      	ldrb	r3, [r4, #13]
						rl_idx)) ||
 101065a:	079a      	lsls	r2, r3, #30
 101065c:	f57f af33 	bpl.w	10104c6 <isr_rx+0x26>
 1010660:	e781      	b.n	1010566 <isr_rx+0xc6>
	if ((pdu_rx->type == PDU_ADV_TYPE_SCAN_REQ) &&
 1010662:	f898 3001 	ldrb.w	r3, [r8, #1]
 1010666:	2b0c      	cmp	r3, #12
 1010668:	f47f af2d 	bne.w	10104c6 <isr_rx+0x26>
	    (pdu_adv->type != PDU_ADV_TYPE_DIRECT_IND) &&
 101066c:	5d63      	ldrb	r3, [r4, r5]
	    (pdu_rx->len == sizeof(struct pdu_adv_scan_req)) &&
 101066e:	f003 030f 	and.w	r3, r3, #15
 1010672:	2b01      	cmp	r3, #1
 1010674:	f43f af27 	beq.w	10104c6 <isr_rx+0x26>
	return ((((lll->filter_policy & 0x01) == 0) &&
 1010678:	7b63      	ldrb	r3, [r4, #13]
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
 101067a:	07db      	lsls	r3, r3, #31
 101067c:	d50c      	bpl.n	1010698 <isr_rx+0x1f8>
		(((lll->filter_policy & 0x01) != 0) &&
 101067e:	2f00      	cmp	r7, #0
 1010680:	d06d      	beq.n	101075e <isr_rx+0x2be>
	return (adv->tx_addr == sr->rx_addr) &&
 1010682:	5d63      	ldrb	r3, [r4, r5]
 1010684:	f898 0000 	ldrb.w	r0, [r8]
 1010688:	f3c3 1380 	ubfx	r3, r3, #6, #1
 101068c:	ebb3 1fd0 	cmp.w	r3, r0, lsr #7
 1010690:	d06c      	beq.n	101076c <isr_rx+0x2cc>
 1010692:	f000 030f 	and.w	r3, r0, #15
 1010696:	e757      	b.n	1010548 <isr_rx+0xa8>
		 ull_filter_lll_rl_addr_allowed(sr->tx_addr,
 1010698:	f3c0 1080 	ubfx	r0, r0, #6, #1
 101069c:	f10d 020f 	add.w	r2, sp, #15
 10106a0:	f108 0102 	add.w	r1, r8, #2
 10106a4:	f7ff f95e 	bl	100f964 <ull_filter_lll_rl_addr_allowed>
	return ((((lll->filter_policy & 0x01) == 0) &&
 10106a8:	2800      	cmp	r0, #0
 10106aa:	d1ea      	bne.n	1010682 <isr_rx+0x1e2>
		(((lll->filter_policy & 0x01) != 0) &&
 10106ac:	7b63      	ldrb	r3, [r4, #13]
						rl_idx)) ||
 10106ae:	07d8      	lsls	r0, r3, #31
 10106b0:	d4e5      	bmi.n	101067e <isr_rx+0x1de>
 10106b2:	f898 0000 	ldrb.w	r0, [r8]
 10106b6:	e7ec      	b.n	1010692 <isr_rx+0x1f2>
		ftr->rl_idx = irkmatch_ok ? rl_idx : FILTER_IDX_NONE;
 10106b8:	23ff      	movs	r3, #255	; 0xff
 10106ba:	e7b1      	b.n	1010620 <isr_rx+0x180>
		LL_ASSERT(!ret);
 10106bc:	f240 21e5 	movw	r1, #741	; 0x2e5
 10106c0:	484d      	ldr	r0, [pc, #308]	; (10107f8 <isr_rx+0x358>)
 10106c2:	f7f2 ff61 	bl	1003588 <bt_ctlr_assert_handle>
 10106c6:	e788      	b.n	10105da <isr_rx+0x13a>
			lll->conn->rssi_latest =  radio_rssi_get();
 10106c8:	f001 fc28 	bl	1011f1c <radio_rssi_get>
 10106cc:	68a3      	ldr	r3, [r4, #8]
 10106ce:	f883 00a5 	strb.w	r0, [r3, #165]	; 0xa5
 10106d2:	e77c      	b.n	10105ce <isr_rx+0x12e>
		LL_ASSERT(!radio_is_ready());
 10106d4:	f240 21d7 	movw	r1, #727	; 0x2d7
 10106d8:	4847      	ldr	r0, [pc, #284]	; (10107f8 <isr_rx+0x358>)
 10106da:	f7f2 ff55 	bl	1003588 <bt_ctlr_assert_handle>
 10106de:	e773      	b.n	10105c8 <isr_rx+0x128>
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
 10106e0:	f89d 000f 	ldrb.w	r0, [sp, #15]
 10106e4:	f7ff f8e6 	bl	100f8b4 <ull_filter_lll_irk_whitelisted>
 10106e8:	2800      	cmp	r0, #0
 10106ea:	f47f af3f 	bne.w	101056c <isr_rx+0xcc>
 10106ee:	e6ea      	b.n	10104c6 <isr_rx+0x26>
						      ci->connect_ind.init_addr,
 10106f0:	f108 0702 	add.w	r7, r8, #2
		return ull_filter_lll_rl_addr_allowed(ci->tx_addr,
 10106f4:	4639      	mov	r1, r7
 10106f6:	f3c0 1080 	ubfx	r0, r0, #6, #1
 10106fa:	f10d 020f 	add.w	r2, sp, #15
 10106fe:	f7ff f931 	bl	100f964 <ull_filter_lll_rl_addr_allowed>
		       isr_rx_ci_adva_check(adv, ci) &&
 1010702:	2800      	cmp	r0, #0
 1010704:	f43f aedf 	beq.w	10104c6 <isr_rx+0x26>
	return (adv->tx_addr == ci->rx_addr) &&
 1010708:	5d63      	ldrb	r3, [r4, r5]
 101070a:	f898 1000 	ldrb.w	r1, [r8]
 101070e:	f3c3 1280 	ubfx	r2, r3, #6, #1
 1010712:	ebb2 1fd1 	cmp.w	r2, r1, lsr #7
 1010716:	f47f aed6 	bne.w	10104c6 <isr_rx+0x26>
 101071a:	f003 030f 	and.w	r3, r3, #15
 101071e:	2b01      	cmp	r3, #1
		 !memcmp(adv->direct_ind.adv_addr, ci->connect_ind.adv_addr,
 1010720:	f108 0108 	add.w	r1, r8, #8
 1010724:	f10a 0b02 	add.w	fp, sl, #2
	return (adv->tx_addr == ci->rx_addr) &&
 1010728:	d04f      	beq.n	10107ca <isr_rx+0x32a>
		 (!memcmp(adv->adv_ind.addr, ci->connect_ind.adv_addr,
 101072a:	4658      	mov	r0, fp
 101072c:	2206      	movs	r2, #6
 101072e:	f006 f8b3 	bl	1016898 <memcmp>
			 BDADDR_SIZE)) ||
 1010732:	2800      	cmp	r0, #0
 1010734:	f47f aec7 	bne.w	10104c6 <isr_rx+0x26>
		       isr_rx_ci_tgta_check(lll, adv, ci, *rl_idx);
 1010738:	f89d 300f 	ldrb.w	r3, [sp, #15]
	if (rl_idx != FILTER_IDX_NONE) {
 101073c:	2bff      	cmp	r3, #255	; 0xff
 101073e:	d03a      	beq.n	10107b6 <isr_rx+0x316>
		return rl_idx == lll->rl_idx;
 1010740:	7ba0      	ldrb	r0, [r4, #14]
 1010742:	1ac0      	subs	r0, r0, r3
 1010744:	fab0 f080 	clz	r0, r0
 1010748:	0940      	lsrs	r0, r0, #5
 101074a:	e728      	b.n	101059e <isr_rx+0xfe>
		 !memcmp(adv->direct_ind.adv_addr, ci->connect_ind.adv_addr,
 101074c:	4650      	mov	r0, sl
 101074e:	4629      	mov	r1, r5
 1010750:	2206      	movs	r2, #6
 1010752:	f006 f8a1 	bl	1016898 <memcmp>
		(((adv->type == PDU_ADV_TYPE_DIRECT_IND) &&
 1010756:	2800      	cmp	r0, #0
 1010758:	f43f af23 	beq.w	10105a2 <isr_rx+0x102>
 101075c:	e717      	b.n	101058e <isr_rx+0xee>
		 (devmatch_ok || ull_filter_lll_irk_whitelisted(*rl_idx)))) &&
 101075e:	f89d 000f 	ldrb.w	r0, [sp, #15]
 1010762:	f7ff f8a7 	bl	100f8b4 <ull_filter_lll_irk_whitelisted>
 1010766:	2800      	cmp	r0, #0
 1010768:	d18b      	bne.n	1010682 <isr_rx+0x1e2>
 101076a:	e7a2      	b.n	10106b2 <isr_rx+0x212>
		!memcmp(adv->adv_ind.addr, sr->scan_req.adv_addr, BDADDR_SIZE);
 101076c:	2206      	movs	r2, #6
 101076e:	f108 0108 	add.w	r1, r8, #8
 1010772:	f10a 0002 	add.w	r0, sl, #2
 1010776:	f006 f88f 	bl	1016898 <memcmp>
	return (adv->tx_addr == sr->rx_addr) &&
 101077a:	2800      	cmp	r0, #0
 101077c:	d199      	bne.n	10106b2 <isr_rx+0x212>
		radio_isr_set(isr_done, lll);
 101077e:	4621      	mov	r1, r4
 1010780:	481b      	ldr	r0, [pc, #108]	; (10107f0 <isr_rx+0x350>)
 1010782:	f001 fa35 	bl	1011bf0 <radio_isr_set>
		radio_switch_complete_and_disable();
 1010786:	f001 fba9 	bl	1011edc <radio_switch_complete_and_disable>
}

static inline struct pdu_adv *lll_adv_scan_rsp_curr_get(struct lll_adv *lll)
{
	return (void *)lll->scan_rsp.pdu[lll->scan_rsp.first];
 101078a:	f894 305f 	ldrb.w	r3, [r4, #95]	; 0x5f
 101078e:	eb03 0083 	add.w	r0, r3, r3, lsl #2
 1010792:	ebc3 03c0 	rsb	r3, r3, r0, lsl #3
 1010796:	f103 0061 	add.w	r0, r3, #97	; 0x61
		radio_pkt_tx_set(lll_adv_scan_rsp_curr_get(lll));
 101079a:	4420      	add	r0, r4
 101079c:	f001 faf8 	bl	1011d90 <radio_pkt_tx_set>
		LL_ASSERT(!radio_is_ready());
 10107a0:	f001 fb46 	bl	1011e30 <radio_is_ready>
 10107a4:	2800      	cmp	r0, #0
 10107a6:	f43f ae94 	beq.w	10104d2 <isr_rx+0x32>
 10107aa:	f240 219b 	movw	r1, #667	; 0x29b
 10107ae:	4812      	ldr	r0, [pc, #72]	; (10107f8 <isr_rx+0x358>)
 10107b0:	f7f2 feea 	bl	1003588 <bt_ctlr_assert_handle>
		if (!err) {
 10107b4:	e68d      	b.n	10104d2 <isr_rx+0x32>
	return (adv->rx_addr == ci->tx_addr) &&
 10107b6:	f898 3000 	ldrb.w	r3, [r8]
 10107ba:	5d62      	ldrb	r2, [r4, r5]
 10107bc:	f3c3 1380 	ubfx	r3, r3, #6, #1
 10107c0:	ebb3 1fd2 	cmp.w	r3, r2, lsr #7
 10107c4:	d00a      	beq.n	10107dc <isr_rx+0x33c>
 10107c6:	2000      	movs	r0, #0
		       isr_rx_ci_adva_check(adv, ci) &&
 10107c8:	e6e9      	b.n	101059e <isr_rx+0xfe>
		 !memcmp(adv->direct_ind.adv_addr, ci->connect_ind.adv_addr,
 10107ca:	4658      	mov	r0, fp
 10107cc:	2206      	movs	r2, #6
 10107ce:	9101      	str	r1, [sp, #4]
 10107d0:	f006 f862 	bl	1016898 <memcmp>
		(((adv->type == PDU_ADV_TYPE_DIRECT_IND) &&
 10107d4:	2800      	cmp	r0, #0
 10107d6:	d0af      	beq.n	1010738 <isr_rx+0x298>
 10107d8:	9901      	ldr	r1, [sp, #4]
 10107da:	e7a6      	b.n	101072a <isr_rx+0x28a>
	       !memcmp(adv->direct_ind.tgt_addr, ci->connect_ind.init_addr,
 10107dc:	4639      	mov	r1, r7
 10107de:	2206      	movs	r2, #6
 10107e0:	f10a 0008 	add.w	r0, sl, #8
 10107e4:	f006 f858 	bl	1016898 <memcmp>
	return (adv->rx_addr == ci->tx_addr) &&
 10107e8:	fab0 f080 	clz	r0, r0
 10107ec:	0940      	lsrs	r0, r0, #5
 10107ee:	e6d6      	b.n	101059e <isr_rx+0xfe>
 10107f0:	01010449 	.word	0x01010449
 10107f4:	0101009d 	.word	0x0101009d
 10107f8:	010189c0 	.word	0x010189c0

010107fc <lll_adv_init>:
}
 10107fc:	2000      	movs	r0, #0
 10107fe:	4770      	bx	lr

01010800 <lll_adv_reset>:
 1010800:	2000      	movs	r0, #0
 1010802:	4770      	bx	lr

01010804 <lll_adv_prepare>:
{
 1010804:	b510      	push	{r4, lr}
 1010806:	b082      	sub	sp, #8
 1010808:	4604      	mov	r4, r0
	err = lll_hfclock_on();
 101080a:	f7ff fc0f 	bl	101002c <lll_hfclock_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
 101080e:	b108      	cbz	r0, 1010814 <lll_adv_prepare+0x10>
 1010810:	3044      	adds	r0, #68	; 0x44
 1010812:	d112      	bne.n	101083a <lll_adv_prepare+0x36>
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, p);
 1010814:	2300      	movs	r3, #0
 1010816:	4a0b      	ldr	r2, [pc, #44]	; (1010844 <lll_adv_prepare+0x40>)
 1010818:	490b      	ldr	r1, [pc, #44]	; (1010848 <lll_adv_prepare+0x44>)
 101081a:	480c      	ldr	r0, [pc, #48]	; (101084c <lll_adv_prepare+0x48>)
 101081c:	9400      	str	r4, [sp, #0]
 101081e:	f7ff fabd 	bl	100fd9c <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
 1010822:	b108      	cbz	r0, 1010828 <lll_adv_prepare+0x24>
 1010824:	3044      	adds	r0, #68	; 0x44
 1010826:	d101      	bne.n	101082c <lll_adv_prepare+0x28>
}
 1010828:	b002      	add	sp, #8
 101082a:	bd10      	pop	{r4, pc}
	LL_ASSERT(!err || err == -EINPROGRESS);
 101082c:	2171      	movs	r1, #113	; 0x71
 101082e:	4808      	ldr	r0, [pc, #32]	; (1010850 <lll_adv_prepare+0x4c>)
}
 1010830:	b002      	add	sp, #8
 1010832:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LL_ASSERT(!err || err == -EINPROGRESS);
 1010836:	f7f2 bea7 	b.w	1003588 <bt_ctlr_assert_handle>
	LL_ASSERT(!err || err == -EINPROGRESS);
 101083a:	216e      	movs	r1, #110	; 0x6e
 101083c:	4804      	ldr	r0, [pc, #16]	; (1010850 <lll_adv_prepare+0x4c>)
 101083e:	f7f2 fea3 	bl	1003588 <bt_ctlr_assert_handle>
 1010842:	e7e7      	b.n	1010814 <lll_adv_prepare+0x10>
 1010844:	01010279 	.word	0x01010279
 1010848:	0101040d 	.word	0x0101040d
 101084c:	010103a9 	.word	0x010103a9
 1010850:	010189c0 	.word	0x010189c0

01010854 <ticker_stop_cb>:
{
 1010854:	b508      	push	{r3, lr}
	radio_isr_set(isr_cleanup, param);
 1010856:	4619      	mov	r1, r3
 1010858:	4803      	ldr	r0, [pc, #12]	; (1010868 <ticker_stop_cb+0x14>)
 101085a:	f001 f9c9 	bl	1011bf0 <radio_isr_set>
}
 101085e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_disable();
 1010862:	f001 bac3 	b.w	1011dec <radio_disable>
 1010866:	bf00      	nop
 1010868:	01010c5d 	.word	0x01010c5d

0101086c <prepare_cb>:
{
 101086c:	b5f0      	push	{r4, r5, r6, r7, lr}
	struct lll_scan *lll = prepare_param->param;
 101086e:	68c5      	ldr	r5, [r0, #12]
	u32_t aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
 1010870:	4b61      	ldr	r3, [pc, #388]	; (10109f8 <prepare_cb+0x18c>)
	return !!hdr->is_stop;
 1010872:	792c      	ldrb	r4, [r5, #4]
{
 1010874:	b08d      	sub	sp, #52	; 0x34
	if (lll_is_stop(lll)) {
 1010876:	f014 0401 	ands.w	r4, r4, #1
	u32_t aa = sys_cpu_to_le32(PDU_AC_ACCESS_ADDR);
 101087a:	930b      	str	r3, [sp, #44]	; 0x2c
	if (lll_is_stop(lll)) {
 101087c:	d176      	bne.n	101096c <prepare_cb+0x100>
	radio_reset();
 101087e:	4606      	mov	r6, r0
 1010880:	f001 f9d6 	bl	1011c30 <radio_reset>
	radio_tx_power_set(RADIO_TXP_DEFAULT);
 1010884:	4620      	mov	r0, r4
 1010886:	f001 fa0f 	bl	1011ca8 <radio_tx_power_set>
	radio_phy_set(0, 0);
 101088a:	4621      	mov	r1, r4
 101088c:	4620      	mov	r0, r4
 101088e:	f001 f9f3 	bl	1011c78 <radio_phy_set>
	radio_pkt_configure(8, PDU_AC_PAYLOAD_SIZE_MAX, 0);
 1010892:	4622      	mov	r2, r4
 1010894:	2125      	movs	r1, #37	; 0x25
 1010896:	2008      	movs	r0, #8
 1010898:	f001 fa3e 	bl	1011d18 <radio_pkt_configure>
	node_rx = ull_pdu_rx_alloc_peek(1);
 101089c:	2001      	movs	r0, #1
 101089e:	f7f9 fca1 	bl	100a1e4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
 10108a2:	4604      	mov	r4, r0
 10108a4:	2800      	cmp	r0, #0
 10108a6:	f000 80a2 	beq.w	10109ee <prepare_cb+0x182>
	radio_pkt_rx_set(node_rx->pdu);
 10108aa:	f104 0020 	add.w	r0, r4, #32
 10108ae:	f001 fa69 	bl	1011d84 <radio_pkt_rx_set>
	radio_aa_set((u8_t *)&aa);
 10108b2:	a80b      	add	r0, sp, #44	; 0x2c
 10108b4:	f001 fa16 	bl	1011ce4 <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
 10108b8:	4950      	ldr	r1, [pc, #320]	; (10109fc <prepare_cb+0x190>)
 10108ba:	f240 605b 	movw	r0, #1627	; 0x65b
 10108be:	f001 fad5 	bl	1011e6c <radio_crc_configure>
	lll_chan_set(37 + lll->chan);
 10108c2:	7da8      	ldrb	r0, [r5, #22]
 10108c4:	f3c0 0041 	ubfx	r0, r0, #1, #2
 10108c8:	3025      	adds	r0, #37	; 0x25
 10108ca:	f7ff fb35 	bl	100ff38 <lll_chan_set>
	radio_isr_set(isr_rx, lll);
 10108ce:	4629      	mov	r1, r5
 10108d0:	484b      	ldr	r0, [pc, #300]	; (1010a00 <prepare_cb+0x194>)
 10108d2:	f001 f98d 	bl	1011bf0 <radio_isr_set>
	radio_tmr_tifs_set(EVENT_IFS_US);
 10108d6:	2096      	movs	r0, #150	; 0x96
 10108d8:	f001 fb86 	bl	1011fe8 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
 10108dc:	2300      	movs	r3, #0
 10108de:	461a      	mov	r2, r3
 10108e0:	4619      	mov	r1, r3
 10108e2:	4618      	mov	r0, r3
 10108e4:	f001 faee 	bl	1011ec4 <radio_switch_complete_and_tx>
	if (ull_filter_lll_rl_enabled()) {
 10108e8:	f7ff f89a 	bl	100fa20 <ull_filter_lll_rl_enabled>
 10108ec:	bb40      	cbnz	r0, 1010940 <prepare_cb+0xd4>
	if (IS_ENABLED(CONFIG_BT_CTLR_FILTER) && lll->filter_policy) {
 10108ee:	7dab      	ldrb	r3, [r5, #22]
 10108f0:	f013 0f18 	tst.w	r3, #24
 10108f4:	d172      	bne.n	10109dc <prepare_cb+0x170>
	evt = HDR_LLL2EVT(lll);
 10108f6:	682f      	ldr	r7, [r5, #0]
	ticks_at_event = prepare_param->ticks_at_expire;
 10108f8:	6834      	ldr	r4, [r6, #0]
	ticks_at_event += lll_evt_offset_get(evt);
 10108fa:	4638      	mov	r0, r7
 10108fc:	f7ff fb00 	bl	100ff00 <lll_evt_offset_get>
 1010900:	4404      	add	r4, r0
	remainder_us = radio_tmr_start(0, ticks_at_start, remainder);
 1010902:	6872      	ldr	r2, [r6, #4]
 1010904:	f104 0109 	add.w	r1, r4, #9
 1010908:	2000      	movs	r0, #0
 101090a:	f001 fb79 	bl	1012000 <radio_tmr_start>
	radio_tmr_end_capture();
 101090e:	f001 fc8f 	bl	1012230 <radio_tmr_end_capture>
	radio_rssi_measure();
 1010912:	f001 faf9 	bl	1011f08 <radio_rssi_measure>
				   ull_scan_lll_handle_get(lll)),
 1010916:	4628      	mov	r0, r5
 1010918:	f7fa fa52 	bl	100adc0 <ull_scan_lll_handle_get>
	if (lll_preempt_calc(evt, (TICKER_ID_SCAN_BASE +
 101091c:	1d01      	adds	r1, r0, #4
 101091e:	b2c9      	uxtb	r1, r1
 1010920:	4638      	mov	r0, r7
 1010922:	4622      	mov	r2, r4
 1010924:	f7ff faf6 	bl	100ff14 <lll_preempt_calc>
 1010928:	4601      	mov	r1, r0
 101092a:	bb70      	cbnz	r0, 101098a <prepare_cb+0x11e>
		if (lll->ticks_window) {
 101092c:	6aab      	ldr	r3, [r5, #40]	; 0x28
 101092e:	2b00      	cmp	r3, #0
 1010930:	d13c      	bne.n	10109ac <prepare_cb+0x140>
		ret = lll_prepare_done(lll);
 1010932:	4628      	mov	r0, r5
 1010934:	f7ff faa6 	bl	100fe84 <lll_prepare_done>
		LL_ASSERT(!ret);
 1010938:	bb80      	cbnz	r0, 101099c <prepare_cb+0x130>
}
 101093a:	2000      	movs	r0, #0
 101093c:	b00d      	add	sp, #52	; 0x34
 101093e:	bdf0      	pop	{r4, r5, r6, r7, pc}
			ull_filter_lll_get(!!(lll->filter_policy & 0x1));
 1010940:	7da8      	ldrb	r0, [r5, #22]
 1010942:	f3c0 00c0 	ubfx	r0, r0, #3, #1
 1010946:	f7fe ffd9 	bl	100f8fc <ull_filter_lll_get>
 101094a:	4604      	mov	r4, r0
		u8_t count, *irks = ull_filter_lll_irks_get(&count);
 101094c:	f10d 002b 	add.w	r0, sp, #43	; 0x2b
 1010950:	f7fe ff34 	bl	100f7bc <ull_filter_lll_irks_get>
 1010954:	4607      	mov	r7, r0
		radio_filter_configure(filter->enable_bitmask,
 1010956:	7861      	ldrb	r1, [r4, #1]
 1010958:	7820      	ldrb	r0, [r4, #0]
 101095a:	1ca2      	adds	r2, r4, #2
 101095c:	f001 faf6 	bl	1011f4c <radio_filter_configure>
		radio_ar_configure(count, irks);
 1010960:	4639      	mov	r1, r7
 1010962:	f89d 002b 	ldrb.w	r0, [sp, #43]	; 0x2b
 1010966:	f001 fd35 	bl	10123d4 <radio_ar_configure>
 101096a:	e7c4      	b.n	10108f6 <prepare_cb+0x8a>
		err = lll_hfclock_off();
 101096c:	f7ff fb66 	bl	101003c <lll_hfclock_off>
		LL_ASSERT(!err || err == -EBUSY);
 1010970:	b128      	cbz	r0, 101097e <prepare_cb+0x112>
 1010972:	3010      	adds	r0, #16
 1010974:	d003      	beq.n	101097e <prepare_cb+0x112>
 1010976:	218b      	movs	r1, #139	; 0x8b
 1010978:	4822      	ldr	r0, [pc, #136]	; (1010a04 <prepare_cb+0x198>)
 101097a:	f7f2 fe05 	bl	1003588 <bt_ctlr_assert_handle>
		lll_done(NULL);
 101097e:	2000      	movs	r0, #0
 1010980:	f7ff fa82 	bl	100fe88 <lll_done>
}
 1010984:	2000      	movs	r0, #0
 1010986:	b00d      	add	sp, #52	; 0x34
 1010988:	bdf0      	pop	{r4, r5, r6, r7, pc}
		radio_isr_set(isr_abort, lll);
 101098a:	4629      	mov	r1, r5
 101098c:	481e      	ldr	r0, [pc, #120]	; (1010a08 <prepare_cb+0x19c>)
 101098e:	f001 f92f 	bl	1011bf0 <radio_isr_set>
		radio_disable();
 1010992:	f001 fa2b 	bl	1011dec <radio_disable>
}
 1010996:	2000      	movs	r0, #0
 1010998:	b00d      	add	sp, #52	; 0x34
 101099a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		LL_ASSERT(!ret);
 101099c:	f44f 7182 	mov.w	r1, #260	; 0x104
 10109a0:	4818      	ldr	r0, [pc, #96]	; (1010a04 <prepare_cb+0x198>)
 10109a2:	f7f2 fdf1 	bl	1003588 <bt_ctlr_assert_handle>
}
 10109a6:	2000      	movs	r0, #0
 10109a8:	b00d      	add	sp, #52	; 0x34
 10109aa:	bdf0      	pop	{r4, r5, r6, r7, pc}
			ret = ticker_start(TICKER_INSTANCE_ID_CTLR,
 10109ac:	22fe      	movs	r2, #254	; 0xfe
 10109ae:	4e17      	ldr	r6, [pc, #92]	; (1010a0c <prepare_cb+0x1a0>)
 10109b0:	9208      	str	r2, [sp, #32]
 10109b2:	4a17      	ldr	r2, [pc, #92]	; (1010a10 <prepare_cb+0x1a4>)
 10109b4:	9300      	str	r3, [sp, #0]
 10109b6:	9205      	str	r2, [sp, #20]
 10109b8:	4623      	mov	r3, r4
 10109ba:	2203      	movs	r2, #3
 10109bc:	e9cd 0003 	strd	r0, r0, [sp, #12]
 10109c0:	e9cd 0001 	strd	r0, r0, [sp, #4]
 10109c4:	9506      	str	r5, [sp, #24]
 10109c6:	9607      	str	r6, [sp, #28]
 10109c8:	f7f6 fbce 	bl	1007168 <ticker_start>
			LL_ASSERT((ret == TICKER_STATUS_SUCCESS) ||
 10109cc:	f030 0302 	bics.w	r3, r0, #2
 10109d0:	d0af      	beq.n	1010932 <prepare_cb+0xc6>
 10109d2:	21ff      	movs	r1, #255	; 0xff
 10109d4:	480b      	ldr	r0, [pc, #44]	; (1010a04 <prepare_cb+0x198>)
 10109d6:	f7f2 fdd7 	bl	1003588 <bt_ctlr_assert_handle>
 10109da:	e7aa      	b.n	1010932 <prepare_cb+0xc6>
		struct lll_filter *wl = ull_filter_lll_get(true);
 10109dc:	2001      	movs	r0, #1
 10109de:	f7fe ff8d 	bl	100f8fc <ull_filter_lll_get>
		radio_filter_configure(wl->enable_bitmask,
 10109e2:	7841      	ldrb	r1, [r0, #1]
 10109e4:	1c82      	adds	r2, r0, #2
 10109e6:	7800      	ldrb	r0, [r0, #0]
 10109e8:	f001 fab0 	bl	1011f4c <radio_filter_configure>
 10109ec:	e783      	b.n	10108f6 <prepare_cb+0x8a>
	LL_ASSERT(node_rx);
 10109ee:	21a4      	movs	r1, #164	; 0xa4
 10109f0:	4804      	ldr	r0, [pc, #16]	; (1010a04 <prepare_cb+0x198>)
 10109f2:	f7f2 fdc9 	bl	1003588 <bt_ctlr_assert_handle>
 10109f6:	e758      	b.n	10108aa <prepare_cb+0x3e>
 10109f8:	8e89bed6 	.word	0x8e89bed6
 10109fc:	00555555 	.word	0x00555555
 1010a00:	01002cf9 	.word	0x01002cf9
 1010a04:	01018a1c 	.word	0x01018a1c
 1010a08:	01010cd1 	.word	0x01010cd1
 1010a0c:	01010b99 	.word	0x01010b99
 1010a10:	01010855 	.word	0x01010855

01010a14 <isr_race>:
	radio_status_reset();
 1010a14:	f001 ba00 	b.w	1011e18 <radio_status_reset>

01010a18 <isr_common_done>:
{
 1010a18:	b530      	push	{r4, r5, lr}
 1010a1a:	b083      	sub	sp, #12
 1010a1c:	4605      	mov	r5, r0
	radio_status_reset();
 1010a1e:	f001 f9fb 	bl	1011e18 <radio_status_reset>
	radio_tmr_status_reset();
 1010a22:	f001 fad1 	bl	1011fc8 <radio_tmr_status_reset>
	radio_filter_status_reset();
 1010a26:	f001 fab7 	bl	1011f98 <radio_filter_status_reset>
	radio_ar_status_reset();
 1010a2a:	f001 fd11 	bl	1012450 <radio_ar_status_reset>
	radio_rssi_status_reset();
 1010a2e:	f001 fa7b 	bl	1011f28 <radio_rssi_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
 1010a32:	2096      	movs	r0, #150	; 0x96
 1010a34:	f001 fad8 	bl	1011fe8 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
 1010a38:	2300      	movs	r3, #0
 1010a3a:	4618      	mov	r0, r3
 1010a3c:	461a      	mov	r2, r3
 1010a3e:	4619      	mov	r1, r3
 1010a40:	f001 fa40 	bl	1011ec4 <radio_switch_complete_and_tx>
	node_rx = ull_pdu_rx_alloc_peek(1);
 1010a44:	2001      	movs	r0, #1
 1010a46:	f7f9 fbcd 	bl	100a1e4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
 1010a4a:	4604      	mov	r4, r0
 1010a4c:	b1c0      	cbz	r0, 1010a80 <isr_common_done+0x68>
	radio_pkt_rx_set(node_rx->pdu);
 1010a4e:	f104 0020 	add.w	r0, r4, #32
 1010a52:	f001 f997 	bl	1011d84 <radio_pkt_rx_set>
	if (ull_filter_lll_rl_enabled()) {
 1010a56:	f7fe ffe3 	bl	100fa20 <ull_filter_lll_rl_enabled>
 1010a5a:	b938      	cbnz	r0, 1010a6c <isr_common_done+0x54>
	radio_rssi_measure();
 1010a5c:	f001 fa54 	bl	1011f08 <radio_rssi_measure>
	radio_isr_set(isr_rx, param);
 1010a60:	4629      	mov	r1, r5
 1010a62:	480a      	ldr	r0, [pc, #40]	; (1010a8c <isr_common_done+0x74>)
 1010a64:	f001 f8c4 	bl	1011bf0 <radio_isr_set>
}
 1010a68:	b003      	add	sp, #12
 1010a6a:	bd30      	pop	{r4, r5, pc}
		u8_t count, *irks = ull_filter_lll_irks_get(&count);
 1010a6c:	f10d 0007 	add.w	r0, sp, #7
 1010a70:	f7fe fea4 	bl	100f7bc <ull_filter_lll_irks_get>
 1010a74:	4601      	mov	r1, r0
		radio_ar_configure(count, irks);
 1010a76:	f89d 0007 	ldrb.w	r0, [sp, #7]
 1010a7a:	f001 fcab 	bl	10123d4 <radio_ar_configure>
 1010a7e:	e7ed      	b.n	1010a5c <isr_common_done+0x44>
	LL_ASSERT(node_rx);
 1010a80:	f44f 71fe 	mov.w	r1, #508	; 0x1fc
 1010a84:	4802      	ldr	r0, [pc, #8]	; (1010a90 <isr_common_done+0x78>)
 1010a86:	f7f2 fd7f 	bl	1003588 <bt_ctlr_assert_handle>
 1010a8a:	e7e0      	b.n	1010a4e <isr_common_done+0x36>
 1010a8c:	01002cf9 	.word	0x01002cf9
 1010a90:	01018a1c 	.word	0x01018a1c

01010a94 <isr_done>:
{
 1010a94:	b508      	push	{r3, lr}
	isr_common_done(param);
 1010a96:	f7ff ffbf 	bl	1010a18 <isr_common_done>
	radio_rx_enable();
 1010a9a:	f001 f99b 	bl	1011dd4 <radio_rx_enable>
}
 1010a9e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_tmr_end_capture();
 1010aa2:	f001 bbc5 	b.w	1012230 <radio_tmr_end_capture>
 1010aa6:	bf00      	nop

01010aa8 <isr_tx>:
{
 1010aa8:	b570      	push	{r4, r5, r6, lr}
 1010aaa:	b082      	sub	sp, #8
 1010aac:	4605      	mov	r5, r0
	radio_status_reset();
 1010aae:	f001 f9b3 	bl	1011e18 <radio_status_reset>
	radio_tmr_status_reset();
 1010ab2:	f001 fa89 	bl	1011fc8 <radio_tmr_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
 1010ab6:	2096      	movs	r0, #150	; 0x96
 1010ab8:	f001 fa96 	bl	1011fe8 <radio_tmr_tifs_set>
	radio_switch_complete_and_tx(0, 0, 0, 0);
 1010abc:	2300      	movs	r3, #0
 1010abe:	4618      	mov	r0, r3
 1010ac0:	461a      	mov	r2, r3
 1010ac2:	4619      	mov	r1, r3
 1010ac4:	f001 f9fe 	bl	1011ec4 <radio_switch_complete_and_tx>
	node_rx = ull_pdu_rx_alloc_peek(1);
 1010ac8:	2001      	movs	r0, #1
 1010aca:	f7f9 fb8b 	bl	100a1e4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
 1010ace:	4604      	mov	r4, r0
 1010ad0:	b3a8      	cbz	r0, 1010b3e <isr_tx+0x96>
	radio_pkt_rx_set(node_rx->pdu);
 1010ad2:	f104 0020 	add.w	r0, r4, #32
 1010ad6:	f001 f955 	bl	1011d84 <radio_pkt_rx_set>
	LL_ASSERT(!radio_is_ready());
 1010ada:	f001 f9a9 	bl	1011e30 <radio_is_ready>
 1010ade:	b9d8      	cbnz	r0, 1010b18 <isr_tx+0x70>
	if (ull_filter_lll_rl_enabled()) {
 1010ae0:	f7fe ff9e 	bl	100fa20 <ull_filter_lll_rl_enabled>
 1010ae4:	bb08      	cbnz	r0, 1010b2a <isr_tx+0x82>
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
 1010ae6:	f001 fbbf 	bl	1012268 <radio_tmr_tifs_base_get>
	hcto += radio_rx_chain_delay_get(0, 0);
 1010aea:	2100      	movs	r1, #0
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 + 1;
 1010aec:	4604      	mov	r4, r0
	hcto += radio_rx_chain_delay_get(0, 0);
 1010aee:	4608      	mov	r0, r1
 1010af0:	f001 f962 	bl	1011db8 <radio_rx_chain_delay_get>
	hcto -= radio_tx_chain_delay_get(0, 0);
 1010af4:	2100      	movs	r1, #0
	hcto += radio_rx_chain_delay_get(0, 0);
 1010af6:	4606      	mov	r6, r0
	hcto -= radio_tx_chain_delay_get(0, 0);
 1010af8:	4608      	mov	r0, r1
 1010afa:	f001 f959 	bl	1011db0 <radio_tx_chain_delay_get>
 1010afe:	4434      	add	r4, r6
 1010b00:	34c3      	adds	r4, #195	; 0xc3
	radio_tmr_hcto_configure(hcto);
 1010b02:	1a20      	subs	r0, r4, r0
 1010b04:	f001 fb3e 	bl	1012184 <radio_tmr_hcto_configure>
	radio_rssi_measure();
 1010b08:	f001 f9fe 	bl	1011f08 <radio_rssi_measure>
	radio_isr_set(isr_rx, param);
 1010b0c:	4629      	mov	r1, r5
 1010b0e:	480f      	ldr	r0, [pc, #60]	; (1010b4c <isr_tx+0xa4>)
 1010b10:	f001 f86e 	bl	1011bf0 <radio_isr_set>
}
 1010b14:	b002      	add	sp, #8
 1010b16:	bd70      	pop	{r4, r5, r6, pc}
	LL_ASSERT(!radio_is_ready());
 1010b18:	f240 11c7 	movw	r1, #455	; 0x1c7
 1010b1c:	480c      	ldr	r0, [pc, #48]	; (1010b50 <isr_tx+0xa8>)
 1010b1e:	f7f2 fd33 	bl	1003588 <bt_ctlr_assert_handle>
	if (ull_filter_lll_rl_enabled()) {
 1010b22:	f7fe ff7d 	bl	100fa20 <ull_filter_lll_rl_enabled>
 1010b26:	2800      	cmp	r0, #0
 1010b28:	d0dd      	beq.n	1010ae6 <isr_tx+0x3e>
		u8_t count, *irks = ull_filter_lll_irks_get(&count);
 1010b2a:	f10d 0007 	add.w	r0, sp, #7
 1010b2e:	f7fe fe45 	bl	100f7bc <ull_filter_lll_irks_get>
 1010b32:	4601      	mov	r1, r0
		radio_ar_configure(count, irks);
 1010b34:	f89d 0007 	ldrb.w	r0, [sp, #7]
 1010b38:	f001 fc4c 	bl	10123d4 <radio_ar_configure>
 1010b3c:	e7d3      	b.n	1010ae6 <isr_tx+0x3e>
	LL_ASSERT(node_rx);
 1010b3e:	f240 11c3 	movw	r1, #451	; 0x1c3
 1010b42:	4803      	ldr	r0, [pc, #12]	; (1010b50 <isr_tx+0xa8>)
 1010b44:	f7f2 fd20 	bl	1003588 <bt_ctlr_assert_handle>
 1010b48:	e7c3      	b.n	1010ad2 <isr_tx+0x2a>
 1010b4a:	bf00      	nop
 1010b4c:	01002cf9 	.word	0x01002cf9
 1010b50:	01018a1c 	.word	0x01018a1c

01010b54 <resume_prepare_cb>:
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
 1010b54:	68c3      	ldr	r3, [r0, #12]
{
 1010b56:	b570      	push	{r4, r5, r6, lr}
 1010b58:	4604      	mov	r4, r0
	struct evt_hdr *evt = HDR_LLL2EVT(p->param);
 1010b5a:	681e      	ldr	r6, [r3, #0]
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
 1010b5c:	f7f6 fba4 	bl	10072a8 <ticker_ticks_now_get>
 1010b60:	4605      	mov	r5, r0
 1010b62:	4630      	mov	r0, r6
 1010b64:	f7ff f9cc 	bl	100ff00 <lll_evt_offset_get>
	p->remainder = 0;
 1010b68:	2300      	movs	r3, #0
	p->ticks_at_expire = ticker_ticks_now_get() - lll_evt_offset_get(evt);
 1010b6a:	1a2d      	subs	r5, r5, r0
	p->remainder = 0;
 1010b6c:	e9c4 5300 	strd	r5, r3, [r4]
	return prepare_cb(p);
 1010b70:	4620      	mov	r0, r4
	p->lazy = 0;
 1010b72:	8123      	strh	r3, [r4, #8]
}
 1010b74:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	return prepare_cb(p);
 1010b78:	f7ff be78 	b.w	101086c <prepare_cb>

01010b7c <isr_window>:
{
 1010b7c:	b508      	push	{r3, lr}
	isr_common_done(param);
 1010b7e:	f7ff ff4b 	bl	1010a18 <isr_common_done>
	ticks_at_start = ticker_ticks_now_get() +
 1010b82:	f7f6 fb91 	bl	10072a8 <ticker_ticks_now_get>
 1010b86:	4601      	mov	r1, r0
	remainder_us = radio_tmr_start_tick(0, ticks_at_start);
 1010b88:	2000      	movs	r0, #0
 1010b8a:	3103      	adds	r1, #3
 1010b8c:	f001 faa8 	bl	10120e0 <radio_tmr_start_tick>
}
 1010b90:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	radio_tmr_end_capture();
 1010b94:	f001 bb4c 	b.w	1012230 <radio_tmr_end_capture>

01010b98 <ticker_op_start_cb>:
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 1010b98:	b900      	cbnz	r0, 1010b9c <ticker_op_start_cb+0x4>
}
 1010b9a:	4770      	bx	lr
	LL_ASSERT(status == TICKER_STATUS_SUCCESS);
 1010b9c:	f44f 71b0 	mov.w	r1, #352	; 0x160
 1010ba0:	4801      	ldr	r0, [pc, #4]	; (1010ba8 <ticker_op_start_cb+0x10>)
 1010ba2:	f7f2 bcf1 	b.w	1003588 <bt_ctlr_assert_handle>
 1010ba6:	bf00      	nop
 1010ba8:	01018a1c 	.word	0x01018a1c

01010bac <abort_cb>:
{
 1010bac:	b510      	push	{r4, lr}
	if (!prepare_param) {
 1010bae:	b178      	cbz	r0, 1010bd0 <abort_cb+0x24>
	err = lll_hfclock_off();
 1010bb0:	460c      	mov	r4, r1
 1010bb2:	f7ff fa43 	bl	101003c <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
 1010bb6:	b130      	cbz	r0, 1010bc6 <abort_cb+0x1a>
 1010bb8:	3010      	adds	r0, #16
 1010bba:	d004      	beq.n	1010bc6 <abort_cb+0x1a>
 1010bbc:	f44f 71a8 	mov.w	r1, #336	; 0x150
 1010bc0:	4807      	ldr	r0, [pc, #28]	; (1010be0 <abort_cb+0x34>)
 1010bc2:	f7f2 fce1 	bl	1003588 <bt_ctlr_assert_handle>
	lll_done(param);
 1010bc6:	4620      	mov	r0, r4
}
 1010bc8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
 1010bcc:	f7ff b95c 	b.w	100fe88 <lll_done>
			radio_isr_set(isr_abort, param);
 1010bd0:	4804      	ldr	r0, [pc, #16]	; (1010be4 <abort_cb+0x38>)
 1010bd2:	f001 f80d 	bl	1011bf0 <radio_isr_set>
}
 1010bd6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
			radio_disable();
 1010bda:	f001 b907 	b.w	1011dec <radio_disable>
 1010bde:	bf00      	nop
 1010be0:	01018a1c 	.word	0x01018a1c
 1010be4:	01010cd1 	.word	0x01010cd1

01010be8 <is_abort_cb>:
	if (next != curr) {
 1010be8:	4282      	cmp	r2, r0
{
 1010bea:	b510      	push	{r4, lr}
	if (next != curr) {
 1010bec:	d11b      	bne.n	1010c26 <is_abort_cb+0x3e>
	radio_isr_set(isr_window, lll);
 1010bee:	4614      	mov	r4, r2
 1010bf0:	4817      	ldr	r0, [pc, #92]	; (1010c50 <is_abort_cb+0x68>)
 1010bf2:	4611      	mov	r1, r2
 1010bf4:	f000 fffc 	bl	1011bf0 <radio_isr_set>
	radio_disable();
 1010bf8:	f001 f8f8 	bl	1011dec <radio_disable>
	if (++lll->chan == 3U) {
 1010bfc:	7da3      	ldrb	r3, [r4, #22]
 1010bfe:	f3c3 0041 	ubfx	r0, r3, #1, #2
 1010c02:	3001      	adds	r0, #1
 1010c04:	f000 0003 	and.w	r0, r0, #3
 1010c08:	2803      	cmp	r0, #3
 1010c0a:	d007      	beq.n	1010c1c <is_abort_cb+0x34>
 1010c0c:	f360 0342 	bfi	r3, r0, #1, #2
 1010c10:	75a3      	strb	r3, [r4, #22]
 1010c12:	3025      	adds	r0, #37	; 0x25
	lll_chan_set(37 + lll->chan);
 1010c14:	f7ff f990 	bl	100ff38 <lll_chan_set>
	return 0;
 1010c18:	2000      	movs	r0, #0
}
 1010c1a:	bd10      	pop	{r4, pc}
		lll->chan = 0U;
 1010c1c:	f36f 0342 	bfc	r3, #1, #2
 1010c20:	2025      	movs	r0, #37	; 0x25
 1010c22:	75a3      	strb	r3, [r4, #22]
 1010c24:	e7f6      	b.n	1010c14 <is_abort_cb+0x2c>
		*resume_prio = 0; /* TODO: */
 1010c26:	2200      	movs	r2, #0
		*resume_cb = resume_prepare_cb;
 1010c28:	490a      	ldr	r1, [pc, #40]	; (1010c54 <is_abort_cb+0x6c>)
 1010c2a:	6019      	str	r1, [r3, #0]
		*resume_prio = 0; /* TODO: */
 1010c2c:	9b02      	ldr	r3, [sp, #8]
 1010c2e:	601a      	str	r2, [r3, #0]
		err = lll_hfclock_on();
 1010c30:	f7ff f9fc 	bl	101002c <lll_hfclock_on>
		LL_ASSERT(!err || err == -EINPROGRESS);
 1010c34:	b148      	cbz	r0, 1010c4a <is_abort_cb+0x62>
 1010c36:	3044      	adds	r0, #68	; 0x44
 1010c38:	d007      	beq.n	1010c4a <is_abort_cb+0x62>
 1010c3a:	f44f 7193 	mov.w	r1, #294	; 0x126
 1010c3e:	4806      	ldr	r0, [pc, #24]	; (1010c58 <is_abort_cb+0x70>)
 1010c40:	f7f2 fca2 	bl	1003588 <bt_ctlr_assert_handle>
 1010c44:	f06f 000a 	mvn.w	r0, #10
}
 1010c48:	bd10      	pop	{r4, pc}
 1010c4a:	f06f 000a 	mvn.w	r0, #10
 1010c4e:	bd10      	pop	{r4, pc}
 1010c50:	01010b7d 	.word	0x01010b7d
 1010c54:	01010b55 	.word	0x01010b55
 1010c58:	01018a1c 	.word	0x01018a1c

01010c5c <isr_cleanup>:
{
 1010c5c:	b538      	push	{r3, r4, r5, lr}
 1010c5e:	4604      	mov	r4, r0
	if (lll_is_done(param)) {
 1010c60:	f7ff f946 	bl	100fef0 <lll_is_done>
 1010c64:	b100      	cbz	r0, 1010c68 <isr_cleanup+0xc>
}
 1010c66:	bd38      	pop	{r3, r4, r5, pc}
	radio_filter_disable();
 1010c68:	4605      	mov	r5, r0
 1010c6a:	f001 f98b 	bl	1011f84 <radio_filter_disable>
	if (++lll->chan == 3U) {
 1010c6e:	7da2      	ldrb	r2, [r4, #22]
	radio_isr_set(isr_race, param);
 1010c70:	4621      	mov	r1, r4
	if (++lll->chan == 3U) {
 1010c72:	f3c2 0341 	ubfx	r3, r2, #1, #2
 1010c76:	3301      	adds	r3, #1
 1010c78:	f003 0303 	and.w	r3, r3, #3
 1010c7c:	2b03      	cmp	r3, #3
 1010c7e:	bf14      	ite	ne
 1010c80:	f363 0242 	bfine	r2, r3, #1, #2
		lll->chan = 0U;
 1010c84:	f365 0242 	bfieq	r2, r5, #1, #2
	radio_isr_set(isr_race, param);
 1010c88:	480f      	ldr	r0, [pc, #60]	; (1010cc8 <isr_cleanup+0x6c>)
		lll->chan = 0U;
 1010c8a:	75a2      	strb	r2, [r4, #22]
	radio_isr_set(isr_race, param);
 1010c8c:	f000 ffb0 	bl	1011bf0 <radio_isr_set>
	if (!radio_is_idle()) {
 1010c90:	f001 f8e2 	bl	1011e58 <radio_is_idle>
 1010c94:	b1a8      	cbz	r0, 1010cc2 <isr_cleanup+0x66>
	radio_tmr_stop();
 1010c96:	f001 fa61 	bl	101215c <radio_tmr_stop>
	err = lll_hfclock_off();
 1010c9a:	f7ff f9cf 	bl	101003c <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
 1010c9e:	b108      	cbz	r0, 1010ca4 <isr_cleanup+0x48>
 1010ca0:	3010      	adds	r0, #16
 1010ca2:	d104      	bne.n	1010cae <isr_cleanup+0x52>
}
 1010ca4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	lll_done(NULL);
 1010ca8:	2000      	movs	r0, #0
 1010caa:	f7ff b8ed 	b.w	100fe88 <lll_done>
	LL_ASSERT(!err || err == -EBUSY);
 1010cae:	4807      	ldr	r0, [pc, #28]	; (1010ccc <isr_cleanup+0x70>)
 1010cb0:	f240 2187 	movw	r1, #647	; 0x287
 1010cb4:	f7f2 fc68 	bl	1003588 <bt_ctlr_assert_handle>
}
 1010cb8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	lll_done(NULL);
 1010cbc:	2000      	movs	r0, #0
 1010cbe:	f7ff b8e3 	b.w	100fe88 <lll_done>
		radio_disable();
 1010cc2:	f001 f893 	bl	1011dec <radio_disable>
 1010cc6:	e7e6      	b.n	1010c96 <isr_cleanup+0x3a>
 1010cc8:	01010a15 	.word	0x01010a15
 1010ccc:	01018a1c 	.word	0x01018a1c

01010cd0 <isr_abort>:
{
 1010cd0:	b510      	push	{r4, lr}
 1010cd2:	b082      	sub	sp, #8
 1010cd4:	4604      	mov	r4, r0
	radio_status_reset();
 1010cd6:	f001 f89f 	bl	1011e18 <radio_status_reset>
	radio_tmr_status_reset();
 1010cda:	f001 f975 	bl	1011fc8 <radio_tmr_status_reset>
	radio_filter_status_reset();
 1010cde:	f001 f95b 	bl	1011f98 <radio_filter_status_reset>
	radio_ar_status_reset();
 1010ce2:	f001 fbb5 	bl	1012450 <radio_ar_status_reset>
	radio_rssi_status_reset();
 1010ce6:	f001 f91f 	bl	1011f28 <radio_rssi_status_reset>
	ticker_stop(TICKER_INSTANCE_ID_CTLR, TICKER_USER_ID_LLL,
 1010cea:	2300      	movs	r3, #0
 1010cec:	2203      	movs	r2, #3
 1010cee:	4619      	mov	r1, r3
 1010cf0:	4618      	mov	r0, r3
 1010cf2:	9300      	str	r3, [sp, #0]
 1010cf4:	f7f6 fa9e 	bl	1007234 <ticker_stop>
	radio_disable();
 1010cf8:	f001 f878 	bl	1011dec <radio_disable>
	isr_cleanup(param);
 1010cfc:	4620      	mov	r0, r4
}
 1010cfe:	b002      	add	sp, #8
 1010d00:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
 1010d04:	f7ff bfaa 	b.w	1010c5c <isr_cleanup>

01010d08 <isr_rx_scan_report.isra.0>:
			&srsp->scan_rsp.addr[0], BDADDR_SIZE) == 0));
}

static u32_t isr_rx_scan_report(struct lll_scan *lll, u8_t rssi_ready,
 1010d08:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1010d0a:	4607      	mov	r7, r0
				u8_t rl_idx, bool dir_report)
{
	struct node_rx_pdu *node_rx;
	struct pdu_adv *pdu_adv_rx;

	node_rx = ull_pdu_rx_alloc_peek(3);
 1010d0c:	2003      	movs	r0, #3
static u32_t isr_rx_scan_report(struct lll_scan *lll, u8_t rssi_ready,
 1010d0e:	460e      	mov	r6, r1
 1010d10:	4615      	mov	r5, r2
	node_rx = ull_pdu_rx_alloc_peek(3);
 1010d12:	f7f9 fa67 	bl	100a1e4 <ull_pdu_rx_alloc_peek>
	if (!node_rx) {
 1010d16:	b1c8      	cbz	r0, 1010d4c <isr_rx_scan_report.isra.0+0x44>
		return 1;
	}
	ull_pdu_rx_alloc();
 1010d18:	4604      	mov	r4, r0
 1010d1a:	f7f9 fa81 	bl	100a220 <ull_pdu_rx_alloc>

	/* Prepare the report (adv or scan resp) */
	node_rx->hdr.handle = 0xffff;
 1010d1e:	f64f 72ff 	movw	r2, #65535	; 0xffff
			LL_ASSERT(0);
			break;
		}
#endif /* CONFIG_BT_CTLR_ADV_EXT */
	} else {
		node_rx->hdr.type = NODE_RX_TYPE_REPORT;
 1010d22:	2304      	movs	r3, #4
	node_rx->hdr.handle = 0xffff;
 1010d24:	80e2      	strh	r2, [r4, #6]
		node_rx->hdr.type = NODE_RX_TYPE_REPORT;
 1010d26:	7123      	strb	r3, [r4, #4]
	}

	pdu_adv_rx = (void *)node_rx->pdu;

	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ?
 1010d28:	b95f      	cbnz	r7, 1010d42 <isr_rx_scan_report.isra.0+0x3a>
 1010d2a:	207f      	movs	r0, #127	; 0x7f
		node_rx->hdr.rx_ftr.chan = _radio.scanner.chan - 1;
		node_rx->hdr.rx_ftr.ticks_anchor = _radio.ticks_anchor;
	}
#endif /* CONFIG_BT_CTLR_EXT_SCAN_FP */

	ull_rx_put(node_rx->hdr.link, node_rx);
 1010d2c:	4621      	mov	r1, r4
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ?
 1010d2e:	7720      	strb	r0, [r4, #28]
	node_rx->hdr.rx_ftr.rl_idx = rl_idx;
 1010d30:	77a6      	strb	r6, [r4, #30]
	ull_rx_put(node_rx->hdr.link, node_rx);
 1010d32:	6820      	ldr	r0, [r4, #0]
	node_rx->hdr.rx_ftr.direct = dir_report;
 1010d34:	77e5      	strb	r5, [r4, #31]
	ull_rx_put(node_rx->hdr.link, node_rx);
 1010d36:	f7f9 fa8b 	bl	100a250 <ull_rx_put>
	ull_rx_sched();
 1010d3a:	f7f9 fa99 	bl	100a270 <ull_rx_sched>

	return 0;
 1010d3e:	2000      	movs	r0, #0
}
 1010d40:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
				   (radio_rssi_get() & 0x7f)
 1010d42:	f001 f8eb 	bl	1011f1c <radio_rssi_get>
	node_rx->hdr.rx_ftr.rssi = (rssi_ready) ?
 1010d46:	f000 007f 	and.w	r0, r0, #127	; 0x7f
 1010d4a:	e7ef      	b.n	1010d2c <isr_rx_scan_report.isra.0+0x24>
		return 1;
 1010d4c:	2001      	movs	r0, #1
}
 1010d4e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

01010d50 <lll_scan_init>:
}
 1010d50:	2000      	movs	r0, #0
 1010d52:	4770      	bx	lr

01010d54 <lll_scan_reset>:
 1010d54:	2000      	movs	r0, #0
 1010d56:	4770      	bx	lr

01010d58 <lll_scan_prepare>:
{
 1010d58:	b510      	push	{r4, lr}
 1010d5a:	b082      	sub	sp, #8
 1010d5c:	4604      	mov	r4, r0
	err = lll_hfclock_on();
 1010d5e:	f7ff f965 	bl	101002c <lll_hfclock_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
 1010d62:	b108      	cbz	r0, 1010d68 <lll_scan_prepare+0x10>
 1010d64:	3044      	adds	r0, #68	; 0x44
 1010d66:	d112      	bne.n	1010d8e <lll_scan_prepare+0x36>
	err = lll_prepare(is_abort_cb, abort_cb, prepare_cb, 0, p);
 1010d68:	2300      	movs	r3, #0
 1010d6a:	4a0b      	ldr	r2, [pc, #44]	; (1010d98 <lll_scan_prepare+0x40>)
 1010d6c:	490b      	ldr	r1, [pc, #44]	; (1010d9c <lll_scan_prepare+0x44>)
 1010d6e:	480c      	ldr	r0, [pc, #48]	; (1010da0 <lll_scan_prepare+0x48>)
 1010d70:	9400      	str	r4, [sp, #0]
 1010d72:	f7ff f813 	bl	100fd9c <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
 1010d76:	b108      	cbz	r0, 1010d7c <lll_scan_prepare+0x24>
 1010d78:	3044      	adds	r0, #68	; 0x44
 1010d7a:	d101      	bne.n	1010d80 <lll_scan_prepare+0x28>
}
 1010d7c:	b002      	add	sp, #8
 1010d7e:	bd10      	pop	{r4, pc}
	LL_ASSERT(!err || err == -EINPROGRESS);
 1010d80:	2170      	movs	r1, #112	; 0x70
 1010d82:	4808      	ldr	r0, [pc, #32]	; (1010da4 <lll_scan_prepare+0x4c>)
}
 1010d84:	b002      	add	sp, #8
 1010d86:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	LL_ASSERT(!err || err == -EINPROGRESS);
 1010d8a:	f7f2 bbfd 	b.w	1003588 <bt_ctlr_assert_handle>
	LL_ASSERT(!err || err == -EINPROGRESS);
 1010d8e:	216d      	movs	r1, #109	; 0x6d
 1010d90:	4804      	ldr	r0, [pc, #16]	; (1010da4 <lll_scan_prepare+0x4c>)
 1010d92:	f7f2 fbf9 	bl	1003588 <bt_ctlr_assert_handle>
 1010d96:	e7e7      	b.n	1010d68 <lll_scan_prepare+0x10>
 1010d98:	0101086d 	.word	0x0101086d
 1010d9c:	01010bad 	.word	0x01010bad
 1010da0:	01010be9 	.word	0x01010be9
 1010da4:	01018a1c 	.word	0x01018a1c

01010da8 <isr_race>:
}

static void isr_race(void *param)
{
	/* NOTE: lll_disable could have a race with ... */
	radio_status_reset();
 1010da8:	f001 b836 	b.w	1011e18 <radio_status_reset>

01010dac <isr_cleanup>:
{
 1010dac:	4601      	mov	r1, r0
 1010dae:	b508      	push	{r3, lr}
	radio_isr_set(isr_race, param);
 1010db0:	480f      	ldr	r0, [pc, #60]	; (1010df0 <isr_cleanup+0x44>)
 1010db2:	f000 ff1d 	bl	1011bf0 <radio_isr_set>
	if (!radio_is_idle()) {
 1010db6:	f001 f84f 	bl	1011e58 <radio_is_idle>
 1010dba:	b1a8      	cbz	r0, 1010de8 <isr_cleanup+0x3c>
	radio_tmr_stop();
 1010dbc:	f001 f9ce 	bl	101215c <radio_tmr_stop>
	err = lll_hfclock_off();
 1010dc0:	f7ff f93c 	bl	101003c <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
 1010dc4:	b108      	cbz	r0, 1010dca <isr_cleanup+0x1e>
 1010dc6:	3010      	adds	r0, #16
 1010dc8:	d104      	bne.n	1010dd4 <isr_cleanup+0x28>
}
 1010dca:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
 1010dce:	2000      	movs	r0, #0
 1010dd0:	f7ff b85a 	b.w	100fe88 <lll_done>
	LL_ASSERT(!err || err == -EBUSY);
 1010dd4:	4807      	ldr	r0, [pc, #28]	; (1010df4 <isr_cleanup+0x48>)
 1010dd6:	f240 219a 	movw	r1, #666	; 0x29a
 1010dda:	f7f2 fbd5 	bl	1003588 <bt_ctlr_assert_handle>
}
 1010dde:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	lll_done(NULL);
 1010de2:	2000      	movs	r0, #0
 1010de4:	f7ff b850 	b.w	100fe88 <lll_done>
		radio_disable();
 1010de8:	f001 f800 	bl	1011dec <radio_disable>
 1010dec:	e7e6      	b.n	1010dbc <isr_cleanup+0x10>
 1010dee:	bf00      	nop
 1010df0:	01010da9 	.word	0x01010da9
 1010df4:	01018a7c 	.word	0x01018a7c

01010df8 <isr_done>:
{
 1010df8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1010dfa:	4606      	mov	r6, r0
	radio_status_reset();
 1010dfc:	f001 f80c 	bl	1011e18 <radio_status_reset>
	radio_tmr_status_reset();
 1010e00:	f001 f8e2 	bl	1011fc8 <radio_tmr_status_reset>
	radio_filter_status_reset();
 1010e04:	f001 f8c8 	bl	1011f98 <radio_filter_status_reset>
	radio_ar_status_reset();
 1010e08:	f001 fb22 	bl	1012450 <radio_ar_status_reset>
	radio_rssi_status_reset();
 1010e0c:	f001 f88c 	bl	1011f28 <radio_rssi_status_reset>
	e = ull_event_done_extra_get();
 1010e10:	f7f9 fa9a 	bl	100a348 <ull_event_done_extra_get>
	LL_ASSERT(e);
 1010e14:	4604      	mov	r4, r0
 1010e16:	2800      	cmp	r0, #0
 1010e18:	d033      	beq.n	1010e82 <isr_done+0x8a>
	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
 1010e1a:	2201      	movs	r2, #1
	e->trx_cnt = trx_cnt;
 1010e1c:	4b1c      	ldr	r3, [pc, #112]	; (1010e90 <isr_done+0x98>)
	e->crc_valid = crc_valid;
 1010e1e:	4d1d      	ldr	r5, [pc, #116]	; (1010e94 <isr_done+0x9c>)
	e->mic_state = mic_state;
 1010e20:	491d      	ldr	r1, [pc, #116]	; (1010e98 <isr_done+0xa0>)
	e->trx_cnt = trx_cnt;
 1010e22:	881b      	ldrh	r3, [r3, #0]
	e->crc_valid = crc_valid;
 1010e24:	782d      	ldrb	r5, [r5, #0]
	e->mic_state = mic_state;
 1010e26:	7809      	ldrb	r1, [r1, #0]
	e->trx_cnt = trx_cnt;
 1010e28:	80a3      	strh	r3, [r4, #4]
	e->crc_valid = crc_valid;
 1010e2a:	71a5      	strb	r5, [r4, #6]
	e->mic_state = mic_state;
 1010e2c:	71e1      	strb	r1, [r4, #7]
	e->type = EVENT_DONE_EXTRA_TYPE_CONN;
 1010e2e:	7022      	strb	r2, [r4, #0]
	if (trx_cnt) {
 1010e30:	b11b      	cbz	r3, 1010e3a <isr_done+0x42>
		if (lll->role) {
 1010e32:	f996 3021 	ldrsb.w	r3, [r6, #33]	; 0x21
 1010e36:	2b00      	cmp	r3, #0
 1010e38:	db04      	blt.n	1010e44 <isr_done+0x4c>
	isr_cleanup(param);
 1010e3a:	4630      	mov	r0, r6
}
 1010e3c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	isr_cleanup(param);
 1010e40:	f7ff bfb4 	b.w	1010dac <isr_cleanup>
				addr_us_get(lll->phy_rx);
 1010e44:	f896 3049 	ldrb.w	r3, [r6, #73]	; 0x49
 1010e48:	f003 0307 	and.w	r3, r3, #7
#define RANGE_DISTANCE 1000 /* meters */
#define RANGE_DELAY_US (2 * RANGE_DISTANCE * 4 / 1000)

static inline u32_t addr_us_get(u8_t phy)
{
	switch (phy) {
 1010e4c:	2b02      	cmp	r3, #2
 1010e4e:	d016      	beq.n	1010e7e <isr_done+0x86>
	case BIT(0):
		return 40;
	case BIT(1):
		return 24;
	case BIT(2):
		return 376;
 1010e50:	2b04      	cmp	r3, #4
 1010e52:	bf14      	ite	ne
 1010e54:	2728      	movne	r7, #40	; 0x28
 1010e56:	f44f 77bc 	moveq.w	r7, #376	; 0x178
				radio_tmr_aa_restore() - radio_tmr_ready_get();
 1010e5a:	f001 f9dd 	bl	1012218 <radio_tmr_aa_restore>
 1010e5e:	4605      	mov	r5, r0
 1010e60:	f001 f9e0 	bl	1012224 <radio_tmr_ready_get>
			lll->slave.window_widening_event_us = 0;
 1010e64:	2300      	movs	r3, #0
			e->slave.window_widening_event_us =
 1010e66:	6b72      	ldr	r2, [r6, #52]	; 0x34
				radio_tmr_aa_restore() - radio_tmr_ready_get();
 1010e68:	1a2d      	subs	r5, r5, r0
			e->slave.window_widening_event_us =
 1010e6a:	e9c4 5202 	strd	r5, r2, [r4, #8]
			e->slave.preamble_to_addr_us = preamble_to_addr_us;
 1010e6e:	6127      	str	r7, [r4, #16]
	isr_cleanup(param);
 1010e70:	4630      	mov	r0, r6
			lll->slave.window_widening_event_us = 0;
 1010e72:	6373      	str	r3, [r6, #52]	; 0x34
			lll->slave.window_size_event_us = 0;
 1010e74:	63f3      	str	r3, [r6, #60]	; 0x3c
}
 1010e76:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	isr_cleanup(param);
 1010e7a:	f7ff bf97 	b.w	1010dac <isr_cleanup>
	switch (phy) {
 1010e7e:	2718      	movs	r7, #24
 1010e80:	e7eb      	b.n	1010e5a <isr_done+0x62>
	LL_ASSERT(e);
 1010e82:	f240 2165 	movw	r1, #613	; 0x265
 1010e86:	4805      	ldr	r0, [pc, #20]	; (1010e9c <isr_done+0xa4>)
 1010e88:	f7f2 fb7e 	bl	1003588 <bt_ctlr_assert_handle>
 1010e8c:	e7c5      	b.n	1010e1a <isr_done+0x22>
 1010e8e:	bf00      	nop
 1010e90:	2100668a 	.word	0x2100668a
 1010e94:	210066f7 	.word	0x210066f7
 1010e98:	210066f8 	.word	0x210066f8
 1010e9c:	01018a7c 	.word	0x01018a7c

01010ea0 <empty_tx_enqueue>:

	return 0;
}

static struct pdu_data *empty_tx_enqueue(struct lll_conn *lll)
{
 1010ea0:	b538      	push	{r3, r4, r5, lr}
	struct pdu_data *p;

	lll->empty = 1;
 1010ea2:	f890 3062 	ldrb.w	r3, [r0, #98]	; 0x62
{
 1010ea6:	4605      	mov	r5, r0
	lll->empty = 1;
 1010ea8:	f043 0304 	orr.w	r3, r3, #4
 1010eac:	f880 3062 	strb.w	r3, [r0, #98]	; 0x62

	p = (void *)radio_pkt_empty_get();
 1010eb0:	f000 fff2 	bl	1011e98 <radio_pkt_empty_get>
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
	p->len = 0;
 1010eb4:	2200      	movs	r2, #0
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
 1010eb6:	2101      	movs	r1, #1
 1010eb8:	7803      	ldrb	r3, [r0, #0]
	p->len = 0;
 1010eba:	7042      	strb	r2, [r0, #1]
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
 1010ebc:	f361 0301 	bfi	r3, r1, #0, #2
	p = (void *)radio_pkt_empty_get();
 1010ec0:	4604      	mov	r4, r0
	p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
 1010ec2:	7003      	strb	r3, [r0, #0]
	if (memq_peek(lll->memq_tx.head, lll->memq_tx.tail, NULL)) {
 1010ec4:	e9d5 0113 	ldrd	r0, r1, [r5, #76]	; 0x4c
 1010ec8:	f7f4 ff16 	bl	1005cf8 <memq_peek>
 1010ecc:	1e03      	subs	r3, r0, #0
 1010ece:	bf18      	it	ne
 1010ed0:	2301      	movne	r3, #1
 1010ed2:	7822      	ldrb	r2, [r4, #0]
	} else {
		p->md = 0;
	}

	return p;
}
 1010ed4:	4620      	mov	r0, r4
 1010ed6:	f363 1204 	bfi	r2, r3, #4, #1
 1010eda:	7022      	strb	r2, [r4, #0]
 1010edc:	bd38      	pop	{r3, r4, r5, pc}
 1010ede:	bf00      	nop

01010ee0 <lll_conn_init>:
}
 1010ee0:	2000      	movs	r0, #0
 1010ee2:	4770      	bx	lr

01010ee4 <lll_conn_reset>:
 1010ee4:	2000      	movs	r0, #0
 1010ee6:	4770      	bx	lr

01010ee8 <lll_conn_sca_local_get>:
}
 1010ee8:	2007      	movs	r0, #7
 1010eea:	4770      	bx	lr

01010eec <lll_conn_ppm_local_get>:
}
 1010eec:	2014      	movs	r0, #20
 1010eee:	4770      	bx	lr

01010ef0 <lll_conn_ppm_get>:
	return sca_ppm_lut[sca];
 1010ef0:	4b01      	ldr	r3, [pc, #4]	; (1010ef8 <lll_conn_ppm_get+0x8>)
}
 1010ef2:	f833 0010 	ldrh.w	r0, [r3, r0, lsl #1]
 1010ef6:	4770      	bx	lr
 1010ef8:	01018adc 	.word	0x01018adc

01010efc <lll_conn_prepare_reset>:
	trx_cnt = 0U;
 1010efc:	2300      	movs	r3, #0
	crc_expire = 0U;
 1010efe:	4805      	ldr	r0, [pc, #20]	; (1010f14 <lll_conn_prepare_reset+0x18>)
	crc_valid = 0U;
 1010f00:	4905      	ldr	r1, [pc, #20]	; (1010f18 <lll_conn_prepare_reset+0x1c>)
	mic_state = LLL_CONN_MIC_NONE;
 1010f02:	4a06      	ldr	r2, [pc, #24]	; (1010f1c <lll_conn_prepare_reset+0x20>)
{
 1010f04:	b410      	push	{r4}
	trx_cnt = 0U;
 1010f06:	4c06      	ldr	r4, [pc, #24]	; (1010f20 <lll_conn_prepare_reset+0x24>)
	crc_expire = 0U;
 1010f08:	7003      	strb	r3, [r0, #0]
	crc_valid = 0U;
 1010f0a:	700b      	strb	r3, [r1, #0]
	mic_state = LLL_CONN_MIC_NONE;
 1010f0c:	7013      	strb	r3, [r2, #0]
	trx_cnt = 0U;
 1010f0e:	8023      	strh	r3, [r4, #0]
}
 1010f10:	bc10      	pop	{r4}
 1010f12:	4770      	bx	lr
 1010f14:	210066f6 	.word	0x210066f6
 1010f18:	210066f7 	.word	0x210066f7
 1010f1c:	210066f8 	.word	0x210066f8
 1010f20:	2100668a 	.word	0x2100668a

01010f24 <lll_conn_is_abort_cb>:
}
 1010f24:	f06f 0047 	mvn.w	r0, #71	; 0x47
 1010f28:	4770      	bx	lr
 1010f2a:	bf00      	nop

01010f2c <lll_conn_abort_cb>:
{
 1010f2c:	b510      	push	{r4, lr}
	if (!prepare_param) {
 1010f2e:	b170      	cbz	r0, 1010f4e <lll_conn_abort_cb+0x22>
	err = lll_hfclock_off();
 1010f30:	460c      	mov	r4, r1
 1010f32:	f7ff f883 	bl	101003c <lll_hfclock_off>
	LL_ASSERT(!err || err == -EBUSY);
 1010f36:	b128      	cbz	r0, 1010f44 <lll_conn_abort_cb+0x18>
 1010f38:	3010      	adds	r0, #16
 1010f3a:	d003      	beq.n	1010f44 <lll_conn_abort_cb+0x18>
 1010f3c:	2182      	movs	r1, #130	; 0x82
 1010f3e:	4807      	ldr	r0, [pc, #28]	; (1010f5c <lll_conn_abort_cb+0x30>)
 1010f40:	f7f2 fb22 	bl	1003588 <bt_ctlr_assert_handle>
	lll_done(param);
 1010f44:	4620      	mov	r0, r4
}
 1010f46:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	lll_done(param);
 1010f4a:	f7fe bf9d 	b.w	100fe88 <lll_done>
		radio_isr_set(isr_done, param);
 1010f4e:	4804      	ldr	r0, [pc, #16]	; (1010f60 <lll_conn_abort_cb+0x34>)
 1010f50:	f000 fe4e 	bl	1011bf0 <radio_isr_set>
}
 1010f54:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		radio_disable();
 1010f58:	f000 bf48 	b.w	1011dec <radio_disable>
 1010f5c:	01018a7c 	.word	0x01018a7c
 1010f60:	01010df9 	.word	0x01010df9

01010f64 <lll_conn_isr_abort>:
{
 1010f64:	b510      	push	{r4, lr}
 1010f66:	4604      	mov	r4, r0
	radio_status_reset();
 1010f68:	f000 ff56 	bl	1011e18 <radio_status_reset>
	radio_tmr_status_reset();
 1010f6c:	f001 f82c 	bl	1011fc8 <radio_tmr_status_reset>
	radio_filter_status_reset();
 1010f70:	f001 f812 	bl	1011f98 <radio_filter_status_reset>
	radio_ar_status_reset();
 1010f74:	f001 fa6c 	bl	1012450 <radio_ar_status_reset>
	radio_rssi_status_reset();
 1010f78:	f000 ffd6 	bl	1011f28 <radio_rssi_status_reset>
	isr_cleanup(param);
 1010f7c:	4620      	mov	r0, r4
}
 1010f7e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	isr_cleanup(param);
 1010f82:	f7ff bf13 	b.w	1010dac <isr_cleanup>
 1010f86:	bf00      	nop

01010f88 <lll_conn_rx_pkt_set>:
{
 1010f88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1010f8a:	4605      	mov	r5, r0
	node_rx = ull_pdu_rx_alloc_peek(1);
 1010f8c:	2001      	movs	r0, #1
 1010f8e:	f7f9 f929 	bl	100a1e4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
 1010f92:	4606      	mov	r6, r0
 1010f94:	b368      	cbz	r0, 1010ff2 <lll_conn_rx_pkt_set+0x6a>
	phy = lll->phy_rx;
 1010f96:	f895 4049 	ldrb.w	r4, [r5, #73]	; 0x49
	radio_phy_set(phy, 0);
 1010f9a:	2100      	movs	r1, #0
	phy = lll->phy_rx;
 1010f9c:	f004 0407 	and.w	r4, r4, #7
	radio_phy_set(phy, 0);
 1010fa0:	4620      	mov	r0, r4
	max_rx_octets = lll->max_rx_octets;
 1010fa2:	f8b5 7042 	ldrh.w	r7, [r5, #66]	; 0x42
	radio_phy_set(phy, 0);
 1010fa6:	f000 fe67 	bl	1011c78 <radio_phy_set>
	} else if (lll->enc_rx) {
 1010faa:	f895 3062 	ldrb.w	r3, [r5, #98]	; 0x62
 1010fae:	071b      	lsls	r3, r3, #28
 1010fb0:	d512      	bpl.n	1010fd8 <lll_conn_rx_pkt_set+0x50>
		radio_pkt_configure(8, (max_rx_octets + 4), (phy << 1) | 0x01);
 1010fb2:	1d39      	adds	r1, r7, #4
 1010fb4:	0062      	lsls	r2, r4, #1
 1010fb6:	2008      	movs	r0, #8
 1010fb8:	b2c9      	uxtb	r1, r1
 1010fba:	f042 0201 	orr.w	r2, r2, #1
 1010fbe:	f000 feab 	bl	1011d18 <radio_pkt_configure>
		radio_pkt_rx_set(radio_ccm_rx_pkt_set(&lll->ccm_rx, phy,
 1010fc2:	4621      	mov	r1, r4
 1010fc4:	f106 0220 	add.w	r2, r6, #32
 1010fc8:	f105 0063 	add.w	r0, r5, #99	; 0x63
 1010fcc:	f001 f952 	bl	1012274 <radio_ccm_rx_pkt_set>
}
 1010fd0:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_rx_set(radio_ccm_rx_pkt_set(&lll->ccm_rx, phy,
 1010fd4:	f000 bed6 	b.w	1011d84 <radio_pkt_rx_set>
		radio_pkt_configure(8, max_rx_octets, (phy << 1) | 0x01);
 1010fd8:	0062      	lsls	r2, r4, #1
 1010fda:	2008      	movs	r0, #8
 1010fdc:	b2f9      	uxtb	r1, r7
 1010fde:	f042 0201 	orr.w	r2, r2, #1
 1010fe2:	f000 fe99 	bl	1011d18 <radio_pkt_configure>
		radio_pkt_rx_set(node_rx->pdu);
 1010fe6:	f106 0020 	add.w	r0, r6, #32
}
 1010fea:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_rx_set(node_rx->pdu);
 1010fee:	f000 bec9 	b.w	1011d84 <radio_pkt_rx_set>
	LL_ASSERT(node_rx);
 1010ff2:	f240 11cf 	movw	r1, #463	; 0x1cf
 1010ff6:	4802      	ldr	r0, [pc, #8]	; (1011000 <lll_conn_rx_pkt_set+0x78>)
 1010ff8:	f7f2 fac6 	bl	1003588 <bt_ctlr_assert_handle>
 1010ffc:	e7cb      	b.n	1010f96 <lll_conn_rx_pkt_set+0xe>
 1010ffe:	bf00      	nop
 1011000:	01018a7c 	.word	0x01018a7c

01011004 <lll_conn_isr_tx>:
{
 1011004:	b538      	push	{r3, r4, r5, lr}
 1011006:	4604      	mov	r4, r0
	radio_status_reset();
 1011008:	f000 ff06 	bl	1011e18 <radio_status_reset>
	radio_tmr_status_reset();
 101100c:	f000 ffdc 	bl	1011fc8 <radio_tmr_status_reset>
	radio_tmr_tifs_set(EVENT_IFS_US);
 1011010:	2096      	movs	r0, #150	; 0x96
 1011012:	f000 ffe9 	bl	1011fe8 <radio_tmr_tifs_set>
				     lll->phy_flags);
 1011016:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
	radio_switch_complete_and_tx(lll->phy_rx, 0,
 101101a:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
 101101e:	f3c2 03c0 	ubfx	r3, r2, #3, #1
 1011022:	2100      	movs	r1, #0
 1011024:	f002 0207 	and.w	r2, r2, #7
 1011028:	f000 0007 	and.w	r0, r0, #7
 101102c:	f000 ff4a 	bl	1011ec4 <radio_switch_complete_and_tx>
	lll_conn_rx_pkt_set(lll);
 1011030:	4620      	mov	r0, r4
 1011032:	f7ff ffa9 	bl	1010f88 <lll_conn_rx_pkt_set>
	LL_ASSERT(!radio_is_ready());
 1011036:	f000 fefb 	bl	1011e30 <radio_is_ready>
 101103a:	bba0      	cbnz	r0, 10110a6 <lll_conn_isr_tx+0xa2>
	hcto = radio_tmr_tifs_base_get() + EVENT_IFS_US + 4 +
 101103c:	f001 f914 	bl	1012268 <radio_tmr_tifs_base_get>
 1011040:	4605      	mov	r5, r0
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
 1011042:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
 1011046:	2101      	movs	r1, #1
 1011048:	f000 0007 	and.w	r0, r0, #7
 101104c:	f000 feb4 	bl	1011db8 <radio_rx_chain_delay_get>
	hcto += addr_us_get(lll->phy_rx);
 1011050:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
 1011054:	4405      	add	r5, r0
	hcto += addr_us_get(lll->phy_rx);
 1011056:	f003 0307 	and.w	r3, r3, #7
 101105a:	2b02      	cmp	r3, #2
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
 101105c:	f105 05a3 	add.w	r5, r5, #163	; 0xa3
 1011060:	d01f      	beq.n	10110a2 <lll_conn_isr_tx+0x9e>
		return 376;
 1011062:	2b04      	cmp	r3, #4
 1011064:	bf14      	ite	ne
 1011066:	2328      	movne	r3, #40	; 0x28
 1011068:	f44f 73bc 	moveq.w	r3, #376	; 0x178
	hcto -= radio_tx_chain_delay_get(lll->phy_tx, lll->phy_flags);
 101106c:	f894 0048 	ldrb.w	r0, [r4, #72]	; 0x48
	hcto += addr_us_get(lll->phy_rx);
 1011070:	441d      	add	r5, r3
	hcto -= radio_tx_chain_delay_get(lll->phy_tx, lll->phy_flags);
 1011072:	f3c0 01c0 	ubfx	r1, r0, #3, #1
 1011076:	f000 0007 	and.w	r0, r0, #7
 101107a:	f000 fe99 	bl	1011db0 <radio_tx_chain_delay_get>
	radio_tmr_hcto_configure(hcto);
 101107e:	1a28      	subs	r0, r5, r0
 1011080:	f001 f880 	bl	1012184 <radio_tmr_hcto_configure>
	if (!trx_cnt && !lll->role) {
 1011084:	4b0b      	ldr	r3, [pc, #44]	; (10110b4 <lll_conn_isr_tx+0xb0>)
 1011086:	881b      	ldrh	r3, [r3, #0]
 1011088:	b92b      	cbnz	r3, 1011096 <lll_conn_isr_tx+0x92>
 101108a:	f994 3021 	ldrsb.w	r3, [r4, #33]	; 0x21
 101108e:	2b00      	cmp	r3, #0
 1011090:	db01      	blt.n	1011096 <lll_conn_isr_tx+0x92>
		radio_rssi_measure();
 1011092:	f000 ff39 	bl	1011f08 <radio_rssi_measure>
	radio_isr_set(lll_conn_isr_rx, param);
 1011096:	4621      	mov	r1, r4
}
 1011098:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	radio_isr_set(lll_conn_isr_rx, param);
 101109c:	4806      	ldr	r0, [pc, #24]	; (10110b8 <lll_conn_isr_tx+0xb4>)
 101109e:	f000 bda7 	b.w	1011bf0 <radio_isr_set>
	switch (phy) {
 10110a2:	2318      	movs	r3, #24
 10110a4:	e7e2      	b.n	101106c <lll_conn_isr_tx+0x68>
	LL_ASSERT(!radio_is_ready());
 10110a6:	f44f 71c5 	mov.w	r1, #394	; 0x18a
 10110aa:	4804      	ldr	r0, [pc, #16]	; (10110bc <lll_conn_isr_tx+0xb8>)
 10110ac:	f7f2 fa6c 	bl	1003588 <bt_ctlr_assert_handle>
 10110b0:	e7c4      	b.n	101103c <lll_conn_isr_tx+0x38>
 10110b2:	bf00      	nop
 10110b4:	2100668a 	.word	0x2100668a
 10110b8:	010111c5 	.word	0x010111c5
 10110bc:	01018a7c 	.word	0x01018a7c

010110c0 <lll_conn_tx_pkt_set>:
{
 10110c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 10110c2:	4604      	mov	r4, r0
	phy = lll->phy_tx;
 10110c4:	f890 3048 	ldrb.w	r3, [r0, #72]	; 0x48
{
 10110c8:	460e      	mov	r6, r1
	phy = lll->phy_tx;
 10110ca:	f003 0507 	and.w	r5, r3, #7
	radio_phy_set(phy, flags);
 10110ce:	f3c3 01c0 	ubfx	r1, r3, #3, #1
 10110d2:	4628      	mov	r0, r5
	max_tx_octets = lll->max_tx_octets;
 10110d4:	f8b4 7040 	ldrh.w	r7, [r4, #64]	; 0x40
	radio_phy_set(phy, flags);
 10110d8:	f000 fdce 	bl	1011c78 <radio_phy_set>
	} else if (lll->enc_tx) {
 10110dc:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
				    (phy << 1) | 0x01);
 10110e0:	006a      	lsls	r2, r5, #1
	} else if (lll->enc_tx) {
 10110e2:	06db      	lsls	r3, r3, #27
 10110e4:	d50f      	bpl.n	1011106 <lll_conn_tx_pkt_set+0x46>
		radio_pkt_configure(8, (max_tx_octets + 4U),
 10110e6:	1d39      	adds	r1, r7, #4
 10110e8:	2008      	movs	r0, #8
 10110ea:	f042 0201 	orr.w	r2, r2, #1
 10110ee:	b2c9      	uxtb	r1, r1
 10110f0:	f000 fe12 	bl	1011d18 <radio_pkt_configure>
		radio_pkt_tx_set(radio_ccm_tx_pkt_set(&lll->ccm_tx,
 10110f4:	4631      	mov	r1, r6
 10110f6:	f104 0084 	add.w	r0, r4, #132	; 0x84
 10110fa:	f001 f917 	bl	101232c <radio_ccm_tx_pkt_set>
}
 10110fe:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_tx_set(radio_ccm_tx_pkt_set(&lll->ccm_tx,
 1011102:	f000 be45 	b.w	1011d90 <radio_pkt_tx_set>
		radio_pkt_configure(8, max_tx_octets, (phy << 1) | 0x01);
 1011106:	2008      	movs	r0, #8
 1011108:	b2f9      	uxtb	r1, r7
 101110a:	f042 0201 	orr.w	r2, r2, #1
 101110e:	f000 fe03 	bl	1011d18 <radio_pkt_configure>
		radio_pkt_tx_set(pdu_data_tx);
 1011112:	4630      	mov	r0, r6
}
 1011114:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
		radio_pkt_tx_set(pdu_data_tx);
 1011118:	f000 be3a 	b.w	1011d90 <radio_pkt_tx_set>

0101111c <lll_conn_pdu_tx_prep>:
{
 101111c:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (lll->empty) {
 1011120:	f890 3062 	ldrb.w	r3, [r0, #98]	; 0x62
{
 1011124:	4688      	mov	r8, r1
	if (lll->empty) {
 1011126:	075b      	lsls	r3, r3, #29
{
 1011128:	b083      	sub	sp, #12
	if (lll->empty) {
 101112a:	d43e      	bmi.n	10111aa <lll_conn_pdu_tx_prep+0x8e>
	link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail, (void **)&tx);
 101112c:	4604      	mov	r4, r0
 101112e:	e9d0 0113 	ldrd	r0, r1, [r0, #76]	; 0x4c
 1011132:	aa01      	add	r2, sp, #4
 1011134:	f7f4 fde0 	bl	1005cf8 <memq_peek>
	if (!link) {
 1011138:	4681      	mov	r9, r0
 101113a:	2800      	cmp	r0, #0
 101113c:	d03c      	beq.n	10111b8 <lll_conn_pdu_tx_prep+0x9c>
		p = (void *)(tx->pdu + lll->packet_tx_head_offset);
 101113e:	9f01      	ldr	r7, [sp, #4]
 1011140:	f894 6061 	ldrb.w	r6, [r4, #97]	; 0x61
		if (!lll->packet_tx_head_len) {
 1011144:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
		p = (void *)(tx->pdu + lll->packet_tx_head_offset);
 1011148:	3704      	adds	r7, #4
 101114a:	19bd      	adds	r5, r7, r6
		if (!lll->packet_tx_head_len) {
 101114c:	b913      	cbnz	r3, 1011154 <lll_conn_pdu_tx_prep+0x38>
			lll->packet_tx_head_len = p->len;
 101114e:	786b      	ldrb	r3, [r5, #1]
 1011150:	f884 3060 	strb.w	r3, [r4, #96]	; 0x60
		if (lll->packet_tx_head_offset) {
 1011154:	b126      	cbz	r6, 1011160 <lll_conn_pdu_tx_prep+0x44>
			p->ll_id = PDU_DATA_LLID_DATA_CONTINUE;
 1011156:	2101      	movs	r1, #1
 1011158:	5dba      	ldrb	r2, [r7, r6]
 101115a:	f361 0201 	bfi	r2, r1, #0, #2
 101115e:	55ba      	strb	r2, [r7, r6]
		p->len = lll->packet_tx_head_len - lll->packet_tx_head_offset;
 1011160:	1b9b      	subs	r3, r3, r6
 1011162:	706b      	strb	r3, [r5, #1]
		p->md = 0;
 1011164:	5dbb      	ldrb	r3, [r7, r6]
		max_tx_octets = ull_conn_lll_max_tx_octets_get(lll);
 1011166:	4620      	mov	r0, r4
		p->md = 0;
 1011168:	f36f 1304 	bfc	r3, #4, #1
 101116c:	55bb      	strb	r3, [r7, r6]
		max_tx_octets = ull_conn_lll_max_tx_octets_get(lll);
 101116e:	f7fc ff2d 	bl	100dfcc <ull_conn_lll_max_tx_octets_get>
		if (p->len > max_tx_octets) {
 1011172:	786b      	ldrb	r3, [r5, #1]
 1011174:	4283      	cmp	r3, r0
 1011176:	d904      	bls.n	1011182 <lll_conn_pdu_tx_prep+0x66>
			p->len = max_tx_octets;
 1011178:	7068      	strb	r0, [r5, #1]
			p->md = 1;
 101117a:	5dbb      	ldrb	r3, [r7, r6]
 101117c:	f043 0310 	orr.w	r3, r3, #16
 1011180:	55bb      	strb	r3, [r7, r6]
		if (link->next != lll->memq_tx.tail) {
 1011182:	f8d9 2000 	ldr.w	r2, [r9]
 1011186:	6d23      	ldr	r3, [r4, #80]	; 0x50
 1011188:	429a      	cmp	r2, r3
 101118a:	d003      	beq.n	1011194 <lll_conn_pdu_tx_prep+0x78>
			p->md = 1;
 101118c:	5dbb      	ldrb	r3, [r7, r6]
 101118e:	f043 0310 	orr.w	r3, r3, #16
 1011192:	55bb      	strb	r3, [r7, r6]
	p->resv = 0U;
 1011194:	2200      	movs	r2, #0
	p->rfu = 0U;
 1011196:	782b      	ldrb	r3, [r5, #0]
	p->resv = 0U;
 1011198:	70aa      	strb	r2, [r5, #2]
	p->rfu = 0U;
 101119a:	f36f 1347 	bfc	r3, #5, #3
 101119e:	702b      	strb	r3, [r5, #0]
	*pdu_data_tx = p;
 10111a0:	f8c8 5000 	str.w	r5, [r8]
}
 10111a4:	b003      	add	sp, #12
 10111a6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		*pdu_data_tx = empty_tx_enqueue(lll);
 10111aa:	f7ff fe79 	bl	1010ea0 <empty_tx_enqueue>
 10111ae:	f8c8 0000 	str.w	r0, [r8]
}
 10111b2:	b003      	add	sp, #12
 10111b4:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		p = empty_tx_enqueue(lll);
 10111b8:	4620      	mov	r0, r4
 10111ba:	f7ff fe71 	bl	1010ea0 <empty_tx_enqueue>
 10111be:	4605      	mov	r5, r0
 10111c0:	e7e8      	b.n	1011194 <lll_conn_pdu_tx_prep+0x78>
 10111c2:	bf00      	nop

010111c4 <lll_conn_isr_rx>:
{
 10111c4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 10111c8:	b083      	sub	sp, #12
 10111ca:	4604      	mov	r4, r0
	trx_done = radio_is_done();
 10111cc:	f000 fe3a 	bl	1011e44 <radio_is_done>
	if (trx_done) {
 10111d0:	f010 0fff 	tst.w	r0, #255	; 0xff
 10111d4:	d10e      	bne.n	10111f4 <lll_conn_isr_rx+0x30>
	radio_status_reset();
 10111d6:	f000 fe1f 	bl	1011e18 <radio_status_reset>
	radio_tmr_status_reset();
 10111da:	f000 fef5 	bl	1011fc8 <radio_tmr_status_reset>
	radio_rssi_status_reset();
 10111de:	f000 fea3 	bl	1011f28 <radio_rssi_status_reset>
		radio_isr_set(isr_done, param);
 10111e2:	4621      	mov	r1, r4
 10111e4:	48b8      	ldr	r0, [pc, #736]	; (10114c8 <lll_conn_isr_rx+0x304>)
 10111e6:	f000 fd03 	bl	1011bf0 <radio_isr_set>
		radio_disable();
 10111ea:	f000 fdff 	bl	1011dec <radio_disable>
}
 10111ee:	b003      	add	sp, #12
 10111f0:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		crc_ok = radio_crc_is_valid();
 10111f4:	f000 fe46 	bl	1011e84 <radio_crc_is_valid>
 10111f8:	b2c5      	uxtb	r5, r0
		rssi_ready = radio_rssi_is_ready();
 10111fa:	f000 fe9d 	bl	1011f38 <radio_rssi_is_ready>
 10111fe:	fa5f f880 	uxtb.w	r8, r0
	radio_status_reset();
 1011202:	f000 fe09 	bl	1011e18 <radio_status_reset>
	radio_tmr_status_reset();
 1011206:	f000 fedf 	bl	1011fc8 <radio_tmr_status_reset>
	radio_rssi_status_reset();
 101120a:	f000 fe8d 	bl	1011f28 <radio_rssi_status_reset>
	node_rx = ull_pdu_rx_alloc_peek(1);
 101120e:	2001      	movs	r0, #1
	trx_cnt++;
 1011210:	4aae      	ldr	r2, [pc, #696]	; (10114cc <lll_conn_isr_rx+0x308>)
 1011212:	8813      	ldrh	r3, [r2, #0]
 1011214:	4403      	add	r3, r0
 1011216:	8013      	strh	r3, [r2, #0]
	node_rx = ull_pdu_rx_alloc_peek(1);
 1011218:	f7f8 ffe4 	bl	100a1e4 <ull_pdu_rx_alloc_peek>
	LL_ASSERT(node_rx);
 101121c:	4607      	mov	r7, r0
 101121e:	2800      	cmp	r0, #0
 1011220:	f000 80c8 	beq.w	10113b4 <lll_conn_isr_rx+0x1f0>
	if (crc_ok) {
 1011224:	2d00      	cmp	r5, #0
 1011226:	d15d      	bne.n	10112e4 <lll_conn_isr_rx+0x120>
		if (crc_expire == 0U) {
 1011228:	4aa9      	ldr	r2, [pc, #676]	; (10114d0 <lll_conn_isr_rx+0x30c>)
 101122a:	7816      	ldrb	r6, [r2, #0]
 101122c:	2e00      	cmp	r6, #0
 101122e:	f040 809b 	bne.w	1011368 <lll_conn_isr_rx+0x1a4>
		crc_expire--;
 1011232:	2301      	movs	r3, #1
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 1011234:	4620      	mov	r0, r4
 1011236:	a901      	add	r1, sp, #4
		crc_expire--;
 1011238:	7013      	strb	r3, [r2, #0]
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 101123a:	f7ff ff6f 	bl	101111c <lll_conn_pdu_tx_prep>
		radio_tmr_tifs_set(EVENT_IFS_US);
 101123e:	2096      	movs	r0, #150	; 0x96
 1011240:	f000 fed2 	bl	1011fe8 <radio_tmr_tifs_set>
		radio_switch_complete_and_rx(lll->phy_rx);
 1011244:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
 1011248:	f000 0007 	and.w	r0, r0, #7
 101124c:	f000 fe2c 	bl	1011ea8 <radio_switch_complete_and_rx>
		radio_isr_set(lll_conn_isr_tx, param);
 1011250:	4621      	mov	r1, r4
 1011252:	48a0      	ldr	r0, [pc, #640]	; (10114d4 <lll_conn_isr_rx+0x310>)
 1011254:	f000 fccc 	bl	1011bf0 <radio_isr_set>
		radio_tmr_end_capture();
 1011258:	f000 ffea 	bl	1012230 <radio_tmr_end_capture>
	pdu_data_tx->sn = lll->sn;
 101125c:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
 1011260:	9901      	ldr	r1, [sp, #4]
	pdu_data_tx->nesn = lll->nesn;
 1011262:	f3c2 0340 	ubfx	r3, r2, #1, #1
 1011266:	7808      	ldrb	r0, [r1, #0]
	pdu_data_tx->sn = lll->sn;
 1011268:	f3c2 0200 	ubfx	r2, r2, #0, #1
	pdu_data_tx->nesn = lll->nesn;
 101126c:	009b      	lsls	r3, r3, #2
 101126e:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 1011272:	f020 020c 	bic.w	r2, r0, #12
 1011276:	4313      	orrs	r3, r2
	lll_conn_tx_pkt_set(lll, pdu_data_tx);
 1011278:	4620      	mov	r0, r4
	pdu_data_tx->nesn = lll->nesn;
 101127a:	700b      	strb	r3, [r1, #0]
	lll_conn_tx_pkt_set(lll, pdu_data_tx);
 101127c:	f7ff ff20 	bl	10110c0 <lll_conn_tx_pkt_set>
	LL_ASSERT(!radio_is_ready());
 1011280:	f000 fdd6 	bl	1011e30 <radio_is_ready>
 1011284:	2800      	cmp	r0, #0
 1011286:	f040 809f 	bne.w	10113c8 <lll_conn_isr_rx+0x204>
	if (!radio_tmr_aa_restore()) {
 101128a:	f000 ffc5 	bl	1012218 <radio_tmr_aa_restore>
 101128e:	b1b0      	cbz	r0, 10112be <lll_conn_isr_rx+0xfa>
	if (tx_release) {
 1011290:	b1dd      	cbz	r5, 10112ca <lll_conn_isr_rx+0x106>
		LL_ASSERT(lll->handle != 0xFFFF);
 1011292:	f64f 73ff 	movw	r3, #65535	; 0xffff
 1011296:	8a20      	ldrh	r0, [r4, #16]
 1011298:	4298      	cmp	r0, r3
 101129a:	f000 809b 	beq.w	10113d4 <lll_conn_isr_rx+0x210>
		ull_conn_lll_ack_enqueue(lll->handle, tx_release);
 101129e:	4629      	mov	r1, r5
 10112a0:	f7fc fcca 	bl	100dc38 <ull_conn_lll_ack_enqueue>
	if (is_rx_enqueue) {
 10112a4:	b99e      	cbnz	r6, 10112ce <lll_conn_isr_rx+0x10a>
		ull_rx_sched();
 10112a6:	f7f8 ffe3 	bl	100a270 <ull_rx_sched>
	if (rssi_ready) {
 10112aa:	f1b8 0f00 	cmp.w	r8, #0
 10112ae:	d09e      	beq.n	10111ee <lll_conn_isr_rx+0x2a>
		u8_t rssi = radio_rssi_get();
 10112b0:	f000 fe34 	bl	1011f1c <radio_rssi_get>
 10112b4:	f884 00a5 	strb.w	r0, [r4, #165]	; 0xa5
}
 10112b8:	b003      	add	sp, #12
 10112ba:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		radio_tmr_aa_save(radio_tmr_aa_get());
 10112be:	f000 ff9f 	bl	1012200 <radio_tmr_aa_get>
 10112c2:	f000 ffa3 	bl	101220c <radio_tmr_aa_save>
	if (tx_release) {
 10112c6:	2d00      	cmp	r5, #0
 10112c8:	d1e3      	bne.n	1011292 <lll_conn_isr_rx+0xce>
	if (is_rx_enqueue) {
 10112ca:	2e00      	cmp	r6, #0
 10112cc:	d0ed      	beq.n	10112aa <lll_conn_isr_rx+0xe6>
		ull_pdu_rx_alloc();
 10112ce:	f7f8 ffa7 	bl	100a220 <ull_pdu_rx_alloc>
		node_rx->hdr.type = NODE_RX_TYPE_DC_PDU;
 10112d2:	2302      	movs	r3, #2
 10112d4:	713b      	strb	r3, [r7, #4]
		node_rx->hdr.handle = lll->handle;
 10112d6:	8a23      	ldrh	r3, [r4, #16]
		ull_rx_put(node_rx->hdr.link, node_rx);
 10112d8:	4639      	mov	r1, r7
 10112da:	6838      	ldr	r0, [r7, #0]
		node_rx->hdr.handle = lll->handle;
 10112dc:	80fb      	strh	r3, [r7, #6]
		ull_rx_put(node_rx->hdr.link, node_rx);
 10112de:	f7f8 ffb7 	bl	100a250 <ull_rx_put>
	if (is_ull_rx) {
 10112e2:	e7e0      	b.n	10112a6 <lll_conn_isr_rx+0xe2>
	if (pdu_data_rx->nesn != lll->sn) {
 10112e4:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 10112e8:	f897 2020 	ldrb.w	r2, [r7, #32]
 10112ec:	f003 0101 	and.w	r1, r3, #1
 10112f0:	f3c2 0080 	ubfx	r0, r2, #2, #1
 10112f4:	4288      	cmp	r0, r1
 10112f6:	d065      	beq.n	10113c4 <lll_conn_isr_rx+0x200>
		if (lll->role) {
 10112f8:	f994 0021 	ldrsb.w	r0, [r4, #33]	; 0x21
		lll->sn++;
 10112fc:	f081 0101 	eor.w	r1, r1, #1
 1011300:	f361 0300 	bfi	r3, r1, #0, #1
		if (lll->role) {
 1011304:	2800      	cmp	r0, #0
		lll->sn++;
 1011306:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62
		if (lll->role) {
 101130a:	da05      	bge.n	1011318 <lll_conn_isr_rx+0x154>
			lll->slave.latency_enabled = 1;
 101130c:	f894 3024 	ldrb.w	r3, [r4, #36]	; 0x24
 1011310:	f043 0301 	orr.w	r3, r3, #1
 1011314:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
		if (!lll->empty) {
 1011318:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 101131c:	075d      	lsls	r5, r3, #29
 101131e:	d560      	bpl.n	10113e2 <lll_conn_isr_rx+0x21e>
	struct node_tx *tx_release = NULL;
 1011320:	2500      	movs	r5, #0
			lll->empty = 0;
 1011322:	f36f 0382 	bfc	r3, #2, #1
 1011326:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62
		if (link) {
 101132a:	b2db      	uxtb	r3, r3
	if ((pdu_data_rx->sn == lll->nesn) &&
 101132c:	f3c2 02c0 	ubfx	r2, r2, #3, #1
 1011330:	f3c3 0140 	ubfx	r1, r3, #1, #1
 1011334:	428a      	cmp	r2, r1
 1011336:	d07b      	beq.n	1011430 <lll_conn_isr_rx+0x26c>
	u8_t is_rx_enqueue = 0U;
 1011338:	2600      	movs	r6, #0
		crc_expire = 0U;
 101133a:	f04f 0c00 	mov.w	ip, #0
		crc_valid = 1U;
 101133e:	2001      	movs	r0, #1
		crc_expire = 0U;
 1011340:	4963      	ldr	r1, [pc, #396]	; (10114d0 <lll_conn_isr_rx+0x30c>)
		crc_valid = 1U;
 1011342:	4a65      	ldr	r2, [pc, #404]	; (10114d8 <lll_conn_isr_rx+0x314>)
		crc_expire = 0U;
 1011344:	f881 c000 	strb.w	ip, [r1]
		crc_valid = 1U;
 1011348:	7010      	strb	r0, [r2, #0]
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 101134a:	a901      	add	r1, sp, #4
 101134c:	4620      	mov	r0, r4
	is_empty_pdu_tx_retry = lll->empty;
 101134e:	f3c3 0980 	ubfx	r9, r3, #2, #1
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 1011352:	f7ff fee3 	bl	101111c <lll_conn_pdu_tx_prep>
	is_done = is_crc_backoff || ((crc_ok) && (pdu_data_rx->md == 0) &&
 1011356:	f897 3020 	ldrb.w	r3, [r7, #32]
 101135a:	06db      	lsls	r3, r3, #27
 101135c:	f53f af6f 	bmi.w	101123e <lll_conn_isr_rx+0x7a>
				     (pdu_data_tx->len == 0));
 1011360:	9b01      	ldr	r3, [sp, #4]
	is_done = is_crc_backoff || ((crc_ok) && (pdu_data_rx->md == 0) &&
 1011362:	785b      	ldrb	r3, [r3, #1]
 1011364:	b173      	cbz	r3, 1011384 <lll_conn_isr_rx+0x1c0>
 1011366:	e76a      	b.n	101123e <lll_conn_isr_rx+0x7a>
	is_empty_pdu_tx_retry = lll->empty;
 1011368:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
		crc_expire--;
 101136c:	3e01      	subs	r6, #1
 101136e:	b2f6      	uxtb	r6, r6
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 1011370:	4620      	mov	r0, r4
 1011372:	a901      	add	r1, sp, #4
		crc_expire--;
 1011374:	7016      	strb	r6, [r2, #0]
	is_empty_pdu_tx_retry = lll->empty;
 1011376:	f3c3 0980 	ubfx	r9, r3, #2, #1
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 101137a:	f7ff fecf 	bl	101111c <lll_conn_pdu_tx_prep>
	is_done = is_crc_backoff || ((crc_ok) && (pdu_data_rx->md == 0) &&
 101137e:	2e00      	cmp	r6, #0
 1011380:	f040 80df 	bne.w	1011542 <lll_conn_isr_rx+0x37e>
		radio_isr_set(isr_done, param);
 1011384:	4621      	mov	r1, r4
 1011386:	4850      	ldr	r0, [pc, #320]	; (10114c8 <lll_conn_isr_rx+0x304>)
 1011388:	f000 fc32 	bl	1011bf0 <radio_isr_set>
		} else if (!lll->role) {
 101138c:	f994 3021 	ldrsb.w	r3, [r4, #33]	; 0x21
 1011390:	2b00      	cmp	r3, #0
 1011392:	da02      	bge.n	101139a <lll_conn_isr_rx+0x1d6>
			radio_switch_complete_and_disable();
 1011394:	f000 fda2 	bl	1011edc <radio_switch_complete_and_disable>
 1011398:	e760      	b.n	101125c <lll_conn_isr_rx+0x98>
			radio_disable();
 101139a:	f000 fd27 	bl	1011dec <radio_disable>
			LL_ASSERT(!radio_is_ready());
 101139e:	f000 fd47 	bl	1011e30 <radio_is_ready>
 10113a2:	2800      	cmp	r0, #0
 10113a4:	d157      	bne.n	1011456 <lll_conn_isr_rx+0x292>
			lll->empty = is_empty_pdu_tx_retry;
 10113a6:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 10113aa:	f369 0382 	bfi	r3, r9, #2, #1
 10113ae:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62
			goto lll_conn_isr_rx_exit;
 10113b2:	e76a      	b.n	101128a <lll_conn_isr_rx+0xc6>
	LL_ASSERT(node_rx);
 10113b4:	21b8      	movs	r1, #184	; 0xb8
 10113b6:	4849      	ldr	r0, [pc, #292]	; (10114dc <lll_conn_isr_rx+0x318>)
 10113b8:	f7f2 f8e6 	bl	1003588 <bt_ctlr_assert_handle>
	if (crc_ok) {
 10113bc:	2d00      	cmp	r5, #0
 10113be:	f43f af33 	beq.w	1011228 <lll_conn_isr_rx+0x64>
 10113c2:	e78f      	b.n	10112e4 <lll_conn_isr_rx+0x120>
	struct node_tx *tx_release = NULL;
 10113c4:	2500      	movs	r5, #0
 10113c6:	e7b1      	b.n	101132c <lll_conn_isr_rx+0x168>
	LL_ASSERT(!radio_is_ready());
 10113c8:	f44f 7191 	mov.w	r1, #290	; 0x122
 10113cc:	4843      	ldr	r0, [pc, #268]	; (10114dc <lll_conn_isr_rx+0x318>)
 10113ce:	f7f2 f8db 	bl	1003588 <bt_ctlr_assert_handle>
 10113d2:	e75a      	b.n	101128a <lll_conn_isr_rx+0xc6>
		LL_ASSERT(lll->handle != 0xFFFF);
 10113d4:	4841      	ldr	r0, [pc, #260]	; (10114dc <lll_conn_isr_rx+0x318>)
 10113d6:	f240 112f 	movw	r1, #303	; 0x12f
 10113da:	f7f2 f8d5 	bl	1003588 <bt_ctlr_assert_handle>
 10113de:	8a20      	ldrh	r0, [r4, #16]
 10113e0:	e75d      	b.n	101129e <lll_conn_isr_rx+0xda>
			link = memq_peek(lll->memq_tx.head, lll->memq_tx.tail,
 10113e2:	aa01      	add	r2, sp, #4
 10113e4:	e9d4 0113 	ldrd	r0, r1, [r4, #76]	; 0x4c
 10113e8:	f7f4 fc86 	bl	1005cf8 <memq_peek>
		if (link) {
 10113ec:	4606      	mov	r6, r0
 10113ee:	2800      	cmp	r0, #0
 10113f0:	d039      	beq.n	1011466 <lll_conn_isr_rx+0x2a2>
					       lll->packet_tx_head_offset);
 10113f2:	f894 2061 	ldrb.w	r2, [r4, #97]	; 0x61
			pdu_data_tx_len = pdu_data_tx->len;
 10113f6:	9b01      	ldr	r3, [sp, #4]
 10113f8:	4413      	add	r3, r2
 10113fa:	7959      	ldrb	r1, [r3, #5]
			if (pdu_data_tx_len != 0U) {
 10113fc:	b151      	cbz	r1, 1011414 <lll_conn_isr_rx+0x250>
				if (lll->enc_tx) {
 10113fe:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 1011402:	06d8      	lsls	r0, r3, #27
 1011404:	d506      	bpl.n	1011414 <lll_conn_isr_rx+0x250>
					lll->ccm_tx.counter++;
 1011406:	e9d4 3025 	ldrd	r3, r0, [r4, #148]	; 0x94
 101140a:	3301      	adds	r3, #1
 101140c:	f140 0000 	adc.w	r0, r0, #0
 1011410:	e9c4 3025 	strd	r3, r0, [r4, #148]	; 0x94
			if (offset < lll->packet_tx_head_len) {
 1011414:	f894 3060 	ldrb.w	r3, [r4, #96]	; 0x60
			offset = lll->packet_tx_head_offset + pdu_data_tx_len;
 1011418:	440a      	add	r2, r1
 101141a:	b2d2      	uxtb	r2, r2
			if (offset < lll->packet_tx_head_len) {
 101141c:	429a      	cmp	r2, r3
 101141e:	d228      	bcs.n	1011472 <lll_conn_isr_rx+0x2ae>
				lll->packet_tx_head_offset = offset;
 1011420:	f884 2061 	strb.w	r2, [r4, #97]	; 0x61
	struct node_tx *tx_release = NULL;
 1011424:	2500      	movs	r5, #0
 1011426:	f897 2020 	ldrb.w	r2, [r7, #32]
 101142a:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 101142e:	e77d      	b.n	101132c <lll_conn_isr_rx+0x168>
	    (ull_pdu_rx_alloc_peek(3) != 0)) {
 1011430:	2003      	movs	r0, #3
 1011432:	f7f8 fed7 	bl	100a1e4 <ull_pdu_rx_alloc_peek>
	if ((pdu_data_rx->sn == lll->nesn) &&
 1011436:	b198      	cbz	r0, 1011460 <lll_conn_isr_rx+0x29c>
		lll->nesn++;
 1011438:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 101143c:	f083 0302 	eor.w	r3, r3, #2
 1011440:	f884 3062 	strb.w	r3, [r4, #98]	; 0x62
		if (pdu_data_rx->len != 0) {
 1011444:	f897 3021 	ldrb.w	r3, [r7, #33]	; 0x21
 1011448:	b153      	cbz	r3, 1011460 <lll_conn_isr_rx+0x29c>
			if (lll->enc_rx) {
 101144a:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 101144e:	071a      	lsls	r2, r3, #28
 1011450:	d421      	bmi.n	1011496 <lll_conn_isr_rx+0x2d2>
			*is_rx_enqueue = 1U;
 1011452:	2601      	movs	r6, #1
 1011454:	e771      	b.n	101133a <lll_conn_isr_rx+0x176>
			LL_ASSERT(!radio_is_ready());
 1011456:	21e8      	movs	r1, #232	; 0xe8
 1011458:	4820      	ldr	r0, [pc, #128]	; (10114dc <lll_conn_isr_rx+0x318>)
 101145a:	f7f2 f895 	bl	1003588 <bt_ctlr_assert_handle>
 101145e:	e7a2      	b.n	10113a6 <lll_conn_isr_rx+0x1e2>
 1011460:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 1011464:	e768      	b.n	1011338 <lll_conn_isr_rx+0x174>
	struct node_tx *tx_release = NULL;
 1011466:	2500      	movs	r5, #0
 1011468:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 101146c:	f897 2020 	ldrb.w	r2, [r7, #32]
 1011470:	e75c      	b.n	101132c <lll_conn_isr_rx+0x168>
			} else if (offset == lll->packet_tx_head_len) {
 1011472:	d1f8      	bne.n	1011466 <lll_conn_isr_rx+0x2a2>
				lll->packet_tx_head_len = 0;
 1011474:	2200      	movs	r2, #0
				memq_dequeue(lll->memq_tx.tail,
 1011476:	6d20      	ldr	r0, [r4, #80]	; 0x50
				lll->packet_tx_head_len = 0;
 1011478:	f8a4 2060 	strh.w	r2, [r4, #96]	; 0x60
				memq_dequeue(lll->memq_tx.tail,
 101147c:	f104 014c 	add.w	r1, r4, #76	; 0x4c
 1011480:	f7f4 fc42 	bl	1005d08 <memq_dequeue>
				link->next = tx->next; /* Indicates ctrl or data
 1011484:	9d01      	ldr	r5, [sp, #4]
 1011486:	f897 2020 	ldrb.w	r2, [r7, #32]
 101148a:	682b      	ldr	r3, [r5, #0]
 101148c:	6033      	str	r3, [r6, #0]
				tx->next = link;
 101148e:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 1011492:	602e      	str	r6, [r5, #0]
				*tx_release = tx;
 1011494:	e74a      	b.n	101132c <lll_conn_isr_rx+0x168>
				done = radio_ccm_is_done();
 1011496:	f000 ff71 	bl	101237c <radio_ccm_is_done>
				LL_ASSERT(done);
 101149a:	2800      	cmp	r0, #0
 101149c:	d04b      	beq.n	1011536 <lll_conn_isr_rx+0x372>
				bool mic_failure = !radio_ccm_mic_is_valid();
 101149e:	f000 ff8f 	bl	10123c0 <radio_ccm_mic_is_valid>
				if (mic_failure &&
 10114a2:	bbb0      	cbnz	r0, 1011512 <lll_conn_isr_rx+0x34e>
				    lll->ccm_rx.counter == 0 &&
 10114a4:	f8d4 2073 	ldr.w	r2, [r4, #115]	; 0x73
 10114a8:	f8d4 3077 	ldr.w	r3, [r4, #119]	; 0x77
				if (mic_failure &&
 10114ac:	4313      	orrs	r3, r2
 10114ae:	d105      	bne.n	10114bc <lll_conn_isr_rx+0x2f8>
				    (pdu_data_rx->ll_id ==
 10114b0:	f897 3020 	ldrb.w	r3, [r7, #32]
				    lll->ccm_rx.counter == 0 &&
 10114b4:	f003 0303 	and.w	r3, r3, #3
 10114b8:	2b03      	cmp	r3, #3
 10114ba:	d013      	beq.n	10114e4 <lll_conn_isr_rx+0x320>
					mic_state = LLL_CONN_MIC_FAIL;
 10114bc:	2202      	movs	r2, #2
 10114be:	4b08      	ldr	r3, [pc, #32]	; (10114e0 <lll_conn_isr_rx+0x31c>)
	u8_t is_rx_enqueue = 0U;
 10114c0:	2600      	movs	r6, #0
					mic_state = LLL_CONN_MIC_FAIL;
 10114c2:	701a      	strb	r2, [r3, #0]
		if (err) {
 10114c4:	e6e1      	b.n	101128a <lll_conn_isr_rx+0xc6>
 10114c6:	bf00      	nop
 10114c8:	01010df9 	.word	0x01010df9
 10114cc:	2100668a 	.word	0x2100668a
 10114d0:	210066f6 	.word	0x210066f6
 10114d4:	01011005 	.word	0x01011005
 10114d8:	210066f7 	.word	0x210066f7
 10114dc:	01018a7c 	.word	0x01018a7c
 10114e0:	210066f8 	.word	0x210066f8
						radio_pkt_scratch_get();
 10114e4:	f000 fcdc 	bl	1011ea0 <radio_pkt_scratch_get>
					if (ctrl_pdu_len_check(
 10114e8:	7842      	ldrb	r2, [r0, #1]
						radio_pkt_scratch_get();
 10114ea:	4601      	mov	r1, r0
					if (ctrl_pdu_len_check(
 10114ec:	2a1b      	cmp	r2, #27
 10114ee:	d8e5      	bhi.n	10114bc <lll_conn_isr_rx+0x2f8>
						memcpy(pdu_data_rx,
 10114f0:	3203      	adds	r2, #3
 10114f2:	f107 0020 	add.w	r0, r7, #32
 10114f6:	f005 f9df 	bl	10168b8 <memcpy>
						lll->ccm_rx.counter--;
 10114fa:	f8d4 3073 	ldr.w	r3, [r4, #115]	; 0x73
 10114fe:	f8d4 2077 	ldr.w	r2, [r4, #119]	; 0x77
 1011502:	f113 33ff 	adds.w	r3, r3, #4294967295
 1011506:	f142 32ff 	adc.w	r2, r2, #4294967295
 101150a:	f8c4 3073 	str.w	r3, [r4, #115]	; 0x73
 101150e:	f8c4 2077 	str.w	r2, [r4, #119]	; 0x77
				mic_state = LLL_CONN_MIC_PASS;
 1011512:	2601      	movs	r6, #1
				lll->ccm_rx.counter++;
 1011514:	f8d4 3073 	ldr.w	r3, [r4, #115]	; 0x73
 1011518:	f8d4 2077 	ldr.w	r2, [r4, #119]	; 0x77
 101151c:	199b      	adds	r3, r3, r6
				mic_state = LLL_CONN_MIC_PASS;
 101151e:	490a      	ldr	r1, [pc, #40]	; (1011548 <lll_conn_isr_rx+0x384>)
						lll->ccm_rx.counter--;
 1011520:	f104 0073 	add.w	r0, r4, #115	; 0x73
				lll->ccm_rx.counter++;
 1011524:	f142 0200 	adc.w	r2, r2, #0
 1011528:	f8c4 3073 	str.w	r3, [r4, #115]	; 0x73
 101152c:	6042      	str	r2, [r0, #4]
				mic_state = LLL_CONN_MIC_PASS;
 101152e:	f894 3062 	ldrb.w	r3, [r4, #98]	; 0x62
 1011532:	700e      	strb	r6, [r1, #0]
		if (err) {
 1011534:	e701      	b.n	101133a <lll_conn_isr_rx+0x176>
				LL_ASSERT(done);
 1011536:	f240 310d 	movw	r1, #781	; 0x30d
 101153a:	4804      	ldr	r0, [pc, #16]	; (101154c <lll_conn_isr_rx+0x388>)
 101153c:	f7f2 f824 	bl	1003588 <bt_ctlr_assert_handle>
 1011540:	e7ad      	b.n	101149e <lll_conn_isr_rx+0x2da>
	u8_t is_rx_enqueue = 0U;
 1011542:	462e      	mov	r6, r5
 1011544:	e67b      	b.n	101123e <lll_conn_isr_rx+0x7a>
 1011546:	bf00      	nop
 1011548:	210066f8 	.word	0x210066f8
 101154c:	01018a7c 	.word	0x01018a7c

01011550 <lll_conn_flush>:

void lll_conn_flush(u16_t handle, struct lll_conn *lll)
{
	/* Nothing to be flushed */
}
 1011550:	4770      	bx	lr
 1011552:	bf00      	nop

01011554 <prepare_cb>:
{
	return 0;
}

static int prepare_cb(struct lll_prepare_param *prepare_param)
{
 1011554:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1011558:	b082      	sub	sp, #8
	struct lll_conn *lll = prepare_param->param;
 101155a:	68c4      	ldr	r4, [r0, #12]
{
 101155c:	4680      	mov	r8, r0
	u32_t hcto;

	DEBUG_RADIO_START_S(1);

	/* Reset connection event global variables */
	lll_conn_prepare_reset();
 101155e:	f7ff fccd 	bl	1010efc <lll_conn_prepare_reset>

	/* Update event counter to next value */
	lll->event_counter = lll->event_counter + lll->latency_prepare;

	/* Reset accumulated latencies */
	lll->latency_prepare = 0;
 1011562:	2100      	movs	r1, #0
	lll->latency_event = lll->latency_prepare - 1;
 1011564:	8ae3      	ldrh	r3, [r4, #22]
	event_counter = lll->event_counter + lll->latency_event;
 1011566:	8b60      	ldrh	r0, [r4, #26]
	lll->latency_event = lll->latency_prepare - 1;
 1011568:	1e5a      	subs	r2, r3, #1
	lll->event_counter = lll->event_counter + lll->latency_prepare;
 101156a:	4403      	add	r3, r0
 101156c:	8363      	strh	r3, [r4, #26]

	if (lll->data_chan_sel) {
 101156e:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
	lll->latency_event = lll->latency_prepare - 1;
 1011572:	b292      	uxth	r2, r2
	lll->latency_prepare = 0;
 1011574:	82e1      	strh	r1, [r4, #22]
	if (lll->data_chan_sel) {
 1011576:	0659      	lsls	r1, r3, #25
	lll->latency_event = lll->latency_prepare - 1;
 1011578:	8322      	strh	r2, [r4, #24]
	if (lll->data_chan_sel) {
 101157a:	f140 808e 	bpl.w	101169a <prepare_cb+0x146>
	event_counter = lll->event_counter + lll->latency_event;
 101157e:	4410      	add	r0, r2
#if defined(CONFIG_BT_CTLR_CHAN_SEL_2)
		data_chan_use = lll_chan_sel_2(event_counter, lll->data_chan_id,
 1011580:	8c61      	ldrh	r1, [r4, #34]	; 0x22
 1011582:	b280      	uxth	r0, r0
 1011584:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 1011588:	f104 021c 	add.w	r2, r4, #28
 101158c:	f7f8 ff58 	bl	100a440 <lll_chan_sel_2>
 1011590:	4606      	mov	r6, r0
					       &lll->data_chan_map[0],
					       lll->data_chan_count);
	}

	/* current window widening */
	lll->slave.window_widening_event_us +=
 1011592:	e9d4 120c 	ldrd	r1, r2, [r4, #48]	; 0x30
		lll->slave.window_widening_prepare_us;
	lll->slave.window_widening_prepare_us = 0;
	if (lll->slave.window_widening_event_us >
	    lll->slave.window_widening_max_us) {
 1011596:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
	lll->slave.window_widening_event_us +=
 1011598:	440a      	add	r2, r1
		lll->slave.window_widening_event_us =
 101159a:	429a      	cmp	r2, r3
 101159c:	bf28      	it	cs
 101159e:	461a      	movcs	r2, r3
			lll->slave.window_widening_max_us;
	}

	/* current window size */
	lll->slave.window_size_event_us +=
 10115a0:	e9d4 130e 	ldrd	r1, r3, [r4, #56]	; 0x38
	lll->slave.window_widening_prepare_us = 0;
 10115a4:	2500      	movs	r5, #0
	lll->slave.window_size_event_us +=
 10115a6:	440b      	add	r3, r1
		lll->slave.window_widening_event_us =
 10115a8:	6362      	str	r2, [r4, #52]	; 0x34
	lll->slave.window_size_event_us +=
 10115aa:	63e3      	str	r3, [r4, #60]	; 0x3c
	lll->slave.window_widening_prepare_us = 0;
 10115ac:	6325      	str	r5, [r4, #48]	; 0x30
		lll->slave.window_size_prepare_us;
	lll->slave.window_size_prepare_us = 0;
 10115ae:	63a5      	str	r5, [r4, #56]	; 0x38

	/* Start setting up Radio h/w */
	radio_reset();
 10115b0:	f000 fb3e 	bl	1011c30 <radio_reset>
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	radio_tx_power_set(lll->tx_pwr_lvl);
#else
	radio_tx_power_set(RADIO_TXP_DEFAULT);
 10115b4:	4628      	mov	r0, r5
 10115b6:	f000 fb77 	bl	1011ca8 <radio_tx_power_set>
#endif /* CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL */

	lll_conn_rx_pkt_set(lll);
 10115ba:	4620      	mov	r0, r4
 10115bc:	f7ff fce4 	bl	1010f88 <lll_conn_rx_pkt_set>

	radio_aa_set(lll->access_addr);
 10115c0:	f104 0008 	add.w	r0, r4, #8
 10115c4:	f000 fb8e 	bl	1011ce4 <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
			    (((u32_t)lll->crc_init[2] << 16) |
			     ((u32_t)lll->crc_init[1] << 8) |
 10115c8:	7b63      	ldrb	r3, [r4, #13]
			    (((u32_t)lll->crc_init[2] << 16) |
 10115ca:	7ba2      	ldrb	r2, [r4, #14]
			     ((u32_t)lll->crc_init[0])));
 10115cc:	7b21      	ldrb	r1, [r4, #12]
			     ((u32_t)lll->crc_init[1] << 8) |
 10115ce:	021b      	lsls	r3, r3, #8
			    (((u32_t)lll->crc_init[2] << 16) |
 10115d0:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
 10115d4:	4319      	orrs	r1, r3
 10115d6:	f240 605b 	movw	r0, #1627	; 0x65b
 10115da:	f000 fc47 	bl	1011e6c <radio_crc_configure>

	lll_chan_set(data_chan_use);
 10115de:	4630      	mov	r0, r6
 10115e0:	f7fe fcaa 	bl	100ff38 <lll_chan_set>

	radio_isr_set(lll_conn_isr_rx, lll);
 10115e4:	4621      	mov	r1, r4
 10115e6:	483d      	ldr	r0, [pc, #244]	; (10116dc <prepare_cb+0x188>)
 10115e8:	f000 fb02 	bl	1011bf0 <radio_isr_set>

	radio_tmr_tifs_set(EVENT_IFS_US);
 10115ec:	2096      	movs	r0, #150	; 0x96
 10115ee:	f000 fcfb 	bl	1011fe8 <radio_tmr_tifs_set>

#if defined(CONFIG_BT_CTLR_PHY)
	radio_switch_complete_and_tx(lll->phy_rx, 0, lll->phy_tx,
				     lll->phy_flags);
 10115f2:	f894 2048 	ldrb.w	r2, [r4, #72]	; 0x48
	radio_switch_complete_and_tx(lll->phy_rx, 0, lll->phy_tx,
 10115f6:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
 10115fa:	f3c2 03c0 	ubfx	r3, r2, #3, #1
 10115fe:	4629      	mov	r1, r5
 1011600:	f002 0207 	and.w	r2, r2, #7
 1011604:	f000 0007 	and.w	r0, r0, #7
 1011608:	f000 fc5c 	bl	1011ec4 <radio_switch_complete_and_tx>
#else /* !CONFIG_BT_CTLR_PHY */
	radio_switch_complete_and_tx(0, 0, 0, 0);
#endif /* !CONFIG_BT_CTLR_PHY */

	ticks_at_event = prepare_param->ticks_at_expire;
	evt = HDR_LLL2EVT(lll);
 101160c:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = prepare_param->ticks_at_expire;
 101160e:	f8d8 6000 	ldr.w	r6, [r8]
	ticks_at_event += lll_evt_offset_get(evt);
 1011612:	4638      	mov	r0, r7
 1011614:	f7fe fc74 	bl	100ff00 <lll_evt_offset_get>
 1011618:	4406      	add	r6, r0

	ticks_at_start = ticks_at_event;
	ticks_at_start += HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US);

	remainder = prepare_param->remainder;
	remainder_us = radio_tmr_start(0, ticks_at_start, remainder);
 101161a:	f8d8 2004 	ldr.w	r2, [r8, #4]
 101161e:	f106 0109 	add.w	r1, r6, #9
 1011622:	4628      	mov	r0, r5
 1011624:	f000 fcec 	bl	1012000 <radio_tmr_start>
 1011628:	4680      	mov	r8, r0

	radio_tmr_aa_capture();
 101162a:	f000 fdcb 	bl	10121c4 <radio_tmr_aa_capture>
	radio_tmr_aa_save(0);
 101162e:	4628      	mov	r0, r5
 1011630:	f000 fdec 	bl	101220c <radio_tmr_aa_save>

	hcto = remainder_us + EVENT_JITTER_US + (EVENT_JITTER_US << 2) +
 1011634:	6be3      	ldr	r3, [r4, #60]	; 0x3c
	       (lll->slave.window_widening_event_us << 1) +
	       lll->slave.window_size_event_us;

#if defined(CONFIG_BT_CTLR_PHY)
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
 1011636:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
	       (lll->slave.window_widening_event_us << 1) +
 101163a:	6b62      	ldr	r2, [r4, #52]	; 0x34
	hcto = remainder_us + EVENT_JITTER_US + (EVENT_JITTER_US << 2) +
 101163c:	f103 0550 	add.w	r5, r3, #80	; 0x50
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
 1011640:	2101      	movs	r1, #1
 1011642:	f000 0007 	and.w	r0, r0, #7
	hcto = remainder_us + EVENT_JITTER_US + (EVENT_JITTER_US << 2) +
 1011646:	eb05 0542 	add.w	r5, r5, r2, lsl #1
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
 101164a:	f000 fbb3 	bl	1011db4 <radio_rx_ready_delay_get>
	hcto += addr_us_get(lll->phy_rx);
 101164e:	f894 3049 	ldrb.w	r3, [r4, #73]	; 0x49
	hcto = remainder_us + EVENT_JITTER_US + (EVENT_JITTER_US << 2) +
 1011652:	4445      	add	r5, r8
	hcto += radio_rx_ready_delay_get(lll->phy_rx, 1);
 1011654:	4405      	add	r5, r0
	hcto += addr_us_get(lll->phy_rx);
 1011656:	f003 0007 	and.w	r0, r3, #7
 101165a:	2802      	cmp	r0, #2
 101165c:	d034      	beq.n	10116c8 <prepare_cb+0x174>
		return 40;
 101165e:	2804      	cmp	r0, #4
 1011660:	bf0c      	ite	eq
 1011662:	f44f 73bc 	moveq.w	r3, #376	; 0x178
 1011666:	2328      	movne	r3, #40	; 0x28
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
 1011668:	2101      	movs	r1, #1
	hcto += addr_us_get(lll->phy_rx);
 101166a:	441d      	add	r5, r3
	hcto += radio_rx_chain_delay_get(lll->phy_rx, 1);
 101166c:	f000 fba4 	bl	1011db8 <radio_rx_chain_delay_get>
	hcto += radio_rx_ready_delay_get(0, 0);
	hcto += addr_us_get(0);
	hcto += radio_rx_chain_delay_get(0, 0);
#endif /* !CONFIG_BT_CTLR_PHY */

	radio_tmr_hcto_configure(hcto);
 1011670:	4428      	add	r0, r5
 1011672:	f000 fd87 	bl	1012184 <radio_tmr_hcto_configure>
	defined(CONFIG_BT_CTLR_GPIO_PA_PIN)
	radio_tmr_end_capture();
#endif /* CONFIG_BT_CTLR_PROFILE_ISR */

#if defined(CONFIG_BT_CTLR_CONN_RSSI)
	radio_rssi_measure();
 1011676:	f000 fc47 	bl	1011f08 <radio_rssi_measure>
#endif /* CONFIG_BT_CTLR_CONN_RSSI */

#if defined(CONFIG_BT_CTLR_XTAL_ADVANCED) && \
	(EVENT_OVERHEAD_PREEMPT_US <= EVENT_OVERHEAD_PREEMPT_MIN_US)
	/* check if preempt to start has changed */
	if (lll_preempt_calc(evt, (TICKER_ID_CONN_BASE + lll->handle),
 101167a:	7c21      	ldrb	r1, [r4, #16]
 101167c:	4632      	mov	r2, r6
 101167e:	3105      	adds	r1, #5
 1011680:	4638      	mov	r0, r7
 1011682:	b2c9      	uxtb	r1, r1
 1011684:	f7fe fc46 	bl	100ff14 <lll_preempt_calc>
 1011688:	b9a0      	cbnz	r0, 10116b4 <prepare_cb+0x160>
	} else
#endif /* CONFIG_BT_CTLR_XTAL_ADVANCED */
	{
		u32_t ret;

		ret = lll_prepare_done(lll);
 101168a:	4620      	mov	r0, r4
 101168c:	f7fe fbfa 	bl	100fe84 <lll_prepare_done>
		LL_ASSERT(!ret);
 1011690:	b9e0      	cbnz	r0, 10116cc <prepare_cb+0x178>
	}

	DEBUG_RADIO_START_S(1);

	return 0;
}
 1011692:	2000      	movs	r0, #0
 1011694:	b002      	add	sp, #8
 1011696:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		data_chan_use = lll_chan_sel_1(&lll->data_chan_use,
 101169a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 101169e:	f894 1022 	ldrb.w	r1, [r4, #34]	; 0x22
 10116a2:	f104 0023 	add.w	r0, r4, #35	; 0x23
 10116a6:	9300      	str	r3, [sp, #0]
 10116a8:	f104 031c 	add.w	r3, r4, #28
 10116ac:	f7f8 fe8c 	bl	100a3c8 <lll_chan_sel_1>
 10116b0:	4606      	mov	r6, r0
 10116b2:	e76e      	b.n	1011592 <prepare_cb+0x3e>
		radio_isr_set(lll_conn_isr_abort, lll);
 10116b4:	4621      	mov	r1, r4
 10116b6:	480a      	ldr	r0, [pc, #40]	; (10116e0 <prepare_cb+0x18c>)
 10116b8:	f000 fa9a 	bl	1011bf0 <radio_isr_set>
		radio_disable();
 10116bc:	f000 fb96 	bl	1011dec <radio_disable>
}
 10116c0:	2000      	movs	r0, #0
 10116c2:	b002      	add	sp, #8
 10116c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	switch (phy) {
 10116c8:	2318      	movs	r3, #24
 10116ca:	e7cd      	b.n	1011668 <prepare_cb+0x114>
		LL_ASSERT(!ret);
 10116cc:	21fe      	movs	r1, #254	; 0xfe
 10116ce:	4805      	ldr	r0, [pc, #20]	; (10116e4 <prepare_cb+0x190>)
 10116d0:	f7f1 ff5a 	bl	1003588 <bt_ctlr_assert_handle>
}
 10116d4:	2000      	movs	r0, #0
 10116d6:	b002      	add	sp, #8
 10116d8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 10116dc:	010111c5 	.word	0x010111c5
 10116e0:	01010f65 	.word	0x01010f65
 10116e4:	01018aec 	.word	0x01018aec

010116e8 <lll_slave_prepare>:
{
 10116e8:	b530      	push	{r4, r5, lr}
 10116ea:	b083      	sub	sp, #12
 10116ec:	4605      	mov	r5, r0
	struct lll_conn *lll = p->param;
 10116ee:	68c4      	ldr	r4, [r0, #12]
	err = lll_hfclock_on();
 10116f0:	f7fe fc9c 	bl	101002c <lll_hfclock_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
 10116f4:	b108      	cbz	r0, 10116fa <lll_slave_prepare+0x12>
 10116f6:	3044      	adds	r0, #68	; 0x44
 10116f8:	d121      	bne.n	101173e <lll_slave_prepare+0x56>
	elapsed = p->lazy + 1;
 10116fa:	892b      	ldrh	r3, [r5, #8]
	    lll->slave.window_widening_periodic_us * elapsed;
 10116fc:	6aa2      	ldr	r2, [r4, #40]	; 0x28
	lll->slave.window_widening_prepare_us +=
 10116fe:	6b21      	ldr	r1, [r4, #48]	; 0x30
	elapsed = p->lazy + 1;
 1011700:	3301      	adds	r3, #1
 1011702:	b29b      	uxth	r3, r3
	lll->slave.window_widening_prepare_us +=
 1011704:	fb02 1103 	mla	r1, r2, r3, r1
	    lll->slave.window_widening_max_us) {
 1011708:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
	lll->latency_prepare += elapsed;
 101170a:	8ae0      	ldrh	r0, [r4, #22]
		lll->slave.window_widening_prepare_us =
 101170c:	428a      	cmp	r2, r1
 101170e:	bf28      	it	cs
 1011710:	460a      	movcs	r2, r1
	lll->latency_prepare += elapsed;
 1011712:	4403      	add	r3, r0
		lll->slave.window_widening_prepare_us =
 1011714:	6322      	str	r2, [r4, #48]	; 0x30
	lll->latency_prepare += elapsed;
 1011716:	82e3      	strh	r3, [r4, #22]
	err = lll_prepare(lll_conn_is_abort_cb, lll_conn_abort_cb, prepare_cb,
 1011718:	4a0b      	ldr	r2, [pc, #44]	; (1011748 <lll_slave_prepare+0x60>)
 101171a:	2300      	movs	r3, #0
 101171c:	490b      	ldr	r1, [pc, #44]	; (101174c <lll_slave_prepare+0x64>)
 101171e:	480c      	ldr	r0, [pc, #48]	; (1011750 <lll_slave_prepare+0x68>)
 1011720:	9500      	str	r5, [sp, #0]
 1011722:	f7fe fb3b 	bl	100fd9c <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
 1011726:	b108      	cbz	r0, 101172c <lll_slave_prepare+0x44>
 1011728:	3044      	adds	r0, #68	; 0x44
 101172a:	d101      	bne.n	1011730 <lll_slave_prepare+0x48>
}
 101172c:	b003      	add	sp, #12
 101172e:	bd30      	pop	{r4, r5, pc}
	LL_ASSERT(!err || err == -EINPROGRESS);
 1011730:	215c      	movs	r1, #92	; 0x5c
 1011732:	4808      	ldr	r0, [pc, #32]	; (1011754 <lll_slave_prepare+0x6c>)
}
 1011734:	b003      	add	sp, #12
 1011736:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	LL_ASSERT(!err || err == -EINPROGRESS);
 101173a:	f7f1 bf25 	b.w	1003588 <bt_ctlr_assert_handle>
	LL_ASSERT(!err || err == -EINPROGRESS);
 101173e:	2148      	movs	r1, #72	; 0x48
 1011740:	4804      	ldr	r0, [pc, #16]	; (1011754 <lll_slave_prepare+0x6c>)
 1011742:	f7f1 ff21 	bl	1003588 <bt_ctlr_assert_handle>
 1011746:	e7d8      	b.n	10116fa <lll_slave_prepare+0x12>
 1011748:	01011555 	.word	0x01011555
 101174c:	01010f2d 	.word	0x01010f2d
 1011750:	01010f25 	.word	0x01010f25
 1011754:	01018aec 	.word	0x01018aec

01011758 <prepare_cb>:
{
	return 0;
}

static int prepare_cb(struct lll_prepare_param *prepare_param)
{
 1011758:	b5f0      	push	{r4, r5, r6, r7, lr}
 101175a:	b085      	sub	sp, #20
	struct lll_conn *lll = prepare_param->param;
 101175c:	68c4      	ldr	r4, [r0, #12]
{
 101175e:	4605      	mov	r5, r0
	u32_t remainder;

	DEBUG_RADIO_START_M(1);

	/* Reset connection event global variables */
	lll_conn_prepare_reset();
 1011760:	f7ff fbcc 	bl	1010efc <lll_conn_prepare_reset>

	/* Update event counter to next value */
	lll->event_counter = lll->event_counter + lll->latency_prepare;

	/* Reset accumulated latencies */
	lll->latency_prepare = 0;
 1011764:	2100      	movs	r1, #0
	lll->latency_event = lll->latency_prepare - 1;
 1011766:	8ae3      	ldrh	r3, [r4, #22]
	event_counter = lll->event_counter + lll->latency_event;
 1011768:	8b60      	ldrh	r0, [r4, #26]
	lll->latency_event = lll->latency_prepare - 1;
 101176a:	1e5a      	subs	r2, r3, #1
	lll->event_counter = lll->event_counter + lll->latency_prepare;
 101176c:	4403      	add	r3, r0
 101176e:	8363      	strh	r3, [r4, #26]

	if (lll->data_chan_sel) {
 1011770:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21
	lll->latency_event = lll->latency_prepare - 1;
 1011774:	b292      	uxth	r2, r2
	lll->latency_prepare = 0;
 1011776:	82e1      	strh	r1, [r4, #22]
	if (lll->data_chan_sel) {
 1011778:	0659      	lsls	r1, r3, #25
	lll->latency_event = lll->latency_prepare - 1;
 101177a:	8322      	strh	r2, [r4, #24]
	if (lll->data_chan_sel) {
 101177c:	d563      	bpl.n	1011846 <prepare_cb+0xee>
	event_counter = lll->event_counter + lll->latency_event;
 101177e:	4410      	add	r0, r2
#if defined(CONFIG_BT_CTLR_CHAN_SEL_2)
		data_chan_use = lll_chan_sel_2(event_counter, lll->data_chan_id,
 1011780:	8c61      	ldrh	r1, [r4, #34]	; 0x22
 1011782:	b280      	uxth	r0, r0
 1011784:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 1011788:	f104 021c 	add.w	r2, r4, #28
 101178c:	f7f8 fe58 	bl	100a440 <lll_chan_sel_2>
 1011790:	4606      	mov	r6, r0
					       &lll->data_chan_map[0],
					       lll->data_chan_count);
	}

	/* Prepare the Tx PDU */
	lll_conn_pdu_tx_prep(lll, &pdu_data_tx);
 1011792:	4620      	mov	r0, r4
 1011794:	a903      	add	r1, sp, #12
 1011796:	f7ff fcc1 	bl	101111c <lll_conn_pdu_tx_prep>
	pdu_data_tx->sn = lll->sn;
 101179a:	f894 2062 	ldrb.w	r2, [r4, #98]	; 0x62
 101179e:	9803      	ldr	r0, [sp, #12]
	pdu_data_tx->nesn = lll->nesn;
 10117a0:	f3c2 0340 	ubfx	r3, r2, #1, #1
 10117a4:	7801      	ldrb	r1, [r0, #0]
	pdu_data_tx->sn = lll->sn;
 10117a6:	f3c2 0200 	ubfx	r2, r2, #0, #1
	pdu_data_tx->nesn = lll->nesn;
 10117aa:	009b      	lsls	r3, r3, #2
 10117ac:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 10117b0:	f021 020c 	bic.w	r2, r1, #12
 10117b4:	4313      	orrs	r3, r2
 10117b6:	7003      	strb	r3, [r0, #0]

	/* Start setting up of Radio h/w */
	radio_reset();
 10117b8:	f000 fa3a 	bl	1011c30 <radio_reset>
#if defined(CONFIG_BT_CTLR_TX_PWR_DYNAMIC_CONTROL)
	radio_tx_power_set(lll->tx_pwr_lvl);
#else
	radio_tx_power_set(RADIO_TXP_DEFAULT);
 10117bc:	2000      	movs	r0, #0
 10117be:	f000 fa73 	bl	1011ca8 <radio_tx_power_set>
#endif

	radio_aa_set(lll->access_addr);
 10117c2:	f104 0008 	add.w	r0, r4, #8
 10117c6:	f000 fa8d 	bl	1011ce4 <radio_aa_set>
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
			    (((u32_t)lll->crc_init[2] << 16) |
			     ((u32_t)lll->crc_init[1] << 8) |
 10117ca:	7b63      	ldrb	r3, [r4, #13]
			    (((u32_t)lll->crc_init[2] << 16) |
 10117cc:	7ba2      	ldrb	r2, [r4, #14]
			     ((u32_t)lll->crc_init[0])));
 10117ce:	7b21      	ldrb	r1, [r4, #12]
			     ((u32_t)lll->crc_init[1] << 8) |
 10117d0:	021b      	lsls	r3, r3, #8
			    (((u32_t)lll->crc_init[2] << 16) |
 10117d2:	ea43 4302 	orr.w	r3, r3, r2, lsl #16
	radio_crc_configure(((0x5bUL) | ((0x06UL) << 8) | ((0x00UL) << 16)),
 10117d6:	4319      	orrs	r1, r3
 10117d8:	f240 605b 	movw	r0, #1627	; 0x65b
 10117dc:	f000 fb46 	bl	1011e6c <radio_crc_configure>
	lll_chan_set(data_chan_use);
 10117e0:	4630      	mov	r0, r6
 10117e2:	f7fe fba9 	bl	100ff38 <lll_chan_set>

	/* setup the radio tx packet buffer */
	lll_conn_tx_pkt_set(lll, pdu_data_tx);
 10117e6:	4620      	mov	r0, r4
 10117e8:	9903      	ldr	r1, [sp, #12]
 10117ea:	f7ff fc69 	bl	10110c0 <lll_conn_tx_pkt_set>

	radio_isr_set(lll_conn_isr_tx, lll);
 10117ee:	4621      	mov	r1, r4
 10117f0:	4821      	ldr	r0, [pc, #132]	; (1011878 <prepare_cb+0x120>)
 10117f2:	f000 f9fd 	bl	1011bf0 <radio_isr_set>

	radio_tmr_tifs_set(EVENT_IFS_US);
 10117f6:	2096      	movs	r0, #150	; 0x96
 10117f8:	f000 fbf6 	bl	1011fe8 <radio_tmr_tifs_set>

#if defined(CONFIG_BT_CTLR_PHY)
	radio_switch_complete_and_rx(lll->phy_rx);
 10117fc:	f894 0049 	ldrb.w	r0, [r4, #73]	; 0x49
 1011800:	f000 0007 	and.w	r0, r0, #7
 1011804:	f000 fb50 	bl	1011ea8 <radio_switch_complete_and_rx>
#else /* !CONFIG_BT_CTLR_PHY */
	radio_switch_complete_and_rx(0);
#endif /* !CONFIG_BT_CTLR_PHY */

	ticks_at_event = prepare_param->ticks_at_expire;
	evt = HDR_LLL2EVT(lll);
 1011808:	6827      	ldr	r7, [r4, #0]
	ticks_at_event = prepare_param->ticks_at_expire;
 101180a:	682e      	ldr	r6, [r5, #0]
	ticks_at_event += lll_evt_offset_get(evt);
 101180c:	4638      	mov	r0, r7
 101180e:	f7fe fb77 	bl	100ff00 <lll_evt_offset_get>
 1011812:	4406      	add	r6, r0

	ticks_at_start = ticks_at_event;
	ticks_at_start += HAL_TICKER_US_TO_TICKS(EVENT_OVERHEAD_START_US);

	remainder = prepare_param->remainder;
	remainder_us = radio_tmr_start(1, ticks_at_start, remainder);
 1011814:	686a      	ldr	r2, [r5, #4]
 1011816:	f106 0109 	add.w	r1, r6, #9
 101181a:	2001      	movs	r0, #1
 101181c:	f000 fbf0 	bl	1012000 <radio_tmr_start>

	/* capture end of Tx-ed PDU, used to calculate HCTO. */
	radio_tmr_end_capture();
 1011820:	f000 fd06 	bl	1012230 <radio_tmr_end_capture>
#endif /* !CONFIG_BT_CTLR_GPIO_PA_PIN */

#if defined(CONFIG_BT_CTLR_XTAL_ADVANCED) && \
	(EVENT_OVERHEAD_PREEMPT_US <= EVENT_OVERHEAD_PREEMPT_MIN_US)
	/* check if preempt to start has changed */
	if (lll_preempt_calc(evt, (TICKER_ID_CONN_BASE + lll->handle),
 1011824:	7c21      	ldrb	r1, [r4, #16]
 1011826:	4632      	mov	r2, r6
 1011828:	3105      	adds	r1, #5
 101182a:	4638      	mov	r0, r7
 101182c:	b2c9      	uxtb	r1, r1
 101182e:	f7fe fb71 	bl	100ff14 <lll_preempt_calc>
 1011832:	b1a8      	cbz	r0, 1011860 <prepare_cb+0x108>
			     ticks_at_event)) {
		radio_isr_set(lll_conn_isr_abort, lll);
 1011834:	4621      	mov	r1, r4
 1011836:	4811      	ldr	r0, [pc, #68]	; (101187c <prepare_cb+0x124>)
 1011838:	f000 f9da 	bl	1011bf0 <radio_isr_set>
		radio_disable();
 101183c:	f000 fad6 	bl	1011dec <radio_disable>
	}

	DEBUG_RADIO_START_M(1);

	return 0;
}
 1011840:	2000      	movs	r0, #0
 1011842:	b005      	add	sp, #20
 1011844:	bdf0      	pop	{r4, r5, r6, r7, pc}
		data_chan_use = lll_chan_sel_1(&lll->data_chan_use,
 1011846:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 101184a:	f894 1022 	ldrb.w	r1, [r4, #34]	; 0x22
 101184e:	f104 0023 	add.w	r0, r4, #35	; 0x23
 1011852:	9300      	str	r3, [sp, #0]
 1011854:	f104 031c 	add.w	r3, r4, #28
 1011858:	f7f8 fdb6 	bl	100a3c8 <lll_chan_sel_1>
 101185c:	4606      	mov	r6, r0
 101185e:	e798      	b.n	1011792 <prepare_cb+0x3a>
		ret = lll_prepare_done(lll);
 1011860:	4620      	mov	r0, r4
 1011862:	f7fe fb0f 	bl	100fe84 <lll_prepare_done>
		LL_ASSERT(!ret);
 1011866:	2800      	cmp	r0, #0
 1011868:	d0ea      	beq.n	1011840 <prepare_cb+0xe8>
 101186a:	21d4      	movs	r1, #212	; 0xd4
 101186c:	4804      	ldr	r0, [pc, #16]	; (1011880 <prepare_cb+0x128>)
 101186e:	f7f1 fe8b 	bl	1003588 <bt_ctlr_assert_handle>
}
 1011872:	2000      	movs	r0, #0
 1011874:	b005      	add	sp, #20
 1011876:	bdf0      	pop	{r4, r5, r6, r7, pc}
 1011878:	01011005 	.word	0x01011005
 101187c:	01010f65 	.word	0x01010f65
 1011880:	01018b4c 	.word	0x01018b4c

01011884 <lll_master_prepare>:
{
 1011884:	b530      	push	{r4, r5, lr}
 1011886:	b083      	sub	sp, #12
 1011888:	4604      	mov	r4, r0
	struct lll_conn *lll = p->param;
 101188a:	68c5      	ldr	r5, [r0, #12]
	err = lll_hfclock_on();
 101188c:	f7fe fbce 	bl	101002c <lll_hfclock_on>
	LL_ASSERT(!err || err == -EINPROGRESS);
 1011890:	b108      	cbz	r0, 1011896 <lll_master_prepare+0x12>
 1011892:	3044      	adds	r0, #68	; 0x44
 1011894:	d117      	bne.n	10118c6 <lll_master_prepare+0x42>
	elapsed = p->lazy + 1;
 1011896:	8923      	ldrh	r3, [r4, #8]
	lll->latency_prepare += elapsed;
 1011898:	8aea      	ldrh	r2, [r5, #22]
	elapsed = p->lazy + 1;
 101189a:	3301      	adds	r3, #1
	lll->latency_prepare += elapsed;
 101189c:	4413      	add	r3, r2
 101189e:	82eb      	strh	r3, [r5, #22]
	err = lll_prepare(lll_conn_is_abort_cb, lll_conn_abort_cb, prepare_cb,
 10118a0:	4a0b      	ldr	r2, [pc, #44]	; (10118d0 <lll_master_prepare+0x4c>)
 10118a2:	2300      	movs	r3, #0
 10118a4:	490b      	ldr	r1, [pc, #44]	; (10118d4 <lll_master_prepare+0x50>)
 10118a6:	480c      	ldr	r0, [pc, #48]	; (10118d8 <lll_master_prepare+0x54>)
 10118a8:	9400      	str	r4, [sp, #0]
 10118aa:	f7fe fa77 	bl	100fd9c <lll_prepare>
	LL_ASSERT(!err || err == -EINPROGRESS);
 10118ae:	b108      	cbz	r0, 10118b4 <lll_master_prepare+0x30>
 10118b0:	3044      	adds	r0, #68	; 0x44
 10118b2:	d101      	bne.n	10118b8 <lll_master_prepare+0x34>
}
 10118b4:	b003      	add	sp, #12
 10118b6:	bd30      	pop	{r4, r5, pc}
	LL_ASSERT(!err || err == -EINPROGRESS);
 10118b8:	2153      	movs	r1, #83	; 0x53
 10118ba:	4808      	ldr	r0, [pc, #32]	; (10118dc <lll_master_prepare+0x58>)
}
 10118bc:	b003      	add	sp, #12
 10118be:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
	LL_ASSERT(!err || err == -EINPROGRESS);
 10118c2:	f7f1 be61 	b.w	1003588 <bt_ctlr_assert_handle>
	LL_ASSERT(!err || err == -EINPROGRESS);
 10118c6:	2148      	movs	r1, #72	; 0x48
 10118c8:	4804      	ldr	r0, [pc, #16]	; (10118dc <lll_master_prepare+0x58>)
 10118ca:	f7f1 fe5d 	bl	1003588 <bt_ctlr_assert_handle>
 10118ce:	e7e2      	b.n	1011896 <lll_master_prepare+0x12>
 10118d0:	01011759 	.word	0x01011759
 10118d4:	01010f2d 	.word	0x01010f2d
 10118d8:	01010f25 	.word	0x01010f25
 10118dc:	01018b4c 	.word	0x01018b4c

010118e0 <cntr_init>:
    p_reg->EVTENSET = mask;
 10118e0:	f44f 3280 	mov.w	r2, #65536	; 0x10000

static u8_t _refcount;

void cntr_init(void)
{
	NRF_RTC->PRESCALER = 0;
 10118e4:	2100      	movs	r1, #0
 10118e6:	4b04      	ldr	r3, [pc, #16]	; (10118f8 <cntr_init+0x18>)
 10118e8:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
 10118ec:	f8c3 2344 	str.w	r2, [r3, #836]	; 0x344
    p_reg->INTENSET = mask;
 10118f0:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
	nrf_rtc_event_enable(NRF_RTC, RTC_EVTENSET_COMPARE0_Msk);
	nrf_rtc_int_enable(NRF_RTC, RTC_INTENSET_COMPARE0_Msk);
}
 10118f4:	4770      	bx	lr
 10118f6:	bf00      	nop
 10118f8:	41011000 	.word	0x41011000

010118fc <cntr_start>:

u32_t cntr_start(void)
{
	if (_refcount++) {
 10118fc:	4b05      	ldr	r3, [pc, #20]	; (1011914 <cntr_start+0x18>)
 10118fe:	7818      	ldrb	r0, [r3, #0]
 1011900:	1c42      	adds	r2, r0, #1
 1011902:	701a      	strb	r2, [r3, #0]
 1011904:	b918      	cbnz	r0, 101190e <cntr_start+0x12>
    *(__IO uint32_t *)((uint32_t)p_reg + task) = 1;
 1011906:	2201      	movs	r2, #1
 1011908:	4b03      	ldr	r3, [pc, #12]	; (1011918 <cntr_start+0x1c>)
 101190a:	601a      	str	r2, [r3, #0]
		return 1;
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_START);

	return 0;
 101190c:	4770      	bx	lr
		return 1;
 101190e:	2001      	movs	r0, #1
}
 1011910:	4770      	bx	lr
 1011912:	bf00      	nop
 1011914:	210066f9 	.word	0x210066f9
 1011918:	41011000 	.word	0x41011000

0101191c <cntr_stop>:

u32_t cntr_stop(void)
{
 101191c:	b510      	push	{r4, lr}
	LL_ASSERT(_refcount);
 101191e:	4c09      	ldr	r4, [pc, #36]	; (1011944 <cntr_stop+0x28>)
 1011920:	7820      	ldrb	r0, [r4, #0]
 1011922:	b148      	cbz	r0, 1011938 <cntr_stop+0x1c>

	if (--_refcount) {
 1011924:	3801      	subs	r0, #1
 1011926:	b2c0      	uxtb	r0, r0
 1011928:	7020      	strb	r0, [r4, #0]
 101192a:	b918      	cbnz	r0, 1011934 <cntr_stop+0x18>
 101192c:	2201      	movs	r2, #1
 101192e:	4b06      	ldr	r3, [pc, #24]	; (1011948 <cntr_stop+0x2c>)
 1011930:	601a      	str	r2, [r3, #0]
	}

	nrf_rtc_task_trigger(NRF_RTC, NRF_RTC_TASK_STOP);

	return 0;
}
 1011932:	bd10      	pop	{r4, pc}
		return 1;
 1011934:	2001      	movs	r0, #1
}
 1011936:	bd10      	pop	{r4, pc}
	LL_ASSERT(_refcount);
 1011938:	4804      	ldr	r0, [pc, #16]	; (101194c <cntr_stop+0x30>)
 101193a:	212e      	movs	r1, #46	; 0x2e
 101193c:	f7f1 fe24 	bl	1003588 <bt_ctlr_assert_handle>
 1011940:	7820      	ldrb	r0, [r4, #0]
 1011942:	e7ef      	b.n	1011924 <cntr_stop+0x8>
 1011944:	210066f9 	.word	0x210066f9
 1011948:	41011004 	.word	0x41011004
 101194c:	01018bb0 	.word	0x01018bb0

01011950 <cntr_cnt_get>:
     return p_reg->COUNTER;
 1011950:	4b01      	ldr	r3, [pc, #4]	; (1011958 <cntr_cnt_get+0x8>)
 1011952:	f8d3 0504 	ldr.w	r0, [r3, #1284]	; 0x504

u32_t cntr_cnt_get(void)
{
	return nrf_rtc_counter_get(NRF_RTC);
}
 1011956:	4770      	bx	lr
 1011958:	41011000 	.word	0x41011000

0101195c <cntr_cmp_set>:
    p_reg->CC[ch] = cc_val;
 101195c:	4b02      	ldr	r3, [pc, #8]	; (1011968 <cntr_cmp_set+0xc>)
 101195e:	f500 70a8 	add.w	r0, r0, #336	; 0x150
 1011962:	f843 1020 	str.w	r1, [r3, r0, lsl #2]

void cntr_cmp_set(u8_t cmp, u32_t value)
{
	nrf_rtc_cc_set(NRF_RTC, cmp, value);
}
 1011966:	4770      	bx	lr
 1011968:	41011000 	.word	0x41011000

0101196c <do_ecb>:
	u8_t clear_text[16];
	u8_t cipher_text[16];
} __packed;

static void do_ecb(struct ecb_param *ecb)
{
 101196c:	b4f0      	push	{r4, r5, r6, r7}

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ecb_task_trigger(NRF_ECB_Type * p_reg, nrf_ecb_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 101196e:	2601      	movs	r6, #1
	do {
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
		NRF_ECB->ECBDATAPTR = (u32_t)ecb;
		NRF_ECB->EVENTS_ENDECB = 0;
 1011970:	2400      	movs	r4, #0
 1011972:	4635      	mov	r5, r6
 1011974:	4910      	ldr	r1, [pc, #64]	; (10119b8 <do_ecb+0x4c>)
		NRF_ECB->ECBDATAPTR = (u32_t)ecb;
 1011976:	4b11      	ldr	r3, [pc, #68]	; (10119bc <do_ecb+0x50>)
 1011978:	600d      	str	r5, [r1, #0]
 101197a:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
		NRF_ECB->EVENTS_ENDECB = 0;
 101197e:	f8c3 4100 	str.w	r4, [r3, #256]	; 0x100
		NRF_ECB->EVENTS_ERRORECB = 0;
 1011982:	f8c3 4104 	str.w	r4, [r3, #260]	; 0x104
 1011986:	601d      	str	r5, [r3, #0]
}
 1011988:	e005      	b.n	1011996 <do_ecb+0x2a>
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STARTECB);
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
 101198a:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
 101198e:	b932      	cbnz	r2, 101199e <do_ecb+0x32>
		       (NRF_ECB->ECBDATAPTR != 0)) {
 1011990:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504
		       (NRF_ECB->EVENTS_ERRORECB == 0) &&
 1011994:	b11a      	cbz	r2, 101199e <do_ecb+0x32>
		while ((NRF_ECB->EVENTS_ENDECB == 0) &&
 1011996:	f8d3 2100 	ldr.w	r2, [r3, #256]	; 0x100
 101199a:	2a00      	cmp	r2, #0
 101199c:	d0f5      	beq.n	101198a <do_ecb+0x1e>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 101199e:	600e      	str	r6, [r1, #0]
#else
			/*__WFE();*/
#endif
		}
		nrf_ecb_task_trigger(NRF_ECB, NRF_ECB_TASK_STOPECB);
	} while ((NRF_ECB->EVENTS_ERRORECB != 0) || (NRF_ECB->ECBDATAPTR == 0));
 10119a0:	f8d3 2104 	ldr.w	r2, [r3, #260]	; 0x104
 10119a4:	2a00      	cmp	r2, #0
 10119a6:	d1e7      	bne.n	1011978 <do_ecb+0xc>
 10119a8:	f8d3 7504 	ldr.w	r7, [r3, #1284]	; 0x504
 10119ac:	2f00      	cmp	r7, #0
 10119ae:	d0e3      	beq.n	1011978 <do_ecb+0xc>

	NRF_ECB->ECBDATAPTR = 0;
}
 10119b0:	bcf0      	pop	{r4, r5, r6, r7}
	NRF_ECB->ECBDATAPTR = 0;
 10119b2:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
}
 10119b6:	4770      	bx	lr
 10119b8:	4100d004 	.word	0x4100d004
 10119bc:	4100d000 	.word	0x4100d000

010119c0 <ecb_encrypt>:
	memcpy(cipher_text_be, &ecb.cipher_text[0], sizeof(ecb.cipher_text));
}

void ecb_encrypt(u8_t const *const key_le, u8_t const *const clear_text_le,
		 u8_t * const cipher_text_le, u8_t * const cipher_text_be)
{
 10119c0:	b570      	push	{r4, r5, r6, lr}
 10119c2:	b08c      	sub	sp, #48	; 0x30
 10119c4:	460e      	mov	r6, r1
 10119c6:	4615      	mov	r5, r2
 10119c8:	4601      	mov	r1, r0
	struct ecb_param ecb;

	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
 10119ca:	2210      	movs	r2, #16
 10119cc:	4668      	mov	r0, sp
{
 10119ce:	461c      	mov	r4, r3
	mem_rcopy(&ecb.key[0], key_le, sizeof(ecb.key));
 10119d0:	f7f4 f962 	bl	1005c98 <mem_rcopy>
	mem_rcopy(&ecb.clear_text[0], clear_text_le, sizeof(ecb.clear_text));
 10119d4:	2210      	movs	r2, #16
 10119d6:	4631      	mov	r1, r6
 10119d8:	eb0d 0002 	add.w	r0, sp, r2
 10119dc:	f7f4 f95c 	bl	1005c98 <mem_rcopy>

	do_ecb(&ecb);
 10119e0:	4668      	mov	r0, sp
 10119e2:	f7ff ffc3 	bl	101196c <do_ecb>

	if (cipher_text_le) {
 10119e6:	b125      	cbz	r5, 10119f2 <ecb_encrypt+0x32>
		mem_rcopy(cipher_text_le, &ecb.cipher_text[0],
 10119e8:	4628      	mov	r0, r5
 10119ea:	2210      	movs	r2, #16
 10119ec:	a908      	add	r1, sp, #32
 10119ee:	f7f4 f953 	bl	1005c98 <mem_rcopy>
			  sizeof(ecb.cipher_text));
	}

	if (cipher_text_be) {
 10119f2:	b124      	cbz	r4, 10119fe <ecb_encrypt+0x3e>
		memcpy(cipher_text_be, &ecb.cipher_text[0],
 10119f4:	4620      	mov	r0, r4
 10119f6:	2210      	movs	r2, #16
 10119f8:	a908      	add	r1, sp, #32
 10119fa:	f004 ff5d 	bl	10168b8 <memcpy>
			 sizeof(ecb.cipher_text));
	}
}
 10119fe:	b00c      	add	sp, #48	; 0x30
 1011a00:	bd70      	pop	{r4, r5, r6, pc}
 1011a02:	bf00      	nop

01011a04 <sw_switch.isra.0>:
#endif

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
static u8_t sw_tifs_toggle;

static void sw_switch(u8_t dir, u8_t phy_curr, u8_t flags_curr, u8_t phy_next,
 1011a04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
		      u8_t flags_next)
{
	u8_t ppi = HAL_SW_SWITCH_RADIO_ENABLE_PPI(sw_tifs_toggle);
 1011a08:	f8df e1c0 	ldr.w	lr, [pc, #448]	; 1011bcc <sw_switch.isra.0+0x1c8>
	/* Set up software switch mechanism for next Radio switch. */

	/* Wire RADIO END event to PPI Group[<index>] enable task,
	 * over PPI[<HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI>]
	 */
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_EVT =
 1011a0c:	4b6a      	ldr	r3, [pc, #424]	; (1011bb8 <sw_switch.isra.0+0x1b4>)
 1011a0e:	f89e 4000 	ldrb.w	r4, [lr]
 1011a12:	f99e c000 	ldrsb.w	ip, [lr]
 1011a16:	00e7      	lsls	r7, r4, #3
 1011a18:	4e68      	ldr	r6, [pc, #416]	; (1011bbc <sw_switch.isra.0+0x1b8>)
 1011a1a:	f107 4782 	add.w	r7, r7, #1090519040	; 0x41000000
 1011a1e:	f507 4770 	add.w	r7, r7, #61440	; 0xf000
 1011a22:	f10c 0508 	add.w	r5, ip, #8
 1011a26:	f8c6 318c 	str.w	r3, [r6, #396]	; 0x18c
 1011a2a:	b2ed      	uxtb	r5, r5
	    HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_EVT;
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(ppi_group_index) =
 1011a2c:	f8c7 3080 	str.w	r3, [r7, #128]	; 0x80
			HAL_SW_SWITCH_TIMER_CLEAR_PPI_EVT,
		"Radio End Timer Capture and Group Disable"
		" not on the same PPI channel.");

	/* We need to un-subscribe the other group from the PPI channel. */
	if (ppi_group_index == 0) {
 1011a30:	2c00      	cmp	r4, #0
 1011a32:	d142      	bne.n	1011aba <sw_switch.isra.0+0xb6>
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(1)	= 0;
 1011a34:	4b62      	ldr	r3, [pc, #392]	; (1011bc0 <sw_switch.isra.0+0x1bc>)
 1011a36:	f8c3 4088 	str.w	r4, [r3, #136]	; 0x88
	 * PPI[<radio_enable_ppi>] for enabling Radio. Do
	 * not wire the task; it is done by the caller of
	 * the function depending on the desired direction
	 * (TX/RX).
	 */
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_EVT(compare_reg) =
 1011a3a:	00a3      	lsls	r3, r4, #2
 1011a3c:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_EVT(radio_enable_ppi);
 1011a40:	f045 4500 	orr.w	r5, r5, #2147483648	; 0x80000000
 1011a44:	f503 33c0 	add.w	r3, r3, #98304	; 0x18000
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_EVT(compare_reg) =
 1011a48:	f8c3 51c0 	str.w	r5, [r3, #448]	; 0x1c0
	u8_t cc = SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle);
	u32_t delay;

	hal_radio_sw_switch_setup(cc, ppi, sw_tifs_toggle);

	if (dir) {
 1011a4c:	b1c8      	cbz	r0, 1011a82 <sw_switch.isra.0+0x7e>
	}
}

static inline u32_t hal_radio_tx_ready_delay_ns_get(u8_t phy, u8_t flags)
{
	switch (phy) {
 1011a4e:	2a02      	cmp	r2, #2
 1011a50:	d040      	beq.n	1011ad4 <sw_switch.isra.0+0xd0>
	default:
	case BIT(0):
		return HAL_RADIO_NRF5340_TXEN_TXIDLE_TX_1M_NS;
 1011a52:	f24a 563c 	movw	r6, #42300	; 0xa53c
 1011a56:	f649 70c4 	movw	r0, #40900	; 0x9fc4
 1011a5a:	2a04      	cmp	r2, #4
 1011a5c:	bf18      	it	ne
 1011a5e:	4606      	movne	r6, r0
	}
}

static inline u32_t hal_radio_rx_chain_delay_ns_get(u8_t phy, u8_t flags)
{
	switch (phy) {
 1011a60:	2902      	cmp	r1, #2
 1011a62:	f000 8085 	beq.w	1011b70 <sw_switch.isra.0+0x16c>
 1011a66:	2904      	cmp	r1, #4
 1011a68:	f040 8094 	bne.w	1011b94 <sw_switch.isra.0+0x190>
 1011a6c:	4855      	ldr	r0, [pc, #340]	; (1011bc4 <sw_switch.isra.0+0x1c0>)
 1011a6e:	f506 46eb 	add.w	r6, r6, #30080	; 0x7580
 1011a72:	3614      	adds	r6, #20
 1011a74:	fba0 0606 	umull	r0, r6, r0, r6
 1011a78:	09b6      	lsrs	r6, r6, #6
}

static inline void hal_radio_txen_on_sw_switch(u8_t ppi)
{
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_TASK_TX =
 1011a7a:	4850      	ldr	r0, [pc, #320]	; (1011bbc <sw_switch.isra.0+0x1b8>)
 1011a7c:	f8c0 5080 	str.w	r5, [r0, #128]	; 0x80
		    HAL_SW_SWITCH_RADIO_ENABLE_S2_PPI(sw_tifs_toggle);
		u8_t ppi_dis =
			HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI(
			    sw_tifs_toggle);

		if (phy_curr & BIT(2)) {
 1011a80:	e032      	b.n	1011ae8 <sw_switch.isra.0+0xe4>
		}
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
	} else {
		/* RX */
		delay = HAL_RADIO_NS2US_CEIL(
 1011a82:	2628      	movs	r6, #40	; 0x28
		HAL_SW_SWITCH_RADIO_ENABLE_PPI_TASK_TX_SET(ppi);
}

static inline void hal_radio_rxen_on_sw_switch(u8_t ppi)
{
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_TASK_RX =
 1011a84:	4a4d      	ldr	r2, [pc, #308]	; (1011bbc <sw_switch.isra.0+0x1b8>)
 1011a86:	f8c2 5084 	str.w	r5, [r2, #132]	; 0x84
	 *
	 * Note: we do not un-subscribe the Radio enable task because
	 * we use the same PPI for both SW Switch Timer compare events.
	 */
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_EVT(
		SW_SWITCH_TIMER_S2_EVTS_COMP(group_index)) = 0;
 1011a8a:	f8c3 01c8 	str.w	r0, [r3, #456]	; 0x1c8

	/* Wire the Group[group_index] task disable to the default
	 * SW Switch Timer EVENTS_COMPARE.
	 */
	HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_REGISTER_EVT(
		cc_reg) =
 1011a8e:	f8c3 51c0 	str.w	r5, [r3, #448]	; 0x1c0
		HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_EVT(
			ppi_dis);
	HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_REGISTER_TASK(
		group_index) =
 1011a92:	f8c7 5084 	str.w	r5, [r7, #132]	; 0x84
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
	}

	if (delay <
		SW_SWITCH_TIMER->CC[cc]) {
 1011a96:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
	if (delay <
 1011a9a:	42b2      	cmp	r2, r6
 1011a9c:	d814      	bhi.n	1011ac8 <sw_switch.isra.0+0xc4>

NRF_STATIC_INLINE void nrf_timer_cc_set(NRF_TIMER_Type *       p_reg,
                                        nrf_timer_cc_channel_t cc_channel,
                                        uint32_t               cc_value)
{
    p_reg->CC[cc_channel] = cc_value;
 1011a9e:	2201      	movs	r2, #1
 1011aa0:	f8c3 2540 	str.w	r2, [r3, #1344]	; 0x540
    p_reg->CHENCLR = 0xFFFFFFFFuL;
}

NRF_STATIC_INLINE void nrf_dppi_channels_enable(NRF_DPPIC_Type * p_reg, uint32_t mask)
{
    p_reg->CHENSET = mask;
 1011aa4:	2220      	movs	r2, #32
 1011aa6:	4b46      	ldr	r3, [pc, #280]	; (1011bc0 <sw_switch.isra.0+0x1bc>)
	 * always need to capture the PDU END time-stamp.
	 */
	radio_tmr_end_capture();
#endif /* CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */

	sw_tifs_toggle += 1U;
 1011aa8:	3401      	adds	r4, #1
	sw_tifs_toggle &= 1;
 1011aaa:	f004 0401 	and.w	r4, r4, #1
 1011aae:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
 1011ab2:	f88e 4000 	strb.w	r4, [lr]
}
 1011ab6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	} else if (ppi_group_index == 1) {
 1011aba:	2c01      	cmp	r4, #1
 1011abc:	d1bd      	bne.n	1011a3a <sw_switch.isra.0+0x36>
		HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(0)	= 0;
 1011abe:	2600      	movs	r6, #0
 1011ac0:	4b3f      	ldr	r3, [pc, #252]	; (1011bc0 <sw_switch.isra.0+0x1bc>)
 1011ac2:	f8c3 6080 	str.w	r6, [r3, #128]	; 0x80
 1011ac6:	e7b8      	b.n	1011a3a <sw_switch.isra.0+0x36>
				 SW_SWITCH_TIMER->CC[cc] - delay);
 1011ac8:	f8d3 2540 	ldr.w	r2, [r3, #1344]	; 0x540
		nrf_timer_cc_set(SW_SWITCH_TIMER, cc,
 1011acc:	1b96      	subs	r6, r2, r6
 1011ace:	f8c3 6540 	str.w	r6, [r3, #1344]	; 0x540
}
 1011ad2:	e7e7      	b.n	1011aa4 <sw_switch.isra.0+0xa0>
 1011ad4:	2902      	cmp	r1, #2
 1011ad6:	d06a      	beq.n	1011bae <sw_switch.isra.0+0x1aa>
 1011ad8:	2904      	cmp	r1, #4
 1011ada:	d066      	beq.n	1011baa <sw_switch.isra.0+0x1a6>
 1011adc:	2631      	movs	r6, #49	; 0x31
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_TASK_TX =
 1011ade:	4837      	ldr	r0, [pc, #220]	; (1011bbc <sw_switch.isra.0+0x1b8>)
 1011ae0:	f8c0 5080 	str.w	r5, [r0, #128]	; 0x80
		if (phy_curr & BIT(2)) {
 1011ae4:	0748      	lsls	r0, r1, #29
 1011ae6:	d54d      	bpl.n	1011b84 <sw_switch.isra.0+0x180>
	switch (phy) {
 1011ae8:	2a02      	cmp	r2, #2
 1011aea:	d05b      	beq.n	1011ba4 <sw_switch.isra.0+0x1a0>
 1011aec:	f24a 18b8 	movw	r8, #41400	; 0xa1b8
 1011af0:	f24a 7030 	movw	r0, #42800	; 0xa730
 1011af4:	2a04      	cmp	r2, #4
 1011af6:	bf14      	ite	ne
 1011af8:	4642      	movne	r2, r8
 1011afa:	4602      	moveq	r2, r0
#if defined(CONFIG_BT_CTLR_PHY_CODED)
	case BIT(2):
		if (flags & 0x01) {
			return HAL_RADIO_NRF5340_RX_CHAIN_DELAY_S8_NS;
		} else {
			return HAL_RADIO_NRF5340_RX_CHAIN_DELAY_S2_NS;
 1011afc:	f242 48b8 	movw	r8, #9400	; 0x24b8
 1011b00:	f246 0018 	movw	r0, #24600	; 0x6018
 1011b04:	2904      	cmp	r1, #4
 1011b06:	bf14      	ite	ne
 1011b08:	4641      	movne	r1, r8
 1011b0a:	4601      	moveq	r1, r0
			    SW_SWITCH_TIMER_S2_EVTS_COMP(sw_tifs_toggle);
 1011b0c:	f10c 0002 	add.w	r0, ip, #2
 1011b10:	b2c0      	uxtb	r0, r0
			delay_s2 = HAL_RADIO_NS2US_ROUND(
 1011b12:	f8df 80b0 	ldr.w	r8, [pc, #176]	; 1011bc4 <sw_switch.isra.0+0x1c0>
 1011b16:	0080      	lsls	r0, r0, #2
				SW_SWITCH_TIMER->CC[cc];
 1011b18:	f8d3 c540 	ldr.w	ip, [r3, #1344]	; 0x540
			delay_s2 = HAL_RADIO_NS2US_ROUND(
 1011b1c:	440a      	add	r2, r1
 1011b1e:	f100 4082 	add.w	r0, r0, #1090519040	; 0x41000000
 1011b22:	fba8 1202 	umull	r1, r2, r8, r2
 1011b26:	f500 30c0 	add.w	r0, r0, #98304	; 0x18000
			SW_SWITCH_TIMER->CC[cc_s2] =
 1011b2a:	f8c0 c540 	str.w	ip, [r0, #1344]	; 0x540
			if (delay_s2 < SW_SWITCH_TIMER->CC[cc_s2]) {
 1011b2e:	f8d0 1540 	ldr.w	r1, [r0, #1344]	; 0x540
			delay_s2 = HAL_RADIO_NS2US_ROUND(
 1011b32:	ea4f 1c92 	mov.w	ip, r2, lsr #6
			if (delay_s2 < SW_SWITCH_TIMER->CC[cc_s2]) {
 1011b36:	ebb1 1f92 	cmp.w	r1, r2, lsr #6
				SW_SWITCH_TIMER->CC[cc_s2] -= delay_s2;
 1011b3a:	bf8a      	itet	hi
 1011b3c:	f8d0 2540 	ldrhi.w	r2, [r0, #1344]	; 0x540
				SW_SWITCH_TIMER->CC[cc_s2] = 1;
 1011b40:	2201      	movls	r2, #1
				SW_SWITCH_TIMER->CC[cc_s2] -= delay_s2;
 1011b42:	eba2 020c 	subhi.w	r2, r2, ip
 1011b46:	f44f 5c00 	mov.w	ip, #8192	; 0x2000
				SW_SWITCH_TIMER->CC[cc_s2] = 1;
 1011b4a:	f8c0 2540 	str.w	r2, [r0, #1344]	; 0x540
	HAL_SW_SWITCH_TIMER_S8_DISABLE_PPI_REGISTER_EVT =
 1011b4e:	f8df 806c 	ldr.w	r8, [pc, #108]	; 1011bbc <sw_switch.isra.0+0x1b8>
 1011b52:	4a1d      	ldr	r2, [pc, #116]	; (1011bc8 <sw_switch.isra.0+0x1c4>)
 1011b54:	491a      	ldr	r1, [pc, #104]	; (1011bc0 <sw_switch.isra.0+0x1bc>)
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_EVT(cc_s2) =
 1011b56:	f8c0 51c0 	str.w	r5, [r0, #448]	; 0x1c0
	HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_REGISTER_EVT(cc_s2) =
 1011b5a:	f8c0 51c0 	str.w	r5, [r0, #448]	; 0x1c0
	HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_REGISTER_TASK(group_index) =
 1011b5e:	f8c7 5084 	str.w	r5, [r7, #132]	; 0x84
	HAL_SW_SWITCH_TIMER_S8_DISABLE_PPI_REGISTER_EVT =
 1011b62:	f8c8 21d0 	str.w	r2, [r8, #464]	; 0x1d0
		SW_SWITCH_TIMER_EVTS_COMP(group_index)) =
 1011b66:	f8c3 20c0 	str.w	r2, [r3, #192]	; 0xc0
 1011b6a:	f8c1 c504 	str.w	ip, [r1, #1284]	; 0x504
}
 1011b6e:	e792      	b.n	1011a96 <sw_switch.isra.0+0x92>
		delay = HAL_RADIO_NS2US_ROUND(
 1011b70:	4a14      	ldr	r2, [pc, #80]	; (1011bc4 <sw_switch.isra.0+0x1c0>)
 1011b72:	f506 56ab 	add.w	r6, r6, #5472	; 0x1560
 1011b76:	361c      	adds	r6, #28
 1011b78:	fba2 2606 	umull	r2, r6, r2, r6
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_TASK_TX =
 1011b7c:	4a0f      	ldr	r2, [pc, #60]	; (1011bbc <sw_switch.isra.0+0x1b8>)
 1011b7e:	09b6      	lsrs	r6, r6, #6
 1011b80:	f8c2 5080 	str.w	r5, [r2, #128]	; 0x80
		SW_SWITCH_TIMER_S2_EVTS_COMP(group_index)) = 0;
 1011b84:	2200      	movs	r2, #0
 1011b86:	f8c3 21c8 	str.w	r2, [r3, #456]	; 0x1c8
		cc_reg) =
 1011b8a:	f8c3 51c0 	str.w	r5, [r3, #448]	; 0x1c0
		group_index) =
 1011b8e:	f8c7 5084 	str.w	r5, [r7, #132]	; 0x84
		HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_TASK(
			ppi_dis);
}
 1011b92:	e780      	b.n	1011a96 <sw_switch.isra.0+0x92>
 1011b94:	480b      	ldr	r0, [pc, #44]	; (1011bc4 <sw_switch.isra.0+0x1c0>)
 1011b96:	f506 561a 	add.w	r6, r6, #9856	; 0x2680
 1011b9a:	362c      	adds	r6, #44	; 0x2c
 1011b9c:	fba0 0606 	umull	r0, r6, r0, r6
 1011ba0:	09b6      	lsrs	r6, r6, #6
 1011ba2:	e79c      	b.n	1011ade <sw_switch.isra.0+0xda>
	switch (phy) {
 1011ba4:	f649 6234 	movw	r2, #40500	; 0x9e34
 1011ba8:	e7a8      	b.n	1011afc <sw_switch.isra.0+0xf8>
	switch (phy) {
 1011baa:	2646      	movs	r6, #70	; 0x46
 1011bac:	e765      	b.n	1011a7a <sw_switch.isra.0+0x76>
	HAL_SW_SWITCH_RADIO_ENABLE_PPI_REGISTER_TASK_TX =
 1011bae:	4a03      	ldr	r2, [pc, #12]	; (1011bbc <sw_switch.isra.0+0x1b8>)
 1011bb0:	262d      	movs	r6, #45	; 0x2d
 1011bb2:	f8c2 5080 	str.w	r5, [r2, #128]	; 0x80
		if (phy_curr & BIT(2)) {
 1011bb6:	e7e5      	b.n	1011b84 <sw_switch.isra.0+0x180>
 1011bb8:	80000005 	.word	0x80000005
 1011bbc:	41008000 	.word	0x41008000
 1011bc0:	4100f000 	.word	0x4100f000
 1011bc4:	10624dd3 	.word	0x10624dd3
 1011bc8:	8000000d 	.word	0x8000000d
 1011bcc:	210066fa 	.word	0x210066fa

01011bd0 <isr_radio>:
	return (NRF_RADIO->EVENTS_DISABLED != 0);
 1011bd0:	4b04      	ldr	r3, [pc, #16]	; (1011be4 <isr_radio+0x14>)
 1011bd2:	f8d3 3110 	ldr.w	r3, [r3, #272]	; 0x110
	if (radio_has_disabled()) {
 1011bd6:	b123      	cbz	r3, 1011be2 <isr_radio+0x12>
		isr_cb(isr_cb_param);
 1011bd8:	4a03      	ldr	r2, [pc, #12]	; (1011be8 <isr_radio+0x18>)
 1011bda:	4b04      	ldr	r3, [pc, #16]	; (1011bec <isr_radio+0x1c>)
 1011bdc:	6810      	ldr	r0, [r2, #0]
 1011bde:	681b      	ldr	r3, [r3, #0]
 1011be0:	4718      	bx	r3
}
 1011be2:	4770      	bx	lr
 1011be4:	41008000 	.word	0x41008000
 1011be8:	21003ee8 	.word	0x21003ee8
 1011bec:	21003ee4 	.word	0x21003ee4

01011bf0 <radio_isr_set>:
{
 1011bf0:	b570      	push	{r4, r5, r6, lr}
 1011bf2:	460d      	mov	r5, r1
 1011bf4:	4604      	mov	r4, r0
	irq_disable(RADIO_IRQn);
 1011bf6:	2008      	movs	r0, #8
 1011bf8:	f7f3 f89c 	bl	1004d34 <arch_irq_disable>
    return p_reg->SHORTS;
}

NRF_STATIC_INLINE void nrf_radio_int_enable(NRF_RADIO_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
 1011bfc:	2610      	movs	r6, #16
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 1011bfe:	f44f 7280 	mov.w	r2, #256	; 0x100
	isr_cb_param = param;
 1011c02:	4b07      	ldr	r3, [pc, #28]	; (1011c20 <radio_isr_set+0x30>)
	isr_cb = cb;
 1011c04:	4807      	ldr	r0, [pc, #28]	; (1011c24 <radio_isr_set+0x34>)
	isr_cb_param = param;
 1011c06:	601d      	str	r5, [r3, #0]
 1011c08:	4907      	ldr	r1, [pc, #28]	; (1011c28 <radio_isr_set+0x38>)
 1011c0a:	4b08      	ldr	r3, [pc, #32]	; (1011c2c <radio_isr_set+0x3c>)
	isr_cb = cb;
 1011c0c:	6004      	str	r4, [r0, #0]
 1011c0e:	f8c1 6304 	str.w	r6, [r1, #772]	; 0x304
	irq_enable(RADIO_IRQn);
 1011c12:	2008      	movs	r0, #8
}
 1011c14:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 1011c18:	f8c3 2180 	str.w	r2, [r3, #384]	; 0x180
	irq_enable(RADIO_IRQn);
 1011c1c:	f7f3 b87a 	b.w	1004d14 <arch_irq_enable>
 1011c20:	21003ee8 	.word	0x21003ee8
 1011c24:	21003ee4 	.word	0x21003ee4
 1011c28:	41008000 	.word	0x41008000
 1011c2c:	e000e100 	.word	0xe000e100

01011c30 <radio_reset>:
{
 1011c30:	b538      	push	{r3, r4, r5, lr}
	irq_disable(RADIO_IRQn);
 1011c32:	2008      	movs	r0, #8
 1011c34:	f7f3 f87e 	bl	1004d34 <arch_irq_disable>

	NRF_DPPIC->TASKS_CHG[SW_SWITCH_TIMER_TASK_GROUP(0)].DIS = 1;
	NRF_DPPIC->TASKS_CHG[SW_SWITCH_TIMER_TASK_GROUP(1)].DIS = 1;

	/* Include the appropriate PPI channels in the two PPI Groups. */
	NRF_DPPIC->CHG[SW_SWITCH_TIMER_TASK_GROUP(0)] =
 1011c38:	f44f 7580 	mov.w	r5, #256	; 0x100
}
#endif

NRF_STATIC_INLINE void nrf_radio_power_set(NRF_RADIO_Type * p_reg, bool radio_power)
{
    p_reg->POWER = (uint32_t) radio_power;
 1011c3c:	2200      	movs	r2, #0
 1011c3e:	2101      	movs	r1, #1
		HAL_SW_SWITCH_GROUP_TASK_DISABLE_PPI_0_INCLUDE |
			HAL_SW_SWITCH_RADIO_ENABLE_PPI_0_INCLUDE;
	NRF_DPPIC->CHG[SW_SWITCH_TIMER_TASK_GROUP(1)] =
 1011c40:	f44f 7400 	mov.w	r4, #512	; 0x200
	NRF_DPPIC->SUBSCRIBE_CHG[SW_SWITCH_TIMER_TASK_GROUP(0)].EN = 0;
 1011c44:	4b0a      	ldr	r3, [pc, #40]	; (1011c70 <radio_reset+0x40>)
 1011c46:	480b      	ldr	r0, [pc, #44]	; (1011c74 <radio_reset+0x44>)
 1011c48:	f8c0 2ffc 	str.w	r2, [r0, #4092]	; 0xffc
 1011c4c:	f8c0 1ffc 	str.w	r1, [r0, #4092]	; 0xffc
 1011c50:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
	NRF_DPPIC->SUBSCRIBE_CHG[SW_SWITCH_TIMER_TASK_GROUP(0)].DIS = 0;
 1011c54:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
	NRF_DPPIC->SUBSCRIBE_CHG[SW_SWITCH_TIMER_TASK_GROUP(1)].EN = 0;
 1011c58:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
	NRF_DPPIC->SUBSCRIBE_CHG[SW_SWITCH_TIMER_TASK_GROUP(1)].DIS = 0;
 1011c5c:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
	NRF_DPPIC->TASKS_CHG[SW_SWITCH_TIMER_TASK_GROUP(0)].DIS = 1;
 1011c60:	6059      	str	r1, [r3, #4]
	NRF_DPPIC->TASKS_CHG[SW_SWITCH_TIMER_TASK_GROUP(1)].DIS = 1;
 1011c62:	60d9      	str	r1, [r3, #12]
	NRF_DPPIC->CHG[SW_SWITCH_TIMER_TASK_GROUP(0)] =
 1011c64:	f8c3 5800 	str.w	r5, [r3, #2048]	; 0x800
	NRF_DPPIC->CHG[SW_SWITCH_TIMER_TASK_GROUP(1)] =
 1011c68:	f8c3 4804 	str.w	r4, [r3, #2052]	; 0x804
}
 1011c6c:	bd38      	pop	{r3, r4, r5, pc}
 1011c6e:	bf00      	nop
 1011c70:	4100f000 	.word	0x4100f000
 1011c74:	41008000 	.word	0x41008000

01011c78 <radio_phy_set>:
	switch (phy) {
 1011c78:	2802      	cmp	r0, #2
 1011c7a:	d011      	beq.n	1011ca0 <radio_phy_set+0x28>
 1011c7c:	2804      	cmp	r0, #4
 1011c7e:	d10d      	bne.n	1011c9c <radio_phy_set+0x24>
		if (flags & 0x01) {
 1011c80:	f001 0101 	and.w	r1, r1, #1
 1011c84:	f1c1 0106 	rsb	r1, r1, #6
	NRF_RADIO->MODE = (mode << RADIO_MODE_MODE_Pos) & RADIO_MODE_MODE_Msk;
 1011c88:	4b06      	ldr	r3, [pc, #24]	; (1011ca4 <radio_phy_set+0x2c>)
 1011c8a:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
	NRF_RADIO->MODECNF0 |= (RADIO_MODECNF0_RU_Fast <<
 1011c8e:	f8d3 2650 	ldr.w	r2, [r3, #1616]	; 0x650
 1011c92:	f042 0201 	orr.w	r2, r2, #1
 1011c96:	f8c3 2650 	str.w	r2, [r3, #1616]	; 0x650
}
 1011c9a:	4770      	bx	lr
		mode = RADIO_MODE_MODE_Ble_1Mbit;
 1011c9c:	2103      	movs	r1, #3
 1011c9e:	e7f3      	b.n	1011c88 <radio_phy_set+0x10>
	switch (phy) {
 1011ca0:	2104      	movs	r1, #4
 1011ca2:	e7f1      	b.n	1011c88 <radio_phy_set+0x10>
 1011ca4:	41008000 	.word	0x41008000

01011ca8 <radio_tx_power_set>:
	NRF_RADIO->TXPOWER = (u32_t)power;
 1011ca8:	4b01      	ldr	r3, [pc, #4]	; (1011cb0 <radio_tx_power_set+0x8>)
 1011caa:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
}
 1011cae:	4770      	bx	lr
 1011cb0:	41008000 	.word	0x41008000

01011cb4 <radio_freq_chan_set>:
	NRF_RADIO->FREQUENCY = chan;
 1011cb4:	4b01      	ldr	r3, [pc, #4]	; (1011cbc <radio_freq_chan_set+0x8>)
 1011cb6:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
}
 1011cba:	4770      	bx	lr
 1011cbc:	41008000 	.word	0x41008000

01011cc0 <radio_whiten_iv_set>:
	NRF_RADIO->DATAWHITEIV = iv;
 1011cc0:	4b07      	ldr	r3, [pc, #28]	; (1011ce0 <radio_whiten_iv_set+0x20>)
 1011cc2:	f8c3 0554 	str.w	r0, [r3, #1364]	; 0x554
	NRF_RADIO->PCNF1 &= ~RADIO_PCNF1_WHITEEN_Msk;
 1011cc6:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
 1011cca:	f022 7200 	bic.w	r2, r2, #33554432	; 0x2000000
 1011cce:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((1UL) << RADIO_PCNF1_WHITEEN_Pos) &
 1011cd2:	f8d3 2518 	ldr.w	r2, [r3, #1304]	; 0x518
 1011cd6:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 1011cda:	f8c3 2518 	str.w	r2, [r3, #1304]	; 0x518
}
 1011cde:	4770      	bx	lr
 1011ce0:	41008000 	.word	0x41008000

01011ce4 <radio_aa_set>:
	NRF_RADIO->TXADDRESS =
 1011ce4:	2100      	movs	r1, #0
	NRF_RADIO->RXADDRESSES =
 1011ce6:	2301      	movs	r3, #1
	NRF_RADIO->TXADDRESS =
 1011ce8:	4a0a      	ldr	r2, [pc, #40]	; (1011d14 <radio_aa_set+0x30>)
{
 1011cea:	b410      	push	{r4}
	NRF_RADIO->TXADDRESS =
 1011cec:	f8c2 152c 	str.w	r1, [r2, #1324]	; 0x52c
	NRF_RADIO->RXADDRESSES =
 1011cf0:	f8c2 3530 	str.w	r3, [r2, #1328]	; 0x530
	NRF_RADIO->PREFIX0 = aa[3];
 1011cf4:	78c3      	ldrb	r3, [r0, #3]
 1011cf6:	f8c2 3524 	str.w	r3, [r2, #1316]	; 0x524
	NRF_RADIO->BASE0 = (aa[2] << 24) | (aa[1] << 16) | (aa[0] << 8);
 1011cfa:	7843      	ldrb	r3, [r0, #1]
 1011cfc:	7884      	ldrb	r4, [r0, #2]
 1011cfe:	7801      	ldrb	r1, [r0, #0]
 1011d00:	041b      	lsls	r3, r3, #16
 1011d02:	ea43 6304 	orr.w	r3, r3, r4, lsl #24
 1011d06:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
}
 1011d0a:	bc10      	pop	{r4}
	NRF_RADIO->BASE0 = (aa[2] << 24) | (aa[1] << 16) | (aa[0] << 8);
 1011d0c:	f8c2 351c 	str.w	r3, [r2, #1308]	; 0x51c
}
 1011d10:	4770      	bx	lr
 1011d12:	bf00      	nop
 1011d14:	41008000 	.word	0x41008000

01011d18 <radio_pkt_configure>:
	phy = (flags >> 1) & 0x07; /* phy */
 1011d18:	f3c2 0342 	ubfx	r3, r2, #1, #3
	switch (phy) {
 1011d1c:	2b02      	cmp	r3, #2
{
 1011d1e:	b410      	push	{r4}
	u8_t dc = flags & 0x01; /* Adv or Data channel */
 1011d20:	f002 0201 	and.w	r2, r2, #1
	switch (phy) {
 1011d24:	d024      	beq.n	1011d70 <radio_pkt_configure+0x58>
		extra |= (3UL << RADIO_PCNF0_TERMLEN_Pos) &
 1011d26:	2b04      	cmp	r3, #4
 1011d28:	bf14      	ite	ne
 1011d2a:	2400      	movne	r4, #0
 1011d2c:	f04f 44c7 	moveq.w	r4, #1669332992	; 0x63800000
	if (dc) {
 1011d30:	b10a      	cbz	r2, 1011d36 <radio_pkt_configure+0x1e>
		extra |= (RADIO_PCNF0_S1INCL_Include <<
 1011d32:	f444 1480 	orr.w	r4, r4, #1048576	; 0x100000
			   ((((u32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
 1011d36:	f1c0 0308 	rsb	r3, r0, #8
 1011d3a:	041b      	lsls	r3, r3, #16
			   ((((u32_t)bits_len) << RADIO_PCNF0_LFLEN_Pos) &
 1011d3c:	f000 000f 	and.w	r0, r0, #15
			    RADIO_PCNF0_S1LEN_Msk) |
 1011d40:	4320      	orrs	r0, r4
			   ((((u32_t)8-bits_len) << RADIO_PCNF0_S1LEN_Pos) &
 1011d42:	f403 2370 	and.w	r3, r3, #983040	; 0xf0000
	NRF_RADIO->PCNF0 = (((1UL) << RADIO_PCNF0_S0LEN_Pos) &
 1011d46:	4a0d      	ldr	r2, [pc, #52]	; (1011d7c <radio_pkt_configure+0x64>)
			    RADIO_PCNF0_S1LEN_Msk) |
 1011d48:	4303      	orrs	r3, r0
 1011d4a:	f443 7380 	orr.w	r3, r3, #256	; 0x100
	NRF_RADIO->PCNF0 = (((1UL) << RADIO_PCNF0_S0LEN_Pos) &
 1011d4e:	f8c2 3514 	str.w	r3, [r2, #1300]	; 0x514
	NRF_RADIO->PCNF1 &= ~(RADIO_PCNF1_MAXLEN_Msk | RADIO_PCNF1_STATLEN_Msk |
 1011d52:	f8d2 0518 	ldr.w	r0, [r2, #1304]	; 0x518
 1011d56:	4b0a      	ldr	r3, [pc, #40]	; (1011d80 <radio_pkt_configure+0x68>)
}
 1011d58:	bc10      	pop	{r4}
	NRF_RADIO->PCNF1 &= ~(RADIO_PCNF1_MAXLEN_Msk | RADIO_PCNF1_STATLEN_Msk |
 1011d5a:	4003      	ands	r3, r0
 1011d5c:	f8c2 3518 	str.w	r3, [r2, #1304]	; 0x518
	NRF_RADIO->PCNF1 |= ((((u32_t)max_len) << RADIO_PCNF1_MAXLEN_Pos) &
 1011d60:	f8d2 3518 	ldr.w	r3, [r2, #1304]	; 0x518
 1011d64:	4319      	orrs	r1, r3
 1011d66:	f441 3140 	orr.w	r1, r1, #196608	; 0x30000
 1011d6a:	f8c2 1518 	str.w	r1, [r2, #1304]	; 0x518
}
 1011d6e:	4770      	bx	lr
	switch (phy) {
 1011d70:	f04f 7480 	mov.w	r4, #16777216	; 0x1000000
	if (dc) {
 1011d74:	2a00      	cmp	r2, #0
 1011d76:	d0de      	beq.n	1011d36 <radio_pkt_configure+0x1e>
 1011d78:	e7db      	b.n	1011d32 <radio_pkt_configure+0x1a>
 1011d7a:	bf00      	nop
 1011d7c:	41008000 	.word	0x41008000
 1011d80:	fef80000 	.word	0xfef80000

01011d84 <radio_pkt_rx_set>:
	NRF_RADIO->PACKETPTR = (u32_t)rx_packet;
 1011d84:	4b01      	ldr	r3, [pc, #4]	; (1011d8c <radio_pkt_rx_set+0x8>)
 1011d86:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
}
 1011d8a:	4770      	bx	lr
 1011d8c:	41008000 	.word	0x41008000

01011d90 <radio_pkt_tx_set>:
 1011d90:	4b01      	ldr	r3, [pc, #4]	; (1011d98 <radio_pkt_tx_set+0x8>)
 1011d92:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
 1011d96:	4770      	bx	lr
 1011d98:	41008000 	.word	0x41008000

01011d9c <radio_tx_ready_delay_get>:
	switch (phy) {
 1011d9c:	2802      	cmp	r0, #2
 1011d9e:	d004      	beq.n	1011daa <radio_tx_ready_delay_get+0xe>
 1011da0:	2804      	cmp	r0, #4
			return HAL_RADIO_NRF5340_TXEN_TXIDLE_TX_S8_US;
 1011da2:	bf14      	ite	ne
 1011da4:	2029      	movne	r0, #41	; 0x29
 1011da6:	202a      	moveq	r0, #42	; 0x2a
 1011da8:	4770      	bx	lr
	switch (phy) {
 1011daa:	2028      	movs	r0, #40	; 0x28
}
 1011dac:	4770      	bx	lr
 1011dae:	bf00      	nop

01011db0 <radio_tx_chain_delay_get>:
}
 1011db0:	2001      	movs	r0, #1
 1011db2:	4770      	bx	lr

01011db4 <radio_rx_ready_delay_get>:
}
 1011db4:	2029      	movs	r0, #41	; 0x29
 1011db6:	4770      	bx	lr

01011db8 <radio_rx_chain_delay_get>:
	switch (phy) {
 1011db8:	2802      	cmp	r0, #2
 1011dba:	d009      	beq.n	1011dd0 <radio_rx_chain_delay_get+0x18>
 1011dbc:	2804      	cmp	r0, #4
 1011dbe:	d105      	bne.n	1011dcc <radio_rx_chain_delay_get+0x14>
		if (flags & 0x01) {
 1011dc0:	f011 0f01 	tst.w	r1, #1
			return HAL_RADIO_NRF5340_RX_CHAIN_DELAY_S2_US;
 1011dc4:	bf14      	ite	ne
 1011dc6:	201e      	movne	r0, #30
 1011dc8:	2019      	moveq	r0, #25
 1011dca:	4770      	bx	lr
		return HAL_RADIO_NRF5340_RX_CHAIN_DELAY_1M_US;
 1011dcc:	200a      	movs	r0, #10
}
 1011dce:	4770      	bx	lr
	switch (phy) {
 1011dd0:	2005      	movs	r0, #5
 1011dd2:	4770      	bx	lr

01011dd4 <radio_rx_enable>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1011dd4:	2201      	movs	r2, #1
 1011dd6:	4b01      	ldr	r3, [pc, #4]	; (1011ddc <radio_rx_enable+0x8>)
 1011dd8:	601a      	str	r2, [r3, #0]
}
 1011dda:	4770      	bx	lr
 1011ddc:	41008004 	.word	0x41008004

01011de0 <radio_tx_enable>:
 1011de0:	2201      	movs	r2, #1
 1011de2:	4b01      	ldr	r3, [pc, #4]	; (1011de8 <radio_tx_enable+0x8>)
 1011de4:	601a      	str	r2, [r3, #0]
}
 1011de6:	4770      	bx	lr
 1011de8:	41008000 	.word	0x41008000

01011dec <radio_disable>:
{
 1011dec:	b430      	push	{r4, r5}
}

NRF_STATIC_INLINE void nrf_dppi_group_disable(NRF_DPPIC_Type *         p_reg,
                                              nrf_dppi_channel_group_t group)
{
    p_reg->TASKS_CHG[(uint32_t) group].DIS = 1;
 1011dee:	2301      	movs	r3, #1
    p_reg->CHENCLR = mask;
 1011df0:	2520      	movs	r5, #32
	NRF_RADIO->SHORTS = 0;
 1011df2:	2400      	movs	r4, #0
 1011df4:	4a05      	ldr	r2, [pc, #20]	; (1011e0c <radio_disable+0x20>)
 1011df6:	4806      	ldr	r0, [pc, #24]	; (1011e10 <radio_disable+0x24>)
 1011df8:	4906      	ldr	r1, [pc, #24]	; (1011e14 <radio_disable+0x28>)
 1011dfa:	f8c2 5508 	str.w	r5, [r2, #1288]	; 0x508
    p_reg->TASKS_CHG[(uint32_t) group].DIS = 1;
 1011dfe:	6053      	str	r3, [r2, #4]
 1011e00:	60d3      	str	r3, [r2, #12]
 1011e02:	f8c0 4200 	str.w	r4, [r0, #512]	; 0x200
 1011e06:	600b      	str	r3, [r1, #0]
}
 1011e08:	bc30      	pop	{r4, r5}
 1011e0a:	4770      	bx	lr
 1011e0c:	4100f000 	.word	0x4100f000
 1011e10:	41008000 	.word	0x41008000
 1011e14:	41008010 	.word	0x41008010

01011e18 <radio_status_reset>:
	NRF_RADIO->EVENTS_READY = 0;
 1011e18:	2200      	movs	r2, #0
 1011e1a:	4b04      	ldr	r3, [pc, #16]	; (1011e2c <radio_status_reset+0x14>)
 1011e1c:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
	NRF_RADIO->EVENTS_END = 0;
 1011e20:	f8c3 210c 	str.w	r2, [r3, #268]	; 0x10c
	NRF_RADIO->EVENTS_DISABLED = 0;
 1011e24:	f8c3 2110 	str.w	r2, [r3, #272]	; 0x110
}
 1011e28:	4770      	bx	lr
 1011e2a:	bf00      	nop
 1011e2c:	41008000 	.word	0x41008000

01011e30 <radio_is_ready>:
	return (NRF_RADIO->EVENTS_READY != 0);
 1011e30:	4b03      	ldr	r3, [pc, #12]	; (1011e40 <radio_is_ready+0x10>)
 1011e32:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
}
 1011e36:	3800      	subs	r0, #0
 1011e38:	bf18      	it	ne
 1011e3a:	2001      	movne	r0, #1
 1011e3c:	4770      	bx	lr
 1011e3e:	bf00      	nop
 1011e40:	41008000 	.word	0x41008000

01011e44 <radio_is_done>:
	return (NRF_RADIO->EVENTS_END != 0);
 1011e44:	4b03      	ldr	r3, [pc, #12]	; (1011e54 <radio_is_done+0x10>)
 1011e46:	f8d3 010c 	ldr.w	r0, [r3, #268]	; 0x10c
}
 1011e4a:	3800      	subs	r0, #0
 1011e4c:	bf18      	it	ne
 1011e4e:	2001      	movne	r0, #1
 1011e50:	4770      	bx	lr
 1011e52:	bf00      	nop
 1011e54:	41008000 	.word	0x41008000

01011e58 <radio_is_idle>:
	return (NRF_RADIO->STATE == 0);
 1011e58:	4b03      	ldr	r3, [pc, #12]	; (1011e68 <radio_is_idle+0x10>)
 1011e5a:	f8d3 0550 	ldr.w	r0, [r3, #1360]	; 0x550
}
 1011e5e:	fab0 f080 	clz	r0, r0
 1011e62:	0940      	lsrs	r0, r0, #5
 1011e64:	4770      	bx	lr
 1011e66:	bf00      	nop
 1011e68:	41008000 	.word	0x41008000

01011e6c <radio_crc_configure>:
	NRF_RADIO->CRCCNF =
 1011e6c:	f240 1203 	movw	r2, #259	; 0x103
 1011e70:	4b03      	ldr	r3, [pc, #12]	; (1011e80 <radio_crc_configure+0x14>)
 1011e72:	f8c3 2534 	str.w	r2, [r3, #1332]	; 0x534
	NRF_RADIO->CRCPOLY = polynomial;
 1011e76:	f8c3 0538 	str.w	r0, [r3, #1336]	; 0x538
	NRF_RADIO->CRCINIT = iv;
 1011e7a:	f8c3 153c 	str.w	r1, [r3, #1340]	; 0x53c
}
 1011e7e:	4770      	bx	lr
 1011e80:	41008000 	.word	0x41008000

01011e84 <radio_crc_is_valid>:
	return (NRF_RADIO->CRCSTATUS != 0);
 1011e84:	4b03      	ldr	r3, [pc, #12]	; (1011e94 <radio_crc_is_valid+0x10>)
 1011e86:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
 1011e8a:	3800      	subs	r0, #0
 1011e8c:	bf18      	it	ne
 1011e8e:	2001      	movne	r0, #1
 1011e90:	4770      	bx	lr
 1011e92:	bf00      	nop
 1011e94:	41008000 	.word	0x41008000

01011e98 <radio_pkt_empty_get>:
}
 1011e98:	4800      	ldr	r0, [pc, #0]	; (1011e9c <radio_pkt_empty_get+0x4>)
 1011e9a:	4770      	bx	lr
 1011e9c:	21003ddc 	.word	0x21003ddc

01011ea0 <radio_pkt_scratch_get>:
}
 1011ea0:	4800      	ldr	r0, [pc, #0]	; (1011ea4 <radio_pkt_scratch_get+0x4>)
 1011ea2:	4770      	bx	lr
 1011ea4:	21003de0 	.word	0x21003de0

01011ea8 <radio_switch_complete_and_rx>:
#endif /* CONFIG_BT_CTLR_TIFS_HW */

void radio_switch_complete_and_rx(u8_t phy_rx)
{
 1011ea8:	b410      	push	{r4}
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_RXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk;
	sw_switch(0, 0, 0, phy_rx, 0);
 1011eaa:	2100      	movs	r1, #0
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
 1011eac:	2403      	movs	r4, #3
 1011eae:	4b04      	ldr	r3, [pc, #16]	; (1011ec0 <radio_switch_complete_and_rx+0x18>)
{
 1011eb0:	4602      	mov	r2, r0
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
 1011eb2:	f8c3 4200 	str.w	r4, [r3, #512]	; 0x200
	sw_switch(0, 0, 0, phy_rx, 0);
 1011eb6:	4608      	mov	r0, r1
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
 1011eb8:	bc10      	pop	{r4}
	sw_switch(0, 0, 0, phy_rx, 0);
 1011eba:	f7ff bda3 	b.w	1011a04 <sw_switch.isra.0>
 1011ebe:	bf00      	nop
 1011ec0:	41008000 	.word	0x41008000

01011ec4 <radio_switch_complete_and_tx>:

void radio_switch_complete_and_tx(u8_t phy_rx, u8_t flags_rx, u8_t phy_tx,
				  u8_t flags_tx)
{
 1011ec4:	b410      	push	{r4}
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
			    RADIO_SHORTS_END_DISABLE_Msk |
			    RADIO_SHORTS_DISABLED_TXEN_Msk;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
 1011ec6:	2403      	movs	r4, #3
 1011ec8:	4b03      	ldr	r3, [pc, #12]	; (1011ed8 <radio_switch_complete_and_tx+0x14>)
{
 1011eca:	4601      	mov	r1, r0
	NRF_RADIO->SHORTS = RADIO_SHORTS_READY_START_Msk |
 1011ecc:	f8c3 4200 	str.w	r4, [r3, #512]	; 0x200
			    RADIO_SHORTS_END_DISABLE_Msk;
	sw_switch(1, phy_rx, flags_rx, phy_tx, flags_tx);
 1011ed0:	2001      	movs	r0, #1
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
 1011ed2:	bc10      	pop	{r4}
	sw_switch(1, phy_rx, flags_rx, phy_tx, flags_tx);
 1011ed4:	f7ff bd96 	b.w	1011a04 <sw_switch.isra.0>
 1011ed8:	41008000 	.word	0x41008000

01011edc <radio_switch_complete_and_disable>:

void radio_switch_complete_and_disable(void)
{
 1011edc:	b410      	push	{r4}
	HAL_SW_SWITCH_TIMER_CLEAR_PPI_REGISTER_TASK = 0;
 1011ede:	2300      	movs	r3, #0
	NRF_RADIO->SHORTS =
 1011ee0:	2403      	movs	r4, #3
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(0) = 0;
 1011ee2:	4a06      	ldr	r2, [pc, #24]	; (1011efc <radio_switch_complete_and_disable+0x20>)
 1011ee4:	4806      	ldr	r0, [pc, #24]	; (1011f00 <radio_switch_complete_and_disable+0x24>)
	HAL_SW_SWITCH_TIMER_CLEAR_PPI_REGISTER_TASK = 0;
 1011ee6:	4907      	ldr	r1, [pc, #28]	; (1011f04 <radio_switch_complete_and_disable+0x28>)
 1011ee8:	f8c0 4200 	str.w	r4, [r0, #512]	; 0x200
 1011eec:	f8c1 308c 	str.w	r3, [r1, #140]	; 0x8c
	    (RADIO_SHORTS_READY_START_Msk | RADIO_SHORTS_END_DISABLE_Msk);

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	hal_radio_sw_switch_disable();
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
 1011ef0:	bc10      	pop	{r4}
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(0) = 0;
 1011ef2:	f8c2 3080 	str.w	r3, [r2, #128]	; 0x80
	HAL_SW_SWITCH_GROUP_TASK_ENABLE_PPI_REGISTER_TASK(1) = 0;
 1011ef6:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
 1011efa:	4770      	bx	lr
 1011efc:	4100f000 	.word	0x4100f000
 1011f00:	41008000 	.word	0x41008000
 1011f04:	41018000 	.word	0x41018000

01011f08 <radio_rssi_measure>:

void radio_rssi_measure(void)
{
	NRF_RADIO->SHORTS |=
 1011f08:	4a03      	ldr	r2, [pc, #12]	; (1011f18 <radio_rssi_measure+0x10>)
 1011f0a:	f8d2 3200 	ldr.w	r3, [r2, #512]	; 0x200
 1011f0e:	f443 7388 	orr.w	r3, r3, #272	; 0x110
 1011f12:	f8c2 3200 	str.w	r3, [r2, #512]	; 0x200
	    (RADIO_SHORTS_ADDRESS_RSSISTART_Msk |
	     RADIO_SHORTS_DISABLED_RSSISTOP_Msk);
}
 1011f16:	4770      	bx	lr
 1011f18:	41008000 	.word	0x41008000

01011f1c <radio_rssi_get>:

u32_t radio_rssi_get(void)
{
	return NRF_RADIO->RSSISAMPLE;
 1011f1c:	4b01      	ldr	r3, [pc, #4]	; (1011f24 <radio_rssi_get+0x8>)
 1011f1e:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
}
 1011f22:	4770      	bx	lr
 1011f24:	41008000 	.word	0x41008000

01011f28 <radio_rssi_status_reset>:

void radio_rssi_status_reset(void)
{
	NRF_RADIO->EVENTS_RSSIEND = 0;
 1011f28:	2200      	movs	r2, #0
 1011f2a:	4b02      	ldr	r3, [pc, #8]	; (1011f34 <radio_rssi_status_reset+0xc>)
 1011f2c:	f8c3 211c 	str.w	r2, [r3, #284]	; 0x11c
}
 1011f30:	4770      	bx	lr
 1011f32:	bf00      	nop
 1011f34:	41008000 	.word	0x41008000

01011f38 <radio_rssi_is_ready>:

u32_t radio_rssi_is_ready(void)
{
	return (NRF_RADIO->EVENTS_RSSIEND != 0);
 1011f38:	4b03      	ldr	r3, [pc, #12]	; (1011f48 <radio_rssi_is_ready+0x10>)
 1011f3a:	f8d3 011c 	ldr.w	r0, [r3, #284]	; 0x11c
}
 1011f3e:	3800      	subs	r0, #0
 1011f40:	bf18      	it	ne
 1011f42:	2001      	movne	r0, #1
 1011f44:	4770      	bx	lr
 1011f46:	bf00      	nop
 1011f48:	41008000 	.word	0x41008000

01011f4c <radio_filter_configure>:

void radio_filter_configure(u8_t bitmask_enable, u8_t bitmask_addr_type,
			    u8_t *bdaddr)
{
 1011f4c:	b430      	push	{r4, r5}
 1011f4e:	2400      	movs	r4, #0
	u8_t index;

	for (index = 0U; index < 8; index++) {
		NRF_RADIO->DAB[index] = ((u32_t)bdaddr[3] << 24) |
 1011f50:	00a3      	lsls	r3, r4, #2
			((u32_t)bdaddr[2] << 16) |
			((u32_t)bdaddr[1] << 8) |
 1011f52:	6815      	ldr	r5, [r2, #0]
 1011f54:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
 1011f58:	f503 4300 	add.w	r3, r3, #32768	; 0x8000
		NRF_RADIO->DAB[index] = ((u32_t)bdaddr[3] << 24) |
 1011f5c:	f8c3 5600 	str.w	r5, [r3, #1536]	; 0x600
			bdaddr[0];
		NRF_RADIO->DAP[index] = ((u32_t)bdaddr[5] << 8) | bdaddr[4];
 1011f60:	8895      	ldrh	r5, [r2, #4]
 1011f62:	3401      	adds	r4, #1
	for (index = 0U; index < 8; index++) {
 1011f64:	2c08      	cmp	r4, #8
		NRF_RADIO->DAP[index] = ((u32_t)bdaddr[5] << 8) | bdaddr[4];
 1011f66:	f8c3 5620 	str.w	r5, [r3, #1568]	; 0x620
		bdaddr += 6;
 1011f6a:	f102 0206 	add.w	r2, r2, #6
	for (index = 0U; index < 8; index++) {
 1011f6e:	d1ef      	bne.n	1011f50 <radio_filter_configure+0x4>
	}

	NRF_RADIO->DACNF = ((u32_t)bitmask_addr_type << 8) | bitmask_enable;
}
 1011f70:	bc30      	pop	{r4, r5}
	NRF_RADIO->DACNF = ((u32_t)bitmask_addr_type << 8) | bitmask_enable;
 1011f72:	4b03      	ldr	r3, [pc, #12]	; (1011f80 <radio_filter_configure+0x34>)
 1011f74:	ea40 2001 	orr.w	r0, r0, r1, lsl #8
 1011f78:	f8c3 0640 	str.w	r0, [r3, #1600]	; 0x640
}
 1011f7c:	4770      	bx	lr
 1011f7e:	bf00      	nop
 1011f80:	41008000 	.word	0x41008000

01011f84 <radio_filter_disable>:

void radio_filter_disable(void)
{
	NRF_RADIO->DACNF &= ~(0x000000FF);
 1011f84:	4a03      	ldr	r2, [pc, #12]	; (1011f94 <radio_filter_disable+0x10>)
 1011f86:	f8d2 3640 	ldr.w	r3, [r2, #1600]	; 0x640
 1011f8a:	f023 03ff 	bic.w	r3, r3, #255	; 0xff
 1011f8e:	f8c2 3640 	str.w	r3, [r2, #1600]	; 0x640
}
 1011f92:	4770      	bx	lr
 1011f94:	41008000 	.word	0x41008000

01011f98 <radio_filter_status_reset>:

void radio_filter_status_reset(void)
{
	NRF_RADIO->EVENTS_DEVMATCH = 0;
 1011f98:	2200      	movs	r2, #0
 1011f9a:	4b02      	ldr	r3, [pc, #8]	; (1011fa4 <radio_filter_status_reset+0xc>)
 1011f9c:	f8c3 2114 	str.w	r2, [r3, #276]	; 0x114
}
 1011fa0:	4770      	bx	lr
 1011fa2:	bf00      	nop
 1011fa4:	41008000 	.word	0x41008000

01011fa8 <radio_filter_has_match>:

u32_t radio_filter_has_match(void)
{
	return (NRF_RADIO->EVENTS_DEVMATCH != 0);
 1011fa8:	4b03      	ldr	r3, [pc, #12]	; (1011fb8 <radio_filter_has_match+0x10>)
 1011faa:	f8d3 0114 	ldr.w	r0, [r3, #276]	; 0x114
}
 1011fae:	3800      	subs	r0, #0
 1011fb0:	bf18      	it	ne
 1011fb2:	2001      	movne	r0, #1
 1011fb4:	4770      	bx	lr
 1011fb6:	bf00      	nop
 1011fb8:	41008000 	.word	0x41008000

01011fbc <radio_filter_match_get>:

u32_t radio_filter_match_get(void)
{
	return NRF_RADIO->DAI;
 1011fbc:	4b01      	ldr	r3, [pc, #4]	; (1011fc4 <radio_filter_match_get+0x8>)
 1011fbe:	f8d3 0410 	ldr.w	r0, [r3, #1040]	; 0x410
}
 1011fc2:	4770      	bx	lr
 1011fc4:	41008000 	.word	0x41008000

01011fc8 <radio_tmr_status_reset>:
}

NRF_STATIC_INLINE void nrf_rtc_event_disable(NRF_RTC_Type * p_reg, uint32_t mask)
{
    p_reg->EVTENCLR = mask;
 1011fc8:	f44f 2080 	mov.w	r0, #262144	; 0x40000
    p_reg->CHENCLR = mask;
 1011fcc:	f242 023f 	movw	r2, #8255	; 0x203f
 1011fd0:	4903      	ldr	r1, [pc, #12]	; (1011fe0 <radio_tmr_status_reset+0x18>)
 1011fd2:	4b04      	ldr	r3, [pc, #16]	; (1011fe4 <radio_tmr_status_reset+0x1c>)
 1011fd4:	f8c1 0348 	str.w	r0, [r1, #840]	; 0x348
 1011fd8:	f8c3 2508 	str.w	r2, [r3, #1288]	; 0x508
			BIT(HAL_SW_SWITCH_TIMER_S8_DISABLE_PPI) |
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
#endif /* CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* CONFIG_BT_CTLR_PHY_CODED */
			BIT(HAL_TRIGGER_CRYPT_PPI));
}
 1011fdc:	4770      	bx	lr
 1011fde:	bf00      	nop
 1011fe0:	41011000 	.word	0x41011000
 1011fe4:	4100f000 	.word	0x4100f000

01011fe8 <radio_tmr_tifs_set>:
void radio_tmr_tifs_set(u32_t tifs)
{
#if defined(CONFIG_BT_CTLR_TIFS_HW)
	NRF_RADIO->TIFS = tifs;
#else /* !CONFIG_BT_CTLR_TIFS_HW */
	nrf_timer_cc_set(SW_SWITCH_TIMER,
 1011fe8:	4b03      	ldr	r3, [pc, #12]	; (1011ff8 <radio_tmr_tifs_set+0x10>)
    p_reg->CC[cc_channel] = cc_value;
 1011fea:	4a04      	ldr	r2, [pc, #16]	; (1011ffc <radio_tmr_tifs_set+0x14>)
 1011fec:	781b      	ldrb	r3, [r3, #0]
 1011fee:	f503 73a8 	add.w	r3, r3, #336	; 0x150
 1011ff2:	f842 0023 	str.w	r0, [r2, r3, lsl #2]
			 SW_SWITCH_TIMER_EVTS_COMP(sw_tifs_toggle), tifs);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
 1011ff6:	4770      	bx	lr
 1011ff8:	210066fa 	.word	0x210066fa
 1011ffc:	41018000 	.word	0x41018000

01012000 <radio_tmr_start>:

u32_t radio_tmr_start(u8_t trx, u32_t ticks_start, u32_t remainder)
{
 1012000:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	if ((!(remainder / 1000000UL)) || (remainder & 0x80000000)) {
 1012004:	f5a2 2374 	sub.w	r3, r2, #999424	; 0xf4000
 1012008:	4d2c      	ldr	r5, [pc, #176]	; (10120bc <radio_tmr_start+0xbc>)
 101200a:	f5a3 7310 	sub.w	r3, r3, #576	; 0x240
 101200e:	42ab      	cmp	r3, r5
{
 1012010:	4604      	mov	r4, r0
	if ((!(remainder / 1000000UL)) || (remainder & 0x80000000)) {
 1012012:	d906      	bls.n	1012022 <radio_tmr_start+0x22>
		ticks_start--;
		remainder += 30517578UL;
 1012014:	f102 72e8 	add.w	r2, r2, #30408704	; 0x1d00000
 1012018:	f502 32d4 	add.w	r2, r2, #108544	; 0x1a800
 101201c:	f502 72a5 	add.w	r2, r2, #330	; 0x14a
		ticks_start--;
 1012020:	3901      	subs	r1, #1
	remainder /= 1000000UL;

	nrf_timer_task_trigger(EVENT_TIMER, NRF_TIMER_TASK_CLEAR);
	EVENT_TIMER->MODE = 0;
	EVENT_TIMER->PRESCALER = 4;
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
 1012022:	2602      	movs	r6, #2
    p_reg->EVTENSET = mask;
 1012024:	f44f 2780 	mov.w	r7, #262144	; 0x40000
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1012028:	f04f 0801 	mov.w	r8, #1
	EVENT_TIMER->MODE = 0;
 101202c:	f04f 0e00 	mov.w	lr, #0
	EVENT_TIMER->PRESCALER = 4;
 1012030:	f04f 0c04 	mov.w	ip, #4
	HAL_RADIO_ENABLE_ON_TICK_PPI_REGISTER_EVT =
 1012034:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
	remainder /= 1000000UL;
 1012038:	4821      	ldr	r0, [pc, #132]	; (10120c0 <radio_tmr_start+0xc0>)
 101203a:	4b22      	ldr	r3, [pc, #136]	; (10120c4 <radio_tmr_start+0xc4>)
 101203c:	fba0 0202 	umull	r0, r2, r0, r2
 1012040:	0c90      	lsrs	r0, r2, #18
    p_reg->CC[ch] = cc_val;
 1012042:	4a21      	ldr	r2, [pc, #132]	; (10120c8 <radio_tmr_start+0xc8>)
 1012044:	f8c3 8000 	str.w	r8, [r3]
	EVENT_TIMER->MODE = 0;
 1012048:	f8c3 e4f8 	str.w	lr, [r3, #1272]	; 0x4f8
	EVENT_TIMER->PRESCALER = 4;
 101204c:	f8c3 c504 	str.w	ip, [r3, #1284]	; 0x504
	EVENT_TIMER->BITMODE = 2;	/* 24 - bit */
 1012050:	f8c3 64fc 	str.w	r6, [r3, #1276]	; 0x4fc
    p_reg->CC[cc_channel] = cc_value;
 1012054:	f8c3 0534 	str.w	r0, [r3, #1332]	; 0x534
 1012058:	f8c2 1548 	str.w	r1, [r2, #1352]	; 0x548
    p_reg->EVTENSET = mask;
 101205c:	f8c2 7344 	str.w	r7, [r2, #836]	; 0x344
	HAL_EVENT_TIMER_START_PPI_REGISTER_EVT =
 1012060:	491a      	ldr	r1, [pc, #104]	; (10120cc <radio_tmr_start+0xcc>)
    p_reg->CHENSET = mask;
 1012062:	4f1b      	ldr	r7, [pc, #108]	; (10120d0 <radio_tmr_start+0xd0>)
 1012064:	f8c2 11c8 	str.w	r1, [r2, #456]	; 0x1c8
	EVENT_TIMER->MODE = 0;
 1012068:	3b0c      	subs	r3, #12
	HAL_EVENT_TIMER_START_PPI_REGISTER_TASK =
 101206a:	f8c3 1080 	str.w	r1, [r3, #128]	; 0x80
 101206e:	f8c7 6504 	str.w	r6, [r7, #1284]	; 0x504
	HAL_RADIO_ENABLE_ON_TICK_PPI_REGISTER_EVT =
 1012072:	f8c3 51c0 	str.w	r5, [r3, #448]	; 0x1c0
	if (trx) {
 1012076:	b1e4      	cbz	r4, 10120b2 <radio_tmr_start+0xb2>
		HAL_RADIO_ENABLE_ON_TICK_PPI_REGISTER_TASK_TX =
 1012078:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
 101207c:	f8c3 5080 	str.w	r5, [r3, #128]	; 0x80
 1012080:	2201      	movs	r2, #1
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	last_pdu_end_us = 0U;

#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_CLEAR);
	SW_SWITCH_TIMER->MODE = 0;
 1012082:	2400      	movs	r4, #0
	SW_SWITCH_TIMER->PRESCALER = 4;
 1012084:	2604      	movs	r6, #4
 1012086:	4b12      	ldr	r3, [pc, #72]	; (10120d0 <radio_tmr_start+0xd0>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1012088:	4912      	ldr	r1, [pc, #72]	; (10120d4 <radio_tmr_start+0xd4>)
 101208a:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
	HAL_SW_SWITCH_TIMER_CLEAR_PPI_REGISTER_EVT =
 101208e:	4d12      	ldr	r5, [pc, #72]	; (10120d8 <radio_tmr_start+0xd8>)
 1012090:	600a      	str	r2, [r1, #0]
 1012092:	4912      	ldr	r1, [pc, #72]	; (10120dc <radio_tmr_start+0xdc>)
	SW_SWITCH_TIMER->MODE = 0;
 1012094:	f503 4310 	add.w	r3, r3, #36864	; 0x9000
 1012098:	f8c3 4504 	str.w	r4, [r3, #1284]	; 0x504
	SW_SWITCH_TIMER->PRESCALER = 4;
 101209c:	f8c3 6510 	str.w	r6, [r3, #1296]	; 0x510
	SW_SWITCH_TIMER->BITMODE = 0; /* 16 bit */
 10120a0:	f8c3 4508 	str.w	r4, [r3, #1288]	; 0x508
 10120a4:	601a      	str	r2, [r3, #0]
 10120a6:	f8c5 118c 	str.w	r1, [r5, #396]	; 0x18c
	HAL_SW_SWITCH_TIMER_CLEAR_PPI_REGISTER_TASK =
 10120aa:	f8c3 108c 	str.w	r1, [r3, #140]	; 0x8c
	 */
#endif /* CONFIG_BT_CTLR_PHY_CODED && CONFIG_HAS_HW_NRF_RADIO_BLE_CODED */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	return remainder;
}
 10120ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		HAL_RADIO_ENABLE_ON_TICK_PPI_REGISTER_TASK_RX =
 10120b2:	4b09      	ldr	r3, [pc, #36]	; (10120d8 <radio_tmr_start+0xd8>)
 10120b4:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
 10120b8:	e7e2      	b.n	1012080 <radio_tmr_start+0x80>
 10120ba:	bf00      	nop
 10120bc:	7ff0bdbf 	.word	0x7ff0bdbf
 10120c0:	431bde83 	.word	0x431bde83
 10120c4:	4100c00c 	.word	0x4100c00c
 10120c8:	41011000 	.word	0x41011000
 10120cc:	80000001 	.word	0x80000001
 10120d0:	4100f000 	.word	0x4100f000
 10120d4:	4101800c 	.word	0x4101800c
 10120d8:	41008000 	.word	0x41008000
 10120dc:	80000005 	.word	0x80000005

010120e0 <radio_tmr_start_tick>:

u32_t radio_tmr_start_tick(u8_t trx, u32_t tick)
{
 10120e0:	b4f0      	push	{r4, r5, r6, r7}
 10120e2:	2401      	movs	r4, #1
 10120e4:	f44f 2780 	mov.w	r7, #262144	; 0x40000
 10120e8:	2602      	movs	r6, #2
	HAL_RADIO_ENABLE_ON_TICK_PPI_REGISTER_EVT =
 10120ea:	f04f 4500 	mov.w	r5, #2147483648	; 0x80000000
 10120ee:	4a12      	ldr	r2, [pc, #72]	; (1012138 <radio_tmr_start_tick+0x58>)
 10120f0:	4b12      	ldr	r3, [pc, #72]	; (101213c <radio_tmr_start_tick+0x5c>)
 10120f2:	6014      	str	r4, [r2, #0]
    p_reg->CC[ch] = cc_val;
 10120f4:	4a12      	ldr	r2, [pc, #72]	; (1012140 <radio_tmr_start_tick+0x60>)
 10120f6:	601c      	str	r4, [r3, #0]
    p_reg->CC[cc_channel] = cc_value;
 10120f8:	f8c3 4534 	str.w	r4, [r3, #1332]	; 0x534
 10120fc:	f8c2 1548 	str.w	r1, [r2, #1352]	; 0x548
 1012100:	4c10      	ldr	r4, [pc, #64]	; (1012144 <radio_tmr_start_tick+0x64>)
	HAL_EVENT_TIMER_START_PPI_REGISTER_EVT =
 1012102:	4911      	ldr	r1, [pc, #68]	; (1012148 <radio_tmr_start_tick+0x68>)
    p_reg->EVTENSET = mask;
 1012104:	f8c2 7344 	str.w	r7, [r2, #836]	; 0x344
 1012108:	f8c2 11c8 	str.w	r1, [r2, #456]	; 0x1c8
	HAL_EVENT_TIMER_START_PPI_REGISTER_TASK =
 101210c:	6759      	str	r1, [r3, #116]	; 0x74
 101210e:	f8c4 6504 	str.w	r6, [r4, #1284]	; 0x504
	HAL_RADIO_ENABLE_ON_TICK_PPI_REGISTER_EVT =
 1012112:	f8c3 51b4 	str.w	r5, [r3, #436]	; 0x1b4
	if (trx) {
 1012116:	b150      	cbz	r0, 101212e <radio_tmr_start_tick+0x4e>
 1012118:	3b0c      	subs	r3, #12
		HAL_RADIO_ENABLE_ON_TICK_PPI_REGISTER_TASK_TX =
 101211a:	f5a3 4380 	sub.w	r3, r3, #16384	; 0x4000
 101211e:	f8c3 5080 	str.w	r5, [r3, #128]	; 0x80
 1012122:	2001      	movs	r0, #1
	last_pdu_end_us = 0U;
#endif /* CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
#endif /* !CONFIG_BT_CTLR_TIFS_HW */

	return remainder_us;
}
 1012124:	bcf0      	pop	{r4, r5, r6, r7}
 1012126:	4b07      	ldr	r3, [pc, #28]	; (1012144 <radio_tmr_start_tick+0x64>)
 1012128:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
 101212c:	4770      	bx	lr
		HAL_RADIO_ENABLE_ON_TICK_PPI_REGISTER_TASK_RX =
 101212e:	4b07      	ldr	r3, [pc, #28]	; (101214c <radio_tmr_start_tick+0x6c>)
 1012130:	f8c3 5084 	str.w	r5, [r3, #132]	; 0x84
 1012134:	e7f5      	b.n	1012122 <radio_tmr_start_tick+0x42>
 1012136:	bf00      	nop
 1012138:	4100c004 	.word	0x4100c004
 101213c:	4100c00c 	.word	0x4100c00c
 1012140:	41011000 	.word	0x41011000
 1012144:	4100f000 	.word	0x4100f000
 1012148:	80000001 	.word	0x80000001
 101214c:	41008000 	.word	0x41008000

01012150 <radio_tmr_start_get>:
    return p_reg->CC[ch];
 1012150:	4b01      	ldr	r3, [pc, #4]	; (1012158 <radio_tmr_start_get+0x8>)
 1012152:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
}

u32_t radio_tmr_start_get(void)
{
	return nrf_rtc_cc_get(NRF_RTC0, 2);
}
 1012156:	4770      	bx	lr
 1012158:	41011000 	.word	0x41011000

0101215c <radio_tmr_stop>:
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 101215c:	2301      	movs	r3, #1

void radio_tmr_stop(void)
{
 101215e:	b410      	push	{r4}
 1012160:	4804      	ldr	r0, [pc, #16]	; (1012174 <radio_tmr_stop+0x18>)
 1012162:	4c05      	ldr	r4, [pc, #20]	; (1012178 <radio_tmr_stop+0x1c>)
 1012164:	4905      	ldr	r1, [pc, #20]	; (101217c <radio_tmr_stop+0x20>)
 1012166:	4a06      	ldr	r2, [pc, #24]	; (1012180 <radio_tmr_stop+0x24>)
 1012168:	6023      	str	r3, [r4, #0]
 101216a:	6003      	str	r3, [r0, #0]

#if !defined(CONFIG_BT_CTLR_TIFS_HW)
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_STOP);
	nrf_timer_task_trigger(SW_SWITCH_TIMER, NRF_TIMER_TASK_SHUTDOWN);
#endif /* !CONFIG_BT_CTLR_TIFS_HW */
}
 101216c:	bc10      	pop	{r4}
 101216e:	600b      	str	r3, [r1, #0]
 1012170:	6013      	str	r3, [r2, #0]
 1012172:	4770      	bx	lr
 1012174:	4100c010 	.word	0x4100c010
 1012178:	4100c004 	.word	0x4100c004
 101217c:	41018004 	.word	0x41018004
 1012180:	41018010 	.word	0x41018010

01012184 <radio_tmr_hcto_configure>:

void radio_tmr_hcto_configure(u32_t hcto)
{
 1012184:	b430      	push	{r4, r5}
 1012186:	2518      	movs	r5, #24
    p_reg->CC[cc_channel] = cc_value;
 1012188:	4b09      	ldr	r3, [pc, #36]	; (10121b0 <radio_tmr_hcto_configure+0x2c>)
	HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI_REGISTER_EVT =
 101218a:	4c0a      	ldr	r4, [pc, #40]	; (10121b4 <radio_tmr_hcto_configure+0x30>)
 101218c:	f8c3 0544 	str.w	r0, [r3, #1348]	; 0x544
 1012190:	4a09      	ldr	r2, [pc, #36]	; (10121b8 <radio_tmr_hcto_configure+0x34>)
	HAL_RADIO_DISABLE_ON_HCTO_PPI_REGISTER_EVT =
 1012192:	490a      	ldr	r1, [pc, #40]	; (10121bc <radio_tmr_hcto_configure+0x38>)
 1012194:	480a      	ldr	r0, [pc, #40]	; (10121c0 <radio_tmr_hcto_configure+0x3c>)
	HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI_REGISTER_EVT =
 1012196:	f8c2 4184 	str.w	r4, [r2, #388]	; 0x184
	HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI_REGISTER_TASK =
 101219a:	f8c3 40c4 	str.w	r4, [r3, #196]	; 0xc4
	HAL_RADIO_DISABLE_ON_HCTO_PPI_REGISTER_EVT =
 101219e:	f8c3 11c4 	str.w	r1, [r3, #452]	; 0x1c4
	HAL_RADIO_DISABLE_ON_HCTO_PPI_REGISTER_TASK =
 10121a2:	f8c2 1090 	str.w	r1, [r2, #144]	; 0x90
 10121a6:	f8c0 5504 	str.w	r5, [r0, #1284]	; 0x504
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_disable_on_hcto_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI) |
		BIT(HAL_RADIO_DISABLE_ON_HCTO_PPI));
}
 10121aa:	bc30      	pop	{r4, r5}
 10121ac:	4770      	bx	lr
 10121ae:	bf00      	nop
 10121b0:	4100c000 	.word	0x4100c000
 10121b4:	80000003 	.word	0x80000003
 10121b8:	41008000 	.word	0x41008000
 10121bc:	80000004 	.word	0x80000004
 10121c0:	4100f000 	.word	0x4100f000

010121c4 <radio_tmr_aa_capture>:

void radio_tmr_aa_capture(void)
{
 10121c4:	b430      	push	{r4, r5}
 10121c6:	250c      	movs	r5, #12
	HAL_RADIO_READY_TIME_CAPTURE_PPI_REGISTER_EVT =
 10121c8:	4908      	ldr	r1, [pc, #32]	; (10121ec <radio_tmr_aa_capture+0x28>)
 10121ca:	4809      	ldr	r0, [pc, #36]	; (10121f0 <radio_tmr_aa_capture+0x2c>)
	HAL_RADIO_READY_TIME_CAPTURE_PPI_REGISTER_TASK =
 10121cc:	4b09      	ldr	r3, [pc, #36]	; (10121f4 <radio_tmr_aa_capture+0x30>)
	HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI_REGISTER_EVT =
 10121ce:	4a0a      	ldr	r2, [pc, #40]	; (10121f8 <radio_tmr_aa_capture+0x34>)
 10121d0:	4c0a      	ldr	r4, [pc, #40]	; (10121fc <radio_tmr_aa_capture+0x38>)
	HAL_RADIO_READY_TIME_CAPTURE_PPI_REGISTER_EVT =
 10121d2:	f8c1 0180 	str.w	r0, [r1, #384]	; 0x180
	HAL_RADIO_READY_TIME_CAPTURE_PPI_REGISTER_TASK =
 10121d6:	f8c3 00c0 	str.w	r0, [r3, #192]	; 0xc0
	HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI_REGISTER_EVT =
 10121da:	f8c1 2184 	str.w	r2, [r1, #388]	; 0x184
	HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI_REGISTER_TASK =
 10121de:	f8c3 20c4 	str.w	r2, [r3, #196]	; 0xc4
 10121e2:	f8c4 5504 	str.w	r5, [r4, #1284]	; 0x504
	hal_radio_ready_time_capture_ppi_config();
	hal_radio_recv_timeout_cancel_ppi_config();
	hal_radio_nrf_ppi_channels_enable(
		BIT(HAL_RADIO_READY_TIME_CAPTURE_PPI) |
		BIT(HAL_RADIO_RECV_TIMEOUT_CANCEL_PPI));
}
 10121e6:	bc30      	pop	{r4, r5}
 10121e8:	4770      	bx	lr
 10121ea:	bf00      	nop
 10121ec:	41008000 	.word	0x41008000
 10121f0:	80000002 	.word	0x80000002
 10121f4:	4100c000 	.word	0x4100c000
 10121f8:	80000003 	.word	0x80000003
 10121fc:	4100f000 	.word	0x4100f000

01012200 <radio_tmr_aa_get>:

u32_t radio_tmr_aa_get(void)
{
	return EVENT_TIMER->CC[1];
 1012200:	4b01      	ldr	r3, [pc, #4]	; (1012208 <radio_tmr_aa_get+0x8>)
 1012202:	f8d3 0544 	ldr.w	r0, [r3, #1348]	; 0x544
}
 1012206:	4770      	bx	lr
 1012208:	4100c000 	.word	0x4100c000

0101220c <radio_tmr_aa_save>:

static u32_t radio_tmr_aa;

void radio_tmr_aa_save(u32_t aa)
{
	radio_tmr_aa = aa;
 101220c:	4b01      	ldr	r3, [pc, #4]	; (1012214 <radio_tmr_aa_save+0x8>)
 101220e:	6018      	str	r0, [r3, #0]
}
 1012210:	4770      	bx	lr
 1012212:	bf00      	nop
 1012214:	21003eec 	.word	0x21003eec

01012218 <radio_tmr_aa_restore>:

u32_t radio_tmr_aa_restore(void)
{
	/* NOTE: we dont need to restore for now, but return the saved value. */
	return radio_tmr_aa;
 1012218:	4b01      	ldr	r3, [pc, #4]	; (1012220 <radio_tmr_aa_restore+0x8>)
}
 101221a:	6818      	ldr	r0, [r3, #0]
 101221c:	4770      	bx	lr
 101221e:	bf00      	nop
 1012220:	21003eec 	.word	0x21003eec

01012224 <radio_tmr_ready_get>:

u32_t radio_tmr_ready_get(void)
{
	return EVENT_TIMER->CC[0];
 1012224:	4b01      	ldr	r3, [pc, #4]	; (101222c <radio_tmr_ready_get+0x8>)
 1012226:	f8d3 0540 	ldr.w	r0, [r3, #1344]	; 0x540
}
 101222a:	4770      	bx	lr
 101222c:	4100c000 	.word	0x4100c000

01012230 <radio_tmr_end_capture>:
 1012230:	2120      	movs	r1, #32

void radio_tmr_end_capture(void)
{
 1012232:	b410      	push	{r4}
	HAL_RADIO_END_TIME_CAPTURE_PPI_REGISTER_EVT =
 1012234:	4b05      	ldr	r3, [pc, #20]	; (101224c <radio_tmr_end_capture+0x1c>)
 1012236:	4c06      	ldr	r4, [pc, #24]	; (1012250 <radio_tmr_end_capture+0x20>)
	HAL_RADIO_END_TIME_CAPTURE_PPI_REGISTER_TASK =
 1012238:	4806      	ldr	r0, [pc, #24]	; (1012254 <radio_tmr_end_capture+0x24>)
 101223a:	4a07      	ldr	r2, [pc, #28]	; (1012258 <radio_tmr_end_capture+0x28>)
	HAL_RADIO_END_TIME_CAPTURE_PPI_REGISTER_EVT =
 101223c:	f8c4 318c 	str.w	r3, [r4, #396]	; 0x18c
	HAL_RADIO_END_TIME_CAPTURE_PPI_REGISTER_TASK =
 1012240:	f8c0 30c8 	str.w	r3, [r0, #200]	; 0xc8
	hal_radio_end_time_capture_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_RADIO_END_TIME_CAPTURE_PPI));
}
 1012244:	bc10      	pop	{r4}
 1012246:	f8c2 1504 	str.w	r1, [r2, #1284]	; 0x504
 101224a:	4770      	bx	lr
 101224c:	80000005 	.word	0x80000005
 1012250:	41008000 	.word	0x41008000
 1012254:	4100c000 	.word	0x4100c000
 1012258:	4100f000 	.word	0x4100f000

0101225c <radio_tmr_end_get>:
u32_t radio_tmr_end_get(void)
{
#if defined(CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER)
	return last_pdu_end_us;
#else /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
	return EVENT_TIMER->CC[2];
 101225c:	4b01      	ldr	r3, [pc, #4]	; (1012264 <radio_tmr_end_get+0x8>)
 101225e:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
#endif /* !CONFIG_BT_CTLR_SW_SWITCH_SINGLE_TIMER */
}
 1012262:	4770      	bx	lr
 1012264:	4100c000 	.word	0x4100c000

01012268 <radio_tmr_tifs_base_get>:
 1012268:	4b01      	ldr	r3, [pc, #4]	; (1012270 <radio_tmr_tifs_base_get+0x8>)
 101226a:	f8d3 0548 	ldr.w	r0, [r3, #1352]	; 0x548
 101226e:	4770      	bx	lr
 1012270:	4100c000 	.word	0x4100c000

01012274 <radio_ccm_rx_pkt_set>:
#endif /* CONFIG_BT_CTLR_GPIO_PA_PIN || CONFIG_BT_CTLR_GPIO_LNA_PIN */

static u8_t MALIGN(4) _ccm_scratch[(HAL_RADIO_PDU_LEN_MAX - 4) + 16];

void *radio_ccm_rx_pkt_set(struct ccm *ccm, u8_t phy, void *pkt)
{
 1012274:	b4f0      	push	{r4, r5, r6, r7}
	u32_t mode;

	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
 1012276:	2402      	movs	r4, #2
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
 1012278:	2500      	movs	r5, #0
 101227a:	4b22      	ldr	r3, [pc, #136]	; (1012304 <radio_ccm_rx_pkt_set+0x90>)
	/* Enable CCM support for 8-bit length field PDUs. */
	mode |= (CCM_MODE_LENGTH_Extended << CCM_MODE_LENGTH_Pos) &
		CCM_MODE_LENGTH_Msk;

	/* Select CCM data rate based on current PHY in use. */
	switch (phy) {
 101227c:	42a1      	cmp	r1, r4
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
 101227e:	f8c3 5500 	str.w	r5, [r3, #1280]	; 0x500
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
 1012282:	f8c3 4500 	str.w	r4, [r3, #1280]	; 0x500
	switch (phy) {
 1012286:	d03a      	beq.n	10122fe <radio_ccm_rx_pkt_set+0x8a>
 1012288:	2904      	cmp	r1, #4
 101228a:	d136      	bne.n	10122fa <radio_ccm_rx_pkt_set+0x86>
	case BIT(2):
		mode |= (CCM_MODE_DATARATE_125Kbps <<
			 CCM_MODE_DATARATE_Pos) &
			CCM_MODE_DATARATE_Msk;

		NRF_CCM->RATEOVERRIDE =
 101228c:	2103      	movs	r1, #3
 101228e:	f44f 5500 	mov.w	r5, #8192	; 0x2000
 1012292:	f8c3 151c 	str.w	r1, [r3, #1308]	; 0x51c
	HAL_TRIGGER_RATEOVERRIDE_PPI_REGISTER_EVT =
 1012296:	4e1c      	ldr	r6, [pc, #112]	; (1012308 <radio_ccm_rx_pkt_set+0x94>)
 1012298:	491c      	ldr	r1, [pc, #112]	; (101230c <radio_ccm_rx_pkt_set+0x98>)
 101229a:	4c1d      	ldr	r4, [pc, #116]	; (1012310 <radio_ccm_rx_pkt_set+0x9c>)
 101229c:	f8c6 11d0 	str.w	r1, [r6, #464]	; 0x1d0
		mode |= (CCM_MODE_DATARATE_125Kbps <<
 10122a0:	4e1c      	ldr	r6, [pc, #112]	; (1012314 <radio_ccm_rx_pkt_set+0xa0>)
	HAL_TRIGGER_RATEOVERRIDE_PPI_REGISTER_TASK =
 10122a2:	f8c3 108c 	str.w	r1, [r3, #140]	; 0x8c
 10122a6:	f8c4 5504 	str.w	r5, [r4, #1284]	; 0x504
	NRF_CCM->MODE = mode;
	NRF_CCM->CNFPTR = (u32_t)ccm;
	NRF_CCM->INPTR = (u32_t)_pkt_scratch;
	NRF_CCM->OUTPTR = (u32_t)pkt;
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
	NRF_CCM->SHORTS = 0;
 10122aa:	2100      	movs	r1, #0
#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ccm_task_trigger(NRF_CCM_Type * p_reg,
                                            nrf_ccm_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 10122ac:	2701      	movs	r7, #1
 10122ae:	f04f 0c08 	mov.w	ip, #8
	u8_t max_len = (NRF_RADIO->PCNF1 & RADIO_PCNF1_MAXLEN_Msk) >>
 10122b2:	4d15      	ldr	r5, [pc, #84]	; (1012308 <radio_ccm_rx_pkt_set+0x94>)
	NRF_CCM->MAXPACKETSIZE = max_len;
 10122b4:	4b13      	ldr	r3, [pc, #76]	; (1012304 <radio_ccm_rx_pkt_set+0x90>)
	u8_t max_len = (NRF_RADIO->PCNF1 & RADIO_PCNF1_MAXLEN_Msk) >>
 10122b6:	f8d5 4518 	ldr.w	r4, [r5, #1304]	; 0x518
	NRF_CCM->MAXPACKETSIZE = max_len;
 10122ba:	b2e4      	uxtb	r4, r4
 10122bc:	f8c3 4518 	str.w	r4, [r3, #1304]	; 0x518
	NRF_CCM->MODE = mode;
 10122c0:	f8c3 6504 	str.w	r6, [r3, #1284]	; 0x504
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
 10122c4:	4c14      	ldr	r4, [pc, #80]	; (1012318 <radio_ccm_rx_pkt_set+0xa4>)
	NRF_CCM->CNFPTR = (u32_t)ccm;
 10122c6:	f8c3 0508 	str.w	r0, [r3, #1288]	; 0x508
	NRF_CCM->INPTR = (u32_t)_pkt_scratch;
 10122ca:	4814      	ldr	r0, [pc, #80]	; (101231c <radio_ccm_rx_pkt_set+0xa8>)
 10122cc:	f8c3 050c 	str.w	r0, [r3, #1292]	; 0x50c
	NRF_CCM->OUTPTR = (u32_t)pkt;
 10122d0:	f8c3 2510 	str.w	r2, [r3, #1296]	; 0x510
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
 10122d4:	f8c3 4514 	str.w	r4, [r3, #1300]	; 0x514
	HAL_TRIGGER_CRYPT_PPI_REGISTER_EVT =
 10122d8:	4a11      	ldr	r2, [pc, #68]	; (1012320 <radio_ccm_rx_pkt_set+0xac>)
 10122da:	4c0d      	ldr	r4, [pc, #52]	; (1012310 <radio_ccm_rx_pkt_set+0x9c>)
	NRF_CCM->SHORTS = 0;
 10122dc:	f8c3 1200 	str.w	r1, [r3, #512]	; 0x200
	NRF_CCM->EVENTS_ENDCRYPT = 0;
 10122e0:	f8c3 1104 	str.w	r1, [r3, #260]	; 0x104
	NRF_CCM->EVENTS_ERROR = 0;
 10122e4:	f8c3 1108 	str.w	r1, [r3, #264]	; 0x108
 10122e8:	f8c5 2184 	str.w	r2, [r5, #388]	; 0x184
	HAL_TRIGGER_CRYPT_PPI_REGISTER_TASK =
 10122ec:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
 10122f0:	f8c4 c504 	str.w	ip, [r4, #1284]	; 0x504
 10122f4:	601f      	str	r7, [r3, #0]
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_TRIGGER_CRYPT_PPI));

	nrf_ccm_task_trigger(NRF_CCM, NRF_CCM_TASK_KSGEN);

	return _pkt_scratch;
}
 10122f6:	bcf0      	pop	{r4, r5, r6, r7}
 10122f8:	4770      	bx	lr
		mode |= (CCM_MODE_DATARATE_1Mbit <<
 10122fa:	4e0a      	ldr	r6, [pc, #40]	; (1012324 <radio_ccm_rx_pkt_set+0xb0>)
 10122fc:	e7d5      	b.n	10122aa <radio_ccm_rx_pkt_set+0x36>
	switch (phy) {
 10122fe:	4e0a      	ldr	r6, [pc, #40]	; (1012328 <radio_ccm_rx_pkt_set+0xb4>)
 1012300:	e7d3      	b.n	10122aa <radio_ccm_rx_pkt_set+0x36>
 1012302:	bf00      	nop
 1012304:	4100e000 	.word	0x4100e000
 1012308:	41008000 	.word	0x41008000
 101230c:	8000000d 	.word	0x8000000d
 1012310:	4100f000 	.word	0x4100f000
 1012314:	01020001 	.word	0x01020001
 1012318:	21003cd0 	.word	0x21003cd0
 101231c:	21003de0 	.word	0x21003de0
 1012320:	80000003 	.word	0x80000003
 1012324:	01000001 	.word	0x01000001
 1012328:	01010001 	.word	0x01010001

0101232c <radio_ccm_tx_pkt_set>:

void *radio_ccm_tx_pkt_set(struct ccm *ccm, void *pkt)
{
 101232c:	b470      	push	{r4, r5, r6}
	u32_t mode;

	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
 101232e:	2200      	movs	r2, #0
{
 1012330:	4604      	mov	r4, r0
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
 1012332:	2602      	movs	r6, #2
	NRF_CCM->MODE = mode;
	NRF_CCM->CNFPTR = (u32_t)ccm;
	NRF_CCM->INPTR = (u32_t)pkt;
	NRF_CCM->OUTPTR = (u32_t)_pkt_scratch;
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
	NRF_CCM->SHORTS = CCM_SHORTS_ENDKSGEN_CRYPT_Msk;
 1012334:	2501      	movs	r5, #1
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
 1012336:	4b0d      	ldr	r3, [pc, #52]	; (101236c <radio_ccm_tx_pkt_set+0x40>)
	NRF_CCM->MODE = mode;
 1012338:	480d      	ldr	r0, [pc, #52]	; (1012370 <radio_ccm_tx_pkt_set+0x44>)
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Disabled;
 101233a:	f8c3 2500 	str.w	r2, [r3, #1280]	; 0x500
	NRF_CCM->ENABLE = CCM_ENABLE_ENABLE_Enabled;
 101233e:	f8c3 6500 	str.w	r6, [r3, #1280]	; 0x500
	NRF_CCM->MODE = mode;
 1012342:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
	NRF_CCM->CNFPTR = (u32_t)ccm;
 1012346:	f8c3 4508 	str.w	r4, [r3, #1288]	; 0x508
	NRF_CCM->OUTPTR = (u32_t)_pkt_scratch;
 101234a:	480a      	ldr	r0, [pc, #40]	; (1012374 <radio_ccm_tx_pkt_set+0x48>)
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
 101234c:	4c0a      	ldr	r4, [pc, #40]	; (1012378 <radio_ccm_tx_pkt_set+0x4c>)
	NRF_CCM->INPTR = (u32_t)pkt;
 101234e:	f8c3 150c 	str.w	r1, [r3, #1292]	; 0x50c
	NRF_CCM->OUTPTR = (u32_t)_pkt_scratch;
 1012352:	f8c3 0510 	str.w	r0, [r3, #1296]	; 0x510
	NRF_CCM->SCRATCHPTR = (u32_t)_ccm_scratch;
 1012356:	f8c3 4514 	str.w	r4, [r3, #1300]	; 0x514
	NRF_CCM->SHORTS = CCM_SHORTS_ENDKSGEN_CRYPT_Msk;
 101235a:	f8c3 5200 	str.w	r5, [r3, #512]	; 0x200
	NRF_CCM->EVENTS_ENDCRYPT = 0;
 101235e:	f8c3 2104 	str.w	r2, [r3, #260]	; 0x104
	NRF_CCM->EVENTS_ERROR = 0;
 1012362:	f8c3 2108 	str.w	r2, [r3, #264]	; 0x108
 1012366:	601d      	str	r5, [r3, #0]

	nrf_ccm_task_trigger(NRF_CCM, NRF_CCM_TASK_KSGEN);

	return _pkt_scratch;
}
 1012368:	bc70      	pop	{r4, r5, r6}
 101236a:	4770      	bx	lr
 101236c:	4100e000 	.word	0x4100e000
 1012370:	01010000 	.word	0x01010000
 1012374:	21003de0 	.word	0x21003de0
 1012378:	21003cd0 	.word	0x21003cd0

0101237c <radio_ccm_is_done>:
    return ((uint32_t)p_reg + (uint32_t)event);
}

NRF_STATIC_INLINE void nrf_ccm_int_enable(NRF_CCM_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
 101237c:	2302      	movs	r3, #2
 101237e:	4a0e      	ldr	r2, [pc, #56]	; (10123b8 <radio_ccm_is_done+0x3c>)
 1012380:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304

u32_t radio_ccm_is_done(void)
{
	nrf_ccm_int_enable(NRF_CCM, CCM_INTENSET_ENDCRYPT_Msk);
	while (NRF_CCM->EVENTS_ENDCRYPT == 0) {
 1012384:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
 1012388:	b933      	cbnz	r3, 1012398 <radio_ccm_is_done+0x1c>
		__WFE();
 101238a:	bf20      	wfe
		__SEV();
 101238c:	bf40      	sev
		__WFE();
 101238e:	bf20      	wfe
	while (NRF_CCM->EVENTS_ENDCRYPT == 0) {
 1012390:	f8d2 3104 	ldr.w	r3, [r2, #260]	; 0x104
 1012394:	2b00      	cmp	r3, #0
 1012396:	d0f8      	beq.n	101238a <radio_ccm_is_done+0xe>
}

NRF_STATIC_INLINE void nrf_ccm_int_disable(NRF_CCM_Type * p_reg, uint32_t mask)
{
    p_reg->INTENCLR = mask;
 1012398:	2002      	movs	r0, #2
 101239a:	f44f 4180 	mov.w	r1, #16384	; 0x4000
 101239e:	4b06      	ldr	r3, [pc, #24]	; (10123b8 <radio_ccm_is_done+0x3c>)
 10123a0:	4a06      	ldr	r2, [pc, #24]	; (10123bc <radio_ccm_is_done+0x40>)
 10123a2:	f8c3 0308 	str.w	r0, [r3, #776]	; 0x308
 10123a6:	f8c2 1180 	str.w	r1, [r2, #384]	; 0x180
	}
	nrf_ccm_int_disable(NRF_CCM, CCM_INTENCLR_ENDCRYPT_Msk);
	NVIC_ClearPendingIRQ(nrfx_get_irq_number(NRF_CCM));

	return (NRF_CCM->EVENTS_ERROR == 0);
 10123aa:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
}
 10123ae:	fab0 f080 	clz	r0, r0
 10123b2:	0940      	lsrs	r0, r0, #5
 10123b4:	4770      	bx	lr
 10123b6:	bf00      	nop
 10123b8:	4100e000 	.word	0x4100e000
 10123bc:	e000e100 	.word	0xe000e100

010123c0 <radio_ccm_mic_is_valid>:

u32_t radio_ccm_mic_is_valid(void)
{
	return (NRF_CCM->MICSTATUS != 0);
 10123c0:	4b03      	ldr	r3, [pc, #12]	; (10123d0 <radio_ccm_mic_is_valid+0x10>)
 10123c2:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
 10123c6:	3800      	subs	r0, #0
 10123c8:	bf18      	it	ne
 10123ca:	2001      	movne	r0, #1
 10123cc:	4770      	bx	lr
 10123ce:	bf00      	nop
 10123d0:	4100e000 	.word	0x4100e000

010123d4 <radio_ar_configure>:

static u8_t MALIGN(4) _aar_scratch[3];

void radio_ar_configure(u32_t nirk, void *irk)
{
 10123d4:	b470      	push	{r4, r5, r6}
	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Enabled << AAR_ENABLE_ENABLE_Pos) &
 10123d6:	2603      	movs	r6, #3
	NRF_AAR->NIRK = nirk;
	NRF_AAR->IRKPTR = (u32_t)irk;
	NRF_AAR->ADDRPTR = (u32_t)NRF_RADIO->PACKETPTR - 1;
	NRF_AAR->SCRATCHPTR = (u32_t)&_aar_scratch[0];

	NRF_AAR->EVENTS_END = 0;
 10123d8:	2400      	movs	r4, #0
    p_reg->BCC = radio_bcc;
 10123da:	2540      	movs	r5, #64	; 0x40
	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Enabled << AAR_ENABLE_ENABLE_Pos) &
 10123dc:	4b14      	ldr	r3, [pc, #80]	; (1012430 <radio_ar_configure+0x5c>)
	NRF_AAR->ADDRPTR = (u32_t)NRF_RADIO->PACKETPTR - 1;
 10123de:	4a15      	ldr	r2, [pc, #84]	; (1012434 <radio_ar_configure+0x60>)
	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Enabled << AAR_ENABLE_ENABLE_Pos) &
 10123e0:	f8c3 6500 	str.w	r6, [r3, #1280]	; 0x500
	NRF_AAR->NIRK = nirk;
 10123e4:	f8c3 0504 	str.w	r0, [r3, #1284]	; 0x504
	NRF_AAR->IRKPTR = (u32_t)irk;
 10123e8:	f8c3 1508 	str.w	r1, [r3, #1288]	; 0x508
	NRF_AAR->ADDRPTR = (u32_t)NRF_RADIO->PACKETPTR - 1;
 10123ec:	f8d2 1504 	ldr.w	r1, [r2, #1284]	; 0x504
	NRF_AAR->SCRATCHPTR = (u32_t)&_aar_scratch[0];
 10123f0:	4811      	ldr	r0, [pc, #68]	; (1012438 <radio_ar_configure+0x64>)
	NRF_AAR->ADDRPTR = (u32_t)NRF_RADIO->PACKETPTR - 1;
 10123f2:	3901      	subs	r1, #1
 10123f4:	f8c3 1510 	str.w	r1, [r3, #1296]	; 0x510
	NRF_AAR->SCRATCHPTR = (u32_t)&_aar_scratch[0];
 10123f8:	f8c3 0514 	str.w	r0, [r3, #1300]	; 0x514
	NRF_AAR->EVENTS_END = 0;
 10123fc:	f8c3 4100 	str.w	r4, [r3, #256]	; 0x100
	NRF_AAR->EVENTS_RESOLVED = 0;
 1012400:	f8c3 4104 	str.w	r4, [r3, #260]	; 0x104
	NRF_AAR->EVENTS_NOTRESOLVED = 0;
 1012404:	f8c3 4108 	str.w	r4, [r3, #264]	; 0x108
 1012408:	f8c2 5560 	str.w	r5, [r2, #1376]	; 0x560
	NRF_RADIO->SHORTS |= RADIO_SHORTS_ADDRESS_BCSTART_Msk;
 101240c:	f8d2 1200 	ldr.w	r1, [r2, #512]	; 0x200
	HAL_TRIGGER_AAR_PPI_REGISTER_EVT =
 1012410:	480a      	ldr	r0, [pc, #40]	; (101243c <radio_ar_configure+0x68>)
 1012412:	4329      	orrs	r1, r5
 1012414:	f8c2 1200 	str.w	r1, [r2, #512]	; 0x200
 1012418:	4909      	ldr	r1, [pc, #36]	; (1012440 <radio_ar_configure+0x6c>)
	NRF_RADIO->EVENTS_BCMATCH = 0;
 101241a:	f8c2 4128 	str.w	r4, [r2, #296]	; 0x128
 101241e:	f8c2 01a8 	str.w	r0, [r2, #424]	; 0x1a8
	HAL_TRIGGER_AAR_PPI_REGISTER_TASK =
 1012422:	f8c3 0080 	str.w	r0, [r3, #128]	; 0x80
 1012426:	f8c1 5504 	str.w	r5, [r1, #1284]	; 0x504
	radio_bc_configure(64);
	radio_bc_status_reset();

	hal_trigger_aar_ppi_config();
	hal_radio_nrf_ppi_channels_enable(BIT(HAL_TRIGGER_AAR_PPI));
}
 101242a:	bc70      	pop	{r4, r5, r6}
 101242c:	4770      	bx	lr
 101242e:	bf00      	nop
 1012430:	4100e000 	.word	0x4100e000
 1012434:	41008000 	.word	0x41008000
 1012438:	21003ccc 	.word	0x21003ccc
 101243c:	80000006 	.word	0x80000006
 1012440:	4100f000 	.word	0x4100f000

01012444 <radio_ar_match_get>:

u32_t radio_ar_match_get(void)
{
	return NRF_AAR->STATUS;
 1012444:	4b01      	ldr	r3, [pc, #4]	; (101244c <radio_ar_match_get+0x8>)
 1012446:	f8d3 0400 	ldr.w	r0, [r3, #1024]	; 0x400
}
 101244a:	4770      	bx	lr
 101244c:	4100e000 	.word	0x4100e000

01012450 <radio_ar_status_reset>:
	NRF_RADIO->EVENTS_BCMATCH = 0;
 1012450:	2300      	movs	r3, #0
 1012452:	4903      	ldr	r1, [pc, #12]	; (1012460 <radio_ar_status_reset+0x10>)

void radio_ar_status_reset(void)
{
	radio_bc_status_reset();

	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Disabled << AAR_ENABLE_ENABLE_Pos) &
 1012454:	4a03      	ldr	r2, [pc, #12]	; (1012464 <radio_ar_status_reset+0x14>)
	NRF_RADIO->EVENTS_BCMATCH = 0;
 1012456:	f8c1 3128 	str.w	r3, [r1, #296]	; 0x128
	NRF_AAR->ENABLE = (AAR_ENABLE_ENABLE_Disabled << AAR_ENABLE_ENABLE_Pos) &
 101245a:	f8c2 3500 	str.w	r3, [r2, #1280]	; 0x500
			  AAR_ENABLE_ENABLE_Msk;
}
 101245e:	4770      	bx	lr
 1012460:	41008000 	.word	0x41008000
 1012464:	4100e000 	.word	0x4100e000

01012468 <radio_ar_has_match>:
	return (NRF_RADIO->EVENTS_BCMATCH != 0);
 1012468:	4b08      	ldr	r3, [pc, #32]	; (101248c <radio_ar_has_match+0x24>)
 101246a:	f8d3 0128 	ldr.w	r0, [r3, #296]	; 0x128

u32_t radio_ar_has_match(void)
{
	return (radio_bc_has_match() &&
		NRF_AAR->EVENTS_END &&
		NRF_AAR->EVENTS_RESOLVED &&
 101246e:	b160      	cbz	r0, 101248a <radio_ar_has_match+0x22>
		NRF_AAR->EVENTS_END &&
 1012470:	f503 43c0 	add.w	r3, r3, #24576	; 0x6000
 1012474:	f8d3 0100 	ldr.w	r0, [r3, #256]	; 0x100
	return (radio_bc_has_match() &&
 1012478:	b138      	cbz	r0, 101248a <radio_ar_has_match+0x22>
		NRF_AAR->EVENTS_RESOLVED &&
 101247a:	f8d3 0104 	ldr.w	r0, [r3, #260]	; 0x104
		NRF_AAR->EVENTS_END &&
 101247e:	b120      	cbz	r0, 101248a <radio_ar_has_match+0x22>
		!NRF_AAR->EVENTS_NOTRESOLVED);
 1012480:	f8d3 0108 	ldr.w	r0, [r3, #264]	; 0x108
		NRF_AAR->EVENTS_RESOLVED &&
 1012484:	fab0 f080 	clz	r0, r0
 1012488:	0940      	lsrs	r0, r0, #5
}
 101248a:	4770      	bx	lr
 101248c:	41008000 	.word	0x41008000

01012490 <mayfly_enable_cb>:

void mayfly_enable_cb(u8_t caller_id, u8_t callee_id, u8_t enable)
{
	(void)caller_id;

	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
 1012490:	2902      	cmp	r1, #2
{
 1012492:	b510      	push	{r4, lr}
 1012494:	4614      	mov	r4, r2
	LL_ASSERT(callee_id == MAYFLY_CALL_ID_JOB);
 1012496:	d003      	beq.n	10124a0 <mayfly_enable_cb+0x10>
 1012498:	2122      	movs	r1, #34	; 0x22
 101249a:	4806      	ldr	r0, [pc, #24]	; (10124b4 <mayfly_enable_cb+0x24>)
 101249c:	f7f1 f874 	bl	1003588 <bt_ctlr_assert_handle>

	if (enable) {
		irq_enable(HAL_SWI_JOB_IRQ);
 10124a0:	2011      	movs	r0, #17
	if (enable) {
 10124a2:	b11c      	cbz	r4, 10124ac <mayfly_enable_cb+0x1c>
	} else {
		irq_disable(HAL_SWI_JOB_IRQ);
	}
}
 10124a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_enable(HAL_SWI_JOB_IRQ);
 10124a8:	f7f2 bc34 	b.w	1004d14 <arch_irq_enable>
}
 10124ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		irq_disable(HAL_SWI_JOB_IRQ);
 10124b0:	f7f2 bc40 	b.w	1004d34 <arch_irq_disable>
 10124b4:	01018c20 	.word	0x01018c20

010124b8 <mayfly_is_enabled>:

u32_t mayfly_is_enabled(u8_t caller_id, u8_t callee_id)
{
	(void)caller_id;

	switch (callee_id) {
 10124b8:	b129      	cbz	r1, 10124c6 <mayfly_is_enabled+0xe>
 10124ba:	3901      	subs	r1, #1
 10124bc:	2901      	cmp	r1, #1
 10124be:	d805      	bhi.n	10124cc <mayfly_is_enabled+0x14>
	case MAYFLY_CALL_ID_LLL:
		return irq_is_enabled(HAL_SWI_RADIO_IRQ);
#endif /* CONFIG_BT_LL_SW_SPLIT */

	case MAYFLY_CALL_ID_WORKER:
		return irq_is_enabled(HAL_SWI_WORKER_IRQ);
 10124c0:	2011      	movs	r0, #17
 10124c2:	f7f2 bc4b 	b.w	1004d5c <arch_irq_is_enabled>
		return irq_is_enabled(HAL_SWI_RADIO_IRQ);
 10124c6:	2014      	movs	r0, #20
 10124c8:	f7f2 bc48 	b.w	1004d5c <arch_irq_is_enabled>
{
 10124cc:	b508      	push	{r3, lr}

	case MAYFLY_CALL_ID_JOB:
		return irq_is_enabled(HAL_SWI_JOB_IRQ);

	default:
		LL_ASSERT(0);
 10124ce:	213c      	movs	r1, #60	; 0x3c
 10124d0:	4802      	ldr	r0, [pc, #8]	; (10124dc <mayfly_is_enabled+0x24>)
 10124d2:	f7f1 f859 	bl	1003588 <bt_ctlr_assert_handle>
		break;
	}

	return 0;
}
 10124d6:	2000      	movs	r0, #0
 10124d8:	bd08      	pop	{r3, pc}
 10124da:	bf00      	nop
 10124dc:	01018c20 	.word	0x01018c20

010124e0 <mayfly_prio_is_equal>:
#endif
#if (CONFIG_BT_CTLR_ULL_HIGH_PRIO == CONFIG_BT_CTLR_ULL_LOW_PRIO)
	       ((caller_id == MAYFLY_CALL_ID_WORKER) &&
		(callee_id == MAYFLY_CALL_ID_JOB)) ||
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
 10124e0:	4288      	cmp	r0, r1
 10124e2:	d013      	beq.n	101250c <mayfly_prio_is_equal+0x2c>
	return (caller_id == callee_id) ||
 10124e4:	b928      	cbnz	r0, 10124f2 <mayfly_prio_is_equal+0x12>
	       ((caller_id == MAYFLY_CALL_ID_LLL) &&
 10124e6:	1e48      	subs	r0, r1, #1
 10124e8:	2801      	cmp	r0, #1
 10124ea:	bf8c      	ite	hi
 10124ec:	2000      	movhi	r0, #0
 10124ee:	2001      	movls	r0, #1
 10124f0:	4770      	bx	lr
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
 10124f2:	2801      	cmp	r0, #1
 10124f4:	d106      	bne.n	1012504 <mayfly_prio_is_equal+0x24>
	       ((caller_id == MAYFLY_CALL_ID_WORKER) &&
 10124f6:	b159      	cbz	r1, 1012510 <mayfly_prio_is_equal+0x30>
	       ((caller_id == MAYFLY_CALL_ID_WORKER) &&
 10124f8:	f1a1 0002 	sub.w	r0, r1, #2
 10124fc:	fab0 f080 	clz	r0, r0
 1012500:	0940      	lsrs	r0, r0, #5
 1012502:	4770      	bx	lr
		(callee_id == MAYFLY_CALL_ID_JOB)) ||
 1012504:	2802      	cmp	r0, #2
 1012506:	d004      	beq.n	1012512 <mayfly_prio_is_equal+0x32>
 1012508:	2000      	movs	r0, #0
		(callee_id == MAYFLY_CALL_ID_WORKER)) ||
 101250a:	4770      	bx	lr
 101250c:	2001      	movs	r0, #1
 101250e:	4770      	bx	lr
#endif
#endif
	       0;
}
 1012510:	4770      	bx	lr
	       ((caller_id == MAYFLY_CALL_ID_JOB) &&
 1012512:	2901      	cmp	r1, #1
 1012514:	bf8c      	ite	hi
 1012516:	2000      	movhi	r0, #0
 1012518:	2001      	movls	r0, #1
 101251a:	4770      	bx	lr

0101251c <mayfly_pend>:

void mayfly_pend(u8_t caller_id, u8_t callee_id)
{
	(void)caller_id;

	switch (callee_id) {
 101251c:	2901      	cmp	r1, #1
 101251e:	d006      	beq.n	101252e <mayfly_pend+0x12>
 1012520:	2902      	cmp	r1, #2
 1012522:	d004      	beq.n	101252e <mayfly_pend+0x12>
 1012524:	b149      	cbz	r1, 101253a <mayfly_pend+0x1e>
	case MAYFLY_CALL_ID_JOB:
		hal_swi_job_pend();
		break;

	default:
		LL_ASSERT(0);
 1012526:	2171      	movs	r1, #113	; 0x71
 1012528:	4807      	ldr	r0, [pc, #28]	; (1012548 <mayfly_pend+0x2c>)
 101252a:	f7f1 b82d 	b.w	1003588 <bt_ctlr_assert_handle>
    NVIC->ISPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 101252e:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 1012532:	4b06      	ldr	r3, [pc, #24]	; (101254c <mayfly_pend+0x30>)
 1012534:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
		break;
	}
}
 1012538:	4770      	bx	lr
 101253a:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 101253e:	4b03      	ldr	r3, [pc, #12]	; (101254c <mayfly_pend+0x30>)
 1012540:	f8c3 2100 	str.w	r2, [r3, #256]	; 0x100
}
 1012544:	4770      	bx	lr
 1012546:	bf00      	nop
 1012548:	01018c20 	.word	0x01018c20
 101254c:	e000e100 	.word	0xe000e100

01012550 <hal_ticker_instance0_caller_id_get>:

u8_t hal_ticker_instance0_caller_id_get(u8_t user_id)
{
	u8_t caller_id;

	LL_ASSERT(user_id < sizeof(caller_id_lut));
 1012550:	2803      	cmp	r0, #3
{
 1012552:	b510      	push	{r4, lr}
 1012554:	4604      	mov	r4, r0
	LL_ASSERT(user_id < sizeof(caller_id_lut));
 1012556:	d804      	bhi.n	1012562 <hal_ticker_instance0_caller_id_get+0x12>

	caller_id = caller_id_lut[user_id];
 1012558:	4b09      	ldr	r3, [pc, #36]	; (1012580 <hal_ticker_instance0_caller_id_get+0x30>)
 101255a:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(caller_id != TICKER_CALL_ID_NONE);
 101255c:	b14c      	cbz	r4, 1012572 <hal_ticker_instance0_caller_id_get+0x22>

	return caller_id;
}
 101255e:	4620      	mov	r0, r4
 1012560:	bd10      	pop	{r4, pc}
	LL_ASSERT(user_id < sizeof(caller_id_lut));
 1012562:	212d      	movs	r1, #45	; 0x2d
 1012564:	4807      	ldr	r0, [pc, #28]	; (1012584 <hal_ticker_instance0_caller_id_get+0x34>)
 1012566:	f7f1 f80f 	bl	1003588 <bt_ctlr_assert_handle>
	caller_id = caller_id_lut[user_id];
 101256a:	4b05      	ldr	r3, [pc, #20]	; (1012580 <hal_ticker_instance0_caller_id_get+0x30>)
 101256c:	5d1c      	ldrb	r4, [r3, r4]
	LL_ASSERT(caller_id != TICKER_CALL_ID_NONE);
 101256e:	2c00      	cmp	r4, #0
 1012570:	d1f5      	bne.n	101255e <hal_ticker_instance0_caller_id_get+0xe>
 1012572:	2130      	movs	r1, #48	; 0x30
 1012574:	4803      	ldr	r0, [pc, #12]	; (1012584 <hal_ticker_instance0_caller_id_get+0x34>)
 1012576:	f7f1 f807 	bl	1003588 <bt_ctlr_assert_handle>
}
 101257a:	4620      	mov	r0, r4
 101257c:	bd10      	pop	{r4, pc}
 101257e:	bf00      	nop
 1012580:	01018ce8 	.word	0x01018ce8
 1012584:	01018c84 	.word	0x01018c84

01012588 <hal_ticker_instance0_sched>:
{
	/* return value not checked as we allow multiple calls to schedule
	 * before being actually needing the work to complete before new
	 * schedule.
	 */
	switch (caller_id) {
 1012588:	3801      	subs	r0, #1
{
 101258a:	b410      	push	{r4}
 101258c:	461c      	mov	r4, r3
 101258e:	2804      	cmp	r0, #4
 1012590:	d853      	bhi.n	101263a <hal_ticker_instance0_sched+0xb2>
 1012592:	e8df f000 	tbb	[pc, r0]
 1012596:	180a      	.short	0x180a
 1012598:	1f11      	.short	0x1f11
 101259a:	03          	.byte	0x03
 101259b:	00          	.byte	0x00
			break;
		}
		break;

	case TICKER_CALL_ID_PROGRAM:
		switch (callee_id) {
 101259c:	2904      	cmp	r1, #4
 101259e:	d022      	beq.n	10125e6 <hal_ticker_instance0_sched+0x5e>
				       &m);
		}
		break;

		default:
			LL_ASSERT(0);
 10125a0:	21be      	movs	r1, #190	; 0xbe
 10125a2:	4828      	ldr	r0, [pc, #160]	; (1012644 <hal_ticker_instance0_sched+0xbc>)

	default:
		LL_ASSERT(0);
		break;
	}
}
 10125a4:	bc10      	pop	{r4}
			LL_ASSERT(0);
 10125a6:	f7f0 bfef 	b.w	1003588 <bt_ctlr_assert_handle>
		switch (callee_id) {
 10125aa:	2904      	cmp	r1, #4
 10125ac:	d029      	beq.n	1012602 <hal_ticker_instance0_sched+0x7a>
			LL_ASSERT(0);
 10125ae:	2151      	movs	r1, #81	; 0x51
 10125b0:	4824      	ldr	r0, [pc, #144]	; (1012644 <hal_ticker_instance0_sched+0xbc>)
}
 10125b2:	bc10      	pop	{r4}
			LL_ASSERT(0);
 10125b4:	f7f0 bfe8 	b.w	1003588 <bt_ctlr_assert_handle>
		switch (callee_id) {
 10125b8:	2904      	cmp	r1, #4
 10125ba:	d01b      	beq.n	10125f4 <hal_ticker_instance0_sched+0x6c>
			LL_ASSERT(0);
 10125bc:	2180      	movs	r1, #128	; 0x80
 10125be:	4821      	ldr	r0, [pc, #132]	; (1012644 <hal_ticker_instance0_sched+0xbc>)
}
 10125c0:	bc10      	pop	{r4}
			LL_ASSERT(0);
 10125c2:	f7f0 bfe1 	b.w	1003588 <bt_ctlr_assert_handle>
		switch (callee_id) {
 10125c6:	2903      	cmp	r1, #3
 10125c8:	d022      	beq.n	1012610 <hal_ticker_instance0_sched+0x88>
			LL_ASSERT(0);
 10125ca:	2169      	movs	r1, #105	; 0x69
 10125cc:	481d      	ldr	r0, [pc, #116]	; (1012644 <hal_ticker_instance0_sched+0xbc>)
}
 10125ce:	bc10      	pop	{r4}
			LL_ASSERT(0);
 10125d0:	f7f0 bfda 	b.w	1003588 <bt_ctlr_assert_handle>
		switch (callee_id) {
 10125d4:	2903      	cmp	r1, #3
 10125d6:	d029      	beq.n	101262c <hal_ticker_instance0_sched+0xa4>
 10125d8:	2904      	cmp	r1, #4
 10125da:	d020      	beq.n	101261e <hal_ticker_instance0_sched+0x96>
			LL_ASSERT(0);
 10125dc:	21a6      	movs	r1, #166	; 0xa6
 10125de:	4819      	ldr	r0, [pc, #100]	; (1012644 <hal_ticker_instance0_sched+0xbc>)
}
 10125e0:	bc10      	pop	{r4}
			LL_ASSERT(0);
 10125e2:	f7f0 bfd1 	b.w	1003588 <bt_ctlr_assert_handle>
			m.param = instance;
 10125e6:	4b18      	ldr	r3, [pc, #96]	; (1012648 <hal_ticker_instance0_sched+0xc0>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
 10125e8:	2102      	movs	r1, #2
			m.param = instance;
 10125ea:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
 10125ec:	2003      	movs	r0, #3
}
 10125ee:	bc10      	pop	{r4}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_PROGRAM,
 10125f0:	f7f3 bbee 	b.w	1005dd0 <mayfly_enqueue>
			m.param = instance;
 10125f4:	4b15      	ldr	r3, [pc, #84]	; (101264c <hal_ticker_instance0_sched+0xc4>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
 10125f6:	2102      	movs	r1, #2
			m.param = instance;
 10125f8:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
 10125fa:	2001      	movs	r0, #1
}
 10125fc:	bc10      	pop	{r4}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_WORKER,
 10125fe:	f7f3 bbe7 	b.w	1005dd0 <mayfly_enqueue>
			m.param = instance;
 1012602:	4b13      	ldr	r3, [pc, #76]	; (1012650 <hal_ticker_instance0_sched+0xc8>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
 1012604:	2102      	movs	r1, #2
			m.param = instance;
 1012606:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
 1012608:	2000      	movs	r0, #0
}
 101260a:	bc10      	pop	{r4}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_ISR,
 101260c:	f7f3 bbe0 	b.w	1005dd0 <mayfly_enqueue>
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_TRIGGER,
 1012610:	2101      	movs	r1, #1
			m.param = instance;
 1012612:	4b10      	ldr	r3, [pc, #64]	; (1012654 <hal_ticker_instance0_sched+0xcc>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_TRIGGER,
 1012614:	4608      	mov	r0, r1
			m.param = instance;
 1012616:	609c      	str	r4, [r3, #8]
}
 1012618:	bc10      	pop	{r4}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_TRIGGER,
 101261a:	f7f3 bbd9 	b.w	1005dd0 <mayfly_enqueue>
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
 101261e:	2102      	movs	r1, #2
			m.param = instance;
 1012620:	4b0d      	ldr	r3, [pc, #52]	; (1012658 <hal_ticker_instance0_sched+0xd0>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
 1012622:	4608      	mov	r0, r1
			m.param = instance;
 1012624:	609c      	str	r4, [r3, #8]
}
 1012626:	bc10      	pop	{r4}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
 1012628:	f7f3 bbd2 	b.w	1005dd0 <mayfly_enqueue>
			m.param = instance;
 101262c:	4b0b      	ldr	r3, [pc, #44]	; (101265c <hal_ticker_instance0_sched+0xd4>)
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
 101262e:	2101      	movs	r1, #1
			m.param = instance;
 1012630:	609c      	str	r4, [r3, #8]
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
 1012632:	2002      	movs	r0, #2
}
 1012634:	bc10      	pop	{r4}
			mayfly_enqueue(TICKER_MAYFLY_CALL_ID_JOB,
 1012636:	f7f3 bbcb 	b.w	1005dd0 <mayfly_enqueue>
		LL_ASSERT(0);
 101263a:	21c4      	movs	r1, #196	; 0xc4
 101263c:	4801      	ldr	r0, [pc, #4]	; (1012644 <hal_ticker_instance0_sched+0xbc>)
}
 101263e:	bc10      	pop	{r4}
		LL_ASSERT(0);
 1012640:	f7f0 bfa2 	b.w	1003588 <bt_ctlr_assert_handle>
 1012644:	01018c84 	.word	0x01018c84
 1012648:	2100044c 	.word	0x2100044c
 101264c:	2100041c 	.word	0x2100041c
 1012650:	210003fc 	.word	0x210003fc
 1012654:	2100040c 	.word	0x2100040c
 1012658:	2100043c 	.word	0x2100043c
 101265c:	2100042c 	.word	0x2100042c

01012660 <hal_ticker_instance0_trigger_set>:

void hal_ticker_instance0_trigger_set(u32_t value)
{
 1012660:	4601      	mov	r1, r0
	cntr_cmp_set(0, value);
 1012662:	2000      	movs	r0, #0
 1012664:	f7ff b97a 	b.w	101195c <cntr_cmp_set>

01012668 <hci_vendor_read_static_addr>:
				 u8_t size)
{
	/* only one supported */
	ARG_UNUSED(size);

	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
 1012668:	4a34      	ldr	r2, [pc, #208]	; (101273c <hci_vendor_read_static_addr+0xd4>)
{
 101266a:	b538      	push	{r3, r4, r5, lr}
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
 101266c:	f8d2 12a4 	ldr.w	r1, [r2, #676]	; 0x2a4
{
 1012670:	4603      	mov	r3, r0
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
 1012672:	3101      	adds	r1, #1
 1012674:	d059      	beq.n	101272a <hci_vendor_read_static_addr+0xc2>
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
	     (NRF_FICR->DEVICEADDRTYPE & 0x01)) {
 1012676:	4a31      	ldr	r2, [pc, #196]	; (101273c <hci_vendor_read_static_addr+0xd4>)
 1012678:	f8d2 02a0 	ldr.w	r0, [r2, #672]	; 0x2a0
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
 101267c:	f010 0001 	ands.w	r0, r0, #1
 1012680:	d100      	bne.n	1012684 <hci_vendor_read_static_addr+0x1c>

		return 1;
	}

	return 0;
}
 1012682:	bd38      	pop	{r3, r4, r5, pc}
		sys_put_le32(NRF_FICR->DEVICEADDR[0], &addrs[0].bdaddr.val[0]);
 1012684:	f8d2 12a4 	ldr.w	r1, [r2, #676]	; 0x2a4
	sys_put_le16(val >> 16, &dst[2]);
 1012688:	0c08      	lsrs	r0, r1, #16
	dst[1] = val >> 8;
 101268a:	0a05      	lsrs	r5, r0, #8
 101268c:	f3c1 2407 	ubfx	r4, r1, #8, #8
	dst[0] = val;
 1012690:	7019      	strb	r1, [r3, #0]
 1012692:	7098      	strb	r0, [r3, #2]
	dst[1] = val >> 8;
 1012694:	70dd      	strb	r5, [r3, #3]
 1012696:	705c      	strb	r4, [r3, #1]
		sys_put_le16(NRF_FICR->DEVICEADDR[1], &addrs[0].bdaddr.val[4]);
 1012698:	f8d2 02a8 	ldr.w	r0, [r2, #680]	; 0x2a8
 101269c:	f3c0 2107 	ubfx	r1, r0, #8, #8
		BT_ADDR_SET_STATIC(&addrs[0].bdaddr);
 10126a0:	f061 013f 	orn	r1, r1, #63	; 0x3f
	dst[0] = val;
 10126a4:	7118      	strb	r0, [r3, #4]
 10126a6:	7159      	strb	r1, [r3, #5]
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
 10126a8:	f8d2 1290 	ldr.w	r1, [r2, #656]	; 0x290
 10126ac:	3101      	adds	r1, #1
 10126ae:	d035      	beq.n	101271c <hci_vendor_read_static_addr+0xb4>
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
 10126b0:	f8d2 1294 	ldr.w	r1, [r2, #660]	; 0x294
		if ((NRF_FICR->IR[0] != UINT32_MAX) &&
 10126b4:	3101      	adds	r1, #1
 10126b6:	d031      	beq.n	101271c <hci_vendor_read_static_addr+0xb4>
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
 10126b8:	f8d2 1298 	ldr.w	r1, [r2, #664]	; 0x298
		    (NRF_FICR->IR[1] != UINT32_MAX) &&
 10126bc:	3101      	adds	r1, #1
 10126be:	d02d      	beq.n	101271c <hci_vendor_read_static_addr+0xb4>
		    (NRF_FICR->IR[3] != UINT32_MAX)) {
 10126c0:	f8d2 129c 	ldr.w	r1, [r2, #668]	; 0x29c
		    (NRF_FICR->IR[2] != UINT32_MAX) &&
 10126c4:	3101      	adds	r1, #1
 10126c6:	d029      	beq.n	101271c <hci_vendor_read_static_addr+0xb4>
			sys_put_le32(NRF_FICR->IR[0], &addrs[0].ir[0]);
 10126c8:	f8d2 1290 	ldr.w	r1, [r2, #656]	; 0x290
		return 1;
 10126cc:	2001      	movs	r0, #1
	sys_put_le16(val >> 16, &dst[2]);
 10126ce:	0c0c      	lsrs	r4, r1, #16
	dst[0] = val;
 10126d0:	7199      	strb	r1, [r3, #6]
	dst[1] = val >> 8;
 10126d2:	0a25      	lsrs	r5, r4, #8
 10126d4:	f3c1 2107 	ubfx	r1, r1, #8, #8
	dst[0] = val;
 10126d8:	721c      	strb	r4, [r3, #8]
	dst[1] = val >> 8;
 10126da:	725d      	strb	r5, [r3, #9]
 10126dc:	71d9      	strb	r1, [r3, #7]
			sys_put_le32(NRF_FICR->IR[1], &addrs[0].ir[4]);
 10126de:	f8d2 1294 	ldr.w	r1, [r2, #660]	; 0x294
	sys_put_le16(val >> 16, &dst[2]);
 10126e2:	0c0c      	lsrs	r4, r1, #16
	dst[0] = val;
 10126e4:	7299      	strb	r1, [r3, #10]
	dst[1] = val >> 8;
 10126e6:	0a25      	lsrs	r5, r4, #8
 10126e8:	f3c1 2107 	ubfx	r1, r1, #8, #8
	dst[0] = val;
 10126ec:	731c      	strb	r4, [r3, #12]
	dst[1] = val >> 8;
 10126ee:	735d      	strb	r5, [r3, #13]
 10126f0:	72d9      	strb	r1, [r3, #11]
			sys_put_le32(NRF_FICR->IR[2], &addrs[0].ir[8]);
 10126f2:	f8d2 1298 	ldr.w	r1, [r2, #664]	; 0x298
	sys_put_le16(val >> 16, &dst[2]);
 10126f6:	0c0c      	lsrs	r4, r1, #16
	dst[1] = val >> 8;
 10126f8:	0a25      	lsrs	r5, r4, #8
	dst[0] = val;
 10126fa:	7399      	strb	r1, [r3, #14]
	dst[1] = val >> 8;
 10126fc:	f3c1 2107 	ubfx	r1, r1, #8, #8
	dst[0] = val;
 1012700:	741c      	strb	r4, [r3, #16]
	dst[1] = val >> 8;
 1012702:	745d      	strb	r5, [r3, #17]
 1012704:	73d9      	strb	r1, [r3, #15]
			sys_put_le32(NRF_FICR->IR[3], &addrs[0].ir[12]);
 1012706:	f8d2 229c 	ldr.w	r2, [r2, #668]	; 0x29c
	sys_put_le16(val >> 16, &dst[2]);
 101270a:	0c11      	lsrs	r1, r2, #16
	dst[1] = val >> 8;
 101270c:	0a0d      	lsrs	r5, r1, #8
 101270e:	f3c2 2407 	ubfx	r4, r2, #8, #8
	dst[0] = val;
 1012712:	749a      	strb	r2, [r3, #18]
 1012714:	7519      	strb	r1, [r3, #20]
	dst[1] = val >> 8;
 1012716:	755d      	strb	r5, [r3, #21]
 1012718:	74dc      	strb	r4, [r3, #19]
}
 101271a:	bd38      	pop	{r3, r4, r5, pc}
			(void)memset(addrs[0].ir, 0x00, sizeof(addrs[0].ir));
 101271c:	2210      	movs	r2, #16
 101271e:	2100      	movs	r1, #0
 1012720:	1d98      	adds	r0, r3, #6
 1012722:	f004 f8f4 	bl	101690e <memset>
		return 1;
 1012726:	2001      	movs	r0, #1
}
 1012728:	bd38      	pop	{r3, r4, r5, pc}
	    ((NRF_FICR->DEVICEADDR[1] & UINT16_MAX) != UINT16_MAX)) &&
 101272a:	f64f 71ff 	movw	r1, #65535	; 0xffff
 101272e:	f8d2 22a8 	ldr.w	r2, [r2, #680]	; 0x2a8
 1012732:	b292      	uxth	r2, r2
	if (((NRF_FICR->DEVICEADDR[0] != UINT32_MAX) ||
 1012734:	428a      	cmp	r2, r1
 1012736:	d19e      	bne.n	1012676 <hci_vendor_read_static_addr+0xe>
	return 0;
 1012738:	2000      	movs	r0, #0
}
 101273a:	bd38      	pop	{r3, r4, r5, pc}
 101273c:	01ff0000 	.word	0x01ff0000

01012740 <hci_vendor_read_key_hierarchy_roots>:

void hci_vendor_read_key_hierarchy_roots(u8_t ir[16], u8_t er[16])
{
 1012740:	b538      	push	{r3, r4, r5, lr}
	/* Mark IR as invalid.
	 * No public address is available, and static address IR should be read
	 * using Read Static Addresses command.
	 */
	(void)memset(ir, 0x00, 16);
 1012742:	2210      	movs	r2, #16
{
 1012744:	460c      	mov	r4, r1
	(void)memset(ir, 0x00, 16);
 1012746:	2100      	movs	r1, #0
 1012748:	f004 f8e1 	bl	101690e <memset>

	/* Fill in ER if present */
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
 101274c:	4b20      	ldr	r3, [pc, #128]	; (10127d0 <hci_vendor_read_key_hierarchy_roots+0x90>)
 101274e:	f8d3 2280 	ldr.w	r2, [r3, #640]	; 0x280
 1012752:	3201      	adds	r2, #1
 1012754:	d034      	beq.n	10127c0 <hci_vendor_read_key_hierarchy_roots+0x80>
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
 1012756:	f8d3 2284 	ldr.w	r2, [r3, #644]	; 0x284
	if ((NRF_FICR->ER[0] != UINT32_MAX) &&
 101275a:	3201      	adds	r2, #1
 101275c:	d030      	beq.n	10127c0 <hci_vendor_read_key_hierarchy_roots+0x80>
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
 101275e:	f8d3 2288 	ldr.w	r2, [r3, #648]	; 0x288
	    (NRF_FICR->ER[1] != UINT32_MAX) &&
 1012762:	3201      	adds	r2, #1
 1012764:	d02c      	beq.n	10127c0 <hci_vendor_read_key_hierarchy_roots+0x80>
	    (NRF_FICR->ER[3] != UINT32_MAX)) {
 1012766:	f8d3 228c 	ldr.w	r2, [r3, #652]	; 0x28c
	    (NRF_FICR->ER[2] != UINT32_MAX) &&
 101276a:	3201      	adds	r2, #1
 101276c:	d028      	beq.n	10127c0 <hci_vendor_read_key_hierarchy_roots+0x80>
		sys_put_le32(NRF_FICR->ER[0], &er[0]);
 101276e:	f8d3 2280 	ldr.w	r2, [r3, #640]	; 0x280
	sys_put_le16(val >> 16, &dst[2]);
 1012772:	0c11      	lsrs	r1, r2, #16
	dst[1] = val >> 8;
 1012774:	0a0d      	lsrs	r5, r1, #8
 1012776:	f3c2 2007 	ubfx	r0, r2, #8, #8
	dst[0] = val;
 101277a:	70a1      	strb	r1, [r4, #2]
	dst[1] = val >> 8;
 101277c:	70e5      	strb	r5, [r4, #3]
 101277e:	7060      	strb	r0, [r4, #1]
	dst[0] = val;
 1012780:	7022      	strb	r2, [r4, #0]
		sys_put_le32(NRF_FICR->ER[1], &er[4]);
 1012782:	f8d3 2284 	ldr.w	r2, [r3, #644]	; 0x284
	sys_put_le16(val >> 16, &dst[2]);
 1012786:	0c11      	lsrs	r1, r2, #16
	dst[1] = val >> 8;
 1012788:	0a0d      	lsrs	r5, r1, #8
 101278a:	f3c2 2007 	ubfx	r0, r2, #8, #8
	dst[0] = val;
 101278e:	71a1      	strb	r1, [r4, #6]
	dst[1] = val >> 8;
 1012790:	71e5      	strb	r5, [r4, #7]
 1012792:	7160      	strb	r0, [r4, #5]
	dst[0] = val;
 1012794:	7122      	strb	r2, [r4, #4]
		sys_put_le32(NRF_FICR->ER[2], &er[8]);
 1012796:	f8d3 2288 	ldr.w	r2, [r3, #648]	; 0x288
	sys_put_le16(val >> 16, &dst[2]);
 101279a:	0c11      	lsrs	r1, r2, #16
	dst[1] = val >> 8;
 101279c:	f3c2 2007 	ubfx	r0, r2, #8, #8
 10127a0:	0a0d      	lsrs	r5, r1, #8
	dst[0] = val;
 10127a2:	7222      	strb	r2, [r4, #8]
 10127a4:	72a1      	strb	r1, [r4, #10]
	dst[1] = val >> 8;
 10127a6:	7260      	strb	r0, [r4, #9]
 10127a8:	72e5      	strb	r5, [r4, #11]
		sys_put_le32(NRF_FICR->ER[3], &er[12]);
 10127aa:	f8d3 328c 	ldr.w	r3, [r3, #652]	; 0x28c
	sys_put_le16(val >> 16, &dst[2]);
 10127ae:	0c1a      	lsrs	r2, r3, #16
	dst[1] = val >> 8;
 10127b0:	0a10      	lsrs	r0, r2, #8
 10127b2:	f3c3 2107 	ubfx	r1, r3, #8, #8
	dst[0] = val;
 10127b6:	7323      	strb	r3, [r4, #12]
 10127b8:	73a2      	strb	r2, [r4, #14]
	dst[1] = val >> 8;
 10127ba:	73e0      	strb	r0, [r4, #15]
 10127bc:	7361      	strb	r1, [r4, #13]
	} else {
		/* Mark ER as invalid */
		(void)memset(er, 0x00, 16);
	}
}
 10127be:	bd38      	pop	{r3, r4, r5, pc}
		(void)memset(er, 0x00, 16);
 10127c0:	4620      	mov	r0, r4
}
 10127c2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		(void)memset(er, 0x00, 16);
 10127c6:	2210      	movs	r2, #16
 10127c8:	2100      	movs	r1, #0
 10127ca:	f004 b8a0 	b.w	101690e <memset>
 10127ce:	bf00      	nop
 10127d0:	01ff0000 	.word	0x01ff0000

010127d4 <net_buf_id>:

int net_buf_id(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);

	return buf - pool->__bufs;
 10127d4:	2128      	movs	r1, #40	; 0x28
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 10127d6:	7983      	ldrb	r3, [r0, #6]
	return buf - pool->__bufs;
 10127d8:	4a04      	ldr	r2, [pc, #16]	; (10127ec <net_buf_id+0x18>)
 10127da:	fb01 2303 	mla	r3, r1, r3, r2
 10127de:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 10127e0:	1ac0      	subs	r0, r0, r3
}
 10127e2:	4b03      	ldr	r3, [pc, #12]	; (10127f0 <net_buf_id+0x1c>)
	return buf - pool->__bufs;
 10127e4:	10c0      	asrs	r0, r0, #3
}
 10127e6:	4358      	muls	r0, r3
 10127e8:	4770      	bx	lr
 10127ea:	bf00      	nop
 10127ec:	210005e4 	.word	0x210005e4
 10127f0:	aaaaaaab 	.word	0xaaaaaaab

010127f4 <fixed_data_alloc>:
	.unref = mem_pool_data_unref,
};

static u8_t *fixed_data_alloc(struct net_buf *buf, size_t *size,
			      k_timeout_t timeout)
{
 10127f4:	b510      	push	{r4, lr}
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
 10127f6:	2428      	movs	r4, #40	; 0x28
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 10127f8:	7983      	ldrb	r3, [r0, #6]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
 10127fa:	4a09      	ldr	r2, [pc, #36]	; (1012820 <fixed_data_alloc+0x2c>)
 10127fc:	fb04 2303 	mla	r3, r4, r3, r2
 1012800:	6a1b      	ldr	r3, [r3, #32]

	*size = MIN(fixed->data_size, *size);
 1012802:	680a      	ldr	r2, [r1, #0]
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
 1012804:	685c      	ldr	r4, [r3, #4]
	*size = MIN(fixed->data_size, *size);
 1012806:	6823      	ldr	r3, [r4, #0]
 1012808:	429a      	cmp	r2, r3
 101280a:	bf94      	ite	ls
 101280c:	600a      	strls	r2, [r1, #0]
 101280e:	600b      	strhi	r3, [r1, #0]

	return fixed->data_pool + fixed->data_size * net_buf_id(buf);
 1012810:	f7ff ffe0 	bl	10127d4 <net_buf_id>
 1012814:	e9d4 2300 	ldrd	r2, r3, [r4]
}
 1012818:	fb02 3000 	mla	r0, r2, r0, r3
 101281c:	bd10      	pop	{r4, pc}
 101281e:	bf00      	nop
 1012820:	210005e4 	.word	0x210005e4

01012824 <net_buf_alloc_len>:
					int line)
#else
struct net_buf *net_buf_alloc_len(struct net_buf_pool *pool, size_t size,
				  k_timeout_t timeout)
#endif
{
 1012824:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
 1012828:	4605      	mov	r5, r0
 101282a:	9101      	str	r1, [sp, #4]
	u64_t end = z_timeout_end_calc(timeout);
 101282c:	4610      	mov	r0, r2
 101282e:	4619      	mov	r1, r3
{
 1012830:	4616      	mov	r6, r2
 1012832:	461f      	mov	r7, r3
	u64_t end = z_timeout_end_calc(timeout);
 1012834:	f005 fa24 	bl	1017c80 <z_timeout_end_calc>
 1012838:	4680      	mov	r8, r0
 101283a:	4689      	mov	r9, r1
 101283c:	f04f 0320 	mov.w	r3, #32
 1012840:	f3ef 8a11 	mrs	sl, BASEPRI
 1012844:	f383 8811 	msr	BASEPRI, r3
 1012848:	f3bf 8f6f 	isb	sy
	key = irq_lock();

	/* If there are uninitialized buffers we're guaranteed to succeed
	 * with the allocation one way or another.
	 */
	if (pool->uninit_count) {
 101284c:	8b6b      	ldrh	r3, [r5, #26]
 101284e:	2b00      	cmp	r3, #0
 1012850:	d053      	beq.n	10128fa <net_buf_alloc_len+0xd6>

		/* If this is not the first access to the pool, we can
		 * be opportunistic and try to fetch a previously used
		 * buffer from the LIFO with K_NO_WAIT.
		 */
		if (pool->uninit_count < pool->buf_count) {
 1012852:	8b2a      	ldrh	r2, [r5, #24]
 1012854:	429a      	cmp	r2, r3
 1012856:	d93c      	bls.n	10128d2 <net_buf_alloc_len+0xae>
	return z_impl_k_queue_get(queue, timeout);
 1012858:	2200      	movs	r2, #0
 101285a:	2300      	movs	r3, #0
 101285c:	4628      	mov	r0, r5
 101285e:	f001 fbb3 	bl	1013fc8 <z_impl_k_queue_get>
			buf = k_lifo_get(&pool->free, K_NO_WAIT);
			if (buf) {
 1012862:	4604      	mov	r4, r0
 1012864:	2800      	cmp	r0, #0
 1012866:	d034      	beq.n	10128d2 <net_buf_alloc_len+0xae>
	__asm__ volatile(
 1012868:	f38a 8811 	msr	BASEPRI, sl
 101286c:	f3bf 8f6f 	isb	sy
	}

success:
	NET_BUF_DBG("allocated buf %p", buf);

	if (size) {
 1012870:	9b01      	ldr	r3, [sp, #4]
 1012872:	2b00      	cmp	r3, #0
 1012874:	d051      	beq.n	101291a <net_buf_alloc_len+0xf6>
#if __ASSERT_ON
		size_t req_size = size;
#endif
		if (!K_TIMEOUT_EQ(timeout, K_NO_WAIT) &&
 1012876:	ea56 0307 	orrs.w	r3, r6, r7
 101287a:	d010      	beq.n	101289e <net_buf_alloc_len+0x7a>
 101287c:	1c7b      	adds	r3, r7, #1
 101287e:	bf08      	it	eq
 1012880:	f1b6 3fff 	cmpeq.w	r6, #4294967295
 1012884:	d00b      	beq.n	101289e <net_buf_alloc_len+0x7a>
		    !K_TIMEOUT_EQ(timeout, K_FOREVER)) {
			s64_t remaining = end - z_tick_get();
 1012886:	f002 f969 	bl	1014b5c <z_tick_get>
 101288a:	ebb8 0600 	subs.w	r6, r8, r0
 101288e:	eb69 0701 	sbc.w	r7, r9, r1
 1012892:	2e00      	cmp	r6, #0
 1012894:	f177 0300 	sbcs.w	r3, r7, #0
 1012898:	bfbc      	itt	lt
 101289a:	2600      	movlt	r6, #0
 101289c:	2700      	movlt	r7, #0
	return pool->alloc->cb->alloc(buf, size, timeout);
 101289e:	f04f 0928 	mov.w	r9, #40	; 0x28
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);
 10128a2:	79a3      	ldrb	r3, [r4, #6]
	return pool->alloc->cb->alloc(buf, size, timeout);
 10128a4:	f8df 8088 	ldr.w	r8, [pc, #136]	; 1012930 <net_buf_alloc_len+0x10c>
 10128a8:	4632      	mov	r2, r6
 10128aa:	fb09 8303 	mla	r3, r9, r3, r8
 10128ae:	6a1b      	ldr	r3, [r3, #32]
 10128b0:	4620      	mov	r0, r4
 10128b2:	681b      	ldr	r3, [r3, #0]
 10128b4:	a901      	add	r1, sp, #4
 10128b6:	681d      	ldr	r5, [r3, #0]
 10128b8:	463b      	mov	r3, r7
 10128ba:	47a8      	blx	r5
 10128bc:	4605      	mov	r5, r0
			} else {
				timeout = Z_TIMEOUT_TICKS(remaining);
			}
		}

		buf->__buf = data_alloc(buf, &size, timeout);
 10128be:	6120      	str	r0, [r4, #16]
		if (!buf->__buf) {
 10128c0:	bb60      	cbnz	r0, 101291c <net_buf_alloc_len+0xf8>
 */
static inline void net_buf_destroy(struct net_buf *buf)
{
	struct net_buf_pool *pool = net_buf_pool_get(buf->pool_id);

	k_lifo_put(&pool->free, buf);
 10128c2:	79a0      	ldrb	r0, [r4, #6]
 10128c4:	4621      	mov	r1, r4
 10128c6:	fb09 8000 	mla	r0, r9, r0, r8
 10128ca:	f004 ff8f 	bl	10177ec <k_queue_prepend>
			NET_BUF_ERR("%s():%d: Failed to allocate data",
				    func, line);
			net_buf_destroy(buf);
			return NULL;
 10128ce:	462c      	mov	r4, r5
}
 10128d0:	e01f      	b.n	1012912 <net_buf_alloc_len+0xee>
		uninit_count = pool->uninit_count--;
 10128d2:	8b68      	ldrh	r0, [r5, #26]
 10128d4:	1e43      	subs	r3, r0, #1
 10128d6:	836b      	strh	r3, [r5, #26]
 10128d8:	f38a 8811 	msr	BASEPRI, sl
 10128dc:	f3bf 8f6f 	isb	sy
	buf = &pool->__bufs[pool->buf_count - uninit_count];
 10128e0:	2318      	movs	r3, #24
 10128e2:	8b2c      	ldrh	r4, [r5, #24]
 10128e4:	1a24      	subs	r4, r4, r0
 10128e6:	6a68      	ldr	r0, [r5, #36]	; 0x24
 10128e8:	fb03 0404 	mla	r4, r3, r4, r0
	return pool - _net_buf_pool_list;
 10128ec:	4810      	ldr	r0, [pc, #64]	; (1012930 <net_buf_alloc_len+0x10c>)
 10128ee:	4b11      	ldr	r3, [pc, #68]	; (1012934 <net_buf_alloc_len+0x110>)
 10128f0:	1a2d      	subs	r5, r5, r0
 10128f2:	10ed      	asrs	r5, r5, #3
 10128f4:	435d      	muls	r5, r3
	buf->pool_id = pool_id(pool);
 10128f6:	71a5      	strb	r5, [r4, #6]
		goto success;
 10128f8:	e7ba      	b.n	1012870 <net_buf_alloc_len+0x4c>
 10128fa:	f38a 8811 	msr	BASEPRI, sl
 10128fe:	f3bf 8f6f 	isb	sy
 1012902:	4632      	mov	r2, r6
 1012904:	463b      	mov	r3, r7
 1012906:	4628      	mov	r0, r5
 1012908:	f001 fb5e 	bl	1013fc8 <z_impl_k_queue_get>
	if (!buf) {
 101290c:	4604      	mov	r4, r0
 101290e:	2800      	cmp	r0, #0
 1012910:	d1ae      	bne.n	1012870 <net_buf_alloc_len+0x4c>
#if defined(CONFIG_NET_BUF_POOL_USAGE)
	pool->avail_count--;
	__ASSERT_NO_MSG(pool->avail_count >= 0);
#endif
	return buf;
}
 1012912:	4620      	mov	r0, r4
 1012914:	b002      	add	sp, #8
 1012916:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		buf->__buf = NULL;
 101291a:	6123      	str	r3, [r4, #16]
	buf->frags = NULL;
 101291c:	2300      	movs	r3, #0
	buf->ref   = 1U;
 101291e:	2201      	movs	r2, #1
	buf->frags = NULL;
 1012920:	6023      	str	r3, [r4, #0]
	buf->ref   = 1U;
 1012922:	80a2      	strh	r2, [r4, #4]
	buf->len  = 0U;
 1012924:	81a3      	strh	r3, [r4, #12]
	buf->size  = size;
 1012926:	9a01      	ldr	r2, [sp, #4]
	buf->data = buf->__buf;
 1012928:	6923      	ldr	r3, [r4, #16]
 101292a:	81e2      	strh	r2, [r4, #14]
 101292c:	60a3      	str	r3, [r4, #8]
	return buf;
 101292e:	e7f0      	b.n	1012912 <net_buf_alloc_len+0xee>
 1012930:	210005e4 	.word	0x210005e4
 1012934:	cccccccd 	.word	0xcccccccd

01012938 <net_buf_unref>:
#if defined(CONFIG_NET_BUF_LOG)
void net_buf_unref_debug(struct net_buf *buf, const char *func, int line)
#else
void net_buf_unref(struct net_buf *buf)
#endif
{
 1012938:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 101293c:	4604      	mov	r4, r0
			return;
		}

		if (buf->__buf) {
			data_unref(buf, buf->__buf);
			buf->__buf = NULL;
 101293e:	2500      	movs	r5, #0
	pool->alloc->cb->unref(buf, data);
 1012940:	2728      	movs	r7, #40	; 0x28
 1012942:	4e14      	ldr	r6, [pc, #80]	; (1012994 <net_buf_unref+0x5c>)
	while (buf) {
 1012944:	b90c      	cbnz	r4, 101294a <net_buf_unref+0x12>
			net_buf_destroy(buf);
		}

		buf = frags;
	}
}
 1012946:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (--buf->ref > 0) {
 101294a:	7923      	ldrb	r3, [r4, #4]
		struct net_buf *frags = buf->frags;
 101294c:	f8d4 8000 	ldr.w	r8, [r4]
		if (--buf->ref > 0) {
 1012950:	3b01      	subs	r3, #1
 1012952:	b2db      	uxtb	r3, r3
 1012954:	7123      	strb	r3, [r4, #4]
 1012956:	2b00      	cmp	r3, #0
 1012958:	d1f5      	bne.n	1012946 <net_buf_unref+0xe>
		if (buf->__buf) {
 101295a:	6921      	ldr	r1, [r4, #16]
 101295c:	b159      	cbz	r1, 1012976 <net_buf_unref+0x3e>
	if (buf->flags & NET_BUF_EXTERNAL_DATA) {
 101295e:	7963      	ldrb	r3, [r4, #5]
 1012960:	079b      	lsls	r3, r3, #30
 1012962:	d407      	bmi.n	1012974 <net_buf_unref+0x3c>
	pool->alloc->cb->unref(buf, data);
 1012964:	79a3      	ldrb	r3, [r4, #6]
 1012966:	4620      	mov	r0, r4
 1012968:	fb07 6303 	mla	r3, r7, r3, r6
 101296c:	6a1b      	ldr	r3, [r3, #32]
 101296e:	681b      	ldr	r3, [r3, #0]
 1012970:	689b      	ldr	r3, [r3, #8]
 1012972:	4798      	blx	r3
			buf->__buf = NULL;
 1012974:	6125      	str	r5, [r4, #16]
		pool = net_buf_pool_get(buf->pool_id);
 1012976:	79a0      	ldrb	r0, [r4, #6]
		buf->data = NULL;
 1012978:	60a5      	str	r5, [r4, #8]
		if (pool->destroy) {
 101297a:	fb07 6000 	mla	r0, r7, r0, r6
 101297e:	69c3      	ldr	r3, [r0, #28]
		buf->frags = NULL;
 1012980:	6025      	str	r5, [r4, #0]
		if (pool->destroy) {
 1012982:	b11b      	cbz	r3, 101298c <net_buf_unref+0x54>
			pool->destroy(buf);
 1012984:	4620      	mov	r0, r4
 1012986:	4798      	blx	r3
{
 1012988:	4644      	mov	r4, r8
 101298a:	e7db      	b.n	1012944 <net_buf_unref+0xc>
	k_lifo_put(&pool->free, buf);
 101298c:	4621      	mov	r1, r4
 101298e:	f004 ff2d 	bl	10177ec <k_queue_prepend>
}
 1012992:	e7f9      	b.n	1012988 <net_buf_unref+0x50>
 1012994:	210005e4 	.word	0x210005e4

01012998 <gpio_nrfx_init>:
}

#define GPIOTE_NODE DT_INST(0, nordic_nrf_gpiote)

static int gpio_nrfx_init(struct device *port)
{
 1012998:	b508      	push	{r3, lr}
	static bool gpio_initialized;

	if (!gpio_initialized) {
 101299a:	4b09      	ldr	r3, [pc, #36]	; (10129c0 <gpio_nrfx_init+0x28>)
 101299c:	781a      	ldrb	r2, [r3, #0]
 101299e:	b96a      	cbnz	r2, 10129bc <gpio_nrfx_init+0x24>
		gpio_initialized = true;
 10129a0:	2101      	movs	r1, #1
		IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
 10129a2:	200a      	movs	r0, #10
		gpio_initialized = true;
 10129a4:	7019      	strb	r1, [r3, #0]
		IRQ_CONNECT(DT_IRQN(GPIOTE_NODE), DT_IRQ(GPIOTE_NODE, priority),
 10129a6:	2105      	movs	r1, #5
 10129a8:	f7f2 f9e6 	bl	1004d78 <z_arm_irq_priority_set>
			    gpiote_event_handler, NULL, 0);

		irq_enable(DT_IRQN(GPIOTE_NODE));
 10129ac:	200a      	movs	r0, #10
 10129ae:	f7f2 f9b1 	bl	1004d14 <arch_irq_enable>
    return ((uint32_t)p_reg + event);
}

NRF_STATIC_INLINE void nrf_gpiote_int_enable(NRF_GPIOTE_Type * p_reg, uint32_t mask)
{
    p_reg->INTENSET = mask;
 10129b2:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000
 10129b6:	4b03      	ldr	r3, [pc, #12]	; (10129c4 <gpio_nrfx_init+0x2c>)
 10129b8:	f8c3 2304 	str.w	r2, [r3, #772]	; 0x304
		nrf_gpiote_int_enable(NRF_GPIOTE, NRF_GPIOTE_INT_PORT_MASK);
	}

	return 0;
}
 10129bc:	2000      	movs	r0, #0
 10129be:	bd08      	pop	{r3, pc}
 10129c0:	210066fb 	.word	0x210066fb
 10129c4:	4100a000 	.word	0x4100a000

010129c8 <gpio_nrfx_config>:
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
 10129c8:	4b2b      	ldr	r3, [pc, #172]	; (1012a78 <gpio_nrfx_config+0xb0>)
{
 10129ca:	b5f0      	push	{r4, r5, r6, r7, lr}
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 10129cc:	6846      	ldr	r6, [r0, #4]
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
 10129ce:	482b      	ldr	r0, [pc, #172]	; (1012a7c <gpio_nrfx_config+0xb4>)
 10129d0:	4013      	ands	r3, r2
 10129d2:	4283      	cmp	r3, r0
 10129d4:	d042      	beq.n	1012a5c <gpio_nrfx_config+0x94>
 10129d6:	d80d      	bhi.n	10129f4 <gpio_nrfx_config+0x2c>
 10129d8:	2b06      	cmp	r3, #6
 10129da:	d015      	beq.n	1012a08 <gpio_nrfx_config+0x40>
 10129dc:	d805      	bhi.n	10129ea <gpio_nrfx_config+0x22>
 10129de:	b19b      	cbz	r3, 1012a08 <gpio_nrfx_config+0x40>
 10129e0:	2b02      	cmp	r3, #2
 10129e2:	d03d      	beq.n	1012a60 <gpio_nrfx_config+0x98>
 10129e4:	f06f 0015 	mvn.w	r0, #21
 10129e8:	e037      	b.n	1012a5a <gpio_nrfx_config+0x92>
 10129ea:	f5b3 1f80 	cmp.w	r3, #1048576	; 0x100000
 10129ee:	d1f9      	bne.n	10129e4 <gpio_nrfx_config+0x1c>
		drive = NRF_GPIO_PIN_H0S1;
 10129f0:	2301      	movs	r3, #1
 10129f2:	e009      	b.n	1012a08 <gpio_nrfx_config+0x40>
	switch (flags & (GPIO_DS_LOW_MASK | GPIO_DS_HIGH_MASK |
 10129f4:	4822      	ldr	r0, [pc, #136]	; (1012a80 <gpio_nrfx_config+0xb8>)
 10129f6:	4283      	cmp	r3, r0
 10129f8:	d034      	beq.n	1012a64 <gpio_nrfx_config+0x9c>
 10129fa:	f5b3 0fa0 	cmp.w	r3, #5242880	; 0x500000
 10129fe:	d033      	beq.n	1012a68 <gpio_nrfx_config+0xa0>
 1012a00:	f5b3 0f80 	cmp.w	r3, #4194304	; 0x400000
 1012a04:	d1ee      	bne.n	10129e4 <gpio_nrfx_config+0x1c>
		drive = NRF_GPIO_PIN_S0H1;
 1012a06:	2302      	movs	r3, #2
	if ((flags & GPIO_PULL_UP) != 0) {
 1012a08:	06d0      	lsls	r0, r2, #27
		pull = NRF_GPIO_PIN_PULLUP;
 1012a0a:	bf4c      	ite	mi
 1012a0c:	2503      	movmi	r5, #3
		pull = NRF_GPIO_PIN_NOPULL;
 1012a0e:	f3c2 1540 	ubfxpl	r5, r2, #5, #1
		: NRF_GPIO_PIN_INPUT_DISCONNECT;
 1012a12:	f482 7480 	eor.w	r4, r2, #256	; 0x100
	if ((flags & GPIO_OUTPUT) != 0) {
 1012a16:	0597      	lsls	r7, r2, #22
	dir = ((flags & GPIO_OUTPUT) != 0)
 1012a18:	f3c2 2040 	ubfx	r0, r2, #9, #1
		: NRF_GPIO_PIN_INPUT_DISCONNECT;
 1012a1c:	f3c4 2400 	ubfx	r4, r4, #8, #1
	if ((flags & GPIO_OUTPUT) != 0) {
 1012a20:	d506      	bpl.n	1012a30 <gpio_nrfx_config+0x68>
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
 1012a22:	f412 6f00 	tst.w	r2, #2048	; 0x800
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1012a26:	6877      	ldr	r7, [r6, #4]
		if ((flags & GPIO_OUTPUT_INIT_HIGH) != 0) {
 1012a28:	d020      	beq.n	1012a6c <gpio_nrfx_config+0xa4>
			nrf_gpio_port_out_set(reg, BIT(pin));
 1012a2a:	2201      	movs	r2, #1
 1012a2c:	408a      	lsls	r2, r1
}


NRF_STATIC_INLINE void nrf_gpio_port_out_set(NRF_GPIO_Type * p_reg, uint32_t set_mask)
{
    p_reg->OUTSET = set_mask;
 1012a2e:	60ba      	str	r2, [r7, #8]
	nrf_gpio_cfg(NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin),
 1012a30:	7a32      	ldrb	r2, [r6, #8]
 1012a32:	f001 011f 	and.w	r1, r1, #31
 1012a36:	ea41 1142 	orr.w	r1, r1, r2, lsl #5
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
 1012a3a:	ea40 0244 	orr.w	r2, r0, r4, lsl #1
	return 0;
 1012a3e:	2000      	movs	r0, #0
    if (*p_pin < P0_PIN_NUM)
 1012a40:	291f      	cmp	r1, #31
        return NRF_P1;
 1012a42:	bfca      	itet	gt
 1012a44:	4e0f      	ldrgt	r6, [pc, #60]	; (1012a84 <gpio_nrfx_config+0xbc>)
        return NRF_P0;
 1012a46:	4e10      	ldrle	r6, [pc, #64]	; (1012a88 <gpio_nrfx_config+0xc0>)
        *p_pin = *p_pin & 0x1F;
 1012a48:	f001 011f 	andgt.w	r1, r1, #31
                               | ((uint32_t)drive << GPIO_PIN_CNF_DRIVE_Pos)
 1012a4c:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 1012a50:	ea43 0385 	orr.w	r3, r3, r5, lsl #2
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
 1012a54:	3180      	adds	r1, #128	; 0x80
 1012a56:	f846 3021 	str.w	r3, [r6, r1, lsl #2]
}
 1012a5a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		drive = NRF_GPIO_PIN_H0D1;
 1012a5c:	2307      	movs	r3, #7
 1012a5e:	e7d3      	b.n	1012a08 <gpio_nrfx_config+0x40>
		drive = NRF_GPIO_PIN_D0S1;
 1012a60:	2304      	movs	r3, #4
 1012a62:	e7d1      	b.n	1012a08 <gpio_nrfx_config+0x40>
		drive = NRF_GPIO_PIN_D0H1;
 1012a64:	2305      	movs	r3, #5
 1012a66:	e7cf      	b.n	1012a08 <gpio_nrfx_config+0x40>
		drive = NRF_GPIO_PIN_H0H1;
 1012a68:	2303      	movs	r3, #3
 1012a6a:	e7cd      	b.n	1012a08 <gpio_nrfx_config+0x40>
		} else if ((flags & GPIO_OUTPUT_INIT_LOW) != 0) {
 1012a6c:	0552      	lsls	r2, r2, #21
			nrf_gpio_port_out_clear(reg, BIT(pin));
 1012a6e:	bf42      	ittt	mi
 1012a70:	2201      	movmi	r2, #1
 1012a72:	408a      	lslmi	r2, r1
}


NRF_STATIC_INLINE void nrf_gpio_port_out_clear(NRF_GPIO_Type * p_reg, uint32_t clr_mask)
{
    p_reg->OUTCLR = clr_mask;
 1012a74:	60fa      	strmi	r2, [r7, #12]
}
 1012a76:	e7db      	b.n	1012a30 <gpio_nrfx_config+0x68>
 1012a78:	00f00006 	.word	0x00f00006
 1012a7c:	00100006 	.word	0x00100006
 1012a80:	00400002 	.word	0x00400002
 1012a84:	418c0800 	.word	0x418c0800
 1012a88:	418c0500 	.word	0x418c0500

01012a8c <nrf_gpio_cfg_sense_set>:
    if (*p_pin < P0_PIN_NUM)
 1012a8c:	281f      	cmp	r0, #31
        return NRF_P1;
 1012a8e:	bf8a      	itet	hi
 1012a90:	4b07      	ldrhi	r3, [pc, #28]	; (1012ab0 <nrf_gpio_cfg_sense_set+0x24>)
        return NRF_P0;
 1012a92:	4b08      	ldrls	r3, [pc, #32]	; (1012ab4 <nrf_gpio_cfg_sense_set+0x28>)
        *p_pin = *p_pin & 0x1F;
 1012a94:	f000 001f 	andhi.w	r0, r0, #31
    uint32_t cnf = reg->PIN_CNF[pin_number] & ~GPIO_PIN_CNF_SENSE_Msk;
 1012a98:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 1012a9c:	f8d0 3200 	ldr.w	r3, [r0, #512]	; 0x200
 1012aa0:	f423 3340 	bic.w	r3, r3, #196608	; 0x30000
    reg->PIN_CNF[pin_number] = cnf | (sense_config << GPIO_PIN_CNF_SENSE_Pos);
 1012aa4:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 1012aa8:	f8c0 1200 	str.w	r1, [r0, #512]	; 0x200
}
 1012aac:	4770      	bx	lr
 1012aae:	bf00      	nop
 1012ab0:	418c0800 	.word	0x418c0800
 1012ab4:	418c0500 	.word	0x418c0500

01012ab8 <gpiote_pin_int_cfg>:
{
 1012ab8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
 1012aba:	6843      	ldr	r3, [r0, #4]
	struct gpio_nrfx_data *data = get_port_data(port);
 1012abc:	68c6      	ldr	r6, [r0, #12]
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
 1012abe:	7a18      	ldrb	r0, [r3, #8]
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
 1012ac0:	2300      	movs	r3, #0
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
 1012ac2:	f001 041f 	and.w	r4, r1, #31
{
 1012ac6:	460d      	mov	r5, r1
    p_reg->INTENCLR = mask;
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_int_enable_check(NRF_GPIOTE_Type const * p_reg, uint32_t mask)
{
    return p_reg->INTENSET & mask;
 1012ac8:	4947      	ldr	r1, [pc, #284]	; (1012be8 <gpiote_pin_int_cfg+0x130>)
	u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
 1012aca:	ea44 1440 	orr.w	r4, r4, r0, lsl #5
 1012ace:	f8d1 2304 	ldr.w	r2, [r1, #772]	; 0x304
 1012ad2:	b2d2      	uxtb	r2, r2
                        ((polarity << GPIOTE_CONFIG_POLARITY_Pos) & GPIOTE_CONFIG_POLARITY_Msk);
}

NRF_STATIC_INLINE uint32_t nrf_gpiote_event_pin_get(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
 1012ad4:	f503 70a2 	add.w	r0, r3, #324	; 0x144
 1012ad8:	f851 0020 	ldr.w	r0, [r1, r0, lsl #2]
 1012adc:	f3c0 2005 	ubfx	r0, r0, #8, #6
		if ((nrf_gpiote_event_pin_get(NRF_GPIOTE, i) == abs_pin)
 1012ae0:	4284      	cmp	r4, r0
 1012ae2:	d16a      	bne.n	1012bba <gpiote_pin_int_cfg+0x102>
		    && (intenset & BIT(i))) {
 1012ae4:	fa22 f003 	lsr.w	r0, r2, r3
 1012ae8:	07c0      	lsls	r0, r0, #31
 1012aea:	d566      	bpl.n	1012bba <gpiote_pin_int_cfg+0x102>
   p_reg->CONFIG[idx] &= ~GPIOTE_CONFIG_MODE_Event;
 1012aec:	009a      	lsls	r2, r3, #2
 1012aee:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
 1012af2:	f502 4220 	add.w	r2, r2, #40960	; 0xa000
 1012af6:	f8d2 0510 	ldr.w	r0, [r2, #1296]	; 0x510
 1012afa:	f020 0001 	bic.w	r0, r0, #1
 1012afe:	f8c2 0510 	str.w	r0, [r2, #1296]	; 0x510
			nrf_gpiote_int_disable(NRF_GPIOTE, BIT(i));
 1012b02:	2201      	movs	r2, #1
 1012b04:	fa02 f303 	lsl.w	r3, r2, r3
    p_reg->INTENCLR = mask;
 1012b08:	f8c1 3308 	str.w	r3, [r1, #776]	; 0x308
	nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
 1012b0c:	4620      	mov	r0, r4
 1012b0e:	2100      	movs	r1, #0
 1012b10:	f7ff ffbc 	bl	1012a8c <nrf_gpio_cfg_sense_set>
	if ((data->pin_int_en & BIT(pin)) && (data->int_en & BIT(pin))) {
 1012b14:	68f3      	ldr	r3, [r6, #12]
 1012b16:	40eb      	lsrs	r3, r5
 1012b18:	f013 0001 	ands.w	r0, r3, #1
 1012b1c:	d04c      	beq.n	1012bb8 <gpiote_pin_int_cfg+0x100>
 1012b1e:	6933      	ldr	r3, [r6, #16]
 1012b20:	40eb      	lsrs	r3, r5
 1012b22:	f013 0001 	ands.w	r0, r3, #1
 1012b26:	d047      	beq.n	1012bb8 <gpiote_pin_int_cfg+0x100>
		if (data->trig_edge & BIT(pin)) {
 1012b28:	69b3      	ldr	r3, [r6, #24]
 1012b2a:	40eb      	lsrs	r3, r5
 1012b2c:	f013 0201 	ands.w	r2, r3, #1
 1012b30:	d04d      	beq.n	1012bce <gpiote_pin_int_cfg+0x116>
			if (data->double_edge & BIT(pin)) {
 1012b32:	69f3      	ldr	r3, [r6, #28]
    p_reg->CONFIG[idx] = 0;
}

NRF_STATIC_INLINE bool nrf_gpiote_te_is_enabled(NRF_GPIOTE_Type const * p_reg, uint32_t idx)
{
    return (p_reg->CONFIG[idx] & GPIOTE_CONFIG_MODE_Msk) != GPIOTE_CONFIG_MODE_Disabled;
 1012b34:	4f2c      	ldr	r7, [pc, #176]	; (1012be8 <gpiote_pin_int_cfg+0x130>)
 1012b36:	40eb      	lsrs	r3, r5
 1012b38:	07db      	lsls	r3, r3, #31
			} else if ((data->int_active_level & BIT(pin)) != 0U) {
 1012b3a:	bf54      	ite	pl
 1012b3c:	6971      	ldrpl	r1, [r6, #20]
				pol = NRF_GPIOTE_POLARITY_TOGGLE;
 1012b3e:	2503      	movmi	r5, #3
 1012b40:	f04f 0600 	mov.w	r6, #0
			} else if ((data->int_active_level & BIT(pin)) != 0U) {
 1012b44:	bf5f      	itttt	pl
 1012b46:	fa21 f505 	lsrpl.w	r5, r1, r5
 1012b4a:	f005 0501 	andpl.w	r5, r5, #1
 1012b4e:	f1c5 0502 	rsbpl	r5, r5, #2
 1012b52:	b2ed      	uxtbpl	r5, r5
 1012b54:	f506 73a2 	add.w	r3, r6, #324	; 0x144
 1012b58:	f857 0023 	ldr.w	r0, [r7, r3, lsl #2]
		if (!nrf_gpiote_te_is_enabled(NRF_GPIOTE, channel)) {
 1012b5c:	f010 0003 	ands.w	r0, r0, #3
 1012b60:	d12f      	bne.n	1012bc2 <gpiote_pin_int_cfg+0x10a>
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
 1012b62:	00b2      	lsls	r2, r6, #2
 1012b64:	f102 4282 	add.w	r2, r2, #1090519040	; 0x41000000
 1012b68:	f502 4220 	add.w	r2, r2, #40960	; 0xa000
 1012b6c:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
 1012b70:	0224      	lsls	r4, r4, #8
  p_reg->CONFIG[idx] &= ~(GPIOTE_CONFIG_PORT_PIN_Msk | GPIOTE_CONFIG_POLARITY_Msk);
 1012b72:	f421 314f 	bic.w	r1, r1, #211968	; 0x33c00
 1012b76:	f421 7140 	bic.w	r1, r1, #768	; 0x300
 1012b7a:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
 1012b7e:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
 1012b82:	f404 547c 	and.w	r4, r4, #16128	; 0x3f00
 1012b86:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
 1012b8a:	430d      	orrs	r5, r1
			nrf_gpiote_event_t evt =
 1012b8c:	f106 0140 	add.w	r1, r6, #64	; 0x40
 1012b90:	0089      	lsls	r1, r1, #2
    return ((uint32_t)p_reg + event);
 1012b92:	b289      	uxth	r1, r1
 1012b94:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
 1012b98:	f501 4120 	add.w	r1, r1, #40960	; 0xa000
  p_reg->CONFIG[idx] |= ((pin << GPIOTE_CONFIG_PSEL_Pos) & GPIOTE_CONFIG_PORT_PIN_Msk) |
 1012b9c:	f8c2 5510 	str.w	r5, [r2, #1296]	; 0x510
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
 1012ba0:	6008      	str	r0, [r1, #0]
   p_reg->CONFIG[idx] |= GPIOTE_CONFIG_MODE_Event;
 1012ba2:	f8d2 1510 	ldr.w	r1, [r2, #1296]	; 0x510
 1012ba6:	f041 0101 	orr.w	r1, r1, #1
 1012baa:	f8c2 1510 	str.w	r1, [r2, #1296]	; 0x510
			nrf_gpiote_int_enable(NRF_GPIOTE, BIT(channel));
 1012bae:	2201      	movs	r2, #1
 1012bb0:	fa02 f606 	lsl.w	r6, r2, r6
    p_reg->INTENSET = mask;
 1012bb4:	f8c7 6304 	str.w	r6, [r7, #772]	; 0x304
}
 1012bb8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
 1012bba:	3301      	adds	r3, #1
 1012bbc:	2b08      	cmp	r3, #8
 1012bbe:	d189      	bne.n	1012ad4 <gpiote_pin_int_cfg+0x1c>
 1012bc0:	e7a4      	b.n	1012b0c <gpiote_pin_int_cfg+0x54>
	for (u8_t channel = 0; channel < GPIOTE_CH_NUM; ++channel) {
 1012bc2:	3601      	adds	r6, #1
 1012bc4:	2e08      	cmp	r6, #8
 1012bc6:	d1c5      	bne.n	1012b54 <gpiote_pin_int_cfg+0x9c>
	return -ENODEV;
 1012bc8:	f06f 0012 	mvn.w	r0, #18
 1012bcc:	e7f4      	b.n	1012bb8 <gpiote_pin_int_cfg+0x100>
	if ((BIT(pin) & data->int_active_level) != 0U) {
 1012bce:	6971      	ldr	r1, [r6, #20]
			nrf_gpio_cfg_sense_set(abs_pin, sense);
 1012bd0:	4620      	mov	r0, r4
	if ((BIT(pin) & data->int_active_level) != 0U) {
 1012bd2:	40e9      	lsrs	r1, r5
 1012bd4:	f001 0101 	and.w	r1, r1, #1
 1012bd8:	f1c1 0103 	rsb	r1, r1, #3
			nrf_gpio_cfg_sense_set(abs_pin, sense);
 1012bdc:	b2c9      	uxtb	r1, r1
 1012bde:	f7ff ff55 	bl	1012a8c <nrf_gpio_cfg_sense_set>
	int res = 0;
 1012be2:	4610      	mov	r0, r2
 1012be4:	e7e8      	b.n	1012bb8 <gpiote_pin_int_cfg+0x100>
 1012be6:	bf00      	nop
 1012be8:	4100a000 	.word	0x4100a000

01012bec <gpio_nrfx_pin_interrupt_configure>:
	if ((mode == GPIO_INT_MODE_EDGE) &&
 1012bec:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
{
 1012bf0:	b470      	push	{r4, r5, r6}
	struct gpio_nrfx_data *data = get_port_data(port);
 1012bf2:	68c4      	ldr	r4, [r0, #12]
	if ((mode == GPIO_INT_MODE_EDGE) &&
 1012bf4:	d114      	bne.n	1012c20 <gpio_nrfx_pin_interrupt_configure+0x34>
	u32_t abs_pin = NRF_GPIO_PIN_MAP(get_port_cfg(port)->port_num, pin);
 1012bf6:	6845      	ldr	r5, [r0, #4]
 1012bf8:	7a2e      	ldrb	r6, [r5, #8]
 1012bfa:	f001 051f 	and.w	r5, r1, #31
 1012bfe:	ea45 1546 	orr.w	r5, r5, r6, lsl #5
    if (*p_pin < P0_PIN_NUM)
 1012c02:	2d1f      	cmp	r5, #31
        return NRF_P1;
 1012c04:	bfca      	itet	gt
 1012c06:	4e1e      	ldrgt	r6, [pc, #120]	; (1012c80 <gpio_nrfx_pin_interrupt_configure+0x94>)
        return NRF_P0;
 1012c08:	4e1e      	ldrle	r6, [pc, #120]	; (1012c84 <gpio_nrfx_pin_interrupt_configure+0x98>)
        *p_pin = *p_pin & 0x1F;
 1012c0a:	f005 051f 	andgt.w	r5, r5, #31
    return (nrf_gpio_pin_dir_t)((reg->PIN_CNF[pin_number] &
 1012c0e:	3580      	adds	r5, #128	; 0x80
 1012c10:	f856 5025 	ldr.w	r5, [r6, r5, lsl #2]
	if ((mode == GPIO_INT_MODE_EDGE) &&
 1012c14:	07ed      	lsls	r5, r5, #31
 1012c16:	d507      	bpl.n	1012c28 <gpio_nrfx_pin_interrupt_configure+0x3c>
}
 1012c18:	f06f 0022 	mvn.w	r0, #34	; 0x22
 1012c1c:	bc70      	pop	{r4, r5, r6}
 1012c1e:	4770      	bx	lr
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
 1012c20:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 1012c24:	68e5      	ldr	r5, [r4, #12]
 1012c26:	d026      	beq.n	1012c76 <gpio_nrfx_pin_interrupt_configure+0x8a>
 1012c28:	2501      	movs	r5, #1
 1012c2a:	68e6      	ldr	r6, [r4, #12]
 1012c2c:	408d      	lsls	r5, r1
 1012c2e:	4335      	orrs	r5, r6
 1012c30:	60e5      	str	r5, [r4, #12]
	WRITE_BIT(data->int_en, pin, mode != GPIO_INT_MODE_DISABLED);
 1012c32:	2501      	movs	r5, #1
 1012c34:	6926      	ldr	r6, [r4, #16]
 1012c36:	408d      	lsls	r5, r1
 1012c38:	f5b2 5f00 	cmp.w	r2, #8192	; 0x2000
 1012c3c:	bf14      	ite	ne
 1012c3e:	432e      	orrne	r6, r5
 1012c40:	43ae      	biceq	r6, r5
 1012c42:	6126      	str	r6, [r4, #16]
	WRITE_BIT(data->trig_edge, pin, mode == GPIO_INT_MODE_EDGE);
 1012c44:	69a6      	ldr	r6, [r4, #24]
 1012c46:	f5b2 3fa0 	cmp.w	r2, #81920	; 0x14000
 1012c4a:	69e2      	ldr	r2, [r4, #28]
 1012c4c:	bf0c      	ite	eq
 1012c4e:	432e      	orreq	r6, r5
 1012c50:	43ae      	bicne	r6, r5
	WRITE_BIT(data->double_edge, pin, trig == GPIO_INT_TRIG_BOTH);
 1012c52:	f5b3 2fc0 	cmp.w	r3, #393216	; 0x60000
 1012c56:	bf0c      	ite	eq
 1012c58:	432a      	orreq	r2, r5
 1012c5a:	43aa      	bicne	r2, r5
 1012c5c:	61e2      	str	r2, [r4, #28]
 1012c5e:	6962      	ldr	r2, [r4, #20]
	WRITE_BIT(data->int_active_level, pin, trig == GPIO_INT_TRIG_HIGH);
 1012c60:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 1012c64:	bf0c      	ite	eq
 1012c66:	4315      	orreq	r5, r2
 1012c68:	ea22 0505 	bicne.w	r5, r2, r5
	WRITE_BIT(data->trig_edge, pin, mode == GPIO_INT_MODE_EDGE);
 1012c6c:	61a6      	str	r6, [r4, #24]
	WRITE_BIT(data->int_active_level, pin, trig == GPIO_INT_TRIG_HIGH);
 1012c6e:	6165      	str	r5, [r4, #20]
}
 1012c70:	bc70      	pop	{r4, r5, r6}
	return gpiote_pin_int_cfg(port, pin);
 1012c72:	f7ff bf21 	b.w	1012ab8 <gpiote_pin_int_cfg>
	WRITE_BIT(data->pin_int_en, pin, mode != GPIO_INT_MODE_DISABLED);
 1012c76:	2601      	movs	r6, #1
 1012c78:	408e      	lsls	r6, r1
 1012c7a:	ea25 0506 	bic.w	r5, r5, r6
 1012c7e:	e7d7      	b.n	1012c30 <gpio_nrfx_pin_interrupt_configure+0x44>
 1012c80:	418c0800 	.word	0x418c0800
 1012c84:	418c0500 	.word	0x418c0500

01012c88 <gpiote_event_handler>:
{
 1012c88:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	u32_t fired_triggers[GPIO_COUNT] = {0};
 1012c8a:	2500      	movs	r5, #0
 1012c8c:	e9cd 5500 	strd	r5, r5, [sp]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 1012c90:	4e24      	ldr	r6, [pc, #144]	; (1012d24 <gpiote_event_handler+0x9c>)
 1012c92:	6834      	ldr	r4, [r6, #0]
	if (port_event) {
 1012c94:	b144      	cbz	r4, 1012ca8 <gpiote_event_handler+0x20>
			check_level_trigger_pins(DEVICE_GET(gpio_nrfx_p0));
 1012c96:	4824      	ldr	r0, [pc, #144]	; (1012d28 <gpiote_event_handler+0xa0>)
 1012c98:	f003 ffad 	bl	1016bf6 <check_level_trigger_pins>
		fired_triggers[0] =
 1012c9c:	9000      	str	r0, [sp, #0]
			check_level_trigger_pins(DEVICE_GET(gpio_nrfx_p1));
 1012c9e:	4823      	ldr	r0, [pc, #140]	; (1012d2c <gpiote_event_handler+0xa4>)
 1012ca0:	f003 ffa9 	bl	1016bf6 <check_level_trigger_pins>
		fired_triggers[1] =
 1012ca4:	9001      	str	r0, [sp, #4]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
 1012ca6:	6035      	str	r5, [r6, #0]
{
 1012ca8:	2200      	movs	r2, #0
		if (nrf_gpiote_int_enable_check(NRF_GPIOTE, BIT(i)) &&
 1012caa:	2601      	movs	r6, #1
 1012cac:	4694      	mov	ip, r2
    return p_reg->INTENSET & mask;
 1012cae:	4d20      	ldr	r5, [pc, #128]	; (1012d30 <gpiote_event_handler+0xa8>)
 1012cb0:	f8d5 3304 	ldr.w	r3, [r5, #772]	; 0x304
 1012cb4:	fa06 f102 	lsl.w	r1, r6, r2
 1012cb8:	4219      	tst	r1, r3
 1012cba:	d01a      	beq.n	1012cf2 <gpiote_event_handler+0x6a>
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 1012cbc:	0091      	lsls	r1, r2, #2
 1012cbe:	f101 4182 	add.w	r1, r1, #1090519040	; 0x41000000
 1012cc2:	f501 4121 	add.w	r1, r1, #41216	; 0xa100
 1012cc6:	680b      	ldr	r3, [r1, #0]
 1012cc8:	b19b      	cbz	r3, 1012cf2 <gpiote_event_handler+0x6a>
    return ((p_reg->CONFIG[idx] & GPIOTE_CONFIG_PORT_PIN_Msk) >> GPIOTE_CONFIG_PSEL_Pos);
 1012cca:	f502 73a2 	add.w	r3, r2, #324	; 0x144
 1012cce:	f855 3023 	ldr.w	r3, [r5, r3, lsl #2]
			fired_triggers[abs_pin / 32U] |= BIT(abs_pin % 32);
 1012cd2:	af02      	add	r7, sp, #8
 1012cd4:	f3c3 3040 	ubfx	r0, r3, #13, #1
 1012cd8:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 1012cdc:	f850 7c08 	ldr.w	r7, [r0, #-8]
 1012ce0:	f3c3 2304 	ubfx	r3, r3, #8, #5
 1012ce4:	fa06 f303 	lsl.w	r3, r6, r3
 1012ce8:	433b      	orrs	r3, r7
 1012cea:	f840 3c08 	str.w	r3, [r0, #-8]
    *((volatile uint32_t *)nrf_gpiote_event_address_get(p_reg, event)) = 0;
 1012cee:	f8c1 c000 	str.w	ip, [r1]
	for (size_t i = 0; i < GPIOTE_CH_NUM; i++) {
 1012cf2:	3201      	adds	r2, #1
 1012cf4:	2a08      	cmp	r2, #8
 1012cf6:	d1db      	bne.n	1012cb0 <gpiote_event_handler+0x28>
	if (fired_triggers[0]) {
 1012cf8:	9900      	ldr	r1, [sp, #0]
 1012cfa:	b111      	cbz	r1, 1012d02 <gpiote_event_handler+0x7a>
		fire_callbacks(DEVICE_GET(gpio_nrfx_p0), fired_triggers[0]);
 1012cfc:	480a      	ldr	r0, [pc, #40]	; (1012d28 <gpiote_event_handler+0xa0>)
 1012cfe:	f003 ff53 	bl	1016ba8 <fire_callbacks>
	if (fired_triggers[1]) {
 1012d02:	9901      	ldr	r1, [sp, #4]
 1012d04:	b111      	cbz	r1, 1012d0c <gpiote_event_handler+0x84>
		fire_callbacks(DEVICE_GET(gpio_nrfx_p1), fired_triggers[1]);
 1012d06:	4809      	ldr	r0, [pc, #36]	; (1012d2c <gpiote_event_handler+0xa4>)
 1012d08:	f003 ff4e 	bl	1016ba8 <fire_callbacks>
	if (port_event) {
 1012d0c:	b144      	cbz	r4, 1012d20 <gpiote_event_handler+0x98>
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p0));
 1012d0e:	4806      	ldr	r0, [pc, #24]	; (1012d28 <gpiote_event_handler+0xa0>)
 1012d10:	f003 ff96 	bl	1016c40 <cfg_level_pins>
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p1));
 1012d14:	4805      	ldr	r0, [pc, #20]	; (1012d2c <gpiote_event_handler+0xa4>)
}
 1012d16:	b003      	add	sp, #12
 1012d18:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
		cfg_level_pins(DEVICE_GET(gpio_nrfx_p1));
 1012d1c:	f003 bf90 	b.w	1016c40 <cfg_level_pins>
}
 1012d20:	b003      	add	sp, #12
 1012d22:	bdf0      	pop	{r4, r5, r6, r7, pc}
 1012d24:	4100a17c 	.word	0x4100a17c
 1012d28:	2100050c 	.word	0x2100050c
 1012d2c:	2100051c 	.word	0x2100051c
 1012d30:	4100a000 	.word	0x4100a000

01012d34 <vipm_nrf_0_register_callback>:
		    &vipm_nrf_##_idx##_driver_api)

#define VIPM_DEVICE(_idx, _)						\
	IF_ENABLED(CONFIG_IPM_MSG_CH_##_idx##_ENABLE, (VIPM_DEVICE_1(_idx);))

UTIL_LISTIFY(NRFX_IPC_ID_MAX_VALUE, VIPM_DEVICE, _);
 1012d34:	4b01      	ldr	r3, [pc, #4]	; (1012d3c <vipm_nrf_0_register_callback+0x8>)
 1012d36:	6019      	str	r1, [r3, #0]
 1012d38:	641a      	str	r2, [r3, #64]	; 0x40
 1012d3a:	4770      	bx	lr
 1012d3c:	21003f68 	.word	0x21003f68

01012d40 <vipm_nrf_0_send>:
 1012d40:	b508      	push	{r3, lr}
 1012d42:	4906      	ldr	r1, [pc, #24]	; (1012d5c <vipm_nrf_0_send+0x1c>)
 1012d44:	4b06      	ldr	r3, [pc, #24]	; (1012d60 <vipm_nrf_0_send+0x20>)
 1012d46:	4807      	ldr	r0, [pc, #28]	; (1012d64 <vipm_nrf_0_send+0x24>)
 1012d48:	1ac9      	subs	r1, r1, r3
 1012d4a:	08c9      	lsrs	r1, r1, #3
 1012d4c:	0189      	lsls	r1, r1, #6
 1012d4e:	f041 0101 	orr.w	r1, r1, #1
 1012d52:	f002 fb1c 	bl	101538e <log_0>
 1012d56:	f06f 0015 	mvn.w	r0, #21
 1012d5a:	bd08      	pop	{r3, pc}
 1012d5c:	010181a0 	.word	0x010181a0
 1012d60:	010180b8 	.word	0x010180b8
 1012d64:	010197d6 	.word	0x010197d6

01012d68 <vipm_nrf_1_set_enabled>:
 1012d68:	b508      	push	{r3, lr}
 1012d6a:	4906      	ldr	r1, [pc, #24]	; (1012d84 <vipm_nrf_1_set_enabled+0x1c>)
 1012d6c:	4b06      	ldr	r3, [pc, #24]	; (1012d88 <vipm_nrf_1_set_enabled+0x20>)
 1012d6e:	4807      	ldr	r0, [pc, #28]	; (1012d8c <vipm_nrf_1_set_enabled+0x24>)
 1012d70:	1ac9      	subs	r1, r1, r3
 1012d72:	08c9      	lsrs	r1, r1, #3
 1012d74:	0189      	lsls	r1, r1, #6
 1012d76:	f041 0101 	orr.w	r1, r1, #1
 1012d7a:	f002 fb08 	bl	101538e <log_0>
 1012d7e:	f06f 0015 	mvn.w	r0, #21
 1012d82:	bd08      	pop	{r3, pc}
 1012d84:	010181a0 	.word	0x010181a0
 1012d88:	010180b8 	.word	0x010180b8
 1012d8c:	010197f2 	.word	0x010197f2

01012d90 <vipm_nrf_1_register_callback>:
 1012d90:	4904      	ldr	r1, [pc, #16]	; (1012da4 <vipm_nrf_1_register_callback+0x14>)
 1012d92:	4b05      	ldr	r3, [pc, #20]	; (1012da8 <vipm_nrf_1_register_callback+0x18>)
 1012d94:	4805      	ldr	r0, [pc, #20]	; (1012dac <vipm_nrf_1_register_callback+0x1c>)
 1012d96:	1ac9      	subs	r1, r1, r3
 1012d98:	08c9      	lsrs	r1, r1, #3
 1012d9a:	0189      	lsls	r1, r1, #6
 1012d9c:	f041 0102 	orr.w	r1, r1, #2
 1012da0:	f002 baf5 	b.w	101538e <log_0>
 1012da4:	010181a0 	.word	0x010181a0
 1012da8:	010180b8 	.word	0x010180b8
 1012dac:	0101980e 	.word	0x0101980e

01012db0 <vipm_nrf_init>:
{
 1012db0:	b538      	push	{r3, r4, r5, lr}
	if (!nrfx_vipm_data.ipm_init) {
 1012db2:	4d0b      	ldr	r5, [pc, #44]	; (1012de0 <vipm_nrf_init+0x30>)
 1012db4:	f895 4080 	ldrb.w	r4, [r5, #128]	; 0x80
 1012db8:	b97c      	cbnz	r4, 1012dda <vipm_nrf_init+0x2a>
{
	/* Init IPC */
#if IS_ENABLED(CONFIG_IPM_NRF_SINGLE_INSTANCE)
	nrfx_ipc_init(0, nrfx_ipc_handler, (void *)&nrfx_ipm_data);
#else
	nrfx_ipc_init(0, vipm_dispatcher, (void *)&nrfx_ipm_data);
 1012dba:	4a0a      	ldr	r2, [pc, #40]	; (1012de4 <vipm_nrf_init+0x34>)
 1012dbc:	490a      	ldr	r1, [pc, #40]	; (1012de8 <vipm_nrf_init+0x38>)
 1012dbe:	4620      	mov	r0, r4
 1012dc0:	f000 fb02 	bl	10133c8 <nrfx_ipc_init>
#endif
	IRQ_CONNECT(DT_INST_IRQN(0),
 1012dc4:	4622      	mov	r2, r4
 1012dc6:	2101      	movs	r1, #1
 1012dc8:	2012      	movs	r0, #18
 1012dca:	f7f1 ffd5 	bl	1004d78 <z_arm_irq_priority_set>
		    DT_INST_IRQ(0, priority),
		    nrfx_isr, nrfx_ipc_irq_handler, 0);

	/* Set up signals and channels */
	nrfx_ipc_config_load(&ipc_cfg);
 1012dce:	4807      	ldr	r0, [pc, #28]	; (1012dec <vipm_nrf_init+0x3c>)
 1012dd0:	f000 fb12 	bl	10133f8 <nrfx_ipc_config_load>
		nrfx_vipm_data.ipm_init = true;
 1012dd4:	2301      	movs	r3, #1
 1012dd6:	f885 3080 	strb.w	r3, [r5, #128]	; 0x80
}
 1012dda:	2000      	movs	r0, #0
 1012ddc:	bd38      	pop	{r3, r4, r5, pc}
 1012dde:	bf00      	nop
 1012de0:	21003f68 	.word	0x21003f68
 1012de4:	21003f60 	.word	0x21003f60
 1012de8:	01012df1 	.word	0x01012df1
 1012dec:	01018d3c 	.word	0x01018d3c

01012df0 <vipm_dispatcher>:
{
 1012df0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1012df2:	4604      	mov	r4, r0
		event_mask &= ~BIT(event_idx);
 1012df4:	2701      	movs	r7, #1
		if (nrfx_vipm_data.callback[event_idx] != NULL) {
 1012df6:	4d0b      	ldr	r5, [pc, #44]	; (1012e24 <vipm_dispatcher+0x34>)
	while (event_mask) {
 1012df8:	b904      	cbnz	r4, 1012dfc <vipm_dispatcher+0xc>
}
 1012dfa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  uint32_t result;

#if ((defined (__ARM_ARCH_7M__      ) && (__ARM_ARCH_7M__      == 1)) || \
     (defined (__ARM_ARCH_7EM__     ) && (__ARM_ARCH_7EM__     == 1)) || \
     (defined (__ARM_ARCH_8M_MAIN__ ) && (__ARM_ARCH_8M_MAIN__ == 1))    )
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 1012dfc:	fa94 f3a4 	rbit	r3, r4
   */
  if (value == 0U)
  {
    return 32U;
  }
  return __builtin_clz(value);
 1012e00:	fab3 f383 	clz	r3, r3
		if (nrfx_vipm_data.callback[event_idx] != NULL) {
 1012e04:	f855 6023 	ldr.w	r6, [r5, r3, lsl #2]
		event_mask &= ~BIT(event_idx);
 1012e08:	fa07 f203 	lsl.w	r2, r7, r3
 1012e0c:	ea24 0402 	bic.w	r4, r4, r2
		if (nrfx_vipm_data.callback[event_idx] != NULL) {
 1012e10:	2e00      	cmp	r6, #0
 1012e12:	d0f1      	beq.n	1012df8 <vipm_dispatcher+0x8>
			nrfx_vipm_data.callback[event_idx]
 1012e14:	2200      	movs	r2, #0
 1012e16:	3310      	adds	r3, #16
 1012e18:	4611      	mov	r1, r2
 1012e1a:	f855 0023 	ldr.w	r0, [r5, r3, lsl #2]
 1012e1e:	47b0      	blx	r6
 1012e20:	e7ea      	b.n	1012df8 <vipm_dispatcher+0x8>
 1012e22:	bf00      	nop
 1012e24:	21003f68 	.word	0x21003f68

01012e28 <vipm_nrf_1_send>:
UTIL_LISTIFY(NRFX_IPC_ID_MAX_VALUE, VIPM_DEVICE, _);
 1012e28:	2a10      	cmp	r2, #16
 1012e2a:	b508      	push	{r3, lr}
 1012e2c:	d81c      	bhi.n	1012e68 <vipm_nrf_1_send+0x40>
 1012e2e:	b14a      	cbz	r2, 1012e44 <vipm_nrf_1_send+0x1c>
 1012e30:	490f      	ldr	r1, [pc, #60]	; (1012e70 <vipm_nrf_1_send+0x48>)
 1012e32:	4b10      	ldr	r3, [pc, #64]	; (1012e74 <vipm_nrf_1_send+0x4c>)
 1012e34:	4810      	ldr	r0, [pc, #64]	; (1012e78 <vipm_nrf_1_send+0x50>)
 1012e36:	1ac9      	subs	r1, r1, r3
 1012e38:	08c9      	lsrs	r1, r1, #3
 1012e3a:	0189      	lsls	r1, r1, #6
 1012e3c:	f041 0102 	orr.w	r1, r1, #2
 1012e40:	f002 faa5 	bl	101538e <log_0>
 1012e44:	9b02      	ldr	r3, [sp, #8]
 1012e46:	2b00      	cmp	r3, #0
 1012e48:	dd09      	ble.n	1012e5e <vipm_nrf_1_send+0x36>
 1012e4a:	4909      	ldr	r1, [pc, #36]	; (1012e70 <vipm_nrf_1_send+0x48>)
 1012e4c:	4b09      	ldr	r3, [pc, #36]	; (1012e74 <vipm_nrf_1_send+0x4c>)
 1012e4e:	480b      	ldr	r0, [pc, #44]	; (1012e7c <vipm_nrf_1_send+0x54>)
 1012e50:	1ac9      	subs	r1, r1, r3
 1012e52:	08c9      	lsrs	r1, r1, #3
 1012e54:	0189      	lsls	r1, r1, #6
 1012e56:	f041 0102 	orr.w	r1, r1, #2
 1012e5a:	f002 fa98 	bl	101538e <log_0>

#ifndef NRF_DECLARE_ONLY

NRF_STATIC_INLINE void nrf_ipc_task_trigger(NRF_IPC_Type * p_reg, nrf_ipc_task_t task)
{
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1012e5e:	2201      	movs	r2, #1
 1012e60:	2000      	movs	r0, #0
 1012e62:	4b07      	ldr	r3, [pc, #28]	; (1012e80 <vipm_nrf_1_send+0x58>)
 1012e64:	601a      	str	r2, [r3, #0]
 1012e66:	bd08      	pop	{r3, pc}
 1012e68:	f06f 0015 	mvn.w	r0, #21
 1012e6c:	e7fb      	b.n	1012e66 <vipm_nrf_1_send+0x3e>
 1012e6e:	bf00      	nop
 1012e70:	010181a0 	.word	0x010181a0
 1012e74:	010180b8 	.word	0x010180b8
 1012e78:	01019840 	.word	0x01019840
 1012e7c:	01019874 	.word	0x01019874
 1012e80:	41012004 	.word	0x41012004

01012e84 <uarte_nrfx_configure>:
	return 0;
}

static int uarte_nrfx_configure(struct device *dev,
				const struct uart_config *cfg)
{
 1012e84:	b5f0      	push	{r4, r5, r6, r7, lr}
	nrf_uarte_config_t uarte_cfg;

#if defined(UARTE_CONFIG_STOP_Msk)
	switch (cfg->stop_bits) {
 1012e86:	794b      	ldrb	r3, [r1, #5]
 1012e88:	2b01      	cmp	r3, #1
 1012e8a:	d02b      	beq.n	1012ee4 <uarte_nrfx_configure+0x60>
 1012e8c:	2b03      	cmp	r3, #3
 1012e8e:	d126      	bne.n	1012ede <uarte_nrfx_configure+0x5a>
	case UART_CFG_STOP_BITS_1:
		uarte_cfg.stop = NRF_UARTE_STOP_ONE;
		break;
	case UART_CFG_STOP_BITS_2:
		uarte_cfg.stop = NRF_UARTE_STOP_TWO;
 1012e90:	2710      	movs	r7, #16
	if (cfg->stop_bits != UART_CFG_STOP_BITS_1) {
		return -ENOTSUP;
	}
#endif

	if (cfg->data_bits != UART_CFG_DATA_BITS_8) {
 1012e92:	798b      	ldrb	r3, [r1, #6]
 1012e94:	2b03      	cmp	r3, #3
 1012e96:	d122      	bne.n	1012ede <uarte_nrfx_configure+0x5a>
		return -ENOTSUP;
	}

	switch (cfg->flow_ctrl) {
 1012e98:	79cd      	ldrb	r5, [r1, #7]
 1012e9a:	b125      	cbz	r5, 1012ea6 <uarte_nrfx_configure+0x22>
 1012e9c:	2d01      	cmp	r5, #1
 1012e9e:	d11e      	bne.n	1012ede <uarte_nrfx_configure+0x5a>
	case UART_CFG_FLOW_CTRL_NONE:
		uarte_cfg.hwfc = NRF_UARTE_HWFC_DISABLED;
		break;
	case UART_CFG_FLOW_CTRL_RTS_CTS:
		if (get_dev_config(dev)->rts_cts_pins_set) {
 1012ea0:	6843      	ldr	r3, [r0, #4]
 1012ea2:	791b      	ldrb	r3, [r3, #4]
 1012ea4:	b1db      	cbz	r3, 1012ede <uarte_nrfx_configure+0x5a>
	}

#if defined(UARTE_CONFIG_PARITYTYPE_Msk)
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
#endif
	switch (cfg->parity) {
 1012ea6:	790a      	ldrb	r2, [r1, #4]
 1012ea8:	2a01      	cmp	r2, #1
 1012eaa:	d01d      	beq.n	1012ee8 <uarte_nrfx_configure+0x64>
 1012eac:	2a02      	cmp	r2, #2
 1012eae:	d01f      	beq.n	1012ef0 <uarte_nrfx_configure+0x6c>
 1012eb0:	b9aa      	cbnz	r2, 1012ede <uarte_nrfx_configure+0x5a>
 1012eb2:	4614      	mov	r4, r2
#endif
	default:
		return -ENOTSUP;
	}

	if (baudrate_set(dev, cfg->baudrate) != 0) {
 1012eb4:	680b      	ldr	r3, [r1, #0]
	return config->uarte_regs;
 1012eb6:	6846      	ldr	r6, [r0, #4]
	switch (baudrate) {
 1012eb8:	f5b3 4f16 	cmp.w	r3, #38400	; 0x9600
	return config->uarte_regs;
 1012ebc:	6836      	ldr	r6, [r6, #0]
	switch (baudrate) {
 1012ebe:	d06d      	beq.n	1012f9c <uarte_nrfx_configure+0x118>
 1012ec0:	d833      	bhi.n	1012f2a <uarte_nrfx_configure+0xa6>
 1012ec2:	f5b3 5f16 	cmp.w	r3, #9600	; 0x2580
 1012ec6:	d06c      	beq.n	1012fa2 <uarte_nrfx_configure+0x11e>
 1012ec8:	d81c      	bhi.n	1012f04 <uarte_nrfx_configure+0x80>
 1012eca:	f5b3 6f96 	cmp.w	r3, #1200	; 0x4b0
 1012ece:	d06a      	beq.n	1012fa6 <uarte_nrfx_configure+0x122>
 1012ed0:	d810      	bhi.n	1012ef4 <uarte_nrfx_configure+0x70>
 1012ed2:	f5b3 7f96 	cmp.w	r3, #300	; 0x12c
 1012ed6:	d069      	beq.n	1012fac <uarte_nrfx_configure+0x128>
 1012ed8:	f5b3 7f16 	cmp.w	r3, #600	; 0x258
 1012edc:	d069      	beq.n	1012fb2 <uarte_nrfx_configure+0x12e>
 1012ede:	f06f 0022 	mvn.w	r0, #34	; 0x22
 1012ee2:	e05a      	b.n	1012f9a <uarte_nrfx_configure+0x116>
	switch (cfg->stop_bits) {
 1012ee4:	2700      	movs	r7, #0
 1012ee6:	e7d4      	b.n	1012e92 <uarte_nrfx_configure+0xe>
		uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_ODD;
 1012ee8:	f44f 7480 	mov.w	r4, #256	; 0x100
		uarte_cfg.parity = NRF_UARTE_PARITY_INCLUDED;
 1012eec:	220e      	movs	r2, #14
 1012eee:	e7e1      	b.n	1012eb4 <uarte_nrfx_configure+0x30>
	uarte_cfg.paritytype = NRF_UARTE_PARITYTYPE_EVEN;
 1012ef0:	2400      	movs	r4, #0
 1012ef2:	e7fb      	b.n	1012eec <uarte_nrfx_configure+0x68>
	switch (baudrate) {
 1012ef4:	f5b3 6f16 	cmp.w	r3, #2400	; 0x960
 1012ef8:	d05e      	beq.n	1012fb8 <uarte_nrfx_configure+0x134>
 1012efa:	f5b3 5f96 	cmp.w	r3, #4800	; 0x12c0
 1012efe:	d1ee      	bne.n	1012ede <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_4800;
 1012f00:	4b38      	ldr	r3, [pc, #224]	; (1012fe4 <uarte_nrfx_configure+0x160>)
 1012f02:	e03e      	b.n	1012f82 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
 1012f04:	f5b3 4fe1 	cmp.w	r3, #28800	; 0x7080
 1012f08:	d059      	beq.n	1012fbe <uarte_nrfx_configure+0x13a>
 1012f0a:	d807      	bhi.n	1012f1c <uarte_nrfx_configure+0x98>
 1012f0c:	f5b3 5f61 	cmp.w	r3, #14400	; 0x3840
 1012f10:	d057      	beq.n	1012fc2 <uarte_nrfx_configure+0x13e>
 1012f12:	f5b3 4f96 	cmp.w	r3, #19200	; 0x4b00
 1012f16:	d1e2      	bne.n	1012ede <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_19200;
 1012f18:	4b33      	ldr	r3, [pc, #204]	; (1012fe8 <uarte_nrfx_configure+0x164>)
 1012f1a:	e032      	b.n	1012f82 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
 1012f1c:	f647 2c12 	movw	ip, #31250	; 0x7a12
 1012f20:	4563      	cmp	r3, ip
 1012f22:	d1dc      	bne.n	1012ede <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_31250;
 1012f24:	f44f 0300 	mov.w	r3, #8388608	; 0x800000
 1012f28:	e02b      	b.n	1012f82 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
 1012f2a:	f5b3 3f61 	cmp.w	r3, #230400	; 0x38400
 1012f2e:	d04a      	beq.n	1012fc6 <uarte_nrfx_configure+0x142>
 1012f30:	d813      	bhi.n	1012f5a <uarte_nrfx_configure+0xd6>
 1012f32:	f5b3 3f96 	cmp.w	r3, #76800	; 0x12c00
 1012f36:	d049      	beq.n	1012fcc <uarte_nrfx_configure+0x148>
 1012f38:	d809      	bhi.n	1012f4e <uarte_nrfx_configure+0xca>
 1012f3a:	f64d 2cc0 	movw	ip, #56000	; 0xdac0
 1012f3e:	4563      	cmp	r3, ip
 1012f40:	d046      	beq.n	1012fd0 <uarte_nrfx_configure+0x14c>
 1012f42:	f5b3 4f61 	cmp.w	r3, #57600	; 0xe100
 1012f46:	d1ca      	bne.n	1012ede <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_57600;
 1012f48:	f44f 036b 	mov.w	r3, #15400960	; 0xeb0000
 1012f4c:	e019      	b.n	1012f82 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
 1012f4e:	f5b3 3fe1 	cmp.w	r3, #115200	; 0x1c200
 1012f52:	d1c4      	bne.n	1012ede <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_115200;
 1012f54:	f04f 73eb 	mov.w	r3, #30801920	; 0x1d60000
 1012f58:	e013      	b.n	1012f82 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
 1012f5a:	f5b3 2f61 	cmp.w	r3, #921600	; 0xe1000
 1012f5e:	d03a      	beq.n	1012fd6 <uarte_nrfx_configure+0x152>
 1012f60:	d809      	bhi.n	1012f76 <uarte_nrfx_configure+0xf2>
 1012f62:	f8df c098 	ldr.w	ip, [pc, #152]	; 1012ffc <uarte_nrfx_configure+0x178>
 1012f66:	4563      	cmp	r3, ip
 1012f68:	d038      	beq.n	1012fdc <uarte_nrfx_configure+0x158>
 1012f6a:	f5b3 2fe1 	cmp.w	r3, #460800	; 0x70800
 1012f6e:	d1b6      	bne.n	1012ede <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_460800;
 1012f70:	f04f 63e8 	mov.w	r3, #121634816	; 0x7400000
 1012f74:	e005      	b.n	1012f82 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
 1012f76:	f8df c088 	ldr.w	ip, [pc, #136]	; 1013000 <uarte_nrfx_configure+0x17c>
 1012f7a:	4563      	cmp	r3, ip
 1012f7c:	d1af      	bne.n	1012ede <uarte_nrfx_configure+0x5a>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1000000;
 1012f7e:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
                    | (uint32_t)p_cfg->hwfc;
}

NRF_STATIC_INLINE void nrf_uarte_baudrate_set(NRF_UARTE_Type * p_reg, nrf_uarte_baudrate_t baudrate)
{
    p_reg->BAUDRATE = baudrate;
 1012f82:	f8c6 3524 	str.w	r3, [r6, #1316]	; 0x524
                    | (uint32_t)p_cfg->hwfc;
 1012f86:	432c      	orrs	r4, r5
		return -ENOTSUP;
	}

	nrf_uarte_configure(get_uarte_instance(dev), &uarte_cfg);

	get_dev_data(dev)->uart_config = *cfg;
 1012f88:	68c3      	ldr	r3, [r0, #12]
                    | (uint32_t)p_cfg->stop
 1012f8a:	433a      	orrs	r2, r7
                    | (uint32_t)p_cfg->hwfc;
 1012f8c:	4322      	orrs	r2, r4
 1012f8e:	c903      	ldmia	r1, {r0, r1}
    p_reg->CONFIG = (uint32_t)p_cfg->parity
 1012f90:	f8c6 256c 	str.w	r2, [r6, #1388]	; 0x56c
 1012f94:	e883 0003 	stmia.w	r3, {r0, r1}

	return 0;
 1012f98:	2000      	movs	r0, #0
}
 1012f9a:	bdf0      	pop	{r4, r5, r6, r7, pc}
		nrf_baudrate = NRF_UARTE_BAUDRATE_38400;
 1012f9c:	f44f 031d 	mov.w	r3, #10289152	; 0x9d0000
 1012fa0:	e7ef      	b.n	1012f82 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_9600;
 1012fa2:	4b12      	ldr	r3, [pc, #72]	; (1012fec <uarte_nrfx_configure+0x168>)
 1012fa4:	e7ed      	b.n	1012f82 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_1200;
 1012fa6:	f44f 239e 	mov.w	r3, #323584	; 0x4f000
 1012faa:	e7ea      	b.n	1012f82 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = 0x00014000;
 1012fac:	f44f 33a0 	mov.w	r3, #81920	; 0x14000
 1012fb0:	e7e7      	b.n	1012f82 <uarte_nrfx_configure+0xfe>
	switch (baudrate) {
 1012fb2:	f44f 331c 	mov.w	r3, #159744	; 0x27000
 1012fb6:	e7e4      	b.n	1012f82 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_2400;
 1012fb8:	f44f 231d 	mov.w	r3, #643072	; 0x9d000
 1012fbc:	e7e1      	b.n	1012f82 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_28800;
 1012fbe:	4b0c      	ldr	r3, [pc, #48]	; (1012ff0 <uarte_nrfx_configure+0x16c>)
 1012fc0:	e7df      	b.n	1012f82 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_14400;
 1012fc2:	4b0c      	ldr	r3, [pc, #48]	; (1012ff4 <uarte_nrfx_configure+0x170>)
 1012fc4:	e7dd      	b.n	1012f82 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_230400;
 1012fc6:	f04f 736c 	mov.w	r3, #61865984	; 0x3b00000
 1012fca:	e7da      	b.n	1012f82 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_76800;
 1012fcc:	4b0a      	ldr	r3, [pc, #40]	; (1012ff8 <uarte_nrfx_configure+0x174>)
 1012fce:	e7d8      	b.n	1012f82 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_56000;
 1012fd0:	f44f 0365 	mov.w	r3, #15007744	; 0xe50000
 1012fd4:	e7d5      	b.n	1012f82 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_921600;
 1012fd6:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
 1012fda:	e7d2      	b.n	1012f82 <uarte_nrfx_configure+0xfe>
		nrf_baudrate = NRF_UARTE_BAUDRATE_250000;
 1012fdc:	f04f 6380 	mov.w	r3, #67108864	; 0x4000000
 1012fe0:	e7cf      	b.n	1012f82 <uarte_nrfx_configure+0xfe>
 1012fe2:	bf00      	nop
 1012fe4:	0013b000 	.word	0x0013b000
 1012fe8:	004ea000 	.word	0x004ea000
 1012fec:	00275000 	.word	0x00275000
 1012ff0:	0075c000 	.word	0x0075c000
 1012ff4:	003af000 	.word	0x003af000
 1012ff8:	013a9000 	.word	0x013a9000
 1012ffc:	0003d090 	.word	0x0003d090
 1013000:	000f4240 	.word	0x000f4240

01013004 <uarte_0_init>:
	return config->uarte_regs;
 1013004:	6842      	ldr	r2, [r0, #4]
				.tx_buffer = uarte##idx##_tx_buffer,	       \
				.tx_buff_size = sizeof(uarte##idx##_tx_buffer),\
			};))

#ifdef CONFIG_UART_0_NRF_UARTE
UART_NRF_UARTE_DEVICE(0);
 1013006:	b570      	push	{r4, r5, r6, lr}
	return config->uarte_regs;
 1013008:	6814      	ldr	r4, [r2, #0]
    p_reg->OUTSET = set_mask;
 101300a:	f04f 7200 	mov.w	r2, #33554432	; 0x2000000
 101300e:	4b16      	ldr	r3, [pc, #88]	; (1013068 <uarte_0_init+0x64>)
	struct uarte_nrfx_data *data = get_dev_data(dev);
 1013010:	68c5      	ldr	r5, [r0, #12]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
 1013012:	2103      	movs	r1, #3
    p_reg->OUTSET = set_mask;
 1013014:	609a      	str	r2, [r3, #8]
    p_reg->PSEL.TXD = pseltxd;
 1013016:	2619      	movs	r6, #25
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
 1013018:	2200      	movs	r2, #0
 101301a:	f8c3 1264 	str.w	r1, [r3, #612]	; 0x264
 101301e:	f8c3 2268 	str.w	r2, [r3, #616]	; 0x268
 1013022:	f8c4 650c 	str.w	r6, [r4, #1292]	; 0x50c
    p_reg->PSEL.RXD = pselrxd;
 1013026:	261a      	movs	r6, #26
 1013028:	f8c4 6514 	str.w	r6, [r4, #1300]	; 0x514
    p_reg->OUTSET = set_mask;
 101302c:	f44f 6680 	mov.w	r6, #1024	; 0x400
 1013030:	609e      	str	r6, [r3, #8]
    reg->PIN_CNF[pin_number] = ((uint32_t)dir << GPIO_PIN_CNF_DIR_Pos)
 1013032:	f8c3 1228 	str.w	r1, [r3, #552]	; 0x228
 1013036:	f8c3 2230 	str.w	r2, [r3, #560]	; 0x230
    p_reg->PSEL.RTS = pselrts;
 101303a:	230a      	movs	r3, #10
 101303c:	f8c4 3508 	str.w	r3, [r4, #1288]	; 0x508
    p_reg->PSEL.CTS = pselcts;
 1013040:	230c      	movs	r3, #12
	err = uarte_nrfx_configure(dev, &get_dev_data(dev)->uart_config);
 1013042:	4629      	mov	r1, r5
 1013044:	f8c4 3510 	str.w	r3, [r4, #1296]	; 0x510
 1013048:	f7ff ff1c 	bl	1012e84 <uarte_nrfx_configure>
	if (err) {
 101304c:	b958      	cbnz	r0, 1013066 <uarte_0_init+0x62>
    p_reg->ENABLE = UARTE_ENABLE_ENABLE_Enabled;
 101304e:	2308      	movs	r3, #8
 1013050:	f8c4 3500 	str.w	r3, [r4, #1280]	; 0x500
NRF_STATIC_INLINE void nrf_uarte_rx_buffer_set(NRF_UARTE_Type * p_reg,
                                               uint8_t *        p_buffer,
                                               size_t           length)
{
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
    p_reg->RXD.MAXCNT = length;
 1013054:	2301      	movs	r3, #1
		nrf_uarte_rx_buffer_set(uarte, &data->rx_data, 1);
 1013056:	350c      	adds	r5, #12
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 1013058:	f8c4 0110 	str.w	r0, [r4, #272]	; 0x110
    p_reg->RXD.PTR    = (uint32_t)p_buffer;
 101305c:	f8c4 5534 	str.w	r5, [r4, #1332]	; 0x534
    p_reg->RXD.MAXCNT = length;
 1013060:	f8c4 3538 	str.w	r3, [r4, #1336]	; 0x538
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1013064:	6023      	str	r3, [r4, #0]
UART_NRF_UARTE_DEVICE(0);
 1013066:	bd70      	pop	{r4, r5, r6, pc}
 1013068:	418c0500 	.word	0x418c0500

0101306c <random_byte_get>:
	__asm__ volatile(
 101306c:	f04f 0320 	mov.w	r3, #32
 1013070:	f3ef 8211 	mrs	r2, BASEPRI
 1013074:	f383 8811 	msr	BASEPRI, r3
 1013078:	f3bf 8f6f 	isb	sy
#endif
}

NRF_STATIC_INLINE bool nrf_rng_event_check(NRF_RNG_Type const * p_reg, nrf_rng_event_t rng_event)
{
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
 101307c:	4b08      	ldr	r3, [pc, #32]	; (10130a0 <random_byte_get+0x34>)
 101307e:	6819      	ldr	r1, [r3, #0]
	int retval = -EAGAIN;
	unsigned int key;

	key = irq_lock();

	if (nrf_rng_event_check(NRF_RNG, NRF_RNG_EVENT_VALRDY)) {
 1013080:	b151      	cbz	r1, 1013098 <random_byte_get+0x2c>
     p_reg->SHORTS &= ~mask;
}

NRF_STATIC_INLINE uint8_t nrf_rng_random_value_get(NRF_RNG_Type const * p_reg)
{
    return (uint8_t)(p_reg->VALUE & RNG_VALUE_VALUE_Msk);
 1013082:	4908      	ldr	r1, [pc, #32]	; (10130a4 <random_byte_get+0x38>)
 1013084:	f8d1 0508 	ldr.w	r0, [r1, #1288]	; 0x508
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
 1013088:	2100      	movs	r1, #0
		retval = nrf_rng_random_value_get(NRF_RNG);
 101308a:	b2c0      	uxtb	r0, r0
 101308c:	6019      	str	r1, [r3, #0]
	__asm__ volatile(
 101308e:	f382 8811 	msr	BASEPRI, r2
 1013092:	f3bf 8f6f 	isb	sy
	}

	irq_unlock(key);

	return retval;
}
 1013096:	4770      	bx	lr
	int retval = -EAGAIN;
 1013098:	f06f 000a 	mvn.w	r0, #10
 101309c:	e7f7      	b.n	101308e <random_byte_get+0x22>
 101309e:	bf00      	nop
 10130a0:	41009100 	.word	0x41009100
 10130a4:	41009000 	.word	0x41009000

010130a8 <rng_pool_get>:
#pragma GCC push_options
#if defined(CONFIG_BT_CTLR_FAST_ENC)
#pragma GCC optimize ("Ofast")
#endif
static u16_t rng_pool_get(struct rng_pool *rngp, u8_t *buf, u16_t len)
{
 10130a8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 10130ac:	4604      	mov	r4, r0
	u32_t last  = rngp->last;
 10130ae:	f890 c002 	ldrb.w	ip, [r0, #2]
	u32_t mask  = rngp->mask;
 10130b2:	78c6      	ldrb	r6, [r0, #3]
	__asm__ volatile(
 10130b4:	f04f 0320 	mov.w	r3, #32
 10130b8:	f3ef 8511 	mrs	r5, BASEPRI
 10130bc:	f383 8811 	msr	BASEPRI, r3
 10130c0:	f3bf 8f6f 	isb	sy
	u32_t first, available;
	u32_t other_read_in_progress;
	unsigned int key;

	key = irq_lock();
	first = rngp->first_alloc;
 10130c4:	f890 e000 	ldrb.w	lr, [r0]
	/*
	 * The other_read_in_progress is non-zero if rngp->first_read != first,
	 * which means that lower-priority code (which was interrupted by this
	 * call) already allocated area for read.
	 */
	other_read_in_progress = (rngp->first_read ^ first);
 10130c8:	f890 8001 	ldrb.w	r8, [r0, #1]

	available = (last - first) & mask;
 10130cc:	ebac 0c0e 	sub.w	ip, ip, lr
 10130d0:	ea0c 0c06 	and.w	ip, ip, r6
	if (available < len) {
 10130d4:	4562      	cmp	r2, ip
 10130d6:	bf94      	ite	ls
 10130d8:	4610      	movls	r0, r2
		len = available;
 10130da:	fa1f f08c 	uxthhi.w	r0, ip

	/*
	 * Move alloc index forward to signal, that part of the buffer is
	 * now reserved for this call.
	 */
	rngp->first_alloc = (first + len) & mask;
 10130de:	eb0e 0200 	add.w	r2, lr, r0
 10130e2:	4032      	ands	r2, r6
	first = rngp->first_alloc;
 10130e4:	4673      	mov	r3, lr
	rngp->first_alloc = (first + len) & mask;
 10130e6:	7022      	strb	r2, [r4, #0]
	__asm__ volatile(
 10130e8:	f385 8811 	msr	BASEPRI, r5
 10130ec:	f3bf 8f6f 	isb	sy
	irq_unlock(key);

	while (likely(len--)) {
 10130f0:	1e42      	subs	r2, r0, #1
 10130f2:	b292      	uxth	r2, r2
 10130f4:	b168      	cbz	r0, 1013112 <rng_pool_get+0x6a>
 10130f6:	3201      	adds	r2, #1
 10130f8:	188f      	adds	r7, r1, r2
		*dst++ = rngp->buffer[first];
 10130fa:	18e5      	adds	r5, r4, r3
 10130fc:	796d      	ldrb	r5, [r5, #5]
		first = (first + 1) & mask;
 10130fe:	3301      	adds	r3, #1
		*dst++ = rngp->buffer[first];
 1013100:	f801 5b01 	strb.w	r5, [r1], #1
	while (likely(len--)) {
 1013104:	42b9      	cmp	r1, r7
		first = (first + 1) & mask;
 1013106:	ea03 0306 	and.w	r3, r3, r6
	while (likely(len--)) {
 101310a:	d1f6      	bne.n	10130fa <rng_pool_get+0x52>
 101310c:	b292      	uxth	r2, r2
 101310e:	ebac 0c02 	sub.w	ip, ip, r2
	/*
	 * If this call is the last one accessing the pool, move read index
	 * to signal that all allocated regions are now read and could be
	 * overwritten.
	 */
	if (likely(!other_read_in_progress)) {
 1013112:	45c6      	cmp	lr, r8
 1013114:	d10d      	bne.n	1013132 <rng_pool_get+0x8a>
	__asm__ volatile(
 1013116:	f04f 0220 	mov.w	r2, #32
 101311a:	f3ef 8311 	mrs	r3, BASEPRI
 101311e:	f382 8811 	msr	BASEPRI, r2
 1013122:	f3bf 8f6f 	isb	sy
		key = irq_lock();
		rngp->first_read = rngp->first_alloc;
 1013126:	7822      	ldrb	r2, [r4, #0]
 1013128:	7062      	strb	r2, [r4, #1]
	__asm__ volatile(
 101312a:	f383 8811 	msr	BASEPRI, r3
 101312e:	f3bf 8f6f 	isb	sy
		irq_unlock(key);
	}

	len = dst - buf;
	available = available - len;
	if (available <= rngp->threshold) {
 1013132:	7923      	ldrb	r3, [r4, #4]
 1013134:	4563      	cmp	r3, ip
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
 1013136:	bf22      	ittt	cs
 1013138:	2201      	movcs	r2, #1
 101313a:	4b02      	ldrcs	r3, [pc, #8]	; (1013144 <rng_pool_get+0x9c>)
 101313c:	601a      	strcs	r2, [r3, #0]
		nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);
	}

	return len;
}
 101313e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 1013142:	bf00      	nop
 1013144:	41009000 	.word	0x41009000

01013148 <entropy_nrf5_get_entropy_isr>:
	u16_t cnt = len;

	/* Check if this API is called on correct driver instance. */
	__ASSERT_NO_MSG(&entropy_nrf5_data == DEV_DATA(dev));

	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
 1013148:	43db      	mvns	r3, r3
{
 101314a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
 101314e:	f013 0501 	ands.w	r5, r3, #1
{
 1013152:	460e      	mov	r6, r1
 1013154:	4614      	mov	r4, r2
	if (likely((flags & ENTROPY_BUSYWAIT) == 0U)) {
 1013156:	d004      	beq.n	1013162 <entropy_nrf5_get_entropy_isr+0x1a>
		return rng_pool_get((struct rng_pool *)(entropy_nrf5_data.isr),
 1013158:	481d      	ldr	r0, [pc, #116]	; (10131d0 <entropy_nrf5_get_entropy_isr+0x88>)
 101315a:	f7ff ffa5 	bl	10130a8 <rng_pool_get>
			irq_enable(IRQN);
		}
	}

	return cnt;
}
 101315e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	if (len) {
 1013162:	b37a      	cbz	r2, 10131c4 <entropy_nrf5_get_entropy_isr+0x7c>
	__asm__ volatile(
 1013164:	f04f 0320 	mov.w	r3, #32
 1013168:	f3ef 8811 	mrs	r8, BASEPRI
 101316c:	f383 8811 	msr	BASEPRI, r3
 1013170:	f3bf 8f6f 	isb	sy
		irq_enabled = irq_is_enabled(IRQN);
 1013174:	2009      	movs	r0, #9
 1013176:	f7f1 fdf1 	bl	1004d5c <arch_irq_is_enabled>
 101317a:	4607      	mov	r7, r0
		irq_disable(IRQN);
 101317c:	2009      	movs	r0, #9
 101317e:	f7f1 fdd9 	bl	1004d34 <arch_irq_disable>
	__asm__ volatile(
 1013182:	f388 8811 	msr	BASEPRI, r8
 1013186:	f3bf 8f6f 	isb	sy
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
 101318a:	4b12      	ldr	r3, [pc, #72]	; (10131d4 <entropy_nrf5_get_entropy_isr+0x8c>)
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
 101318c:	2101      	movs	r1, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
 101318e:	601d      	str	r5, [r3, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
 1013190:	4698      	mov	r8, r3
}
 1013192:	4625      	mov	r5, r4
    NVIC->ICPR[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 1013194:	f44f 7a00 	mov.w	sl, #512	; 0x200
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
 1013198:	4a0f      	ldr	r2, [pc, #60]	; (10131d8 <entropy_nrf5_get_entropy_isr+0x90>)
 101319a:	f8df 9040 	ldr.w	r9, [pc, #64]	; 10131dc <entropy_nrf5_get_entropy_isr+0x94>
 101319e:	6011      	str	r1, [r2, #0]
    return (bool) * ((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event));
 10131a0:	f8d8 3000 	ldr.w	r3, [r8]
			while (!nrf_rng_event_check(NRF_RNG,
 10131a4:	b183      	cbz	r3, 10131c8 <entropy_nrf5_get_entropy_isr+0x80>
			byte = random_byte_get();
 10131a6:	f7ff ff61 	bl	101306c <random_byte_get>
			if (byte < 0) {
 10131aa:	1e03      	subs	r3, r0, #0
 10131ac:	f8c9 a180 	str.w	sl, [r9, #384]	; 0x180
 10131b0:	dbf6      	blt.n	10131a0 <entropy_nrf5_get_entropy_isr+0x58>
 10131b2:	3d01      	subs	r5, #1
 10131b4:	b2ad      	uxth	r5, r5
			buf[--len] = byte;
 10131b6:	5573      	strb	r3, [r6, r5]
		} while (len);
 10131b8:	2d00      	cmp	r5, #0
 10131ba:	d1f1      	bne.n	10131a0 <entropy_nrf5_get_entropy_isr+0x58>
		if (irq_enabled) {
 10131bc:	b117      	cbz	r7, 10131c4 <entropy_nrf5_get_entropy_isr+0x7c>
			irq_enable(IRQN);
 10131be:	2009      	movs	r0, #9
 10131c0:	f7f1 fda8 	bl	1004d14 <arch_irq_enable>
	return cnt;
 10131c4:	4620      	mov	r0, r4
 10131c6:	e7ca      	b.n	101315e <entropy_nrf5_get_entropy_isr+0x16>
				__WFE();
 10131c8:	bf20      	wfe
				__SEV();
 10131ca:	bf40      	sev
				__WFE();
 10131cc:	bf20      	wfe
 10131ce:	e7e7      	b.n	10131a0 <entropy_nrf5_get_entropy_isr+0x58>
 10131d0:	21004020 	.word	0x21004020
 10131d4:	41009100 	.word	0x41009100
 10131d8:	41009000 	.word	0x41009000
 10131dc:	e000e100 	.word	0xe000e100

010131e0 <entropy_nrf5_get_entropy>:
{
 10131e0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 10131e4:	460d      	mov	r5, r1
 10131e6:	4614      	mov	r4, r2
	return z_impl_k_sem_take(sem, timeout);
 10131e8:	4f12      	ldr	r7, [pc, #72]	; (1013234 <entropy_nrf5_get_entropy+0x54>)
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
 10131ea:	f107 0845 	add.w	r8, r7, #69	; 0x45
 10131ee:	f107 0918 	add.w	r9, r7, #24
	while (len) {
 10131f2:	b914      	cbnz	r4, 10131fa <entropy_nrf5_get_entropy+0x1a>
}
 10131f4:	4620      	mov	r0, r4
 10131f6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 10131fa:	f04f 33ff 	mov.w	r3, #4294967295
 10131fe:	f04f 32ff 	mov.w	r2, #4294967295
 1013202:	4638      	mov	r0, r7
 1013204:	f001 fa46 	bl	1014694 <z_impl_k_sem_take>
		bytes = rng_pool_get((struct rng_pool *)(entropy_nrf5_data.thr),
 1013208:	4622      	mov	r2, r4
 101320a:	4629      	mov	r1, r5
 101320c:	4640      	mov	r0, r8
 101320e:	f7ff ff4b 	bl	10130a8 <rng_pool_get>
 1013212:	4606      	mov	r6, r0
	z_impl_k_sem_give(sem);
 1013214:	4638      	mov	r0, r7
 1013216:	f001 fa17 	bl	1014648 <z_impl_k_sem_give>
		if (bytes == 0U) {
 101321a:	b93e      	cbnz	r6, 101322c <entropy_nrf5_get_entropy+0x4c>
	return z_impl_k_sem_take(sem, timeout);
 101321c:	f04f 32ff 	mov.w	r2, #4294967295
 1013220:	f04f 33ff 	mov.w	r3, #4294967295
 1013224:	4648      	mov	r0, r9
 1013226:	f001 fa35 	bl	1014694 <z_impl_k_sem_take>
			continue;
 101322a:	e7e2      	b.n	10131f2 <entropy_nrf5_get_entropy+0x12>
		len -= bytes;
 101322c:	1ba4      	subs	r4, r4, r6
 101322e:	b2a4      	uxth	r4, r4
		buf += bytes;
 1013230:	4435      	add	r5, r6
 1013232:	e7de      	b.n	10131f2 <entropy_nrf5_get_entropy+0x12>
 1013234:	21003ff0 	.word	0x21003ff0

01013238 <entropy_nrf5_init>:
		    entropy_nrf5_init, &entropy_nrf5_data, NULL,
		    PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_DEVICE,
		    &entropy_nrf5_api_funcs);

static int entropy_nrf5_init(struct device *device)
{
 1013238:	b538      	push	{r3, r4, r5, lr}
	return z_impl_k_sem_init(sem, initial_count, limit);
 101323a:	2201      	movs	r2, #1
 101323c:	4c17      	ldr	r4, [pc, #92]	; (101329c <entropy_nrf5_init+0x64>)
 101323e:	4611      	mov	r1, r2
 1013240:	4620      	mov	r0, r4
 1013242:	f004 fc41 	bl	1017ac8 <z_impl_k_sem_init>
 1013246:	2201      	movs	r2, #1
 1013248:	2100      	movs	r1, #0
 101324a:	f104 0018 	add.w	r0, r4, #24
 101324e:	f004 fc3b 	bl	1017ac8 <z_impl_k_sem_init>
	rngp->mask	  = size - 1;
 1013252:	f240 4307 	movw	r3, #1031	; 0x407
 1013256:	f8a4 3048 	strh.w	r3, [r4, #72]	; 0x48
	rngp->first_alloc = 0U;
 101325a:	f04f 6370 	mov.w	r3, #251658240	; 0xf000000
 101325e:	6323      	str	r3, [r4, #48]	; 0x30
	rngp->threshold	  = threshold;
 1013260:	230c      	movs	r3, #12
	rngp->first_alloc = 0U;
 1013262:	2500      	movs	r5, #0
    p_reg->INTENSET = mask;
 1013264:	2101      	movs	r1, #1
	rngp->threshold	  = threshold;
 1013266:	f884 3034 	strb.w	r3, [r4, #52]	; 0x34
}

NRF_STATIC_INLINE void nrf_rng_error_correction_enable(NRF_RNG_Type * p_reg)
{
    p_reg->CONFIG |= RNG_CONFIG_DERCEN_Msk;
 101326a:	4b0d      	ldr	r3, [pc, #52]	; (10132a0 <entropy_nrf5_init+0x68>)
	rngp->first_alloc = 0U;
 101326c:	f884 5045 	strb.w	r5, [r4, #69]	; 0x45
	rngp->first_read  = 0U;
 1013270:	f8a4 5046 	strh.w	r5, [r4, #70]	; 0x46
 1013274:	f8d3 2504 	ldr.w	r2, [r3, #1284]	; 0x504

	nrf_rng_event_clear(NRF_RNG, NRF_RNG_EVENT_VALRDY);
	nrf_rng_int_enable(NRF_RNG, NRF_RNG_INT_VALRDY_MASK);
	nrf_rng_task_trigger(NRF_RNG, NRF_RNG_TASK_START);

	IRQ_CONNECT(IRQN, IRQ_PRIO, isr, &entropy_nrf5_data, 0);
 1013278:	2009      	movs	r0, #9
 101327a:	f042 0201 	orr.w	r2, r2, #1
 101327e:	f8c3 2504 	str.w	r2, [r3, #1284]	; 0x504
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_event)) = 0x0UL;
 1013282:	4a08      	ldr	r2, [pc, #32]	; (10132a4 <entropy_nrf5_init+0x6c>)
 1013284:	6015      	str	r5, [r2, #0]
    p_reg->INTENSET = mask;
 1013286:	f8c3 1304 	str.w	r1, [r3, #772]	; 0x304
 101328a:	462a      	mov	r2, r5
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)rng_task)) = 0x1UL;
 101328c:	6019      	str	r1, [r3, #0]
 101328e:	f7f1 fd73 	bl	1004d78 <z_arm_irq_priority_set>
	irq_enable(IRQN);
 1013292:	2009      	movs	r0, #9
 1013294:	f7f1 fd3e 	bl	1004d14 <arch_irq_enable>

	return 0;
}
 1013298:	4628      	mov	r0, r5
 101329a:	bd38      	pop	{r3, r4, r5, pc}
 101329c:	21003ff0 	.word	0x21003ff0
 10132a0:	41009000 	.word	0x41009000
 10132a4:	41009100 	.word	0x41009100

010132a8 <isr>:
{
 10132a8:	b510      	push	{r4, lr}
	byte = random_byte_get();
 10132aa:	f7ff fedf 	bl	101306c <random_byte_get>
	if (byte < 0) {
 10132ae:	2800      	cmp	r0, #0
 10132b0:	db20      	blt.n	10132f4 <isr+0x4c>
	u8_t last  = rngp->last;
 10132b2:	4b17      	ldr	r3, [pc, #92]	; (1013310 <isr+0x68>)
	ret = rng_pool_put((struct rng_pool *)(entropy_nrf5_data.isr), byte);
 10132b4:	b2c0      	uxtb	r0, r0
	u8_t last  = rngp->last;
 10132b6:	f893 2032 	ldrb.w	r2, [r3, #50]	; 0x32
	if (((last - first) & mask) == mask) {
 10132ba:	f893 1031 	ldrb.w	r1, [r3, #49]	; 0x31
	u8_t mask  = rngp->mask;
 10132be:	f893 4033 	ldrb.w	r4, [r3, #51]	; 0x33
	if (((last - first) & mask) == mask) {
 10132c2:	1a51      	subs	r1, r2, r1
 10132c4:	ea34 0101 	bics.w	r1, r4, r1
 10132c8:	d10d      	bne.n	10132e6 <isr+0x3e>
	u8_t last  = rngp->last;
 10132ca:	f893 2047 	ldrb.w	r2, [r3, #71]	; 0x47
	if (((last - first) & mask) == mask) {
 10132ce:	f893 1046 	ldrb.w	r1, [r3, #70]	; 0x46
	u8_t mask  = rngp->mask;
 10132d2:	f893 4048 	ldrb.w	r4, [r3, #72]	; 0x48
	if (((last - first) & mask) == mask) {
 10132d6:	1a51      	subs	r1, r2, r1
 10132d8:	ea34 0101 	bics.w	r1, r4, r1
 10132dc:	d10b      	bne.n	10132f6 <isr+0x4e>
 10132de:	2201      	movs	r2, #1
 10132e0:	4b0c      	ldr	r3, [pc, #48]	; (1013314 <isr+0x6c>)
 10132e2:	601a      	str	r2, [r3, #0]
}
 10132e4:	e00e      	b.n	1013304 <isr+0x5c>
	rngp->buffer[last] = byte;
 10132e6:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
 10132e8:	3201      	adds	r2, #1
 10132ea:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
 10132ec:	f881 0035 	strb.w	r0, [r1, #53]	; 0x35
	rngp->last = (last + 1) & mask;
 10132f0:	f883 2032 	strb.w	r2, [r3, #50]	; 0x32
}
 10132f4:	bd10      	pop	{r4, pc}
	rngp->buffer[last] = byte;
 10132f6:	1899      	adds	r1, r3, r2
	rngp->last = (last + 1) & mask;
 10132f8:	3201      	adds	r2, #1
 10132fa:	4022      	ands	r2, r4
	rngp->buffer[last] = byte;
 10132fc:	f881 004a 	strb.w	r0, [r1, #74]	; 0x4a
	rngp->last = (last + 1) & mask;
 1013300:	f883 2047 	strb.w	r2, [r3, #71]	; 0x47
	z_impl_k_sem_give(sem);
 1013304:	4804      	ldr	r0, [pc, #16]	; (1013318 <isr+0x70>)
}
 1013306:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 101330a:	f001 b99d 	b.w	1014648 <z_impl_k_sem_give>
 101330e:	bf00      	nop
 1013310:	21003ff0 	.word	0x21003ff0
 1013314:	41009004 	.word	0x41009004
 1013318:	21004008 	.word	0x21004008

0101331c <k_sys_fatal_error_handler>:

extern void sys_arch_reboot(int type);

void k_sys_fatal_error_handler(unsigned int reason,
			       const z_arch_esf_t *esf)
{
 101331c:	b508      	push	{r3, lr}
	z_impl_log_panic();
 101331e:	f7f0 ff21 	bl	1004164 <z_impl_log_panic>
 1013322:	4b06      	ldr	r3, [pc, #24]	; (101333c <k_sys_fatal_error_handler+0x20>)
 1013324:	4906      	ldr	r1, [pc, #24]	; (1013340 <k_sys_fatal_error_handler+0x24>)
	ARG_UNUSED(esf);
	ARG_UNUSED(reason);

	LOG_PANIC();

	LOG_ERR("Resetting system");
 1013326:	4807      	ldr	r0, [pc, #28]	; (1013344 <k_sys_fatal_error_handler+0x28>)
 1013328:	1ac9      	subs	r1, r1, r3
 101332a:	08c9      	lsrs	r1, r1, #3
 101332c:	0189      	lsls	r1, r1, #6
 101332e:	f041 0101 	orr.w	r1, r1, #1
 1013332:	f002 f82c 	bl	101538e <log_0>
	sys_arch_reboot(0);
 1013336:	2000      	movs	r0, #0
 1013338:	f7f2 f826 	bl	1005388 <sys_arch_reboot>

	CODE_UNREACHABLE;
 101333c:	010180b8 	.word	0x010180b8
 1013340:	01018190 	.word	0x01018190
 1013344:	010198c6 	.word	0x010198c6

01013348 <SystemInit>:
void SystemInit(void)
{
    /* Trimming of the device. Copy all the trimming values from FICR into the target addresses. Trim
     until one ADDR is not initialized. */
    uint32_t index = 0;
    for (index = 0; index < 32ul && NRF_FICR_NS->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
 1013348:	2200      	movs	r2, #0
 101334a:	00d3      	lsls	r3, r2, #3
 101334c:	f103 73ff 	add.w	r3, r3, #33423360	; 0x1fe0000
 1013350:	f503 3380 	add.w	r3, r3, #65536	; 0x10000
 1013354:	f8d3 1300 	ldr.w	r1, [r3, #768]	; 0x300
 1013358:	3101      	adds	r1, #1
 101335a:	d007      	beq.n	101336c <SystemInit+0x24>
        #if defined ( __ICCARM__ )
            /* IAR will complain about the order of volatile pointer accesses. */
            #pragma diag_suppress=Pa082
        #endif
        *NRF_FICR_NS->TRIMCNF[index].ADDR = NRF_FICR_NS->TRIMCNF[index].DATA;
 101335c:	f8d3 1300 	ldr.w	r1, [r3, #768]	; 0x300
    for (index = 0; index < 32ul && NRF_FICR_NS->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
 1013360:	3201      	adds	r2, #1
        *NRF_FICR_NS->TRIMCNF[index].ADDR = NRF_FICR_NS->TRIMCNF[index].DATA;
 1013362:	f8d3 3304 	ldr.w	r3, [r3, #772]	; 0x304
    for (index = 0; index < 32ul && NRF_FICR_NS->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
 1013366:	2a20      	cmp	r2, #32
        *NRF_FICR_NS->TRIMCNF[index].ADDR = NRF_FICR_NS->TRIMCNF[index].DATA;
 1013368:	600b      	str	r3, [r1, #0]
    for (index = 0; index < 32ul && NRF_FICR_NS->TRIMCNF[index].ADDR != (uint32_t *)0xFFFFFFFFul; index++){
 101336a:	d1ee      	bne.n	101334a <SystemInit+0x2>
         || defined (NRF5340_XXAA_NETWORK) || defined (DEVELOP_IN_NRF5340_NETWORK)
            #if defined(NRF_APPLICATION)
                uint32_t var1 = *(uint32_t *)0x00FF0130ul;
                uint32_t var2 = *(uint32_t *)0x00FF0134ul;
            #elif defined(NRF_NETWORK)
                uint32_t var1 = *(uint32_t *)0x01FF0130ul;
 101336c:	4b11      	ldr	r3, [pc, #68]	; (10133b4 <SystemInit+0x6c>)
                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
            #endif
        #endif
        #if defined (NRF5340_XXAA_APPLICATION) || defined (DEVELOP_IN_NRF5340_APPLICATION)\
         || defined (NRF5340_XXAA_NETWORK) || defined (DEVELOP_IN_NRF5340_NETWORK)
            if (var1 == 0x07)
 101336e:	681b      	ldr	r3, [r3, #0]
 1013370:	2b07      	cmp	r3, #7
 1013372:	d11a      	bne.n	10133aa <SystemInit+0x62>
                uint32_t var2 = *(uint32_t *)0x01FF0134ul;
 1013374:	4b10      	ldr	r3, [pc, #64]	; (10133b8 <SystemInit+0x70>)
            {
                switch(var2)
 1013376:	681a      	ldr	r2, [r3, #0]
 1013378:	2a02      	cmp	r2, #2
 101337a:	d109      	bne.n	1013390 <SystemInit+0x48>

    /* Workaround for Errata 49 "SLEEPENTER and SLEEPEXIT events asserted after pin reset" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf53_errata_49())
    {
        if (NRF_RESET_NS->RESETREAS & RESET_RESETREAS_RESETPIN_Msk)
 101337c:	4a0f      	ldr	r2, [pc, #60]	; (10133bc <SystemInit+0x74>)
 101337e:	f8d2 1400 	ldr.w	r1, [r2, #1024]	; 0x400
 1013382:	07c9      	lsls	r1, r1, #31
        {
            NRF_POWER_NS->EVENTS_SLEEPENTER = 0;
 1013384:	bf42      	ittt	mi
 1013386:	2100      	movmi	r1, #0
 1013388:	f8c2 1114 	strmi.w	r1, [r2, #276]	; 0x114
            NRF_POWER_NS->EVENTS_SLEEPEXIT = 0;
 101338c:	f8c2 1118 	strmi.w	r1, [r2, #280]	; 0x118
        #endif
        #if defined (NRF5340_XXAA_APPLICATION) || defined (DEVELOP_IN_NRF5340_APPLICATION)\
         || defined (NRF5340_XXAA_NETWORK) || defined (DEVELOP_IN_NRF5340_NETWORK)
            if (var1 == 0x07)
            {
                switch(var2)
 1013390:	681b      	ldr	r3, [r3, #0]
 1013392:	3b02      	subs	r3, #2
 1013394:	2b01      	cmp	r3, #1
 1013396:	d808      	bhi.n	10133aa <SystemInit+0x62>

    /* Workaround for Errata 55 "Bits in RESETREAS are set when they should not be" found at the Errata document
       for your device located at https://infocenter.nordicsemi.com/index.jsp  */
    if (nrf53_errata_55())
    {
        if (NRF_RESET_NS->RESETREAS & RESET_RESETREAS_RESETPIN_Msk){
 1013398:	4b08      	ldr	r3, [pc, #32]	; (10133bc <SystemInit+0x74>)
 101339a:	f8d3 2400 	ldr.w	r2, [r3, #1024]	; 0x400
 101339e:	07d2      	lsls	r2, r2, #31
            NRF_RESET_NS->RESETREAS = ~RESET_RESETREAS_RESETPIN_Msk;
 10133a0:	bf44      	itt	mi
 10133a2:	f06f 0201 	mvnmi.w	r2, #1
 10133a6:	f8c3 2400 	strmi.w	r2, [r3, #1024]	; 0x400
    SystemCoreClock = __SYSTEM_CLOCK;
 10133aa:	4b05      	ldr	r3, [pc, #20]	; (10133c0 <SystemInit+0x78>)
 10133ac:	4a05      	ldr	r2, [pc, #20]	; (10133c4 <SystemInit+0x7c>)
 10133ae:	601a      	str	r2, [r3, #0]
        }
    }    

    SystemCoreClockUpdate();
}
 10133b0:	4770      	bx	lr
 10133b2:	bf00      	nop
 10133b4:	01ff0130 	.word	0x01ff0130
 10133b8:	01ff0134 	.word	0x01ff0134
 10133bc:	41005000 	.word	0x41005000
 10133c0:	2100046c 	.word	0x2100046c
 10133c4:	03d09000 	.word	0x03d09000

010133c8 <nrfx_ipc_init>:
} ipc_control_block_t;

static ipc_control_block_t m_ipc_cb;

nrfx_err_t nrfx_ipc_init(uint8_t irq_priority, nrfx_ipc_handler_t handler, void * p_context)
{
 10133c8:	b570      	push	{r4, r5, r6, lr}
    NRFX_ASSERT(handler);
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
 10133ca:	4c08      	ldr	r4, [pc, #32]	; (10133ec <nrfx_ipc_init+0x24>)
{
 10133cc:	460e      	mov	r6, r1
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
 10133ce:	7923      	ldrb	r3, [r4, #4]
{
 10133d0:	4615      	mov	r5, r2
    if (m_ipc_cb.state != NRFX_DRV_STATE_UNINITIALIZED)
 10133d2:	b943      	cbnz	r3, 10133e6 <nrfx_ipc_init+0x1e>
    {
        return NRFX_ERROR_ALREADY_INITIALIZED;
    }

    NRFX_IRQ_PRIORITY_SET(IPC_IRQn, irq_priority);
    NRFX_IRQ_ENABLE(IPC_IRQn);
 10133d4:	2012      	movs	r0, #18
 10133d6:	f7f1 fc9d 	bl	1004d14 <arch_irq_enable>

    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
 10133da:	2301      	movs	r3, #1
    m_ipc_cb.handler = handler;
    m_ipc_cb.p_context = p_context;

    return NRFX_SUCCESS;
 10133dc:	4804      	ldr	r0, [pc, #16]	; (10133f0 <nrfx_ipc_init+0x28>)
    m_ipc_cb.state = NRFX_DRV_STATE_INITIALIZED;
 10133de:	7123      	strb	r3, [r4, #4]
    m_ipc_cb.handler = handler;
 10133e0:	6026      	str	r6, [r4, #0]
    m_ipc_cb.p_context = p_context;
 10133e2:	60a5      	str	r5, [r4, #8]
}
 10133e4:	bd70      	pop	{r4, r5, r6, pc}
        return NRFX_ERROR_ALREADY_INITIALIZED;
 10133e6:	4803      	ldr	r0, [pc, #12]	; (10133f4 <nrfx_ipc_init+0x2c>)
 10133e8:	e7fc      	b.n	10133e4 <nrfx_ipc_init+0x1c>
 10133ea:	bf00      	nop
 10133ec:	21004044 	.word	0x21004044
 10133f0:	0bad0000 	.word	0x0bad0000
 10133f4:	0bad000c 	.word	0x0bad000c

010133f8 <nrfx_ipc_config_load>:
{
    NRFX_ASSERT(p_config);
    NRFX_ASSERT(m_ipc_cb.state == NRFX_DRV_STATE_INITIALIZED);

    uint32_t i;
    for (i = 0; i < IPC_CONF_NUM; ++i)
 10133f8:	2300      	movs	r3, #0
{
 10133fa:	b530      	push	{r4, r5, lr}

NRF_STATIC_INLINE void nrf_ipc_send_config_set(NRF_IPC_Type * p_reg,
                                               uint8_t        index,
                                               uint32_t       channels_mask)
{
    p_reg->SEND_CNF[index] = channels_mask;
 10133fc:	4a0d      	ldr	r2, [pc, #52]	; (1013434 <nrfx_ipc_config_load+0x3c>)
    {
        nrf_ipc_send_config_set(NRF_IPC, i, p_config->send_task_config[i]);
 10133fe:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
 1013402:	f503 71a2 	add.w	r1, r3, #324	; 0x144
    for (i = 0; i < IPC_CONF_NUM; ++i)
 1013406:	3301      	adds	r3, #1
 1013408:	2b10      	cmp	r3, #16
 101340a:	f842 4021 	str.w	r4, [r2, r1, lsl #2]
 101340e:	d1f6      	bne.n	10133fe <nrfx_ipc_config_load+0x6>
    }

    for (i = 0; i < IPC_CONF_NUM; ++i)
 1013410:	2300      	movs	r3, #0

NRF_STATIC_INLINE void nrf_ipc_receive_config_set(NRF_IPC_Type * p_reg,
                                                  uint8_t        index,
                                                  uint32_t       channels_mask)
{
    p_reg->RECEIVE_CNF[index] = channels_mask;
 1013412:	4a08      	ldr	r2, [pc, #32]	; (1013434 <nrfx_ipc_config_load+0x3c>)
 1013414:	f100 0140 	add.w	r1, r0, #64	; 0x40
 1013418:	f503 74b2 	add.w	r4, r3, #356	; 0x164
    {
        nrf_ipc_receive_config_set(NRF_IPC, i, p_config->receive_event_config[i]);
 101341c:	f851 5b04 	ldr.w	r5, [r1], #4
    for (i = 0; i < IPC_CONF_NUM; ++i)
 1013420:	3301      	adds	r3, #1
 1013422:	2b10      	cmp	r3, #16
 1013424:	f842 5024 	str.w	r5, [r2, r4, lsl #2]
 1013428:	d1f6      	bne.n	1013418 <nrfx_ipc_config_load+0x20>
    }

    nrf_ipc_int_enable(NRF_IPC, p_config->receive_events_enabled);
 101342a:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
    p_reg->INTENSET = mask;
 101342e:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
 1013432:	bd30      	pop	{r4, r5, pc}
 1013434:	41012000 	.word	0x41012000

01013438 <nrfx_ipc_receive_event_enable>:
}

void nrfx_ipc_receive_event_enable(uint8_t event_index)
{
    NRFX_ASSERT(m_ipc_cb.state == NRFX_DRV_STATE_INITIALIZED);
    nrf_ipc_int_enable(NRF_IPC, (1UL << event_index));
 1013438:	2301      	movs	r3, #1
 101343a:	4a02      	ldr	r2, [pc, #8]	; (1013444 <nrfx_ipc_receive_event_enable+0xc>)
 101343c:	4083      	lsls	r3, r0
 101343e:	f8c2 3304 	str.w	r3, [r2, #772]	; 0x304
}
 1013442:	4770      	bx	lr
 1013444:	41012000 	.word	0x41012000

01013448 <nrfx_ipc_receive_event_disable>:

void nrfx_ipc_receive_event_disable(uint8_t event_index)
{
    NRFX_ASSERT(m_ipc_cb.state == NRFX_DRV_STATE_INITIALIZED);
    nrf_ipc_int_disable(NRF_IPC, (1UL << event_index));
 1013448:	2301      	movs	r3, #1
    p_reg->INTENCLR = mask;
 101344a:	4a02      	ldr	r2, [pc, #8]	; (1013454 <nrfx_ipc_receive_event_disable+0xc>)
 101344c:	4083      	lsls	r3, r0
 101344e:	f8c2 3308 	str.w	r3, [r2, #776]	; 0x308
}
 1013452:	4770      	bx	lr
 1013454:	41012000 	.word	0x41012000

01013458 <nrfx_ipc_irq_handler>:
    return p_reg->INTPEND;
 1013458:	4b0c      	ldr	r3, [pc, #48]	; (101348c <nrfx_ipc_irq_handler+0x34>)
    channel_bitmask |= nrf_ipc_send_config_get(NRF_IPC, send_index);
    nrf_ipc_send_config_set(NRF_IPC, send_index, channel_bitmask);
}

void nrfx_ipc_irq_handler(void)
{
 101345a:	b430      	push	{r4, r5}
 101345c:	f8d3 030c 	ldr.w	r0, [r3, #780]	; 0x30c
    // Clear these events
    uint32_t bitmask = events_map;
    while (bitmask)
    {
        uint8_t event_idx = __CLZ(__RBIT(bitmask));
        bitmask &= ~(1UL << event_idx);
 1013460:	2401      	movs	r4, #1
    uint32_t bitmask = events_map;
 1013462:	4602      	mov	r2, r0
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 1013464:	2500      	movs	r5, #0
    while (bitmask)
 1013466:	b922      	cbnz	r2, 1013472 <nrfx_ipc_irq_handler+0x1a>
        nrf_ipc_event_clear(NRF_IPC, nrf_ipc_receive_event_get(event_idx));
    }

    // Execute interrupt handler to provide information about events to app
    m_ipc_cb.handler(events_map, m_ipc_cb.p_context);
}
 1013468:	bc30      	pop	{r4, r5}
    m_ipc_cb.handler(events_map, m_ipc_cb.p_context);
 101346a:	4b09      	ldr	r3, [pc, #36]	; (1013490 <nrfx_ipc_irq_handler+0x38>)
 101346c:	681a      	ldr	r2, [r3, #0]
 101346e:	6899      	ldr	r1, [r3, #8]
 1013470:	4710      	bx	r2
   __ASM ("rbit %0, %1" : "=r" (result) : "r" (value) );
 1013472:	fa92 f3a2 	rbit	r3, r2
  return __builtin_clz(value);
 1013476:	fab3 f383 	clz	r3, r3
        bitmask &= ~(1UL << event_idx);
 101347a:	fa04 f103 	lsl.w	r1, r4, r3
 101347e:	ea22 0201 	bic.w	r2, r2, r1
 1013482:	4904      	ldr	r1, [pc, #16]	; (1013494 <nrfx_ipc_irq_handler+0x3c>)
}

NRF_STATIC_INLINE nrf_ipc_event_t nrf_ipc_receive_event_get(uint8_t index)
{
    NRFX_ASSERT(index < IPC_CH_NUM);
    return (nrf_ipc_event_t)(NRFX_OFFSETOF(NRF_IPC_Type, EVENTS_RECEIVE[index]));
 1013484:	009b      	lsls	r3, r3, #2
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 1013486:	50cd      	str	r5, [r1, r3]
}
 1013488:	e7ed      	b.n	1013466 <nrfx_ipc_irq_handler+0xe>
 101348a:	bf00      	nop
 101348c:	41012000 	.word	0x41012000
 1013490:	21004044 	.word	0x21004044
 1013494:	41012100 	.word	0x41012100

01013498 <metal_generic_dev_open>:
	return 0;
}

int metal_generic_dev_open(struct metal_bus *bus, const char *dev_name,
			   struct metal_device **device)
{
 1013498:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 101349c:	460e      	mov	r6, r1
 101349e:	4617      	mov	r7, r2
	struct metal_list *node;
	struct metal_device *dev;

	(void)bus;

	metal_list_for_each(&_metal.common.generic_device_list, node) {
 10134a0:	4d0c      	ldr	r5, [pc, #48]	; (10134d4 <metal_generic_dev_open+0x3c>)
 10134a2:	f855 4f18 	ldr.w	r4, [r5, #24]!
 10134a6:	42ac      	cmp	r4, r5
 10134a8:	d103      	bne.n	10134b2 <metal_generic_dev_open+0x1a>
			return metal_generic_dev_sys_open(dev);
		}
	}

	return -ENODEV;
}
 10134aa:	f06f 0012 	mvn.w	r0, #18
 10134ae:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		if (strcmp(dev->name, dev_name) == 0) {
 10134b2:	4631      	mov	r1, r6
 10134b4:	f854 0c44 	ldr.w	r0, [r4, #-68]
		dev = metal_container_of(node, struct metal_device, node);
 10134b8:	f1a4 0844 	sub.w	r8, r4, #68	; 0x44
		if (strcmp(dev->name, dev_name) == 0) {
 10134bc:	f003 f9d1 	bl	1016862 <strcmp>
 10134c0:	b930      	cbnz	r0, 10134d0 <metal_generic_dev_open+0x38>
			return metal_generic_dev_sys_open(dev);
 10134c2:	4640      	mov	r0, r8
			*device = dev;
 10134c4:	f8c7 8000 	str.w	r8, [r7]
}
 10134c8:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
			return metal_generic_dev_sys_open(dev);
 10134cc:	f003 bd33 	b.w	1016f36 <metal_generic_dev_sys_open>
	metal_list_for_each(&_metal.common.generic_device_list, node) {
 10134d0:	6824      	ldr	r4, [r4, #0]
 10134d2:	e7e8      	b.n	10134a6 <metal_generic_dev_open+0xe>
 10134d4:	21004050 	.word	0x21004050

010134d8 <metal_bus_find>:
{
 10134d8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 10134dc:	4607      	mov	r7, r0
 10134de:	460d      	mov	r5, r1
	metal_list_for_each(&_metal.common.bus_list, node) {
 10134e0:	4e0b      	ldr	r6, [pc, #44]	; (1013510 <metal_bus_find+0x38>)
 10134e2:	f856 4f08 	ldr.w	r4, [r6, #8]!
 10134e6:	42b4      	cmp	r4, r6
 10134e8:	d102      	bne.n	10134f0 <metal_bus_find+0x18>
	return -ENOENT;
 10134ea:	f06f 0001 	mvn.w	r0, #1
 10134ee:	e00a      	b.n	1013506 <metal_bus_find+0x2e>
		if (strcmp(bus->name, name) == 0 && result) {
 10134f0:	4639      	mov	r1, r7
 10134f2:	f854 0c24 	ldr.w	r0, [r4, #-36]
		bus = metal_container_of(node, struct metal_bus, node);
 10134f6:	f1a4 0824 	sub.w	r8, r4, #36	; 0x24
		if (strcmp(bus->name, name) == 0 && result) {
 10134fa:	f003 f9b2 	bl	1016862 <strcmp>
 10134fe:	b920      	cbnz	r0, 101350a <metal_bus_find+0x32>
 1013500:	b11d      	cbz	r5, 101350a <metal_bus_find+0x32>
			*result = bus;
 1013502:	f8c5 8000 	str.w	r8, [r5]
}
 1013506:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	metal_list_for_each(&_metal.common.bus_list, node) {
 101350a:	6824      	ldr	r4, [r4, #0]
 101350c:	e7eb      	b.n	10134e6 <metal_bus_find+0xe>
 101350e:	bf00      	nop
 1013510:	21004050 	.word	0x21004050

01013514 <metal_bus_register>:
{
 1013514:	b510      	push	{r4, lr}
	if (!bus || !bus->name || !strlen(bus->name))
 1013516:	4604      	mov	r4, r0
 1013518:	b910      	cbnz	r0, 1013520 <metal_bus_register+0xc>
		return -EINVAL;
 101351a:	f06f 0015 	mvn.w	r0, #21
}
 101351e:	bd10      	pop	{r4, pc}
	if (!bus || !bus->name || !strlen(bus->name))
 1013520:	6800      	ldr	r0, [r0, #0]
 1013522:	2800      	cmp	r0, #0
 1013524:	d0f9      	beq.n	101351a <metal_bus_register+0x6>
 1013526:	f003 f995 	bl	1016854 <strlen>
 101352a:	2800      	cmp	r0, #0
 101352c:	d0f5      	beq.n	101351a <metal_bus_register+0x6>
	if (metal_bus_find(bus->name, NULL) == 0)
 101352e:	2100      	movs	r1, #0
 1013530:	6820      	ldr	r0, [r4, #0]
 1013532:	f7ff ffd1 	bl	10134d8 <metal_bus_find>
 1013536:	b1c0      	cbz	r0, 101356a <metal_bus_register+0x56>
	metal_list_init(&bus->devices);
 1013538:	f104 031c 	add.w	r3, r4, #28
	struct metal_list name = METAL_INIT_LIST(name)

static inline void metal_list_init(struct metal_list *list)
{
	list->prev = list;
	list->next = list;
 101353c:	e9c4 3307 	strd	r3, r3, [r4, #28]
}

static inline void metal_list_add_before(struct metal_list *node,
					 struct metal_list *new_node)
{
	new_node->prev = node->prev;
 1013540:	4b0c      	ldr	r3, [pc, #48]	; (1013574 <metal_bus_register+0x60>)
	metal_list_add_tail(&_metal.common.bus_list, &bus->node);
 1013542:	f104 0224 	add.w	r2, r4, #36	; 0x24
 1013546:	68d9      	ldr	r1, [r3, #12]
	new_node->next = node;
 1013548:	f103 0008 	add.w	r0, r3, #8
	new_node->next->prev = new_node;
 101354c:	60da      	str	r2, [r3, #12]
	new_node->prev = node->prev;
 101354e:	62a1      	str	r1, [r4, #40]	; 0x28
	new_node->next = node;
 1013550:	6260      	str	r0, [r4, #36]	; 0x24
	new_node->prev->next = new_node;
 1013552:	600a      	str	r2, [r1, #0]
	metal_log(METAL_LOG_DEBUG, "registered %s bus\n", bus->name);
 1013554:	781a      	ldrb	r2, [r3, #0]
 1013556:	2a06      	cmp	r2, #6
 1013558:	d905      	bls.n	1013566 <metal_bus_register+0x52>
 101355a:	685b      	ldr	r3, [r3, #4]
 101355c:	b143      	cbz	r3, 1013570 <metal_bus_register+0x5c>
 101355e:	2007      	movs	r0, #7
 1013560:	6822      	ldr	r2, [r4, #0]
 1013562:	4905      	ldr	r1, [pc, #20]	; (1013578 <metal_bus_register+0x64>)
 1013564:	4798      	blx	r3
	return 0;
 1013566:	2000      	movs	r0, #0
 1013568:	e7d9      	b.n	101351e <metal_bus_register+0xa>
		return -EEXIST;
 101356a:	f06f 0010 	mvn.w	r0, #16
 101356e:	e7d6      	b.n	101351e <metal_bus_register+0xa>
	return 0;
 1013570:	4618      	mov	r0, r3
 1013572:	e7d4      	b.n	101351e <metal_bus_register+0xa>
 1013574:	21004050 	.word	0x21004050
 1013578:	010198e3 	.word	0x010198e3

0101357c <metal_register_generic_device>:
{
 101357c:	b510      	push	{r4, lr}
 101357e:	4604      	mov	r4, r0
	if (!device->name || !strlen(device->name) ||
 1013580:	6800      	ldr	r0, [r0, #0]
 1013582:	b910      	cbnz	r0, 101358a <metal_register_generic_device+0xe>
		return -EINVAL;
 1013584:	f06f 0015 	mvn.w	r0, #21
}
 1013588:	bd10      	pop	{r4, pc}
	if (!device->name || !strlen(device->name) ||
 101358a:	f003 f963 	bl	1016854 <strlen>
 101358e:	2800      	cmp	r0, #0
 1013590:	d0f8      	beq.n	1013584 <metal_register_generic_device+0x8>
 1013592:	68a3      	ldr	r3, [r4, #8]
 1013594:	2b01      	cmp	r3, #1
 1013596:	d8f5      	bhi.n	1013584 <metal_register_generic_device+0x8>
	device->bus = &metal_generic_bus;
 1013598:	4b06      	ldr	r3, [pc, #24]	; (10135b4 <metal_register_generic_device+0x38>)
	metal_list_add_tail(&_metal.common.generic_device_list,
 101359a:	f104 0144 	add.w	r1, r4, #68	; 0x44
	device->bus = &metal_generic_bus;
 101359e:	6063      	str	r3, [r4, #4]
	new_node->prev = node->prev;
 10135a0:	4b05      	ldr	r3, [pc, #20]	; (10135b8 <metal_register_generic_device+0x3c>)
 10135a2:	69da      	ldr	r2, [r3, #28]
	new_node->next = node;
 10135a4:	f103 0018 	add.w	r0, r3, #24
 10135a8:	6460      	str	r0, [r4, #68]	; 0x44
	new_node->prev = node->prev;
 10135aa:	64a2      	str	r2, [r4, #72]	; 0x48
	new_node->next->prev = new_node;
 10135ac:	61d9      	str	r1, [r3, #28]
	return 0;
 10135ae:	2000      	movs	r0, #0
	new_node->prev->next = new_node;
 10135b0:	6011      	str	r1, [r2, #0]
}
 10135b2:	e7e9      	b.n	1013588 <metal_register_generic_device+0xc>
 10135b4:	21000470 	.word	0x21000470
 10135b8:	21004050 	.word	0x21004050

010135bc <metal_init>:

#include <string.h>
#include <metal/sys.h>

int metal_init(const struct metal_init_params *params)
{
 10135bc:	b538      	push	{r3, r4, r5, lr}
 10135be:	4605      	mov	r5, r0
	int error = 0;

	memset(&_metal, 0, sizeof(_metal));
 10135c0:	4c0d      	ldr	r4, [pc, #52]	; (10135f8 <metal_init+0x3c>)
 10135c2:	2220      	movs	r2, #32
 10135c4:	4620      	mov	r0, r4
 10135c6:	2100      	movs	r1, #0
 10135c8:	f003 f9a1 	bl	101690e <memset>

	_metal.common.log_handler   = params->log_handler;
 10135cc:	682b      	ldr	r3, [r5, #0]

	metal_list_init(&_metal.common.bus_list);
	metal_list_init(&_metal.common.generic_shmem_list);
	metal_list_init(&_metal.common.generic_device_list);

	error = metal_sys_init(params);
 10135ce:	4628      	mov	r0, r5
	_metal.common.log_handler   = params->log_handler;
 10135d0:	6063      	str	r3, [r4, #4]
	_metal.common.log_level     = params->log_level;
 10135d2:	4623      	mov	r3, r4
 10135d4:	792a      	ldrb	r2, [r5, #4]
 10135d6:	f803 2b08 	strb.w	r2, [r3], #8
	list->next = list;
 10135da:	e9c4 3302 	strd	r3, r3, [r4, #8]
	list->prev = list;
 10135de:	f104 0310 	add.w	r3, r4, #16
	list->next = list;
 10135e2:	e9c4 3304 	strd	r3, r3, [r4, #16]
	list->prev = list;
 10135e6:	f104 0318 	add.w	r3, r4, #24
	list->next = list;
 10135ea:	e9c4 3306 	strd	r3, r3, [r4, #24]
	if (error)
		return error;

	return error;
}
 10135ee:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	error = metal_sys_init(params);
 10135f2:	f000 b803 	b.w	10135fc <metal_sys_init>
 10135f6:	bf00      	nop
 10135f8:	21004050 	.word	0x21004050

010135fc <metal_sys_init>:
#include <metal/utilities.h>

struct metal_state _metal;

int metal_sys_init(const struct metal_init_params *params)
{
 10135fc:	b508      	push	{r3, lr}
	metal_bus_register(&metal_generic_bus);
 10135fe:	4802      	ldr	r0, [pc, #8]	; (1013608 <metal_sys_init+0xc>)
 1013600:	f7ff ff88 	bl	1013514 <metal_bus_register>
	return 0;
}
 1013604:	2000      	movs	r0, #0
 1013606:	bd08      	pop	{r3, pc}
 1013608:	21000470 	.word	0x21000470

0101360c <metal_zephyr_log_handler>:
	"metal: debug:     ",
};

void metal_zephyr_log_handler(enum metal_log_level level,
			      const char *format, ...)
{
 101360c:	b40e      	push	{r1, r2, r3}
	va_list args;

	if (level <= METAL_LOG_EMERGENCY || level > METAL_LOG_DEBUG)
 101360e:	1e43      	subs	r3, r0, #1
		level = METAL_LOG_EMERGENCY;
 1013610:	2b06      	cmp	r3, #6
{
 1013612:	b533      	push	{r0, r1, r4, r5, lr}
		level = METAL_LOG_EMERGENCY;
 1013614:	bf88      	it	hi
 1013616:	2000      	movhi	r0, #0
	printk("%s", level_strs[level]);
 1013618:	4b09      	ldr	r3, [pc, #36]	; (1013640 <metal_zephyr_log_handler+0x34>)
{
 101361a:	ac05      	add	r4, sp, #20
 101361c:	f854 5b04 	ldr.w	r5, [r4], #4
	printk("%s", level_strs[level]);
 1013620:	f853 1020 	ldr.w	r1, [r3, r0, lsl #2]
 1013624:	4807      	ldr	r0, [pc, #28]	; (1013644 <metal_zephyr_log_handler+0x38>)
 1013626:	f001 fbd6 	bl	1014dd6 <printk>

	va_start(args, format);
	vprintk(format, args);
 101362a:	4621      	mov	r1, r4
 101362c:	4628      	mov	r0, r5
	va_start(args, format);
 101362e:	9401      	str	r4, [sp, #4]
	vprintk(format, args);
 1013630:	f7f0 fb0e 	bl	1003c50 <vprintk>
	va_end(args);
}
 1013634:	b002      	add	sp, #8
 1013636:	e8bd 4030 	ldmia.w	sp!, {r4, r5, lr}
 101363a:	b003      	add	sp, #12
 101363c:	4770      	bx	lr
 101363e:	bf00      	nop
 1013640:	01018e0c 	.word	0x01018e0c
 1013644:	0101920a 	.word	0x0101920a

01013648 <virtio_create_virtqueues>:
}

int virtio_create_virtqueues(struct virtio_device *vdev, unsigned int flags,
			     unsigned int nvqs, const char *names[],
			     vq_callback callbacks[])
{
 1013648:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 101364c:	b087      	sub	sp, #28
 101364e:	9305      	str	r3, [sp, #20]
	unsigned int num_vrings, i;
	int ret;
	(void)flags;

	num_vrings = vdev->vrings_num;
	if (nvqs > num_vrings)
 1013650:	6a83      	ldr	r3, [r0, #40]	; 0x28
{
 1013652:	4606      	mov	r6, r0
	if (nvqs > num_vrings)
 1013654:	4293      	cmp	r3, r2
{
 1013656:	4617      	mov	r7, r2
	if (nvqs > num_vrings)
 1013658:	d342      	bcc.n	10136e0 <virtio_create_virtqueues+0x98>
		return ERROR_VQUEUE_INVLD_PARAM;
	/* Initialize virtqueue for each vring */
	for (i = 0; i < nvqs; i++) {
 101365a:	2500      	movs	r5, #0
		vring_info = &vdev->vrings_info[i];
 101365c:	f04f 0b18 	mov.w	fp, #24
	for (i = 0; i < nvqs; i++) {
 1013660:	42bd      	cmp	r5, r7
 1013662:	d103      	bne.n	101366c <virtio_create_virtqueues+0x24>
				       callbacks[i], vdev->func->notify,
				       vring_info->vq);
		if (ret)
			return ret;
	}
	return 0;
 1013664:	2000      	movs	r0, #0
}
 1013666:	b007      	add	sp, #28
 1013668:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		vring_info = &vdev->vrings_info[i];
 101366c:	fb0b f805 	mul.w	r8, fp, r5
 1013670:	f8d6 902c 	ldr.w	r9, [r6, #44]	; 0x2c
		if (vdev->role == VIRTIO_DEV_MASTER) {
 1013674:	69b2      	ldr	r2, [r6, #24]
		vring_info = &vdev->vrings_info[i];
 1013676:	eb09 0408 	add.w	r4, r9, r8
		vring_alloc = &vring_info->info;
 101367a:	f104 0a04 	add.w	sl, r4, #4
		if (vdev->role == VIRTIO_DEV_MASTER) {
 101367e:	b9ca      	cbnz	r2, 10136b4 <virtio_create_virtqueues+0x6c>
			struct metal_io_region *io = vring_info->io;
 1013680:	6960      	ldr	r0, [r4, #20]
 * @return	METAL_BAD_OFFSET if out of range, or offset.
 */
static inline unsigned long
metal_io_virt_to_offset(struct metal_io_region *io, void *virt)
{
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
 1013682:	6863      	ldr	r3, [r4, #4]
 1013684:	6801      	ldr	r1, [r0, #0]
			metal_io_block_set(io, offset, 0,
 1013686:	f8b4 c00c 	ldrh.w	ip, [r4, #12]
 101368a:	1a59      	subs	r1, r3, r1
						      vring_alloc->align));
 101368c:	68a3      	ldr	r3, [r4, #8]
static inline int vring_size(unsigned int num, unsigned long align)
{
	int size;

	size = num * sizeof(struct vring_desc);
	size += sizeof(struct vring_avail) + (num * sizeof(uint16_t)) +
 101368e:	f10c 0e03 	add.w	lr, ip, #3
	    sizeof(uint16_t);
	size = (size + align - 1) & ~(align - 1);
 1013692:	1e5c      	subs	r4, r3, #1
 1013694:	eb04 140c 	add.w	r4, r4, ip, lsl #4
 1013698:	eb04 044e 	add.w	r4, r4, lr, lsl #1
 101369c:	425b      	negs	r3, r3
 101369e:	4023      	ands	r3, r4
			metal_io_block_set(io, offset, 0,
 10136a0:	6884      	ldr	r4, [r0, #8]
	size += sizeof(struct vring_used) +
 10136a2:	eb03 03cc 	add.w	r3, r3, ip, lsl #3
 10136a6:	42a1      	cmp	r1, r4
 10136a8:	bf28      	it	cs
 10136aa:	f04f 31ff 	movcs.w	r1, #4294967295
 10136ae:	3306      	adds	r3, #6
 10136b0:	f003 fc08 	bl	1016ec4 <metal_io_block_set>
		ret = virtqueue_create(vdev, i, names[i], vring_alloc,
 10136b4:	f859 3008 	ldr.w	r3, [r9, r8]
 10136b8:	9a05      	ldr	r2, [sp, #20]
 10136ba:	9302      	str	r3, [sp, #8]
 10136bc:	6a33      	ldr	r3, [r6, #32]
 10136be:	4630      	mov	r0, r6
 10136c0:	6a1b      	ldr	r3, [r3, #32]
 10136c2:	b2a9      	uxth	r1, r5
 10136c4:	9301      	str	r3, [sp, #4]
 10136c6:	9b10      	ldr	r3, [sp, #64]	; 0x40
 10136c8:	f853 3025 	ldr.w	r3, [r3, r5, lsl #2]
 10136cc:	9300      	str	r3, [sp, #0]
 10136ce:	f852 2025 	ldr.w	r2, [r2, r5, lsl #2]
 10136d2:	4653      	mov	r3, sl
 10136d4:	f003 fc4c 	bl	1016f70 <virtqueue_create>
		if (ret)
 10136d8:	2800      	cmp	r0, #0
 10136da:	d1c4      	bne.n	1013666 <virtio_create_virtqueues+0x1e>
	for (i = 0; i < nvqs; i++) {
 10136dc:	3501      	adds	r5, #1
 10136de:	e7bf      	b.n	1013660 <virtio_create_virtqueues+0x18>
		return ERROR_VQUEUE_INVLD_PARAM;
 10136e0:	4800      	ldr	r0, [pc, #0]	; (10136e4 <virtio_create_virtqueues+0x9c>)
 10136e2:	e7c0      	b.n	1013666 <virtio_create_virtqueues+0x1e>
 10136e4:	fffff440 	.word	0xfffff440

010136e8 <virtqueue_add_consumed_buffer>:
 *
 * @return                       - Function status
 */
int virtqueue_add_consumed_buffer(struct virtqueue *vq, uint16_t head_idx,
				  uint32_t len)
{
 10136e8:	b530      	push	{r4, r5, lr}
	struct vring_used_elem *used_desc = NULL;
	uint16_t used_idx;

	if (head_idx > vq->vq_nentries) {
 10136ea:	8944      	ldrh	r4, [r0, #10]
 10136ec:	428c      	cmp	r4, r1
 10136ee:	d312      	bcc.n	1013716 <virtqueue_add_consumed_buffer+0x2e>
		return ERROR_VRING_NO_BUFF;
	}

	VQUEUE_BUSY(vq);

	used_idx = vq->vq_ring.used->idx & (vq->vq_nentries - 1);
 10136f0:	6a03      	ldr	r3, [r0, #32]
 10136f2:	3c01      	subs	r4, #1
 10136f4:	885d      	ldrh	r5, [r3, #2]
 10136f6:	402c      	ands	r4, r5
 10136f8:	eb03 03c4 	add.w	r3, r3, r4, lsl #3
	used_desc = &vq->vq_ring.used->ring[used_idx];
	used_desc->id = head_idx;
	used_desc->len = len;
 10136fc:	609a      	str	r2, [r3, #8]
	used_desc->id = head_idx;
 10136fe:	6059      	str	r1, [r3, #4]

	atomic_thread_fence(memory_order_seq_cst);
 1013700:	f3bf 8f5b 	dmb	ish

	vq->vq_ring.used->idx++;
 1013704:	6a02      	ldr	r2, [r0, #32]
 1013706:	8853      	ldrh	r3, [r2, #2]
 1013708:	3301      	adds	r3, #1
 101370a:	8053      	strh	r3, [r2, #2]

	/* Keep pending count until virtqueue_notify(). */
	vq->vq_queued_cnt++;
 101370c:	8cc3      	ldrh	r3, [r0, #38]	; 0x26
 101370e:	3301      	adds	r3, #1
 1013710:	84c3      	strh	r3, [r0, #38]	; 0x26

	VQUEUE_IDLE(vq);

	return VQUEUE_SUCCESS;
 1013712:	2000      	movs	r0, #0
}
 1013714:	bd30      	pop	{r4, r5, pc}
		return ERROR_VRING_NO_BUFF;
 1013716:	4801      	ldr	r0, [pc, #4]	; (101371c <virtqueue_add_consumed_buffer+0x34>)
 1013718:	e7fc      	b.n	1013714 <virtqueue_add_consumed_buffer+0x2c>
 101371a:	bf00      	nop
 101371c:	fffff441 	.word	0xfffff441

01013720 <rpmsg_send_offchannel_raw>:
 *
 */
int rpmsg_send_offchannel_raw(struct rpmsg_endpoint *ept, uint32_t src,
			      uint32_t dst, const void *data, int size,
			      int wait)
{
 1013720:	b430      	push	{r4, r5}
 1013722:	4614      	mov	r4, r2
	struct rpmsg_device *rdev;

	if (!ept || !ept->rdev || !data || dst == RPMSG_ADDR_ANY)
 1013724:	b148      	cbz	r0, 101373a <rpmsg_send_offchannel_raw+0x1a>
 1013726:	6a00      	ldr	r0, [r0, #32]
 1013728:	b138      	cbz	r0, 101373a <rpmsg_send_offchannel_raw+0x1a>
 101372a:	b133      	cbz	r3, 101373a <rpmsg_send_offchannel_raw+0x1a>
 101372c:	3401      	adds	r4, #1
 101372e:	d004      	beq.n	101373a <rpmsg_send_offchannel_raw+0x1a>
		return RPMSG_ERR_PARAM;

	rdev = ept->rdev;

	if (rdev->ops.send_offchannel_raw)
 1013730:	6f44      	ldr	r4, [r0, #116]	; 0x74
 1013732:	b114      	cbz	r4, 101373a <rpmsg_send_offchannel_raw+0x1a>
		return rdev->ops.send_offchannel_raw(rdev, src, dst, data,
 1013734:	46a4      	mov	ip, r4
						      size, wait);

	return RPMSG_ERR_PARAM;
}
 1013736:	bc30      	pop	{r4, r5}
		return rdev->ops.send_offchannel_raw(rdev, src, dst, data,
 1013738:	4760      	bx	ip
		return RPMSG_ERR_PARAM;
 101373a:	4801      	ldr	r0, [pc, #4]	; (1013740 <rpmsg_send_offchannel_raw+0x20>)
}
 101373c:	bc30      	pop	{r4, r5}
 101373e:	4770      	bx	lr
 1013740:	fffff82d 	.word	0xfffff82d

01013744 <rpmsg_create_ept>:
}

int rpmsg_create_ept(struct rpmsg_endpoint *ept, struct rpmsg_device *rdev,
		     const char *name, uint32_t src, uint32_t dest,
		     rpmsg_ept_cb cb, rpmsg_ns_unbind_cb unbind_cb)
{
 1013744:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1013748:	460e      	mov	r6, r1
 101374a:	4690      	mov	r8, r2
 101374c:	461d      	mov	r5, r3
	int status = RPMSG_SUCCESS;
	uint32_t addr = src;

	if (!ept)
 101374e:	4604      	mov	r4, r0
 1013750:	2800      	cmp	r0, #0
 1013752:	d066      	beq.n	1013822 <rpmsg_create_ept+0xde>
		return RPMSG_ERR_PARAM;

	metal_mutex_acquire(&rdev->lock);
 1013754:	f101 0758 	add.w	r7, r1, #88	; 0x58
 * @brief	Acquire a mutex
 * @param[in]	mutex	Mutex to mutex.
 */
static inline void metal_mutex_acquire(metal_mutex_t *mutex)
{
	__metal_mutex_acquire(mutex);
 1013758:	4638      	mov	r0, r7
 101375a:	f003 fdc0 	bl	10172de <__metal_mutex_acquire>
	if (src != RPMSG_ADDR_ANY) {
 101375e:	1c69      	adds	r1, r5, #1
 1013760:	f106 0248 	add.w	r2, r6, #72	; 0x48
 1013764:	d059      	beq.n	101381a <rpmsg_create_ept+0xd6>
	if (addr < size)
 1013766:	2d7f      	cmp	r5, #127	; 0x7f
 1013768:	dc59      	bgt.n	101381e <rpmsg_create_ept+0xda>
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
}

static inline int metal_bitmap_is_bit_set(unsigned long *bitmap, int bit)
{
	return ((bitmap[bit / METAL_BITS_PER_ULONG] &
 101376a:	0969      	lsrs	r1, r5, #5
 101376c:	f852 0021 	ldr.w	r0, [r2, r1, lsl #2]
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1))) == 0) ? 0 : 1;
 1013770:	f005 0c1f 	and.w	ip, r5, #31
 1013774:	fa20 f30c 	lsr.w	r3, r0, ip
		status = rpmsg_is_address_set(rdev->bitmap,
					      RPMSG_ADDR_BMP_SIZE, src);
		if (!status) {
 1013778:	07db      	lsls	r3, r3, #31
 101377a:	d506      	bpl.n	101378a <rpmsg_create_ept+0x46>
			/* Mark the address as used in the address bitmap. */
			rpmsg_set_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE,
					  src);
		} else if (status > 0) {
			status = RPMSG_SUCCESS;
 101377c:	2500      	movs	r5, #0
 101377e:	4638      	mov	r0, r7
 1013780:	f000 ff62 	bl	1014648 <z_impl_k_sem_give>
	}

ret_status:
	metal_mutex_release(&rdev->lock);
	return status;
}
 1013784:	4628      	mov	r0, r5
 1013786:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
 101378a:	2301      	movs	r3, #1
 101378c:	fa03 f30c 	lsl.w	r3, r3, ip
	bitmap[bit / METAL_BITS_PER_ULONG] |=
 1013790:	4303      	orrs	r3, r0
 1013792:	f842 3021 	str.w	r3, [r2, r1, lsl #2]
				  const char *name,
				  uint32_t src, uint32_t dest,
				  rpmsg_ept_cb cb,
				  rpmsg_ns_unbind_cb ns_unbind_cb)
{
	strncpy(ept->name, name ? name : "", sizeof(ept->name));
 1013796:	4924      	ldr	r1, [pc, #144]	; (1013828 <rpmsg_create_ept+0xe4>)
 1013798:	2220      	movs	r2, #32
 101379a:	f1b8 0f00 	cmp.w	r8, #0
 101379e:	bf18      	it	ne
 10137a0:	4641      	movne	r1, r8
 10137a2:	4620      	mov	r0, r4
 10137a4:	f003 f843 	bl	101682e <strncpy>
	ept->addr = src;
	ept->dest_addr = dest;
 10137a8:	9b06      	ldr	r3, [sp, #24]
	rpmsg_register_endpoint(rdev, ept);
 10137aa:	4621      	mov	r1, r4
 10137ac:	62a3      	str	r3, [r4, #40]	; 0x28
	ept->cb = cb;
 10137ae:	9b07      	ldr	r3, [sp, #28]
 10137b0:	4630      	mov	r0, r6
 10137b2:	62e3      	str	r3, [r4, #44]	; 0x2c
	ept->ns_unbind_cb = ns_unbind_cb;
 10137b4:	9b08      	ldr	r3, [sp, #32]
	ept->addr = src;
 10137b6:	6265      	str	r5, [r4, #36]	; 0x24
	ept->ns_unbind_cb = ns_unbind_cb;
 10137b8:	6323      	str	r3, [r4, #48]	; 0x30
 10137ba:	f003 fddf 	bl	101737c <rpmsg_register_endpoint>
	if (rdev->support_ns && ept->dest_addr == RPMSG_ADDR_ANY) {
 10137be:	f896 3078 	ldrb.w	r3, [r6, #120]	; 0x78
 10137c2:	2b00      	cmp	r3, #0
 10137c4:	d0da      	beq.n	101377c <rpmsg_create_ept+0x38>
 10137c6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 10137c8:	3301      	adds	r3, #1
 10137ca:	d1d7      	bne.n	101377c <rpmsg_create_ept+0x38>
 10137cc:	4638      	mov	r0, r7
 10137ce:	f000 ff3b 	bl	1014648 <z_impl_k_sem_give>
		status = rpmsg_send_ns_message(ept, RPMSG_NS_CREATE);
 10137d2:	2100      	movs	r1, #0
 10137d4:	4620      	mov	r0, r4
 10137d6:	f003 fd88 	bl	10172ea <rpmsg_send_ns_message>
 10137da:	4605      	mov	r5, r0
 10137dc:	4638      	mov	r0, r7
 10137de:	f003 fd7e 	bl	10172de <__metal_mutex_acquire>
		if (status)
 10137e2:	2d00      	cmp	r5, #0
 10137e4:	d0cb      	beq.n	101377e <rpmsg_create_ept+0x3a>
			rpmsg_unregister_endpoint(ept);
 10137e6:	4620      	mov	r0, r4
 10137e8:	f003 fd5b 	bl	10172a2 <rpmsg_unregister_endpoint>
 10137ec:	e7c7      	b.n	101377e <rpmsg_create_ept+0x3a>
{
	unsigned int bit;

	for (bit = start;
	     bit < max && !metal_bitmap_is_bit_clear(bitmap, bit);
	     bit++)
 10137ee:	3301      	adds	r3, #1
	for (bit = start;
 10137f0:	2b80      	cmp	r3, #128	; 0x80
 10137f2:	d0d0      	beq.n	1013796 <rpmsg_create_ept+0x52>
	return ((bitmap[bit / METAL_BITS_PER_ULONG] &
 10137f4:	0959      	lsrs	r1, r3, #5
 10137f6:	eb02 0e81 	add.w	lr, r2, r1, lsl #2
 10137fa:	f852 1021 	ldr.w	r1, [r2, r1, lsl #2]
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1))) == 0) ? 0 : 1;
 10137fe:	f003 0c1f 	and.w	ip, r3, #31
 1013802:	fa21 f00c 	lsr.w	r0, r1, ip
	     bit < max && !metal_bitmap_is_bit_clear(bitmap, bit);
 1013806:	07c0      	lsls	r0, r0, #31
 1013808:	d4f1      	bmi.n	10137ee <rpmsg_create_ept+0xaa>
		metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
 101380a:	2001      	movs	r0, #1
 101380c:	fa00 f00c 	lsl.w	r0, r0, ip
	bitmap[bit / METAL_BITS_PER_ULONG] |=
 1013810:	4308      	orrs	r0, r1
}
 1013812:	461d      	mov	r5, r3
	bitmap[bit / METAL_BITS_PER_ULONG] |=
 1013814:	f8ce 0000 	str.w	r0, [lr]
}
 1013818:	e7bd      	b.n	1013796 <rpmsg_create_ept+0x52>
	for (bit = start;
 101381a:	2300      	movs	r3, #0
 101381c:	e7ea      	b.n	10137f4 <rpmsg_create_ept+0xb0>
		return RPMSG_ERR_PARAM;
 101381e:	4d03      	ldr	r5, [pc, #12]	; (101382c <rpmsg_create_ept+0xe8>)
 1013820:	e7ad      	b.n	101377e <rpmsg_create_ept+0x3a>
		return RPMSG_ERR_PARAM;
 1013822:	4d02      	ldr	r5, [pc, #8]	; (101382c <rpmsg_create_ept+0xe8>)
 1013824:	e7ae      	b.n	1013784 <rpmsg_create_ept+0x40>
 1013826:	bf00      	nop
 1013828:	01019215 	.word	0x01019215
 101382c:	fffff82d 	.word	0xfffff82d

01013830 <rpmsg_virtio_send_offchannel_raw>:
 */
static int rpmsg_virtio_send_offchannel_raw(struct rpmsg_device *rdev,
					    uint32_t src, uint32_t dst,
					    const void *data,
					    int size, int wait)
{
 1013830:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1013834:	4604      	mov	r4, r0
	struct metal_io_region *io;

	/* Get the associated remote device for channel. */
	rvdev = metal_container_of(rdev, struct rpmsg_virtio_device, rdev);

	status = rpmsg_virtio_get_status(rvdev);
 1013836:	6fc0      	ldr	r0, [r0, #124]	; 0x7c
{
 1013838:	469b      	mov	fp, r3
	rvdev->vdev->func->set_status(rvdev->vdev, status);
}

static inline uint8_t rpmsg_virtio_get_status(struct rpmsg_virtio_device *rvdev)
{
	return rvdev->vdev->func->get_status(rvdev->vdev);
 101383a:	6a03      	ldr	r3, [r0, #32]
 101383c:	b08d      	sub	sp, #52	; 0x34
 101383e:	681b      	ldr	r3, [r3, #0]
 1013840:	4692      	mov	sl, r2
 1013842:	e9dd 6716 	ldrd	r6, r7, [sp, #88]	; 0x58
 1013846:	9103      	str	r1, [sp, #12]
 1013848:	4798      	blx	r3
	/* Validate device state */
	if (!(status & VIRTIO_CONFIG_STATUS_DRIVER_OK)) {
 101384a:	0743      	lsls	r3, r0, #29
 101384c:	f140 8089 	bpl.w	1013962 <rpmsg_virtio_send_offchannel_raw+0x132>
		return RPMSG_ERR_DEV_STATE;
	}

	if (wait)
		tick_count = RPMSG_TICK_COUNT / RPMSG_TICKS_PER_INTERVAL;
 1013850:	f643 2398 	movw	r3, #15000	; 0x3a98
 1013854:	2f00      	cmp	r7, #0
 1013856:	bf18      	it	ne
 1013858:	461f      	movne	r7, r3

	while (1) {
		int avail_size;

		/* Lock the device to enable exclusive access to virtqueues */
		metal_mutex_acquire(&rdev->lock);
 101385a:	f104 0858 	add.w	r8, r4, #88	; 0x58
 101385e:	4640      	mov	r0, r8
 1013860:	f003 fdcb 	bl	10173fa <__metal_mutex_acquire>
	return rvdev->vdev->role;
 1013864:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 1013866:	699b      	ldr	r3, [r3, #24]
	if (role == RPMSG_MASTER) {
 1013868:	b373      	cbz	r3, 10138c8 <rpmsg_virtio_send_offchannel_raw+0x98>
	if (role == RPMSG_REMOTE) {
 101386a:	2b01      	cmp	r3, #1
 101386c:	d108      	bne.n	1013880 <rpmsg_virtio_send_offchannel_raw+0x50>
		    (int)virtqueue_get_desc_size(rvdev->svq) -
 101386e:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 1013872:	f003 fcfe 	bl	1017272 <virtqueue_get_desc_size>
 1013876:	3810      	subs	r0, #16
		avail_size = _rpmsg_virtio_get_buffer_size(rvdev);
		if (avail_size && size > avail_size) {
 1013878:	2800      	cmp	r0, #0
 101387a:	ea20 79e0 	bic.w	r9, r0, r0, asr #31
 101387e:	dc25      	bgt.n	10138cc <rpmsg_virtio_send_offchannel_raw+0x9c>
		length = RPMSG_BUFFER_SIZE - sizeof(struct rpmsg_hdr);
 1013880:	f04f 0900 	mov.w	r9, #0
 1013884:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 1013886:	699b      	ldr	r3, [r3, #24]
	if (role == RPMSG_MASTER) {
 1013888:	bb3b      	cbnz	r3, 10138da <rpmsg_virtio_send_offchannel_raw+0xaa>
		data = virtqueue_get_buffer(rvdev->svq, len, idx);
 101388a:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 101388e:	f10d 0212 	add.w	r2, sp, #18
 1013892:	a905      	add	r1, sp, #20
 1013894:	f003 fbfc 	bl	1017090 <virtqueue_get_buffer>
		if (!data) {
 1013898:	4605      	mov	r5, r0
 101389a:	b948      	cbnz	r0, 10138b0 <rpmsg_virtio_send_offchannel_raw+0x80>
			data = rpmsg_virtio_shm_pool_get_buffer(rvdev->shpool,
 101389c:	f44f 7100 	mov.w	r1, #512	; 0x200
 10138a0:	f8d4 008c 	ldr.w	r0, [r4, #140]	; 0x8c
 10138a4:	f003 fe58 	bl	1017558 <rpmsg_virtio_shm_pool_get_buffer>
			*len = RPMSG_BUFFER_SIZE;
 10138a8:	f44f 7300 	mov.w	r3, #512	; 0x200
			data = rpmsg_virtio_shm_pool_get_buffer(rvdev->shpool,
 10138ac:	4605      	mov	r5, r0
			*len = RPMSG_BUFFER_SIZE;
 10138ae:	9305      	str	r3, [sp, #20]
	k_sem_take(m, K_FOREVER);
}

static inline void __metal_mutex_release(metal_mutex_t *m)
{
	k_sem_give(m);
 10138b0:	4640      	mov	r0, r8
 10138b2:	f003 fd8a 	bl	10173ca <k_sem_give>
			return RPMSG_ERR_BUFF_SIZE;
		}

		buffer = rpmsg_virtio_get_tx_buffer(rvdev, &buff_len, &idx);
		metal_mutex_release(&rdev->lock);
		if (buffer || !tick_count)
 10138b6:	2d00      	cmp	r5, #0
 10138b8:	d157      	bne.n	101396a <rpmsg_virtio_send_offchannel_raw+0x13a>
 10138ba:	2f00      	cmp	r7, #0
 10138bc:	d053      	beq.n	1013966 <rpmsg_virtio_send_offchannel_raw+0x136>
			break;
		if (avail_size != 0)
 10138be:	f1b9 0f00 	cmp.w	r9, #0
 10138c2:	d108      	bne.n	10138d6 <rpmsg_virtio_send_offchannel_raw+0xa6>
			return RPMSG_ERR_BUFF_SIZE;
		metal_sleep_usec(RPMSG_TICKS_PER_INTERVAL);
		tick_count--;
 10138c4:	3f01      	subs	r7, #1
	while (1) {
 10138c6:	e7ca      	b.n	101385e <rpmsg_virtio_send_offchannel_raw+0x2e>
		length = RPMSG_BUFFER_SIZE - sizeof(struct rpmsg_hdr);
 10138c8:	f44f 79f8 	mov.w	r9, #496	; 0x1f0
		if (avail_size && size > avail_size) {
 10138cc:	454e      	cmp	r6, r9
 10138ce:	ddd9      	ble.n	1013884 <rpmsg_virtio_send_offchannel_raw+0x54>
 10138d0:	4640      	mov	r0, r8
 10138d2:	f003 fd7a 	bl	10173ca <k_sem_give>
			return RPMSG_ERR_BUFF_SIZE;
 10138d6:	4e31      	ldr	r6, [pc, #196]	; (101399c <rpmsg_virtio_send_offchannel_raw+0x16c>)
 10138d8:	e03f      	b.n	101395a <rpmsg_virtio_send_offchannel_raw+0x12a>
	if (role == RPMSG_REMOTE) {
 10138da:	2b01      	cmp	r3, #1
 10138dc:	d108      	bne.n	10138f0 <rpmsg_virtio_send_offchannel_raw+0xc0>
		data = virtqueue_get_available_buffer(rvdev->svq, idx, len);
 10138de:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 10138e2:	aa05      	add	r2, sp, #20
 10138e4:	f10d 0112 	add.w	r1, sp, #18
 10138e8:	f003 fc0c 	bl	1017104 <virtqueue_get_available_buffer>
 10138ec:	4605      	mov	r5, r0
 10138ee:	e7df      	b.n	10138b0 <rpmsg_virtio_send_offchannel_raw+0x80>
	void *data = NULL;
 10138f0:	2500      	movs	r5, #0
 10138f2:	e7dd      	b.n	10138b0 <rpmsg_virtio_send_offchannel_raw+0x80>
 10138f4:	683b      	ldr	r3, [r7, #0]

	return (offset < io->size ? offset : METAL_BAD_OFFSET);
 10138f6:	68b8      	ldr	r0, [r7, #8]
	io = rvdev->shbuf_io;
	status = metal_io_block_write(io, metal_io_virt_to_offset(io, buffer),
				      &rp_hdr, sizeof(rp_hdr));
	RPMSG_ASSERT(status == sizeof(rp_hdr), "failed to write header\r\n");

	status = metal_io_block_write(io,
 10138f8:	f105 0110 	add.w	r1, r5, #16
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
 10138fc:	1ac9      	subs	r1, r1, r3
 10138fe:	4281      	cmp	r1, r0
 1013900:	bf28      	it	cs
 1013902:	f04f 31ff 	movcs.w	r1, #4294967295
 1013906:	4633      	mov	r3, r6
 1013908:	465a      	mov	r2, fp
 101390a:	4638      	mov	r0, r7
 101390c:	f003 fa9f 	bl	1016e4e <metal_io_block_write>
				      metal_io_virt_to_offset(io,
						RPMSG_LOCATE_DATA(buffer)),
				      data, size);
	RPMSG_ASSERT(status == size, "failed to write buffer\r\n");
 1013910:	4286      	cmp	r6, r0
 1013912:	d000      	beq.n	1013916 <rpmsg_virtio_send_offchannel_raw+0xe6>
 1013914:	e7fe      	b.n	1013914 <rpmsg_virtio_send_offchannel_raw+0xe4>
 1013916:	4640      	mov	r0, r8
 1013918:	f003 fd6f 	bl	10173fa <__metal_mutex_acquire>
 101391c:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
	metal_mutex_acquire(&rdev->lock);

	/* Enqueue buffer on virtqueue. */
	status = rpmsg_virtio_enqueue_buffer(rvdev, buffer, buff_len, idx);
 101391e:	9a05      	ldr	r2, [sp, #20]
 1013920:	699b      	ldr	r3, [r3, #24]
	if (role == RPMSG_MASTER) {
 1013922:	b953      	cbnz	r3, 101393a <rpmsg_virtio_send_offchannel_raw+0x10a>
		vqbuf.len = len;
 1013924:	e9cd 5206 	strd	r5, r2, [sp, #24]
		return virtqueue_add_buffer(rvdev->svq, &vqbuf, 1, 0, buffer);
 1013928:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 101392c:	2201      	movs	r2, #1
 101392e:	9500      	str	r5, [sp, #0]
 1013930:	a906      	add	r1, sp, #24
 1013932:	f003 fb4d 	bl	1016fd0 <virtqueue_add_buffer>
	RPMSG_ASSERT(status == VQUEUE_SUCCESS, "failed to enqueue buffer\r\n");
 1013936:	b148      	cbz	r0, 101394c <rpmsg_virtio_send_offchannel_raw+0x11c>
 1013938:	e7fe      	b.n	1013938 <rpmsg_virtio_send_offchannel_raw+0x108>
	if (role == RPMSG_REMOTE) {
 101393a:	2b01      	cmp	r3, #1
 101393c:	d106      	bne.n	101394c <rpmsg_virtio_send_offchannel_raw+0x11c>
		return virtqueue_add_consumed_buffer(rvdev->svq, idx, len);
 101393e:	f8bd 1012 	ldrh.w	r1, [sp, #18]
 1013942:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 1013946:	f7ff fecf 	bl	10136e8 <virtqueue_add_consumed_buffer>
 101394a:	e7f4      	b.n	1013936 <rpmsg_virtio_send_offchannel_raw+0x106>
	/* Let the other side know that there is a job to process. */
	virtqueue_kick(rvdev->svq);
 101394c:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 1013950:	f003 fc57 	bl	1017202 <virtqueue_kick>
 1013954:	4640      	mov	r0, r8
 1013956:	f003 fd38 	bl	10173ca <k_sem_give>

	metal_mutex_release(&rdev->lock);

	return size;
}
 101395a:	4630      	mov	r0, r6
 101395c:	b00d      	add	sp, #52	; 0x34
 101395e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		return RPMSG_ERR_DEV_STATE;
 1013962:	4e0f      	ldr	r6, [pc, #60]	; (10139a0 <rpmsg_virtio_send_offchannel_raw+0x170>)
 1013964:	e7f9      	b.n	101395a <rpmsg_virtio_send_offchannel_raw+0x12a>
		return RPMSG_ERR_NO_BUFF;
 1013966:	4e0f      	ldr	r6, [pc, #60]	; (10139a4 <rpmsg_virtio_send_offchannel_raw+0x174>)
 1013968:	e7f7      	b.n	101395a <rpmsg_virtio_send_offchannel_raw+0x12a>
	rp_hdr.src = src;
 101396a:	9b03      	ldr	r3, [sp, #12]
	io = rvdev->shbuf_io;
 101396c:	f8d4 7088 	ldr.w	r7, [r4, #136]	; 0x88
	rp_hdr.src = src;
 1013970:	9308      	str	r3, [sp, #32]
	rp_hdr.reserved = 0;
 1013972:	2300      	movs	r3, #0
 1013974:	6839      	ldr	r1, [r7, #0]
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
 1013976:	68b8      	ldr	r0, [r7, #8]
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
 1013978:	1a69      	subs	r1, r5, r1
	status = metal_io_block_write(io, metal_io_virt_to_offset(io, buffer),
 101397a:	4281      	cmp	r1, r0
 101397c:	bf28      	it	cs
 101397e:	f04f 31ff 	movcs.w	r1, #4294967295
	rp_hdr.reserved = 0;
 1013982:	930a      	str	r3, [sp, #40]	; 0x28
	status = metal_io_block_write(io, metal_io_virt_to_offset(io, buffer),
 1013984:	4638      	mov	r0, r7
 1013986:	2310      	movs	r3, #16
 1013988:	aa08      	add	r2, sp, #32
	rp_hdr.dst = dst;
 101398a:	f8cd a024 	str.w	sl, [sp, #36]	; 0x24
	rp_hdr.len = size;
 101398e:	f8ad 602c 	strh.w	r6, [sp, #44]	; 0x2c
	status = metal_io_block_write(io, metal_io_virt_to_offset(io, buffer),
 1013992:	f003 fa5c 	bl	1016e4e <metal_io_block_write>
	RPMSG_ASSERT(status == sizeof(rp_hdr), "failed to write header\r\n");
 1013996:	2810      	cmp	r0, #16
 1013998:	d0ac      	beq.n	10138f4 <rpmsg_virtio_send_offchannel_raw+0xc4>
 101399a:	e7fe      	b.n	101399a <rpmsg_virtio_send_offchannel_raw+0x16a>
 101399c:	fffff82b 	.word	0xfffff82b
 10139a0:	fffff82c 	.word	0xfffff82c
 10139a4:	fffff82e 	.word	0xfffff82e

010139a8 <rpmsg_init_vdev>:
int rpmsg_init_vdev(struct rpmsg_virtio_device *rvdev,
		    struct virtio_device *vdev,
		    rpmsg_ns_bind_cb ns_bind_cb,
		    struct metal_io_region *shm_io,
		    struct rpmsg_virtio_shm_pool *shpool)
{
 10139a8:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 10139ac:	460d      	mov	r5, r1
 10139ae:	b088      	sub	sp, #32
 10139b0:	4617      	mov	r7, r2
	vq_callback callback[RPMSG_NUM_VRINGS];
	int status;
	unsigned int i, role;

	rdev = &rvdev->rdev;
	memset(rdev, 0, sizeof(*rdev));
 10139b2:	2100      	movs	r1, #0
 10139b4:	227c      	movs	r2, #124	; 0x7c
{
 10139b6:	4604      	mov	r4, r0
 10139b8:	461e      	mov	r6, r3
 10139ba:	f8dd 9040 	ldr.w	r9, [sp, #64]	; 0x40
	memset(rdev, 0, sizeof(*rdev));
 10139be:	f002 ffa6 	bl	101690e <memset>
	return z_impl_k_sem_init(sem, initial_count, limit);
 10139c2:	2201      	movs	r2, #1
 10139c4:	f104 0058 	add.w	r0, r4, #88	; 0x58
 10139c8:	4611      	mov	r1, r2
 10139ca:	f004 f87d 	bl	1017ac8 <z_impl_k_sem_init>
	metal_mutex_init(&rdev->lock);
	rvdev->vdev = vdev;
	rdev->ns_bind_cb = ns_bind_cb;
	vdev->priv = rvdev;
	rdev->ops.send_offchannel_raw = rpmsg_virtio_send_offchannel_raw;
 10139ce:	4b5e      	ldr	r3, [pc, #376]	; (1013b48 <rpmsg_init_vdev+0x1a0>)
	rvdev->vdev = vdev;
 10139d0:	67e5      	str	r5, [r4, #124]	; 0x7c
	rdev->ns_bind_cb = ns_bind_cb;
 10139d2:	6727      	str	r7, [r4, #112]	; 0x70
	vdev->priv = rvdev;
 10139d4:	626c      	str	r4, [r5, #36]	; 0x24
	rdev->ops.send_offchannel_raw = rpmsg_virtio_send_offchannel_raw;
 10139d6:	6763      	str	r3, [r4, #116]	; 0x74
 10139d8:	6fe3      	ldr	r3, [r4, #124]	; 0x7c
 10139da:	f8d3 8018 	ldr.w	r8, [r3, #24]
	role = rpmsg_virtio_get_role(rvdev);

#ifndef VIRTIO_MASTER_ONLY
	if (role == RPMSG_REMOTE) {
 10139de:	f1b8 0f01 	cmp.w	r8, #1
 10139e2:	d020      	beq.n	1013a26 <rpmsg_init_vdev+0x7e>
		/* wait synchro with the master */
		rpmsg_virtio_wait_remote_ready(rvdev);
	}
#endif /*!VIRTIO_MASTER_ONLY*/
	vdev->features = rpmsg_virtio_get_features(rvdev);
 10139e4:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
}

static inline uint32_t
rpmsg_virtio_get_features(struct rpmsg_virtio_device *rvdev)
{
	return rvdev->vdev->func->get_features(rvdev->vdev);
 10139e6:	6a03      	ldr	r3, [r0, #32]
 10139e8:	689b      	ldr	r3, [r3, #8]
 10139ea:	4798      	blx	r3
 10139ec:	2300      	movs	r3, #0
 10139ee:	6128      	str	r0, [r5, #16]
	rdev->support_ns = !!(vdev->features & (1 << VIRTIO_RPMSG_F_NS));
 10139f0:	f000 0001 	and.w	r0, r0, #1
	vdev->features = rpmsg_virtio_get_features(rvdev);
 10139f4:	616b      	str	r3, [r5, #20]
	rdev->support_ns = !!(vdev->features & (1 << VIRTIO_RPMSG_F_NS));
 10139f6:	f884 0078 	strb.w	r0, [r4, #120]	; 0x78

#ifndef VIRTIO_SLAVE_ONLY
	if (role == RPMSG_MASTER) {
 10139fa:	f1b8 0f00 	cmp.w	r8, #0
 10139fe:	d01e      	beq.n	1013a3e <rpmsg_init_vdev+0x96>
	}
#endif /*!VIRTIO_SLAVE_ONLY*/

#ifndef VIRTIO_MASTER_ONLY
	(void)shpool;
	if (role == RPMSG_REMOTE) {
 1013a00:	f1b8 0f01 	cmp.w	r8, #1
 1013a04:	d133      	bne.n	1013a6e <rpmsg_init_vdev+0xc6>
		vq_names[0] = "tx_vq";
 1013a06:	4b51      	ldr	r3, [pc, #324]	; (1013b4c <rpmsg_init_vdev+0x1a4>)
 1013a08:	9302      	str	r3, [sp, #8]
		vq_names[1] = "rx_vq";
 1013a0a:	4b51      	ldr	r3, [pc, #324]	; (1013b50 <rpmsg_init_vdev+0x1a8>)
 1013a0c:	9303      	str	r3, [sp, #12]
		callback[0] = rpmsg_virtio_tx_callback;
 1013a0e:	4b51      	ldr	r3, [pc, #324]	; (1013b54 <rpmsg_init_vdev+0x1ac>)
 1013a10:	9304      	str	r3, [sp, #16]
		callback[1] = rpmsg_virtio_rx_callback;
 1013a12:	4b51      	ldr	r3, [pc, #324]	; (1013b58 <rpmsg_init_vdev+0x1b0>)
 1013a14:	9305      	str	r3, [sp, #20]
		rvdev->rvq  = vdev->vrings_info[1].vq;
 1013a16:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 1013a18:	699a      	ldr	r2, [r3, #24]
		rvdev->svq  = vdev->vrings_info[0].vq;
 1013a1a:	681b      	ldr	r3, [r3, #0]
		rvdev->rvq  = vdev->vrings_info[1].vq;
 1013a1c:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
		rvdev->svq  = vdev->vrings_info[0].vq;
 1013a20:	e023      	b.n	1013a6a <rpmsg_init_vdev+0xc2>
		} else if (status & VIRTIO_CONFIG_STATUS_DRIVER_OK) {
 1013a22:	0743      	lsls	r3, r0, #29
 1013a24:	d4de      	bmi.n	10139e4 <rpmsg_init_vdev+0x3c>
		status = rpmsg_virtio_get_status(rvdev);
 1013a26:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
	return rvdev->vdev->func->get_status(rvdev->vdev);
 1013a28:	6a03      	ldr	r3, [r0, #32]
 1013a2a:	681b      	ldr	r3, [r3, #0]
 1013a2c:	4798      	blx	r3
		if (status & VIRTIO_CONFIG_STATUS_NEEDS_RESET) {
 1013a2e:	0642      	lsls	r2, r0, #25
 1013a30:	d5f7      	bpl.n	1013a22 <rpmsg_init_vdev+0x7a>
			rpmsg_virtio_set_status(rvdev, 0);
 1013a32:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
	rvdev->vdev->func->set_status(rvdev->vdev, status);
 1013a34:	2100      	movs	r1, #0
 1013a36:	6a03      	ldr	r3, [r0, #32]
 1013a38:	685b      	ldr	r3, [r3, #4]
 1013a3a:	4798      	blx	r3
}
 1013a3c:	e7f3      	b.n	1013a26 <rpmsg_init_vdev+0x7e>
		if (!shpool)
 1013a3e:	f1b9 0f00 	cmp.w	r9, #0
 1013a42:	d07d      	beq.n	1013b40 <rpmsg_init_vdev+0x198>
		if (!shpool->size)
 1013a44:	f8d9 3008 	ldr.w	r3, [r9, #8]
 1013a48:	2b00      	cmp	r3, #0
 1013a4a:	d07b      	beq.n	1013b44 <rpmsg_init_vdev+0x19c>
		vq_names[0] = "rx_vq";
 1013a4c:	4b40      	ldr	r3, [pc, #256]	; (1013b50 <rpmsg_init_vdev+0x1a8>)
		rvdev->shpool = shpool;
 1013a4e:	f8c4 908c 	str.w	r9, [r4, #140]	; 0x8c
		vq_names[0] = "rx_vq";
 1013a52:	9302      	str	r3, [sp, #8]
		vq_names[1] = "tx_vq";
 1013a54:	4b3d      	ldr	r3, [pc, #244]	; (1013b4c <rpmsg_init_vdev+0x1a4>)
 1013a56:	9303      	str	r3, [sp, #12]
		callback[0] = rpmsg_virtio_rx_callback;
 1013a58:	4b3f      	ldr	r3, [pc, #252]	; (1013b58 <rpmsg_init_vdev+0x1b0>)
 1013a5a:	9304      	str	r3, [sp, #16]
		callback[1] = rpmsg_virtio_tx_callback;
 1013a5c:	4b3d      	ldr	r3, [pc, #244]	; (1013b54 <rpmsg_init_vdev+0x1ac>)
 1013a5e:	9305      	str	r3, [sp, #20]
		rvdev->rvq  = vdev->vrings_info[0].vq;
 1013a60:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
 1013a62:	681a      	ldr	r2, [r3, #0]
		rvdev->svq  = vdev->vrings_info[1].vq;
 1013a64:	699b      	ldr	r3, [r3, #24]
		rvdev->rvq  = vdev->vrings_info[0].vq;
 1013a66:	f8c4 2080 	str.w	r2, [r4, #128]	; 0x80
		rvdev->svq  = vdev->vrings_info[0].vq;
 1013a6a:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
rpmsg_virtio_create_virtqueues(struct rpmsg_virtio_device *rvdev,
			       int flags, unsigned int nvqs,
			       const char *names[],
			       vq_callback *callbacks)
{
	return virtio_create_virtqueues(rvdev->vdev, flags, nvqs, names,
 1013a6e:	ab04      	add	r3, sp, #16
 1013a70:	9300      	str	r3, [sp, #0]
 1013a72:	2202      	movs	r2, #2
 1013a74:	2100      	movs	r1, #0
 1013a76:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
	}
#endif /*!VIRTIO_MASTER_ONLY*/
	rvdev->shbuf_io = shm_io;
 1013a78:	f8c4 6088 	str.w	r6, [r4, #136]	; 0x88
 1013a7c:	ab02      	add	r3, sp, #8
 1013a7e:	f7ff fde3 	bl	1013648 <virtio_create_virtqueues>

	/* Create virtqueues for remote device */
	status = rpmsg_virtio_create_virtqueues(rvdev, 0, RPMSG_NUM_VRINGS,
						vq_names, callback);
	if (status != RPMSG_SUCCESS)
 1013a82:	4607      	mov	r7, r0
 1013a84:	2800      	cmp	r0, #0
 1013a86:	d157      	bne.n	1013b38 <rpmsg_init_vdev+0x190>

	/*
	 * Suppress "tx-complete" interrupts
	 * since send method use busy loop when buffer pool exhaust
	 */
	virtqueue_disable_cb(rvdev->svq);
 1013a88:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 1013a8c:	f003 fb8f 	bl	10171ae <virtqueue_disable_cb>

	/* TODO: can have a virtio function to set the shared memory I/O */
	for (i = 0; i < RPMSG_NUM_VRINGS; i++) {
		struct virtqueue *vq;

		vq = vdev->vrings_info[i].vq;
 1013a90:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
		vq->shm_io = shm_io;
 1013a92:	681a      	ldr	r2, [r3, #0]
 1013a94:	699b      	ldr	r3, [r3, #24]
 1013a96:	6296      	str	r6, [r2, #40]	; 0x28
 1013a98:	629e      	str	r6, [r3, #40]	; 0x28
	}

#ifndef VIRTIO_SLAVE_ONLY
	if (role == RPMSG_MASTER) {
 1013a9a:	f1b8 0f00 	cmp.w	r8, #0
 1013a9e:	d108      	bne.n	1013ab2 <rpmsg_init_vdev+0x10a>
		struct virtqueue_buf vqbuf;
		unsigned int idx;
		void *buffer;

		vqbuf.len = RPMSG_BUFFER_SIZE;
 1013aa0:	f44f 7300 	mov.w	r3, #512	; 0x200
		for (idx = 0; idx < rvdev->rvq->vq_nentries; idx++) {
 1013aa4:	46c2      	mov	sl, r8
		vqbuf.len = RPMSG_BUFFER_SIZE;
 1013aa6:	9307      	str	r3, [sp, #28]
		for (idx = 0; idx < rvdev->rvq->vq_nentries; idx++) {
 1013aa8:	f8d4 3080 	ldr.w	r3, [r4, #128]	; 0x80
 1013aac:	895b      	ldrh	r3, [r3, #10]
 1013aae:	4553      	cmp	r3, sl
 1013ab0:	d81f      	bhi.n	1013af2 <rpmsg_init_vdev+0x14a>

	/*
	 * Create name service announcement endpoint if device supports name
	 * service announcement feature.
	 */
	if (rdev->support_ns) {
 1013ab2:	f894 3078 	ldrb.w	r3, [r4, #120]	; 0x78
 1013ab6:	e9c4 4400 	strd	r4, r4, [r4]
 1013aba:	b18b      	cbz	r3, 1013ae0 <rpmsg_init_vdev+0x138>
		rpmsg_init_ept(&rdev->ns_ept, "NS",
 1013abc:	f104 0508 	add.w	r5, r4, #8
	strncpy(ept->name, name ? name : "", sizeof(ept->name));
 1013ac0:	4926      	ldr	r1, [pc, #152]	; (1013b5c <rpmsg_init_vdev+0x1b4>)
 1013ac2:	2220      	movs	r2, #32
 1013ac4:	4628      	mov	r0, r5
 1013ac6:	f002 feb2 	bl	101682e <strncpy>
	ept->addr = src;
 1013aca:	2335      	movs	r3, #53	; 0x35
	ept->dest_addr = dest;
 1013acc:	e9c4 330b 	strd	r3, r3, [r4, #44]	; 0x2c
	ept->cb = cb;
 1013ad0:	4b23      	ldr	r3, [pc, #140]	; (1013b60 <rpmsg_init_vdev+0x1b8>)
			       RPMSG_NS_EPT_ADDR, RPMSG_NS_EPT_ADDR,
			       rpmsg_virtio_ns_callback, NULL);
		rpmsg_register_endpoint(rdev, &rdev->ns_ept);
 1013ad2:	4629      	mov	r1, r5
 1013ad4:	6363      	str	r3, [r4, #52]	; 0x34
	ept->ns_unbind_cb = ns_unbind_cb;
 1013ad6:	2300      	movs	r3, #0
 1013ad8:	4620      	mov	r0, r4
 1013ada:	63a3      	str	r3, [r4, #56]	; 0x38
 1013adc:	f003 fc4e 	bl	101737c <rpmsg_register_endpoint>
	}

#ifndef VIRTIO_SLAVE_ONLY
	if (role == RPMSG_MASTER)
 1013ae0:	f1b8 0f00 	cmp.w	r8, #0
 1013ae4:	d128      	bne.n	1013b38 <rpmsg_init_vdev+0x190>
		rpmsg_virtio_set_status(rvdev, VIRTIO_CONFIG_STATUS_DRIVER_OK);
 1013ae6:	6fe0      	ldr	r0, [r4, #124]	; 0x7c
	rvdev->vdev->func->set_status(rvdev->vdev, status);
 1013ae8:	2104      	movs	r1, #4
 1013aea:	6a03      	ldr	r3, [r0, #32]
 1013aec:	685b      	ldr	r3, [r3, #4]
 1013aee:	4798      	blx	r3
}
 1013af0:	e022      	b.n	1013b38 <rpmsg_init_vdev+0x190>
			buffer = rpmsg_virtio_shm_pool_get_buffer(shpool,
 1013af2:	f44f 7100 	mov.w	r1, #512	; 0x200
 1013af6:	4648      	mov	r0, r9
 1013af8:	f003 fd2e 	bl	1017558 <rpmsg_virtio_shm_pool_get_buffer>
			if (!buffer) {
 1013afc:	4605      	mov	r5, r0
 1013afe:	b1c8      	cbz	r0, 1013b34 <rpmsg_init_vdev+0x18c>
 1013b00:	6831      	ldr	r1, [r6, #0]
			vqbuf.buf = buffer;
 1013b02:	9006      	str	r0, [sp, #24]
 1013b04:	1a41      	subs	r1, r0, r1
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
 1013b06:	68b0      	ldr	r0, [r6, #8]
			metal_io_block_set(shm_io,
 1013b08:	f44f 7300 	mov.w	r3, #512	; 0x200
 1013b0c:	4281      	cmp	r1, r0
 1013b0e:	bf28      	it	cs
 1013b10:	f04f 31ff 	movcs.w	r1, #4294967295
 1013b14:	2200      	movs	r2, #0
 1013b16:	4630      	mov	r0, r6
 1013b18:	f003 f9d4 	bl	1016ec4 <metal_io_block_set>
				virtqueue_add_buffer(rvdev->rvq, &vqbuf, 0, 1,
 1013b1c:	2301      	movs	r3, #1
 1013b1e:	2200      	movs	r2, #0
 1013b20:	f8d4 0080 	ldr.w	r0, [r4, #128]	; 0x80
 1013b24:	9500      	str	r5, [sp, #0]
 1013b26:	a906      	add	r1, sp, #24
 1013b28:	f003 fa52 	bl	1016fd0 <virtqueue_add_buffer>
			if (status != RPMSG_SUCCESS) {
 1013b2c:	b918      	cbnz	r0, 1013b36 <rpmsg_init_vdev+0x18e>
		for (idx = 0; idx < rvdev->rvq->vq_nentries; idx++) {
 1013b2e:	f10a 0a01 	add.w	sl, sl, #1
 1013b32:	e7b9      	b.n	1013aa8 <rpmsg_init_vdev+0x100>
				return RPMSG_ERR_NO_BUFF;
 1013b34:	480b      	ldr	r0, [pc, #44]	; (1013b64 <rpmsg_init_vdev+0x1bc>)
 1013b36:	4607      	mov	r7, r0
#endif /*!VIRTIO_SLAVE_ONLY*/

	return status;
}
 1013b38:	4638      	mov	r0, r7
 1013b3a:	b008      	add	sp, #32
 1013b3c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
			return RPMSG_ERR_PARAM;
 1013b40:	4f09      	ldr	r7, [pc, #36]	; (1013b68 <rpmsg_init_vdev+0x1c0>)
 1013b42:	e7f9      	b.n	1013b38 <rpmsg_init_vdev+0x190>
			return RPMSG_ERR_NO_BUFF;
 1013b44:	4f07      	ldr	r7, [pc, #28]	; (1013b64 <rpmsg_init_vdev+0x1bc>)
 1013b46:	e7f7      	b.n	1013b38 <rpmsg_init_vdev+0x190>
 1013b48:	01013831 	.word	0x01013831
 1013b4c:	01019994 	.word	0x01019994
 1013b50:	0101998e 	.word	0x0101998e
 1013b54:	010173c9 	.word	0x010173c9
 1013b58:	01017499 	.word	0x01017499
 1013b5c:	0101999a 	.word	0x0101999a
 1013b60:	01017407 	.word	0x01017407
 1013b64:	fffff82e 	.word	0xfffff82e
 1013b68:	fffff82d 	.word	0xfffff82d

01013b6c <z_sys_init_run_level>:
 * off and the next one begins.
 *
 * @param level init level to run.
 */
void z_sys_init_run_level(s32_t level)
{
 1013b6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
			if (dev) {
				/* Initialization failed. Clear the API struct
				 * so that device_get_binding() will not succeed
				 * for it.
				 */
				dev->driver_api = NULL;
 1013b6e:	2700      	movs	r7, #0
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 1013b70:	4b08      	ldr	r3, [pc, #32]	; (1013b94 <z_sys_init_run_level+0x28>)
 1013b72:	f853 4020 	ldr.w	r4, [r3, r0, lsl #2]
 1013b76:	3001      	adds	r0, #1
 1013b78:	f853 6020 	ldr.w	r6, [r3, r0, lsl #2]
 1013b7c:	42a6      	cmp	r6, r4
 1013b7e:	d800      	bhi.n	1013b82 <z_sys_init_run_level+0x16>
			}
		}
	}
}
 1013b80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		retval = entry->init(dev);
 1013b82:	e9d4 3500 	ldrd	r3, r5, [r4]
 1013b86:	4628      	mov	r0, r5
 1013b88:	4798      	blx	r3
		if (retval != 0) {
 1013b8a:	b108      	cbz	r0, 1013b90 <z_sys_init_run_level+0x24>
			if (dev) {
 1013b8c:	b105      	cbz	r5, 1013b90 <z_sys_init_run_level+0x24>
				dev->driver_api = NULL;
 1013b8e:	60af      	str	r7, [r5, #8]
	for (entry = levels[level]; entry < levels[level+1]; entry++) {
 1013b90:	3408      	adds	r4, #8
 1013b92:	e7f3      	b.n	1013b7c <z_sys_init_run_level+0x10>
 1013b94:	01018e2c 	.word	0x01018e2c

01013b98 <z_impl_device_get_binding>:
	/* Split the search into two loops: in the common scenario, where
	 * device names are stored in ROM (and are referenced by the user
	 * with CONFIG_* macros), only cheap pointer comparisons will be
	 * performed. Reserve string comparisons for a fallback.
	 */
	for (dev = __device_start; dev != __device_end; dev++) {
 1013b98:	4b0f      	ldr	r3, [pc, #60]	; (1013bd8 <z_impl_device_get_binding+0x40>)
{
 1013b9a:	b570      	push	{r4, r5, r6, lr}
 1013b9c:	4605      	mov	r5, r0
 1013b9e:	461e      	mov	r6, r3
	for (dev = __device_start; dev != __device_end; dev++) {
 1013ba0:	4c0e      	ldr	r4, [pc, #56]	; (1013bdc <z_impl_device_get_binding+0x44>)
 1013ba2:	429c      	cmp	r4, r3
 1013ba4:	d104      	bne.n	1013bb0 <z_impl_device_get_binding+0x18>
		    (dev->name == name)) {
			return dev;
		}
	}

	for (dev = __device_start; dev != __device_end; dev++) {
 1013ba6:	4c0d      	ldr	r4, [pc, #52]	; (1013bdc <z_impl_device_get_binding+0x44>)
 1013ba8:	42b4      	cmp	r4, r6
 1013baa:	d108      	bne.n	1013bbe <z_impl_device_get_binding+0x26>
		    (strcmp(name, dev->name) == 0)) {
			return dev;
		}
	}

	return NULL;
 1013bac:	2400      	movs	r4, #0
 1013bae:	e010      	b.n	1013bd2 <z_impl_device_get_binding+0x3a>
		if ((dev->driver_api != NULL) &&
 1013bb0:	68a2      	ldr	r2, [r4, #8]
 1013bb2:	b112      	cbz	r2, 1013bba <z_impl_device_get_binding+0x22>
 1013bb4:	6822      	ldr	r2, [r4, #0]
 1013bb6:	42aa      	cmp	r2, r5
 1013bb8:	d00b      	beq.n	1013bd2 <z_impl_device_get_binding+0x3a>
	for (dev = __device_start; dev != __device_end; dev++) {
 1013bba:	3410      	adds	r4, #16
 1013bbc:	e7f1      	b.n	1013ba2 <z_impl_device_get_binding+0xa>
		if ((dev->driver_api != NULL) &&
 1013bbe:	68a3      	ldr	r3, [r4, #8]
 1013bc0:	b90b      	cbnz	r3, 1013bc6 <z_impl_device_get_binding+0x2e>
	for (dev = __device_start; dev != __device_end; dev++) {
 1013bc2:	3410      	adds	r4, #16
 1013bc4:	e7f0      	b.n	1013ba8 <z_impl_device_get_binding+0x10>
		    (strcmp(name, dev->name) == 0)) {
 1013bc6:	4628      	mov	r0, r5
 1013bc8:	6821      	ldr	r1, [r4, #0]
 1013bca:	f002 fe4a 	bl	1016862 <strcmp>
		if ((dev->driver_api != NULL) &&
 1013bce:	2800      	cmp	r0, #0
 1013bd0:	d1f7      	bne.n	1013bc2 <z_impl_device_get_binding+0x2a>
}
 1013bd2:	4620      	mov	r0, r4
 1013bd4:	bd70      	pop	{r4, r5, r6, pc}
 1013bd6:	bf00      	nop
 1013bd8:	2100052c 	.word	0x2100052c
 1013bdc:	210004ac 	.word	0x210004ac

01013be0 <z_fatal_error>:
	return 0;
#endif
}

void z_fatal_error(unsigned int reason, const z_arch_esf_t *esf)
{
 1013be0:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
 1013be4:	4605      	mov	r5, r0
 1013be6:	460f      	mov	r7, r1
	__asm__ volatile(
 1013be8:	f04f 0320 	mov.w	r3, #32
 1013bec:	f3ef 8811 	mrs	r8, BASEPRI
 1013bf0:	f383 8811 	msr	BASEPRI, r3
 1013bf4:	f3bf 8f6f 	isb	sy
	return z_impl_k_current_get();
 1013bf8:	f000 fd20 	bl	101463c <z_impl_k_current_get>
 1013bfc:	4c22      	ldr	r4, [pc, #136]	; (1013c88 <z_fatal_error+0xa8>)
 1013bfe:	4b23      	ldr	r3, [pc, #140]	; (1013c8c <z_fatal_error+0xac>)
 1013c00:	2d04      	cmp	r5, #4
 1013c02:	eba4 0403 	sub.w	r4, r4, r3
 1013c06:	ea4f 04d4 	mov.w	r4, r4, lsr #3
 1013c0a:	bf98      	it	ls
 1013c0c:	4a20      	ldrls	r2, [pc, #128]	; (1013c90 <z_fatal_error+0xb0>)
	struct k_thread *thread = k_current_get();

	/* sanitycheck looks for the "ZEPHYR FATAL ERROR" string, don't
	 * change it without also updating sanitycheck
	 */
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
 1013c0e:	ea4f 1484 	mov.w	r4, r4, lsl #6
 1013c12:	f044 0301 	orr.w	r3, r4, #1
 1013c16:	4606      	mov	r6, r0
	switch (reason) {
 1013c18:	bf94      	ite	ls
 1013c1a:	f852 2025 	ldrls.w	r2, [r2, r5, lsl #2]
	LOG_ERR(">>> ZEPHYR FATAL ERROR %d: %s on CPU %d", reason,
 1013c1e:	4a1d      	ldrhi	r2, [pc, #116]	; (1013c94 <z_fatal_error+0xb4>)
 1013c20:	f8ad 3000 	strh.w	r3, [sp]
 1013c24:	4629      	mov	r1, r5
 1013c26:	2300      	movs	r3, #0
 1013c28:	481b      	ldr	r0, [pc, #108]	; (1013c98 <z_fatal_error+0xb8>)
 1013c2a:	f001 fbea 	bl	1015402 <log_3>
	 * an IRQ or exception was being handled, or thread context.
	 *
	 * See #17656
	 */
#if defined(CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION)
	if ((esf != NULL) && arch_is_in_nested_exception(esf)) {
 1013c2e:	b147      	cbz	r7, 1013c42 <z_fatal_error+0x62>
 * @return true if execution state was in handler mode, before
 *              the current exception occurred, otherwise false.
 */
static ALWAYS_INLINE bool arch_is_in_nested_exception(const z_arch_esf_t *esf)
{
	return (esf->basic.xpsr & IPSR_ISR_Msk) ? (true) : (false);
 1013c30:	69fb      	ldr	r3, [r7, #28]
 1013c32:	f3c3 0308 	ubfx	r3, r3, #0, #9
 1013c36:	b123      	cbz	r3, 1013c42 <z_fatal_error+0x62>
		LOG_ERR("Fault during interrupt handling\n");
 1013c38:	4818      	ldr	r0, [pc, #96]	; (1013c9c <z_fatal_error+0xbc>)
 1013c3a:	f044 0101 	orr.w	r1, r4, #1
 1013c3e:	f001 fba6 	bl	101538e <log_0>
	const char *thread_name = k_thread_name_get(thread);
 1013c42:	4630      	mov	r0, r6
	}
#endif

	LOG_ERR("Current thread: %p (%s)", thread,
 1013c44:	f044 0401 	orr.w	r4, r4, #1
	const char *thread_name = k_thread_name_get(thread);
 1013c48:	f003 ff59 	bl	1017afe <k_thread_name_get>
	if (thread_name == NULL || thread_name[0] == '\0') {
 1013c4c:	b1d0      	cbz	r0, 1013c84 <z_fatal_error+0xa4>
 1013c4e:	7802      	ldrb	r2, [r0, #0]
		thread_name = "unknown";
 1013c50:	4b13      	ldr	r3, [pc, #76]	; (1013ca0 <z_fatal_error+0xc0>)
 1013c52:	2a00      	cmp	r2, #0
 1013c54:	bf08      	it	eq
 1013c56:	4618      	moveq	r0, r3
	LOG_ERR("Current thread: %p (%s)", thread,
 1013c58:	f7f0 f90e 	bl	1003e78 <log_strdup>
 1013c5c:	4623      	mov	r3, r4
 1013c5e:	4602      	mov	r2, r0
 1013c60:	4631      	mov	r1, r6
 1013c62:	4810      	ldr	r0, [pc, #64]	; (1013ca4 <z_fatal_error+0xc4>)
 1013c64:	f001 fbb4 	bl	10153d0 <log_2>
		log_strdup(thread_name_get(thread)));

	k_sys_fatal_error_handler(reason, esf);
 1013c68:	4639      	mov	r1, r7
 1013c6a:	4628      	mov	r0, r5
 1013c6c:	f7ff fb56 	bl	101331c <k_sys_fatal_error_handler>
	__asm__ volatile(
 1013c70:	f388 8811 	msr	BASEPRI, r8
 1013c74:	f3bf 8f6f 	isb	sy
	z_impl_k_thread_abort(thread);
 1013c78:	4630      	mov	r0, r6
#endif /*CONFIG_ARCH_HAS_NESTED_EXCEPTION_DETECTION */
	}

	arch_irq_unlock(key);
	k_thread_abort(thread);
}
 1013c7a:	b002      	add	sp, #8
 1013c7c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 1013c80:	f7f1 bba0 	b.w	10053c4 <z_impl_k_thread_abort>
		thread_name = "unknown";
 1013c84:	4806      	ldr	r0, [pc, #24]	; (1013ca0 <z_fatal_error+0xc0>)
 1013c86:	e7e7      	b.n	1013c58 <z_fatal_error+0x78>
 1013c88:	010181c0 	.word	0x010181c0
 1013c8c:	010180b8 	.word	0x010180b8
 1013c90:	01018e44 	.word	0x01018e44
 1013c94:	0101999d 	.word	0x0101999d
 1013c98:	010199b3 	.word	0x010199b3
 1013c9c:	010199db 	.word	0x010199db
 1013ca0:	010199ab 	.word	0x010199ab
 1013ca4:	010199fc 	.word	0x010199fc

01013ca8 <idle>:
#else
#define IDLE_YIELD_IF_COOP() do { } while (false)
#endif

void idle(void *unused1, void *unused2, void *unused3)
{
 1013ca8:	b508      	push	{r3, lr}
	_kernel.idle = ticks;
 1013caa:	4d0b      	ldr	r5, [pc, #44]	; (1013cd8 <idle+0x30>)
	__asm__ volatile(
 1013cac:	f04f 0220 	mov.w	r2, #32
 1013cb0:	f3ef 8311 	mrs	r3, BASEPRI
 1013cb4:	f382 8811 	msr	BASEPRI, r2
 1013cb8:	f3bf 8f6f 	isb	sy
	s32_t ticks = z_get_next_timeout_expiry();
 1013cbc:	f003 ffb0 	bl	1017c20 <z_get_next_timeout_expiry>
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
 1013cc0:	2101      	movs	r1, #1
	s32_t ticks = z_get_next_timeout_expiry();
 1013cc2:	4604      	mov	r4, r0
	z_set_timeout_expiry((ticks < IDLE_THRESH) ? 1 : ticks, true);
 1013cc4:	2802      	cmp	r0, #2
 1013cc6:	bfd8      	it	le
 1013cc8:	4608      	movle	r0, r1
 1013cca:	f003 ffb9 	bl	1017c40 <z_set_timeout_expiry>
	_kernel.idle = ticks;
 1013cce:	622c      	str	r4, [r5, #32]
 *
 * @return N/A
 */
static inline void k_cpu_idle(void)
{
	arch_cpu_idle();
 1013cd0:	f7f1 f8b2 	bl	1004e38 <arch_cpu_idle>
}
 1013cd4:	e7ea      	b.n	1013cac <idle+0x4>
 1013cd6:	bf00      	nop
 1013cd8:	210065b8 	.word	0x210065b8

01013cdc <z_bss_zero>:
 *
 * @return N/A
 */
void z_bss_zero(void)
{
	(void)memset(__bss_start, 0, __bss_end - __bss_start);
 1013cdc:	4802      	ldr	r0, [pc, #8]	; (1013ce8 <z_bss_zero+0xc>)
 1013cde:	4a03      	ldr	r2, [pc, #12]	; (1013cec <z_bss_zero+0x10>)
 1013ce0:	2100      	movs	r1, #0
 1013ce2:	1a12      	subs	r2, r2, r0
 1013ce4:	f002 be13 	b.w	101690e <memset>
 1013ce8:	21000660 	.word	0x21000660
 1013cec:	21006700 	.word	0x21006700

01013cf0 <z_data_copy>:
 * This routine copies the data section from ROM to RAM.
 *
 * @return N/A
 */
void z_data_copy(void)
{
 1013cf0:	b508      	push	{r3, lr}
	(void)memcpy(&__data_ram_start, &__data_rom_start,
		 __data_ram_end - __data_ram_start);
 1013cf2:	4806      	ldr	r0, [pc, #24]	; (1013d0c <z_data_copy+0x1c>)
	(void)memcpy(&__data_ram_start, &__data_rom_start,
 1013cf4:	4a06      	ldr	r2, [pc, #24]	; (1013d10 <z_data_copy+0x20>)
 1013cf6:	4907      	ldr	r1, [pc, #28]	; (1013d14 <z_data_copy+0x24>)
 1013cf8:	1a12      	subs	r2, r2, r0
 1013cfa:	f002 fddd 	bl	10168b8 <memcpy>
#else
	(void)memcpy(&_app_smem_start, &_app_smem_rom_start,
		 _app_smem_end - _app_smem_start);
#endif /* CONFIG_STACK_CANARIES */
#endif /* CONFIG_USERSPACE */
}
 1013cfe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	(void)memcpy(&_ramfunc_ram_start, &_ramfunc_rom_start,
 1013d02:	4a05      	ldr	r2, [pc, #20]	; (1013d18 <z_data_copy+0x28>)
 1013d04:	4905      	ldr	r1, [pc, #20]	; (1013d1c <z_data_copy+0x2c>)
 1013d06:	4806      	ldr	r0, [pc, #24]	; (1013d20 <z_data_copy+0x30>)
 1013d08:	f002 bdd6 	b.w	10168b8 <memcpy>
 1013d0c:	21000000 	.word	0x21000000
 1013d10:	2100065c 	.word	0x2100065c
 1013d14:	01019ab0 	.word	0x01019ab0
 1013d18:	00000000 	.word	0x00000000
 1013d1c:	01019ab0 	.word	0x01019ab0
 1013d20:	21000000 	.word	0x21000000

01013d24 <bg_thread_main>:
	static const unsigned int boot_delay = CONFIG_BOOT_DELAY;
#else
	static const unsigned int boot_delay;
#endif

	z_sys_post_kernel = true;
 1013d24:	2201      	movs	r2, #1
{
 1013d26:	b508      	push	{r3, lr}
	z_sys_post_kernel = true;
 1013d28:	4b0b      	ldr	r3, [pc, #44]	; (1013d58 <bg_thread_main+0x34>)

	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
 1013d2a:	2002      	movs	r0, #2
	z_sys_post_kernel = true;
 1013d2c:	701a      	strb	r2, [r3, #0]
	z_sys_init_run_level(_SYS_INIT_LEVEL_POST_KERNEL);
 1013d2e:	f7ff ff1d 	bl	1013b6c <z_sys_init_run_level>
		k_busy_wait(CONFIG_BOOT_DELAY * USEC_PER_MSEC);
	}

#if defined(CONFIG_BOOT_BANNER)
#ifdef BUILD_VERSION
	printk("*** Booting Zephyr OS build %s %s ***\n",
 1013d32:	4a0a      	ldr	r2, [pc, #40]	; (1013d5c <bg_thread_main+0x38>)
 1013d34:	490a      	ldr	r1, [pc, #40]	; (1013d60 <bg_thread_main+0x3c>)
 1013d36:	480b      	ldr	r0, [pc, #44]	; (1013d64 <bg_thread_main+0x40>)
 1013d38:	f001 f84d 	bl	1014dd6 <printk>
	__do_global_ctors_aux();
	__do_init_array_aux();
#endif

	/* Final init level before app starts */
	z_sys_init_run_level(_SYS_INIT_LEVEL_APPLICATION);
 1013d3c:	2003      	movs	r0, #3
 1013d3e:	f7ff ff15 	bl	1013b6c <z_sys_init_run_level>

	z_init_static_threads();
 1013d42:	f000 fd3b 	bl	10147bc <z_init_static_threads>
	z_timestamp_main = k_cycle_get_32();
#endif

	extern void main(void);

	main();
 1013d46:	f7ef fc31 	bl	10035ac <main>

	/* Mark nonessenrial since main() has no more work to do */
	z_main_thread.base.user_options &= ~K_ESSENTIAL;
 1013d4a:	4a07      	ldr	r2, [pc, #28]	; (1013d68 <bg_thread_main+0x44>)
 1013d4c:	7b13      	ldrb	r3, [r2, #12]
 1013d4e:	f023 0301 	bic.w	r3, r3, #1
 1013d52:	7313      	strb	r3, [r2, #12]

#ifdef CONFIG_COVERAGE_DUMP
	/* Dump coverage data once the main() has exited. */
	gcov_coverage_dump();
#endif
} /* LCOV_EXCL_LINE ... because we just dumped final coverage data */
 1013d54:	bd08      	pop	{r3, pc}
 1013d56:	bf00      	nop
 1013d58:	210066fc 	.word	0x210066fc
 1013d5c:	01019215 	.word	0x01019215
 1013d60:	01019a5e 	.word	0x01019a5e
 1013d64:	01019a6e 	.word	0x01019a6e
 1013d68:	210040e4 	.word	0x210040e4

01013d6c <z_cstart>:
 * cleared/zeroed.
 *
 * @return Does not return
 */
FUNC_NORETURN void z_cstart(void)
{
 1013d6c:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 1013d70:	b0a5      	sub	sp, #148	; 0x94
	/* gcov hook needed to get the coverage report.*/
	gcov_static_init();

	LOG_CORE_INIT();
 1013d72:	f7ef ffe5 	bl	1003d40 <log_core_init>
 *
 * @return N/A
 */
static ALWAYS_INLINE void z_arm_interrupt_stack_setup(void)
{
	u32_t msp = (u32_t)(Z_THREAD_STACK_BUFFER(z_interrupt_stacks[0])) +
 1013d76:	f8df 90ec 	ldr.w	r9, [pc, #236]	; 1013e64 <z_cstart+0xf8>
  __ASM volatile ("MSR msp, %0" : : "r" (topOfMainStack) : );
 1013d7a:	f389 8808 	msr	MSP, r9
    SCB->SHPR[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 1013d7e:	2400      	movs	r4, #0
 1013d80:	23e0      	movs	r3, #224	; 0xe0
 1013d82:	4d31      	ldr	r5, [pc, #196]	; (1013e48 <z_cstart+0xdc>)
	z_setup_new_thread(&z_main_thread, z_main_stack,
 1013d84:	f04f 0b01 	mov.w	fp, #1
 1013d88:	f885 3022 	strb.w	r3, [r5, #34]	; 0x22
 1013d8c:	77ec      	strb	r4, [r5, #31]
 1013d8e:	762c      	strb	r4, [r5, #24]
 1013d90:	766c      	strb	r4, [r5, #25]
 1013d92:	76ac      	strb	r4, [r5, #26]
#if defined(CONFIG_ARM_SECURE_FIRMWARE)
	NVIC_SetPriority(SecureFault_IRQn, _EXC_FAULT_PRIO);
#endif /* CONFIG_ARM_SECURE_FIRMWARE */

	/* Enable Usage, Mem, & Bus Faults */
	SCB->SHCSR |= SCB_SHCSR_USGFAULTENA_Msk | SCB_SHCSR_MEMFAULTENA_Msk |
 1013d94:	6a6b      	ldr	r3, [r5, #36]	; 0x24
	_kernel.ready_q.cache = &z_main_thread;
 1013d96:	4e2d      	ldr	r6, [pc, #180]	; (1013e4c <z_cstart+0xe0>)
 1013d98:	f443 23e0 	orr.w	r3, r3, #458752	; 0x70000
 1013d9c:	626b      	str	r3, [r5, #36]	; 0x24

static ALWAYS_INLINE void arch_kernel_init(void)
{
	z_arm_interrupt_stack_setup();
	z_arm_exc_setup();
	z_arm_fault_init();
 1013d9e:	f7f1 fadd 	bl	100535c <z_arm_fault_init>
	z_arm_cpu_idle_init();
 1013da2:	f7f1 f843 	bl	1004e2c <z_arm_cpu_idle_init>
static ALWAYS_INLINE void z_arm_clear_faults(void)
{
#if defined(CONFIG_ARMV6_M_ARMV8_M_BASELINE)
#elif defined(CONFIG_ARMV7_M_ARMV8_M_MAINLINE)
	/* Reset all faults */
	SCB->CFSR = SCB_CFSR_USGFAULTSR_Msk |
 1013da6:	f04f 33ff 	mov.w	r3, #4294967295
 1013daa:	62ab      	str	r3, [r5, #40]	; 0x28
		    SCB_CFSR_MEMFAULTSR_Msk |
		    SCB_CFSR_BUSFAULTSR_Msk;

	/* Clear all Hard Faults - HFSR is write-one-to-clear */
	SCB->HFSR = 0xffffffff;
 1013dac:	62eb      	str	r3, [r5, #44]	; 0x2c
{
	dummy_thread->base.thread_state = _THREAD_DUMMY;
#ifdef CONFIG_SCHED_CPU_MASK
	dummy_thread->base.cpu_mask = -1;
#endif
	dummy_thread->base.user_options = K_ESSENTIAL;
 1013dae:	f240 1301 	movw	r3, #257	; 0x101
#endif
#ifdef CONFIG_USERSPACE
	dummy_thread->mem_domain_info.mem_domain = 0;
#endif

	_current_cpu->current = dummy_thread;
 1013db2:	4d27      	ldr	r5, [pc, #156]	; (1013e50 <z_cstart+0xe4>)
	dummy_thread->base.user_options = K_ESSENTIAL;
 1013db4:	f8ad 3028 	strh.w	r3, [sp, #40]	; 0x28
	_current_cpu->current = dummy_thread;
 1013db8:	ab07      	add	r3, sp, #28
 1013dba:	60ab      	str	r3, [r5, #8]

	z_dummy_thread_init(&dummy_thread);
#endif

	/* perform basic hardware initialization */
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_1);
 1013dbc:	4620      	mov	r0, r4
	dummy_thread->stack_info.size = 0U;
 1013dbe:	e9cd 441f 	strd	r4, r4, [sp, #124]	; 0x7c
 1013dc2:	f7ff fed3 	bl	1013b6c <z_sys_init_run_level>
	z_sys_init_run_level(_SYS_INIT_LEVEL_PRE_KERNEL_2);
 1013dc6:	2001      	movs	r0, #1
 1013dc8:	f7ff fed0 	bl	1013b6c <z_sys_init_run_level>
	z_setup_new_thread(&z_main_thread, z_main_stack,
 1013dcc:	f8df a098 	ldr.w	sl, [pc, #152]	; 1013e68 <z_cstart+0xfc>
	z_sched_init();
 1013dd0:	f000 fbba 	bl	1014548 <z_sched_init>
	z_setup_new_thread(&z_main_thread, z_main_stack,
 1013dd4:	f8df 8094 	ldr.w	r8, [pc, #148]	; 1013e6c <z_cstart+0x100>
 1013dd8:	4b1e      	ldr	r3, [pc, #120]	; (1013e54 <z_cstart+0xe8>)
	_kernel.ready_q.cache = &z_main_thread;
 1013dda:	626e      	str	r6, [r5, #36]	; 0x24
	z_setup_new_thread(&z_main_thread, z_main_stack,
 1013ddc:	f44f 7200 	mov.w	r2, #512	; 0x200
 1013de0:	4641      	mov	r1, r8
 1013de2:	4630      	mov	r0, r6
 1013de4:	9305      	str	r3, [sp, #20]
 1013de6:	e9cd 4b03 	strd	r4, fp, [sp, #12]
 1013dea:	4653      	mov	r3, sl
 1013dec:	e9cd 4401 	strd	r4, r4, [sp, #4]
 1013df0:	9400      	str	r4, [sp, #0]
 1013df2:	f000 fc91 	bl	1014718 <z_setup_new_thread>
	sys_trace_thread_resume(thread);
}

static inline void z_mark_thread_as_started(struct k_thread *thread)
{
	thread->base.thread_state &= ~_THREAD_PRESTART;
 1013df6:	7b73      	ldrb	r3, [r6, #13]
	z_ready_thread(&z_main_thread);
 1013df8:	4630      	mov	r0, r6
 1013dfa:	f023 0304 	bic.w	r3, r3, #4
 1013dfe:	7373      	strb	r3, [r6, #13]
 1013e00:	f003 fdaf 	bl	1017962 <z_ready_thread>
	z_setup_new_thread(thread, stack,
 1013e04:	230f      	movs	r3, #15
 1013e06:	4f14      	ldr	r7, [pc, #80]	; (1013e58 <z_cstart+0xec>)
 1013e08:	f44f 7280 	mov.w	r2, #256	; 0x100
 1013e0c:	4638      	mov	r0, r7
 1013e0e:	e9cd 4302 	strd	r4, r3, [sp, #8]
 1013e12:	4912      	ldr	r1, [pc, #72]	; (1013e5c <z_cstart+0xf0>)
 1013e14:	4b12      	ldr	r3, [pc, #72]	; (1013e60 <z_cstart+0xf4>)
 1013e16:	e9cd b404 	strd	fp, r4, [sp, #16]
 1013e1a:	e9cd 4400 	strd	r4, r4, [sp]
 1013e1e:	f000 fc7b 	bl	1014718 <z_setup_new_thread>
 1013e22:	7b7b      	ldrb	r3, [r7, #13]
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
 1013e24:	f44f 7200 	mov.w	r2, #512	; 0x200
 1013e28:	f023 0304 	bic.w	r3, r3, #4
 1013e2c:	737b      	strb	r3, [r7, #13]
 * @return N/A
 */

static inline void sys_dlist_init(sys_dlist_t *list)
{
	list->head = (sys_dnode_t *)list;
 1013e2e:	f105 0318 	add.w	r3, r5, #24
	list->tail = (sys_dnode_t *)list;
 1013e32:	e9c5 3306 	strd	r3, r3, [r5, #24]
 1013e36:	4641      	mov	r1, r8
 1013e38:	4653      	mov	r3, sl
 1013e3a:	4630      	mov	r0, r6
		_kernel.cpus[i].idle_thread = &z_idle_threads[i];
 1013e3c:	60ef      	str	r7, [r5, #12]
		_kernel.cpus[i].id = i;
 1013e3e:	752c      	strb	r4, [r5, #20]
		_kernel.cpus[i].irq_stack =
 1013e40:	f8c5 9004 	str.w	r9, [r5, #4]
	arch_switch_to_main_thread(&z_main_thread, z_main_stack,
 1013e44:	f7f0 ffd6 	bl	1004df4 <arch_switch_to_main_thread>
	CODE_UNREACHABLE; /* LCOV_EXCL_LINE */
 1013e48:	e000ed00 	.word	0xe000ed00
 1013e4c:	210040e4 	.word	0x210040e4
 1013e50:	210065b8 	.word	0x210065b8
 1013e54:	01019a95 	.word	0x01019a95
 1013e58:	21004070 	.word	0x21004070
 1013e5c:	21007810 	.word	0x21007810
 1013e60:	01013ca9 	.word	0x01013ca9
 1013e64:	21008110 	.word	0x21008110
 1013e68:	01013d25 	.word	0x01013d25
 1013e6c:	21007610 	.word	0x21007610

01013e70 <statics_init>:
	z_waitq_init(&h->wait_q);
	sys_heap_init(&h->heap, mem, bytes);
}

static int statics_init(struct device *unused)
{
 1013e70:	b538      	push	{r3, r4, r5, lr}
	ARG_UNUSED(unused);
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
 1013e72:	4c06      	ldr	r4, [pc, #24]	; (1013e8c <statics_init+0x1c>)
 1013e74:	4d06      	ldr	r5, [pc, #24]	; (1013e90 <statics_init+0x20>)
 1013e76:	42ac      	cmp	r4, r5
 1013e78:	d301      	bcc.n	1013e7e <statics_init+0xe>
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
	}
	return 0;
}
 1013e7a:	2000      	movs	r0, #0
 1013e7c:	bd38      	pop	{r3, r4, r5, pc}
		k_heap_init(h, h->heap.init_mem, h->heap.init_bytes);
 1013e7e:	4620      	mov	r0, r4
 1013e80:	e9d4 1201 	ldrd	r1, r2, [r4, #4]
 1013e84:	f003 fb78 	bl	1017578 <k_heap_init>
	Z_STRUCT_SECTION_FOREACH(k_heap, h) {
 1013e88:	3414      	adds	r4, #20
 1013e8a:	e7f4      	b.n	1013e76 <statics_init+0x6>
 1013e8c:	2100052c 	.word	0x2100052c
 1013e90:	21000540 	.word	0x21000540

01013e94 <init_mem_slab_module>:
 * Perform any initialization that wasn't done at build time.
 *
 * @return N/A
 */
static int init_mem_slab_module(struct device *dev)
{
 1013e94:	b570      	push	{r4, r5, r6, lr}
	int rc = 0;
	ARG_UNUSED(dev);

	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
 1013e96:	4b0e      	ldr	r3, [pc, #56]	; (1013ed0 <init_mem_slab_module+0x3c>)
 1013e98:	4c0e      	ldr	r4, [pc, #56]	; (1013ed4 <init_mem_slab_module+0x40>)
 1013e9a:	42a3      	cmp	r3, r4
 1013e9c:	d301      	bcc.n	1013ea2 <init_mem_slab_module+0xe>
		}
		SYS_TRACING_OBJ_INIT(k_mem_slab, slab);
		z_object_init(slab);
	}

out:
 1013e9e:	2000      	movs	r0, #0
	return rc;
}
 1013ea0:	bd70      	pop	{r4, r5, r6, pc}
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
 1013ea2:	e9d3 0103 	ldrd	r0, r1, [r3, #12]
 1013ea6:	ea41 0200 	orr.w	r2, r1, r0
 1013eaa:	f012 0203 	ands.w	r2, r2, #3
 1013eae:	d10b      	bne.n	1013ec8 <init_mem_slab_module+0x34>
	for (j = 0U; j < slab->num_blocks; j++) {
 1013eb0:	689d      	ldr	r5, [r3, #8]
	slab->free_list = NULL;
 1013eb2:	615a      	str	r2, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
 1013eb4:	42aa      	cmp	r2, r5
 1013eb6:	d101      	bne.n	1013ebc <init_mem_slab_module+0x28>
	Z_STRUCT_SECTION_FOREACH(k_mem_slab, slab) {
 1013eb8:	331c      	adds	r3, #28
 1013eba:	e7ee      	b.n	1013e9a <init_mem_slab_module+0x6>
		*(char **)p = slab->free_list;
 1013ebc:	695e      	ldr	r6, [r3, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
 1013ebe:	3201      	adds	r2, #1
		*(char **)p = slab->free_list;
 1013ec0:	600e      	str	r6, [r1, #0]
		slab->free_list = p;
 1013ec2:	6159      	str	r1, [r3, #20]
		p += slab->block_size;
 1013ec4:	4401      	add	r1, r0
	for (j = 0U; j < slab->num_blocks; j++) {
 1013ec6:	e7f5      	b.n	1013eb4 <init_mem_slab_module+0x20>
		return -EINVAL;
 1013ec8:	f06f 0015 	mvn.w	r0, #21
	return rc;
 1013ecc:	e7e8      	b.n	1013ea0 <init_mem_slab_module+0xc>
 1013ece:	bf00      	nop
 1013ed0:	2100052c 	.word	0x2100052c
 1013ed4:	2100052c 	.word	0x2100052c

01013ed8 <k_mem_slab_alloc>:
out:
	return rc;
}

int k_mem_slab_alloc(struct k_mem_slab *slab, void **mem, k_timeout_t timeout)
{
 1013ed8:	b5d3      	push	{r0, r1, r4, r6, r7, lr}
 1013eda:	460c      	mov	r4, r1
 1013edc:	4616      	mov	r6, r2
 1013ede:	461f      	mov	r7, r3
 1013ee0:	f04f 0320 	mov.w	r3, #32
 1013ee4:	f3ef 8111 	mrs	r1, BASEPRI
 1013ee8:	f383 8811 	msr	BASEPRI, r3
 1013eec:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int result;

	if (slab->free_list != NULL) {
 1013ef0:	6943      	ldr	r3, [r0, #20]
 1013ef2:	b15b      	cbz	r3, 1013f0c <k_mem_slab_alloc+0x34>
		/* take a free block */
		*mem = slab->free_list;
 1013ef4:	6023      	str	r3, [r4, #0]
		slab->free_list = *(char **)(slab->free_list);
 1013ef6:	681b      	ldr	r3, [r3, #0]
 1013ef8:	6143      	str	r3, [r0, #20]
		slab->num_used++;
 1013efa:	6983      	ldr	r3, [r0, #24]
 1013efc:	3301      	adds	r3, #1
 1013efe:	6183      	str	r3, [r0, #24]
		result = 0;
 1013f00:	2000      	movs	r0, #0
	__asm__ volatile(
 1013f02:	f381 8811 	msr	BASEPRI, r1
 1013f06:	f3bf 8f6f 	isb	sy
		return result;
	}

	k_spin_unlock(&lock, key);

	return result;
 1013f0a:	e011      	b.n	1013f30 <k_mem_slab_alloc+0x58>
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 1013f0c:	ea56 0207 	orrs.w	r2, r6, r7
 1013f10:	d103      	bne.n	1013f1a <k_mem_slab_alloc+0x42>
		result = -ENOMEM;
 1013f12:	f06f 000b 	mvn.w	r0, #11
		*mem = NULL;
 1013f16:	6023      	str	r3, [r4, #0]
		result = -ENOMEM;
 1013f18:	e7f3      	b.n	1013f02 <k_mem_slab_alloc+0x2a>
		result = z_pend_curr(&lock, key, &slab->wait_q, timeout);
 1013f1a:	4602      	mov	r2, r0
 1013f1c:	e9cd 6700 	strd	r6, r7, [sp]
 1013f20:	4804      	ldr	r0, [pc, #16]	; (1013f34 <k_mem_slab_alloc+0x5c>)
 1013f22:	f000 fafd 	bl	1014520 <z_pend_curr>
		if (result == 0) {
 1013f26:	b918      	cbnz	r0, 1013f30 <k_mem_slab_alloc+0x58>
			*mem = _current->base.swap_data;
 1013f28:	4b03      	ldr	r3, [pc, #12]	; (1013f38 <k_mem_slab_alloc+0x60>)
 1013f2a:	689b      	ldr	r3, [r3, #8]
 1013f2c:	695b      	ldr	r3, [r3, #20]
 1013f2e:	6023      	str	r3, [r4, #0]
}
 1013f30:	b002      	add	sp, #8
 1013f32:	bdd0      	pop	{r4, r6, r7, pc}
 1013f34:	210066fd 	.word	0x210066fd
 1013f38:	210065b8 	.word	0x210065b8

01013f3c <k_mem_slab_free>:

void k_mem_slab_free(struct k_mem_slab *slab, void **mem)
{
 1013f3c:	b570      	push	{r4, r5, r6, lr}
 1013f3e:	4604      	mov	r4, r0
 1013f40:	460d      	mov	r5, r1
	__asm__ volatile(
 1013f42:	f04f 0320 	mov.w	r3, #32
 1013f46:	f3ef 8611 	mrs	r6, BASEPRI
 1013f4a:	f383 8811 	msr	BASEPRI, r3
 1013f4e:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *pending_thread = z_unpend_first_thread(&slab->wait_q);
 1013f52:	f003 fd7c 	bl	1017a4e <z_unpend_first_thread>

	if (pending_thread != NULL) {
 1013f56:	b158      	cbz	r0, 1013f70 <k_mem_slab_free+0x34>
}

static ALWAYS_INLINE void
arch_thread_return_value_set(struct k_thread *thread, unsigned int value)
{
	thread->arch.swap_return_value = value;
 1013f58:	2100      	movs	r1, #0
		z_thread_return_value_set_with_data(pending_thread, 0, *mem);
 1013f5a:	682a      	ldr	r2, [r5, #0]
 1013f5c:	6701      	str	r1, [r0, #112]	; 0x70
z_thread_return_value_set_with_data(struct k_thread *thread,
				   unsigned int value,
				   void *data)
{
	arch_thread_return_value_set(thread, value);
	thread->base.swap_data = data;
 1013f5e:	6142      	str	r2, [r0, #20]
		z_ready_thread(pending_thread);
 1013f60:	f003 fcff 	bl	1017962 <z_ready_thread>
		z_reschedule(&lock, key);
 1013f64:	4631      	mov	r1, r6
		**(char ***)mem = slab->free_list;
		slab->free_list = *(char **)mem;
		slab->num_used--;
		k_spin_unlock(&lock, key);
	}
}
 1013f66:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule(&lock, key);
 1013f6a:	4808      	ldr	r0, [pc, #32]	; (1013f8c <k_mem_slab_free+0x50>)
 1013f6c:	f003 bcb1 	b.w	10178d2 <z_reschedule>
		**(char ***)mem = slab->free_list;
 1013f70:	682b      	ldr	r3, [r5, #0]
 1013f72:	6962      	ldr	r2, [r4, #20]
 1013f74:	601a      	str	r2, [r3, #0]
		slab->free_list = *(char **)mem;
 1013f76:	682b      	ldr	r3, [r5, #0]
 1013f78:	6163      	str	r3, [r4, #20]
		slab->num_used--;
 1013f7a:	69a3      	ldr	r3, [r4, #24]
 1013f7c:	3b01      	subs	r3, #1
 1013f7e:	61a3      	str	r3, [r4, #24]
	__asm__ volatile(
 1013f80:	f386 8811 	msr	BASEPRI, r6
 1013f84:	f3bf 8f6f 	isb	sy
}
 1013f88:	bd70      	pop	{r4, r5, r6, pc}
 1013f8a:	bf00      	nop
 1013f8c:	210066fd 	.word	0x210066fd

01013f90 <k_malloc>:
K_MEM_POOL_DEFINE(_heap_mem_pool, CONFIG_HEAP_MEM_POOL_MIN_SIZE,
		  CONFIG_HEAP_MEM_POOL_SIZE, 1, 4);
#define _HEAP_MEM_POOL (&_heap_mem_pool)

void *k_malloc(size_t size)
{
 1013f90:	4601      	mov	r1, r0
	return k_mem_pool_malloc(_HEAP_MEM_POOL, size);
 1013f92:	4801      	ldr	r0, [pc, #4]	; (1013f98 <k_malloc+0x8>)
 1013f94:	f003 bb90 	b.w	10176b8 <k_mem_pool_malloc>
 1013f98:	2100049c 	.word	0x2100049c

01013f9c <z_thread_malloc>:
#else
#define _HEAP_MEM_POOL	NULL
#endif

void *z_thread_malloc(size_t size)
{
 1013f9c:	b510      	push	{r4, lr}
 1013f9e:	4604      	mov	r4, r0
	void *ret;
	struct k_mem_pool *pool;

	if (k_is_in_isr()) {
 1013fa0:	f003 fda2 	bl	1017ae8 <k_is_in_isr>
 1013fa4:	b948      	cbnz	r0, 1013fba <z_thread_malloc+0x1e>
		pool = _HEAP_MEM_POOL;
	} else {
		pool = _current->resource_pool;
 1013fa6:	4b06      	ldr	r3, [pc, #24]	; (1013fc0 <z_thread_malloc+0x24>)
 1013fa8:	689b      	ldr	r3, [r3, #8]
 1013faa:	6e9b      	ldr	r3, [r3, #104]	; 0x68
	}

	if (pool) {
 1013fac:	b13b      	cbz	r3, 1013fbe <z_thread_malloc+0x22>
		ret = k_mem_pool_malloc(pool, size);
 1013fae:	4621      	mov	r1, r4
	} else {
		ret = NULL;
	}

	return ret;
}
 1013fb0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		ret = k_mem_pool_malloc(pool, size);
 1013fb4:	4618      	mov	r0, r3
 1013fb6:	f003 bb7f 	b.w	10176b8 <k_mem_pool_malloc>
		pool = _HEAP_MEM_POOL;
 1013fba:	4b02      	ldr	r3, [pc, #8]	; (1013fc4 <z_thread_malloc+0x28>)
 1013fbc:	e7f7      	b.n	1013fae <z_thread_malloc+0x12>
}
 1013fbe:	bd10      	pop	{r4, pc}
 1013fc0:	210065b8 	.word	0x210065b8
 1013fc4:	2100049c 	.word	0x2100049c

01013fc8 <z_impl_k_queue_get>:

	return 0;
}

void *z_impl_k_queue_get(struct k_queue *queue, k_timeout_t timeout)
{
 1013fc8:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 1013fca:	4616      	mov	r6, r2
 1013fcc:	461f      	mov	r7, r3
	__asm__ volatile(
 1013fce:	f04f 0320 	mov.w	r3, #32
 1013fd2:	f3ef 8511 	mrs	r5, BASEPRI
 1013fd6:	f383 8811 	msr	BASEPRI, r3
 1013fda:	f3bf 8f6f 	isb	sy
 *
 * @return a boolean, true if it's empty, false otherwise
 */
static inline bool sys_sflist_is_empty(sys_sflist_t *list);

Z_GENLIST_IS_EMPTY(sflist)
 1013fde:	6804      	ldr	r4, [r0, #0]
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
	void *data;

	if (likely(!sys_sflist_is_empty(&queue->data_q))) {
 1013fe0:	b19c      	cbz	r4, 101400a <z_impl_k_queue_get+0x42>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
 1013fe2:	6823      	ldr	r3, [r4, #0]
 *
 * @return A pointer to the first node of the list
 */
static inline sys_sfnode_t *sys_sflist_get_not_empty(sys_sflist_t *list);

Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
 1013fe4:	6842      	ldr	r2, [r0, #4]
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
 1013fe6:	f023 0303 	bic.w	r3, r3, #3
Z_GENLIST_GET_NOT_EMPTY(sflist, sfnode)
 1013fea:	4294      	cmp	r4, r2
	list->head = node;
 1013fec:	6003      	str	r3, [r0, #0]
	list->tail = node;
 1013fee:	bf08      	it	eq
 1013ff0:	6043      	streq	r3, [r0, #4]
		sys_sfnode_t *node;

		node = sys_sflist_get_not_empty(&queue->data_q);
		data = z_queue_node_peek(node, true);
 1013ff2:	2101      	movs	r1, #1
 1013ff4:	4620      	mov	r0, r4
 1013ff6:	f003 fbdc 	bl	10177b2 <z_queue_node_peek>
 1013ffa:	4604      	mov	r4, r0
	__asm__ volatile(
 1013ffc:	f385 8811 	msr	BASEPRI, r5
 1014000:	f3bf 8f6f 	isb	sy
	}

	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);

	return (ret != 0) ? NULL : _current->base.swap_data;
}
 1014004:	4620      	mov	r0, r4
 1014006:	b003      	add	sp, #12
 1014008:	bdf0      	pop	{r4, r5, r6, r7, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 101400a:	ea56 0307 	orrs.w	r3, r6, r7
 101400e:	d0f5      	beq.n	1013ffc <z_impl_k_queue_get+0x34>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
 1014010:	f100 0208 	add.w	r2, r0, #8
	int ret = z_pend_curr(&queue->lock, key, &queue->wait_q, timeout);
 1014014:	4629      	mov	r1, r5
 1014016:	4610      	mov	r0, r2
 1014018:	e9cd 6700 	strd	r6, r7, [sp]
 101401c:	f000 fa80 	bl	1014520 <z_pend_curr>
	return (ret != 0) ? NULL : _current->base.swap_data;
 1014020:	2800      	cmp	r0, #0
 1014022:	d1ef      	bne.n	1014004 <z_impl_k_queue_get+0x3c>
 1014024:	4b01      	ldr	r3, [pc, #4]	; (101402c <z_impl_k_queue_get+0x64>)
 1014026:	689b      	ldr	r3, [r3, #8]
 1014028:	695c      	ldr	r4, [r3, #20]
 101402a:	e7eb      	b.n	1014004 <z_impl_k_queue_get+0x3c>
 101402c:	210065b8 	.word	0x210065b8

01014030 <z_reset_time_slice>:
 */
static struct k_thread *pending_current;
#endif

void z_reset_time_slice(void)
{
 1014030:	b510      	push	{r4, lr}
	/* Add the elapsed time since the last announced tick to the
	 * slice count, as we'll see those "expired" ticks arrive in a
	 * FUTURE z_time_slice() call.
	 */
	if (slice_time != 0) {
 1014032:	4c08      	ldr	r4, [pc, #32]	; (1014054 <z_reset_time_slice+0x24>)
 1014034:	6823      	ldr	r3, [r4, #0]
 1014036:	b15b      	cbz	r3, 1014050 <z_reset_time_slice+0x20>
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
 1014038:	f7f0 fd14 	bl	1004a64 <z_clock_elapsed>
 101403c:	4603      	mov	r3, r0
 101403e:	6820      	ldr	r0, [r4, #0]
 1014040:	4a05      	ldr	r2, [pc, #20]	; (1014058 <z_reset_time_slice+0x28>)
 1014042:	4403      	add	r3, r0
		z_set_timeout_expiry(slice_time, false);
 1014044:	2100      	movs	r1, #0
	}
}
 1014046:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		_current_cpu->slice_ticks = slice_time + z_clock_elapsed();
 101404a:	6113      	str	r3, [r2, #16]
		z_set_timeout_expiry(slice_time, false);
 101404c:	f003 bdf8 	b.w	1017c40 <z_set_timeout_expiry>
}
 1014050:	bd10      	pop	{r4, pc}
 1014052:	bf00      	nop
 1014054:	210065f0 	.word	0x210065f0
 1014058:	210065b8 	.word	0x210065b8

0101405c <k_sched_time_slice_set>:

void k_sched_time_slice_set(s32_t slice, int prio)
{
 101405c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 101405e:	4605      	mov	r5, r0
 1014060:	460c      	mov	r4, r1
	__asm__ volatile(
 1014062:	f04f 0320 	mov.w	r3, #32
 1014066:	f3ef 8611 	mrs	r6, BASEPRI
 101406a:	f383 8811 	msr	BASEPRI, r3
 101406e:	f3bf 8f6f 	isb	sy
	LOCKED(&sched_spinlock) {
		_current_cpu->slice_ticks = 0;
 1014072:	2200      	movs	r2, #0
 1014074:	f44f 4700 	mov.w	r7, #32768	; 0x8000
 1014078:	f240 30e7 	movw	r0, #999	; 0x3e7
 101407c:	2100      	movs	r1, #0
 101407e:	4b0a      	ldr	r3, [pc, #40]	; (10140a8 <k_sched_time_slice_set+0x4c>)
 1014080:	fbe7 0105 	umlal	r0, r1, r7, r5
 1014084:	611a      	str	r2, [r3, #16]
 1014086:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 101408a:	2300      	movs	r3, #0
 101408c:	f7ec f814 	bl	10000b8 <__aeabi_uldivmod>
		slice_time = k_ms_to_ticks_ceil32(slice);
 1014090:	4b06      	ldr	r3, [pc, #24]	; (10140ac <k_sched_time_slice_set+0x50>)
 1014092:	6018      	str	r0, [r3, #0]
		slice_max_prio = prio;
 1014094:	4b06      	ldr	r3, [pc, #24]	; (10140b0 <k_sched_time_slice_set+0x54>)
 1014096:	601c      	str	r4, [r3, #0]
		z_reset_time_slice();
 1014098:	f7ff ffca 	bl	1014030 <z_reset_time_slice>
	__asm__ volatile(
 101409c:	f386 8811 	msr	BASEPRI, r6
 10140a0:	f3bf 8f6f 	isb	sy
	}
}
 10140a4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 10140a6:	bf00      	nop
 10140a8:	210065b8 	.word	0x210065b8
 10140ac:	210065f0 	.word	0x210065f0
 10140b0:	210065ec 	.word	0x210065ec

010140b4 <k_sched_lock>:
	__asm__ volatile(
 10140b4:	f04f 0320 	mov.w	r3, #32
 10140b8:	f3ef 8111 	mrs	r1, BASEPRI
 10140bc:	f383 8811 	msr	BASEPRI, r3
 10140c0:	f3bf 8f6f 	isb	sy
{
#ifdef CONFIG_PREEMPT_ENABLED
	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(_current->base.sched_locked != 1, "");

	--_current->base.sched_locked;
 10140c4:	4b04      	ldr	r3, [pc, #16]	; (10140d8 <k_sched_lock+0x24>)
 10140c6:	689a      	ldr	r2, [r3, #8]
 10140c8:	7bd3      	ldrb	r3, [r2, #15]
 10140ca:	3b01      	subs	r3, #1
 10140cc:	73d3      	strb	r3, [r2, #15]
	__asm__ volatile(
 10140ce:	f381 8811 	msr	BASEPRI, r1
 10140d2:	f3bf 8f6f 	isb	sy
void k_sched_lock(void)
{
	LOCKED(&sched_spinlock) {
		z_sched_lock();
	}
}
 10140d6:	4770      	bx	lr
 10140d8:	210065b8 	.word	0x210065b8

010140dc <z_priq_dumb_remove>:
}

void z_priq_dumb_remove(sys_dlist_t *pq, struct k_thread *thread)
{
#if defined(CONFIG_SWAP_NONATOMIC) && defined(CONFIG_SCHED_DUMB)
	if (pq == &_kernel.ready_q.runq && thread == _current &&
 10140dc:	4b09      	ldr	r3, [pc, #36]	; (1014104 <z_priq_dumb_remove+0x28>)
 10140de:	f103 0228 	add.w	r2, r3, #40	; 0x28
 10140e2:	4282      	cmp	r2, r0
 10140e4:	d105      	bne.n	10140f2 <z_priq_dumb_remove+0x16>
 10140e6:	689b      	ldr	r3, [r3, #8]
 10140e8:	428b      	cmp	r3, r1
 10140ea:	d102      	bne.n	10140f2 <z_priq_dumb_remove+0x16>
 10140ec:	7b4b      	ldrb	r3, [r1, #13]
 10140ee:	06db      	lsls	r3, r3, #27
 10140f0:	d106      	bne.n	1014100 <z_priq_dumb_remove+0x24>
 * @return N/A
 */

static inline void sys_dlist_remove(sys_dnode_t *node)
{
	node->prev->next = node->next;
 10140f2:	e9d1 3200 	ldrd	r3, r2, [r1]
 10140f6:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
 10140f8:	605a      	str	r2, [r3, #4]
	node->next = NULL;
 10140fa:	2300      	movs	r3, #0
	node->prev = NULL;
 10140fc:	e9c1 3300 	strd	r3, r3, [r1]
#endif

	__ASSERT_NO_MSG(!z_is_idle_thread_object(thread));

	sys_dlist_remove(&thread->base.qnode_dlist);
}
 1014100:	4770      	bx	lr
 1014102:	bf00      	nop
 1014104:	210065b8 	.word	0x210065b8

01014108 <update_cache>:
{
 1014108:	b570      	push	{r4, r5, r6, lr}
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
 101410a:	4c10      	ldr	r4, [pc, #64]	; (101414c <update_cache+0x44>)
{
 101410c:	4606      	mov	r6, r0
	struct k_thread *thread = _priq_run_best(&_kernel.ready_q.runq);
 101410e:	f104 0028 	add.w	r0, r4, #40	; 0x28
 1014112:	f003 fc1c 	bl	101794e <z_priq_dumb_best>
 1014116:	4605      	mov	r5, r0
	if (_current->base.thread_state & _THREAD_ABORTING) {
 1014118:	68a3      	ldr	r3, [r4, #8]
 101411a:	7b59      	ldrb	r1, [r3, #13]
 101411c:	0688      	lsls	r0, r1, #26
		_current->base.thread_state |= _THREAD_DEAD;
 101411e:	bf44      	itt	mi
 1014120:	f041 0108 	orrmi.w	r1, r1, #8
 1014124:	7359      	strbmi	r1, [r3, #13]
	return thread ? thread : _current_cpu->idle_thread;
 1014126:	b905      	cbnz	r5, 101412a <update_cache+0x22>
 1014128:	68e5      	ldr	r5, [r4, #12]
	if (preempt_ok != 0) {
 101412a:	b94e      	cbnz	r6, 1014140 <update_cache+0x38>
	if (z_is_thread_prevented_from_running(_current)) {
 101412c:	7b5a      	ldrb	r2, [r3, #13]
 101412e:	06d2      	lsls	r2, r2, #27
 1014130:	d106      	bne.n	1014140 <update_cache+0x38>
	if (IS_ENABLED(CONFIG_SWAP_NONATOMIC)
 1014132:	69aa      	ldr	r2, [r5, #24]
 1014134:	b922      	cbnz	r2, 1014140 <update_cache+0x38>
	if (is_preempt(_current) || is_metairq(thread)) {
 1014136:	89da      	ldrh	r2, [r3, #14]
 1014138:	2a7f      	cmp	r2, #127	; 0x7f
 101413a:	d901      	bls.n	1014140 <update_cache+0x38>
		_kernel.ready_q.cache = _current;
 101413c:	6263      	str	r3, [r4, #36]	; 0x24
}
 101413e:	bd70      	pop	{r4, r5, r6, pc}
		if (thread != _current) {
 1014140:	42ab      	cmp	r3, r5
 1014142:	d001      	beq.n	1014148 <update_cache+0x40>
			z_reset_time_slice();
 1014144:	f7ff ff74 	bl	1014030 <z_reset_time_slice>
		_kernel.ready_q.cache = thread;
 1014148:	6265      	str	r5, [r4, #36]	; 0x24
}
 101414a:	e7f8      	b.n	101413e <update_cache+0x36>
 101414c:	210065b8 	.word	0x210065b8

01014150 <k_sched_unlock>:
{
 1014150:	b510      	push	{r4, lr}
	__asm__ volatile(
 1014152:	f04f 0320 	mov.w	r3, #32
 1014156:	f3ef 8411 	mrs	r4, BASEPRI
 101415a:	f383 8811 	msr	BASEPRI, r3
 101415e:	f3bf 8f6f 	isb	sy
		++_current->base.sched_locked;
 1014162:	4b08      	ldr	r3, [pc, #32]	; (1014184 <k_sched_unlock+0x34>)
		update_cache(0);
 1014164:	2000      	movs	r0, #0
		++_current->base.sched_locked;
 1014166:	689a      	ldr	r2, [r3, #8]
 1014168:	7bd3      	ldrb	r3, [r2, #15]
 101416a:	3301      	adds	r3, #1
 101416c:	73d3      	strb	r3, [r2, #15]
		update_cache(0);
 101416e:	f7ff ffcb 	bl	1014108 <update_cache>
	__asm__ volatile(
 1014172:	f384 8811 	msr	BASEPRI, r4
 1014176:	f3bf 8f6f 	isb	sy
}
 101417a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule_unlocked();
 101417e:	f003 bbbf 	b.w	1017900 <z_reschedule_unlocked>
 1014182:	bf00      	nop
 1014184:	210065b8 	.word	0x210065b8

01014188 <ready_thread>:
{
 1014188:	b470      	push	{r4, r5, r6}
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
 101418a:	7b43      	ldrb	r3, [r0, #13]
 101418c:	06db      	lsls	r3, r3, #27
 101418e:	d12a      	bne.n	10141e6 <ready_thread+0x5e>

int z_abort_timeout(struct _timeout *to);

static inline bool z_is_inactive_timeout(struct _timeout *t)
{
	return !sys_dnode_is_linked(&t->node);
 1014190:	6983      	ldr	r3, [r0, #24]
	if (z_is_thread_ready(thread)) {
 1014192:	bb43      	cbnz	r3, 10141e6 <ready_thread+0x5e>
	return list->head == list;
 1014194:	4a15      	ldr	r2, [pc, #84]	; (10141ec <ready_thread+0x64>)
 1014196:	4611      	mov	r1, r2
 1014198:	f851 4f28 	ldr.w	r4, [r1, #40]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
 101419c:	428c      	cmp	r4, r1
 101419e:	bf18      	it	ne
 10141a0:	4623      	movne	r3, r4
 10141a2:	2b00      	cmp	r3, #0
 10141a4:	bf38      	it	cc
 10141a6:	2300      	movcc	r3, #0
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 10141a8:	6ad4      	ldr	r4, [r2, #44]	; 0x2c
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 10141aa:	b1b3      	cbz	r3, 10141da <ready_thread+0x52>
	if (thread_1->base.prio < thread_2->base.prio) {
 10141ac:	f990 600e 	ldrsb.w	r6, [r0, #14]
 10141b0:	f993 500e 	ldrsb.w	r5, [r3, #14]
 10141b4:	42ae      	cmp	r6, r5
 10141b6:	db03      	blt.n	10141c0 <ready_thread+0x38>
	return (node == list->tail) ? NULL : node->next;
 10141b8:	42a3      	cmp	r3, r4
 10141ba:	d00e      	beq.n	10141da <ready_thread+0x52>
 10141bc:	681b      	ldr	r3, [r3, #0]
 10141be:	e7f4      	b.n	10141aa <ready_thread+0x22>
	node->prev = successor->prev;
 10141c0:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
 10141c2:	e9c0 3200 	strd	r3, r2, [r0]
	successor->prev->next = node;
 10141c6:	6010      	str	r0, [r2, #0]
	successor->prev = node;
 10141c8:	6058      	str	r0, [r3, #4]
	thread->base.thread_state |= states;
 10141ca:	7b43      	ldrb	r3, [r0, #13]
 10141cc:	f063 037f 	orn	r3, r3, #127	; 0x7f
 10141d0:	7343      	strb	r3, [r0, #13]
}
 10141d2:	bc70      	pop	{r4, r5, r6}
		update_cache(0);
 10141d4:	2000      	movs	r0, #0
 10141d6:	f7ff bf97 	b.w	1014108 <update_cache>
	node->prev = list->tail;
 10141da:	e9c0 1400 	strd	r1, r4, [r0]
	list->tail->next = node;
 10141de:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 10141e0:	6018      	str	r0, [r3, #0]
	list->tail = node;
 10141e2:	62d0      	str	r0, [r2, #44]	; 0x2c
}
 10141e4:	e7f1      	b.n	10141ca <ready_thread+0x42>
}
 10141e6:	bc70      	pop	{r4, r5, r6}
 10141e8:	4770      	bx	lr
 10141ea:	bf00      	nop
 10141ec:	210065b8 	.word	0x210065b8

010141f0 <z_sched_start>:
{
 10141f0:	b510      	push	{r4, lr}
	__asm__ volatile(
 10141f2:	f04f 0220 	mov.w	r2, #32
 10141f6:	f3ef 8411 	mrs	r4, BASEPRI
 10141fa:	f382 8811 	msr	BASEPRI, r2
 10141fe:	f3bf 8f6f 	isb	sy
	if (z_has_thread_started(thread)) {
 1014202:	7b42      	ldrb	r2, [r0, #13]
 1014204:	0751      	lsls	r1, r2, #29
 1014206:	d404      	bmi.n	1014212 <z_sched_start+0x22>
	__asm__ volatile(
 1014208:	f384 8811 	msr	BASEPRI, r4
 101420c:	f3bf 8f6f 	isb	sy
}
 1014210:	bd10      	pop	{r4, pc}
	thread->base.thread_state &= ~_THREAD_PRESTART;
 1014212:	f022 0204 	bic.w	r2, r2, #4
 1014216:	7342      	strb	r2, [r0, #13]
	ready_thread(thread);
 1014218:	f7ff ffb6 	bl	1014188 <ready_thread>
	z_reschedule(&sched_spinlock, key);
 101421c:	4621      	mov	r1, r4
}
 101421e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	z_reschedule(&sched_spinlock, key);
 1014222:	4801      	ldr	r0, [pc, #4]	; (1014228 <z_sched_start+0x38>)
 1014224:	f003 bb55 	b.w	10178d2 <z_reschedule>
 1014228:	210066fd 	.word	0x210066fd

0101422c <z_move_thread_to_end_of_prio_q>:
{
 101422c:	4601      	mov	r1, r0
 101422e:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	__asm__ volatile(
 1014230:	f04f 0320 	mov.w	r3, #32
 1014234:	f3ef 8411 	mrs	r4, BASEPRI
 1014238:	f383 8811 	msr	BASEPRI, r3
 101423c:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
 1014240:	f990 300d 	ldrsb.w	r3, [r0, #13]
 1014244:	2b00      	cmp	r3, #0
 1014246:	da02      	bge.n	101424e <z_move_thread_to_end_of_prio_q+0x22>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
 1014248:	4819      	ldr	r0, [pc, #100]	; (10142b0 <z_move_thread_to_end_of_prio_q+0x84>)
 101424a:	f7ff ff47 	bl	10140dc <z_priq_dumb_remove>
	return list->head == list;
 101424e:	4a19      	ldr	r2, [pc, #100]	; (10142b4 <z_move_thread_to_end_of_prio_q+0x88>)
 1014250:	4610      	mov	r0, r2
 1014252:	f850 3f28 	ldr.w	r3, [r0, #40]!
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 1014256:	6ad5      	ldr	r5, [r2, #44]	; 0x2c
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1014258:	4283      	cmp	r3, r0
 101425a:	bf08      	it	eq
 101425c:	2300      	moveq	r3, #0
 101425e:	2b00      	cmp	r3, #0
 1014260:	bf38      	it	cc
 1014262:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 1014264:	b1eb      	cbz	r3, 10142a2 <z_move_thread_to_end_of_prio_q+0x76>
	if (thread_1->base.prio < thread_2->base.prio) {
 1014266:	f991 700e 	ldrsb.w	r7, [r1, #14]
 101426a:	f993 600e 	ldrsb.w	r6, [r3, #14]
 101426e:	42b7      	cmp	r7, r6
 1014270:	db03      	blt.n	101427a <z_move_thread_to_end_of_prio_q+0x4e>
	return (node == list->tail) ? NULL : node->next;
 1014272:	429d      	cmp	r5, r3
 1014274:	d015      	beq.n	10142a2 <z_move_thread_to_end_of_prio_q+0x76>
 1014276:	681b      	ldr	r3, [r3, #0]
 1014278:	e7f4      	b.n	1014264 <z_move_thread_to_end_of_prio_q+0x38>
	node->prev = successor->prev;
 101427a:	6858      	ldr	r0, [r3, #4]
	node->next = successor;
 101427c:	e9c1 3000 	strd	r3, r0, [r1]
	successor->prev->next = node;
 1014280:	6001      	str	r1, [r0, #0]
	successor->prev = node;
 1014282:	6059      	str	r1, [r3, #4]
	thread->base.thread_state |= states;
 1014284:	7b4b      	ldrb	r3, [r1, #13]
		update_cache(thread == _current);
 1014286:	6890      	ldr	r0, [r2, #8]
 1014288:	f063 037f 	orn	r3, r3, #127	; 0x7f
 101428c:	734b      	strb	r3, [r1, #13]
 101428e:	1a43      	subs	r3, r0, r1
 1014290:	4258      	negs	r0, r3
 1014292:	4158      	adcs	r0, r3
 1014294:	f7ff ff38 	bl	1014108 <update_cache>
	__asm__ volatile(
 1014298:	f384 8811 	msr	BASEPRI, r4
 101429c:	f3bf 8f6f 	isb	sy
}
 10142a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	node->prev = list->tail;
 10142a2:	e9c1 0500 	strd	r0, r5, [r1]
	list->tail->next = node;
 10142a6:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 10142a8:	6019      	str	r1, [r3, #0]
	list->tail = node;
 10142aa:	62d1      	str	r1, [r2, #44]	; 0x2c
}
 10142ac:	e7ea      	b.n	1014284 <z_move_thread_to_end_of_prio_q+0x58>
 10142ae:	bf00      	nop
 10142b0:	210065e0 	.word	0x210065e0
 10142b4:	210065b8 	.word	0x210065b8

010142b8 <z_time_slice>:
{
 10142b8:	b538      	push	{r3, r4, r5, lr}
	if (pending_current == _current) {
 10142ba:	4a15      	ldr	r2, [pc, #84]	; (1014310 <z_time_slice+0x58>)
 10142bc:	4b15      	ldr	r3, [pc, #84]	; (1014314 <z_time_slice+0x5c>)
 10142be:	6814      	ldr	r4, [r2, #0]
{
 10142c0:	4601      	mov	r1, r0
	if (pending_current == _current) {
 10142c2:	6898      	ldr	r0, [r3, #8]
 10142c4:	42a0      	cmp	r0, r4
 10142c6:	461c      	mov	r4, r3
 10142c8:	d103      	bne.n	10142d2 <z_time_slice+0x1a>
}
 10142ca:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			z_reset_time_slice();
 10142ce:	f7ff beaf 	b.w	1014030 <z_reset_time_slice>
	pending_current = NULL;
 10142d2:	2500      	movs	r5, #0
 10142d4:	6015      	str	r5, [r2, #0]
	if (slice_time && sliceable(_current)) {
 10142d6:	4a10      	ldr	r2, [pc, #64]	; (1014318 <z_time_slice+0x60>)
 10142d8:	6812      	ldr	r2, [r2, #0]
 10142da:	b1b2      	cbz	r2, 101430a <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
 10142dc:	89c2      	ldrh	r2, [r0, #14]
 10142de:	2a7f      	cmp	r2, #127	; 0x7f
 10142e0:	d813      	bhi.n	101430a <z_time_slice+0x52>
		&& !z_is_prio_higher(thread->base.prio, slice_max_prio)
 10142e2:	4a0e      	ldr	r2, [pc, #56]	; (101431c <z_time_slice+0x64>)
 10142e4:	f990 500e 	ldrsb.w	r5, [r0, #14]
 10142e8:	6812      	ldr	r2, [r2, #0]
 10142ea:	4295      	cmp	r5, r2
 10142ec:	db0d      	blt.n	101430a <z_time_slice+0x52>
		&& !z_is_idle_thread_object(thread)
 10142ee:	4a0c      	ldr	r2, [pc, #48]	; (1014320 <z_time_slice+0x68>)
 10142f0:	4290      	cmp	r0, r2
 10142f2:	d00a      	beq.n	101430a <z_time_slice+0x52>
		&& !z_is_thread_timeout_active(thread);
 10142f4:	6982      	ldr	r2, [r0, #24]
 10142f6:	b942      	cbnz	r2, 101430a <z_time_slice+0x52>
		if (ticks >= _current_cpu->slice_ticks) {
 10142f8:	691a      	ldr	r2, [r3, #16]
 10142fa:	428a      	cmp	r2, r1
 10142fc:	dc02      	bgt.n	1014304 <z_time_slice+0x4c>
			z_move_thread_to_end_of_prio_q(_current);
 10142fe:	f7ff ff95 	bl	101422c <z_move_thread_to_end_of_prio_q>
 1014302:	e7e2      	b.n	10142ca <z_time_slice+0x12>
			_current_cpu->slice_ticks -= ticks;
 1014304:	1a52      	subs	r2, r2, r1
 1014306:	611a      	str	r2, [r3, #16]
}
 1014308:	bd38      	pop	{r3, r4, r5, pc}
		_current_cpu->slice_ticks = 0;
 101430a:	2300      	movs	r3, #0
 101430c:	6123      	str	r3, [r4, #16]
 101430e:	e7fb      	b.n	1014308 <z_time_slice+0x50>
 1014310:	210065e8 	.word	0x210065e8
 1014314:	210065b8 	.word	0x210065b8
 1014318:	210065f0 	.word	0x210065f0
 101431c:	210065ec 	.word	0x210065ec
 1014320:	21004070 	.word	0x21004070

01014324 <z_impl_k_thread_suspend>:
{
 1014324:	b570      	push	{r4, r5, r6, lr}
 1014326:	4604      	mov	r4, r0
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
}

static inline int z_abort_thread_timeout(struct k_thread *thread)
{
	return z_abort_timeout(&thread->base.timeout);
 1014328:	3018      	adds	r0, #24
 101432a:	f003 fc63 	bl	1017bf4 <z_abort_timeout>
	__asm__ volatile(
 101432e:	f04f 0320 	mov.w	r3, #32
 1014332:	f3ef 8611 	mrs	r6, BASEPRI
 1014336:	f383 8811 	msr	BASEPRI, r3
 101433a:	f3bf 8f6f 	isb	sy
		if (z_is_thread_queued(thread)) {
 101433e:	f994 300d 	ldrsb.w	r3, [r4, #13]
 1014342:	2b00      	cmp	r3, #0
 1014344:	da07      	bge.n	1014356 <z_impl_k_thread_suspend+0x32>
			_priq_run_remove(&_kernel.ready_q.runq, thread);
 1014346:	4621      	mov	r1, r4
 1014348:	480e      	ldr	r0, [pc, #56]	; (1014384 <z_impl_k_thread_suspend+0x60>)
 101434a:	f7ff fec7 	bl	10140dc <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
 101434e:	7b63      	ldrb	r3, [r4, #13]
 1014350:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 1014354:	7363      	strb	r3, [r4, #13]
		update_cache(thread == _current);
 1014356:	4d0c      	ldr	r5, [pc, #48]	; (1014388 <z_impl_k_thread_suspend+0x64>)
	thread->base.thread_state |= _THREAD_SUSPENDED;
 1014358:	7b63      	ldrb	r3, [r4, #13]
 101435a:	68a8      	ldr	r0, [r5, #8]
 101435c:	f043 0310 	orr.w	r3, r3, #16
 1014360:	7363      	strb	r3, [r4, #13]
 1014362:	1b03      	subs	r3, r0, r4
 1014364:	4258      	negs	r0, r3
 1014366:	4158      	adcs	r0, r3
 1014368:	f7ff fece 	bl	1014108 <update_cache>
	__asm__ volatile(
 101436c:	f386 8811 	msr	BASEPRI, r6
 1014370:	f3bf 8f6f 	isb	sy
	if (thread == _current) {
 1014374:	68ab      	ldr	r3, [r5, #8]
 1014376:	42a3      	cmp	r3, r4
 1014378:	d103      	bne.n	1014382 <z_impl_k_thread_suspend+0x5e>
}
 101437a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		z_reschedule_unlocked();
 101437e:	f003 babf 	b.w	1017900 <z_reschedule_unlocked>
}
 1014382:	bd70      	pop	{r4, r5, r6, pc}
 1014384:	210065e0 	.word	0x210065e0
 1014388:	210065b8 	.word	0x210065b8

0101438c <z_thread_single_abort>:
	if (thread->fn_abort != NULL) {
 101438c:	6d83      	ldr	r3, [r0, #88]	; 0x58
{
 101438e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1014392:	4604      	mov	r4, r0
	if (thread->fn_abort != NULL) {
 1014394:	b103      	cbz	r3, 1014398 <z_thread_single_abort+0xc>
		thread->fn_abort();
 1014396:	4798      	blx	r3
 1014398:	f104 0018 	add.w	r0, r4, #24
 101439c:	f003 fc2a 	bl	1017bf4 <z_abort_timeout>
	__asm__ volatile(
 10143a0:	f04f 0320 	mov.w	r3, #32
 10143a4:	f3ef 8611 	mrs	r6, BASEPRI
 10143a8:	f383 8811 	msr	BASEPRI, r3
 10143ac:	f3bf 8f6f 	isb	sy
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
 10143b0:	7b63      	ldrb	r3, [r4, #13]
 10143b2:	06d8      	lsls	r0, r3, #27
 10143b4:	d123      	bne.n	10143fe <z_thread_single_abort+0x72>
		if (z_is_thread_ready(thread)) {
 10143b6:	69a2      	ldr	r2, [r4, #24]
 10143b8:	bb0a      	cbnz	r2, 10143fe <z_thread_single_abort+0x72>
			if (z_is_thread_queued(thread)) {
 10143ba:	0619      	lsls	r1, r3, #24
 10143bc:	d507      	bpl.n	10143ce <z_thread_single_abort+0x42>
				_priq_run_remove(&_kernel.ready_q.runq,
 10143be:	4621      	mov	r1, r4
 10143c0:	481e      	ldr	r0, [pc, #120]	; (101443c <z_thread_single_abort+0xb0>)
 10143c2:	f7ff fe8b 	bl	10140dc <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
 10143c6:	7b63      	ldrb	r3, [r4, #13]
 10143c8:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 10143cc:	7363      	strb	r3, [r4, #13]
			update_cache(thread == _current);
 10143ce:	4b1c      	ldr	r3, [pc, #112]	; (1014440 <z_thread_single_abort+0xb4>)
 10143d0:	6898      	ldr	r0, [r3, #8]
 10143d2:	1b02      	subs	r2, r0, r4
 10143d4:	4250      	negs	r0, r2
 10143d6:	4150      	adcs	r0, r2
 10143d8:	f7ff fe96 	bl	1014108 <update_cache>
			waiter->base.pended_on = NULL;
 10143dc:	2700      	movs	r7, #0
		thread->base.thread_state |= mask;
 10143de:	7b63      	ldrb	r3, [r4, #13]
	sys_dlist_init(&w->waitq);
}

static inline struct k_thread *z_waitq_head(_wait_q_t *w)
{
	return (struct k_thread *)sys_dlist_peek_head(&w->waitq);
 10143e0:	f104 0828 	add.w	r8, r4, #40	; 0x28
 10143e4:	f043 0308 	orr.w	r3, r3, #8
 10143e8:	7363      	strb	r3, [r4, #13]
	return list->head == list;
 10143ea:	6aa5      	ldr	r5, [r4, #40]	; 0x28
	return sys_dlist_is_empty(list) ? NULL : list->head;
 10143ec:	4545      	cmp	r5, r8
 10143ee:	d000      	beq.n	10143f2 <z_thread_single_abort+0x66>
		while ((waiter = z_waitq_head(&thread->base.join_waiters)) !=
 10143f0:	b995      	cbnz	r5, 1014418 <z_thread_single_abort+0x8c>
	__asm__ volatile(
 10143f2:	f386 8811 	msr	BASEPRI, r6
 10143f6:	f3bf 8f6f 	isb	sy
}
 10143fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
			if (z_is_thread_pending(thread)) {
 10143fe:	079b      	lsls	r3, r3, #30
 1014400:	d5ec      	bpl.n	10143dc <z_thread_single_abort+0x50>
				_priq_wait_remove(&pended_on(thread)->waitq,
 1014402:	4621      	mov	r1, r4
 1014404:	68a0      	ldr	r0, [r4, #8]
 1014406:	f7ff fe69 	bl	10140dc <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
 101440a:	7b63      	ldrb	r3, [r4, #13]
 101440c:	f023 0302 	bic.w	r3, r3, #2
 1014410:	7363      	strb	r3, [r4, #13]
				thread->base.pended_on = NULL;
 1014412:	2300      	movs	r3, #0
 1014414:	60a3      	str	r3, [r4, #8]
 1014416:	e7e1      	b.n	10143dc <z_thread_single_abort+0x50>
 1014418:	f105 0018 	add.w	r0, r5, #24
 101441c:	f003 fbea 	bl	1017bf4 <z_abort_timeout>
			_priq_wait_remove(&pended_on(waiter)->waitq, waiter);
 1014420:	68a8      	ldr	r0, [r5, #8]
 1014422:	4629      	mov	r1, r5
 1014424:	f7ff fe5a 	bl	10140dc <z_priq_dumb_remove>
 1014428:	7b6b      	ldrb	r3, [r5, #13]
			ready_thread(waiter);
 101442a:	4628      	mov	r0, r5
 101442c:	f023 0302 	bic.w	r3, r3, #2
 1014430:	736b      	strb	r3, [r5, #13]
			waiter->base.pended_on = NULL;
 1014432:	60af      	str	r7, [r5, #8]
 1014434:	672f      	str	r7, [r5, #112]	; 0x70
			ready_thread(waiter);
 1014436:	f7ff fea7 	bl	1014188 <ready_thread>
 101443a:	e7d6      	b.n	10143ea <z_thread_single_abort+0x5e>
 101443c:	210065e0 	.word	0x210065e0
 1014440:	210065b8 	.word	0x210065b8

01014444 <unready_thread>:
{
 1014444:	b508      	push	{r3, lr}
	if (z_is_thread_queued(thread)) {
 1014446:	f990 300d 	ldrsb.w	r3, [r0, #13]
{
 101444a:	4601      	mov	r1, r0
	if (z_is_thread_queued(thread)) {
 101444c:	2b00      	cmp	r3, #0
 101444e:	da06      	bge.n	101445e <unready_thread+0x1a>
		_priq_run_remove(&_kernel.ready_q.runq, thread);
 1014450:	4807      	ldr	r0, [pc, #28]	; (1014470 <unready_thread+0x2c>)
 1014452:	f7ff fe43 	bl	10140dc <z_priq_dumb_remove>
	thread->base.thread_state &= ~states;
 1014456:	7b4b      	ldrb	r3, [r1, #13]
 1014458:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 101445c:	734b      	strb	r3, [r1, #13]
	update_cache(thread == _current);
 101445e:	4b05      	ldr	r3, [pc, #20]	; (1014474 <unready_thread+0x30>)
 1014460:	6898      	ldr	r0, [r3, #8]
 1014462:	1a43      	subs	r3, r0, r1
 1014464:	4258      	negs	r0, r3
 1014466:	4158      	adcs	r0, r3
}
 1014468:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	update_cache(thread == _current);
 101446c:	f7ff be4c 	b.w	1014108 <update_cache>
 1014470:	210065e0 	.word	0x210065e0
 1014474:	210065b8 	.word	0x210065b8

01014478 <z_tick_sleep.part.0>:
	z_impl_k_yield();
}
#include <syscalls/k_yield_mrsh.c>
#endif

static s32_t z_tick_sleep(s32_t ticks)
 1014478:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 101447a:	4605      	mov	r5, r0
#else
	ticks += _TICK_ALIGN;
	timeout = (k_ticks_t) ticks;
#endif

	expected_wakeup_time = ticks + z_tick_get_32();
 101447c:	f003 fbfa 	bl	1017c74 <z_tick_get_32>
 1014480:	182c      	adds	r4, r5, r0
	__asm__ volatile(
 1014482:	f04f 0320 	mov.w	r3, #32
 1014486:	f3ef 8711 	mrs	r7, BASEPRI
 101448a:	f383 8811 	msr	BASEPRI, r3
 101448e:	f3bf 8f6f 	isb	sy
	 */
	struct k_spinlock local_lock = {};
	k_spinlock_key_t key = k_spin_lock(&local_lock);

#if defined(CONFIG_TIMESLICING) && defined(CONFIG_SWAP_NONATOMIC)
	pending_current = _current;
 1014492:	4e0d      	ldr	r6, [pc, #52]	; (10144c8 <z_tick_sleep.part.0+0x50>)
 1014494:	4b0d      	ldr	r3, [pc, #52]	; (10144cc <z_tick_sleep.part.0+0x54>)
 1014496:	68b0      	ldr	r0, [r6, #8]
 1014498:	6018      	str	r0, [r3, #0]
#endif
	z_remove_thread_from_ready_q(_current);
 101449a:	f003 fa9d 	bl	10179d8 <z_remove_thread_from_ready_q>
	z_add_thread_timeout(_current, timeout);
 101449e:	68b0      	ldr	r0, [r6, #8]
	z_add_timeout(&th->base.timeout, z_thread_timeout, ticks);
 10144a0:	490b      	ldr	r1, [pc, #44]	; (10144d0 <z_tick_sleep.part.0+0x58>)
 10144a2:	462a      	mov	r2, r5
 10144a4:	17eb      	asrs	r3, r5, #31
 10144a6:	3018      	adds	r0, #24
 10144a8:	f000 fa8a 	bl	10149c0 <z_add_timeout>
	z_mark_thread_as_suspended(_current);
 10144ac:	68b2      	ldr	r2, [r6, #8]
	ret = arch_swap(key);
 10144ae:	4638      	mov	r0, r7
	thread->base.thread_state |= _THREAD_SUSPENDED;
 10144b0:	7b53      	ldrb	r3, [r2, #13]
 10144b2:	f043 0310 	orr.w	r3, r3, #16
 10144b6:	7353      	strb	r3, [r2, #13]
 10144b8:	f7f0 fbde 	bl	1004c78 <arch_swap>

	(void)z_swap(&local_lock, key);

	__ASSERT(!z_is_thread_state_set(_current, _THREAD_SUSPENDED), "");

	ticks = expected_wakeup_time - z_tick_get_32();
 10144bc:	f003 fbda 	bl	1017c74 <z_tick_get_32>
 10144c0:	1a20      	subs	r0, r4, r0
		return ticks;
	}
#endif

	return 0;
}
 10144c2:	ea20 70e0 	bic.w	r0, r0, r0, asr #31
 10144c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 10144c8:	210065b8 	.word	0x210065b8
 10144cc:	210065e8 	.word	0x210065e8
 10144d0:	01017983 	.word	0x01017983

010144d4 <pend>:
{
 10144d4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 10144d8:	4606      	mov	r6, r0
 10144da:	4614      	mov	r4, r2
 10144dc:	461d      	mov	r5, r3
 10144de:	f04f 0320 	mov.w	r3, #32
 10144e2:	f3ef 8711 	mrs	r7, BASEPRI
 10144e6:	f383 8811 	msr	BASEPRI, r3
 10144ea:	f3bf 8f6f 	isb	sy
		add_to_waitq_locked(thread, wait_q);
 10144ee:	f003 fa83 	bl	10179f8 <add_to_waitq_locked>
	__asm__ volatile(
 10144f2:	f387 8811 	msr	BASEPRI, r7
 10144f6:	f3bf 8f6f 	isb	sy
	if (!K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 10144fa:	1c6b      	adds	r3, r5, #1
 10144fc:	bf08      	it	eq
 10144fe:	f1b4 3fff 	cmpeq.w	r4, #4294967295
 1014502:	d008      	beq.n	1014516 <pend+0x42>
 1014504:	4622      	mov	r2, r4
 1014506:	462b      	mov	r3, r5
 1014508:	f106 0018 	add.w	r0, r6, #24
 101450c:	4903      	ldr	r1, [pc, #12]	; (101451c <pend+0x48>)
}
 101450e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 1014512:	f000 ba55 	b.w	10149c0 <z_add_timeout>
 1014516:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 101451a:	bf00      	nop
 101451c:	01017983 	.word	0x01017983

01014520 <z_pend_curr>:
{
 1014520:	b510      	push	{r4, lr}
 1014522:	460c      	mov	r4, r1
	pending_current = _current;
 1014524:	4b06      	ldr	r3, [pc, #24]	; (1014540 <z_pend_curr+0x20>)
{
 1014526:	4611      	mov	r1, r2
	pending_current = _current;
 1014528:	6898      	ldr	r0, [r3, #8]
 101452a:	4b06      	ldr	r3, [pc, #24]	; (1014544 <z_pend_curr+0x24>)
 101452c:	6018      	str	r0, [r3, #0]
	pend(_current, wait_q, timeout);
 101452e:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 1014532:	f7ff ffcf 	bl	10144d4 <pend>
 1014536:	4620      	mov	r0, r4
}
 1014538:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 101453c:	f7f0 bb9c 	b.w	1004c78 <arch_swap>
 1014540:	210065b8 	.word	0x210065b8
 1014544:	210065e8 	.word	0x210065e8

01014548 <z_sched_init>:
	k_sched_time_slice_set(CONFIG_TIMESLICE_SIZE,
 1014548:	2100      	movs	r1, #0
	list->head = (sys_dnode_t *)list;
 101454a:	4b04      	ldr	r3, [pc, #16]	; (101455c <z_sched_init+0x14>)
 101454c:	4608      	mov	r0, r1
 101454e:	f103 0228 	add.w	r2, r3, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
 1014552:	e9c3 220a 	strd	r2, r2, [r3, #40]	; 0x28
 1014556:	f7ff bd81 	b.w	101405c <k_sched_time_slice_set>
 101455a:	bf00      	nop
 101455c:	210065b8 	.word	0x210065b8

01014560 <z_impl_k_yield>:
{
 1014560:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	if (!z_is_idle_thread_object(_current)) {
 1014562:	4c24      	ldr	r4, [pc, #144]	; (10145f4 <z_impl_k_yield+0x94>)
 1014564:	4b24      	ldr	r3, [pc, #144]	; (10145f8 <z_impl_k_yield+0x98>)
 1014566:	68a2      	ldr	r2, [r4, #8]
 1014568:	429a      	cmp	r2, r3
 101456a:	d030      	beq.n	10145ce <z_impl_k_yield+0x6e>
	__asm__ volatile(
 101456c:	f04f 0320 	mov.w	r3, #32
 1014570:	f3ef 8511 	mrs	r5, BASEPRI
 1014574:	f383 8811 	msr	BASEPRI, r3
 1014578:	f3bf 8f6f 	isb	sy
				_priq_run_remove(&_kernel.ready_q.runq,
 101457c:	68a1      	ldr	r1, [r4, #8]
 101457e:	f104 0028 	add.w	r0, r4, #40	; 0x28
 1014582:	f7ff fdab 	bl	10140dc <z_priq_dumb_remove>
	return list->head == list;
 1014586:	6aa3      	ldr	r3, [r4, #40]	; 0x28
			_priq_run_add(&_kernel.ready_q.runq, _current);
 1014588:	68a2      	ldr	r2, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 101458a:	4283      	cmp	r3, r0
 101458c:	bf08      	it	eq
 101458e:	2300      	moveq	r3, #0
 1014590:	2b00      	cmp	r3, #0
 1014592:	bf38      	it	cc
 1014594:	2300      	movcc	r3, #0
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 1014596:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 1014598:	b32b      	cbz	r3, 10145e6 <z_impl_k_yield+0x86>
	if (thread_1->base.prio < thread_2->base.prio) {
 101459a:	f992 700e 	ldrsb.w	r7, [r2, #14]
 101459e:	f993 600e 	ldrsb.w	r6, [r3, #14]
 10145a2:	42b7      	cmp	r7, r6
 10145a4:	db03      	blt.n	10145ae <z_impl_k_yield+0x4e>
	return (node == list->tail) ? NULL : node->next;
 10145a6:	428b      	cmp	r3, r1
 10145a8:	d01d      	beq.n	10145e6 <z_impl_k_yield+0x86>
 10145aa:	681b      	ldr	r3, [r3, #0]
 10145ac:	e7f4      	b.n	1014598 <z_impl_k_yield+0x38>
	node->prev = successor->prev;
 10145ae:	6859      	ldr	r1, [r3, #4]
	node->next = successor;
 10145b0:	e9c2 3100 	strd	r3, r1, [r2]
	successor->prev->next = node;
 10145b4:	600a      	str	r2, [r1, #0]
	successor->prev = node;
 10145b6:	605a      	str	r2, [r3, #4]
	thread->base.thread_state |= states;
 10145b8:	7b53      	ldrb	r3, [r2, #13]
			update_cache(1);
 10145ba:	2001      	movs	r0, #1
 10145bc:	f063 037f 	orn	r3, r3, #127	; 0x7f
 10145c0:	7353      	strb	r3, [r2, #13]
 10145c2:	f7ff fda1 	bl	1014108 <update_cache>
	__asm__ volatile(
 10145c6:	f385 8811 	msr	BASEPRI, r5
 10145ca:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
 10145ce:	f04f 0320 	mov.w	r3, #32
 10145d2:	f3ef 8011 	mrs	r0, BASEPRI
 10145d6:	f383 8811 	msr	BASEPRI, r3
 10145da:	f3bf 8f6f 	isb	sy
}
 10145de:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 10145e2:	f7f0 bb49 	b.w	1004c78 <arch_swap>
	node->prev = list->tail;
 10145e6:	e9c2 0100 	strd	r0, r1, [r2]
	list->tail->next = node;
 10145ea:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 10145ec:	601a      	str	r2, [r3, #0]
	list->tail = node;
 10145ee:	62e2      	str	r2, [r4, #44]	; 0x2c
}
 10145f0:	e7e2      	b.n	10145b8 <z_impl_k_yield+0x58>
 10145f2:	bf00      	nop
 10145f4:	210065b8 	.word	0x210065b8
 10145f8:	21004070 	.word	0x21004070

010145fc <z_impl_k_sleep>:

s32_t z_impl_k_sleep(k_timeout_t timeout)
{
 10145fc:	460b      	mov	r3, r1
	k_ticks_t ticks;

	__ASSERT(!arch_is_in_isr(), "");

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 10145fe:	3301      	adds	r3, #1
 1014600:	bf08      	it	eq
 1014602:	f1b0 3fff 	cmpeq.w	r0, #4294967295
{
 1014606:	b510      	push	{r4, lr}
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 1014608:	d106      	bne.n	1014618 <z_impl_k_sleep+0x1c>
		k_thread_suspend(_current);
 101460a:	4b0b      	ldr	r3, [pc, #44]	; (1014638 <z_impl_k_sleep+0x3c>)
 101460c:	6898      	ldr	r0, [r3, #8]
	z_impl_k_thread_suspend(thread);
 101460e:	f7ff fe89 	bl	1014324 <z_impl_k_thread_suspend>
		return (s32_t) K_TICKS_FOREVER;
 1014612:	f04f 30ff 	mov.w	r0, #4294967295
	ticks = timeout.ticks;
#endif

	ticks = z_tick_sleep(ticks);
	return k_ticks_to_ms_floor64(ticks);
}
 1014616:	bd10      	pop	{r4, pc}
	ticks = z_tick_sleep(ticks);
 1014618:	4604      	mov	r4, r0
	if (ticks == 0) {
 101461a:	b948      	cbnz	r0, 1014630 <z_impl_k_sleep+0x34>
	z_impl_k_yield();
 101461c:	f7ff ffa0 	bl	1014560 <z_impl_k_yield>
			return (t * to_hz + off) / from_hz;
 1014620:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 1014624:	fb84 3400 	smull	r3, r4, r4, r0
 1014628:	0bd8      	lsrs	r0, r3, #15
 101462a:	ea40 4044 	orr.w	r0, r0, r4, lsl #17
	return k_ticks_to_ms_floor64(ticks);
 101462e:	e7f2      	b.n	1014616 <z_impl_k_sleep+0x1a>
 1014630:	f7ff ff22 	bl	1014478 <z_tick_sleep.part.0>
 1014634:	4604      	mov	r4, r0
 1014636:	e7f3      	b.n	1014620 <z_impl_k_sleep+0x24>
 1014638:	210065b8 	.word	0x210065b8

0101463c <z_impl_k_current_get>:

#ifdef CONFIG_SMP
	arch_irq_unlock(k);
#endif
	return ret;
}
 101463c:	4b01      	ldr	r3, [pc, #4]	; (1014644 <z_impl_k_current_get+0x8>)
 101463e:	6898      	ldr	r0, [r3, #8]
 1014640:	4770      	bx	lr
 1014642:	bf00      	nop
 1014644:	210065b8 	.word	0x210065b8

01014648 <z_impl_k_sem_give>:
	ARG_UNUSED(sem);
#endif
}

void z_impl_k_sem_give(struct k_sem *sem)
{
 1014648:	b538      	push	{r3, r4, r5, lr}
 101464a:	4604      	mov	r4, r0
 101464c:	f04f 0320 	mov.w	r3, #32
 1014650:	f3ef 8511 	mrs	r5, BASEPRI
 1014654:	f383 8811 	msr	BASEPRI, r3
 1014658:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_thread *thread = z_unpend_first_thread(&sem->wait_q);
 101465c:	f003 f9f7 	bl	1017a4e <z_unpend_first_thread>

	sys_trace_void(SYS_TRACE_ID_SEMA_GIVE);

	if (thread != NULL) {
 1014660:	b148      	cbz	r0, 1014676 <z_impl_k_sem_give+0x2e>
 1014662:	2200      	movs	r2, #0
 1014664:	6702      	str	r2, [r0, #112]	; 0x70
		arch_thread_return_value_set(thread, 0);
		z_ready_thread(thread);
 1014666:	f003 f97c 	bl	1017962 <z_ready_thread>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
		handle_poll_events(sem);
	}

	sys_trace_end_call(SYS_TRACE_ID_SEMA_GIVE);
	z_reschedule(&lock, key);
 101466a:	4629      	mov	r1, r5
}
 101466c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_reschedule(&lock, key);
 1014670:	4807      	ldr	r0, [pc, #28]	; (1014690 <z_impl_k_sem_give+0x48>)
 1014672:	f003 b92e 	b.w	10178d2 <z_reschedule>
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
 1014676:	e9d4 3202 	ldrd	r3, r2, [r4, #8]
 101467a:	429a      	cmp	r2, r3
 101467c:	bf18      	it	ne
 101467e:	3301      	addne	r3, #1
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
 1014680:	2102      	movs	r1, #2
		sem->count += (sem->count != sem->limit) ? 1U : 0U;
 1014682:	60a3      	str	r3, [r4, #8]
	z_handle_obj_poll_events(&sem->poll_events, K_POLL_STATE_SEM_AVAILABLE);
 1014684:	f104 0010 	add.w	r0, r4, #16
 1014688:	f003 fc4b 	bl	1017f22 <z_handle_obj_poll_events>
}
 101468c:	e7ed      	b.n	101466a <z_impl_k_sem_give+0x22>
 101468e:	bf00      	nop
 1014690:	210066fd 	.word	0x210066fd

01014694 <z_impl_k_sem_take>:
}
#include <syscalls/k_sem_give_mrsh.c>
#endif

int z_impl_k_sem_take(struct k_sem *sem, k_timeout_t timeout)
{
 1014694:	b537      	push	{r0, r1, r2, r4, r5, lr}
 1014696:	4614      	mov	r4, r2
 1014698:	461d      	mov	r5, r3
 101469a:	f04f 0320 	mov.w	r3, #32
 101469e:	f3ef 8111 	mrs	r1, BASEPRI
 10146a2:	f383 8811 	msr	BASEPRI, r3
 10146a6:	f3bf 8f6f 	isb	sy
		  K_TIMEOUT_EQ(timeout, K_NO_WAIT)), "");

	sys_trace_void(SYS_TRACE_ID_SEMA_TAKE);
	k_spinlock_key_t key = k_spin_lock(&lock);

	if (likely(sem->count > 0U)) {
 10146aa:	6883      	ldr	r3, [r0, #8]
 10146ac:	b143      	cbz	r3, 10146c0 <z_impl_k_sem_take+0x2c>
		sem->count--;
 10146ae:	3b01      	subs	r3, #1
 10146b0:	6083      	str	r3, [r0, #8]
	__asm__ volatile(
 10146b2:	f381 8811 	msr	BASEPRI, r1
 10146b6:	f3bf 8f6f 	isb	sy
		k_spin_unlock(&lock, key);
		ret = 0;
 10146ba:	2000      	movs	r0, #0
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);

out:
	sys_trace_end_call(SYS_TRACE_ID_SEMA_TAKE);
	return ret;
}
 10146bc:	b003      	add	sp, #12
 10146be:	bd30      	pop	{r4, r5, pc}
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 10146c0:	ea54 0305 	orrs.w	r3, r4, r5
 10146c4:	d106      	bne.n	10146d4 <z_impl_k_sem_take+0x40>
 10146c6:	f381 8811 	msr	BASEPRI, r1
 10146ca:	f3bf 8f6f 	isb	sy
		ret = -EBUSY;
 10146ce:	f06f 000f 	mvn.w	r0, #15
 10146d2:	e7f3      	b.n	10146bc <z_impl_k_sem_take+0x28>
	ret = z_pend_curr(&lock, key, &sem->wait_q, timeout);
 10146d4:	4602      	mov	r2, r0
 10146d6:	e9cd 4500 	strd	r4, r5, [sp]
 10146da:	4802      	ldr	r0, [pc, #8]	; (10146e4 <z_impl_k_sem_take+0x50>)
 10146dc:	f7ff ff20 	bl	1014520 <z_pend_curr>
	return ret;
 10146e0:	e7ec      	b.n	10146bc <z_impl_k_sem_take+0x28>
 10146e2:	bf00      	nop
 10146e4:	210066fd 	.word	0x210066fd

010146e8 <k_sys_work_q_init>:
K_THREAD_STACK_DEFINE(sys_work_q_stack, CONFIG_SYSTEM_WORKQUEUE_STACK_SIZE);

struct k_work_q k_sys_work_q;

static int k_sys_work_q_init(struct device *dev)
{
 10146e8:	b510      	push	{r4, lr}
	ARG_UNUSED(dev);

	k_work_q_start(&k_sys_work_q,
 10146ea:	4c08      	ldr	r4, [pc, #32]	; (101470c <k_sys_work_q_init+0x24>)
 10146ec:	f04f 33ff 	mov.w	r3, #4294967295
 10146f0:	f44f 7200 	mov.w	r2, #512	; 0x200
 10146f4:	4620      	mov	r0, r4
 10146f6:	4906      	ldr	r1, [pc, #24]	; (1014710 <k_sys_work_q_init+0x28>)
 10146f8:	f000 f8c2 	bl	1014880 <k_work_q_start>
	return z_impl_k_thread_name_set(thread_id, value);
 10146fc:	4905      	ldr	r1, [pc, #20]	; (1014714 <k_sys_work_q_init+0x2c>)
 10146fe:	f104 0018 	add.w	r0, r4, #24
 1014702:	f003 f9f9 	bl	1017af8 <z_impl_k_thread_name_set>
		       K_THREAD_STACK_SIZEOF(sys_work_q_stack),
		       CONFIG_SYSTEM_WORKQUEUE_PRIORITY);
	k_thread_name_set(&k_sys_work_q.thread, "sysworkq");

	return 0;
}
 1014706:	2000      	movs	r0, #0
 1014708:	bd10      	pop	{r4, pc}
 101470a:	bf00      	nop
 101470c:	210065f4 	.word	0x210065f4
 1014710:	21008110 	.word	0x21008110
 1014714:	01019a9d 	.word	0x01019a9d

01014718 <z_setup_new_thread>:
void z_setup_new_thread(struct k_thread *new_thread,
		       k_thread_stack_t *stack, size_t stack_size,
		       k_thread_entry_t entry,
		       void *p1, void *p2, void *p3,
		       int prio, u32_t options, const char *name)
{
 1014718:	b5f0      	push	{r4, r5, r6, r7, lr}
	sys_dlist_init(&w->waitq);
 101471a:	f100 0528 	add.w	r5, r0, #40	; 0x28
	list->tail = (sys_dnode_t *)list;
 101471e:	e9c0 550a 	strd	r5, r5, [r0, #40]	; 0x28
		       u32_t initial_state, unsigned int options)
{
	/* k_q_node is initialized upon first insertion in a list */

	thread_base->user_options = (u8_t)options;
	thread_base->thread_state = (u8_t)initial_state;
 1014722:	2504      	movs	r5, #4
 1014724:	7345      	strb	r5, [r0, #13]

	thread_base->prio = priority;

	thread_base->sched_locked = 0U;
 1014726:	2500      	movs	r5, #0
{
 1014728:	4604      	mov	r4, r0
 101472a:	b087      	sub	sp, #28
 101472c:	e9dd 670f 	ldrd	r6, r7, [sp, #60]	; 0x3c
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 1014730:	e9cd 6703 	strd	r6, r7, [sp, #12]
	thread_base->prio = priority;
 1014734:	7386      	strb	r6, [r0, #14]
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 1014736:	9e0e      	ldr	r6, [sp, #56]	; 0x38
	node->prev = NULL;
 1014738:	e9c0 5506 	strd	r5, r5, [r0, #24]
 101473c:	9602      	str	r6, [sp, #8]
 101473e:	9e0d      	ldr	r6, [sp, #52]	; 0x34
	thread_base->user_options = (u8_t)options;
 1014740:	7307      	strb	r7, [r0, #12]
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 1014742:	9601      	str	r6, [sp, #4]
 1014744:	9e0c      	ldr	r6, [sp, #48]	; 0x30
	thread_base->sched_locked = 0U;
 1014746:	73c5      	strb	r5, [r0, #15]
	arch_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 1014748:	9600      	str	r6, [sp, #0]
 101474a:	f7f0 fb39 	bl	1004dc0 <arch_new_thread>
	if (!_current) {
 101474e:	4b04      	ldr	r3, [pc, #16]	; (1014760 <z_setup_new_thread+0x48>)
	new_thread->fn_abort = NULL;
 1014750:	e9c4 5515 	strd	r5, r5, [r4, #84]	; 0x54
	if (!_current) {
 1014754:	689b      	ldr	r3, [r3, #8]
 1014756:	b103      	cbz	r3, 101475a <z_setup_new_thread+0x42>
	new_thread->resource_pool = _current->resource_pool;
 1014758:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 101475a:	66a3      	str	r3, [r4, #104]	; 0x68
}
 101475c:	b007      	add	sp, #28
 101475e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 1014760:	210065b8 	.word	0x210065b8

01014764 <z_impl_k_thread_create>:
{
 1014764:	b5f0      	push	{r4, r5, r6, r7, lr}
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 1014766:	2500      	movs	r5, #0
{
 1014768:	b087      	sub	sp, #28
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 101476a:	9505      	str	r5, [sp, #20]
 101476c:	9d10      	ldr	r5, [sp, #64]	; 0x40
{
 101476e:	e9dd 6712 	ldrd	r6, r7, [sp, #72]	; 0x48
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 1014772:	9504      	str	r5, [sp, #16]
 1014774:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
{
 1014776:	4604      	mov	r4, r0
	z_setup_new_thread(new_thread, stack, stack_size, entry, p1, p2, p3,
 1014778:	9503      	str	r5, [sp, #12]
 101477a:	9d0e      	ldr	r5, [sp, #56]	; 0x38
 101477c:	9502      	str	r5, [sp, #8]
 101477e:	9d0d      	ldr	r5, [sp, #52]	; 0x34
 1014780:	9501      	str	r5, [sp, #4]
 1014782:	9d0c      	ldr	r5, [sp, #48]	; 0x30
 1014784:	9500      	str	r5, [sp, #0]
 1014786:	f7ff ffc7 	bl	1014718 <z_setup_new_thread>
	if (!K_TIMEOUT_EQ(delay, K_FOREVER)) {
 101478a:	1c7b      	adds	r3, r7, #1
 101478c:	bf08      	it	eq
 101478e:	f1b6 3fff 	cmpeq.w	r6, #4294967295
 1014792:	d005      	beq.n	10147a0 <z_impl_k_thread_create+0x3c>
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 1014794:	ea56 0307 	orrs.w	r3, r6, r7
 1014798:	d105      	bne.n	10147a6 <z_impl_k_thread_create+0x42>
	z_sched_start(thread);
 101479a:	4620      	mov	r0, r4
 101479c:	f7ff fd28 	bl	10141f0 <z_sched_start>
}
 10147a0:	4620      	mov	r0, r4
 10147a2:	b007      	add	sp, #28
 10147a4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 10147a6:	4632      	mov	r2, r6
 10147a8:	463b      	mov	r3, r7
 10147aa:	4903      	ldr	r1, [pc, #12]	; (10147b8 <z_impl_k_thread_create+0x54>)
 10147ac:	f104 0018 	add.w	r0, r4, #24
 10147b0:	f000 f906 	bl	10149c0 <z_add_timeout>
 10147b4:	e7f4      	b.n	10147a0 <z_impl_k_thread_create+0x3c>
 10147b6:	bf00      	nop
 10147b8:	01017983 	.word	0x01017983

010147bc <z_init_static_threads>:
{
 10147bc:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	_FOREACH_STATIC_THREAD(thread_data) {
 10147c0:	f8df 90b4 	ldr.w	r9, [pc, #180]	; 1014878 <z_init_static_threads+0xbc>
 10147c4:	4d2b      	ldr	r5, [pc, #172]	; (1014874 <z_init_static_threads+0xb8>)
 10147c6:	46c8      	mov	r8, r9
{
 10147c8:	b087      	sub	sp, #28
	_FOREACH_STATIC_THREAD(thread_data) {
 10147ca:	454d      	cmp	r5, r9
 10147cc:	f105 0430 	add.w	r4, r5, #48	; 0x30
 10147d0:	d30d      	bcc.n	10147ee <z_init_static_threads+0x32>
	k_sched_lock();
 10147d2:	f7ff fc6f 	bl	10140b4 <k_sched_lock>
			return (u32_t)((t * to_hz + off) / from_hz);
 10147d6:	f44f 4900 	mov.w	r9, #32768	; 0x8000
	_FOREACH_STATIC_THREAD(thread_data) {
 10147da:	4c26      	ldr	r4, [pc, #152]	; (1014874 <z_init_static_threads+0xb8>)
 10147dc:	f8df a09c 	ldr.w	sl, [pc, #156]	; 101487c <z_init_static_threads+0xc0>
 10147e0:	4544      	cmp	r4, r8
 10147e2:	d321      	bcc.n	1014828 <z_init_static_threads+0x6c>
}
 10147e4:	b007      	add	sp, #28
 10147e6:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	k_sched_unlock();
 10147ea:	f7ff bcb1 	b.w	1014150 <k_sched_unlock>
		z_setup_new_thread(
 10147ee:	f854 3c04 	ldr.w	r3, [r4, #-4]
 10147f2:	9305      	str	r3, [sp, #20]
 10147f4:	f854 3c10 	ldr.w	r3, [r4, #-16]
 10147f8:	9304      	str	r3, [sp, #16]
 10147fa:	f854 3c14 	ldr.w	r3, [r4, #-20]
 10147fe:	9303      	str	r3, [sp, #12]
 1014800:	f854 3c18 	ldr.w	r3, [r4, #-24]
 1014804:	9302      	str	r3, [sp, #8]
 1014806:	f854 3c1c 	ldr.w	r3, [r4, #-28]
 101480a:	9301      	str	r3, [sp, #4]
 101480c:	f854 3c20 	ldr.w	r3, [r4, #-32]
 1014810:	9300      	str	r3, [sp, #0]
 1014812:	e954 230a 	ldrd	r2, r3, [r4, #-40]	; 0x28
 1014816:	e954 010c 	ldrd	r0, r1, [r4, #-48]	; 0x30
 101481a:	f7ff ff7d 	bl	1014718 <z_setup_new_thread>
		thread_data->init_thread->init_data = thread_data;
 101481e:	f854 3c30 	ldr.w	r3, [r4, #-48]
 1014822:	655d      	str	r5, [r3, #84]	; 0x54
 1014824:	4625      	mov	r5, r4
 1014826:	e7d0      	b.n	10147ca <z_init_static_threads+0xe>
		if (thread_data->init_delay != K_TICKS_FOREVER) {
 1014828:	6a61      	ldr	r1, [r4, #36]	; 0x24
 101482a:	1c4b      	adds	r3, r1, #1
 101482c:	d017      	beq.n	101485e <z_init_static_threads+0xa2>
 101482e:	f240 3be7 	movw	fp, #999	; 0x3e7
 1014832:	f04f 0c00 	mov.w	ip, #0
					    K_MSEC(thread_data->init_delay));
 1014836:	ea21 71e1 	bic.w	r1, r1, r1, asr #31
 101483a:	fbc9 bc01 	smlal	fp, ip, r9, r1
 101483e:	2300      	movs	r3, #0
 1014840:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 1014844:	4658      	mov	r0, fp
 1014846:	4661      	mov	r1, ip
 1014848:	f7eb fc36 	bl	10000b8 <__aeabi_uldivmod>
 101484c:	2700      	movs	r7, #0
 101484e:	4606      	mov	r6, r0
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 1014850:	ea56 0307 	orrs.w	r3, r6, r7
			schedule_new_thread(thread_data->init_thread,
 1014854:	6825      	ldr	r5, [r4, #0]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 1014856:	d104      	bne.n	1014862 <z_init_static_threads+0xa6>
	z_sched_start(thread);
 1014858:	4628      	mov	r0, r5
 101485a:	f7ff fcc9 	bl	10141f0 <z_sched_start>
	_FOREACH_STATIC_THREAD(thread_data) {
 101485e:	3430      	adds	r4, #48	; 0x30
 1014860:	e7be      	b.n	10147e0 <z_init_static_threads+0x24>
 1014862:	4602      	mov	r2, r0
 1014864:	463b      	mov	r3, r7
 1014866:	4651      	mov	r1, sl
 1014868:	f105 0018 	add.w	r0, r5, #24
 101486c:	f000 f8a8 	bl	10149c0 <z_add_timeout>
 1014870:	e7f5      	b.n	101485e <z_init_static_threads+0xa2>
 1014872:	bf00      	nop
 1014874:	2100052c 	.word	0x2100052c
 1014878:	2100052c 	.word	0x2100052c
 101487c:	01017983 	.word	0x01017983

01014880 <k_work_q_start>:

extern void z_work_q_main(void *work_q_ptr, void *p2, void *p3);

void k_work_q_start(struct k_work_q *work_q, k_thread_stack_t *stack,
		    size_t stack_size, int prio)
{
 1014880:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1014884:	4604      	mov	r4, r0
 1014886:	b088      	sub	sp, #32
 1014888:	460d      	mov	r5, r1
 101488a:	4616      	mov	r6, r2
 101488c:	461f      	mov	r7, r3
	z_impl_k_queue_init(queue);
 101488e:	f002 ff9c 	bl	10177ca <z_impl_k_queue_init>
	k_queue_init(&work_q->queue);
	(void)k_thread_create(&work_q->thread, stack, stack_size, z_work_q_main,
 1014892:	f104 0818 	add.w	r8, r4, #24
	return z_impl_k_thread_create(new_thread, stack, stack_size, entry, p1, p2, p3, prio, options, delay);
 1014896:	2200      	movs	r2, #0
 1014898:	2300      	movs	r3, #0
 101489a:	e9cd 7203 	strd	r7, r2, [sp, #12]
 101489e:	e9cd 2306 	strd	r2, r3, [sp, #24]
 10148a2:	e9cd 2201 	strd	r2, r2, [sp, #4]
 10148a6:	4629      	mov	r1, r5
 10148a8:	4632      	mov	r2, r6
 10148aa:	4640      	mov	r0, r8
 10148ac:	4b05      	ldr	r3, [pc, #20]	; (10148c4 <k_work_q_start+0x44>)
 10148ae:	9400      	str	r4, [sp, #0]
 10148b0:	f7ff ff58 	bl	1014764 <z_impl_k_thread_create>
	return z_impl_k_thread_name_set(thread_id, value);
 10148b4:	4640      	mov	r0, r8
 10148b6:	4904      	ldr	r1, [pc, #16]	; (10148c8 <k_work_q_start+0x48>)
			work_q, NULL, NULL, prio, 0, K_NO_WAIT);

	k_thread_name_set(&work_q->thread, WORKQUEUE_THREAD_NAME);
}
 10148b8:	b008      	add	sp, #32
 10148ba:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 10148be:	f003 b91b 	b.w	1017af8 <z_impl_k_thread_name_set>
 10148c2:	bf00      	nop
 10148c4:	01014e1f 	.word	0x01014e1f
 10148c8:	01019aa6 	.word	0x01019aa6

010148cc <k_delayed_work_submit_to_queue>:
}

int k_delayed_work_submit_to_queue(struct k_work_q *work_q,
				   struct k_delayed_work *work,
				   k_timeout_t delay)
{
 10148cc:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 10148d0:	4606      	mov	r6, r0
 10148d2:	460d      	mov	r5, r1
 10148d4:	4690      	mov	r8, r2
 10148d6:	4699      	mov	r9, r3
	__asm__ volatile(
 10148d8:	f04f 0320 	mov.w	r3, #32
 10148dc:	f3ef 8711 	mrs	r7, BASEPRI
 10148e0:	f383 8811 	msr	BASEPRI, r3
 10148e4:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	int err = 0;

	/* Work cannot be active in multiple queues */
	if (work->work_q != NULL && work->work_q != work_q) {
 10148e8:	69cb      	ldr	r3, [r1, #28]
 10148ea:	b17b      	cbz	r3, 101490c <k_delayed_work_submit_to_queue+0x40>
 10148ec:	4283      	cmp	r3, r0
 10148ee:	d128      	bne.n	1014942 <k_delayed_work_submit_to_queue+0x76>
		goto done;
	}

	/* Cancel if work has been submitted */
	if (work->work_q == work_q) {
		err = work_cancel(work);
 10148f0:	4628      	mov	r0, r5
 10148f2:	f003 f91f 	bl	1017b34 <work_cancel>
		/* -EALREADY indicates the work has already completed so this
		 * is likely a recurring work.
		 */
		if (err == -EALREADY) {
 10148f6:	f110 0f45 	cmn.w	r0, #69	; 0x45
		err = work_cancel(work);
 10148fa:	4604      	mov	r4, r0
		if (err == -EALREADY) {
 10148fc:	d008      	beq.n	1014910 <k_delayed_work_submit_to_queue+0x44>
			err = 0;
		} else if (err < 0) {
 10148fe:	2800      	cmp	r0, #0
 1014900:	da07      	bge.n	1014912 <k_delayed_work_submit_to_queue+0x46>
	__asm__ volatile(
 1014902:	f387 8811 	msr	BASEPRI, r7
 1014906:	f3bf 8f6f 	isb	sy
	/* Add timeout */
	z_add_timeout(&work->timeout, work_timeout, delay);

done:
	k_spin_unlock(&lock, key);
	return err;
 101490a:	e00f      	b.n	101492c <k_delayed_work_submit_to_queue+0x60>
	if (work->work_q == work_q) {
 101490c:	2800      	cmp	r0, #0
 101490e:	d0ef      	beq.n	10148f0 <k_delayed_work_submit_to_queue+0x24>
	int err = 0;
 1014910:	2400      	movs	r4, #0
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 1014912:	ea58 0309 	orrs.w	r3, r8, r9
	work->work_q = work_q;
 1014916:	61ee      	str	r6, [r5, #28]
	if (K_TIMEOUT_EQ(delay, K_NO_WAIT)) {
 1014918:	d10b      	bne.n	1014932 <k_delayed_work_submit_to_queue+0x66>
 101491a:	f387 8811 	msr	BASEPRI, r7
 101491e:	f3bf 8f6f 	isb	sy
		k_work_submit_to_queue(work_q, &work->work);
 1014922:	4629      	mov	r1, r5
 1014924:	4630      	mov	r0, r6
 1014926:	f003 f8ec 	bl	1017b02 <k_work_submit_to_queue>
		return 0;
 101492a:	2400      	movs	r4, #0
}
 101492c:	4620      	mov	r0, r4
 101492e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	z_add_timeout(&work->timeout, work_timeout, delay);
 1014932:	4642      	mov	r2, r8
 1014934:	464b      	mov	r3, r9
 1014936:	4904      	ldr	r1, [pc, #16]	; (1014948 <k_delayed_work_submit_to_queue+0x7c>)
 1014938:	f105 000c 	add.w	r0, r5, #12
 101493c:	f000 f840 	bl	10149c0 <z_add_timeout>
 1014940:	e7df      	b.n	1014902 <k_delayed_work_submit_to_queue+0x36>
		err = -EADDRINUSE;
 1014942:	f06f 042f 	mvn.w	r4, #47	; 0x2f
 1014946:	e7dc      	b.n	1014902 <k_delayed_work_submit_to_queue+0x36>
 1014948:	01017b2b 	.word	0x01017b2b

0101494c <elapsed>:
	sys_dlist_remove(&t->node);
}

static s32_t elapsed(void)
{
	return announce_remaining == 0 ? z_clock_elapsed() : 0;
 101494c:	4b03      	ldr	r3, [pc, #12]	; (101495c <elapsed+0x10>)
 101494e:	681b      	ldr	r3, [r3, #0]
 1014950:	b90b      	cbnz	r3, 1014956 <elapsed+0xa>
 1014952:	f7f0 b887 	b.w	1004a64 <z_clock_elapsed>
}
 1014956:	2000      	movs	r0, #0
 1014958:	4770      	bx	lr
 101495a:	bf00      	nop
 101495c:	21006680 	.word	0x21006680

01014960 <remove_timeout>:
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 1014960:	6803      	ldr	r3, [r0, #0]
 1014962:	b140      	cbz	r0, 1014976 <remove_timeout+0x16>
 1014964:	4a07      	ldr	r2, [pc, #28]	; (1014984 <remove_timeout+0x24>)
	return (node == list->tail) ? NULL : node->next;
 1014966:	6852      	ldr	r2, [r2, #4]
 1014968:	4290      	cmp	r0, r2
 101496a:	d004      	beq.n	1014976 <remove_timeout+0x16>
	if (next(t) != NULL) {
 101496c:	b11b      	cbz	r3, 1014976 <remove_timeout+0x16>
		next(t)->dticks += t->dticks;
 101496e:	689a      	ldr	r2, [r3, #8]
 1014970:	6881      	ldr	r1, [r0, #8]
 1014972:	440a      	add	r2, r1
 1014974:	609a      	str	r2, [r3, #8]
	node->prev->next = node->next;
 1014976:	6842      	ldr	r2, [r0, #4]
 1014978:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
 101497a:	605a      	str	r2, [r3, #4]
	node->next = NULL;
 101497c:	2300      	movs	r3, #0
	node->prev = NULL;
 101497e:	e9c0 3300 	strd	r3, r3, [r0]
}
 1014982:	4770      	bx	lr
 1014984:	210004a0 	.word	0x210004a0

01014988 <next_timeout>:
	return list->head == list;
 1014988:	4b0b      	ldr	r3, [pc, #44]	; (10149b8 <next_timeout+0x30>)

static s32_t next_timeout(void)
{
 101498a:	b510      	push	{r4, lr}
 101498c:	681c      	ldr	r4, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 101498e:	429c      	cmp	r4, r3
 1014990:	bf08      	it	eq
 1014992:	2400      	moveq	r4, #0
	struct _timeout *to = first();
	s32_t ticks_elapsed = elapsed();
 1014994:	f7ff ffda 	bl	101494c <elapsed>
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
 1014998:	b154      	cbz	r4, 10149b0 <next_timeout+0x28>
 101499a:	68a3      	ldr	r3, [r4, #8]
 101499c:	1a18      	subs	r0, r3, r0
 101499e:	ea20 70e0 	bic.w	r0, r0, r0, asr #31

#ifdef CONFIG_TIMESLICING
	if (_current_cpu->slice_ticks && _current_cpu->slice_ticks < ret) {
 10149a2:	4b06      	ldr	r3, [pc, #24]	; (10149bc <next_timeout+0x34>)
 10149a4:	691b      	ldr	r3, [r3, #16]
 10149a6:	b113      	cbz	r3, 10149ae <next_timeout+0x26>
 10149a8:	4298      	cmp	r0, r3
 10149aa:	bfa8      	it	ge
 10149ac:	4618      	movge	r0, r3
		ret = _current_cpu->slice_ticks;
	}
#endif
	return ret;
}
 10149ae:	bd10      	pop	{r4, pc}
	s32_t ret = to == NULL ? MAX_WAIT : MAX(0, to->dticks - ticks_elapsed);
 10149b0:	f06f 4000 	mvn.w	r0, #2147483648	; 0x80000000
 10149b4:	e7f5      	b.n	10149a2 <next_timeout+0x1a>
 10149b6:	bf00      	nop
 10149b8:	210004a0 	.word	0x210004a0
 10149bc:	210065b8 	.word	0x210065b8

010149c0 <z_add_timeout>:

void z_add_timeout(struct _timeout *to, _timeout_func_t fn,
		   k_timeout_t timeout)
{
 10149c0:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 10149c4:	9101      	str	r1, [sp, #4]
 10149c6:	4619      	mov	r1, r3
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 10149c8:	1c4b      	adds	r3, r1, #1
 10149ca:	bf08      	it	eq
 10149cc:	f1b2 3fff 	cmpeq.w	r2, #4294967295
{
 10149d0:	4682      	mov	sl, r0
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 10149d2:	d061      	beq.n	1014a98 <z_add_timeout+0xd8>
#ifdef CONFIG_LEGACY_TIMEOUT_API
	k_ticks_t ticks = timeout;
#else
	k_ticks_t ticks = timeout.ticks + 1;

	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
 10149d4:	f06f 0301 	mvn.w	r3, #1
 10149d8:	f04f 3bff 	mov.w	fp, #4294967295
	k_ticks_t ticks = timeout.ticks + 1;
 10149dc:	1c54      	adds	r4, r2, #1
 10149de:	f141 0500 	adc.w	r5, r1, #0
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(ticks) >= 0) {
 10149e2:	ebb3 0804 	subs.w	r8, r3, r4
 10149e6:	eb6b 0905 	sbc.w	r9, fp, r5
 10149ea:	f1b8 0f00 	cmp.w	r8, #0
 10149ee:	f179 0300 	sbcs.w	r3, r9, #0
 10149f2:	db0f      	blt.n	1014a14 <z_add_timeout+0x54>
		ticks = Z_TICK_ABS(ticks) - (curr_tick + elapsed());
 10149f4:	f7ff ffaa 	bl	101494c <elapsed>
 10149f8:	f06f 0301 	mvn.w	r3, #1
 10149fc:	4a2b      	ldr	r2, [pc, #172]	; (1014aac <z_add_timeout+0xec>)
 10149fe:	e9d2 1c00 	ldrd	r1, ip, [r2]
 1014a02:	1a5b      	subs	r3, r3, r1
 1014a04:	eb6b 020c 	sbc.w	r2, fp, ip
 1014a08:	1b1e      	subs	r6, r3, r4
 1014a0a:	eb62 0705 	sbc.w	r7, r2, r5
 1014a0e:	1a34      	subs	r4, r6, r0
 1014a10:	eb67 75e0 	sbc.w	r5, r7, r0, asr #31
	}
#endif

	__ASSERT(!sys_dnode_is_linked(&to->node), "");
	to->fn = fn;
 1014a14:	9b01      	ldr	r3, [sp, #4]
 1014a16:	f8ca 300c 	str.w	r3, [sl, #12]
	__asm__ volatile(
 1014a1a:	f04f 0320 	mov.w	r3, #32
 1014a1e:	f3ef 8611 	mrs	r6, BASEPRI
 1014a22:	f383 8811 	msr	BASEPRI, r3
 1014a26:	f3bf 8f6f 	isb	sy
	ticks = MAX(1, ticks);

	LOCKED(&timeout_lock) {
		struct _timeout *t;

		to->dticks = ticks + elapsed();
 1014a2a:	f7ff ff8f 	bl	101494c <elapsed>
	ticks = MAX(1, ticks);
 1014a2e:	2c01      	cmp	r4, #1
 1014a30:	f175 0300 	sbcs.w	r3, r5, #0
 1014a34:	bfb8      	it	lt
 1014a36:	2401      	movlt	r4, #1
	return list->head == list;
 1014a38:	4b1d      	ldr	r3, [pc, #116]	; (1014ab0 <z_add_timeout+0xf0>)
		to->dticks = ticks + elapsed();
 1014a3a:	4404      	add	r4, r0
 1014a3c:	681a      	ldr	r2, [r3, #0]
 1014a3e:	f8ca 4008 	str.w	r4, [sl, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1014a42:	429a      	cmp	r2, r3
 1014a44:	d001      	beq.n	1014a4a <z_add_timeout+0x8a>
	return (node != NULL) ? sys_dlist_peek_next_no_check(list, node) : NULL;
 1014a46:	685c      	ldr	r4, [r3, #4]
		for (t = first(); t != NULL; t = next(t)) {
 1014a48:	b952      	cbnz	r2, 1014a60 <z_add_timeout+0xa0>
	node->prev = list->tail;
 1014a4a:	685a      	ldr	r2, [r3, #4]
	node->next = list;
 1014a4c:	f8ca 3000 	str.w	r3, [sl]
	node->prev = list->tail;
 1014a50:	f8ca 2004 	str.w	r2, [sl, #4]
	list->tail->next = node;
 1014a54:	685a      	ldr	r2, [r3, #4]
 1014a56:	f8c2 a000 	str.w	sl, [r2]
	list->tail = node;
 1014a5a:	f8c3 a004 	str.w	sl, [r3, #4]
}
 1014a5e:	e00d      	b.n	1014a7c <z_add_timeout+0xbc>
			__ASSERT(t->dticks >= 0, "");

			if (t->dticks > to->dticks) {
 1014a60:	6890      	ldr	r0, [r2, #8]
 1014a62:	f8da 1008 	ldr.w	r1, [sl, #8]
 1014a66:	4288      	cmp	r0, r1
 1014a68:	dd19      	ble.n	1014a9e <z_add_timeout+0xde>
				t->dticks -= to->dticks;
 1014a6a:	1a41      	subs	r1, r0, r1
 1014a6c:	6091      	str	r1, [r2, #8]
	node->prev = successor->prev;
 1014a6e:	6851      	ldr	r1, [r2, #4]
	node->next = successor;
 1014a70:	e9ca 2100 	strd	r2, r1, [sl]
	successor->prev->next = node;
 1014a74:	f8c1 a000 	str.w	sl, [r1]
	successor->prev = node;
 1014a78:	f8c2 a004 	str.w	sl, [r2, #4]
	return list->head == list;
 1014a7c:	681a      	ldr	r2, [r3, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1014a7e:	429a      	cmp	r2, r3
 1014a80:	d006      	beq.n	1014a90 <z_add_timeout+0xd0>

		if (t == NULL) {
			sys_dlist_append(&timeout_list, &to->node);
		}

		if (to == first()) {
 1014a82:	4592      	cmp	sl, r2
 1014a84:	d104      	bne.n	1014a90 <z_add_timeout+0xd0>
			z_clock_set_timeout(next_timeout(), false);
 1014a86:	f7ff ff7f 	bl	1014988 <next_timeout>
 1014a8a:	2100      	movs	r1, #0
 1014a8c:	f7ef ff86 	bl	100499c <z_clock_set_timeout>
	__asm__ volatile(
 1014a90:	f386 8811 	msr	BASEPRI, r6
 1014a94:	f3bf 8f6f 	isb	sy
		}
	}
}
 1014a98:	b003      	add	sp, #12
 1014a9a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			to->dticks -= t->dticks;
 1014a9e:	1a09      	subs	r1, r1, r0
	return (node == list->tail) ? NULL : node->next;
 1014aa0:	4294      	cmp	r4, r2
 1014aa2:	f8ca 1008 	str.w	r1, [sl, #8]
 1014aa6:	d0d0      	beq.n	1014a4a <z_add_timeout+0x8a>
 1014aa8:	6812      	ldr	r2, [r2, #0]
 1014aaa:	e7cd      	b.n	1014a48 <z_add_timeout+0x88>
 1014aac:	210006d0 	.word	0x210006d0
 1014ab0:	210004a0 	.word	0x210004a0

01014ab4 <z_clock_announce>:
		}
	}
}

void z_clock_announce(s32_t ticks)
{
 1014ab4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1014ab8:	4606      	mov	r6, r0
#ifdef CONFIG_TIMESLICING
	z_time_slice(ticks);
 1014aba:	f7ff fbfd 	bl	10142b8 <z_time_slice>
	__asm__ volatile(
 1014abe:	f04f 0320 	mov.w	r3, #32
 1014ac2:	f3ef 8411 	mrs	r4, BASEPRI
 1014ac6:	f383 8811 	msr	BASEPRI, r3
 1014aca:	f3bf 8f6f 	isb	sy
#endif

	k_spinlock_key_t key = k_spin_lock(&timeout_lock);

	announce_remaining = ticks;
 1014ace:	f8df 8084 	ldr.w	r8, [pc, #132]	; 1014b54 <z_clock_announce+0xa0>
 1014ad2:	4d1f      	ldr	r5, [pc, #124]	; (1014b50 <z_clock_announce+0x9c>)
 1014ad4:	46c1      	mov	r9, r8
	return list->head == list;
 1014ad6:	f8df a080 	ldr.w	sl, [pc, #128]	; 1014b58 <z_clock_announce+0xa4>
 1014ada:	602e      	str	r6, [r5, #0]
 1014adc:	f8da 0000 	ldr.w	r0, [sl]
 1014ae0:	682a      	ldr	r2, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1014ae2:	4550      	cmp	r0, sl
 1014ae4:	e9d8 6700 	ldrd	r6, r7, [r8]
 1014ae8:	d005      	beq.n	1014af6 <z_clock_announce+0x42>

	while (first() != NULL && first()->dticks <= announce_remaining) {
 1014aea:	b120      	cbz	r0, 1014af6 <z_clock_announce+0x42>
 1014aec:	6883      	ldr	r3, [r0, #8]
 1014aee:	4293      	cmp	r3, r2
 1014af0:	dd13      	ble.n	1014b1a <z_clock_announce+0x66>
		t->fn(t);
		key = k_spin_lock(&timeout_lock);
	}

	if (first() != NULL) {
		first()->dticks -= announce_remaining;
 1014af2:	1a9b      	subs	r3, r3, r2
 1014af4:	6083      	str	r3, [r0, #8]
	}

	curr_tick += announce_remaining;
 1014af6:	18b6      	adds	r6, r6, r2
 1014af8:	eb47 77e2 	adc.w	r7, r7, r2, asr #31
 1014afc:	e9c9 6700 	strd	r6, r7, [r9]
	announce_remaining = 0;
 1014b00:	2600      	movs	r6, #0
 1014b02:	602e      	str	r6, [r5, #0]

	z_clock_set_timeout(next_timeout(), false);
 1014b04:	f7ff ff40 	bl	1014988 <next_timeout>
 1014b08:	4631      	mov	r1, r6
 1014b0a:	f7ef ff47 	bl	100499c <z_clock_set_timeout>
	__asm__ volatile(
 1014b0e:	f384 8811 	msr	BASEPRI, r4
 1014b12:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&timeout_lock, key);
}
 1014b16:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		curr_tick += dt;
 1014b1a:	18f6      	adds	r6, r6, r3
 1014b1c:	eb47 77e3 	adc.w	r7, r7, r3, asr #31
		announce_remaining -= dt;
 1014b20:	1ad3      	subs	r3, r2, r3
 1014b22:	602b      	str	r3, [r5, #0]
		t->dticks = 0;
 1014b24:	2300      	movs	r3, #0
 1014b26:	6083      	str	r3, [r0, #8]
		curr_tick += dt;
 1014b28:	e9c8 6700 	strd	r6, r7, [r8]
		remove_timeout(t);
 1014b2c:	f7ff ff18 	bl	1014960 <remove_timeout>
 1014b30:	f384 8811 	msr	BASEPRI, r4
 1014b34:	f3bf 8f6f 	isb	sy
		t->fn(t);
 1014b38:	68c3      	ldr	r3, [r0, #12]
 1014b3a:	4798      	blx	r3
	__asm__ volatile(
 1014b3c:	f04f 0320 	mov.w	r3, #32
 1014b40:	f3ef 8411 	mrs	r4, BASEPRI
 1014b44:	f383 8811 	msr	BASEPRI, r3
 1014b48:	f3bf 8f6f 	isb	sy
#endif

#ifdef CONFIG_SPIN_VALIDATE
	z_spin_lock_set_owner(l);
#endif
	return k;
 1014b4c:	e7c6      	b.n	1014adc <z_clock_announce+0x28>
 1014b4e:	bf00      	nop
 1014b50:	21006680 	.word	0x21006680
 1014b54:	210006d0 	.word	0x210006d0
 1014b58:	210004a0 	.word	0x210004a0

01014b5c <z_tick_get>:

s64_t z_tick_get(void)
{
 1014b5c:	b510      	push	{r4, lr}
 1014b5e:	f04f 0320 	mov.w	r3, #32
 1014b62:	f3ef 8411 	mrs	r4, BASEPRI
 1014b66:	f383 8811 	msr	BASEPRI, r3
 1014b6a:	f3bf 8f6f 	isb	sy
	u64_t t = 0U;

	LOCKED(&timeout_lock) {
		t = curr_tick + z_clock_elapsed();
 1014b6e:	f7ef ff79 	bl	1004a64 <z_clock_elapsed>
 1014b72:	4b06      	ldr	r3, [pc, #24]	; (1014b8c <z_tick_get+0x30>)
 1014b74:	e9d3 2300 	ldrd	r2, r3, [r3]
 1014b78:	1812      	adds	r2, r2, r0
 1014b7a:	f143 0300 	adc.w	r3, r3, #0
	__asm__ volatile(
 1014b7e:	f384 8811 	msr	BASEPRI, r4
 1014b82:	f3bf 8f6f 	isb	sy
	}
	return t;
}
 1014b86:	4610      	mov	r0, r2
 1014b88:	4619      	mov	r1, r3
 1014b8a:	bd10      	pop	{r4, pc}
 1014b8c:	210006d0 	.word	0x210006d0

01014b90 <z_timer_expiration_handler>:
 * @param t  Timeout used by the timer.
 *
 * @return N/A
 */
void z_timer_expiration_handler(struct _timeout *t)
{
 1014b90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

	/*
	 * if the timer is periodic, start it again; don't add _TICK_ALIGN
	 * since we're already aligned to a tick boundary
	 */
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
 1014b92:	e9d0 2308 	ldrd	r2, r3, [r0, #32]
 1014b96:	1c56      	adds	r6, r2, #1
 1014b98:	f143 0700 	adc.w	r7, r3, #0
 1014b9c:	2f00      	cmp	r7, #0
 1014b9e:	bf08      	it	eq
 1014ba0:	2e02      	cmpeq	r6, #2
{
 1014ba2:	4604      	mov	r4, r0
	if (!K_TIMEOUT_EQ(timer->period, K_NO_WAIT) &&
 1014ba4:	d302      	bcc.n	1014bac <z_timer_expiration_handler+0x1c>
	    !K_TIMEOUT_EQ(timer->period, K_FOREVER)) {
		z_add_timeout(&timer->timeout, z_timer_expiration_handler,
 1014ba6:	490c      	ldr	r1, [pc, #48]	; (1014bd8 <z_timer_expiration_handler+0x48>)
 1014ba8:	f7ff ff0a 	bl	10149c0 <z_add_timeout>
			     timer->period);
	}

	/* update timer's status */
	timer->status += 1U;
 1014bac:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1014bae:	3301      	adds	r3, #1
 1014bb0:	62a3      	str	r3, [r4, #40]	; 0x28

	/* invoke timer expiry function */
	if (timer->expiry_fn != NULL) {
 1014bb2:	69a3      	ldr	r3, [r4, #24]
 1014bb4:	b10b      	cbz	r3, 1014bba <z_timer_expiration_handler+0x2a>
		timer->expiry_fn(timer);
 1014bb6:	4620      	mov	r0, r4
 1014bb8:	4798      	blx	r3
	return list->head == list;
 1014bba:	f854 5f10 	ldr.w	r5, [r4, #16]!
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1014bbe:	42a5      	cmp	r5, r4
 1014bc0:	d008      	beq.n	1014bd4 <z_timer_expiration_handler+0x44>
	}

	thread = z_waitq_head(&timer->wait_q);

	if (thread == NULL) {
 1014bc2:	b13d      	cbz	r5, 1014bd4 <z_timer_expiration_handler+0x44>
	 * place a thread can be taken off this pend queue, and b) the
	 * only place a thread can be put on the pend queue is at
	 * thread level, which of course cannot interrupt the current
	 * context.
	 */
	z_unpend_thread_no_timeout(thread);
 1014bc4:	4628      	mov	r0, r5
 1014bc6:	f002 fe6b 	bl	10178a0 <z_unpend_thread_no_timeout>

	z_ready_thread(thread);
 1014bca:	4628      	mov	r0, r5
 1014bcc:	f002 fec9 	bl	1017962 <z_ready_thread>
 1014bd0:	2300      	movs	r3, #0
 1014bd2:	672b      	str	r3, [r5, #112]	; 0x70

	arch_thread_return_value_set(thread, 0);
}
 1014bd4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 1014bd6:	bf00      	nop
 1014bd8:	01014b91 	.word	0x01014b91

01014bdc <z_impl_k_timer_start>:
}


void z_impl_k_timer_start(struct k_timer *timer, k_timeout_t duration,
			  k_timeout_t period)
{
 1014bdc:	e92d 4df3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, sl, fp, lr}
 1014be0:	e9dd 450a 	ldrd	r4, r5, [sp, #40]	; 0x28
	 * for backwards compatibility.  This is unfortunate
	 * (i.e. k_timer_start() doesn't treat its initial sleep
	 * argument the same way k_sleep() does), but historical.  The
	 * timer_api test relies on this behavior.
	 */
	if (period.ticks != 0 && Z_TICK_ABS(period.ticks) < 0) {
 1014be4:	ea54 0105 	orrs.w	r1, r4, r5
{
 1014be8:	4680      	mov	r8, r0
 1014bea:	4616      	mov	r6, r2
 1014bec:	461f      	mov	r7, r3
	if (period.ticks != 0 && Z_TICK_ABS(period.ticks) < 0) {
 1014bee:	d016      	beq.n	1014c1e <z_impl_k_timer_start+0x42>
 1014bf0:	f06f 0101 	mvn.w	r1, #1
 1014bf4:	ebb1 0a04 	subs.w	sl, r1, r4
 1014bf8:	f04f 31ff 	mov.w	r1, #4294967295
 1014bfc:	eb61 0b05 	sbc.w	fp, r1, r5
 1014c00:	f1ba 0f00 	cmp.w	sl, #0
 1014c04:	f17b 0100 	sbcs.w	r1, fp, #0
 1014c08:	da09      	bge.n	1014c1e <z_impl_k_timer_start+0x42>
		period.ticks = MAX(period.ticks - 1, 1);
 1014c0a:	f114 34ff 	adds.w	r4, r4, #4294967295
 1014c0e:	f145 35ff 	adc.w	r5, r5, #4294967295
 1014c12:	2c01      	cmp	r4, #1
 1014c14:	f175 0100 	sbcs.w	r1, r5, #0
 1014c18:	bfbc      	itt	lt
 1014c1a:	2401      	movlt	r4, #1
 1014c1c:	2500      	movlt	r5, #0
	}
	if (Z_TICK_ABS(duration.ticks) < 0) {
 1014c1e:	f06f 0101 	mvn.w	r1, #1
 1014c22:	1a89      	subs	r1, r1, r2
 1014c24:	9100      	str	r1, [sp, #0]
 1014c26:	f04f 31ff 	mov.w	r1, #4294967295
 1014c2a:	eb61 0103 	sbc.w	r1, r1, r3
 1014c2e:	9101      	str	r1, [sp, #4]
 1014c30:	e9dd 0100 	ldrd	r0, r1, [sp]
 1014c34:	2800      	cmp	r0, #0
 1014c36:	f171 0100 	sbcs.w	r1, r1, #0
 1014c3a:	da09      	bge.n	1014c50 <z_impl_k_timer_start+0x74>
		duration.ticks = MAX(duration.ticks - 1, 0);
 1014c3c:	f112 36ff 	adds.w	r6, r2, #4294967295
 1014c40:	f143 37ff 	adc.w	r7, r3, #4294967295
 1014c44:	2e00      	cmp	r6, #0
 1014c46:	f177 0300 	sbcs.w	r3, r7, #0
 1014c4a:	bfbc      	itt	lt
 1014c4c:	2600      	movlt	r6, #0
 1014c4e:	2700      	movlt	r7, #0
	}
#endif

	(void)z_abort_timeout(&timer->timeout);
 1014c50:	4640      	mov	r0, r8
 1014c52:	f002 ffcf 	bl	1017bf4 <z_abort_timeout>
	timer->period = period;
	timer->status = 0U;
 1014c56:	2300      	movs	r3, #0

	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
 1014c58:	4632      	mov	r2, r6
	timer->status = 0U;
 1014c5a:	f8c8 3028 	str.w	r3, [r8, #40]	; 0x28
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
 1014c5e:	4640      	mov	r0, r8
 1014c60:	463b      	mov	r3, r7
 1014c62:	4904      	ldr	r1, [pc, #16]	; (1014c74 <z_impl_k_timer_start+0x98>)
	timer->period = period;
 1014c64:	e9c8 4508 	strd	r4, r5, [r8, #32]
		     duration);
}
 1014c68:	b002      	add	sp, #8
 1014c6a:	e8bd 4df0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, sl, fp, lr}
	z_add_timeout(&timer->timeout, z_timer_expiration_handler,
 1014c6e:	f7ff bea7 	b.w	10149c0 <z_add_timeout>
 1014c72:	bf00      	nop
 1014c74:	01014b91 	.word	0x01014b91

01014c78 <z_impl_k_poll>:
	return 0;
}

int z_impl_k_poll(struct k_poll_event *events, int num_events,
		  k_timeout_t timeout)
{
 1014c78:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 1014c7c:	461f      	mov	r7, r3
	int events_registered;
	k_spinlock_key_t key;
	struct _poller poller = { .is_polling = true,
 1014c7e:	2301      	movs	r3, #1
{
 1014c80:	b089      	sub	sp, #36	; 0x24
	struct _poller poller = { .is_polling = true,
 1014c82:	f88d 3014 	strb.w	r3, [sp, #20]
				  .thread     = _current,
 1014c86:	4b29      	ldr	r3, [pc, #164]	; (1014d2c <z_impl_k_poll+0xb4>)
{
 1014c88:	4616      	mov	r6, r2
	struct _poller poller = { .is_polling = true,
 1014c8a:	689b      	ldr	r3, [r3, #8]
{
 1014c8c:	4605      	mov	r5, r0
	struct _poller poller = { .is_polling = true,
 1014c8e:	9306      	str	r3, [sp, #24]
 1014c90:	4b27      	ldr	r3, [pc, #156]	; (1014d30 <z_impl_k_poll+0xb8>)
 1014c92:	9307      	str	r3, [sp, #28]

	__ASSERT(!arch_is_in_isr(), "");
	__ASSERT(events != NULL, "NULL events\n");
	__ASSERT(num_events >= 0, "<0 events\n");

	events_registered = register_events(events, num_events, &poller,
 1014c94:	ea52 0307 	orrs.w	r3, r2, r7
 1014c98:	bf0c      	ite	eq
 1014c9a:	2301      	moveq	r3, #1
 1014c9c:	2300      	movne	r3, #0
 1014c9e:	aa05      	add	r2, sp, #20
 1014ca0:	f003 f8de 	bl	1017e60 <register_events>
 1014ca4:	4680      	mov	r8, r0
	__asm__ volatile(
 1014ca6:	f04f 0320 	mov.w	r3, #32
 1014caa:	f3ef 8911 	mrs	r9, BASEPRI
 1014cae:	f383 8811 	msr	BASEPRI, r3
 1014cb2:	f3bf 8f6f 	isb	sy
	/*
	 * If we're not polling anymore, it means that at least one event
	 * condition is met, either when looping through the events here or
	 * because one of the events registered has had its state changed.
	 */
	if (!poller.is_polling) {
 1014cb6:	f89d 3014 	ldrb.w	r3, [sp, #20]
 1014cba:	f003 04ff 	and.w	r4, r3, #255	; 0xff
 1014cbe:	b963      	cbnz	r3, 1014cda <z_impl_k_poll+0x62>
		clear_event_registrations(events, events_registered, key);
 1014cc0:	4601      	mov	r1, r0
 1014cc2:	464a      	mov	r2, r9
 1014cc4:	4628      	mov	r0, r5
 1014cc6:	f003 f832 	bl	1017d2e <clear_event_registrations>
	__asm__ volatile(
 1014cca:	f389 8811 	msr	BASEPRI, r9
 1014cce:	f3bf 8f6f 	isb	sy
	key = k_spin_lock(&lock);
	clear_event_registrations(events, events_registered, key);
	k_spin_unlock(&lock, key);

	return swap_rc;
}
 1014cd2:	4620      	mov	r0, r4
 1014cd4:	b009      	add	sp, #36	; 0x24
 1014cd6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	poller.is_polling = false;
 1014cda:	2300      	movs	r3, #0
 1014cdc:	f88d 3014 	strb.w	r3, [sp, #20]
	if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 1014ce0:	ea56 0307 	orrs.w	r3, r6, r7
 1014ce4:	d106      	bne.n	1014cf4 <z_impl_k_poll+0x7c>
 1014ce6:	f389 8811 	msr	BASEPRI, r9
 1014cea:	f3bf 8f6f 	isb	sy
		return -EAGAIN;
 1014cee:	f06f 040a 	mvn.w	r4, #10
 1014cf2:	e7ee      	b.n	1014cd2 <z_impl_k_poll+0x5a>
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
 1014cf4:	aa03      	add	r2, sp, #12
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
 1014cf6:	4649      	mov	r1, r9
 1014cf8:	e9cd 6700 	strd	r6, r7, [sp]
 1014cfc:	480d      	ldr	r0, [pc, #52]	; (1014d34 <z_impl_k_poll+0xbc>)
	_wait_q_t wait_q = Z_WAIT_Q_INIT(&wait_q);
 1014cfe:	e9cd 2203 	strd	r2, r2, [sp, #12]
	int swap_rc = z_pend_curr(&lock, key, &wait_q, timeout);
 1014d02:	f7ff fc0d 	bl	1014520 <z_pend_curr>
 1014d06:	4604      	mov	r4, r0
	__asm__ volatile(
 1014d08:	f04f 0320 	mov.w	r3, #32
 1014d0c:	f3ef 8611 	mrs	r6, BASEPRI
 1014d10:	f383 8811 	msr	BASEPRI, r3
 1014d14:	f3bf 8f6f 	isb	sy
	clear_event_registrations(events, events_registered, key);
 1014d18:	4632      	mov	r2, r6
 1014d1a:	4641      	mov	r1, r8
 1014d1c:	4628      	mov	r0, r5
 1014d1e:	f003 f806 	bl	1017d2e <clear_event_registrations>
	__asm__ volatile(
 1014d22:	f386 8811 	msr	BASEPRI, r6
 1014d26:	f3bf 8f6f 	isb	sy
	return swap_rc;
 1014d2a:	e7d2      	b.n	1014cd2 <z_impl_k_poll+0x5a>
 1014d2c:	210065b8 	.word	0x210065b8
 1014d30:	01017dbb 	.word	0x01017dbb
 1014d34:	210066fd 	.word	0x210066fd

01014d38 <z_impl_k_poll_signal_raise>:
}
#include <syscalls/k_poll_signal_check_mrsh.c>
#endif

int z_impl_k_poll_signal_raise(struct k_poll_signal *signal, int result)
{
 1014d38:	b538      	push	{r3, r4, r5, lr}
 1014d3a:	4603      	mov	r3, r0
	__asm__ volatile(
 1014d3c:	f04f 0220 	mov.w	r2, #32
 1014d40:	f3ef 8511 	mrs	r5, BASEPRI
 1014d44:	f382 8811 	msr	BASEPRI, r2
 1014d48:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&lock);
	struct k_poll_event *poll_event;

	signal->result = result;
 1014d4c:	60c1      	str	r1, [r0, #12]
	signal->signaled = 1U;
 1014d4e:	2101      	movs	r1, #1
 1014d50:	6081      	str	r1, [r0, #8]
	return list->head == list;
 1014d52:	6800      	ldr	r0, [r0, #0]

static inline sys_dnode_t *sys_dlist_get(sys_dlist_t *list)
{
	sys_dnode_t *node = NULL;

	if (!sys_dlist_is_empty(list)) {
 1014d54:	4283      	cmp	r3, r0
 1014d56:	d106      	bne.n	1014d66 <z_impl_k_poll_signal_raise+0x2e>
	__asm__ volatile(
 1014d58:	f385 8811 	msr	BASEPRI, r5
 1014d5c:	f3bf 8f6f 	isb	sy

	poll_event = (struct k_poll_event *)sys_dlist_get(&signal->poll_events);
	if (poll_event == NULL) {
		k_spin_unlock(&lock, key);
		return 0;
 1014d60:	2400      	movs	r4, #0

	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);

	z_reschedule(&lock, key);
	return rc;
}
 1014d62:	4620      	mov	r0, r4
 1014d64:	bd38      	pop	{r3, r4, r5, pc}
	node->prev->next = node->next;
 1014d66:	e9d0 3200 	ldrd	r3, r2, [r0]
 1014d6a:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
 1014d6c:	605a      	str	r2, [r3, #4]
	node->next = NULL;
 1014d6e:	2300      	movs	r3, #0
	node->prev = NULL;
 1014d70:	e9c0 3300 	strd	r3, r3, [r0]
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
 1014d74:	f003 f806 	bl	1017d84 <signal_poll_event>
	z_reschedule(&lock, key);
 1014d78:	4629      	mov	r1, r5
	int rc = signal_poll_event(poll_event, K_POLL_STATE_SIGNALED);
 1014d7a:	4604      	mov	r4, r0
	z_reschedule(&lock, key);
 1014d7c:	4801      	ldr	r0, [pc, #4]	; (1014d84 <z_impl_k_poll_signal_raise+0x4c>)
 1014d7e:	f002 fda8 	bl	10178d2 <z_reschedule>
	return rc;
 1014d82:	e7ee      	b.n	1014d62 <z_impl_k_poll_signal_raise+0x2a>
 1014d84:	210066fd 	.word	0x210066fd

01014d88 <virtio_get_features>:
}
 1014d88:	2001      	movs	r0, #1
 1014d8a:	4770      	bx	lr

01014d8c <rpmsg_service_unbind>:
	rpmsg_destroy_ept(ep);
 1014d8c:	f002 bb00 	b.w	1017390 <rpmsg_destroy_ept>

01014d90 <arch_printk_char_out>:
}
 1014d90:	2000      	movs	r0, #0
 1014d92:	4770      	bx	lr

01014d94 <print_err>:
{
 1014d94:	b570      	push	{r4, r5, r6, lr}
 1014d96:	460d      	mov	r5, r1
 1014d98:	4604      	mov	r4, r0
	out('E', ctx);
 1014d9a:	2045      	movs	r0, #69	; 0x45
 1014d9c:	47a0      	blx	r4
	out('R', ctx);
 1014d9e:	4629      	mov	r1, r5
 1014da0:	2052      	movs	r0, #82	; 0x52
 1014da2:	47a0      	blx	r4
	out('R', ctx);
 1014da4:	4629      	mov	r1, r5
 1014da6:	4623      	mov	r3, r4
}
 1014da8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	out('R', ctx);
 1014dac:	2052      	movs	r0, #82	; 0x52
 1014dae:	4718      	bx	r3

01014db0 <str_out>:
{
 1014db0:	b530      	push	{r4, r5, lr}
 1014db2:	688a      	ldr	r2, [r1, #8]
	if (ctx->str == NULL || ctx->count >= ctx->max) {
 1014db4:	680c      	ldr	r4, [r1, #0]
 1014db6:	1c55      	adds	r5, r2, #1
 1014db8:	b114      	cbz	r4, 1014dc0 <str_out+0x10>
 1014dba:	684b      	ldr	r3, [r1, #4]
 1014dbc:	4293      	cmp	r3, r2
 1014dbe:	dc01      	bgt.n	1014dc4 <str_out+0x14>
		ctx->count++;
 1014dc0:	608d      	str	r5, [r1, #8]
}
 1014dc2:	bd30      	pop	{r4, r5, pc}
	if (ctx->count == ctx->max - 1) {
 1014dc4:	3b01      	subs	r3, #1
 1014dc6:	4293      	cmp	r3, r2
		ctx->str[ctx->count++] = '\0';
 1014dc8:	bf08      	it	eq
 1014dca:	2200      	moveq	r2, #0
 1014dcc:	608d      	str	r5, [r1, #8]
 1014dce:	bf0c      	ite	eq
 1014dd0:	54e2      	strbeq	r2, [r4, r3]
		ctx->str[ctx->count++] = c;
 1014dd2:	54a0      	strbne	r0, [r4, r2]
 1014dd4:	e7f5      	b.n	1014dc2 <str_out+0x12>

01014dd6 <printk>:
{
 1014dd6:	b40f      	push	{r0, r1, r2, r3}
 1014dd8:	b507      	push	{r0, r1, r2, lr}
 1014dda:	a904      	add	r1, sp, #16
 1014ddc:	f851 0b04 	ldr.w	r0, [r1], #4
	va_start(ap, fmt);
 1014de0:	9101      	str	r1, [sp, #4]
		vprintk(fmt, ap);
 1014de2:	f7ee ff35 	bl	1003c50 <vprintk>
}
 1014de6:	b003      	add	sp, #12
 1014de8:	f85d eb04 	ldr.w	lr, [sp], #4
 1014dec:	b004      	add	sp, #16
 1014dee:	4770      	bx	lr

01014df0 <snprintk>:
{
 1014df0:	b40c      	push	{r2, r3}
 1014df2:	b507      	push	{r0, r1, r2, lr}
 1014df4:	ab04      	add	r3, sp, #16
 1014df6:	f853 2b04 	ldr.w	r2, [r3], #4
	va_start(ap, fmt);
 1014dfa:	9301      	str	r3, [sp, #4]
	ret = vsnprintk(str, size, fmt, ap);
 1014dfc:	f7ee ff36 	bl	1003c6c <vsnprintk>
}
 1014e00:	b003      	add	sp, #12
 1014e02:	f85d eb04 	ldr.w	lr, [sp], #4
 1014e06:	b002      	add	sp, #8
 1014e08:	4770      	bx	lr

01014e0a <z_thread_entry>:
 * This routine does not return, and is marked as such so the compiler won't
 * generate preamble code that is only used by functions that actually return.
 */
FUNC_NORETURN void z_thread_entry(k_thread_entry_t entry,
				 void *p1, void *p2, void *p3)
{
 1014e0a:	4604      	mov	r4, r0
 1014e0c:	b508      	push	{r3, lr}
 1014e0e:	4608      	mov	r0, r1
 1014e10:	4611      	mov	r1, r2
	entry(p1, p2, p3);
 1014e12:	461a      	mov	r2, r3
 1014e14:	47a0      	blx	r4
	return z_impl_k_current_get();
 1014e16:	f7ff fc11 	bl	101463c <z_impl_k_current_get>
	z_impl_k_thread_abort(thread);
 1014e1a:	f7f0 fad3 	bl	10053c4 <z_impl_k_thread_abort>

01014e1e <z_work_q_main>:

#include <kernel.h>
#define WORKQUEUE_THREAD_NAME	"workqueue"

void z_work_q_main(void *work_q_ptr, void *p2, void *p3)
{
 1014e1e:	b510      	push	{r4, lr}
 1014e20:	4604      	mov	r4, r0
	return z_impl_k_queue_get(queue, timeout);
 1014e22:	f04f 33ff 	mov.w	r3, #4294967295
 1014e26:	f04f 32ff 	mov.w	r2, #4294967295
 1014e2a:	4620      	mov	r0, r4
 1014e2c:	f7ff f8cc 	bl	1013fc8 <z_impl_k_queue_get>
 1014e30:	4603      	mov	r3, r0
	while (true) {
		struct k_work *work;
		k_work_handler_t handler;

		work = k_queue_get(&work_q->queue, K_FOREVER);
		if (work == NULL) {
 1014e32:	2800      	cmp	r0, #0
 1014e34:	d0f5      	beq.n	1014e22 <z_work_q_main+0x4>
			continue;
		}

		handler = work->handler;
 1014e36:	6842      	ldr	r2, [r0, #4]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 1014e38:	3308      	adds	r3, #8
 1014e3a:	e8d3 1fef 	ldaex	r1, [r3]
 1014e3e:	f021 0c01 	bic.w	ip, r1, #1
 1014e42:	e8c3 cfee 	stlex	lr, ip, [r3]
 1014e46:	f1be 0f00 	cmp.w	lr, #0
 1014e4a:	d1f6      	bne.n	1014e3a <z_work_q_main+0x1c>

		/* Reset pending state so it can be resubmitted by handler */
		if (atomic_test_and_clear_bit(work->flags,
 1014e4c:	07cb      	lsls	r3, r1, #31
 1014e4e:	d500      	bpl.n	1014e52 <z_work_q_main+0x34>
					      K_WORK_STATE_PENDING)) {
			handler(work);
 1014e50:	4790      	blx	r2
	z_impl_k_yield();
 1014e52:	f7ff fb85 	bl	1014560 <z_impl_k_yield>
 1014e56:	e7e4      	b.n	1014e22 <z_work_q_main+0x4>

01014e58 <chunk_field>:
}

static inline size_t chunk_field(struct z_heap *h, chunkid_t c,
				 enum chunk_fields f)
{
	void *cmem = &h->buf[c];
 1014e58:	6803      	ldr	r3, [r0, #0]
 1014e5a:	eb03 01c1 	add.w	r1, r3, r1, lsl #3

	if (big_heap(h)) {
 1014e5e:	6883      	ldr	r3, [r0, #8]
 1014e60:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
		return ((u32_t *)cmem)[f];
 1014e64:	bf2c      	ite	cs
 1014e66:	f851 0022 	ldrcs.w	r0, [r1, r2, lsl #2]
	} else {
		return ((u16_t *)cmem)[f];
 1014e6a:	f831 0012 	ldrhcc.w	r0, [r1, r2, lsl #1]
	}
}
 1014e6e:	4770      	bx	lr

01014e70 <chunk_set>:

static inline void chunk_set(struct z_heap *h, chunkid_t c,
			     enum chunk_fields f, chunkid_t val)
{
 1014e70:	b510      	push	{r4, lr}
	CHECK(c >= h->chunk0 && c < h->len);
	CHECK((val & ~((h->size_mask << 1) + 1)) == 0);
	CHECK((val & h->size_mask) < h->len);

	void *cmem = &h->buf[c];
 1014e72:	6804      	ldr	r4, [r0, #0]

	if (big_heap(h)) {
 1014e74:	6880      	ldr	r0, [r0, #8]
	void *cmem = &h->buf[c];
 1014e76:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
	if (big_heap(h)) {
 1014e7a:	f5b0 4f00 	cmp.w	r0, #32768	; 0x8000
		((u32_t *)cmem)[f] = (u32_t) val;
 1014e7e:	bf2c      	ite	cs
 1014e80:	f841 3022 	strcs.w	r3, [r1, r2, lsl #2]
	} else {
		((u16_t *)cmem)[f] = (u16_t) val;
 1014e84:	f821 3012 	strhcc.w	r3, [r1, r2, lsl #1]
	}
}
 1014e88:	bd10      	pop	{r4, pc}

01014e8a <right_chunk>:
{
	return c - left_size(h, c);
}

static inline chunkid_t right_chunk(struct z_heap *h, chunkid_t c)
{
 1014e8a:	b538      	push	{r3, r4, r5, lr}
 1014e8c:	4605      	mov	r5, r0
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 1014e8e:	2200      	movs	r2, #0
{
 1014e90:	460c      	mov	r4, r1
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 1014e92:	f7ff ffe1 	bl	1014e58 <chunk_field>
 1014e96:	68eb      	ldr	r3, [r5, #12]
 1014e98:	4018      	ands	r0, r3
	return c + size(h, c);
}
 1014e9a:	4420      	add	r0, r4
 1014e9c:	bd38      	pop	{r3, r4, r5, pc}

01014e9e <free_list_remove>:
	return ret;
}

static void free_list_remove(struct z_heap *h, int bidx,
			     chunkid_t c)
{
 1014e9e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct z_heap_bucket *b = &h->buckets[bidx];
 1014ea2:	f8d0 8004 	ldr.w	r8, [r0, #4]
{
 1014ea6:	4616      	mov	r6, r2
	struct z_heap_bucket *b = &h->buckets[bidx];
 1014ea8:	eb08 02c1 	add.w	r2, r8, r1, lsl #3
	CHECK(b->next != 0);
	CHECK(b->list_size > 0);
	CHECK((((h->avail_buckets & (1 << bidx)) == 0)
	       == (h->buckets[bidx].next == 0)));

	b->list_size--;
 1014eac:	6853      	ldr	r3, [r2, #4]
{
 1014eae:	4604      	mov	r4, r0
	b->list_size--;
 1014eb0:	3b01      	subs	r3, #1
{
 1014eb2:	460d      	mov	r5, r1
	b->list_size--;
 1014eb4:	6053      	str	r3, [r2, #4]

	if (b->list_size == 0) {
 1014eb6:	b953      	cbnz	r3, 1014ece <free_list_remove+0x30>
		h->avail_buckets &= ~(1 << bidx);
 1014eb8:	2201      	movs	r2, #1
 1014eba:	fa02 f101 	lsl.w	r1, r2, r1
 1014ebe:	6942      	ldr	r2, [r0, #20]
 1014ec0:	ea22 0201 	bic.w	r2, r2, r1
 1014ec4:	6142      	str	r2, [r0, #20]
		b->next = 0;
 1014ec6:	f848 3035 	str.w	r3, [r8, r5, lsl #3]

		b->next = second;
		chunk_set(h, first, FREE_NEXT, second);
		chunk_set(h, second, FREE_PREV, first);
	}
}
 1014eca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
	return chunk_field(h, c, FREE_PREV);
 1014ece:	4631      	mov	r1, r6
 1014ed0:	2202      	movs	r2, #2
 1014ed2:	f7ff ffc1 	bl	1014e58 <chunk_field>
	return chunk_field(h, c, FREE_NEXT);
 1014ed6:	4631      	mov	r1, r6
	return chunk_field(h, c, FREE_PREV);
 1014ed8:	4607      	mov	r7, r0
	return chunk_field(h, c, FREE_NEXT);
 1014eda:	2203      	movs	r2, #3
 1014edc:	4620      	mov	r0, r4
 1014ede:	f7ff ffbb 	bl	1014e58 <chunk_field>
 1014ee2:	4606      	mov	r6, r0
		chunk_set(h, first, FREE_NEXT, second);
 1014ee4:	4603      	mov	r3, r0
 1014ee6:	4639      	mov	r1, r7
		b->next = second;
 1014ee8:	f848 0035 	str.w	r0, [r8, r5, lsl #3]
		chunk_set(h, first, FREE_NEXT, second);
 1014eec:	2203      	movs	r2, #3
 1014eee:	4620      	mov	r0, r4
 1014ef0:	f7ff ffbe 	bl	1014e70 <chunk_set>
		chunk_set(h, second, FREE_PREV, first);
 1014ef4:	463b      	mov	r3, r7
 1014ef6:	4631      	mov	r1, r6
 1014ef8:	4620      	mov	r0, r4
}
 1014efa:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		chunk_set(h, second, FREE_PREV, first);
 1014efe:	2202      	movs	r2, #2
 1014f00:	f7ff bfb6 	b.w	1014e70 <chunk_set>

01014f04 <free_list_add>:

static void free_list_add(struct z_heap *h, chunkid_t c)
{
 1014f04:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 1014f08:	4604      	mov	r4, r0
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 1014f0a:	2200      	movs	r2, #0
 1014f0c:	460d      	mov	r5, r1
 1014f0e:	f7ff ffa3 	bl	1014e58 <chunk_field>
 1014f12:	68e2      	ldr	r2, [r4, #12]
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 1014f14:	68a3      	ldr	r3, [r4, #8]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 1014f16:	4010      	ands	r0, r2
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 1014f18:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
}

static int bucket_idx(struct z_heap *h, size_t sz)
{
	/* A chunk of size 2 is the minimum size on big heaps */
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
 1014f1c:	fab0 f280 	clz	r2, r0
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 1014f20:	bf34      	ite	cc
 1014f22:	2000      	movcc	r0, #0
 1014f24:	2001      	movcs	r0, #1
	int b = bucket_idx(h, size(h, c));

	if (h->buckets[b].list_size++ == 0) {
 1014f26:	6863      	ldr	r3, [r4, #4]
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
 1014f28:	f1c0 001f 	rsb	r0, r0, #31
 1014f2c:	1a80      	subs	r0, r0, r2
 1014f2e:	eb03 01c0 	add.w	r1, r3, r0, lsl #3
 1014f32:	684a      	ldr	r2, [r1, #4]
 1014f34:	1c56      	adds	r6, r2, #1
 1014f36:	604e      	str	r6, [r1, #4]
 1014f38:	b9a2      	cbnz	r2, 1014f64 <free_list_add+0x60>
		CHECK(h->buckets[b].next == 0);
		CHECK((h->avail_buckets & (1 << b)) == 0);

		/* Empty list, first item */
		h->avail_buckets |= (1 << b);
 1014f3a:	2201      	movs	r2, #1
 1014f3c:	fa02 f100 	lsl.w	r1, r2, r0
 1014f40:	6962      	ldr	r2, [r4, #20]
 1014f42:	430a      	orrs	r2, r1
 1014f44:	6162      	str	r2, [r4, #20]
		h->buckets[b].next = c;
		chunk_set(h, c, FREE_PREV, c);
 1014f46:	4629      	mov	r1, r5
		h->buckets[b].next = c;
 1014f48:	f843 5030 	str.w	r5, [r3, r0, lsl #3]
		chunk_set(h, c, FREE_PREV, c);
 1014f4c:	2202      	movs	r2, #2
 1014f4e:	462b      	mov	r3, r5
 1014f50:	4620      	mov	r0, r4
 1014f52:	f7ff ff8d 	bl	1014e70 <chunk_set>
		chunk_set(h, c, FREE_NEXT, c);
 1014f56:	2203      	movs	r2, #3
 1014f58:	4629      	mov	r1, r5
		chunkid_t first = free_prev(h, second);

		chunk_set(h, c, FREE_PREV, first);
		chunk_set(h, c, FREE_NEXT, second);
		chunk_set(h, first, FREE_NEXT, c);
		chunk_set(h, second, FREE_PREV, c);
 1014f5a:	4620      	mov	r0, r4
	}

	CHECK(h->avail_buckets & (1 << bucket_idx(h, size(h, c))));
}
 1014f5c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		chunk_set(h, second, FREE_PREV, c);
 1014f60:	f7ff bf86 	b.w	1014e70 <chunk_set>
		chunkid_t second = h->buckets[b].next;
 1014f64:	f853 7030 	ldr.w	r7, [r3, r0, lsl #3]
	return chunk_field(h, c, FREE_PREV);
 1014f68:	2202      	movs	r2, #2
 1014f6a:	4639      	mov	r1, r7
 1014f6c:	4620      	mov	r0, r4
 1014f6e:	f7ff ff73 	bl	1014e58 <chunk_field>
 1014f72:	4606      	mov	r6, r0
		chunk_set(h, c, FREE_PREV, first);
 1014f74:	4603      	mov	r3, r0
 1014f76:	2202      	movs	r2, #2
 1014f78:	4629      	mov	r1, r5
 1014f7a:	4620      	mov	r0, r4
 1014f7c:	f7ff ff78 	bl	1014e70 <chunk_set>
		chunk_set(h, c, FREE_NEXT, second);
 1014f80:	463b      	mov	r3, r7
 1014f82:	2203      	movs	r2, #3
 1014f84:	4629      	mov	r1, r5
 1014f86:	4620      	mov	r0, r4
 1014f88:	f7ff ff72 	bl	1014e70 <chunk_set>
		chunk_set(h, first, FREE_NEXT, c);
 1014f8c:	2203      	movs	r2, #3
 1014f8e:	4631      	mov	r1, r6
 1014f90:	462b      	mov	r3, r5
 1014f92:	4620      	mov	r0, r4
 1014f94:	f7ff ff6c 	bl	1014e70 <chunk_set>
		chunk_set(h, second, FREE_PREV, c);
 1014f98:	2202      	movs	r2, #2
 1014f9a:	4639      	mov	r1, r7
 1014f9c:	e7dd      	b.n	1014f5a <free_list_add+0x56>

01014f9e <split_alloc>:

/* Allocates (fit check has already been perfomred) from the next
 * chunk at the specified bucket level
 */
static void *split_alloc(struct z_heap *h, int bidx, size_t sz)
{
 1014f9e:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1014fa2:	4604      	mov	r4, r0
	CHECK(h->buckets[bidx].next != 0
	      && sz <= size(h, h->buckets[bidx].next));

	chunkid_t c = h->buckets[bidx].next;
 1014fa4:	6843      	ldr	r3, [r0, #4]
{
 1014fa6:	4617      	mov	r7, r2
	chunkid_t c = h->buckets[bidx].next;
 1014fa8:	f853 5031 	ldr.w	r5, [r3, r1, lsl #3]

	free_list_remove(h, bidx, c);
 1014fac:	462a      	mov	r2, r5
 1014fae:	f7ff ff76 	bl	1014e9e <free_list_remove>
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 1014fb2:	2200      	movs	r2, #0
 1014fb4:	4629      	mov	r1, r5
 1014fb6:	4620      	mov	r0, r4
 1014fb8:	f7ff ff4e 	bl	1014e58 <chunk_field>
	/* Split off remainder if it's usefully large */
	size_t rem = size(h, c) - sz;

	CHECK(rem < h->len);

	if (rem >= (big_heap(h) ? 2 : 1)) {
 1014fbc:	68a3      	ldr	r3, [r4, #8]
 1014fbe:	68e6      	ldr	r6, [r4, #12]
 1014fc0:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 1014fc4:	bf2c      	ite	cs
 1014fc6:	2302      	movcs	r3, #2
 1014fc8:	2301      	movcc	r3, #1
 1014fca:	4006      	ands	r6, r0
	size_t rem = size(h, c) - sz;
 1014fcc:	1bf6      	subs	r6, r6, r7
	if (rem >= (big_heap(h) ? 2 : 1)) {
 1014fce:	42b3      	cmp	r3, r6
 1014fd0:	d82d      	bhi.n	101502e <split_alloc+0x90>
		chunkid_t c2 = c + sz;
		chunkid_t c3 = right_chunk(h, c);
 1014fd2:	4629      	mov	r1, r5
 1014fd4:	4620      	mov	r0, r4
 1014fd6:	f7ff ff58 	bl	1014e8a <right_chunk>
		chunkid_t c2 = c + sz;
 1014fda:	eb05 0807 	add.w	r8, r5, r7

		chunk_set(h, c, SIZE_AND_USED, sz);
 1014fde:	463b      	mov	r3, r7
 1014fe0:	2200      	movs	r2, #0
 1014fe2:	4629      	mov	r1, r5
		chunkid_t c3 = right_chunk(h, c);
 1014fe4:	4681      	mov	r9, r0
		chunk_set(h, c, SIZE_AND_USED, sz);
 1014fe6:	4620      	mov	r0, r4
 1014fe8:	f7ff ff42 	bl	1014e70 <chunk_set>
		chunk_set(h, c2, SIZE_AND_USED, rem);
 1014fec:	4633      	mov	r3, r6
 1014fee:	2200      	movs	r2, #0
 1014ff0:	4641      	mov	r1, r8
 1014ff2:	4620      	mov	r0, r4
 1014ff4:	f7ff ff3c 	bl	1014e70 <chunk_set>
		chunk_set(h, c2, LEFT_SIZE, sz);
 1014ff8:	463b      	mov	r3, r7
 1014ffa:	2201      	movs	r2, #1
 1014ffc:	4641      	mov	r1, r8
 1014ffe:	4620      	mov	r0, r4
 1015000:	f7ff ff36 	bl	1014e70 <chunk_set>
 1015004:	2200      	movs	r2, #0
 1015006:	4641      	mov	r1, r8
 1015008:	4620      	mov	r0, r4
 101500a:	f7ff ff25 	bl	1014e58 <chunk_field>
 101500e:	68e3      	ldr	r3, [r4, #12]
		if (!last_chunk(h, c2)) {
 1015010:	68a2      	ldr	r2, [r4, #8]
 1015012:	4003      	ands	r3, r0
	return (c + size(h, c)) == h->len;
 1015014:	4443      	add	r3, r8
		if (!last_chunk(h, c2)) {
 1015016:	4293      	cmp	r3, r2
 1015018:	d005      	beq.n	1015026 <split_alloc+0x88>
			chunk_set(h, c3, LEFT_SIZE, rem);
 101501a:	4633      	mov	r3, r6
 101501c:	2201      	movs	r2, #1
 101501e:	4649      	mov	r1, r9
 1015020:	4620      	mov	r0, r4
 1015022:	f7ff ff25 	bl	1014e70 <chunk_set>
		}
		free_list_add(h, c2);
 1015026:	4641      	mov	r1, r8
 1015028:	4620      	mov	r0, r4
 101502a:	f7ff ff6b 	bl	1014f04 <free_list_add>
 101502e:	4629      	mov	r1, r5
 1015030:	2200      	movs	r2, #0
 1015032:	4620      	mov	r0, r4
 1015034:	f7ff ff10 	bl	1014e58 <chunk_field>
 1015038:	68e2      	ldr	r2, [r4, #12]
	chunk_set(h, c, SIZE_AND_USED,
 101503a:	4629      	mov	r1, r5
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 101503c:	ea00 0302 	and.w	r3, r0, r2
		  size(h, c) | (used ? (h->size_mask + 1) : 0));
 1015040:	3201      	adds	r2, #1
	chunk_set(h, c, SIZE_AND_USED,
 1015042:	4620      	mov	r0, r4
 1015044:	4313      	orrs	r3, r2
 1015046:	2200      	movs	r2, #0
 1015048:	f7ff ff12 	bl	1014e70 <chunk_set>
	return big_heap(h) ? 8 : 4;
 101504c:	68a3      	ldr	r3, [r4, #8]
	u8_t *ret = ((u8_t *)&h->buf[c]) + chunk_header_bytes(h);
 101504e:	6820      	ldr	r0, [r4, #0]
 1015050:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 1015054:	bf2c      	ite	cs
 1015056:	2308      	movcs	r3, #8
 1015058:	2304      	movcc	r3, #4
 101505a:	eb03 05c5 	add.w	r5, r3, r5, lsl #3
	}

	chunk_set_used(h, c, true);

	return chunk_mem(h, c);
}
 101505e:	4428      	add	r0, r5
 1015060:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

01015064 <sys_heap_free>:

void sys_heap_free(struct sys_heap *heap, void *mem)
{
 1015064:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	if (mem == NULL) {
 1015068:	2900      	cmp	r1, #0
 101506a:	f000 80ac 	beq.w	10151c6 <sys_heap_free+0x162>
		return; /* ISO C free() semantics */
	}

	struct z_heap *h = heap->heap;
 101506e:	6804      	ldr	r4, [r0, #0]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 1015070:	2200      	movs	r2, #0
	return big_heap(h) ? 8 : 4;
 1015072:	68a7      	ldr	r7, [r4, #8]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 1015074:	4620      	mov	r0, r4
	return big_heap(h) ? 8 : 4;
 1015076:	f5b7 4f00 	cmp.w	r7, #32768	; 0x8000
 101507a:	bf2c      	ite	cs
 101507c:	2508      	movcs	r5, #8
 101507e:	2504      	movcc	r5, #4
	chunkid_t c = ((u8_t *)mem - chunk_header_bytes(h)
 1015080:	1b4d      	subs	r5, r1, r5
		       - (u8_t *)h->buf) / CHUNK_UNIT;
 1015082:	6821      	ldr	r1, [r4, #0]
 1015084:	1a6d      	subs	r5, r5, r1
 1015086:	bf48      	it	mi
 1015088:	3507      	addmi	r5, #7
 101508a:	10ed      	asrs	r5, r5, #3
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 101508c:	4629      	mov	r1, r5
 101508e:	f7ff fee3 	bl	1014e58 <chunk_field>
 1015092:	68e6      	ldr	r6, [r4, #12]
 1015094:	ea06 0800 	and.w	r8, r6, r0
	return (c + size(h, c)) == h->len;
 1015098:	eb05 0308 	add.w	r3, r5, r8

	/* Merge with right chunk?  We can just absorb it. */
	if (!last_chunk(h, c) && !used(h, right_chunk(h, c))) {
 101509c:	42bb      	cmp	r3, r7
 101509e:	d036      	beq.n	101510e <sys_heap_free+0xaa>
 10150a0:	4629      	mov	r1, r5
 10150a2:	4620      	mov	r0, r4
 10150a4:	f7ff fef1 	bl	1014e8a <right_chunk>
	return (chunk_field(h, c, SIZE_AND_USED) & ~h->size_mask) != 0;
 10150a8:	2200      	movs	r2, #0
 10150aa:	4601      	mov	r1, r0
 10150ac:	4682      	mov	sl, r0
 10150ae:	4620      	mov	r0, r4
 10150b0:	f7ff fed2 	bl	1014e58 <chunk_field>
 10150b4:	ea30 0906 	bics.w	r9, r0, r6
 10150b8:	d129      	bne.n	101510e <sys_heap_free+0xaa>
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 10150ba:	f5b7 4f00 	cmp.w	r7, #32768	; 0x8000
 10150be:	bf34      	ite	cc
 10150c0:	2700      	movcc	r7, #0
 10150c2:	2701      	movcs	r7, #1
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 10150c4:	4006      	ands	r6, r0
		chunkid_t rc = right_chunk(h, c);
		size_t newsz = size(h, c) + size(h, rc);
 10150c6:	44b0      	add	r8, r6
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
 10150c8:	fab6 f686 	clz	r6, r6
 10150cc:	f1c7 071f 	rsb	r7, r7, #31

		free_list_remove(h, bucket_idx(h, size(h, rc)), rc);
 10150d0:	4652      	mov	r2, sl
 10150d2:	4620      	mov	r0, r4
 10150d4:	1bb9      	subs	r1, r7, r6
 10150d6:	f7ff fee2 	bl	1014e9e <free_list_remove>
		chunk_set(h, c, SIZE_AND_USED, newsz);
 10150da:	4643      	mov	r3, r8
 10150dc:	464a      	mov	r2, r9
 10150de:	4629      	mov	r1, r5
 10150e0:	4620      	mov	r0, r4
 10150e2:	f7ff fec5 	bl	1014e70 <chunk_set>
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 10150e6:	4629      	mov	r1, r5
 10150e8:	4620      	mov	r0, r4
 10150ea:	f7ff feb5 	bl	1014e58 <chunk_field>
 10150ee:	68e3      	ldr	r3, [r4, #12]
 10150f0:	4018      	ands	r0, r3
		if (!last_chunk(h, c)) {
 10150f2:	68a3      	ldr	r3, [r4, #8]
	return (c + size(h, c)) == h->len;
 10150f4:	4428      	add	r0, r5
		if (!last_chunk(h, c)) {
 10150f6:	4283      	cmp	r3, r0
 10150f8:	d009      	beq.n	101510e <sys_heap_free+0xaa>
			chunk_set(h, right_chunk(h, c), LEFT_SIZE, newsz);
 10150fa:	4629      	mov	r1, r5
 10150fc:	4620      	mov	r0, r4
 10150fe:	f7ff fec4 	bl	1014e8a <right_chunk>
 1015102:	4643      	mov	r3, r8
 1015104:	4601      	mov	r1, r0
 1015106:	2201      	movs	r2, #1
 1015108:	4620      	mov	r0, r4
 101510a:	f7ff feb1 	bl	1014e70 <chunk_set>
		}
	}

	/* Merge with left chunk?  It absorbs us. */
	if (c != h->chunk0 && !used(h, left_chunk(h, c))) {
 101510e:	6923      	ldr	r3, [r4, #16]
 1015110:	42ab      	cmp	r3, r5
 1015112:	d046      	beq.n	10151a2 <sys_heap_free+0x13e>
	return chunk_field(h, c, LEFT_SIZE);
 1015114:	2201      	movs	r2, #1
 1015116:	4629      	mov	r1, r5
 1015118:	4620      	mov	r0, r4
 101511a:	f7ff fe9d 	bl	1014e58 <chunk_field>
	return c - left_size(h, c);
 101511e:	1a2f      	subs	r7, r5, r0
	return (chunk_field(h, c, SIZE_AND_USED) & ~h->size_mask) != 0;
 1015120:	2200      	movs	r2, #0
 1015122:	4639      	mov	r1, r7
 1015124:	4620      	mov	r0, r4
 1015126:	f7ff fe97 	bl	1014e58 <chunk_field>
 101512a:	f8d4 800c 	ldr.w	r8, [r4, #12]
 101512e:	4606      	mov	r6, r0
 1015130:	ea30 0908 	bics.w	r9, r0, r8
 1015134:	d135      	bne.n	10151a2 <sys_heap_free+0x13e>
 1015136:	464a      	mov	r2, r9
 1015138:	4629      	mov	r1, r5
 101513a:	4620      	mov	r0, r4
 101513c:	f7ff fe8c 	bl	1014e58 <chunk_field>
 1015140:	4682      	mov	sl, r0
		chunkid_t lc = left_chunk(h, c);
		chunkid_t rc = right_chunk(h, c);
 1015142:	4629      	mov	r1, r5
 1015144:	4620      	mov	r0, r4
 1015146:	f7ff fea0 	bl	1014e8a <right_chunk>
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 101514a:	68a1      	ldr	r1, [r4, #8]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 101514c:	ea06 0608 	and.w	r6, r6, r8
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 1015150:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 1015154:	bf34      	ite	cc
 1015156:	2100      	movcc	r1, #0
 1015158:	2101      	movcs	r1, #1
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 101515a:	ea08 080a 	and.w	r8, r8, sl
		size_t csz = size(h, c);
		size_t merged_sz = csz + size(h, lc);
 101515e:	44b0      	add	r8, r6
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
 1015160:	fab6 f686 	clz	r6, r6
 1015164:	f1c1 011f 	rsb	r1, r1, #31

		free_list_remove(h, bucket_idx(h, size(h, lc)), lc);
 1015168:	463a      	mov	r2, r7
 101516a:	1b89      	subs	r1, r1, r6
		chunkid_t rc = right_chunk(h, c);
 101516c:	4605      	mov	r5, r0
		free_list_remove(h, bucket_idx(h, size(h, lc)), lc);
 101516e:	4620      	mov	r0, r4
 1015170:	f7ff fe95 	bl	1014e9e <free_list_remove>
		chunk_set(h, lc, SIZE_AND_USED, merged_sz);
 1015174:	4643      	mov	r3, r8
 1015176:	464a      	mov	r2, r9
 1015178:	4639      	mov	r1, r7
 101517a:	4620      	mov	r0, r4
 101517c:	f7ff fe78 	bl	1014e70 <chunk_set>
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 1015180:	4639      	mov	r1, r7
 1015182:	4620      	mov	r0, r4
 1015184:	f7ff fe68 	bl	1014e58 <chunk_field>
 1015188:	68e3      	ldr	r3, [r4, #12]
 101518a:	4018      	ands	r0, r3
		if (!last_chunk(h, lc)) {
 101518c:	68a3      	ldr	r3, [r4, #8]
	return (c + size(h, c)) == h->len;
 101518e:	4438      	add	r0, r7
		if (!last_chunk(h, lc)) {
 1015190:	4298      	cmp	r0, r3
 1015192:	d005      	beq.n	10151a0 <sys_heap_free+0x13c>
			chunk_set(h, rc, LEFT_SIZE, merged_sz);
 1015194:	4643      	mov	r3, r8
 1015196:	2201      	movs	r2, #1
 1015198:	4629      	mov	r1, r5
 101519a:	4620      	mov	r0, r4
 101519c:	f7ff fe68 	bl	1014e70 <chunk_set>
		}

		c = lc;
 10151a0:	463d      	mov	r5, r7
 10151a2:	4629      	mov	r1, r5
 10151a4:	2200      	movs	r2, #0
 10151a6:	4620      	mov	r0, r4
 10151a8:	f7ff fe56 	bl	1014e58 <chunk_field>
 10151ac:	68e3      	ldr	r3, [r4, #12]
	chunk_set(h, c, SIZE_AND_USED,
 10151ae:	4629      	mov	r1, r5
 10151b0:	4003      	ands	r3, r0
 10151b2:	2200      	movs	r2, #0
 10151b4:	4620      	mov	r0, r4
 10151b6:	f7ff fe5b 	bl	1014e70 <chunk_set>
	}

	chunk_set_used(h, c, false);
	free_list_add(h, c);
 10151ba:	4629      	mov	r1, r5
 10151bc:	4620      	mov	r0, r4
}
 10151be:	e8bd 47f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	free_list_add(h, c);
 10151c2:	f7ff be9f 	b.w	1014f04 <free_list_add>
}
 10151c6:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

010151ca <sys_heap_alloc>:

void *sys_heap_alloc(struct sys_heap *heap, size_t bytes)
{
 10151ca:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	struct z_heap *h = heap->heap;
 10151ce:	6804      	ldr	r4, [r0, #0]
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
 10151d0:	1dcd      	adds	r5, r1, #7
	return big_heap(h) ? 8 : 4;
 10151d2:	68a2      	ldr	r2, [r4, #8]
 10151d4:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
 10151d8:	bf2c      	ite	cs
 10151da:	2308      	movcs	r3, #8
 10151dc:	2304      	movcc	r3, #4
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
 10151de:	441d      	add	r5, r3
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 10151e0:	f5b2 4f00 	cmp.w	r2, #32768	; 0x8000
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
 10151e4:	ea4f 05d5 	mov.w	r5, r5, lsr #3
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
 10151e8:	fab5 f685 	clz	r6, r5
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 10151ec:	bf34      	ite	cc
 10151ee:	2300      	movcc	r3, #0
 10151f0:	2301      	movcs	r3, #1
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
 10151f2:	441e      	add	r6, r3
 10151f4:	f1c6 081f 	rsb	r8, r6, #31
	size_t sz = bytes_to_chunksz(h, bytes);
	int bi = bucket_idx(h, sz);
	struct z_heap_bucket *b = &h->buckets[bi];

	if (bytes == 0 || bi > bucket_idx(h, h->len)) {
 10151f8:	2900      	cmp	r1, #0
 10151fa:	d03b      	beq.n	1015274 <sys_heap_alloc+0xaa>
 10151fc:	fab2 f282 	clz	r2, r2
 1015200:	f1c3 031f 	rsb	r3, r3, #31
 1015204:	1a9b      	subs	r3, r3, r2
 1015206:	4598      	cmp	r8, r3
 1015208:	dc34      	bgt.n	1015274 <sys_heap_alloc+0xaa>
	struct z_heap_bucket *b = &h->buckets[bi];
 101520a:	6867      	ldr	r7, [r4, #4]
	 * fragmentation waste of the order of the block allocated
	 * only.
	 */
	int loops = MIN(b->list_size, CONFIG_SYS_HEAP_ALLOC_LOOPS);

	for (int i = 0; i < loops; i++) {
 101520c:	f04f 0a00 	mov.w	sl, #0
	struct z_heap_bucket *b = &h->buckets[bi];
 1015210:	eb07 07c8 	add.w	r7, r7, r8, lsl #3
	int loops = MIN(b->list_size, CONFIG_SYS_HEAP_ALLOC_LOOPS);
 1015214:	687b      	ldr	r3, [r7, #4]
 1015216:	2b03      	cmp	r3, #3
 1015218:	bf28      	it	cs
 101521a:	2303      	movcs	r3, #3
 101521c:	4699      	mov	r9, r3
	for (int i = 0; i < loops; i++) {
 101521e:	45ca      	cmp	sl, r9
 1015220:	db0d      	blt.n	101523e <sys_heap_alloc+0x74>
	}

	/* Otherwise pick the smallest non-empty bucket guaranteed to
	 * fit and use that unconditionally.
	 */
	size_t bmask = h->avail_buckets & ~((1 << (bi + 1)) - 1);
 1015222:	f04f 31ff 	mov.w	r1, #4294967295
 1015226:	6963      	ldr	r3, [r4, #20]
 1015228:	f1c6 0620 	rsb	r6, r6, #32
 101522c:	40b1      	lsls	r1, r6

	if ((bmask & h->avail_buckets) != 0) {
 101522e:	4019      	ands	r1, r3
 1015230:	d020      	beq.n	1015274 <sys_heap_alloc+0xaa>
		int minbucket = __builtin_ctz(bmask & h->avail_buckets);

		return split_alloc(h, minbucket, sz);
 1015232:	fa91 f1a1 	rbit	r1, r1
 1015236:	462a      	mov	r2, r5
 1015238:	fab1 f181 	clz	r1, r1
 101523c:	e00c      	b.n	1015258 <sys_heap_alloc+0x8e>
		if (size(h, b->next) >= sz) {
 101523e:	f8d7 b000 	ldr.w	fp, [r7]
	return chunk_field(h, c, SIZE_AND_USED) & h->size_mask;
 1015242:	2200      	movs	r2, #0
 1015244:	4659      	mov	r1, fp
 1015246:	4620      	mov	r0, r4
 1015248:	f7ff fe06 	bl	1014e58 <chunk_field>
 101524c:	68e3      	ldr	r3, [r4, #12]
 101524e:	4018      	ands	r0, r3
 1015250:	42a8      	cmp	r0, r5
 1015252:	d306      	bcc.n	1015262 <sys_heap_alloc+0x98>
			return split_alloc(h, bi, sz);
 1015254:	462a      	mov	r2, r5
 1015256:	4641      	mov	r1, r8
		return split_alloc(h, minbucket, sz);
 1015258:	4620      	mov	r0, r4
	}

	return NULL;
}
 101525a:	e8bd 4ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
		return split_alloc(h, minbucket, sz);
 101525e:	f7ff be9e 	b.w	1014f9e <split_alloc>
	return chunk_field(h, c, FREE_NEXT);
 1015262:	2203      	movs	r2, #3
 1015264:	4659      	mov	r1, fp
 1015266:	4620      	mov	r0, r4
 1015268:	f7ff fdf6 	bl	1014e58 <chunk_field>
	for (int i = 0; i < loops; i++) {
 101526c:	f10a 0a01 	add.w	sl, sl, #1
		b->next = free_next(h, b->next);
 1015270:	6038      	str	r0, [r7, #0]
	for (int i = 0; i < loops; i++) {
 1015272:	e7d4      	b.n	101521e <sys_heap_alloc+0x54>
}
 1015274:	2000      	movs	r0, #0
 1015276:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}

0101527a <sys_heap_init>:

void sys_heap_init(struct sys_heap *heap, void *mem, size_t bytes)
{
 101527a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	CHECK(bytes < 0x800000000ULL);
#endif

	/* Round the start up, the end down */
	size_t addr = ((size_t)mem + CHUNK_UNIT - 1) & ~(CHUNK_UNIT - 1);
	size_t end = ((size_t)mem + bytes) & ~(CHUNK_UNIT - 1);
 101527c:	188b      	adds	r3, r1, r2

	heap->heap = (struct z_heap *)addr;
	h->buf = (u64_t *)addr;
	h->buckets = (void *)(addr + CHUNK_UNIT * hdr_chunks);
	h->len = buf_sz;
	h->size_mask = (1 << (big_heap(h) ? 31 : 15)) - 1;
 101527e:	f647 72ff 	movw	r2, #32767	; 0x7fff
	size_t addr = ((size_t)mem + CHUNK_UNIT - 1) & ~(CHUNK_UNIT - 1);
 1015282:	1dcc      	adds	r4, r1, #7
 1015284:	f024 0407 	bic.w	r4, r4, #7
	size_t end = ((size_t)mem + bytes) & ~(CHUNK_UNIT - 1);
 1015288:	f023 0307 	bic.w	r3, r3, #7
	size_t buf_sz = (end - addr) / CHUNK_UNIT;
 101528c:	1b1b      	subs	r3, r3, r4
 101528e:	08db      	lsrs	r3, r3, #3
	h->size_mask = (1 << (big_heap(h) ? 31 : 15)) - 1;
 1015290:	f5b3 4f00 	cmp.w	r3, #32768	; 0x8000
 1015294:	bf2c      	ite	cs
 1015296:	f06f 4100 	mvncs.w	r1, #2147483648	; 0x80000000
 101529a:	4611      	movcc	r1, r2
	heap->heap = (struct z_heap *)addr;
 101529c:	6004      	str	r4, [r0, #0]
	h->avail_buckets = 0;
 101529e:	2000      	movs	r0, #0
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 10152a0:	4293      	cmp	r3, r2
	h->size_mask = (1 << (big_heap(h) ? 31 : 15)) - 1;
 10152a2:	60e1      	str	r1, [r4, #12]
 10152a4:	bf94      	ite	ls
 10152a6:	2100      	movls	r1, #0
 10152a8:	2101      	movhi	r1, #1
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
 10152aa:	fab3 f683 	clz	r6, r3
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 10152ae:	4617      	mov	r7, r2
				* sizeof(struct z_heap_bucket));

	h->chunk0 = hdr_chunks + chunksz(buckets_bytes);

	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
		heap->heap->buckets[i].list_size = 0;
 10152b0:	4684      	mov	ip, r0
	size_t buckets_bytes = ((bucket_idx(h, buf_sz) + 1)
 10152b2:	f1c1 0120 	rsb	r1, r1, #32
	h->buckets = (void *)(addr + CHUNK_UNIT * hdr_chunks);
 10152b6:	f104 0518 	add.w	r5, r4, #24
	size_t buckets_bytes = ((bucket_idx(h, buf_sz) + 1)
 10152ba:	1b89      	subs	r1, r1, r6
	return (bytes + CHUNK_UNIT - 1) / CHUNK_UNIT;
 10152bc:	f021 4160 	bic.w	r1, r1, #3758096384	; 0xe0000000
	h->len = buf_sz;
 10152c0:	e9c4 5301 	strd	r5, r3, [r4, #4]
	h->chunk0 = hdr_chunks + chunksz(buckets_bytes);
 10152c4:	3103      	adds	r1, #3
	h->buf = (u64_t *)addr;
 10152c6:	6024      	str	r4, [r4, #0]
	h->avail_buckets = 0;
 10152c8:	6160      	str	r0, [r4, #20]
	h->chunk0 = hdr_chunks + chunksz(buckets_bytes);
 10152ca:	6121      	str	r1, [r4, #16]
	return sizeof(size_t) > 4 || h->len > 0x7fff;
 10152cc:	68a2      	ldr	r2, [r4, #8]
 10152ce:	42ba      	cmp	r2, r7
 10152d0:	bf94      	ite	ls
 10152d2:	2200      	movls	r2, #0
 10152d4:	2201      	movhi	r2, #1
	return 31 - __builtin_clz(sz) - (big_heap(h) ? 1 : 0);
 10152d6:	f1c2 021f 	rsb	r2, r2, #31
 10152da:	1b92      	subs	r2, r2, r6
	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
 10152dc:	4290      	cmp	r0, r2
 10152de:	dd0a      	ble.n	10152f6 <sys_heap_init+0x7c>
		heap->heap->buckets[i].next = 0;
	}

	chunk_set(h, h->chunk0, SIZE_AND_USED, buf_sz - h->chunk0);
 10152e0:	4620      	mov	r0, r4
 10152e2:	1a5b      	subs	r3, r3, r1
 10152e4:	2200      	movs	r2, #0
 10152e6:	f7ff fdc3 	bl	1014e70 <chunk_set>
	free_list_add(h, h->chunk0);
 10152ea:	4620      	mov	r0, r4
 10152ec:	6921      	ldr	r1, [r4, #16]
}
 10152ee:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
	free_list_add(h, h->chunk0);
 10152f2:	f7ff be07 	b.w	1014f04 <free_list_add>
		heap->heap->buckets[i].list_size = 0;
 10152f6:	f8c5 c004 	str.w	ip, [r5, #4]
	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
 10152fa:	3001      	adds	r0, #1
		heap->heap->buckets[i].next = 0;
 10152fc:	f845 cb08 	str.w	ip, [r5], #8
	for (int i = 0; i <= bucket_idx(heap->heap, heap->heap->len); i++) {
 1015300:	e7e4      	b.n	10152cc <sys_heap_init+0x52>

01015302 <_ConfigAbsSyms>:
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_DISASSEMBLY, 1);
GEN_ABSOLUTE_SYM(CONFIG_OUTPUT_PRINT_MEMORY_USAGE, 1);
GEN_ABSOLUTE_SYM(CONFIG_BUILD_OUTPUT_BIN, 1);
GEN_ABSOLUTE_SYM(CONFIG_COMPAT_INCLUDES, 1);

GEN_ABS_SYM_END
 1015302:	4770      	bx	lr

01015304 <z_platform_init>:

void z_platform_init(void)
{
	SystemInit();
 1015304:	f7fe b820 	b.w	1013348 <SystemInit>

01015308 <log_list_init>:

#include "log_list.h"

void log_list_init(struct log_list_t *list)
{
	list->tail = NULL;
 1015308:	2300      	movs	r3, #0
	list->head = NULL;
 101530a:	e9c0 3300 	strd	r3, r3, [r0]
}
 101530e:	4770      	bx	lr

01015310 <log_list_add_tail>:

void log_list_add_tail(struct log_list_t *list, struct log_msg *msg)
{
	if (list->head == NULL) {
 1015310:	6803      	ldr	r3, [r0, #0]
 1015312:	b923      	cbnz	r3, 101531e <log_list_add_tail+0xe>
		list->head = msg;
 1015314:	6001      	str	r1, [r0, #0]
	} else {
		list->tail->next = msg;
	}

	list->tail = msg;
	msg->next = NULL;
 1015316:	2300      	movs	r3, #0
	list->tail = msg;
 1015318:	6041      	str	r1, [r0, #4]
	msg->next = NULL;
 101531a:	600b      	str	r3, [r1, #0]
}
 101531c:	4770      	bx	lr
		list->tail->next = msg;
 101531e:	6843      	ldr	r3, [r0, #4]
 1015320:	6019      	str	r1, [r3, #0]
 1015322:	e7f8      	b.n	1015316 <log_list_add_tail+0x6>

01015324 <log_list_head_peek>:

struct log_msg *log_list_head_peek(struct log_list_t *list)
{
	return list->head;
}
 1015324:	6800      	ldr	r0, [r0, #0]
 1015326:	4770      	bx	lr

01015328 <log_list_head_get>:

struct log_msg *log_list_head_get(struct log_list_t *list)
{
 1015328:	4603      	mov	r3, r0
	struct log_msg *msg = list->head;
 101532a:	6800      	ldr	r0, [r0, #0]

	if (list->head != NULL) {
 101532c:	b108      	cbz	r0, 1015332 <log_list_head_get+0xa>
		list->head = list->head->next;
 101532e:	6802      	ldr	r2, [r0, #0]
 1015330:	601a      	str	r2, [r3, #0]
	}

	return msg;
}
 1015332:	4770      	bx	lr

01015334 <z_log_msg_std_alloc>:
/** @brief Allocate chunk for standard log message.
 *
 *  @return Allocated chunk of NULL.
 */
static inline struct log_msg *z_log_msg_std_alloc(void)
{
 1015334:	b508      	push	{r3, lr}
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
 1015336:	f7ee ff71 	bl	100421c <log_msg_chunk_alloc>

	if (msg != NULL) {
 101533a:	b118      	cbz	r0, 1015344 <z_log_msg_std_alloc+0x10>
		/* all fields reset to 0, reference counter to 1 */
		msg->hdr.ref_cnt = 1;
 101533c:	2301      	movs	r3, #1
 101533e:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
 1015340:	2300      	movs	r3, #0
 1015342:	8103      	strh	r3, [r0, #8]
		msg->hdr.params.std.type = LOG_MSG_TYPE_STD;
	}

	return msg;
}
 1015344:	bd08      	pop	{r3, pc}

01015346 <k_cycle_get_32_wrapper>:
#ifndef _ASMLANGUAGE
extern u32_t z_timer_cycle_get_32(void);

static inline u32_t arch_k_cycle_get_32(void)
{
	return z_timer_cycle_get_32();
 1015346:	f7ef bba7 	b.w	1004a98 <z_timer_cycle_get_32>

0101534a <dummy_timestamp>:
 101534a:	2000      	movs	r0, #0
 101534c:	4770      	bx	lr

0101534e <z_log_get_s_mask>:
{
 101534e:	b5f0      	push	{r4, r5, r6, r7, lr}
 1015350:	4605      	mov	r5, r0
	u32_t mask = 0;
 1015352:	2000      	movs	r0, #0
				mask |= BIT(arg);
 1015354:	2701      	movs	r7, #1
	u32_t arg = 0;
 1015356:	4603      	mov	r3, r0
	bool arm = false;
 1015358:	4602      	mov	r2, r0
	while ((curr = *str++) && arg < nargs) {
 101535a:	f815 4b01 	ldrb.w	r4, [r5], #1
 101535e:	b10c      	cbz	r4, 1015364 <z_log_get_s_mask+0x16>
 1015360:	428b      	cmp	r3, r1
 1015362:	d300      	bcc.n	1015366 <z_log_get_s_mask+0x18>
}
 1015364:	bdf0      	pop	{r4, r5, r6, r7, pc}
		if (curr == '%') {
 1015366:	2c25      	cmp	r4, #37	; 0x25
 1015368:	d102      	bne.n	1015370 <z_log_get_s_mask+0x22>
			arm = !arm;
 101536a:	f082 0201 	eor.w	r2, r2, #1
 101536e:	e7f4      	b.n	101535a <z_log_get_s_mask+0xc>
		} else if (arm && isalpha((int)curr)) {
 1015370:	2a00      	cmp	r2, #0
 1015372:	d0f2      	beq.n	101535a <z_log_get_s_mask+0xc>
	return (int)((((unsigned)c|32u)-(unsigned)'a') < 26U);
 1015374:	f044 0620 	orr.w	r6, r4, #32
 1015378:	3e61      	subs	r6, #97	; 0x61
 101537a:	2e19      	cmp	r6, #25
 101537c:	d8ed      	bhi.n	101535a <z_log_get_s_mask+0xc>
			if (curr == 's') {
 101537e:	2c73      	cmp	r4, #115	; 0x73
				mask |= BIT(arg);
 1015380:	bf04      	itt	eq
 1015382:	fa07 f203 	lsleq.w	r2, r7, r3
 1015386:	4310      	orreq	r0, r2
			arg++;
 1015388:	3301      	adds	r3, #1
			arm = false;
 101538a:	2200      	movs	r2, #0
 101538c:	e7e5      	b.n	101535a <z_log_get_s_mask+0xc>

0101538e <log_0>:
{
 101538e:	b538      	push	{r3, r4, r5, lr}
 1015390:	4605      	mov	r5, r0
 1015392:	460c      	mov	r4, r1
 *
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_0(const char *str)
{
	struct log_msg *msg = z_log_msg_std_alloc();
 1015394:	f7ff ffce 	bl	1015334 <z_log_msg_std_alloc>

	if (msg != NULL) {
 1015398:	b128      	cbz	r0, 10153a6 <log_0+0x18>
		msg_finalize(msg, src_level);
 101539a:	4621      	mov	r1, r4
		msg->str = str;
 101539c:	6105      	str	r5, [r0, #16]
}
 101539e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		msg_finalize(msg, src_level);
 10153a2:	f7ee be5d 	b.w	1004060 <msg_finalize>
}
 10153a6:	bd38      	pop	{r3, r4, r5, pc}

010153a8 <log_1>:
{
 10153a8:	b570      	push	{r4, r5, r6, lr}
 10153aa:	4606      	mov	r6, r0
 10153ac:	460d      	mov	r5, r1
 10153ae:	4614      	mov	r4, r2
 *  @return Pointer to allocated head of the message or NULL.
 */
static inline struct log_msg *log_msg_create_1(const char *str,
					       log_arg_t arg1)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
 10153b0:	f7ff ffc0 	bl	1015334 <z_log_msg_std_alloc>

	if (msg != NULL) {
 10153b4:	b158      	cbz	r0, 10153ce <log_1+0x26>
		msg->str = str;
		msg->hdr.params.std.nargs = 1U;
 10153b6:	2101      	movs	r1, #1
 10153b8:	7a42      	ldrb	r2, [r0, #9]
		msg->str = str;
 10153ba:	6106      	str	r6, [r0, #16]
		msg->hdr.params.std.nargs = 1U;
 10153bc:	f361 1207 	bfi	r2, r1, #4, #4
 10153c0:	7242      	strb	r2, [r0, #9]
		msg_finalize(msg, src_level);
 10153c2:	4621      	mov	r1, r4
		msg->payload.single.args[0] = arg1;
 10153c4:	6145      	str	r5, [r0, #20]
}
 10153c6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		msg_finalize(msg, src_level);
 10153ca:	f7ee be49 	b.w	1004060 <msg_finalize>
}
 10153ce:	bd70      	pop	{r4, r5, r6, pc}

010153d0 <log_2>:
{
 10153d0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 10153d4:	4680      	mov	r8, r0
 10153d6:	460f      	mov	r7, r1
 10153d8:	4616      	mov	r6, r2
 10153da:	461d      	mov	r5, r3
 */
static inline struct log_msg *log_msg_create_2(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
 10153dc:	f7ff ffaa 	bl	1015334 <z_log_msg_std_alloc>

	if (msg != NULL) {
 10153e0:	b168      	cbz	r0, 10153fe <log_2+0x2e>
		msg->str = str;
		msg->hdr.params.std.nargs = 2U;
 10153e2:	2202      	movs	r2, #2
 10153e4:	7a43      	ldrb	r3, [r0, #9]
		msg_finalize(msg, src_level);
 10153e6:	4629      	mov	r1, r5
 10153e8:	f362 1307 	bfi	r3, r2, #4, #4
 10153ec:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
 10153ee:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg->str = str;
 10153f2:	f8c0 8010 	str.w	r8, [r0, #16]
}
 10153f6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
		msg_finalize(msg, src_level);
 10153fa:	f7ee be31 	b.w	1004060 <msg_finalize>
}
 10153fe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

01015402 <log_3>:
{
 1015402:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1015406:	4680      	mov	r8, r0
 1015408:	460f      	mov	r7, r1
 101540a:	4616      	mov	r6, r2
 101540c:	461d      	mov	r5, r3
 101540e:	f8bd 9020 	ldrh.w	r9, [sp, #32]
static inline struct log_msg *log_msg_create_3(const char *str,
					       log_arg_t arg1,
					       log_arg_t arg2,
					       log_arg_t arg3)
{
	struct  log_msg *msg = z_log_msg_std_alloc();
 1015412:	f7ff ff8f 	bl	1015334 <z_log_msg_std_alloc>

	if (msg != NULL) {
 1015416:	b170      	cbz	r0, 1015436 <log_3+0x34>
		msg->str = str;
		msg->hdr.params.std.nargs = 3U;
 1015418:	2203      	movs	r2, #3
 101541a:	7a43      	ldrb	r3, [r0, #9]
		msg_finalize(msg, src_level);
 101541c:	4649      	mov	r1, r9
 101541e:	f362 1307 	bfi	r3, r2, #4, #4
 1015422:	7243      	strb	r3, [r0, #9]
		msg->payload.single.args[0] = arg1;
		msg->payload.single.args[1] = arg2;
 1015424:	e9c0 7605 	strd	r7, r6, [r0, #20]
		msg->str = str;
 1015428:	f8c0 8010 	str.w	r8, [r0, #16]
		msg->payload.single.args[2] = arg3;
 101542c:	61c5      	str	r5, [r0, #28]
}
 101542e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
		msg_finalize(msg, src_level);
 1015432:	f7ee be15 	b.w	1004060 <msg_finalize>
}
 1015436:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0101543a <log_n>:
{
 101543a:	b510      	push	{r4, lr}
 101543c:	461c      	mov	r4, r3
		struct log_msg *msg = log_msg_create_n(str, args, narg);
 101543e:	f000 f896 	bl	101556e <log_msg_create_n>
		if (msg == NULL) {
 1015442:	b120      	cbz	r0, 101544e <log_n+0x14>
		msg_finalize(msg, src_level);
 1015444:	4621      	mov	r1, r4
}
 1015446:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
		msg_finalize(msg, src_level);
 101544a:	f7ee be09 	b.w	1004060 <msg_finalize>
}
 101544e:	bd10      	pop	{r4, pc}

01015450 <log_msg_hexdump_data_op>:
static void log_msg_hexdump_data_op(struct log_msg *msg,
				    u8_t *data,
				    size_t *length,
				    size_t offset,
				    bool put_op)
{
 1015450:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1015454:	461c      	mov	r4, r3
	u32_t available_len = msg->hdr.params.hexdump.length;
 1015456:	8903      	ldrh	r3, [r0, #8]
{
 1015458:	460e      	mov	r6, r1
 101545a:	4611      	mov	r1, r2
	u32_t available_len = msg->hdr.params.hexdump.length;
 101545c:	f3c3 028d 	ubfx	r2, r3, #2, #14
	u8_t *head_data;
	u32_t chunk_len;
	u32_t req_len;
	u32_t cpy_len;

	if (offset >= available_len) {
 1015460:	42a2      	cmp	r2, r4
{
 1015462:	f89d 7020 	ldrb.w	r7, [sp, #32]
	if (offset >= available_len) {
 1015466:	d803      	bhi.n	1015470 <log_msg_hexdump_data_op+0x20>
		*length = 0;
 1015468:	2300      	movs	r3, #0
 101546a:	600b      	str	r3, [r1, #0]
		offset = 0;
		cont = cont->next;
		req_len -= cpy_len;
		data += cpy_len;
	}
}
 101546c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	if ((offset + *length) > available_len) {
 1015470:	680b      	ldr	r3, [r1, #0]
 1015472:	4423      	add	r3, r4
 1015474:	4293      	cmp	r3, r2
		*length = available_len - offset;
 1015476:	bf84      	itt	hi
 1015478:	1b13      	subhi	r3, r2, r4
 101547a:	600b      	strhi	r3, [r1, #0]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
 101547c:	2a0c      	cmp	r2, #12
	req_len = *length;
 101547e:	f8d1 9000 	ldr.w	r9, [r1]
	if (available_len > LOG_MSG_HEXDUMP_BYTES_SINGLE_CHUNK) {
 1015482:	d927      	bls.n	10154d4 <log_msg_hexdump_data_op+0x84>
	if (offset < chunk_len) {
 1015484:	2c07      	cmp	r4, #7
		cont = msg->payload.ext.next;
 1015486:	f8d0 8014 	ldr.w	r8, [r0, #20]
	if (offset < chunk_len) {
 101548a:	d82a      	bhi.n	10154e2 <log_msg_hexdump_data_op+0x92>
		chunk_len = LOG_MSG_HEXDUMP_BYTES_HEAD_CHUNK;
 101548c:	2208      	movs	r2, #8
		head_data = msg->payload.ext.data.bytes;
 101548e:	3018      	adds	r0, #24
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
 1015490:	454a      	cmp	r2, r9
 1015492:	bf28      	it	cs
 1015494:	464a      	movcs	r2, r9
 1015496:	4420      	add	r0, r4
 1015498:	4615      	mov	r5, r2
		if (put_op) {
 101549a:	b1ff      	cbz	r7, 10154dc <log_msg_hexdump_data_op+0x8c>
			(void)memcpy(&head_data[offset], data, cpy_len);
 101549c:	4631      	mov	r1, r6
			(void)memcpy(data, &head_data[offset], cpy_len);
 101549e:	f001 fa0b 	bl	10168b8 <memcpy>
		req_len -= cpy_len;
 10154a2:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
 10154a6:	442e      	add	r6, r5
	while (req_len > 0) {
 10154a8:	f1b9 0f00 	cmp.w	r9, #0
 10154ac:	d0de      	beq.n	101546c <log_msg_hexdump_data_op+0x1c>
		chunk_len = HEXDUMP_BYTES_CONT_MSG - offset;
 10154ae:	f1c4 051c 	rsb	r5, r4, #28
		cpy_len = req_len > chunk_len ? chunk_len : req_len;
 10154b2:	454d      	cmp	r5, r9
 10154b4:	bf28      	it	cs
 10154b6:	464d      	movcs	r5, r9
		if (put_op) {
 10154b8:	1d20      	adds	r0, r4, #4
			(void)memcpy(&cont->payload.bytes[offset],
 10154ba:	462a      	mov	r2, r5
 10154bc:	4440      	add	r0, r8
		if (put_op) {
 10154be:	b1bf      	cbz	r7, 10154f0 <log_msg_hexdump_data_op+0xa0>
			(void)memcpy(&cont->payload.bytes[offset],
 10154c0:	4631      	mov	r1, r6
			(void)memcpy(data, &cont->payload.bytes[offset],
 10154c2:	f001 f9f9 	bl	10168b8 <memcpy>
		offset = 0;
 10154c6:	2400      	movs	r4, #0
		cont = cont->next;
 10154c8:	f8d8 8000 	ldr.w	r8, [r8]
		req_len -= cpy_len;
 10154cc:	eba9 0905 	sub.w	r9, r9, r5
		data += cpy_len;
 10154d0:	442e      	add	r6, r5
 10154d2:	e7e9      	b.n	10154a8 <log_msg_hexdump_data_op+0x58>
	struct log_msg_cont *cont = NULL;
 10154d4:	f04f 0800 	mov.w	r8, #0
		head_data = msg->payload.single.bytes;
 10154d8:	3014      	adds	r0, #20
	if (offset < chunk_len) {
 10154da:	e7d9      	b.n	1015490 <log_msg_hexdump_data_op+0x40>
			(void)memcpy(data, &head_data[offset], cpy_len);
 10154dc:	4601      	mov	r1, r0
 10154de:	4630      	mov	r0, r6
 10154e0:	e7dd      	b.n	101549e <log_msg_hexdump_data_op+0x4e>
		offset -= chunk_len;
 10154e2:	3c08      	subs	r4, #8
		while (offset >= chunk_len) {
 10154e4:	2c1b      	cmp	r4, #27
 10154e6:	d9df      	bls.n	10154a8 <log_msg_hexdump_data_op+0x58>
			cont = cont->next;
 10154e8:	f8d8 8000 	ldr.w	r8, [r8]
			offset -= chunk_len;
 10154ec:	3c1c      	subs	r4, #28
 10154ee:	e7f9      	b.n	10154e4 <log_msg_hexdump_data_op+0x94>
			(void)memcpy(data, &cont->payload.bytes[offset],
 10154f0:	4601      	mov	r1, r0
 10154f2:	4630      	mov	r0, r6
 10154f4:	e7e5      	b.n	10154c2 <log_msg_hexdump_data_op+0x72>

010154f6 <log_msg_get>:
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 10154f6:	3004      	adds	r0, #4
 10154f8:	e8d0 3fef 	ldaex	r3, [r0]
 10154fc:	3301      	adds	r3, #1
 10154fe:	e8c0 3fe2 	stlex	r2, r3, [r0]
 1015502:	2a00      	cmp	r2, #0
 1015504:	d1f8      	bne.n	10154f8 <log_msg_get+0x2>
}
 1015506:	4770      	bx	lr

01015508 <log_msg_nargs_get>:
	return msg->hdr.params.std.nargs;
 1015508:	7a40      	ldrb	r0, [r0, #9]
}
 101550a:	0900      	lsrs	r0, r0, #4
 101550c:	4770      	bx	lr

0101550e <log_msg_arg_get>:
	if (arg_idx >= msg->hdr.params.std.nargs) {
 101550e:	7a43      	ldrb	r3, [r0, #9]
 1015510:	ebb1 1f13 	cmp.w	r1, r3, lsr #4
 1015514:	ea4f 1213 	mov.w	r2, r3, lsr #4
 1015518:	d216      	bcs.n	1015548 <log_msg_arg_get+0x3a>
	if (msg->hdr.params.std.nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
 101551a:	2a03      	cmp	r2, #3
 101551c:	d803      	bhi.n	1015526 <log_msg_arg_get+0x18>
		arg = msg->payload.single.args[arg_idx];
 101551e:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 1015522:	6948      	ldr	r0, [r1, #20]
 1015524:	4770      	bx	lr
	if (arg_idx < LOG_MSG_NARGS_HEAD_CHUNK) {
 1015526:	2901      	cmp	r1, #1
 1015528:	d803      	bhi.n	1015532 <log_msg_arg_get+0x24>
		return msg->payload.ext.data.args[arg_idx];
 101552a:	eb00 0181 	add.w	r1, r0, r1, lsl #2
 101552e:	6988      	ldr	r0, [r1, #24]
 1015530:	4770      	bx	lr
	cont = msg->payload.ext.next;
 1015532:	6943      	ldr	r3, [r0, #20]
	arg_idx -= LOG_MSG_NARGS_HEAD_CHUNK;
 1015534:	3902      	subs	r1, #2
	while (arg_idx >= ARGS_CONT_MSG) {
 1015536:	2906      	cmp	r1, #6
 1015538:	d803      	bhi.n	1015542 <log_msg_arg_get+0x34>
	return cont->payload.args[arg_idx];
 101553a:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 101553e:	6848      	ldr	r0, [r1, #4]
 1015540:	4770      	bx	lr
		cont = cont->next;
 1015542:	681b      	ldr	r3, [r3, #0]
		arg_idx -= ARGS_CONT_MSG;
 1015544:	3907      	subs	r1, #7
		cont = cont->next;
 1015546:	e7f6      	b.n	1015536 <log_msg_arg_get+0x28>
		return 0;
 1015548:	2000      	movs	r0, #0
}
 101554a:	4770      	bx	lr

0101554c <log_msg_put>:
{
 101554c:	4603      	mov	r3, r0
	return __atomic_fetch_sub(target, value, __ATOMIC_SEQ_CST);
 101554e:	1d02      	adds	r2, r0, #4
 1015550:	e8d2 1fef 	ldaex	r1, [r2]
 1015554:	3901      	subs	r1, #1
 1015556:	e8c2 1fec 	stlex	ip, r1, [r2]
 101555a:	f1bc 0f00 	cmp.w	ip, #0
 101555e:	d1f7      	bne.n	1015550 <log_msg_put+0x4>
	if (msg->hdr.ref_cnt == 0) {
 1015560:	685b      	ldr	r3, [r3, #4]
 1015562:	b90b      	cbnz	r3, 1015568 <log_msg_put+0x1c>
		msg_free(msg);
 1015564:	f7ee be6e 	b.w	1004244 <msg_free>
}
 1015568:	4770      	bx	lr

0101556a <log_msg_str_get>:
}
 101556a:	6900      	ldr	r0, [r0, #16]
 101556c:	4770      	bx	lr

0101556e <log_msg_create_n>:
{
 101556e:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1015572:	4681      	mov	r9, r0
 1015574:	4688      	mov	r8, r1
 1015576:	4615      	mov	r5, r2
	struct  log_msg *msg = (struct  log_msg *)log_msg_chunk_alloc();
 1015578:	f7ee fe50 	bl	100421c <log_msg_chunk_alloc>
	if (msg != NULL) {
 101557c:	4604      	mov	r4, r0
 101557e:	b330      	cbz	r0, 10155ce <log_msg_create_n+0x60>
		msg->hdr.ref_cnt = 1;
 1015580:	2301      	movs	r3, #1
		msg->hdr.params.raw = 0U;
 1015582:	2700      	movs	r7, #0
	if ((msg == NULL) || nargs <= LOG_MSG_NARGS_SINGLE_CHUNK) {
 1015584:	2d03      	cmp	r5, #3
		msg->hdr.ref_cnt = 1;
 1015586:	6043      	str	r3, [r0, #4]
		msg->hdr.params.raw = 0U;
 1015588:	8107      	strh	r7, [r0, #8]
 101558a:	d909      	bls.n	10155a0 <log_msg_create_n+0x32>
	msg->hdr.params.generic.ext = 1;
 101558c:	2202      	movs	r2, #2
	n -= LOG_MSG_NARGS_HEAD_CHUNK;
 101558e:	f1a5 0a02 	sub.w	sl, r5, #2
	msg->hdr.params.generic.ext = 1;
 1015592:	8102      	strh	r2, [r0, #8]
	next = &msg->payload.ext.next;
 1015594:	f100 0b14 	add.w	fp, r0, #20
	*next = NULL;
 1015598:	6147      	str	r7, [r0, #20]
	while (n > 0) {
 101559a:	f1ba 0f00 	cmp.w	sl, #0
 101559e:	dc0e      	bgt.n	10155be <log_msg_create_n+0x50>
		msg->hdr.params.std.nargs = nargs;
 10155a0:	7a63      	ldrb	r3, [r4, #9]
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
 10155a2:	2d03      	cmp	r5, #3
		msg->hdr.params.std.nargs = nargs;
 10155a4:	f365 1307 	bfi	r3, r5, #4, #4
		msg->str = str;
 10155a8:	f8c4 9010 	str.w	r9, [r4, #16]
		msg->hdr.params.std.nargs = nargs;
 10155ac:	7263      	strb	r3, [r4, #9]
	if (nargs > LOG_MSG_NARGS_SINGLE_CHUNK) {
 10155ae:	d818      	bhi.n	10155e2 <log_msg_create_n+0x74>
		(void)memcpy(msg->payload.single.args, args,
 10155b0:	4641      	mov	r1, r8
 10155b2:	00aa      	lsls	r2, r5, #2
 10155b4:	f104 0014 	add.w	r0, r4, #20
 10155b8:	f001 f97e 	bl	10168b8 <memcpy>
	while (nargs != 0U) {
 10155bc:	e007      	b.n	10155ce <log_msg_create_n+0x60>
		cont = (struct log_msg_cont *)log_msg_chunk_alloc();
 10155be:	f7ee fe2d 	bl	100421c <log_msg_chunk_alloc>
		if (cont == NULL) {
 10155c2:	4606      	mov	r6, r0
 10155c4:	b930      	cbnz	r0, 10155d4 <log_msg_create_n+0x66>
			msg_free(msg);
 10155c6:	4620      	mov	r0, r4
 10155c8:	f7ee fe3c 	bl	1004244 <msg_free>
			return NULL;
 10155cc:	4634      	mov	r4, r6
}
 10155ce:	4620      	mov	r0, r4
 10155d0:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
		*next = cont;
 10155d4:	f8cb 0000 	str.w	r0, [fp]
		cont->next = NULL;
 10155d8:	f1aa 0a07 	sub.w	sl, sl, #7
		next = &cont->next;
 10155dc:	4683      	mov	fp, r0
		cont->next = NULL;
 10155de:	6007      	str	r7, [r0, #0]
		n -= ARGS_CONT_MSG;
 10155e0:	e7db      	b.n	101559a <log_msg_create_n+0x2c>
		(void)memcpy(msg->payload.ext.data.args, args,
 10155e2:	4641      	mov	r1, r8
 10155e4:	2208      	movs	r2, #8
 10155e6:	f104 0018 	add.w	r0, r4, #24
	struct log_msg_cont *cont = msg->payload.ext.next;
 10155ea:	6967      	ldr	r7, [r4, #20]
		(void)memcpy(msg->payload.ext.data.args, args,
 10155ec:	f001 f964 	bl	10168b8 <memcpy>
		nargs -= LOG_MSG_NARGS_HEAD_CHUNK;
 10155f0:	3d02      	subs	r5, #2
		args += LOG_MSG_NARGS_HEAD_CHUNK;
 10155f2:	f108 0808 	add.w	r8, r8, #8
		u32_t cpy_args = MIN(nargs, ARGS_CONT_MSG);
 10155f6:	2d07      	cmp	r5, #7
 10155f8:	462e      	mov	r6, r5
 10155fa:	bf28      	it	cs
 10155fc:	2607      	movcs	r6, #7
		(void)memcpy(cont->payload.args, args,
 10155fe:	ea4f 0986 	mov.w	r9, r6, lsl #2
 1015602:	4641      	mov	r1, r8
 1015604:	1d38      	adds	r0, r7, #4
 1015606:	464a      	mov	r2, r9
 1015608:	f001 f956 	bl	10168b8 <memcpy>
	while (nargs != 0U) {
 101560c:	1bad      	subs	r5, r5, r6
		cont = cont->next;
 101560e:	683f      	ldr	r7, [r7, #0]
		args += cpy_args;
 1015610:	44c8      	add	r8, r9
	while (nargs != 0U) {
 1015612:	d1f0      	bne.n	10155f6 <log_msg_create_n+0x88>
 1015614:	e7db      	b.n	10155ce <log_msg_create_n+0x60>

01015616 <log_msg_hexdump_data_get>:

void log_msg_hexdump_data_get(struct log_msg *msg,
			      u8_t *data,
			      size_t *length,
			      size_t offset)
{
 1015616:	b513      	push	{r0, r1, r4, lr}
	log_msg_hexdump_data_op(msg, data, length, offset, false);
 1015618:	2400      	movs	r4, #0
 101561a:	9400      	str	r4, [sp, #0]
 101561c:	f7ff ff18 	bl	1015450 <log_msg_hexdump_data_op>
}
 1015620:	b002      	add	sp, #8
 1015622:	bd10      	pop	{r4, pc}

01015624 <buffer_write>:
{
 1015624:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1015626:	4606      	mov	r6, r0
 1015628:	460d      	mov	r5, r1
 101562a:	4614      	mov	r4, r2
 101562c:	461f      	mov	r7, r3
		processed = outf(buf, len, ctx);
 101562e:	4621      	mov	r1, r4
 1015630:	4628      	mov	r0, r5
 1015632:	463a      	mov	r2, r7
 1015634:	47b0      	blx	r6
	} while (len != 0);
 1015636:	1a24      	subs	r4, r4, r0
		buf += processed;
 1015638:	4405      	add	r5, r0
	} while (len != 0);
 101563a:	d1f8      	bne.n	101562e <buffer_write+0xa>
}
 101563c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

0101563e <std_print>:
{
 101563e:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1015642:	b08e      	sub	sp, #56	; 0x38
 1015644:	af0e      	add	r7, sp, #56	; 0x38
 1015646:	4680      	mov	r8, r0
 1015648:	460d      	mov	r5, r1
	const char *str = log_msg_str_get(msg);
 101564a:	f7ff ff8e 	bl	101556a <log_msg_str_get>
 101564e:	4606      	mov	r6, r0
	u32_t nargs = log_msg_nargs_get(msg);
 1015650:	4640      	mov	r0, r8
 1015652:	f7ff ff59 	bl	1015508 <log_msg_nargs_get>
	for (i = 0; i < nargs; i++) {
 1015656:	f04f 0900 	mov.w	r9, #0
	u32_t nargs = log_msg_nargs_get(msg);
 101565a:	4682      	mov	sl, r0
	u32_t *args = alloca(sizeof(u32_t)*nargs);
 101565c:	0083      	lsls	r3, r0, #2
 101565e:	3307      	adds	r3, #7
 1015660:	f023 0307 	bic.w	r3, r3, #7
 1015664:	ebad 0d03 	sub.w	sp, sp, r3
 1015668:	ac0e      	add	r4, sp, #56	; 0x38
	for (i = 0; i < nargs; i++) {
 101566a:	45d1      	cmp	r9, sl
 101566c:	d116      	bne.n	101569c <std_print+0x5e>
	switch (log_msg_nargs_get(msg)) {
 101566e:	4640      	mov	r0, r8
 1015670:	f7ff ff4a 	bl	1015508 <log_msg_nargs_get>
 1015674:	280f      	cmp	r0, #15
 1015676:	d81e      	bhi.n	10156b6 <std_print+0x78>
 1015678:	e8df f010 	tbh	[pc, r0, lsl #1]
 101567c:	00200019 	.word	0x00200019
 1015680:	002d0026 	.word	0x002d0026
 1015684:	00410036 	.word	0x00410036
 1015688:	005d004e 	.word	0x005d004e
 101568c:	0081006e 	.word	0x0081006e
 1015690:	00ad0096 	.word	0x00ad0096
 1015694:	00e100c6 	.word	0x00e100c6
 1015698:	011d00fe 	.word	0x011d00fe
		args[i] = log_msg_arg_get(msg, i);
 101569c:	4649      	mov	r1, r9
 101569e:	4640      	mov	r0, r8
 10156a0:	f7ff ff35 	bl	101550e <log_msg_arg_get>
 10156a4:	f844 0029 	str.w	r0, [r4, r9, lsl #2]
	for (i = 0; i < nargs; i++) {
 10156a8:	f109 0901 	add.w	r9, r9, #1
 10156ac:	e7dd      	b.n	101566a <std_print+0x2c>
		print_formatted(log_output, str);
 10156ae:	4631      	mov	r1, r6
 10156b0:	4628      	mov	r0, r5
 10156b2:	f7ee fe05 	bl	10042c0 <print_formatted>
}
 10156b6:	46bd      	mov	sp, r7
 10156b8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		print_formatted(log_output, str, args[0]);
 10156bc:	4631      	mov	r1, r6
 10156be:	4628      	mov	r0, r5
 10156c0:	6822      	ldr	r2, [r4, #0]
 10156c2:	f7ee fdfd 	bl	10042c0 <print_formatted>
		break;
 10156c6:	e7f6      	b.n	10156b6 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1]);
 10156c8:	4631      	mov	r1, r6
 10156ca:	e9d4 2300 	ldrd	r2, r3, [r4]
 10156ce:	4628      	mov	r0, r5
 10156d0:	f7ee fdf6 	bl	10042c0 <print_formatted>
		break;
 10156d4:	e7ef      	b.n	10156b6 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2]);
 10156d6:	68a3      	ldr	r3, [r4, #8]
 10156d8:	4631      	mov	r1, r6
 10156da:	9300      	str	r3, [sp, #0]
 10156dc:	4628      	mov	r0, r5
 10156de:	e9d4 2300 	ldrd	r2, r3, [r4]
 10156e2:	f7ee fded 	bl	10042c0 <print_formatted>
		break;
 10156e6:	e7e6      	b.n	10156b6 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 10156e8:	68e3      	ldr	r3, [r4, #12]
 10156ea:	4631      	mov	r1, r6
 10156ec:	9301      	str	r3, [sp, #4]
 10156ee:	68a3      	ldr	r3, [r4, #8]
 10156f0:	4628      	mov	r0, r5
 10156f2:	9300      	str	r3, [sp, #0]
 10156f4:	e9d4 2300 	ldrd	r2, r3, [r4]
 10156f8:	f7ee fde2 	bl	10042c0 <print_formatted>
		break;
 10156fc:	e7db      	b.n	10156b6 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 10156fe:	6923      	ldr	r3, [r4, #16]
 1015700:	4631      	mov	r1, r6
 1015702:	9302      	str	r3, [sp, #8]
 1015704:	68e3      	ldr	r3, [r4, #12]
 1015706:	4628      	mov	r0, r5
 1015708:	9301      	str	r3, [sp, #4]
 101570a:	68a3      	ldr	r3, [r4, #8]
 101570c:	9300      	str	r3, [sp, #0]
 101570e:	e9d4 2300 	ldrd	r2, r3, [r4]
 1015712:	f7ee fdd5 	bl	10042c0 <print_formatted>
		break;
 1015716:	e7ce      	b.n	10156b6 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 1015718:	6963      	ldr	r3, [r4, #20]
 101571a:	4631      	mov	r1, r6
 101571c:	9303      	str	r3, [sp, #12]
 101571e:	6923      	ldr	r3, [r4, #16]
 1015720:	4628      	mov	r0, r5
 1015722:	9302      	str	r3, [sp, #8]
 1015724:	68e3      	ldr	r3, [r4, #12]
 1015726:	9301      	str	r3, [sp, #4]
 1015728:	68a3      	ldr	r3, [r4, #8]
 101572a:	9300      	str	r3, [sp, #0]
 101572c:	e9d4 2300 	ldrd	r2, r3, [r4]
 1015730:	f7ee fdc6 	bl	10042c0 <print_formatted>
		break;
 1015734:	e7bf      	b.n	10156b6 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 1015736:	69a3      	ldr	r3, [r4, #24]
 1015738:	4631      	mov	r1, r6
 101573a:	9304      	str	r3, [sp, #16]
 101573c:	6963      	ldr	r3, [r4, #20]
 101573e:	4628      	mov	r0, r5
 1015740:	9303      	str	r3, [sp, #12]
 1015742:	6923      	ldr	r3, [r4, #16]
 1015744:	9302      	str	r3, [sp, #8]
 1015746:	68e3      	ldr	r3, [r4, #12]
 1015748:	9301      	str	r3, [sp, #4]
 101574a:	68a3      	ldr	r3, [r4, #8]
 101574c:	9300      	str	r3, [sp, #0]
 101574e:	e9d4 2300 	ldrd	r2, r3, [r4]
 1015752:	f7ee fdb5 	bl	10042c0 <print_formatted>
		break;
 1015756:	e7ae      	b.n	10156b6 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 1015758:	69e3      	ldr	r3, [r4, #28]
 101575a:	4631      	mov	r1, r6
 101575c:	9305      	str	r3, [sp, #20]
 101575e:	69a3      	ldr	r3, [r4, #24]
 1015760:	4628      	mov	r0, r5
 1015762:	9304      	str	r3, [sp, #16]
 1015764:	6963      	ldr	r3, [r4, #20]
 1015766:	9303      	str	r3, [sp, #12]
 1015768:	6923      	ldr	r3, [r4, #16]
 101576a:	9302      	str	r3, [sp, #8]
 101576c:	68e3      	ldr	r3, [r4, #12]
 101576e:	9301      	str	r3, [sp, #4]
 1015770:	68a3      	ldr	r3, [r4, #8]
 1015772:	9300      	str	r3, [sp, #0]
 1015774:	e9d4 2300 	ldrd	r2, r3, [r4]
 1015778:	f7ee fda2 	bl	10042c0 <print_formatted>
		break;
 101577c:	e79b      	b.n	10156b6 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 101577e:	6a23      	ldr	r3, [r4, #32]
 1015780:	4631      	mov	r1, r6
 1015782:	9306      	str	r3, [sp, #24]
 1015784:	69e3      	ldr	r3, [r4, #28]
 1015786:	4628      	mov	r0, r5
 1015788:	9305      	str	r3, [sp, #20]
 101578a:	69a3      	ldr	r3, [r4, #24]
 101578c:	9304      	str	r3, [sp, #16]
 101578e:	6963      	ldr	r3, [r4, #20]
 1015790:	9303      	str	r3, [sp, #12]
 1015792:	6923      	ldr	r3, [r4, #16]
 1015794:	9302      	str	r3, [sp, #8]
 1015796:	68e3      	ldr	r3, [r4, #12]
 1015798:	9301      	str	r3, [sp, #4]
 101579a:	68a3      	ldr	r3, [r4, #8]
 101579c:	9300      	str	r3, [sp, #0]
 101579e:	e9d4 2300 	ldrd	r2, r3, [r4]
 10157a2:	f7ee fd8d 	bl	10042c0 <print_formatted>
		break;
 10157a6:	e786      	b.n	10156b6 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 10157a8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 10157aa:	4631      	mov	r1, r6
 10157ac:	9307      	str	r3, [sp, #28]
 10157ae:	6a23      	ldr	r3, [r4, #32]
 10157b0:	4628      	mov	r0, r5
 10157b2:	9306      	str	r3, [sp, #24]
 10157b4:	69e3      	ldr	r3, [r4, #28]
 10157b6:	9305      	str	r3, [sp, #20]
 10157b8:	69a3      	ldr	r3, [r4, #24]
 10157ba:	9304      	str	r3, [sp, #16]
 10157bc:	6963      	ldr	r3, [r4, #20]
 10157be:	9303      	str	r3, [sp, #12]
 10157c0:	6923      	ldr	r3, [r4, #16]
 10157c2:	9302      	str	r3, [sp, #8]
 10157c4:	68e3      	ldr	r3, [r4, #12]
 10157c6:	9301      	str	r3, [sp, #4]
 10157c8:	68a3      	ldr	r3, [r4, #8]
 10157ca:	9300      	str	r3, [sp, #0]
 10157cc:	e9d4 2300 	ldrd	r2, r3, [r4]
 10157d0:	f7ee fd76 	bl	10042c0 <print_formatted>
		break;
 10157d4:	e76f      	b.n	10156b6 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 10157d6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 10157d8:	4631      	mov	r1, r6
 10157da:	9308      	str	r3, [sp, #32]
 10157dc:	6a63      	ldr	r3, [r4, #36]	; 0x24
 10157de:	4628      	mov	r0, r5
 10157e0:	9307      	str	r3, [sp, #28]
 10157e2:	6a23      	ldr	r3, [r4, #32]
 10157e4:	9306      	str	r3, [sp, #24]
 10157e6:	69e3      	ldr	r3, [r4, #28]
 10157e8:	9305      	str	r3, [sp, #20]
 10157ea:	69a3      	ldr	r3, [r4, #24]
 10157ec:	9304      	str	r3, [sp, #16]
 10157ee:	6963      	ldr	r3, [r4, #20]
 10157f0:	9303      	str	r3, [sp, #12]
 10157f2:	6923      	ldr	r3, [r4, #16]
 10157f4:	9302      	str	r3, [sp, #8]
 10157f6:	68e3      	ldr	r3, [r4, #12]
 10157f8:	9301      	str	r3, [sp, #4]
 10157fa:	68a3      	ldr	r3, [r4, #8]
 10157fc:	9300      	str	r3, [sp, #0]
 10157fe:	e9d4 2300 	ldrd	r2, r3, [r4]
 1015802:	f7ee fd5d 	bl	10042c0 <print_formatted>
		break;
 1015806:	e756      	b.n	10156b6 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 1015808:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 101580a:	4631      	mov	r1, r6
 101580c:	9309      	str	r3, [sp, #36]	; 0x24
 101580e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1015810:	4628      	mov	r0, r5
 1015812:	9308      	str	r3, [sp, #32]
 1015814:	6a63      	ldr	r3, [r4, #36]	; 0x24
 1015816:	9307      	str	r3, [sp, #28]
 1015818:	6a23      	ldr	r3, [r4, #32]
 101581a:	9306      	str	r3, [sp, #24]
 101581c:	69e3      	ldr	r3, [r4, #28]
 101581e:	9305      	str	r3, [sp, #20]
 1015820:	69a3      	ldr	r3, [r4, #24]
 1015822:	9304      	str	r3, [sp, #16]
 1015824:	6963      	ldr	r3, [r4, #20]
 1015826:	9303      	str	r3, [sp, #12]
 1015828:	6923      	ldr	r3, [r4, #16]
 101582a:	9302      	str	r3, [sp, #8]
 101582c:	68e3      	ldr	r3, [r4, #12]
 101582e:	9301      	str	r3, [sp, #4]
 1015830:	68a3      	ldr	r3, [r4, #8]
 1015832:	9300      	str	r3, [sp, #0]
 1015834:	e9d4 2300 	ldrd	r2, r3, [r4]
 1015838:	f7ee fd42 	bl	10042c0 <print_formatted>
		break;
 101583c:	e73b      	b.n	10156b6 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 101583e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 1015840:	4631      	mov	r1, r6
 1015842:	930a      	str	r3, [sp, #40]	; 0x28
 1015844:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 1015846:	4628      	mov	r0, r5
 1015848:	9309      	str	r3, [sp, #36]	; 0x24
 101584a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 101584c:	9308      	str	r3, [sp, #32]
 101584e:	6a63      	ldr	r3, [r4, #36]	; 0x24
 1015850:	9307      	str	r3, [sp, #28]
 1015852:	6a23      	ldr	r3, [r4, #32]
 1015854:	9306      	str	r3, [sp, #24]
 1015856:	69e3      	ldr	r3, [r4, #28]
 1015858:	9305      	str	r3, [sp, #20]
 101585a:	69a3      	ldr	r3, [r4, #24]
 101585c:	9304      	str	r3, [sp, #16]
 101585e:	6963      	ldr	r3, [r4, #20]
 1015860:	9303      	str	r3, [sp, #12]
 1015862:	6923      	ldr	r3, [r4, #16]
 1015864:	9302      	str	r3, [sp, #8]
 1015866:	68e3      	ldr	r3, [r4, #12]
 1015868:	9301      	str	r3, [sp, #4]
 101586a:	68a3      	ldr	r3, [r4, #8]
 101586c:	9300      	str	r3, [sp, #0]
 101586e:	e9d4 2300 	ldrd	r2, r3, [r4]
 1015872:	f7ee fd25 	bl	10042c0 <print_formatted>
		break;
 1015876:	e71e      	b.n	10156b6 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 1015878:	6b63      	ldr	r3, [r4, #52]	; 0x34
 101587a:	4631      	mov	r1, r6
 101587c:	930b      	str	r3, [sp, #44]	; 0x2c
 101587e:	6b23      	ldr	r3, [r4, #48]	; 0x30
 1015880:	4628      	mov	r0, r5
 1015882:	930a      	str	r3, [sp, #40]	; 0x28
 1015884:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 1015886:	9309      	str	r3, [sp, #36]	; 0x24
 1015888:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 101588a:	9308      	str	r3, [sp, #32]
 101588c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 101588e:	9307      	str	r3, [sp, #28]
 1015890:	6a23      	ldr	r3, [r4, #32]
 1015892:	9306      	str	r3, [sp, #24]
 1015894:	69e3      	ldr	r3, [r4, #28]
 1015896:	9305      	str	r3, [sp, #20]
 1015898:	69a3      	ldr	r3, [r4, #24]
 101589a:	9304      	str	r3, [sp, #16]
 101589c:	6963      	ldr	r3, [r4, #20]
 101589e:	9303      	str	r3, [sp, #12]
 10158a0:	6923      	ldr	r3, [r4, #16]
 10158a2:	9302      	str	r3, [sp, #8]
 10158a4:	68e3      	ldr	r3, [r4, #12]
 10158a6:	9301      	str	r3, [sp, #4]
 10158a8:	68a3      	ldr	r3, [r4, #8]
 10158aa:	9300      	str	r3, [sp, #0]
 10158ac:	e9d4 2300 	ldrd	r2, r3, [r4]
 10158b0:	f7ee fd06 	bl	10042c0 <print_formatted>
		break;
 10158b4:	e6ff      	b.n	10156b6 <std_print+0x78>
		print_formatted(log_output, str, args[0], args[1], args[2],
 10158b6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 10158b8:	4631      	mov	r1, r6
 10158ba:	930c      	str	r3, [sp, #48]	; 0x30
 10158bc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 10158be:	4628      	mov	r0, r5
 10158c0:	930b      	str	r3, [sp, #44]	; 0x2c
 10158c2:	6b23      	ldr	r3, [r4, #48]	; 0x30
 10158c4:	930a      	str	r3, [sp, #40]	; 0x28
 10158c6:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 10158c8:	9309      	str	r3, [sp, #36]	; 0x24
 10158ca:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 10158cc:	9308      	str	r3, [sp, #32]
 10158ce:	6a63      	ldr	r3, [r4, #36]	; 0x24
 10158d0:	9307      	str	r3, [sp, #28]
 10158d2:	6a23      	ldr	r3, [r4, #32]
 10158d4:	9306      	str	r3, [sp, #24]
 10158d6:	69e3      	ldr	r3, [r4, #28]
 10158d8:	9305      	str	r3, [sp, #20]
 10158da:	69a3      	ldr	r3, [r4, #24]
 10158dc:	9304      	str	r3, [sp, #16]
 10158de:	6963      	ldr	r3, [r4, #20]
 10158e0:	9303      	str	r3, [sp, #12]
 10158e2:	6923      	ldr	r3, [r4, #16]
 10158e4:	9302      	str	r3, [sp, #8]
 10158e6:	68e3      	ldr	r3, [r4, #12]
 10158e8:	9301      	str	r3, [sp, #4]
 10158ea:	68a3      	ldr	r3, [r4, #8]
 10158ec:	9300      	str	r3, [sp, #0]
 10158ee:	e9d4 2300 	ldrd	r2, r3, [r4]
 10158f2:	f7ee fce5 	bl	10042c0 <print_formatted>
}
 10158f6:	e6de      	b.n	10156b6 <std_print+0x78>

010158f8 <log_output_flush>:
		     log_output->control_block->offset,
 10158f8:	6842      	ldr	r2, [r0, #4]
{
 10158fa:	b510      	push	{r4, lr}
	buffer_write(log_output->func, log_output->buf,
 10158fc:	e9d2 2300 	ldrd	r2, r3, [r2]
{
 1015900:	4604      	mov	r4, r0
	buffer_write(log_output->func, log_output->buf,
 1015902:	6881      	ldr	r1, [r0, #8]
 1015904:	6800      	ldr	r0, [r0, #0]
 1015906:	f7ff fe8d 	bl	1015624 <buffer_write>
	log_output->control_block->offset = 0;
 101590a:	2200      	movs	r2, #0
 101590c:	6863      	ldr	r3, [r4, #4]
 101590e:	601a      	str	r2, [r3, #0]
}
 1015910:	bd10      	pop	{r4, pc}

01015912 <out_func>:
{
 1015912:	b538      	push	{r3, r4, r5, lr}
	if (out_ctx->control_block->offset == out_ctx->size) {
 1015914:	684b      	ldr	r3, [r1, #4]
{
 1015916:	4605      	mov	r5, r0
	if (out_ctx->control_block->offset == out_ctx->size) {
 1015918:	681a      	ldr	r2, [r3, #0]
 101591a:	68cb      	ldr	r3, [r1, #12]
{
 101591c:	460c      	mov	r4, r1
	if (out_ctx->control_block->offset == out_ctx->size) {
 101591e:	429a      	cmp	r2, r3
 1015920:	d102      	bne.n	1015928 <out_func+0x16>
		log_output_flush(out_ctx);
 1015922:	4608      	mov	r0, r1
 1015924:	f7ff ffe8 	bl	10158f8 <log_output_flush>
	return __atomic_fetch_add(target, value, __ATOMIC_SEQ_CST);
 1015928:	6863      	ldr	r3, [r4, #4]
 101592a:	e8d3 2fef 	ldaex	r2, [r3]
 101592e:	1c51      	adds	r1, r2, #1
 1015930:	e8c3 1fe0 	stlex	r0, r1, [r3]
 1015934:	2800      	cmp	r0, #0
 1015936:	d1f8      	bne.n	101592a <out_func+0x18>
	out_ctx->buf[idx] = (u8_t)c;
 1015938:	68a3      	ldr	r3, [r4, #8]
}
 101593a:	2000      	movs	r0, #0
	out_ctx->buf[idx] = (u8_t)c;
 101593c:	549d      	strb	r5, [r3, r2]
}
 101593e:	bd38      	pop	{r3, r4, r5, pc}

01015940 <char_out>:
{
 1015940:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1015942:	460d      	mov	r5, r1
 1015944:	4616      	mov	r6, r2
	for (size_t i = 0; i < length; i++) {
 1015946:	4604      	mov	r4, r0
 1015948:	1847      	adds	r7, r0, r1
 101594a:	42bc      	cmp	r4, r7
 101594c:	d101      	bne.n	1015952 <char_out+0x12>
}
 101594e:	4628      	mov	r0, r5
 1015950:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		uart_poll_out(dev, data[i]);
 1015952:	f814 1b01 	ldrb.w	r1, [r4], #1
 1015956:	68b3      	ldr	r3, [r6, #8]
 1015958:	4630      	mov	r0, r6
 101595a:	685b      	ldr	r3, [r3, #4]
 101595c:	4798      	blx	r3
	for (size_t i = 0; i < length; i++) {
 101595e:	e7f4      	b.n	101594a <char_out+0xa>

01015960 <get_status>:
	if (data->started) {
 1015960:	220c      	movs	r2, #12
	data = get_sub_data(dev, type);
 1015962:	68c3      	ldr	r3, [r0, #12]
	return &data->subsys[type];
 1015964:	b2c9      	uxtb	r1, r1
	if (data->started) {
 1015966:	fb02 3101 	mla	r1, r2, r1, r3
 101596a:	7a4b      	ldrb	r3, [r1, #9]
 101596c:	b923      	cbnz	r3, 1015978 <get_status+0x18>
	if (data->ref > 0) {
 101596e:	7a08      	ldrb	r0, [r1, #8]
		return CLOCK_CONTROL_STATUS_ON;
 1015970:	fab0 f080 	clz	r0, r0
 1015974:	0940      	lsrs	r0, r0, #5
 1015976:	4770      	bx	lr
 1015978:	2002      	movs	r0, #2
}
 101597a:	4770      	bx	lr

0101597c <clock_stop>:
{
 101597c:	b570      	push	{r4, r5, r6, lr}
 101597e:	b2c9      	uxtb	r1, r1
	config = get_sub_config(dev, type);
 1015980:	6844      	ldr	r4, [r0, #4]
	data = get_sub_data(dev, type);
 1015982:	68c5      	ldr	r5, [r0, #12]
	__asm__ volatile(
 1015984:	f04f 0320 	mov.w	r3, #32
 1015988:	f3ef 8611 	mrs	r6, BASEPRI
 101598c:	f383 8811 	msr	BASEPRI, r3
 1015990:	f3bf 8f6f 	isb	sy
	if (data->ref == 0) {
 1015994:	230c      	movs	r3, #12
 1015996:	434b      	muls	r3, r1
 1015998:	18ea      	adds	r2, r5, r3
 101599a:	7a10      	ldrb	r0, [r2, #8]
 101599c:	b1a0      	cbz	r0, 10159c8 <clock_stop+0x4c>
	data->ref--;
 101599e:	3801      	subs	r0, #1
 10159a0:	b2c0      	uxtb	r0, r0
 10159a2:	7210      	strb	r0, [r2, #8]
	if (data->ref == 0) {
 10159a4:	b998      	cbnz	r0, 10159ce <clock_stop+0x52>
		nrf_clock_task_trigger(NRF_CLOCK, config->stop_tsk);
 10159a6:	eb04 01c1 	add.w	r1, r4, r1, lsl #3
	list->head = NULL;
 10159aa:	50e8      	str	r0, [r5, r3]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 10159ac:	78cb      	ldrb	r3, [r1, #3]
 10159ae:	2101      	movs	r1, #1
 10159b0:	f103 4382 	add.w	r3, r3, #1090519040	; 0x41000000
 10159b4:	f503 43a0 	add.w	r3, r3, #20480	; 0x5000
	list->tail = NULL;
 10159b8:	6050      	str	r0, [r2, #4]
 10159ba:	6019      	str	r1, [r3, #0]
		data->started = false;
 10159bc:	7250      	strb	r0, [r2, #9]
	__asm__ volatile(
 10159be:	f386 8811 	msr	BASEPRI, r6
 10159c2:	f3bf 8f6f 	isb	sy
}
 10159c6:	bd70      	pop	{r4, r5, r6, pc}
		err = -EALREADY;
 10159c8:	f06f 0044 	mvn.w	r0, #68	; 0x44
 10159cc:	e7f7      	b.n	10159be <clock_stop+0x42>
	int err = 0;
 10159ce:	2000      	movs	r0, #0
 10159d0:	e7f5      	b.n	10159be <clock_stop+0x42>

010159d2 <clock_start>:
	return clock_async_start(dev, sub_system, NULL);
 10159d2:	2200      	movs	r2, #0
 10159d4:	f7ee beb2 	b.w	100473c <clock_async_start>

010159d8 <z_clock_isr>:
/* Weak-linked noop defaults for optional driver interfaces: */

void __weak z_clock_isr(void *arg)
{
	__ASSERT_NO_MSG(false);
}
 10159d8:	4770      	bx	lr

010159da <z_clock_idle_exit>:
{
}

void __weak z_clock_idle_exit(void)
{
}
 10159da:	4770      	bx	lr

010159dc <uECC_make_key>:
	}
	return 0;
}

int uECC_make_key(uint8_t *public_key, uint8_t *private_key, uECC_Curve curve)
{
 10159dc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 10159e0:	4606      	mov	r6, r0
 10159e2:	4688      	mov	r8, r1
 10159e4:	4614      	mov	r4, r2
 10159e6:	2740      	movs	r7, #64	; 0x40
 10159e8:	b0a9      	sub	sp, #164	; 0xa4
			!rng_function((uint8_t *)_random, 2 * NUM_ECC_WORDS*uECC_WORD_SIZE)) {
        		return 0;
		}

		/* computing modular reduction of _random (see FIPS 186.4 B.4.1): */
		uECC_vli_mmod(_private, _random, curve->n, BITS_TO_WORDS(curve->num_n_bits));
 10159ea:	f102 0924 	add.w	r9, r2, #36	; 0x24
		uECC_RNG_Function rng_function = uECC_get_rng();
 10159ee:	f7ef f86d 	bl	1004acc <uECC_get_rng>
		if (!rng_function ||
 10159f2:	4603      	mov	r3, r0
 10159f4:	2800      	cmp	r0, #0
 10159f6:	d03e      	beq.n	1015a76 <uECC_make_key+0x9a>
			!rng_function((uint8_t *)_random, 2 * NUM_ECC_WORDS*uECC_WORD_SIZE)) {
 10159f8:	2140      	movs	r1, #64	; 0x40
 10159fa:	a808      	add	r0, sp, #32
 10159fc:	4798      	blx	r3
		if (!rng_function ||
 10159fe:	b3d0      	cbz	r0, 1015a76 <uECC_make_key+0x9a>
		uECC_vli_mmod(_private, _random, curve->n, BITS_TO_WORDS(curve->num_n_bits));
 1015a00:	466d      	mov	r5, sp
 1015a02:	f9b4 2002 	ldrsh.w	r2, [r4, #2]
 1015a06:	4628      	mov	r0, r5
 1015a08:	f112 031f 	adds.w	r3, r2, #31
 1015a0c:	bf48      	it	mi
 1015a0e:	f102 033e 	addmi.w	r3, r2, #62	; 0x3e
 1015a12:	a908      	add	r1, sp, #32
 1015a14:	464a      	mov	r2, r9
 1015a16:	f343 1347 	sbfx	r3, r3, #5, #8
 1015a1a:	f000 f9fe 	bl	1015e1a <uECC_vli_mmod>

		/* Computing public-key from private: */
		if (EccPoint_compute_public_key(_public, _private, curve)) {
 1015a1e:	4622      	mov	r2, r4
 1015a20:	4629      	mov	r1, r5
 1015a22:	a818      	add	r0, sp, #96	; 0x60
 1015a24:	f000 fe17 	bl	1016656 <EccPoint_compute_public_key>
 1015a28:	b318      	cbz	r0, 1015a72 <uECC_make_key+0x96>

			/* Converting buffers to correct bit order: */
			uECC_vli_nativeToBytes(private_key,
					       BITS_TO_BYTES(curve->num_n_bits),
 1015a2a:	f9b4 3002 	ldrsh.w	r3, [r4, #2]
			uECC_vli_nativeToBytes(private_key,
 1015a2e:	462a      	mov	r2, r5
 1015a30:	1dd9      	adds	r1, r3, #7
 1015a32:	bf48      	it	mi
 1015a34:	f103 010e 	addmi.w	r1, r3, #14
 1015a38:	4640      	mov	r0, r8
 1015a3a:	10c9      	asrs	r1, r1, #3
 1015a3c:	f000 fe33 	bl	10166a6 <uECC_vli_nativeToBytes>
					       _private);
			uECC_vli_nativeToBytes(public_key,
 1015a40:	4630      	mov	r0, r6
 1015a42:	f994 1001 	ldrsb.w	r1, [r4, #1]
 1015a46:	aa18      	add	r2, sp, #96	; 0x60
 1015a48:	f000 fe2d 	bl	10166a6 <uECC_vli_nativeToBytes>
					       curve->num_bytes,
					       _public);
			uECC_vli_nativeToBytes(public_key + curve->num_bytes,
 1015a4c:	f994 1001 	ldrsb.w	r1, [r4, #1]
 					       curve->num_bytes,
					       _public + curve->num_words);
 1015a50:	f994 2000 	ldrsb.w	r2, [r4]
			uECC_vli_nativeToBytes(public_key + curve->num_bytes,
 1015a54:	ab18      	add	r3, sp, #96	; 0x60
 1015a56:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 1015a5a:	1870      	adds	r0, r6, r1
 1015a5c:	f000 fe23 	bl	10166a6 <uECC_vli_nativeToBytes>
#ifdef TINYCRYPT_ARCH_HAS_SET_SECURE
extern void _set_secure(void *to, uint8_t val, unsigned int len);
#else /* ! TINYCRYPT_ARCH_HAS_SET_SECURE */
static inline void _set_secure(void *to, uint8_t val, unsigned int len)
{
  (void) memset(to, val, len);
 1015a60:	2220      	movs	r2, #32
 1015a62:	2100      	movs	r1, #0
 1015a64:	4628      	mov	r0, r5
 1015a66:	f000 ff52 	bl	101690e <memset>

			/* erasing temporary buffer that stored secret: */
			_set_secure(_private, 0, NUM_ECC_BYTES);

      			return 1;
 1015a6a:	2001      	movs	r0, #1
    		}
  	}
	return 0;
}
 1015a6c:	b029      	add	sp, #164	; 0xa4
 1015a6e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
	for (tries = 0; tries < uECC_RNG_MAX_TRIES; ++tries) {
 1015a72:	3f01      	subs	r7, #1
 1015a74:	d1bb      	bne.n	10159ee <uECC_make_key+0x12>
        		return 0;
 1015a76:	2000      	movs	r0, #0
 1015a78:	e7f8      	b.n	1015a6c <uECC_make_key+0x90>

01015a7a <uECC_shared_secret>:

int uECC_shared_secret(const uint8_t *public_key, const uint8_t *private_key,
		       uint8_t *secret, uECC_Curve curve)
{
 1015a7a:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1015a7e:	4681      	mov	r9, r0
 1015a80:	461c      	mov	r4, r3
	uECC_word_t tmp[NUM_ECC_WORDS];
	uECC_word_t *p2[2] = {_private, tmp};
	uECC_word_t *initial_Z = 0;
	uECC_word_t carry;
	wordcount_t num_words = curve->num_words;
	wordcount_t num_bytes = curve->num_bytes;
 1015a82:	f993 7001 	ldrsb.w	r7, [r3, #1]
	wordcount_t num_words = curve->num_words;
 1015a86:	f993 a000 	ldrsb.w	sl, [r3]
	int r;

	/* Converting buffers to correct bit order: */
	uECC_vli_bytesToNative(_private,
      			       private_key,
			       BITS_TO_BYTES(curve->num_n_bits));
 1015a8a:	f9b3 3002 	ldrsh.w	r3, [r3, #2]
{
 1015a8e:	b0a4      	sub	sp, #144	; 0x90
 1015a90:	4690      	mov	r8, r2
	uECC_vli_bytesToNative(_private,
 1015a92:	1dda      	adds	r2, r3, #7
 1015a94:	bf48      	it	mi
 1015a96:	f103 020e 	addmi.w	r2, r3, #14
	uECC_word_t *p2[2] = {_private, tmp};
 1015a9a:	ad04      	add	r5, sp, #16
	uECC_vli_bytesToNative(_private,
 1015a9c:	4628      	mov	r0, r5
	uECC_word_t *p2[2] = {_private, tmp};
 1015a9e:	ae0c      	add	r6, sp, #48	; 0x30
	uECC_vli_bytesToNative(_private,
 1015aa0:	10d2      	asrs	r2, r2, #3
	uECC_word_t *p2[2] = {_private, tmp};
 1015aa2:	9502      	str	r5, [sp, #8]
 1015aa4:	9603      	str	r6, [sp, #12]
	uECC_vli_bytesToNative(_private,
 1015aa6:	f000 fe12 	bl	10166ce <uECC_vli_bytesToNative>
	uECC_vli_bytesToNative(_public,
 1015aaa:	463a      	mov	r2, r7
 1015aac:	4649      	mov	r1, r9
 1015aae:	a814      	add	r0, sp, #80	; 0x50
 1015ab0:	f000 fe0d 	bl	10166ce <uECC_vli_bytesToNative>
      			       public_key,
			       num_bytes);
	uECC_vli_bytesToNative(_public + num_words,
 1015ab4:	ab14      	add	r3, sp, #80	; 0x50
 1015ab6:	eb09 0107 	add.w	r1, r9, r7
 1015aba:	eb03 008a 	add.w	r0, r3, sl, lsl #2
 1015abe:	463a      	mov	r2, r7
 1015ac0:	f000 fe05 	bl	10166ce <uECC_vli_bytesToNative>
			       public_key + num_bytes,
			       num_bytes);

	/* Regularize the bitcount for the private key so that attackers cannot use a
	 * side channel attack to learn the number of leading zeros. */
	carry = regularize_k(_private, _private, tmp, curve);
 1015ac4:	4623      	mov	r3, r4
 1015ac6:	4632      	mov	r2, r6
 1015ac8:	4629      	mov	r1, r5
 1015aca:	4628      	mov	r0, r5
 1015acc:	f000 fd97 	bl	10165fe <regularize_k>
			goto clear_and_out;
    		}
    		initial_Z = p2[carry];
  	}

	EccPoint_mult(_public, _public, p2[!carry], initial_Z, curve->num_n_bits + 1,
 1015ad0:	fab0 f080 	clz	r0, r0
 1015ad4:	9401      	str	r4, [sp, #4]
 1015ad6:	ab24      	add	r3, sp, #144	; 0x90
 1015ad8:	0940      	lsrs	r0, r0, #5
 1015ada:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 1015ade:	8863      	ldrh	r3, [r4, #2]
 1015ae0:	a914      	add	r1, sp, #80	; 0x50
 1015ae2:	3301      	adds	r3, #1
 1015ae4:	b21b      	sxth	r3, r3
 1015ae6:	9300      	str	r3, [sp, #0]
 1015ae8:	f850 2c88 	ldr.w	r2, [r0, #-136]
 1015aec:	2300      	movs	r3, #0
 1015aee:	4608      	mov	r0, r1
 1015af0:	f000 fcb6 	bl	1016460 <EccPoint_mult>
		      curve);

	uECC_vli_nativeToBytes(secret, num_bytes, _public);
 1015af4:	aa14      	add	r2, sp, #80	; 0x50
 1015af6:	4639      	mov	r1, r7
 1015af8:	4640      	mov	r0, r8
 1015afa:	f000 fdd4 	bl	10166a6 <uECC_vli_nativeToBytes>
	r = !EccPoint_isZero(_public, curve);
 1015afe:	4621      	mov	r1, r4
 1015b00:	a814      	add	r0, sp, #80	; 0x50
 1015b02:	f000 fc22 	bl	101634a <EccPoint_isZero>
 1015b06:	af02      	add	r7, sp, #8
 1015b08:	4604      	mov	r4, r0
 1015b0a:	2208      	movs	r2, #8
 1015b0c:	2100      	movs	r1, #0
 1015b0e:	4638      	mov	r0, r7
 1015b10:	f000 fefd 	bl	101690e <memset>
 1015b14:	2220      	movs	r2, #32
 1015b16:	2100      	movs	r1, #0
 1015b18:	4630      	mov	r0, r6
 1015b1a:	f000 fef8 	bl	101690e <memset>
 1015b1e:	2220      	movs	r2, #32
 1015b20:	2100      	movs	r1, #0
 1015b22:	4628      	mov	r0, r5
 1015b24:	f000 fef3 	bl	101690e <memset>
	_set_secure(p2, 0, sizeof(p2));
	_set_secure(tmp, 0, sizeof(tmp));
	_set_secure(_private, 0, sizeof(_private));

	return r;
}
 1015b28:	fab4 f084 	clz	r0, r4
 1015b2c:	0940      	lsrs	r0, r0, #5
 1015b2e:	b024      	add	sp, #144	; 0x90
 1015b30:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

01015b34 <uECC_vli_add>:
{
 1015b34:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0; i < num_words; ++i) {
 1015b36:	2400      	movs	r4, #0
{
 1015b38:	4606      	mov	r6, r0
	uECC_word_t carry = 0;
 1015b3a:	4620      	mov	r0, r4
	for (i = 0; i < num_words; ++i) {
 1015b3c:	b265      	sxtb	r5, r4
 1015b3e:	42ab      	cmp	r3, r5
 1015b40:	dc00      	bgt.n	1015b44 <uECC_vli_add+0x10>
}
 1015b42:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uECC_word_t sum = left[i] + right[i] + carry;
 1015b44:	f851 7024 	ldr.w	r7, [r1, r4, lsl #2]
 1015b48:	f852 5024 	ldr.w	r5, [r2, r4, lsl #2]
 1015b4c:	443d      	add	r5, r7
 1015b4e:	4405      	add	r5, r0
		carry = cond_set(val, carry, (sum != left[i]));
 1015b50:	42af      	cmp	r7, r5
		uECC_word_t val = (sum < left[i]);
 1015b52:	bf8c      	ite	hi
 1015b54:	2701      	movhi	r7, #1
 1015b56:	2700      	movls	r7, #0
		result[i] = sum;
 1015b58:	f846 5024 	str.w	r5, [r6, r4, lsl #2]
	return (p_true*(cond)) | (p_false*(!cond));
 1015b5c:	bf18      	it	ne
 1015b5e:	4638      	movne	r0, r7
	for (i = 0; i < num_words; ++i) {
 1015b60:	3401      	adds	r4, #1
 1015b62:	e7eb      	b.n	1015b3c <uECC_vli_add+0x8>

01015b64 <uECC_vli_rshift1>:
	uECC_word_t carry = 0;
 1015b64:	2300      	movs	r3, #0
	vli += num_words;
 1015b66:	eb00 0181 	add.w	r1, r0, r1, lsl #2
	while (vli-- > end) {
 1015b6a:	4288      	cmp	r0, r1
 1015b6c:	d300      	bcc.n	1015b70 <uECC_vli_rshift1+0xc>
}
 1015b6e:	4770      	bx	lr
		uECC_word_t temp = *vli;
 1015b70:	f851 2d04 	ldr.w	r2, [r1, #-4]!
		*vli = (temp >> 1) | carry;
 1015b74:	ea43 0352 	orr.w	r3, r3, r2, lsr #1
 1015b78:	600b      	str	r3, [r1, #0]
		carry = temp << (uECC_WORD_BITS - 1);
 1015b7a:	07d3      	lsls	r3, r2, #31
 1015b7c:	e7f5      	b.n	1015b6a <uECC_vli_rshift1+0x6>

01015b7e <vli_modInv_update>:
	if (!EVEN(uv)) {
 1015b7e:	6803      	ldr	r3, [r0, #0]
{
 1015b80:	b570      	push	{r4, r5, r6, lr}
	if (!EVEN(uv)) {
 1015b82:	f013 0601 	ands.w	r6, r3, #1
{
 1015b86:	4605      	mov	r5, r0
 1015b88:	4614      	mov	r4, r2
	if (!EVEN(uv)) {
 1015b8a:	d005      	beq.n	1015b98 <vli_modInv_update+0x1a>
		carry = uECC_vli_add(uv, uv, mod, num_words);
 1015b8c:	4613      	mov	r3, r2
 1015b8e:	460a      	mov	r2, r1
 1015b90:	4601      	mov	r1, r0
 1015b92:	f7ff ffcf 	bl	1015b34 <uECC_vli_add>
 1015b96:	4606      	mov	r6, r0
	uECC_vli_rshift1(uv, num_words);
 1015b98:	4621      	mov	r1, r4
 1015b9a:	4628      	mov	r0, r5
 1015b9c:	f7ff ffe2 	bl	1015b64 <uECC_vli_rshift1>
	if (carry) {
 1015ba0:	b146      	cbz	r6, 1015bb4 <vli_modInv_update+0x36>
		uv[num_words - 1] |= HIGH_BIT_SET;
 1015ba2:	f104 4280 	add.w	r2, r4, #1073741824	; 0x40000000
 1015ba6:	3a01      	subs	r2, #1
 1015ba8:	f855 3022 	ldr.w	r3, [r5, r2, lsl #2]
 1015bac:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 1015bb0:	f845 3022 	str.w	r3, [r5, r2, lsl #2]
}
 1015bb4:	bd70      	pop	{r4, r5, r6, pc}

01015bb6 <uECC_vli_mult>:
{
 1015bb6:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (k = 0; k < num_words; ++k) {
 1015bba:	2500      	movs	r5, #0
{
 1015bbc:	b087      	sub	sp, #28
 1015bbe:	e9cd 1200 	strd	r1, r2, [sp]
	uECC_word_t r1 = 0;
 1015bc2:	462c      	mov	r4, r5
	uECC_word_t r0 = 0;
 1015bc4:	462a      	mov	r2, r5
	for (k = 0; k < num_words; ++k) {
 1015bc6:	fa4f f885 	sxtb.w	r8, r5
 1015bca:	4543      	cmp	r3, r8
 1015bcc:	dc14      	bgt.n	1015bf8 <uECC_vli_mult+0x42>
	for (k = num_words; k < num_words * 2 - 1; ++k) {
 1015bce:	f04f 0a00 	mov.w	sl, #0
 1015bd2:	005d      	lsls	r5, r3, #1
 1015bd4:	3d01      	subs	r5, #1
 1015bd6:	9502      	str	r5, [sp, #8]
 1015bd8:	fa5f f58a 	uxtb.w	r5, sl
 1015bdc:	9e02      	ldr	r6, [sp, #8]
 1015bde:	eb05 0c03 	add.w	ip, r5, r3
 1015be2:	fa4f fc8c 	sxtb.w	ip, ip
 1015be6:	45b4      	cmp	ip, r6
 1015be8:	db2d      	blt.n	1015c46 <uECC_vli_mult+0x90>
	result[num_words * 2 - 1] = r0;
 1015bea:	eb00 00c3 	add.w	r0, r0, r3, lsl #3
 1015bee:	f840 2c04 	str.w	r2, [r0, #-4]
}
 1015bf2:	b007      	add	sp, #28
 1015bf4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	for (k = 0; k < num_words; ++k) {
 1015bf8:	f04f 0c00 	mov.w	ip, #0
 1015bfc:	46e6      	mov	lr, ip
 1015bfe:	9e01      	ldr	r6, [sp, #4]
 1015c00:	eb06 0985 	add.w	r9, r6, r5, lsl #2
	uECC_dword_t p = (uECC_dword_t)a * b;
 1015c04:	9900      	ldr	r1, [sp, #0]
			muladd(left[i], right[k - i], &r0, &r1, &r2);
 1015c06:	f859 7904 	ldr.w	r7, [r9], #-4
	uECC_dword_t p = (uECC_dword_t)a * b;
 1015c0a:	f851 602c 	ldr.w	r6, [r1, ip, lsl #2]
	uECC_dword_t r01 = ((uECC_dword_t)(*r1) << uECC_WORD_BITS) | *r0;
 1015c0e:	e9cd 2402 	strd	r2, r4, [sp, #8]
	uECC_dword_t p = (uECC_dword_t)a * b;
 1015c12:	fba7 ab06 	umull	sl, fp, r7, r6
 1015c16:	e9dd 1202 	ldrd	r1, r2, [sp, #8]
 1015c1a:	eb1a 0601 	adds.w	r6, sl, r1
 1015c1e:	eb5b 0702 	adcs.w	r7, fp, r2
 1015c22:	bf2c      	ite	cs
 1015c24:	2201      	movcs	r2, #1
 1015c26:	2200      	movcc	r2, #0
	*r2 += (r01 < p);
 1015c28:	f10c 0c01 	add.w	ip, ip, #1
		for (i = 0; i <= k; ++i) {
 1015c2c:	fa4f fa8c 	sxtb.w	sl, ip
 1015c30:	45c2      	cmp	sl, r8
	*r2 += (r01 < p);
 1015c32:	4496      	add	lr, r2
	*r1 = r01 >> uECC_WORD_BITS;
 1015c34:	463c      	mov	r4, r7
	*r0 = (uECC_word_t)r01;
 1015c36:	4632      	mov	r2, r6
		for (i = 0; i <= k; ++i) {
 1015c38:	dde4      	ble.n	1015c04 <uECC_vli_mult+0x4e>
		result[k] = r0;
 1015c3a:	f840 6025 	str.w	r6, [r0, r5, lsl #2]
	*r1 = r01 >> uECC_WORD_BITS;
 1015c3e:	463a      	mov	r2, r7
	*r2 += (r01 < p);
 1015c40:	4674      	mov	r4, lr
 1015c42:	3501      	adds	r5, #1
 1015c44:	e7bf      	b.n	1015bc6 <uECC_vli_mult+0x10>
		for (i = (k + 1) - num_words; i < num_words; ++i) {
 1015c46:	9900      	ldr	r1, [sp, #0]
 1015c48:	3501      	adds	r5, #1
 1015c4a:	b26d      	sxtb	r5, r5
 1015c4c:	eb01 0b85 	add.w	fp, r1, r5, lsl #2
 1015c50:	4621      	mov	r1, r4
 1015c52:	2400      	movs	r4, #0
 1015c54:	9e01      	ldr	r6, [sp, #4]
 1015c56:	ebac 0e05 	sub.w	lr, ip, r5
 1015c5a:	eb06 0e8e 	add.w	lr, r6, lr, lsl #2
 1015c5e:	429d      	cmp	r5, r3
 1015c60:	db05      	blt.n	1015c6e <uECC_vli_mult+0xb8>
		result[k] = r0;
 1015c62:	f840 202c 	str.w	r2, [r0, ip, lsl #2]
	for (k = num_words; k < num_words * 2 - 1; ++k) {
 1015c66:	f10a 0a01 	add.w	sl, sl, #1
		result[k] = r0;
 1015c6a:	460a      	mov	r2, r1
 1015c6c:	e7b4      	b.n	1015bd8 <uECC_vli_mult+0x22>
			muladd(left[i], right[k - i], &r0, &r1, &r2);
 1015c6e:	f85b 7b04 	ldr.w	r7, [fp], #4
 1015c72:	f85e 6904 	ldr.w	r6, [lr], #-4
	uECC_dword_t r01 = ((uECC_dword_t)(*r1) << uECC_WORD_BITS) | *r0;
 1015c76:	e9cd 2104 	strd	r2, r1, [sp, #16]
	uECC_dword_t p = (uECC_dword_t)a * b;
 1015c7a:	fba7 6706 	umull	r6, r7, r7, r6
 1015c7e:	e9dd 1204 	ldrd	r1, r2, [sp, #16]
 1015c82:	eb16 0801 	adds.w	r8, r6, r1
 1015c86:	eb57 0902 	adcs.w	r9, r7, r2
 1015c8a:	bf2c      	ite	cs
 1015c8c:	2201      	movcs	r2, #1
 1015c8e:	2200      	movcc	r2, #0
		for (i = (k + 1) - num_words; i < num_words; ++i) {
 1015c90:	3501      	adds	r5, #1
	*r2 += (r01 < p);
 1015c92:	4414      	add	r4, r2
	*r1 = r01 >> uECC_WORD_BITS;
 1015c94:	4649      	mov	r1, r9
	*r0 = (uECC_word_t)r01;
 1015c96:	4642      	mov	r2, r8
		for (i = (k + 1) - num_words; i < num_words; ++i) {
 1015c98:	b26d      	sxtb	r5, r5
 1015c9a:	e7e0      	b.n	1015c5e <uECC_vli_mult+0xa8>

01015c9c <uECC_vli_clear>:
	for (i = 0; i < num_words; ++i) {
 1015c9c:	2300      	movs	r3, #0
{
 1015c9e:	b510      	push	{r4, lr}
		 vli[i] = 0;
 1015ca0:	461c      	mov	r4, r3
	for (i = 0; i < num_words; ++i) {
 1015ca2:	b25a      	sxtb	r2, r3
 1015ca4:	4291      	cmp	r1, r2
 1015ca6:	dc00      	bgt.n	1015caa <uECC_vli_clear+0xe>
}
 1015ca8:	bd10      	pop	{r4, pc}
		 vli[i] = 0;
 1015caa:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
	for (i = 0; i < num_words; ++i) {
 1015cae:	3301      	adds	r3, #1
 1015cb0:	e7f7      	b.n	1015ca2 <uECC_vli_clear+0x6>

01015cb2 <uECC_vli_isZero>:
	for (i = 0; i < num_words; ++i) {
 1015cb2:	2300      	movs	r3, #0
	uECC_word_t bits = 0;
 1015cb4:	461a      	mov	r2, r3
{
 1015cb6:	b510      	push	{r4, lr}
	for (i = 0; i < num_words; ++i) {
 1015cb8:	b25c      	sxtb	r4, r3
 1015cba:	42a1      	cmp	r1, r4
 1015cbc:	dc03      	bgt.n	1015cc6 <uECC_vli_isZero+0x14>
}
 1015cbe:	fab2 f082 	clz	r0, r2
 1015cc2:	0940      	lsrs	r0, r0, #5
 1015cc4:	bd10      	pop	{r4, pc}
		bits |= vli[i];
 1015cc6:	f850 4023 	ldr.w	r4, [r0, r3, lsl #2]
 1015cca:	3301      	adds	r3, #1
 1015ccc:	4322      	orrs	r2, r4
	for (i = 0; i < num_words; ++i) {
 1015cce:	e7f3      	b.n	1015cb8 <uECC_vli_isZero+0x6>

01015cd0 <uECC_vli_testBit>:
		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
 1015cd0:	2301      	movs	r3, #1
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
 1015cd2:	114a      	asrs	r2, r1, #5
 1015cd4:	f850 0022 	ldr.w	r0, [r0, r2, lsl #2]
		((uECC_word_t)1 << (bit & uECC_WORD_BITS_MASK)));
 1015cd8:	f001 011f 	and.w	r1, r1, #31
 1015cdc:	fa03 f101 	lsl.w	r1, r3, r1
}
 1015ce0:	4008      	ands	r0, r1
 1015ce2:	4770      	bx	lr

01015ce4 <uECC_vli_numBits>:
{
 1015ce4:	4603      	mov	r3, r0
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
 1015ce6:	3901      	subs	r1, #1
 1015ce8:	b249      	sxtb	r1, r1
 1015cea:	eb00 0281 	add.w	r2, r0, r1, lsl #2
 1015cee:	2900      	cmp	r1, #0
 1015cf0:	da03      	bge.n	1015cfa <uECC_vli_numBits+0x16>
	return (i + 1);
 1015cf2:	3101      	adds	r1, #1
 1015cf4:	b248      	sxtb	r0, r1
	if (num_digits == 0) {
 1015cf6:	b938      	cbnz	r0, 1015d08 <uECC_vli_numBits+0x24>
 1015cf8:	4770      	bx	lr
	for (i = max_words - 1; i >= 0 && vli[i] == 0; --i) {
 1015cfa:	f852 0904 	ldr.w	r0, [r2], #-4
 1015cfe:	2800      	cmp	r0, #0
 1015d00:	d1f7      	bne.n	1015cf2 <uECC_vli_numBits+0xe>
 1015d02:	3901      	subs	r1, #1
 1015d04:	b249      	sxtb	r1, r1
 1015d06:	e7f2      	b.n	1015cee <uECC_vli_numBits+0xa>
	for (i = 0; digit; ++i) {
 1015d08:	2100      	movs	r1, #0
	digit = vli[num_digits - 1];
 1015d0a:	f100 4280 	add.w	r2, r0, #1073741824	; 0x40000000
 1015d0e:	3a01      	subs	r2, #1
 1015d10:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
	for (i = 0; digit; ++i) {
 1015d14:	b923      	cbnz	r3, 1015d20 <uECC_vli_numBits+0x3c>
	return (((bitcount_t)(num_digits - 1) << uECC_WORD_BITS_SHIFT) + i);
 1015d16:	3801      	subs	r0, #1
 1015d18:	eb01 1040 	add.w	r0, r1, r0, lsl #5
 1015d1c:	b200      	sxth	r0, r0
}
 1015d1e:	4770      	bx	lr
		digit >>= 1;
 1015d20:	085b      	lsrs	r3, r3, #1
	for (i = 0; digit; ++i) {
 1015d22:	3101      	adds	r1, #1
 1015d24:	e7f6      	b.n	1015d14 <uECC_vli_numBits+0x30>

01015d26 <uECC_vli_set>:
	for (i = 0; i < num_words; ++i) {
 1015d26:	2300      	movs	r3, #0
{
 1015d28:	b510      	push	{r4, lr}
	for (i = 0; i < num_words; ++i) {
 1015d2a:	b25c      	sxtb	r4, r3
 1015d2c:	42a2      	cmp	r2, r4
 1015d2e:	dc00      	bgt.n	1015d32 <uECC_vli_set+0xc>
}
 1015d30:	bd10      	pop	{r4, pc}
		dest[i] = src[i];
 1015d32:	f851 4023 	ldr.w	r4, [r1, r3, lsl #2]
 1015d36:	f840 4023 	str.w	r4, [r0, r3, lsl #2]
	for (i = 0; i < num_words; ++i) {
 1015d3a:	3301      	adds	r3, #1
 1015d3c:	e7f5      	b.n	1015d2a <uECC_vli_set+0x4>

01015d3e <uECC_vli_cmp_unsafe>:
{
 1015d3e:	b530      	push	{r4, r5, lr}
	for (i = num_words - 1; i >= 0; --i) {
 1015d40:	3a01      	subs	r2, #1
 1015d42:	b252      	sxtb	r2, r2
 1015d44:	0093      	lsls	r3, r2, #2
 1015d46:	2a00      	cmp	r2, #0
 1015d48:	da01      	bge.n	1015d4e <uECC_vli_cmp_unsafe+0x10>
	return 0;
 1015d4a:	2000      	movs	r0, #0
}
 1015d4c:	bd30      	pop	{r4, r5, pc}
		if (left[i] > right[i]) {
 1015d4e:	58c5      	ldr	r5, [r0, r3]
 1015d50:	58cc      	ldr	r4, [r1, r3]
 1015d52:	42a5      	cmp	r5, r4
 1015d54:	d805      	bhi.n	1015d62 <uECC_vli_cmp_unsafe+0x24>
		} else if (left[i] < right[i]) {
 1015d56:	f1a3 0304 	sub.w	r3, r3, #4
 1015d5a:	d304      	bcc.n	1015d66 <uECC_vli_cmp_unsafe+0x28>
	for (i = num_words - 1; i >= 0; --i) {
 1015d5c:	3a01      	subs	r2, #1
 1015d5e:	b252      	sxtb	r2, r2
 1015d60:	e7f1      	b.n	1015d46 <uECC_vli_cmp_unsafe+0x8>
			return 1;
 1015d62:	2001      	movs	r0, #1
 1015d64:	e7f2      	b.n	1015d4c <uECC_vli_cmp_unsafe+0xe>
			return -1;
 1015d66:	f04f 30ff 	mov.w	r0, #4294967295
 1015d6a:	e7ef      	b.n	1015d4c <uECC_vli_cmp_unsafe+0xe>

01015d6c <uECC_vli_equal>:
{
 1015d6c:	b570      	push	{r4, r5, r6, lr}
	uECC_word_t diff = 0;
 1015d6e:	2400      	movs	r4, #0
	for (i = num_words - 1; i >= 0; --i) {
 1015d70:	3a01      	subs	r2, #1
 1015d72:	b252      	sxtb	r2, r2
 1015d74:	0093      	lsls	r3, r2, #2
 1015d76:	2a00      	cmp	r2, #0
 1015d78:	da03      	bge.n	1015d82 <uECC_vli_equal+0x16>
}
 1015d7a:	1e20      	subs	r0, r4, #0
 1015d7c:	bf18      	it	ne
 1015d7e:	2001      	movne	r0, #1
 1015d80:	bd70      	pop	{r4, r5, r6, pc}
		diff |= (left[i] ^ right[i]);
 1015d82:	58c5      	ldr	r5, [r0, r3]
 1015d84:	58ce      	ldr	r6, [r1, r3]
	for (i = num_words - 1; i >= 0; --i) {
 1015d86:	3a01      	subs	r2, #1
		diff |= (left[i] ^ right[i]);
 1015d88:	4075      	eors	r5, r6
 1015d8a:	432c      	orrs	r4, r5
	for (i = num_words - 1; i >= 0; --i) {
 1015d8c:	b252      	sxtb	r2, r2
 1015d8e:	3b04      	subs	r3, #4
 1015d90:	e7f1      	b.n	1015d76 <uECC_vli_equal+0xa>

01015d92 <uECC_vli_sub>:
{
 1015d92:	b5f0      	push	{r4, r5, r6, r7, lr}
	for (i = 0; i < num_words; ++i) {
 1015d94:	2400      	movs	r4, #0
{
 1015d96:	4606      	mov	r6, r0
 1015d98:	469c      	mov	ip, r3
	uECC_word_t borrow = 0;
 1015d9a:	4620      	mov	r0, r4
	for (i = 0; i < num_words; ++i) {
 1015d9c:	b265      	sxtb	r5, r4
 1015d9e:	45ac      	cmp	ip, r5
 1015da0:	dc00      	bgt.n	1015da4 <uECC_vli_sub+0x12>
}
 1015da2:	bdf0      	pop	{r4, r5, r6, r7, pc}
		uECC_word_t diff = left[i] - right[i] - borrow;
 1015da4:	f851 7024 	ldr.w	r7, [r1, r4, lsl #2]
 1015da8:	f852 3024 	ldr.w	r3, [r2, r4, lsl #2]
 1015dac:	1a3d      	subs	r5, r7, r0
 1015dae:	1aed      	subs	r5, r5, r3
		borrow = cond_set(val, borrow, (diff != left[i]));
 1015db0:	42af      	cmp	r7, r5
		uECC_word_t val = (diff > left[i]);
 1015db2:	bf34      	ite	cc
 1015db4:	2701      	movcc	r7, #1
 1015db6:	2700      	movcs	r7, #0
		result[i] = diff;
 1015db8:	f846 5024 	str.w	r5, [r6, r4, lsl #2]
	return (p_true*(cond)) | (p_false*(!cond));
 1015dbc:	bf18      	it	ne
 1015dbe:	4638      	movne	r0, r7
	for (i = 0; i < num_words; ++i) {
 1015dc0:	3401      	adds	r4, #1
 1015dc2:	e7eb      	b.n	1015d9c <uECC_vli_sub+0xa>

01015dc4 <uECC_vli_modAdd>:
{
 1015dc4:	b570      	push	{r4, r5, r6, lr}
 1015dc6:	f99d 6010 	ldrsb.w	r6, [sp, #16]
 1015dca:	461d      	mov	r5, r3
	uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
 1015dcc:	4633      	mov	r3, r6
{
 1015dce:	4604      	mov	r4, r0
	uECC_word_t carry = uECC_vli_add(result, left, right, num_words);
 1015dd0:	f7ff feb0 	bl	1015b34 <uECC_vli_add>
	if (carry || uECC_vli_cmp_unsafe(mod, result, num_words) != 1) {
 1015dd4:	b930      	cbnz	r0, 1015de4 <uECC_vli_modAdd+0x20>
 1015dd6:	4632      	mov	r2, r6
 1015dd8:	4621      	mov	r1, r4
 1015dda:	4628      	mov	r0, r5
 1015ddc:	f7ff ffaf 	bl	1015d3e <uECC_vli_cmp_unsafe>
 1015de0:	2801      	cmp	r0, #1
 1015de2:	d007      	beq.n	1015df4 <uECC_vli_modAdd+0x30>
		uECC_vli_sub(result, result, mod, num_words);
 1015de4:	4633      	mov	r3, r6
 1015de6:	462a      	mov	r2, r5
 1015de8:	4621      	mov	r1, r4
 1015dea:	4620      	mov	r0, r4
}
 1015dec:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		uECC_vli_sub(result, result, mod, num_words);
 1015df0:	f7ff bfcf 	b.w	1015d92 <uECC_vli_sub>
}
 1015df4:	bd70      	pop	{r4, r5, r6, pc}

01015df6 <uECC_vli_modSub>:
{
 1015df6:	b570      	push	{r4, r5, r6, lr}
 1015df8:	f99d 6010 	ldrsb.w	r6, [sp, #16]
 1015dfc:	461d      	mov	r5, r3
	uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
 1015dfe:	4633      	mov	r3, r6
{
 1015e00:	4604      	mov	r4, r0
	uECC_word_t l_borrow = uECC_vli_sub(result, left, right, num_words);
 1015e02:	f7ff ffc6 	bl	1015d92 <uECC_vli_sub>
	if (l_borrow) {
 1015e06:	b138      	cbz	r0, 1015e18 <uECC_vli_modSub+0x22>
		uECC_vli_add(result, result, mod, num_words);
 1015e08:	4633      	mov	r3, r6
 1015e0a:	462a      	mov	r2, r5
 1015e0c:	4621      	mov	r1, r4
 1015e0e:	4620      	mov	r0, r4
}
 1015e10:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
		uECC_vli_add(result, result, mod, num_words);
 1015e14:	f7ff be8e 	b.w	1015b34 <uECC_vli_add>
}
 1015e18:	bd70      	pop	{r4, r5, r6, pc}

01015e1a <uECC_vli_mmod>:
{
 1015e1a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1015e1e:	461d      	mov	r5, r3
 1015e20:	b0a5      	sub	sp, #148	; 0x94
	uECC_word_t *v[2] = {tmp, product};
 1015e22:	ab14      	add	r3, sp, #80	; 0x50
 1015e24:	e9cd 3102 	strd	r3, r1, [sp, #8]
{
 1015e28:	4680      	mov	r8, r0
			   uECC_vli_numBits(mod, num_words);
 1015e2a:	4629      	mov	r1, r5
 1015e2c:	4610      	mov	r0, r2
{
 1015e2e:	4616      	mov	r6, r2
			   uECC_vli_numBits(mod, num_words);
 1015e30:	f7ff ff58 	bl	1015ce4 <uECC_vli_numBits>
	bitcount_t shift = (num_words * 2 * uECC_WORD_BITS) -
 1015e34:	ebc0 1485 	rsb	r4, r0, r5, lsl #6
 1015e38:	b224      	sxth	r4, r4
	wordcount_t word_shift = shift / uECC_WORD_BITS;
 1015e3a:	4621      	mov	r1, r4
 1015e3c:	2c00      	cmp	r4, #0
 1015e3e:	bfb8      	it	lt
 1015e40:	f104 011f 	addlt.w	r1, r4, #31
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
 1015e44:	4263      	negs	r3, r4
	wordcount_t word_shift = shift / uECC_WORD_BITS;
 1015e46:	f341 1147 	sbfx	r1, r1, #5, #8
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
 1015e4a:	f003 031f 	and.w	r3, r3, #31
	uECC_vli_clear(mod_multiple, word_shift);
 1015e4e:	a804      	add	r0, sp, #16
	wordcount_t bit_shift = shift % uECC_WORD_BITS;
 1015e50:	f004 071f 	and.w	r7, r4, #31
 1015e54:	bf58      	it	pl
 1015e56:	425f      	negpl	r7, r3
	uECC_vli_clear(mod_multiple, word_shift);
 1015e58:	f7ff ff20 	bl	1015c9c <uECC_vli_clear>
	if (bit_shift > 0) {
 1015e5c:	2f00      	cmp	r7, #0
 1015e5e:	ea4f 0081 	mov.w	r0, r1, lsl #2
 1015e62:	dd2c      	ble.n	1015ebe <uECC_vli_mmod+0xa4>
	uECC_word_t carry = 0;
 1015e64:	2200      	movs	r2, #0
 1015e66:	ab04      	add	r3, sp, #16
 1015e68:	1819      	adds	r1, r3, r0
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
 1015e6a:	4613      	mov	r3, r2
			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
 1015e6c:	f1c7 0e20 	rsb	lr, r7, #32
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
 1015e70:	429d      	cmp	r5, r3
 1015e72:	d819      	bhi.n	1015ea8 <uECC_vli_mmod+0x8e>
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
 1015e74:	2601      	movs	r6, #1
		for (i = 0; i < num_words * 2; ++i) {
 1015e76:	006b      	lsls	r3, r5, #1
 1015e78:	9300      	str	r3, [sp, #0]
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
 1015e7a:	00ab      	lsls	r3, r5, #2
 1015e7c:	9301      	str	r3, [sp, #4]
 1015e7e:	ab04      	add	r3, sp, #16
 1015e80:	eb03 0985 	add.w	r9, r3, r5, lsl #2
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
 1015e84:	1e6f      	subs	r7, r5, #1
 1015e86:	ab24      	add	r3, sp, #144	; 0x90
 1015e88:	eb03 0787 	add.w	r7, r3, r7, lsl #2
	for (index = 1; shift >= 0; --shift) {
 1015e8c:	2c00      	cmp	r4, #0
 1015e8e:	da54      	bge.n	1015f3a <uECC_vli_mmod+0x120>
	uECC_vli_set(result, v[index], num_words);
 1015e90:	ab24      	add	r3, sp, #144	; 0x90
 1015e92:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 1015e96:	462a      	mov	r2, r5
 1015e98:	4640      	mov	r0, r8
 1015e9a:	f856 1c88 	ldr.w	r1, [r6, #-136]
 1015e9e:	f7ff ff42 	bl	1015d26 <uECC_vli_set>
}
 1015ea2:	b025      	add	sp, #148	; 0x94
 1015ea4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
			mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
 1015ea8:	f856 c023 	ldr.w	ip, [r6, r3, lsl #2]
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
 1015eac:	3301      	adds	r3, #1
			mod_multiple[word_shift + index] = (mod[index] << bit_shift) | carry;
 1015eae:	fa0c f007 	lsl.w	r0, ip, r7
 1015eb2:	4302      	orrs	r2, r0
 1015eb4:	f841 2b04 	str.w	r2, [r1], #4
			carry = mod[index] >> (uECC_WORD_BITS - bit_shift);
 1015eb8:	fa2c f20e 	lsr.w	r2, ip, lr
		for(index = 0; index < (uECC_word_t)num_words; ++index) {
 1015ebc:	e7d8      	b.n	1015e70 <uECC_vli_mmod+0x56>
		uECC_vli_set(mod_multiple + word_shift, mod, num_words);
 1015ebe:	ab04      	add	r3, sp, #16
 1015ec0:	462a      	mov	r2, r5
 1015ec2:	4631      	mov	r1, r6
 1015ec4:	4418      	add	r0, r3
 1015ec6:	f7ff ff2e 	bl	1015d26 <uECC_vli_set>
 1015eca:	e7d3      	b.n	1015e74 <uECC_vli_mmod+0x5a>
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
 1015ecc:	f85a 3c88 	ldr.w	r3, [sl, #-136]
 1015ed0:	f10c 0c01 	add.w	ip, ip, #1
 1015ed4:	f853 2020 	ldr.w	r2, [r3, r0, lsl #2]
 1015ed8:	ab24      	add	r3, sp, #144	; 0x90
 1015eda:	eb03 0380 	add.w	r3, r3, r0, lsl #2
 1015ede:	f853 3c80 	ldr.w	r3, [r3, #-128]
 1015ee2:	440b      	add	r3, r1
 1015ee4:	1ad3      	subs	r3, r2, r3
 1015ee6:	bf34      	ite	cc
 1015ee8:	f04f 0b01 	movcc.w	fp, #1
 1015eec:	f04f 0b00 	movcs.w	fp, #0
			if (diff != v[index][i]) {
 1015ef0:	429a      	cmp	r2, r3
				borrow = (diff > v[index][i]);
 1015ef2:	bf18      	it	ne
 1015ef4:	4659      	movne	r1, fp
			v[1 - index][i] = diff;
 1015ef6:	f85e 2c88 	ldr.w	r2, [lr, #-136]
 1015efa:	f842 3020 	str.w	r3, [r2, r0, lsl #2]
		for (i = 0; i < num_words * 2; ++i) {
 1015efe:	9b00      	ldr	r3, [sp, #0]
 1015f00:	fa4f f08c 	sxtb.w	r0, ip
 1015f04:	4298      	cmp	r0, r3
 1015f06:	dbe1      	blt.n	1015ecc <uECC_vli_mmod+0xb2>
		index = !(index ^ borrow);
 1015f08:	1a73      	subs	r3, r6, r1
 1015f0a:	425e      	negs	r6, r3
		uECC_vli_rshift1(mod_multiple, num_words);
 1015f0c:	4629      	mov	r1, r5
 1015f0e:	a804      	add	r0, sp, #16
		index = !(index ^ borrow);
 1015f10:	415e      	adcs	r6, r3
		uECC_vli_rshift1(mod_multiple, num_words);
 1015f12:	f7ff fe27 	bl	1015b64 <uECC_vli_rshift1>
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
 1015f16:	9a01      	ldr	r2, [sp, #4]
 1015f18:	ab24      	add	r3, sp, #144	; 0x90
 1015f1a:	4413      	add	r3, r2
 1015f1c:	f853 2c80 	ldr.w	r2, [r3, #-128]
 1015f20:	f857 3c80 	ldr.w	r3, [r7, #-128]
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
 1015f24:	4629      	mov	r1, r5
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
 1015f26:	ea43 73c2 	orr.w	r3, r3, r2, lsl #31
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
 1015f2a:	4648      	mov	r0, r9
	for (index = 1; shift >= 0; --shift) {
 1015f2c:	3c01      	subs	r4, #1
		mod_multiple[num_words - 1] |= mod_multiple[num_words] <<
 1015f2e:	f847 3c80 	str.w	r3, [r7, #-128]
	for (index = 1; shift >= 0; --shift) {
 1015f32:	b224      	sxth	r4, r4
		uECC_vli_rshift1(mod_multiple + num_words, num_words);
 1015f34:	f7ff fe16 	bl	1015b64 <uECC_vli_rshift1>
	for (index = 1; shift >= 0; --shift) {
 1015f38:	e7a8      	b.n	1015e8c <uECC_vli_mmod+0x72>
 1015f3a:	f04f 0c00 	mov.w	ip, #0
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
 1015f3e:	ab24      	add	r3, sp, #144	; 0x90
			v[1 - index][i] = diff;
 1015f40:	f1c6 0e01 	rsb	lr, r6, #1
		uECC_word_t borrow = 0;
 1015f44:	4661      	mov	r1, ip
			uECC_word_t diff = v[index][i] - mod_multiple[i] - borrow;
 1015f46:	eb03 0a86 	add.w	sl, r3, r6, lsl #2
			v[1 - index][i] = diff;
 1015f4a:	eb03 0e8e 	add.w	lr, r3, lr, lsl #2
 1015f4e:	e7d6      	b.n	1015efe <uECC_vli_mmod+0xe4>

01015f50 <uECC_vli_modMult_fast>:
{
 1015f50:	b530      	push	{r4, r5, lr}
 1015f52:	4605      	mov	r5, r0
 1015f54:	461c      	mov	r4, r3
 1015f56:	b091      	sub	sp, #68	; 0x44
	uECC_vli_mult(product, left, right, curve->num_words);
 1015f58:	4668      	mov	r0, sp
 1015f5a:	f993 3000 	ldrsb.w	r3, [r3]
 1015f5e:	f7ff fe2a 	bl	1015bb6 <uECC_vli_mult>
	curve->mmod_fast(result, product);
 1015f62:	4669      	mov	r1, sp
 1015f64:	4628      	mov	r0, r5
 1015f66:	f8d4 30ac 	ldr.w	r3, [r4, #172]	; 0xac
 1015f6a:	4798      	blx	r3
}
 1015f6c:	b011      	add	sp, #68	; 0x44
 1015f6e:	bd30      	pop	{r4, r5, pc}

01015f70 <uECC_vli_modSquare_fast>:
{
 1015f70:	4613      	mov	r3, r2
	uECC_vli_modMult_fast(result, left, left, curve);
 1015f72:	460a      	mov	r2, r1
 1015f74:	f7ff bfec 	b.w	1015f50 <uECC_vli_modMult_fast>

01015f78 <double_jacobian_default>:
{
 1015f78:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
	wordcount_t num_words = curve->num_words;
 1015f7c:	f993 6000 	ldrsb.w	r6, [r3]
{
 1015f80:	4604      	mov	r4, r0
 1015f82:	4689      	mov	r9, r1
 1015f84:	b092      	sub	sp, #72	; 0x48
	if (uECC_vli_isZero(Z1, num_words)) {
 1015f86:	4631      	mov	r1, r6
 1015f88:	4610      	mov	r0, r2
{
 1015f8a:	4615      	mov	r5, r2
 1015f8c:	461f      	mov	r7, r3
	if (uECC_vli_isZero(Z1, num_words)) {
 1015f8e:	f7ff fe90 	bl	1015cb2 <uECC_vli_isZero>
 1015f92:	2800      	cmp	r0, #0
 1015f94:	f040 8091 	bne.w	10160ba <double_jacobian_default+0x142>
	uECC_vli_modSquare_fast(t4, Y1, curve);   /* t4 = y1^2 */
 1015f98:	463a      	mov	r2, r7
 1015f9a:	4649      	mov	r1, r9
 1015f9c:	a802      	add	r0, sp, #8
 1015f9e:	f7ff ffe7 	bl	1015f70 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(t5, X1, t4, curve); /* t5 = x1*y1^2 = A */
 1015fa2:	463b      	mov	r3, r7
 1015fa4:	4621      	mov	r1, r4
 1015fa6:	aa02      	add	r2, sp, #8
 1015fa8:	a80a      	add	r0, sp, #40	; 0x28
 1015faa:	f7ff ffd1 	bl	1015f50 <uECC_vli_modMult_fast>
	uECC_vli_modSquare_fast(t4, t4, curve);   /* t4 = y1^4 */
 1015fae:	a902      	add	r1, sp, #8
 1015fb0:	4608      	mov	r0, r1
 1015fb2:	463a      	mov	r2, r7
 1015fb4:	f7ff ffdc 	bl	1015f70 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(Y1, Y1, Z1, curve); /* t2 = y1*z1 = z3 */
 1015fb8:	463b      	mov	r3, r7
 1015fba:	462a      	mov	r2, r5
 1015fbc:	4649      	mov	r1, r9
 1015fbe:	4648      	mov	r0, r9
 1015fc0:	f7ff ffc6 	bl	1015f50 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
 1015fc4:	f107 0804 	add.w	r8, r7, #4
	uECC_vli_modSquare_fast(Z1, Z1, curve);   /* t3 = z1^2 */
 1015fc8:	463a      	mov	r2, r7
 1015fca:	4629      	mov	r1, r5
 1015fcc:	4628      	mov	r0, r5
 1015fce:	f7ff ffcf 	bl	1015f70 <uECC_vli_modSquare_fast>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = x1 + z1^2 */
 1015fd2:	4643      	mov	r3, r8
 1015fd4:	462a      	mov	r2, r5
 1015fd6:	4621      	mov	r1, r4
 1015fd8:	4620      	mov	r0, r4
 1015fda:	9600      	str	r6, [sp, #0]
 1015fdc:	f7ff fef2 	bl	1015dc4 <uECC_vli_modAdd>
	uECC_vli_modAdd(Z1, Z1, Z1, curve->p, num_words); /* t3 = 2*z1^2 */
 1015fe0:	4643      	mov	r3, r8
 1015fe2:	462a      	mov	r2, r5
 1015fe4:	4629      	mov	r1, r5
 1015fe6:	4628      	mov	r0, r5
 1015fe8:	9600      	str	r6, [sp, #0]
 1015fea:	f7ff feeb 	bl	1015dc4 <uECC_vli_modAdd>
	uECC_vli_modSub(Z1, X1, Z1, curve->p, num_words); /* t3 = x1 - z1^2 */
 1015fee:	4643      	mov	r3, r8
 1015ff0:	462a      	mov	r2, r5
 1015ff2:	4621      	mov	r1, r4
 1015ff4:	4628      	mov	r0, r5
 1015ff6:	9600      	str	r6, [sp, #0]
 1015ff8:	f7ff fefd 	bl	1015df6 <uECC_vli_modSub>
	uECC_vli_modMult_fast(X1, X1, Z1, curve); /* t1 = x1^2 - z1^4 */
 1015ffc:	463b      	mov	r3, r7
 1015ffe:	462a      	mov	r2, r5
 1016000:	4621      	mov	r1, r4
 1016002:	4620      	mov	r0, r4
 1016004:	f7ff ffa4 	bl	1015f50 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(Z1, X1, X1, curve->p, num_words); /* t3 = 2*(x1^2 - z1^4) */
 1016008:	4643      	mov	r3, r8
 101600a:	4622      	mov	r2, r4
 101600c:	4621      	mov	r1, r4
 101600e:	4628      	mov	r0, r5
 1016010:	9600      	str	r6, [sp, #0]
 1016012:	f7ff fed7 	bl	1015dc4 <uECC_vli_modAdd>
	uECC_vli_modAdd(X1, X1, Z1, curve->p, num_words); /* t1 = 3*(x1^2 - z1^4) */
 1016016:	4643      	mov	r3, r8
 1016018:	462a      	mov	r2, r5
 101601a:	4621      	mov	r1, r4
 101601c:	4620      	mov	r0, r4
 101601e:	9600      	str	r6, [sp, #0]
 1016020:	f7ff fed0 	bl	1015dc4 <uECC_vli_modAdd>
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
 1016024:	6823      	ldr	r3, [r4, #0]
	if (uECC_vli_testBit(X1, 0)) {
 1016026:	07db      	lsls	r3, r3, #31
 1016028:	d54a      	bpl.n	10160c0 <double_jacobian_default+0x148>
		uECC_word_t l_carry = uECC_vli_add(X1, X1, curve->p, num_words);
 101602a:	4633      	mov	r3, r6
 101602c:	4642      	mov	r2, r8
 101602e:	4621      	mov	r1, r4
 1016030:	4620      	mov	r0, r4
 1016032:	f7ff fd7f 	bl	1015b34 <uECC_vli_add>
 1016036:	4682      	mov	sl, r0
		uECC_vli_rshift1(X1, num_words);
 1016038:	4631      	mov	r1, r6
 101603a:	4620      	mov	r0, r4
 101603c:	f7ff fd92 	bl	1015b64 <uECC_vli_rshift1>
		X1[num_words - 1] |= l_carry << (uECC_WORD_BITS - 1);
 1016040:	f106 4380 	add.w	r3, r6, #1073741824	; 0x40000000
 1016044:	3b01      	subs	r3, #1
 1016046:	f854 2023 	ldr.w	r2, [r4, r3, lsl #2]
 101604a:	ea42 72ca 	orr.w	r2, r2, sl, lsl #31
 101604e:	f844 2023 	str.w	r2, [r4, r3, lsl #2]
	uECC_vli_modSquare_fast(Z1, X1, curve); /* t3 = B^2 */
 1016052:	463a      	mov	r2, r7
 1016054:	4621      	mov	r1, r4
 1016056:	4628      	mov	r0, r5
 1016058:	f7ff ff8a 	bl	1015f70 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - A */
 101605c:	4643      	mov	r3, r8
 101605e:	4629      	mov	r1, r5
 1016060:	4628      	mov	r0, r5
 1016062:	aa0a      	add	r2, sp, #40	; 0x28
 1016064:	9600      	str	r6, [sp, #0]
 1016066:	f7ff fec6 	bl	1015df6 <uECC_vli_modSub>
	uECC_vli_modSub(Z1, Z1, t5, curve->p, num_words); /* t3 = B^2 - 2A = x3 */
 101606a:	4643      	mov	r3, r8
 101606c:	4629      	mov	r1, r5
 101606e:	4628      	mov	r0, r5
 1016070:	aa0a      	add	r2, sp, #40	; 0x28
 1016072:	9600      	str	r6, [sp, #0]
 1016074:	f7ff febf 	bl	1015df6 <uECC_vli_modSub>
	uECC_vli_modSub(t5, t5, Z1, curve->p, num_words); /* t5 = A - x3 */
 1016078:	a90a      	add	r1, sp, #40	; 0x28
 101607a:	4608      	mov	r0, r1
 101607c:	4643      	mov	r3, r8
 101607e:	462a      	mov	r2, r5
 1016080:	9600      	str	r6, [sp, #0]
 1016082:	f7ff feb8 	bl	1015df6 <uECC_vli_modSub>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = B * (A - x3) */
 1016086:	463b      	mov	r3, r7
 1016088:	4621      	mov	r1, r4
 101608a:	4620      	mov	r0, r4
 101608c:	aa0a      	add	r2, sp, #40	; 0x28
 101608e:	f7ff ff5f 	bl	1015f50 <uECC_vli_modMult_fast>
	uECC_vli_modSub(t4, X1, t4, curve->p, num_words);
 1016092:	aa02      	add	r2, sp, #8
 1016094:	4643      	mov	r3, r8
 1016096:	4610      	mov	r0, r2
 1016098:	4621      	mov	r1, r4
 101609a:	9600      	str	r6, [sp, #0]
 101609c:	f7ff feab 	bl	1015df6 <uECC_vli_modSub>
	uECC_vli_set(X1, Z1, num_words);
 10160a0:	4632      	mov	r2, r6
 10160a2:	4629      	mov	r1, r5
 10160a4:	4620      	mov	r0, r4
 10160a6:	f7ff fe3e 	bl	1015d26 <uECC_vli_set>
	uECC_vli_set(Z1, Y1, num_words);
 10160aa:	4649      	mov	r1, r9
 10160ac:	4628      	mov	r0, r5
 10160ae:	f7ff fe3a 	bl	1015d26 <uECC_vli_set>
	uECC_vli_set(Y1, t4, num_words);
 10160b2:	4648      	mov	r0, r9
 10160b4:	a902      	add	r1, sp, #8
 10160b6:	f7ff fe36 	bl	1015d26 <uECC_vli_set>
}
 10160ba:	b012      	add	sp, #72	; 0x48
 10160bc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
		uECC_vli_rshift1(X1, num_words);
 10160c0:	4631      	mov	r1, r6
 10160c2:	4620      	mov	r0, r4
 10160c4:	f7ff fd4e 	bl	1015b64 <uECC_vli_rshift1>
 10160c8:	e7c3      	b.n	1016052 <double_jacobian_default+0xda>

010160ca <x_side_default>:
{
 10160ca:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 10160ce:	4615      	mov	r5, r2
 10160d0:	b08a      	sub	sp, #40	; 0x28
 10160d2:	4604      	mov	r4, r0
 10160d4:	460e      	mov	r6, r1
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
 10160d6:	221c      	movs	r2, #28
 10160d8:	2100      	movs	r1, #0
 10160da:	a803      	add	r0, sp, #12
 10160dc:	f000 fc17 	bl	101690e <memset>
 10160e0:	2303      	movs	r3, #3
	wordcount_t num_words = curve->num_words;
 10160e2:	f995 8000 	ldrsb.w	r8, [r5]
	uECC_vli_modSquare_fast(result, x, curve); /* r = x^2 */
 10160e6:	462a      	mov	r2, r5
 10160e8:	4631      	mov	r1, r6
 10160ea:	4620      	mov	r0, r4
	uECC_vli_modSub(result, result, _3, curve->p, num_words); /* r = x^2 - 3 */
 10160ec:	1d2f      	adds	r7, r5, #4
	uECC_word_t _3[NUM_ECC_WORDS] = {3}; /* -a = 3 */
 10160ee:	9302      	str	r3, [sp, #8]
	uECC_vli_modSquare_fast(result, x, curve); /* r = x^2 */
 10160f0:	f7ff ff3e 	bl	1015f70 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(result, result, _3, curve->p, num_words); /* r = x^2 - 3 */
 10160f4:	463b      	mov	r3, r7
 10160f6:	4621      	mov	r1, r4
 10160f8:	4620      	mov	r0, r4
 10160fa:	aa02      	add	r2, sp, #8
 10160fc:	f8cd 8000 	str.w	r8, [sp]
 1016100:	f7ff fe79 	bl	1015df6 <uECC_vli_modSub>
	uECC_vli_modMult_fast(result, result, x, curve); /* r = x^3 - 3x */
 1016104:	462b      	mov	r3, r5
 1016106:	4632      	mov	r2, r6
 1016108:	4621      	mov	r1, r4
 101610a:	4620      	mov	r0, r4
 101610c:	f7ff ff20 	bl	1015f50 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(result, result, curve->b, curve->p, num_words);
 1016110:	463b      	mov	r3, r7
 1016112:	4621      	mov	r1, r4
 1016114:	4620      	mov	r0, r4
 1016116:	f8cd 8000 	str.w	r8, [sp]
 101611a:	f105 0284 	add.w	r2, r5, #132	; 0x84
 101611e:	f7ff fe51 	bl	1015dc4 <uECC_vli_modAdd>
}
 1016122:	b00a      	add	sp, #40	; 0x28
 1016124:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

01016128 <XYcZ_addC>:
   or P => P - Q, Q => P + Q
 */
static void XYcZ_addC(uECC_word_t * X1, uECC_word_t * Y1,
		      uECC_word_t * X2, uECC_word_t * Y2,
		      uECC_Curve curve)
{
 1016128:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 101612c:	b09a      	sub	sp, #104	; 0x68
 101612e:	f8dd 8088 	ldr.w	r8, [sp, #136]	; 0x88
 1016132:	4616      	mov	r6, r2
	/* t1 = X1, t2 = Y1, t3 = X2, t4 = Y2 */
	uECC_word_t t5[NUM_ECC_WORDS];
	uECC_word_t t6[NUM_ECC_WORDS];
	uECC_word_t t7[NUM_ECC_WORDS];
	wordcount_t num_words = curve->num_words;
 1016134:	4644      	mov	r4, r8
{
 1016136:	4607      	mov	r7, r0
 1016138:	4699      	mov	r9, r3
 101613a:	468a      	mov	sl, r1
	wordcount_t num_words = curve->num_words;
 101613c:	f914 5b04 	ldrsb.w	r5, [r4], #4

	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
 1016140:	4602      	mov	r2, r0
 1016142:	4623      	mov	r3, r4
 1016144:	4631      	mov	r1, r6
 1016146:	a802      	add	r0, sp, #8
 1016148:	9500      	str	r5, [sp, #0]
 101614a:	f7ff fe54 	bl	1015df6 <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, t5, curve); /* t5 = (x2 - x1)^2 = A */
 101614e:	a902      	add	r1, sp, #8
 1016150:	4642      	mov	r2, r8
 1016152:	4608      	mov	r0, r1
 1016154:	f7ff ff0c 	bl	1015f70 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = x1*A = B */
 1016158:	4643      	mov	r3, r8
 101615a:	4639      	mov	r1, r7
 101615c:	4638      	mov	r0, r7
 101615e:	aa02      	add	r2, sp, #8
 1016160:	f7ff fef6 	bl	1015f50 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(X2, X2, t5, curve); /* t3 = x2*A = C */
 1016164:	4643      	mov	r3, r8
 1016166:	4631      	mov	r1, r6
 1016168:	4630      	mov	r0, r6
 101616a:	aa02      	add	r2, sp, #8
 101616c:	f7ff fef0 	bl	1015f50 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(t5, Y2, Y1, curve->p, num_words); /* t5 = y2 + y1 */
 1016170:	4623      	mov	r3, r4
 1016172:	4652      	mov	r2, sl
 1016174:	4649      	mov	r1, r9
 1016176:	a802      	add	r0, sp, #8
 1016178:	9500      	str	r5, [sp, #0]
 101617a:	f7ff fe23 	bl	1015dc4 <uECC_vli_modAdd>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
 101617e:	4623      	mov	r3, r4
 1016180:	4652      	mov	r2, sl
 1016182:	4649      	mov	r1, r9
 1016184:	4648      	mov	r0, r9
 1016186:	9500      	str	r5, [sp, #0]
 1016188:	f7ff fe35 	bl	1015df6 <uECC_vli_modSub>

	uECC_vli_modSub(t6, X2, X1, curve->p, num_words); /* t6 = C - B */
 101618c:	4623      	mov	r3, r4
 101618e:	463a      	mov	r2, r7
 1016190:	4631      	mov	r1, r6
 1016192:	a80a      	add	r0, sp, #40	; 0x28
 1016194:	9500      	str	r5, [sp, #0]
 1016196:	f7ff fe2e 	bl	1015df6 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y1, Y1, t6, curve); /* t2 = y1 * (C - B) = E */
 101619a:	4643      	mov	r3, r8
 101619c:	4651      	mov	r1, sl
 101619e:	4650      	mov	r0, sl
 10161a0:	aa0a      	add	r2, sp, #40	; 0x28
 10161a2:	f7ff fed5 	bl	1015f50 <uECC_vli_modMult_fast>
	uECC_vli_modAdd(t6, X1, X2, curve->p, num_words); /* t6 = B + C */
 10161a6:	4623      	mov	r3, r4
 10161a8:	4632      	mov	r2, r6
 10161aa:	4639      	mov	r1, r7
 10161ac:	a80a      	add	r0, sp, #40	; 0x28
 10161ae:	9500      	str	r5, [sp, #0]
 10161b0:	f7ff fe08 	bl	1015dc4 <uECC_vli_modAdd>
	uECC_vli_modSquare_fast(X2, Y2, curve); /* t3 = (y2 - y1)^2 = D */
 10161b4:	4642      	mov	r2, r8
 10161b6:	4649      	mov	r1, r9
 10161b8:	4630      	mov	r0, r6
 10161ba:	f7ff fed9 	bl	1015f70 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(X2, X2, t6, curve->p, num_words); /* t3 = D - (B + C) = x3 */
 10161be:	4623      	mov	r3, r4
 10161c0:	4631      	mov	r1, r6
 10161c2:	4630      	mov	r0, r6
 10161c4:	aa0a      	add	r2, sp, #40	; 0x28
 10161c6:	9500      	str	r5, [sp, #0]
 10161c8:	f7ff fe15 	bl	1015df6 <uECC_vli_modSub>

	uECC_vli_modSub(t7, X1, X2, curve->p, num_words); /* t7 = B - x3 */
 10161cc:	4623      	mov	r3, r4
 10161ce:	4632      	mov	r2, r6
 10161d0:	4639      	mov	r1, r7
 10161d2:	a812      	add	r0, sp, #72	; 0x48
 10161d4:	9500      	str	r5, [sp, #0]
 10161d6:	f7ff fe0e 	bl	1015df6 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y2, Y2, t7, curve); /* t4 = (y2 - y1)*(B - x3) */
 10161da:	4643      	mov	r3, r8
 10161dc:	4649      	mov	r1, r9
 10161de:	4648      	mov	r0, r9
 10161e0:	aa12      	add	r2, sp, #72	; 0x48
 10161e2:	f7ff feb5 	bl	1015f50 <uECC_vli_modMult_fast>
	/* t4 = (y2 - y1)*(B - x3) - E = y3: */
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words);
 10161e6:	4623      	mov	r3, r4
 10161e8:	4652      	mov	r2, sl
 10161ea:	4649      	mov	r1, r9
 10161ec:	4648      	mov	r0, r9
 10161ee:	9500      	str	r5, [sp, #0]
 10161f0:	f7ff fe01 	bl	1015df6 <uECC_vli_modSub>

	uECC_vli_modSquare_fast(t7, t5, curve); /* t7 = (y2 + y1)^2 = F */
 10161f4:	4642      	mov	r2, r8
 10161f6:	a902      	add	r1, sp, #8
 10161f8:	a812      	add	r0, sp, #72	; 0x48
 10161fa:	f7ff feb9 	bl	1015f70 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(t7, t7, t6, curve->p, num_words); /* t7 = F - (B + C) = x3' */
 10161fe:	a912      	add	r1, sp, #72	; 0x48
 1016200:	4623      	mov	r3, r4
 1016202:	4608      	mov	r0, r1
 1016204:	aa0a      	add	r2, sp, #40	; 0x28
 1016206:	9500      	str	r5, [sp, #0]
 1016208:	f7ff fdf5 	bl	1015df6 <uECC_vli_modSub>
	uECC_vli_modSub(t6, t7, X1, curve->p, num_words); /* t6 = x3' - B */
 101620c:	4623      	mov	r3, r4
 101620e:	463a      	mov	r2, r7
 1016210:	a912      	add	r1, sp, #72	; 0x48
 1016212:	a80a      	add	r0, sp, #40	; 0x28
 1016214:	9500      	str	r5, [sp, #0]
 1016216:	f7ff fdee 	bl	1015df6 <uECC_vli_modSub>
	uECC_vli_modMult_fast(t6, t6, t5, curve); /* t6 = (y2+y1)*(x3' - B) */
 101621a:	a90a      	add	r1, sp, #40	; 0x28
 101621c:	4643      	mov	r3, r8
 101621e:	4608      	mov	r0, r1
 1016220:	aa02      	add	r2, sp, #8
 1016222:	f7ff fe95 	bl	1015f50 <uECC_vli_modMult_fast>
	/* t2 = (y2+y1)*(x3' - B) - E = y3': */
	uECC_vli_modSub(Y1, t6, Y1, curve->p, num_words);
 1016226:	4623      	mov	r3, r4
 1016228:	4652      	mov	r2, sl
 101622a:	4650      	mov	r0, sl
 101622c:	a90a      	add	r1, sp, #40	; 0x28
 101622e:	9500      	str	r5, [sp, #0]
 1016230:	f7ff fde1 	bl	1015df6 <uECC_vli_modSub>

	uECC_vli_set(X1, t7, num_words);
 1016234:	462a      	mov	r2, r5
 1016236:	4638      	mov	r0, r7
 1016238:	a912      	add	r1, sp, #72	; 0x48
 101623a:	f7ff fd74 	bl	1015d26 <uECC_vli_set>
}
 101623e:	b01a      	add	sp, #104	; 0x68
 1016240:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

01016244 <uECC_vli_modInv>:
{
 1016244:	b5f0      	push	{r4, r5, r6, r7, lr}
 1016246:	460f      	mov	r7, r1
 1016248:	4606      	mov	r6, r0
 101624a:	b0a1      	sub	sp, #132	; 0x84
	if (uECC_vli_isZero(input, num_words)) {
 101624c:	4619      	mov	r1, r3
 101624e:	4638      	mov	r0, r7
{
 1016250:	4615      	mov	r5, r2
 1016252:	461c      	mov	r4, r3
	if (uECC_vli_isZero(input, num_words)) {
 1016254:	f7ff fd2d 	bl	1015cb2 <uECC_vli_isZero>
 1016258:	b120      	cbz	r0, 1016264 <uECC_vli_modInv+0x20>
		uECC_vli_clear(result, num_words);
 101625a:	4630      	mov	r0, r6
 101625c:	f7ff fd1e 	bl	1015c9c <uECC_vli_clear>
}
 1016260:	b021      	add	sp, #132	; 0x84
 1016262:	bdf0      	pop	{r4, r5, r6, r7, pc}
	uECC_vli_set(a, input, num_words);
 1016264:	4622      	mov	r2, r4
 1016266:	4639      	mov	r1, r7
 1016268:	4668      	mov	r0, sp
 101626a:	f7ff fd5c 	bl	1015d26 <uECC_vli_set>
	uECC_vli_set(b, mod, num_words);
 101626e:	4629      	mov	r1, r5
 1016270:	a808      	add	r0, sp, #32
 1016272:	f7ff fd58 	bl	1015d26 <uECC_vli_set>
	uECC_vli_clear(u, num_words);
 1016276:	a810      	add	r0, sp, #64	; 0x40
 1016278:	4621      	mov	r1, r4
 101627a:	f7ff fd0f 	bl	1015c9c <uECC_vli_clear>
	u[0] = 1;
 101627e:	2301      	movs	r3, #1
	uECC_vli_clear(v, num_words);
 1016280:	a818      	add	r0, sp, #96	; 0x60
	u[0] = 1;
 1016282:	9310      	str	r3, [sp, #64]	; 0x40
	uECC_vli_clear(v, num_words);
 1016284:	f7ff fd0a 	bl	1015c9c <uECC_vli_clear>
	while ((cmpResult = uECC_vli_cmp_unsafe(a, b, num_words)) != 0) {
 1016288:	4622      	mov	r2, r4
 101628a:	4668      	mov	r0, sp
 101628c:	a908      	add	r1, sp, #32
 101628e:	f7ff fd56 	bl	1015d3e <uECC_vli_cmp_unsafe>
 1016292:	b928      	cbnz	r0, 10162a0 <uECC_vli_modInv+0x5c>
  	uECC_vli_set(result, u, num_words);
 1016294:	4622      	mov	r2, r4
 1016296:	4630      	mov	r0, r6
 1016298:	a910      	add	r1, sp, #64	; 0x40
 101629a:	f7ff fd44 	bl	1015d26 <uECC_vli_set>
 101629e:	e7df      	b.n	1016260 <uECC_vli_modInv+0x1c>
		if (EVEN(a)) {
 10162a0:	9b00      	ldr	r3, [sp, #0]
 10162a2:	07da      	lsls	r2, r3, #31
 10162a4:	d409      	bmi.n	10162ba <uECC_vli_modInv+0x76>
			uECC_vli_rshift1(a, num_words);
 10162a6:	4621      	mov	r1, r4
 10162a8:	4668      	mov	r0, sp
 10162aa:	f7ff fc5b 	bl	1015b64 <uECC_vli_rshift1>
      			vli_modInv_update(u, mod, num_words);
 10162ae:	4622      	mov	r2, r4
 10162b0:	4629      	mov	r1, r5
 10162b2:	a810      	add	r0, sp, #64	; 0x40
      			vli_modInv_update(v, mod, num_words);
 10162b4:	f7ff fc63 	bl	1015b7e <vli_modInv_update>
 10162b8:	e7e6      	b.n	1016288 <uECC_vli_modInv+0x44>
    		} else if (EVEN(b)) {
 10162ba:	9b08      	ldr	r3, [sp, #32]
 10162bc:	07db      	lsls	r3, r3, #31
 10162be:	d407      	bmi.n	10162d0 <uECC_vli_modInv+0x8c>
			uECC_vli_rshift1(b, num_words);
 10162c0:	4621      	mov	r1, r4
 10162c2:	a808      	add	r0, sp, #32
 10162c4:	f7ff fc4e 	bl	1015b64 <uECC_vli_rshift1>
      			vli_modInv_update(v, mod, num_words);
 10162c8:	4622      	mov	r2, r4
 10162ca:	4629      	mov	r1, r5
 10162cc:	a818      	add	r0, sp, #96	; 0x60
 10162ce:	e7f1      	b.n	10162b4 <uECC_vli_modInv+0x70>
		} else if (cmpResult > 0) {
 10162d0:	2800      	cmp	r0, #0
			uECC_vli_sub(a, a, b, num_words);
 10162d2:	4623      	mov	r3, r4
		} else if (cmpResult > 0) {
 10162d4:	dd1c      	ble.n	1016310 <uECC_vli_modInv+0xcc>
			uECC_vli_sub(a, a, b, num_words);
 10162d6:	aa08      	add	r2, sp, #32
 10162d8:	4669      	mov	r1, sp
 10162da:	4668      	mov	r0, sp
 10162dc:	f7ff fd59 	bl	1015d92 <uECC_vli_sub>
			uECC_vli_rshift1(a, num_words);
 10162e0:	4621      	mov	r1, r4
 10162e2:	4668      	mov	r0, sp
 10162e4:	f7ff fc3e 	bl	1015b64 <uECC_vli_rshift1>
			if (uECC_vli_cmp_unsafe(u, v, num_words) < 0) {
 10162e8:	4622      	mov	r2, r4
 10162ea:	a918      	add	r1, sp, #96	; 0x60
 10162ec:	a810      	add	r0, sp, #64	; 0x40
 10162ee:	f7ff fd26 	bl	1015d3e <uECC_vli_cmp_unsafe>
 10162f2:	2800      	cmp	r0, #0
 10162f4:	da05      	bge.n	1016302 <uECC_vli_modInv+0xbe>
        			uECC_vli_add(u, u, mod, num_words);
 10162f6:	a910      	add	r1, sp, #64	; 0x40
 10162f8:	4623      	mov	r3, r4
 10162fa:	462a      	mov	r2, r5
 10162fc:	4608      	mov	r0, r1
 10162fe:	f7ff fc19 	bl	1015b34 <uECC_vli_add>
      			uECC_vli_sub(u, u, v, num_words);
 1016302:	a910      	add	r1, sp, #64	; 0x40
 1016304:	4623      	mov	r3, r4
 1016306:	4608      	mov	r0, r1
 1016308:	aa18      	add	r2, sp, #96	; 0x60
 101630a:	f7ff fd42 	bl	1015d92 <uECC_vli_sub>
 101630e:	e7ce      	b.n	10162ae <uECC_vli_modInv+0x6a>
      			uECC_vli_sub(b, b, a, num_words);
 1016310:	a908      	add	r1, sp, #32
 1016312:	466a      	mov	r2, sp
 1016314:	4608      	mov	r0, r1
 1016316:	f7ff fd3c 	bl	1015d92 <uECC_vli_sub>
      			uECC_vli_rshift1(b, num_words);
 101631a:	4621      	mov	r1, r4
 101631c:	a808      	add	r0, sp, #32
 101631e:	f7ff fc21 	bl	1015b64 <uECC_vli_rshift1>
      			if (uECC_vli_cmp_unsafe(v, u, num_words) < 0) {
 1016322:	4622      	mov	r2, r4
 1016324:	a910      	add	r1, sp, #64	; 0x40
 1016326:	a818      	add	r0, sp, #96	; 0x60
 1016328:	f7ff fd09 	bl	1015d3e <uECC_vli_cmp_unsafe>
 101632c:	2800      	cmp	r0, #0
 101632e:	da05      	bge.n	101633c <uECC_vli_modInv+0xf8>
        			uECC_vli_add(v, v, mod, num_words);
 1016330:	a918      	add	r1, sp, #96	; 0x60
 1016332:	4623      	mov	r3, r4
 1016334:	462a      	mov	r2, r5
 1016336:	4608      	mov	r0, r1
 1016338:	f7ff fbfc 	bl	1015b34 <uECC_vli_add>
      			uECC_vli_sub(v, v, u, num_words);
 101633c:	a918      	add	r1, sp, #96	; 0x60
 101633e:	4623      	mov	r3, r4
 1016340:	4608      	mov	r0, r1
 1016342:	aa10      	add	r2, sp, #64	; 0x40
 1016344:	f7ff fd25 	bl	1015d92 <uECC_vli_sub>
 1016348:	e7be      	b.n	10162c8 <uECC_vli_modInv+0x84>

0101634a <EccPoint_isZero>:
	return uECC_vli_isZero(point, curve->num_words * 2);
 101634a:	7809      	ldrb	r1, [r1, #0]
 101634c:	0049      	lsls	r1, r1, #1
 101634e:	b249      	sxtb	r1, r1
 1016350:	f7ff bcaf 	b.w	1015cb2 <uECC_vli_isZero>

01016354 <apply_z>:
{
 1016354:	b5f0      	push	{r4, r5, r6, r7, lr}
 1016356:	4615      	mov	r5, r2
 1016358:	461c      	mov	r4, r3
 101635a:	4607      	mov	r7, r0
 101635c:	460e      	mov	r6, r1
 101635e:	b089      	sub	sp, #36	; 0x24
	uECC_vli_modSquare_fast(t1, Z, curve);    /* z^2 */
 1016360:	461a      	mov	r2, r3
 1016362:	4629      	mov	r1, r5
 1016364:	4668      	mov	r0, sp
 1016366:	f7ff fe03 	bl	1015f70 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t1, curve); /* x1 * z^2 */
 101636a:	4623      	mov	r3, r4
 101636c:	466a      	mov	r2, sp
 101636e:	4639      	mov	r1, r7
 1016370:	4638      	mov	r0, r7
 1016372:	f7ff fded 	bl	1015f50 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(t1, t1, Z, curve);  /* z^3 */
 1016376:	4623      	mov	r3, r4
 1016378:	462a      	mov	r2, r5
 101637a:	4669      	mov	r1, sp
 101637c:	4668      	mov	r0, sp
 101637e:	f7ff fde7 	bl	1015f50 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(Y1, Y1, t1, curve); /* y1 * z^3 */
 1016382:	4623      	mov	r3, r4
 1016384:	466a      	mov	r2, sp
 1016386:	4631      	mov	r1, r6
 1016388:	4630      	mov	r0, r6
 101638a:	f7ff fde1 	bl	1015f50 <uECC_vli_modMult_fast>
}
 101638e:	b009      	add	sp, #36	; 0x24
 1016390:	bdf0      	pop	{r4, r5, r6, r7, pc}

01016392 <XYcZ_add>:
{
 1016392:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 1016396:	b08a      	sub	sp, #40	; 0x28
 1016398:	f8dd a048 	ldr.w	sl, [sp, #72]	; 0x48
 101639c:	4614      	mov	r4, r2
	wordcount_t num_words = curve->num_words;
 101639e:	4655      	mov	r5, sl
{
 10163a0:	4680      	mov	r8, r0
 10163a2:	461f      	mov	r7, r3
 10163a4:	4689      	mov	r9, r1
	wordcount_t num_words = curve->num_words;
 10163a6:	f915 6b04 	ldrsb.w	r6, [r5], #4
	uECC_vli_modSub(t5, X2, X1, curve->p, num_words); /* t5 = x2 - x1 */
 10163aa:	4602      	mov	r2, r0
 10163ac:	462b      	mov	r3, r5
 10163ae:	4621      	mov	r1, r4
 10163b0:	a802      	add	r0, sp, #8
 10163b2:	9600      	str	r6, [sp, #0]
 10163b4:	f7ff fd1f 	bl	1015df6 <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, t5, curve); /* t5 = (x2 - x1)^2 = A */
 10163b8:	a902      	add	r1, sp, #8
 10163ba:	4652      	mov	r2, sl
 10163bc:	4608      	mov	r0, r1
 10163be:	f7ff fdd7 	bl	1015f70 <uECC_vli_modSquare_fast>
	uECC_vli_modMult_fast(X1, X1, t5, curve); /* t1 = x1*A = B */
 10163c2:	4653      	mov	r3, sl
 10163c4:	4641      	mov	r1, r8
 10163c6:	4640      	mov	r0, r8
 10163c8:	aa02      	add	r2, sp, #8
 10163ca:	f7ff fdc1 	bl	1015f50 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(X2, X2, t5, curve); /* t3 = x2*A = C */
 10163ce:	4653      	mov	r3, sl
 10163d0:	4621      	mov	r1, r4
 10163d2:	4620      	mov	r0, r4
 10163d4:	aa02      	add	r2, sp, #8
 10163d6:	f7ff fdbb 	bl	1015f50 <uECC_vli_modMult_fast>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y2 - y1 */
 10163da:	462b      	mov	r3, r5
 10163dc:	464a      	mov	r2, r9
 10163de:	4639      	mov	r1, r7
 10163e0:	4638      	mov	r0, r7
 10163e2:	9600      	str	r6, [sp, #0]
 10163e4:	f7ff fd07 	bl	1015df6 <uECC_vli_modSub>
	uECC_vli_modSquare_fast(t5, Y2, curve); /* t5 = (y2 - y1)^2 = D */
 10163e8:	4652      	mov	r2, sl
 10163ea:	4639      	mov	r1, r7
 10163ec:	a802      	add	r0, sp, #8
 10163ee:	f7ff fdbf 	bl	1015f70 <uECC_vli_modSquare_fast>
	uECC_vli_modSub(t5, t5, X1, curve->p, num_words); /* t5 = D - B */
 10163f2:	a902      	add	r1, sp, #8
 10163f4:	462b      	mov	r3, r5
 10163f6:	4642      	mov	r2, r8
 10163f8:	4608      	mov	r0, r1
 10163fa:	9600      	str	r6, [sp, #0]
 10163fc:	f7ff fcfb 	bl	1015df6 <uECC_vli_modSub>
	uECC_vli_modSub(t5, t5, X2, curve->p, num_words); /* t5 = D - B - C = x3 */
 1016400:	a902      	add	r1, sp, #8
 1016402:	462b      	mov	r3, r5
 1016404:	4622      	mov	r2, r4
 1016406:	4608      	mov	r0, r1
 1016408:	9600      	str	r6, [sp, #0]
 101640a:	f7ff fcf4 	bl	1015df6 <uECC_vli_modSub>
	uECC_vli_modSub(X2, X2, X1, curve->p, num_words); /* t3 = C - B */
 101640e:	462b      	mov	r3, r5
 1016410:	4642      	mov	r2, r8
 1016412:	4621      	mov	r1, r4
 1016414:	4620      	mov	r0, r4
 1016416:	9600      	str	r6, [sp, #0]
 1016418:	f7ff fced 	bl	1015df6 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y1, Y1, X2, curve); /* t2 = y1*(C - B) */
 101641c:	4653      	mov	r3, sl
 101641e:	4622      	mov	r2, r4
 1016420:	4649      	mov	r1, r9
 1016422:	4648      	mov	r0, r9
 1016424:	f7ff fd94 	bl	1015f50 <uECC_vli_modMult_fast>
	uECC_vli_modSub(X2, X1, t5, curve->p, num_words); /* t3 = B - x3 */
 1016428:	462b      	mov	r3, r5
 101642a:	4641      	mov	r1, r8
 101642c:	4620      	mov	r0, r4
 101642e:	aa02      	add	r2, sp, #8
 1016430:	9600      	str	r6, [sp, #0]
 1016432:	f7ff fce0 	bl	1015df6 <uECC_vli_modSub>
	uECC_vli_modMult_fast(Y2, Y2, X2, curve); /* t4 = (y2 - y1)*(B - x3) */
 1016436:	4653      	mov	r3, sl
 1016438:	4622      	mov	r2, r4
 101643a:	4639      	mov	r1, r7
 101643c:	4638      	mov	r0, r7
 101643e:	f7ff fd87 	bl	1015f50 <uECC_vli_modMult_fast>
	uECC_vli_modSub(Y2, Y2, Y1, curve->p, num_words); /* t4 = y3 */
 1016442:	462b      	mov	r3, r5
 1016444:	464a      	mov	r2, r9
 1016446:	4639      	mov	r1, r7
 1016448:	4638      	mov	r0, r7
 101644a:	9600      	str	r6, [sp, #0]
 101644c:	f7ff fcd3 	bl	1015df6 <uECC_vli_modSub>
	uECC_vli_set(X2, t5, num_words);
 1016450:	4632      	mov	r2, r6
 1016452:	4620      	mov	r0, r4
 1016454:	a902      	add	r1, sp, #8
 1016456:	f7ff fc66 	bl	1015d26 <uECC_vli_set>
}
 101645a:	b00a      	add	sp, #40	; 0x28
 101645c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

01016460 <EccPoint_mult>:

void EccPoint_mult(uECC_word_t * result, const uECC_word_t * point,
		   const uECC_word_t * scalar,
		   const uECC_word_t * initial_Z,
		   bitcount_t num_bits, uECC_Curve curve) 
{
 1016460:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 1016464:	461e      	mov	r6, r3
 1016466:	b0b1      	sub	sp, #196	; 0xc4
 1016468:	9c3b      	ldr	r4, [sp, #236]	; 0xec
 101646a:	e9cd 0103 	strd	r0, r1, [sp, #12]
	uECC_word_t Rx[2][NUM_ECC_WORDS];
	uECC_word_t Ry[2][NUM_ECC_WORDS];
	uECC_word_t z[NUM_ECC_WORDS];
	bitcount_t i;
	uECC_word_t nb;
	wordcount_t num_words = curve->num_words;
 101646e:	f994 7000 	ldrsb.w	r7, [r4]

	uECC_vli_set(Rx[1], point, num_words);
 1016472:	a818      	add	r0, sp, #96	; 0x60
{
 1016474:	4692      	mov	sl, r2
	uECC_vli_set(Rx[1], point, num_words);
 1016476:	463a      	mov	r2, r7
 1016478:	f7ff fc55 	bl	1015d26 <uECC_vli_set>
  	uECC_vli_set(Ry[1], point + num_words, num_words);
 101647c:	00bb      	lsls	r3, r7, #2
 101647e:	9305      	str	r3, [sp, #20]
 1016480:	9b04      	ldr	r3, [sp, #16]
 1016482:	a828      	add	r0, sp, #160	; 0xa0
 1016484:	eb03 0387 	add.w	r3, r3, r7, lsl #2
 1016488:	4619      	mov	r1, r3
 101648a:	9302      	str	r3, [sp, #8]
 101648c:	f7ff fc4b 	bl	1015d26 <uECC_vli_set>
	wordcount_t num_words = curve->num_words;
 1016490:	f994 5000 	ldrsb.w	r5, [r4]
	if (initial_Z) {
 1016494:	2e00      	cmp	r6, #0
 1016496:	f000 8088 	beq.w	10165aa <EccPoint_mult+0x14a>
		uECC_vli_set(z, initial_Z, num_words);
 101649a:	462a      	mov	r2, r5
 101649c:	4631      	mov	r1, r6
 101649e:	a808      	add	r0, sp, #32
 10164a0:	f7ff fc41 	bl	1015d26 <uECC_vli_set>
	uECC_vli_set(X2, X1, num_words);
 10164a4:	f10d 0840 	add.w	r8, sp, #64	; 0x40
 10164a8:	462a      	mov	r2, r5
 10164aa:	4640      	mov	r0, r8
 10164ac:	a918      	add	r1, sp, #96	; 0x60
	uECC_vli_set(Y2, Y1, num_words);
 10164ae:	f10d 0980 	add.w	r9, sp, #128	; 0x80
	uECC_vli_set(X2, X1, num_words);
 10164b2:	f7ff fc38 	bl	1015d26 <uECC_vli_set>
	uECC_vli_set(Y2, Y1, num_words);
 10164b6:	4648      	mov	r0, r9
 10164b8:	a928      	add	r1, sp, #160	; 0xa0
 10164ba:	f7ff fc34 	bl	1015d26 <uECC_vli_set>
	apply_z(X1, Y1, z, curve);
 10164be:	4623      	mov	r3, r4
 10164c0:	aa08      	add	r2, sp, #32
 10164c2:	a928      	add	r1, sp, #160	; 0xa0
 10164c4:	a818      	add	r0, sp, #96	; 0x60
 10164c6:	f7ff ff45 	bl	1016354 <apply_z>
	curve->double_jacobian(X1, Y1, z, curve);
 10164ca:	4623      	mov	r3, r4
 10164cc:	f8d4 50a4 	ldr.w	r5, [r4, #164]	; 0xa4
 10164d0:	aa08      	add	r2, sp, #32
 10164d2:	a928      	add	r1, sp, #160	; 0xa0
 10164d4:	a818      	add	r0, sp, #96	; 0x60
 10164d6:	47a8      	blx	r5
	apply_z(X2, Y2, z, curve);
 10164d8:	4623      	mov	r3, r4
 10164da:	4649      	mov	r1, r9
 10164dc:	4640      	mov	r0, r8
 10164de:	aa08      	add	r2, sp, #32
 10164e0:	f7ff ff38 	bl	1016354 <apply_z>

	XYcZ_initial_double(Rx[1], Ry[1], Rx[0], Ry[0], initial_Z, curve);

	for (i = num_bits - 2; i > 0; --i) {
 10164e4:	f9bd 50e8 	ldrsh.w	r5, [sp, #232]	; 0xe8
 10164e8:	3d02      	subs	r5, #2
 10164ea:	b22d      	sxth	r5, r5
 10164ec:	2d00      	cmp	r5, #0
 10164ee:	dc63      	bgt.n	10165b8 <EccPoint_mult+0x158>
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
 10164f0:	f8da 5000 	ldr.w	r5, [sl]
		XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
		XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
	}

	nb = !uECC_vli_testBit(scalar, 0);
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
 10164f4:	ab10      	add	r3, sp, #64	; 0x40
	return (vli[bit >> uECC_WORD_BITS_SHIFT] &
 10164f6:	f005 0601 	and.w	r6, r5, #1
 10164fa:	43ed      	mvns	r5, r5
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
 10164fc:	eb03 1846 	add.w	r8, r3, r6, lsl #5
 1016500:	ab20      	add	r3, sp, #128	; 0x80
 1016502:	eb03 1646 	add.w	r6, r3, r6, lsl #5
 1016506:	f005 0501 	and.w	r5, r5, #1
 101650a:	ab10      	add	r3, sp, #64	; 0x40
 101650c:	eb03 1945 	add.w	r9, r3, r5, lsl #5
 1016510:	ab20      	add	r3, sp, #128	; 0x80
 1016512:	eb03 1545 	add.w	r5, r3, r5, lsl #5

	/* Find final 1/Z value. */
	uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
 1016516:	f104 0a04 	add.w	sl, r4, #4
	XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
 101651a:	462b      	mov	r3, r5
 101651c:	464a      	mov	r2, r9
 101651e:	4631      	mov	r1, r6
 1016520:	4640      	mov	r0, r8
 1016522:	9400      	str	r4, [sp, #0]
 1016524:	f7ff fe00 	bl	1016128 <XYcZ_addC>
	uECC_vli_modSub(z, Rx[1], Rx[0], curve->p, num_words); /* X1 - X0 */
 1016528:	4653      	mov	r3, sl
 101652a:	aa10      	add	r2, sp, #64	; 0x40
 101652c:	a918      	add	r1, sp, #96	; 0x60
 101652e:	a808      	add	r0, sp, #32
 1016530:	9700      	str	r7, [sp, #0]
 1016532:	f7ff fc60 	bl	1015df6 <uECC_vli_modSub>
	uECC_vli_modMult_fast(z, z, Ry[1 - nb], curve); /* Yb * (X1 - X0) */
 1016536:	a908      	add	r1, sp, #32
 1016538:	4623      	mov	r3, r4
 101653a:	4632      	mov	r2, r6
 101653c:	4608      	mov	r0, r1
 101653e:	f7ff fd07 	bl	1015f50 <uECC_vli_modMult_fast>
	uECC_vli_modMult_fast(z, z, point, curve); /* xP * Yb * (X1 - X0) */
 1016542:	a908      	add	r1, sp, #32
 1016544:	4623      	mov	r3, r4
 1016546:	4608      	mov	r0, r1
 1016548:	9a04      	ldr	r2, [sp, #16]
 101654a:	f7ff fd01 	bl	1015f50 <uECC_vli_modMult_fast>
	uECC_vli_modInv(z, z, curve->p, num_words); /* 1 / (xP * Yb * (X1 - X0))*/
 101654e:	a908      	add	r1, sp, #32
 1016550:	463b      	mov	r3, r7
 1016552:	4652      	mov	r2, sl
 1016554:	4608      	mov	r0, r1
 1016556:	f7ff fe75 	bl	1016244 <uECC_vli_modInv>
	/* yP / (xP * Yb * (X1 - X0)) */
	uECC_vli_modMult_fast(z, z, point + num_words, curve);
 101655a:	a908      	add	r1, sp, #32
 101655c:	4623      	mov	r3, r4
 101655e:	4608      	mov	r0, r1
 1016560:	9a02      	ldr	r2, [sp, #8]
 1016562:	f7ff fcf5 	bl	1015f50 <uECC_vli_modMult_fast>
	/* Xb * yP / (xP * Yb * (X1 - X0)) */
	uECC_vli_modMult_fast(z, z, Rx[1 - nb], curve);
 1016566:	a908      	add	r1, sp, #32
 1016568:	4623      	mov	r3, r4
 101656a:	4642      	mov	r2, r8
 101656c:	4608      	mov	r0, r1
 101656e:	f7ff fcef 	bl	1015f50 <uECC_vli_modMult_fast>
	/* End 1/Z calculation */

	XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
 1016572:	4633      	mov	r3, r6
 1016574:	4642      	mov	r2, r8
 1016576:	4629      	mov	r1, r5
 1016578:	4648      	mov	r0, r9
 101657a:	9400      	str	r4, [sp, #0]
 101657c:	f7ff ff09 	bl	1016392 <XYcZ_add>
	apply_z(Rx[0], Ry[0], z, curve);
 1016580:	4623      	mov	r3, r4
 1016582:	aa08      	add	r2, sp, #32
 1016584:	a920      	add	r1, sp, #128	; 0x80
 1016586:	a810      	add	r0, sp, #64	; 0x40
 1016588:	f7ff fee4 	bl	1016354 <apply_z>

	uECC_vli_set(result, Rx[0], num_words);
 101658c:	463a      	mov	r2, r7
 101658e:	9803      	ldr	r0, [sp, #12]
 1016590:	a910      	add	r1, sp, #64	; 0x40
 1016592:	f7ff fbc8 	bl	1015d26 <uECC_vli_set>
	uECC_vli_set(result + num_words, Ry[0], num_words);
 1016596:	9b03      	ldr	r3, [sp, #12]
 1016598:	9c05      	ldr	r4, [sp, #20]
 101659a:	a920      	add	r1, sp, #128	; 0x80
 101659c:	4423      	add	r3, r4
 101659e:	4618      	mov	r0, r3
 10165a0:	f7ff fbc1 	bl	1015d26 <uECC_vli_set>
}
 10165a4:	b031      	add	sp, #196	; 0xc4
 10165a6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		uECC_vli_clear(z, num_words);
 10165aa:	4629      	mov	r1, r5
 10165ac:	a808      	add	r0, sp, #32
 10165ae:	f7ff fb75 	bl	1015c9c <uECC_vli_clear>
		z[0] = 1;
 10165b2:	2301      	movs	r3, #1
 10165b4:	9308      	str	r3, [sp, #32]
 10165b6:	e775      	b.n	10164a4 <EccPoint_mult+0x44>
		nb = !uECC_vli_testBit(scalar, i);
 10165b8:	4629      	mov	r1, r5
 10165ba:	4650      	mov	r0, sl
 10165bc:	f7ff fb88 	bl	1015cd0 <uECC_vli_testBit>
 10165c0:	fab0 f680 	clz	r6, r0
 10165c4:	0976      	lsrs	r6, r6, #5
		XYcZ_addC(Rx[1 - nb], Ry[1 - nb], Rx[nb], Ry[nb], curve);
 10165c6:	f1c6 0101 	rsb	r1, r6, #1
 10165ca:	eb08 1b46 	add.w	fp, r8, r6, lsl #5
 10165ce:	eb09 1646 	add.w	r6, r9, r6, lsl #5
 10165d2:	eb08 1041 	add.w	r0, r8, r1, lsl #5
 10165d6:	4633      	mov	r3, r6
 10165d8:	eb09 1141 	add.w	r1, r9, r1, lsl #5
 10165dc:	465a      	mov	r2, fp
 10165de:	9400      	str	r4, [sp, #0]
 10165e0:	e9cd 0106 	strd	r0, r1, [sp, #24]
 10165e4:	f7ff fda0 	bl	1016128 <XYcZ_addC>
		XYcZ_add(Rx[nb], Ry[nb], Rx[1 - nb], Ry[1 - nb], curve);
 10165e8:	9907      	ldr	r1, [sp, #28]
 10165ea:	9806      	ldr	r0, [sp, #24]
 10165ec:	460b      	mov	r3, r1
 10165ee:	4602      	mov	r2, r0
 10165f0:	4631      	mov	r1, r6
 10165f2:	4658      	mov	r0, fp
 10165f4:	9400      	str	r4, [sp, #0]
 10165f6:	f7ff fecc 	bl	1016392 <XYcZ_add>
	for (i = num_bits - 2; i > 0; --i) {
 10165fa:	3d01      	subs	r5, #1
 10165fc:	e775      	b.n	10164ea <EccPoint_mult+0x8a>

010165fe <regularize_k>:

uECC_word_t regularize_k(const uECC_word_t * const k, uECC_word_t *k0,
			 uECC_word_t *k1, uECC_Curve curve)
{
 10165fe:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1016602:	461d      	mov	r5, r3
 1016604:	460e      	mov	r6, r1

	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 1016606:	f9b3 9002 	ldrsh.w	r9, [r3, #2]

	bitcount_t num_n_bits = curve->num_n_bits;

	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 101660a:	3524      	adds	r5, #36	; 0x24
	wordcount_t num_n_words = BITS_TO_WORDS(curve->num_n_bits);
 101660c:	f119 081f 	adds.w	r8, r9, #31
 1016610:	bf48      	it	mi
 1016612:	f109 083e 	addmi.w	r8, r9, #62	; 0x3e
 1016616:	f348 1847 	sbfx	r8, r8, #5, #8
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 101661a:	4601      	mov	r1, r0
{
 101661c:	4617      	mov	r7, r2
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 101661e:	4643      	mov	r3, r8
 1016620:	462a      	mov	r2, r5
 1016622:	4630      	mov	r0, r6
 1016624:	f7ff fa86 	bl	1015b34 <uECC_vli_add>
 1016628:	4604      	mov	r4, r0
 101662a:	b990      	cbnz	r0, 1016652 <regularize_k+0x54>
 101662c:	ebb9 1f48 	cmp.w	r9, r8, lsl #5
 1016630:	da06      	bge.n	1016640 <regularize_k+0x42>
			     (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
			     uECC_vli_testBit(k0, num_n_bits));
 1016632:	4649      	mov	r1, r9
 1016634:	4630      	mov	r0, r6
 1016636:	f7ff fb4b 	bl	1015cd0 <uECC_vli_testBit>
			     (num_n_bits < ((bitcount_t)num_n_words * uECC_WORD_SIZE * 8) &&
 101663a:	1e04      	subs	r4, r0, #0
 101663c:	bf18      	it	ne
 101663e:	2401      	movne	r4, #1

	uECC_vli_add(k1, k0, curve->n, num_n_words);
 1016640:	4643      	mov	r3, r8
 1016642:	462a      	mov	r2, r5
 1016644:	4631      	mov	r1, r6
 1016646:	4638      	mov	r0, r7
 1016648:	f7ff fa74 	bl	1015b34 <uECC_vli_add>

	return carry;
}
 101664c:	4620      	mov	r0, r4
 101664e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	uECC_word_t carry = uECC_vli_add(k0, k, curve->n, num_n_words) ||
 1016652:	2401      	movs	r4, #1
 1016654:	e7f4      	b.n	1016640 <regularize_k+0x42>

01016656 <EccPoint_compute_public_key>:

uECC_word_t EccPoint_compute_public_key(uECC_word_t *result,
					uECC_word_t *private_key,
					uECC_Curve curve)
{
 1016656:	b530      	push	{r4, r5, lr}
 1016658:	4614      	mov	r4, r2
 101665a:	b095      	sub	sp, #84	; 0x54
 101665c:	4605      	mov	r5, r0

	uECC_word_t tmp1[NUM_ECC_WORDS];
 	uECC_word_t tmp2[NUM_ECC_WORDS];
	uECC_word_t *p2[2] = {tmp1, tmp2};
 101665e:	aa0c      	add	r2, sp, #48	; 0x30
	uECC_word_t carry;

	/* Regularize the bitcount for the private key so that attackers cannot
	 * use a side channel attack to learn the number of leading zeros. */
	carry = regularize_k(private_key, tmp1, tmp2, curve);
 1016660:	4623      	mov	r3, r4
{
 1016662:	4608      	mov	r0, r1
	uECC_word_t *p2[2] = {tmp1, tmp2};
 1016664:	a904      	add	r1, sp, #16
 1016666:	9102      	str	r1, [sp, #8]
 1016668:	9203      	str	r2, [sp, #12]
	carry = regularize_k(private_key, tmp1, tmp2, curve);
 101666a:	f7ff ffc8 	bl	10165fe <regularize_k>

	EccPoint_mult(result, curve->G, p2[!carry], 0, curve->num_n_bits + 1, curve);
 101666e:	fab0 f380 	clz	r3, r0
 1016672:	aa14      	add	r2, sp, #80	; 0x50
 1016674:	095b      	lsrs	r3, r3, #5
 1016676:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 101667a:	8863      	ldrh	r3, [r4, #2]
 101667c:	9401      	str	r4, [sp, #4]
 101667e:	3301      	adds	r3, #1
 1016680:	b21b      	sxth	r3, r3
 1016682:	9300      	str	r3, [sp, #0]
 1016684:	4628      	mov	r0, r5
 1016686:	2300      	movs	r3, #0
 1016688:	f852 2c48 	ldr.w	r2, [r2, #-72]
 101668c:	f104 0144 	add.w	r1, r4, #68	; 0x44
 1016690:	f7ff fee6 	bl	1016460 <EccPoint_mult>

	if (EccPoint_isZero(result, curve)) {
 1016694:	4621      	mov	r1, r4
 1016696:	4628      	mov	r0, r5
 1016698:	f7ff fe57 	bl	101634a <EccPoint_isZero>
		return 0;
	}
	return 1;
}
 101669c:	fab0 f080 	clz	r0, r0
 10166a0:	0940      	lsrs	r0, r0, #5
 10166a2:	b015      	add	sp, #84	; 0x54
 10166a4:	bd30      	pop	{r4, r5, pc}

010166a6 <uECC_vli_nativeToBytes>:

/* Converts an integer in uECC native format to big-endian bytes. */
void uECC_vli_nativeToBytes(uint8_t *bytes, int num_bytes,
			    const unsigned int *native)
{
 10166a6:	b5f0      	push	{r4, r5, r6, r7, lr}
	wordcount_t i;
	for (i = 0; i < num_bytes; ++i) {
 10166a8:	2500      	movs	r5, #0
		unsigned b = num_bytes - 1 - i;
 10166aa:	1e4f      	subs	r7, r1, #1
 10166ac:	b26c      	sxtb	r4, r5
	for (i = 0; i < num_bytes; ++i) {
 10166ae:	428c      	cmp	r4, r1
 10166b0:	f105 0501 	add.w	r5, r5, #1
 10166b4:	db00      	blt.n	10166b8 <uECC_vli_nativeToBytes+0x12>
		bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
	}
}
 10166b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
		unsigned b = num_bytes - 1 - i;
 10166b8:	1b3b      	subs	r3, r7, r4
		bytes[i] = native[b / uECC_WORD_SIZE] >> (8 * (b % uECC_WORD_SIZE));
 10166ba:	f023 0603 	bic.w	r6, r3, #3
 10166be:	5996      	ldr	r6, [r2, r6]
 10166c0:	f003 0303 	and.w	r3, r3, #3
 10166c4:	00db      	lsls	r3, r3, #3
 10166c6:	fa26 f303 	lsr.w	r3, r6, r3
 10166ca:	5503      	strb	r3, [r0, r4]
	for (i = 0; i < num_bytes; ++i) {
 10166cc:	e7ee      	b.n	10166ac <uECC_vli_nativeToBytes+0x6>

010166ce <uECC_vli_bytesToNative>:

/* Converts big-endian bytes to an integer in uECC native format. */
void uECC_vli_bytesToNative(unsigned int *native, const uint8_t *bytes,
			    int num_bytes)
{
 10166ce:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 10166d0:	460e      	mov	r6, r1
	wordcount_t i;
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
 10166d2:	1cd1      	adds	r1, r2, #3
 10166d4:	bf48      	it	mi
 10166d6:	1d91      	addmi	r1, r2, #6
{
 10166d8:	4614      	mov	r4, r2
	uECC_vli_clear(native, (num_bytes + (uECC_WORD_SIZE - 1)) / uECC_WORD_SIZE);
 10166da:	f341 0187 	sbfx	r1, r1, #2, #8
 10166de:	f7ff fadd 	bl	1015c9c <uECC_vli_clear>
	for (i = 0; i < num_bytes; ++i) {
 10166e2:	2500      	movs	r5, #0
		unsigned b = num_bytes - 1 - i;
 10166e4:	1e67      	subs	r7, r4, #1
 10166e6:	b26a      	sxtb	r2, r5
	for (i = 0; i < num_bytes; ++i) {
 10166e8:	42a2      	cmp	r2, r4
 10166ea:	f105 0501 	add.w	r5, r5, #1
 10166ee:	db00      	blt.n	10166f2 <uECC_vli_bytesToNative+0x24>
		native[b / uECC_WORD_SIZE] |=
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
  	}
}
 10166f0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		unsigned b = num_bytes - 1 - i;
 10166f2:	1abb      	subs	r3, r7, r2
		native[b / uECC_WORD_SIZE] |=
 10166f4:	f023 0103 	bic.w	r1, r3, #3
			(uECC_word_t)bytes[i] << (8 * (b % uECC_WORD_SIZE));
 10166f8:	5cb2      	ldrb	r2, [r6, r2]
 10166fa:	f003 0303 	and.w	r3, r3, #3
 10166fe:	00db      	lsls	r3, r3, #3
 1016700:	fa02 f303 	lsl.w	r3, r2, r3
		native[b / uECC_WORD_SIZE] |=
 1016704:	5842      	ldr	r2, [r0, r1]
 1016706:	431a      	orrs	r2, r3
 1016708:	5042      	str	r2, [r0, r1]
	for (i = 0; i < num_bytes; ++i) {
 101670a:	e7ec      	b.n	10166e6 <uECC_vli_bytesToNative+0x18>

0101670c <uECC_valid_point>:
	return 0;
}


int uECC_valid_point(const uECC_word_t *point, uECC_Curve curve)
{
 101670c:	b5f0      	push	{r4, r5, r6, r7, lr}
 101670e:	b091      	sub	sp, #68	; 0x44
 1016710:	4605      	mov	r5, r0
 1016712:	460c      	mov	r4, r1
	uECC_word_t tmp1[NUM_ECC_WORDS];
	uECC_word_t tmp2[NUM_ECC_WORDS];
	wordcount_t num_words = curve->num_words;
 1016714:	f991 6000 	ldrsb.w	r6, [r1]

	/* The point at infinity is invalid. */
	if (EccPoint_isZero(point, curve)) {
 1016718:	f7ff fe17 	bl	101634a <EccPoint_isZero>
 101671c:	bb28      	cbnz	r0, 101676a <uECC_valid_point+0x5e>
		return -1;
	}

	/* x and y must be smaller than p. */
	if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||
 101671e:	1d27      	adds	r7, r4, #4
 1016720:	4632      	mov	r2, r6
 1016722:	4629      	mov	r1, r5
 1016724:	4638      	mov	r0, r7
 1016726:	f7ff fb0a 	bl	1015d3e <uECC_vli_cmp_unsafe>
 101672a:	2801      	cmp	r0, #1
 101672c:	d120      	bne.n	1016770 <uECC_valid_point+0x64>
		uECC_vli_cmp_unsafe(curve->p, point + num_words, num_words) != 1) {
 101672e:	4632      	mov	r2, r6
 1016730:	4638      	mov	r0, r7
 1016732:	eb05 0186 	add.w	r1, r5, r6, lsl #2
 1016736:	f7ff fb02 	bl	1015d3e <uECC_vli_cmp_unsafe>
	if (uECC_vli_cmp_unsafe(curve->p, point, num_words) != 1 ||
 101673a:	2801      	cmp	r0, #1
 101673c:	d118      	bne.n	1016770 <uECC_valid_point+0x64>
		return -2;
	}

	uECC_vli_modSquare_fast(tmp1, point + num_words, curve);
 101673e:	4622      	mov	r2, r4
 1016740:	4668      	mov	r0, sp
 1016742:	f7ff fc15 	bl	1015f70 <uECC_vli_modSquare_fast>
	curve->x_side(tmp2, point, curve); /* tmp2 = x^3 + ax + b */
 1016746:	4622      	mov	r2, r4
 1016748:	4629      	mov	r1, r5
 101674a:	f8d4 30a8 	ldr.w	r3, [r4, #168]	; 0xa8
 101674e:	a808      	add	r0, sp, #32
 1016750:	4798      	blx	r3

	/* Make sure that y^2 == x^3 + ax + b */
	if (uECC_vli_equal(tmp1, tmp2, num_words) != 0)
 1016752:	4632      	mov	r2, r6
 1016754:	4668      	mov	r0, sp
 1016756:	a908      	add	r1, sp, #32
 1016758:	f7ff fb08 	bl	1015d6c <uECC_vli_equal>
 101675c:	2800      	cmp	r0, #0
		return -3;
 101675e:	bf0c      	ite	eq
 1016760:	2000      	moveq	r0, #0
 1016762:	f06f 0002 	mvnne.w	r0, #2

	return 0;
}
 1016766:	b011      	add	sp, #68	; 0x44
 1016768:	bdf0      	pop	{r4, r5, r6, r7, pc}
		return -1;
 101676a:	f04f 30ff 	mov.w	r0, #4294967295
 101676e:	e7fa      	b.n	1016766 <uECC_valid_point+0x5a>
		return -2;
 1016770:	f06f 0001 	mvn.w	r0, #1
 1016774:	e7f7      	b.n	1016766 <uECC_valid_point+0x5a>

01016776 <uECC_valid_public_key>:

int uECC_valid_public_key(const uint8_t *public_key, uECC_Curve curve)
{
 1016776:	b570      	push	{r4, r5, r6, lr}
 1016778:	460c      	mov	r4, r1

	uECC_word_t _public[NUM_ECC_WORDS * 2];

	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
	uECC_vli_bytesToNative(
	_public + curve->num_words,
 101677a:	4626      	mov	r6, r4
{
 101677c:	4605      	mov	r5, r0
 101677e:	b090      	sub	sp, #64	; 0x40
	uECC_vli_bytesToNative(_public, public_key, curve->num_bytes);
 1016780:	f991 2001 	ldrsb.w	r2, [r1, #1]
 1016784:	4601      	mov	r1, r0
 1016786:	4668      	mov	r0, sp
 1016788:	f7ff ffa1 	bl	10166ce <uECC_vli_bytesToNative>
	public_key + curve->num_bytes,
 101678c:	f994 2001 	ldrsb.w	r2, [r4, #1]
	_public + curve->num_words,
 1016790:	f916 0b44 	ldrsb.w	r0, [r6], #68
	uECC_vli_bytesToNative(
 1016794:	18a9      	adds	r1, r5, r2
 1016796:	eb0d 0080 	add.w	r0, sp, r0, lsl #2
 101679a:	f7ff ff98 	bl	10166ce <uECC_vli_bytesToNative>
	curve->num_bytes);

	if (uECC_vli_cmp_unsafe(_public, curve->G, NUM_ECC_WORDS * 2) == 0) {
 101679e:	2210      	movs	r2, #16
 10167a0:	4631      	mov	r1, r6
 10167a2:	4668      	mov	r0, sp
 10167a4:	f7ff facb 	bl	1015d3e <uECC_vli_cmp_unsafe>
 10167a8:	b128      	cbz	r0, 10167b6 <uECC_valid_public_key+0x40>
		return -4;
	}

	return uECC_valid_point(_public, curve);
 10167aa:	4621      	mov	r1, r4
 10167ac:	4668      	mov	r0, sp
 10167ae:	f7ff ffad 	bl	101670c <uECC_valid_point>
}
 10167b2:	b010      	add	sp, #64	; 0x40
 10167b4:	bd70      	pop	{r4, r5, r6, pc}
		return -4;
 10167b6:	f06f 0003 	mvn.w	r0, #3
 10167ba:	e7fa      	b.n	10167b2 <uECC_valid_public_key+0x3c>

010167bc <z_irq_spurious>:
	z_arm_fatal_error(K_ERR_SPURIOUS_IRQ, NULL);
 10167bc:	2100      	movs	r1, #0
 10167be:	2001      	movs	r0, #1
 10167c0:	f7ee bb48 	b.w	1004e54 <z_arm_fatal_error>

010167c4 <z_do_kernel_oops>:
 *   fault handler will executed insted of the SVC.
 *
 * @param esf exception frame
 */
void z_do_kernel_oops(const z_arch_esf_t *esf)
{
 10167c4:	4601      	mov	r1, r0
			reason = K_ERR_KERNEL_OOPS;
		}
	}

#endif /* CONFIG_USERSPACE */
	z_arm_fatal_error(reason, esf);
 10167c6:	6800      	ldr	r0, [r0, #0]
 10167c8:	f7ee bb44 	b.w	1004e54 <z_arm_fatal_error>

010167cc <z_arm_nmi>:
 *
 * @return N/A
 */

void z_arm_nmi(void)
{
 10167cc:	b508      	push	{r3, lr}
	handler();
 10167ce:	f7ee fb79 	bl	1004ec4 <z_SysNmiOnReset>
	z_arm_int_exit();
}
 10167d2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
	z_arm_int_exit();
 10167d6:	f7ee bdc9 	b.w	100536c <z_arm_exc_exit>

010167da <mpu_configure_region>:
{
 10167da:	b530      	push	{r4, r5, lr}
	p_attr->rbar = attr->rbar &
 10167dc:	890a      	ldrh	r2, [r1, #8]
 10167de:	7a8d      	ldrb	r5, [r1, #10]
	region_conf.base = new_region->start;
 10167e0:	680b      	ldr	r3, [r1, #0]
	get_region_attr_from_k_mem_partition_info(&region_conf.attr,
 10167e2:	684c      	ldr	r4, [r1, #4]
 10167e4:	f002 021f 	and.w	r2, r2, #31
{
 10167e8:	b085      	sub	sp, #20
 10167ea:	ea42 1245 	orr.w	r2, r2, r5, lsl #5
	region_conf.base = new_region->start;
 10167ee:	9300      	str	r3, [sp, #0]
 10167f0:	f88d 2008 	strb.w	r2, [sp, #8]
	p_attr->r_limit = REGION_LIMIT_ADDR(base, size);
 10167f4:	f023 031f 	bic.w	r3, r3, #31
 10167f8:	1e62      	subs	r2, r4, #1
 10167fa:	4413      	add	r3, r2
 10167fc:	f023 031f 	bic.w	r3, r3, #31
	if (index > (get_num_regions() - 1)) {
 1016800:	280f      	cmp	r0, #15
 1016802:	4604      	mov	r4, r0
 1016804:	9303      	str	r3, [sp, #12]
 1016806:	d905      	bls.n	1016814 <mpu_configure_region+0x3a>
 1016808:	f7ee fe44 	bl	1005494 <region_allocate_and_init.part.0>
 101680c:	4604      	mov	r4, r0
}
 101680e:	4620      	mov	r0, r4
 1016810:	b005      	add	sp, #20
 1016812:	bd30      	pop	{r4, r5, pc}
	region_init(index, region_conf);
 1016814:	4669      	mov	r1, sp
 1016816:	f7ee fe25 	bl	1005464 <region_init>
	return region_allocate_and_init(index,
 101681a:	e7f8      	b.n	101680e <mpu_configure_region+0x34>

0101681c <arm_cmse_mpu_region_get>:
__CMSE_TT_ASM ()

__extension__ static __inline __attribute__ ((__always_inline__))
cmse_address_info_t
cmse_TT (void *__p)
__CMSE_TT_ASM ()
 101681c:	e840 f300 	tt	r3, r0

int arm_cmse_mpu_region_get(u32_t addr)
{
	cmse_address_info_t addr_info =	cmse_TT((void *)addr);

	if (addr_info.flags.mpu_region_valid) {
 1016820:	f413 3f80 	tst.w	r3, #65536	; 0x10000
 1016824:	b2d8      	uxtb	r0, r3
		return addr_info.flags.mpu_region;
	}

	return -EINVAL;
}
 1016826:	bf08      	it	eq
 1016828:	f06f 0015 	mvneq.w	r0, #21
 101682c:	4770      	bx	lr

0101682e <strncpy>:
 *
 * @return pointer to destination buffer <d>
 */

char *strncpy(char *_MLIBC_RESTRICT d, const char *_MLIBC_RESTRICT s, size_t n)
{
 101682e:	b570      	push	{r4, r5, r6, lr}
 1016830:	4605      	mov	r5, r0
 1016832:	3901      	subs	r1, #1
 1016834:	462c      	mov	r4, r5
	char *dest = d;

	while ((n > 0) && *s != '\0') {
 1016836:	b142      	cbz	r2, 101684a <strncpy+0x1c>
 1016838:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 101683c:	1e56      	subs	r6, r2, #1
 101683e:	b92b      	cbnz	r3, 101684c <strncpy+0x1e>
 1016840:	442a      	add	r2, r5
		d++;
		n--;
	}

	while (n > 0) {
		*d = '\0';
 1016842:	f804 3b01 	strb.w	r3, [r4], #1
	while (n > 0) {
 1016846:	42a2      	cmp	r2, r4
 1016848:	d1fb      	bne.n	1016842 <strncpy+0x14>
		d++;
		n--;
	}

	return dest;
}
 101684a:	bd70      	pop	{r4, r5, r6, pc}
		n--;
 101684c:	4632      	mov	r2, r6
		*d = *s;
 101684e:	f805 3b01 	strb.w	r3, [r5], #1
		n--;
 1016852:	e7ef      	b.n	1016834 <strncpy+0x6>

01016854 <strlen>:
 *
 * @return number of bytes in string <s>
 */

size_t strlen(const char *s)
{
 1016854:	4603      	mov	r3, r0
	size_t n = 0;
 1016856:	2000      	movs	r0, #0

	while (*s != '\0') {
 1016858:	5c1a      	ldrb	r2, [r3, r0]
 101685a:	b902      	cbnz	r2, 101685e <strlen+0xa>
		s++;
		n++;
	}

	return n;
}
 101685c:	4770      	bx	lr
		n++;
 101685e:	3001      	adds	r0, #1
 1016860:	e7fa      	b.n	1016858 <strlen+0x4>

01016862 <strcmp>:
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strcmp(const char *s1, const char *s2)
{
	while ((*s1 == *s2) && (*s1 != '\0')) {
 1016862:	1e43      	subs	r3, r0, #1
 1016864:	3901      	subs	r1, #1
 1016866:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 101686a:	f811 0f01 	ldrb.w	r0, [r1, #1]!
 101686e:	4282      	cmp	r2, r0
 1016870:	d101      	bne.n	1016876 <strcmp+0x14>
 1016872:	2a00      	cmp	r2, #0
 1016874:	d1f7      	bne.n	1016866 <strcmp+0x4>
		s1++;
		s2++;
	}

	return *s1 - *s2;
}
 1016876:	1a10      	subs	r0, r2, r0
 1016878:	4770      	bx	lr

0101687a <strncmp>:
 *
 * @return negative # if <s1> < <s2>, 0 if <s1> == <s2>, else positive #
 */

int strncmp(const char *s1, const char *s2, size_t n)
{
 101687a:	b530      	push	{r4, r5, lr}
	while ((n > 0) && (*s1 == *s2) && (*s1 != '\0')) {
 101687c:	2400      	movs	r4, #0
 101687e:	42a2      	cmp	r2, r4
 1016880:	d008      	beq.n	1016894 <strncmp+0x1a>
 1016882:	5d03      	ldrb	r3, [r0, r4]
 1016884:	5d0d      	ldrb	r5, [r1, r4]
 1016886:	42ab      	cmp	r3, r5
 1016888:	d102      	bne.n	1016890 <strncmp+0x16>
 101688a:	3401      	adds	r4, #1
 101688c:	2b00      	cmp	r3, #0
 101688e:	d1f6      	bne.n	101687e <strncmp+0x4>
		s1++;
		s2++;
		n--;
	}

	return (n == 0) ? 0 : (*s1 - *s2);
 1016890:	1b58      	subs	r0, r3, r5
 1016892:	e000      	b.n	1016896 <strncmp+0x1c>
 1016894:	2000      	movs	r0, #0
}
 1016896:	bd30      	pop	{r4, r5, pc}

01016898 <memcmp>:
 * @brief Compare two memory areas
 *
 * @return negative # if <m1> < <m2>, 0 if <m1> == <m2>, else positive #
 */
int memcmp(const void *m1, const void *m2, size_t n)
{
 1016898:	b510      	push	{r4, lr}
	const char *c1 = m1;
	const char *c2 = m2;

	if (!n) {
 101689a:	b15a      	cbz	r2, 10168b4 <memcmp+0x1c>
 101689c:	3901      	subs	r1, #1
 101689e:	1884      	adds	r4, r0, r2
		return 0;
	}

	while ((--n > 0) && (*c1 == *c2)) {
 10168a0:	f810 2b01 	ldrb.w	r2, [r0], #1
 10168a4:	f811 3f01 	ldrb.w	r3, [r1, #1]!
 10168a8:	42a0      	cmp	r0, r4
 10168aa:	d001      	beq.n	10168b0 <memcmp+0x18>
 10168ac:	429a      	cmp	r2, r3
 10168ae:	d0f7      	beq.n	10168a0 <memcmp+0x8>
		c1++;
		c2++;
	}

	return *c1 - *c2;
 10168b0:	1ad0      	subs	r0, r2, r3
}
 10168b2:	bd10      	pop	{r4, pc}
		return 0;
 10168b4:	4610      	mov	r0, r2
 10168b6:	e7fc      	b.n	10168b2 <memcmp+0x1a>

010168b8 <memcpy>:
 *
 * @return pointer to start of destination buffer
 */

void *memcpy(void *_MLIBC_RESTRICT d, const void *_MLIBC_RESTRICT s, size_t n)
{
 10168b8:	b5f0      	push	{r4, r5, r6, r7, lr}

	unsigned char *d_byte = (unsigned char *)d;
	const unsigned char *s_byte = (const unsigned char *)s;
	const uintptr_t mask = sizeof(mem_word_t) - 1;

	if ((((uintptr_t)d ^ (uintptr_t)s_byte) & mask) == 0) {
 10168ba:	ea81 0400 	eor.w	r4, r1, r0
 10168be:	07a5      	lsls	r5, r4, #30
 10168c0:	4603      	mov	r3, r0
 10168c2:	d00b      	beq.n	10168dc <memcpy+0x24>
 10168c4:	3b01      	subs	r3, #1
 10168c6:	440a      	add	r2, r1
		s_byte = (unsigned char *)s_word;
	}

	/* do byte-sized copying until finished */

	while (n > 0) {
 10168c8:	4291      	cmp	r1, r2
 10168ca:	d11b      	bne.n	1016904 <memcpy+0x4c>
		*(d_byte++) = *(s_byte++);
		n--;
	}

	return d;
}
 10168cc:	bdf0      	pop	{r4, r5, r6, r7, pc}
			if (n == 0) {
 10168ce:	2a00      	cmp	r2, #0
 10168d0:	d0fc      	beq.n	10168cc <memcpy+0x14>
			*(d_byte++) = *(s_byte++);
 10168d2:	f811 4b01 	ldrb.w	r4, [r1], #1
			n--;
 10168d6:	3a01      	subs	r2, #1
			*(d_byte++) = *(s_byte++);
 10168d8:	f803 4b01 	strb.w	r4, [r3], #1
		while (((uintptr_t)d_byte) & mask) {
 10168dc:	079c      	lsls	r4, r3, #30
 10168de:	d1f6      	bne.n	10168ce <memcpy+0x16>
 10168e0:	f022 0403 	bic.w	r4, r2, #3
 10168e4:	1f1d      	subs	r5, r3, #4
 10168e6:	0896      	lsrs	r6, r2, #2
 10168e8:	190f      	adds	r7, r1, r4
		while (n >= sizeof(mem_word_t)) {
 10168ea:	42b9      	cmp	r1, r7
 10168ec:	d105      	bne.n	10168fa <memcpy+0x42>
 10168ee:	f06f 0503 	mvn.w	r5, #3
 10168f2:	4423      	add	r3, r4
 10168f4:	fb05 2206 	mla	r2, r5, r6, r2
 10168f8:	e7e4      	b.n	10168c4 <memcpy+0xc>
			*(d_word++) = *(s_word++);
 10168fa:	f851 cb04 	ldr.w	ip, [r1], #4
 10168fe:	f845 cf04 	str.w	ip, [r5, #4]!
			n -= sizeof(mem_word_t);
 1016902:	e7f2      	b.n	10168ea <memcpy+0x32>
		*(d_byte++) = *(s_byte++);
 1016904:	f811 4b01 	ldrb.w	r4, [r1], #1
 1016908:	f803 4f01 	strb.w	r4, [r3, #1]!
		n--;
 101690c:	e7dc      	b.n	10168c8 <memcpy+0x10>

0101690e <memset>:

void *memset(void *buf, int c, size_t n)
{
	/* do byte-sized initialization until word-aligned or finished */

	unsigned char *d_byte = (unsigned char *)buf;
 101690e:	4603      	mov	r3, r0
{
 1016910:	b570      	push	{r4, r5, r6, lr}
	unsigned char c_byte = (unsigned char)c;
 1016912:	b2c9      	uxtb	r1, r1

	while (((uintptr_t)d_byte) & (sizeof(mem_word_t) - 1)) {
 1016914:	079c      	lsls	r4, r3, #30
 1016916:	d111      	bne.n	101693c <memset+0x2e>
	/* do word-sized initialization as long as possible */

	mem_word_t *d_word = (mem_word_t *)d_byte;
	mem_word_t c_word = (mem_word_t)c_byte;

	c_word |= c_word << 8;
 1016918:	ea41 2401 	orr.w	r4, r1, r1, lsl #8
	c_word |= c_word << 16;
 101691c:	f022 0603 	bic.w	r6, r2, #3
 1016920:	ea44 4504 	orr.w	r5, r4, r4, lsl #16
#if Z_MEM_WORD_T_WIDTH > 32
	c_word |= c_word << 32;
#endif

	while (n >= sizeof(mem_word_t)) {
 1016924:	441e      	add	r6, r3
 1016926:	0894      	lsrs	r4, r2, #2
 1016928:	42b3      	cmp	r3, r6
 101692a:	d10d      	bne.n	1016948 <memset+0x3a>
 101692c:	f06f 0503 	mvn.w	r5, #3
 1016930:	fb05 2204 	mla	r2, r5, r4, r2
 1016934:	441a      	add	r2, r3

	/* do byte-sized initialization until finished */

	d_byte = (unsigned char *)d_word;

	while (n > 0) {
 1016936:	4293      	cmp	r3, r2
 1016938:	d109      	bne.n	101694e <memset+0x40>
		*(d_byte++) = c_byte;
		n--;
	}

	return buf;
}
 101693a:	bd70      	pop	{r4, r5, r6, pc}
		if (n == 0) {
 101693c:	2a00      	cmp	r2, #0
 101693e:	d0fc      	beq.n	101693a <memset+0x2c>
		*(d_byte++) = c_byte;
 1016940:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
 1016944:	3a01      	subs	r2, #1
 1016946:	e7e5      	b.n	1016914 <memset+0x6>
		*(d_word++) = c_word;
 1016948:	f843 5b04 	str.w	r5, [r3], #4
		n -= sizeof(mem_word_t);
 101694c:	e7ec      	b.n	1016928 <memset+0x1a>
		*(d_byte++) = c_byte;
 101694e:	f803 1b01 	strb.w	r1, [r3], #1
		n--;
 1016952:	e7f0      	b.n	1016936 <memset+0x28>

01016954 <_stdout_hook_default>:
}
 1016954:	f04f 30ff 	mov.w	r0, #4294967295
 1016958:	4770      	bx	lr

0101695a <ah>:
	return bt_encrypt_le(key, plaintext, enc_data);
#endif
}

static int ah(const u8_t irk[16], const u8_t r[3], u8_t out[3])
{
 101695a:	b530      	push	{r4, r5, lr}
 101695c:	4604      	mov	r4, r0
 101695e:	b085      	sub	sp, #20
 1016960:	4615      	mov	r5, r2

	BT_DBG("irk %s", bt_hex(irk, 16));
	BT_DBG("r %s", bt_hex(r, 3));

	/* r' = padding || r */
	memcpy(res, r, 3);
 1016962:	4668      	mov	r0, sp
 1016964:	2203      	movs	r2, #3
 1016966:	f7ff ffa7 	bl	10168b8 <memcpy>
	(void)memset(res + 3, 0, 13);
 101696a:	220d      	movs	r2, #13
 101696c:	2100      	movs	r1, #0
 101696e:	f10d 0003 	add.w	r0, sp, #3
 1016972:	f7ff ffcc 	bl	101690e <memset>
	return bt_encrypt_le(key, plaintext, enc_data);
 1016976:	4620      	mov	r0, r4
 1016978:	466a      	mov	r2, sp
 101697a:	4669      	mov	r1, sp
 101697c:	f7f2 fbd4 	bl	1009128 <bt_encrypt_le>

	err = internal_encrypt_le(irk, res, res);
	if (err) {
 1016980:	4604      	mov	r4, r0
 1016982:	b920      	cbnz	r0, 101698e <ah+0x34>
	 *      ah(h, r) = e(k, r') mod 2^24
	 * The output of the security function e is then truncated to 24 bits
	 * by taking the least significant 24 bits of the output of e as the
	 * result of ah.
	 */
	memcpy(out, res, 3);
 1016984:	2203      	movs	r2, #3
 1016986:	4669      	mov	r1, sp
 1016988:	4628      	mov	r0, r5
 101698a:	f7ff ff95 	bl	10168b8 <memcpy>

	return 0;
}
 101698e:	4620      	mov	r0, r4
 1016990:	b005      	add	sp, #20
 1016992:	bd30      	pop	{r4, r5, pc}

01016994 <bt_rpa_irk_matches>:

#if defined(CONFIG_BT_SMP) || defined(CONFIG_BT_CTLR_PRIVACY)
bool bt_rpa_irk_matches(const u8_t irk[16], const bt_addr_t *addr)
{
 1016994:	b513      	push	{r0, r1, r4, lr}
 1016996:	460c      	mov	r4, r1
	u8_t hash[3];
	int err;

	BT_DBG("IRK %s bdaddr %s", bt_hex(irk, 16), bt_addr_str(addr));

	err = ah(irk, addr->val + 3, hash);
 1016998:	aa01      	add	r2, sp, #4
 101699a:	3103      	adds	r1, #3
 101699c:	f7ff ffdd 	bl	101695a <ah>
	if (err) {
 10169a0:	b948      	cbnz	r0, 10169b6 <bt_rpa_irk_matches+0x22>
		return false;
	}

	return !memcmp(addr->val, hash, 3);
 10169a2:	2203      	movs	r2, #3
 10169a4:	4620      	mov	r0, r4
 10169a6:	a901      	add	r1, sp, #4
 10169a8:	f7ff ff76 	bl	1016898 <memcmp>
 10169ac:	fab0 f080 	clz	r0, r0
 10169b0:	0940      	lsrs	r0, r0, #5
}
 10169b2:	b002      	add	sp, #8
 10169b4:	bd10      	pop	{r4, pc}
		return false;
 10169b6:	2000      	movs	r0, #0
 10169b8:	e7fb      	b.n	10169b2 <bt_rpa_irk_matches+0x1e>

010169ba <bt_rpa_create>:
#endif

#if defined(CONFIG_BT_PRIVACY) || defined(CONFIG_BT_CTLR_PRIVACY)
int bt_rpa_create(const u8_t irk[16], bt_addr_t *rpa)
{
 10169ba:	b570      	push	{r4, r5, r6, lr}
	int err;

	err = internal_rand(rpa->val + 3, 3);
 10169bc:	1cce      	adds	r6, r1, #3
{
 10169be:	4605      	mov	r5, r0
 10169c0:	460c      	mov	r4, r1
	return bt_rand(buf, len);
 10169c2:	4630      	mov	r0, r6
 10169c4:	2103      	movs	r1, #3
 10169c6:	f7f2 fbad 	bl	1009124 <bt_rand>
	if (err) {
 10169ca:	b960      	cbnz	r0, 10169e6 <bt_rpa_create+0x2c>
		return err;
	}

	BT_ADDR_SET_RPA(rpa);
 10169cc:	7963      	ldrb	r3, [r4, #5]

	err = ah(irk, rpa->val + 3, rpa->val);
 10169ce:	4622      	mov	r2, r4
	BT_ADDR_SET_RPA(rpa);
 10169d0:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 10169d4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
	err = ah(irk, rpa->val + 3, rpa->val);
 10169d8:	4631      	mov	r1, r6
 10169da:	4628      	mov	r0, r5
	BT_ADDR_SET_RPA(rpa);
 10169dc:	7163      	strb	r3, [r4, #5]
	}

	BT_DBG("Created RPA %s", bt_addr_str((bt_addr_t *)rpa->val));

	return 0;
}
 10169de:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
	err = ah(irk, rpa->val + 3, rpa->val);
 10169e2:	f7ff bfba 	b.w	101695a <ah>
}
 10169e6:	bd70      	pop	{r4, r5, r6, pc}

010169e8 <bt_buf_get_evt>:
	return bt_buf_get_rx(BT_BUF_EVT, timeout);
 10169e8:	2001      	movs	r0, #1
 10169ea:	f7ee bed7 	b.w	100579c <bt_buf_get_rx>

010169ee <bt_recv_prio>:
	return bt_recv(buf);
 10169ee:	f7ee bf39 	b.w	1005864 <bt_recv>

010169f2 <bt_send>:
		return bt_hci_ecc_send(buf);
 10169f2:	f7ef b849 	b.w	1005a88 <bt_hci_ecc_send>

010169f6 <send_cmd_status>:
{
 10169f6:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
 10169fa:	f04f 32ff 	mov.w	r2, #4294967295
{
 10169fe:	4606      	mov	r6, r0
 1016a00:	460d      	mov	r5, r1
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
 1016a02:	f04f 33ff 	mov.w	r3, #4294967295
 1016a06:	2100      	movs	r1, #0
 1016a08:	200f      	movs	r0, #15
 1016a0a:	f7ff ffed 	bl	10169e8 <bt_buf_get_evt>
	*(u8_t *)net_buf_user_data(buf) = type;
 1016a0e:	2701      	movs	r7, #1
	hdr = net_buf_add(buf, sizeof(*hdr));
 1016a10:	f100 0808 	add.w	r8, r0, #8
	buf = bt_buf_get_evt(BT_HCI_EVT_CMD_STATUS, false, K_FOREVER);
 1016a14:	4604      	mov	r4, r0
 1016a16:	7507      	strb	r7, [r0, #20]
	hdr = net_buf_add(buf, sizeof(*hdr));
 1016a18:	2102      	movs	r1, #2
 1016a1a:	4640      	mov	r0, r8
 1016a1c:	f000 f851 	bl	1016ac2 <net_buf_simple_add>
	hdr->evt = BT_HCI_EVT_CMD_STATUS;
 1016a20:	230f      	movs	r3, #15
	hdr->len = sizeof(*evt);
 1016a22:	2104      	movs	r1, #4
	hdr->evt = BT_HCI_EVT_CMD_STATUS;
 1016a24:	7003      	strb	r3, [r0, #0]
	hdr->len = sizeof(*evt);
 1016a26:	7041      	strb	r1, [r0, #1]
	evt = net_buf_add(buf, sizeof(*evt));
 1016a28:	4640      	mov	r0, r8
 1016a2a:	f000 f84a 	bl	1016ac2 <net_buf_simple_add>
	evt->ncmd = 1U;
 1016a2e:	7047      	strb	r7, [r0, #1]
	evt->status = status;
 1016a30:	7005      	strb	r5, [r0, #0]
	evt->opcode = sys_cpu_to_le16(opcode);
 1016a32:	8046      	strh	r6, [r0, #2]
	bt_recv_prio(buf);
 1016a34:	4620      	mov	r0, r4
}
 1016a36:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
	bt_recv_prio(buf);
 1016a3a:	f7ff bfd8 	b.w	10169ee <bt_recv_prio>

01016a3e <sys_memcpy_swap.constprop.0>:
	for (; length > 0; length--) {
 1016a3e:	f101 0320 	add.w	r3, r1, #32
 1016a42:	3801      	subs	r0, #1
		*pdst++ = *psrc--;
 1016a44:	f813 2d01 	ldrb.w	r2, [r3, #-1]!
	for (; length > 0; length--) {
 1016a48:	428b      	cmp	r3, r1
		*pdst++ = *psrc--;
 1016a4a:	f800 2f01 	strb.w	r2, [r0, #1]!
	for (; length > 0; length--) {
 1016a4e:	d1f9      	bne.n	1016a44 <sys_memcpy_swap.constprop.0+0x6>
	}
}
 1016a50:	4770      	bx	lr

01016a52 <default_CSPRNG>:
{
 1016a52:	b508      	push	{r3, lr}
	return !bt_rand(dst, len);
 1016a54:	f7f2 fb66 	bl	1009124 <bt_rand>
}
 1016a58:	fab0 f080 	clz	r0, r0
 1016a5c:	0940      	lsrs	r0, r0, #5
 1016a5e:	bd08      	pop	{r3, pc}

01016a60 <fixed_data_unref>:
}
 1016a60:	4770      	bx	lr

01016a62 <net_buf_alloc_fixed>:
	const struct net_buf_pool_fixed *fixed = pool->alloc->alloc_data;
 1016a62:	6a01      	ldr	r1, [r0, #32]
	return net_buf_alloc_len(pool, fixed->data_size, timeout);
 1016a64:	6849      	ldr	r1, [r1, #4]
 1016a66:	6809      	ldr	r1, [r1, #0]
 1016a68:	f7fb bedc 	b.w	1012824 <net_buf_alloc_len>

01016a6c <net_buf_get>:
{
 1016a6c:	b570      	push	{r4, r5, r6, lr}
 1016a6e:	4606      	mov	r6, r0
	return z_impl_k_queue_get(queue, timeout);
 1016a70:	f7fd faaa 	bl	1013fc8 <z_impl_k_queue_get>
	if (!buf) {
 1016a74:	4605      	mov	r5, r0
 1016a76:	b128      	cbz	r0, 1016a84 <net_buf_get+0x18>
 1016a78:	4604      	mov	r4, r0
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
 1016a7a:	7963      	ldrb	r3, [r4, #5]
 1016a7c:	f013 0301 	ands.w	r3, r3, #1
 1016a80:	d102      	bne.n	1016a88 <net_buf_get+0x1c>
	frag->frags = NULL;
 1016a82:	6023      	str	r3, [r4, #0]
}
 1016a84:	4628      	mov	r0, r5
 1016a86:	bd70      	pop	{r4, r5, r6, pc}
 1016a88:	2300      	movs	r3, #0
 1016a8a:	2200      	movs	r2, #0
 1016a8c:	4630      	mov	r0, r6
 1016a8e:	f7fd fa9b 	bl	1013fc8 <z_impl_k_queue_get>
		frag->flags &= ~NET_BUF_FRAGS;
 1016a92:	7963      	ldrb	r3, [r4, #5]
		frag->frags = k_fifo_get(fifo, K_NO_WAIT);
 1016a94:	6020      	str	r0, [r4, #0]
		frag->flags &= ~NET_BUF_FRAGS;
 1016a96:	f023 0301 	bic.w	r3, r3, #1
 1016a9a:	7163      	strb	r3, [r4, #5]
	for (frag = buf; (frag->flags & NET_BUF_FRAGS); frag = frag->frags) {
 1016a9c:	4604      	mov	r4, r0
 1016a9e:	e7ec      	b.n	1016a7a <net_buf_get+0xe>

01016aa0 <net_buf_simple_reserve>:
	buf->data = buf->__buf + reserve;
 1016aa0:	6883      	ldr	r3, [r0, #8]
 1016aa2:	440b      	add	r3, r1
 1016aa4:	6003      	str	r3, [r0, #0]
}
 1016aa6:	4770      	bx	lr

01016aa8 <net_buf_put>:
	for (tail = buf; tail->frags; tail = tail->frags) {
 1016aa8:	460a      	mov	r2, r1
{
 1016aaa:	b410      	push	{r4}
	for (tail = buf; tail->frags; tail = tail->frags) {
 1016aac:	6814      	ldr	r4, [r2, #0]
 1016aae:	b914      	cbnz	r4, 1016ab6 <net_buf_put+0xe>
}
 1016ab0:	bc10      	pop	{r4}
	k_fifo_put_list(fifo, buf, tail);
 1016ab2:	f000 bea0 	b.w	10177f6 <k_queue_append_list>
		tail->flags |= NET_BUF_FRAGS;
 1016ab6:	7953      	ldrb	r3, [r2, #5]
 1016ab8:	f043 0301 	orr.w	r3, r3, #1
 1016abc:	7153      	strb	r3, [r2, #5]
 1016abe:	4622      	mov	r2, r4
 1016ac0:	e7f4      	b.n	1016aac <net_buf_put+0x4>

01016ac2 <net_buf_simple_add>:
	return buf->data + buf->len;
 1016ac2:	8883      	ldrh	r3, [r0, #4]
 1016ac4:	6802      	ldr	r2, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_tailroom(buf) >= len);

	buf->len += len;
 1016ac6:	4419      	add	r1, r3
 1016ac8:	8081      	strh	r1, [r0, #4]
	return tail;
}
 1016aca:	18d0      	adds	r0, r2, r3
 1016acc:	4770      	bx	lr

01016ace <net_buf_simple_add_mem>:

void *net_buf_simple_add_mem(struct net_buf_simple *buf, const void *mem,
			     size_t len)
{
 1016ace:	b430      	push	{r4, r5}
 1016ad0:	8884      	ldrh	r4, [r0, #4]
 1016ad2:	6805      	ldr	r5, [r0, #0]
	buf->len += len;
 1016ad4:	18a3      	adds	r3, r4, r2
 1016ad6:	8083      	strh	r3, [r0, #4]
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	return memcpy(net_buf_simple_add(buf, len), mem, len);
 1016ad8:	1928      	adds	r0, r5, r4
}
 1016ada:	bc30      	pop	{r4, r5}
	return memcpy(net_buf_simple_add(buf, len), mem, len);
 1016adc:	f7ff beec 	b.w	10168b8 <memcpy>

01016ae0 <net_buf_simple_push_u8>:
{
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(net_buf_simple_headroom(buf) >= len);

	buf->data -= len;
 1016ae0:	6802      	ldr	r2, [r0, #0]
 1016ae2:	1e53      	subs	r3, r2, #1
 1016ae4:	6003      	str	r3, [r0, #0]
	buf->len += len;
 1016ae6:	8883      	ldrh	r3, [r0, #4]
 1016ae8:	3301      	adds	r3, #1
 1016aea:	8083      	strh	r3, [r0, #4]

void net_buf_simple_push_u8(struct net_buf_simple *buf, u8_t val)
{
	u8_t *data = net_buf_simple_push(buf, 1);

	*data = val;
 1016aec:	f802 1c01 	strb.w	r1, [r2, #-1]
}
 1016af0:	4770      	bx	lr

01016af2 <net_buf_simple_pull>:

	sys_put_be64(val, net_buf_simple_push(buf, sizeof(val)));
}

void *net_buf_simple_pull(struct net_buf_simple *buf, size_t len)
{
 1016af2:	4603      	mov	r3, r0
	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
 1016af4:	8882      	ldrh	r2, [r0, #4]
 1016af6:	1a52      	subs	r2, r2, r1
 1016af8:	8082      	strh	r2, [r0, #4]
	return buf->data += len;
 1016afa:	6800      	ldr	r0, [r0, #0]
 1016afc:	4408      	add	r0, r1
 1016afe:	6018      	str	r0, [r3, #0]
}
 1016b00:	4770      	bx	lr

01016b02 <net_buf_simple_pull_mem>:

void *net_buf_simple_pull_mem(struct net_buf_simple *buf, size_t len)
{
 1016b02:	4603      	mov	r3, r0
	void *data = buf->data;
 1016b04:	6800      	ldr	r0, [r0, #0]

	NET_BUF_SIMPLE_DBG("buf %p len %zu", buf, len);

	__ASSERT_NO_MSG(buf->len >= len);

	buf->len -= len;
 1016b06:	889a      	ldrh	r2, [r3, #4]
 1016b08:	1a52      	subs	r2, r2, r1
	buf->data += len;
 1016b0a:	4401      	add	r1, r0
	buf->len -= len;
 1016b0c:	809a      	strh	r2, [r3, #4]
	buf->data += len;
 1016b0e:	6019      	str	r1, [r3, #0]

	return data;
}
 1016b10:	4770      	bx	lr

01016b12 <gpio_nrfx_port_get_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1016b12:	6843      	ldr	r3, [r0, #4]
}
 1016b14:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1016b16:	685b      	ldr	r3, [r3, #4]
    return p_reg->IN;
 1016b18:	691b      	ldr	r3, [r3, #16]
	*value = nrf_gpio_port_in_read(reg);
 1016b1a:	600b      	str	r3, [r1, #0]
}
 1016b1c:	4770      	bx	lr

01016b1e <gpio_nrfx_port_set_masked_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1016b1e:	6843      	ldr	r3, [r0, #4]
 1016b20:	685b      	ldr	r3, [r3, #4]
    return p_reg->OUT;
 1016b22:	6858      	ldr	r0, [r3, #4]
	nrf_gpio_port_out_write(reg, value_tmp | (mask & value));
 1016b24:	4042      	eors	r2, r0
 1016b26:	400a      	ands	r2, r1
 1016b28:	4042      	eors	r2, r0
    p_reg->OUT = value;
 1016b2a:	605a      	str	r2, [r3, #4]
}
 1016b2c:	2000      	movs	r0, #0
 1016b2e:	4770      	bx	lr

01016b30 <gpio_nrfx_port_set_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1016b30:	6843      	ldr	r3, [r0, #4]
}
 1016b32:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1016b34:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTSET = set_mask;
 1016b36:	6099      	str	r1, [r3, #8]
}
 1016b38:	4770      	bx	lr

01016b3a <gpio_nrfx_port_clear_bits_raw>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1016b3a:	6843      	ldr	r3, [r0, #4]
}
 1016b3c:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1016b3e:	685b      	ldr	r3, [r3, #4]
    p_reg->OUTCLR = clr_mask;
 1016b40:	60d9      	str	r1, [r3, #12]
}
 1016b42:	4770      	bx	lr

01016b44 <gpio_nrfx_port_toggle_bits>:
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1016b44:	6843      	ldr	r3, [r0, #4]
}
 1016b46:	2000      	movs	r0, #0
	NRF_GPIO_Type *reg = get_port_cfg(port)->port;
 1016b48:	685a      	ldr	r2, [r3, #4]
    return p_reg->OUT;
 1016b4a:	6853      	ldr	r3, [r2, #4]
	nrf_gpio_port_out_write(reg, value ^ mask);
 1016b4c:	404b      	eors	r3, r1
    p_reg->OUT = value;
 1016b4e:	6053      	str	r3, [r2, #4]
}
 1016b50:	4770      	bx	lr

01016b52 <gpio_nrfx_manage_callback>:
	return gpio_manage_callback(&get_port_data(port)->callbacks,
 1016b52:	68c3      	ldr	r3, [r0, #12]
{
 1016b54:	b530      	push	{r4, r5, lr}
Z_GENLIST_IS_EMPTY(slist)
 1016b56:	6858      	ldr	r0, [r3, #4]
					bool set)
{
	__ASSERT(callback, "No callback!");
	__ASSERT(callback->handler, "No callback handler!");

	if (!sys_slist_is_empty(callbacks)) {
 1016b58:	b158      	cbz	r0, 1016b72 <gpio_nrfx_manage_callback+0x20>
 * @return true if node was removed
 */
static inline bool sys_slist_find_and_remove(sys_slist_t *list,
					     sys_snode_t *node);

Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 1016b5a:	2400      	movs	r4, #0
 1016b5c:	4281      	cmp	r1, r0
 1016b5e:	d113      	bne.n	1016b88 <gpio_nrfx_manage_callback+0x36>
Z_GENLIST_REMOVE(slist, snode)
 1016b60:	6808      	ldr	r0, [r1, #0]
 1016b62:	b95c      	cbnz	r4, 1016b7c <gpio_nrfx_manage_callback+0x2a>
 1016b64:	689c      	ldr	r4, [r3, #8]
	list->head = node;
 1016b66:	6058      	str	r0, [r3, #4]
Z_GENLIST_REMOVE(slist, snode)
 1016b68:	42a1      	cmp	r1, r4
 1016b6a:	d100      	bne.n	1016b6e <gpio_nrfx_manage_callback+0x1c>
	list->tail = node;
 1016b6c:	6098      	str	r0, [r3, #8]
	parent->next = child;
 1016b6e:	2000      	movs	r0, #0
 1016b70:	6008      	str	r0, [r1, #0]
				return -EINVAL;
			}
		}
	}

	if (set) {
 1016b72:	b972      	cbnz	r2, 1016b92 <gpio_nrfx_manage_callback+0x40>
		sys_slist_prepend(callbacks, &callback->node);
	}

	return 0;
 1016b74:	2000      	movs	r0, #0
}
 1016b76:	bd30      	pop	{r4, r5, pc}
 1016b78:	4628      	mov	r0, r5
 1016b7a:	e7ef      	b.n	1016b5c <gpio_nrfx_manage_callback+0xa>
 1016b7c:	6020      	str	r0, [r4, #0]
Z_GENLIST_REMOVE(slist, snode)
 1016b7e:	6898      	ldr	r0, [r3, #8]
 1016b80:	4281      	cmp	r1, r0
	list->tail = node;
 1016b82:	bf08      	it	eq
 1016b84:	609c      	streq	r4, [r3, #8]
}
 1016b86:	e7f2      	b.n	1016b6e <gpio_nrfx_manage_callback+0x1c>
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 1016b88:	6805      	ldr	r5, [r0, #0]
Z_GENLIST_FIND_AND_REMOVE(slist, snode)
 1016b8a:	4604      	mov	r4, r0
 1016b8c:	2d00      	cmp	r5, #0
 1016b8e:	d1f3      	bne.n	1016b78 <gpio_nrfx_manage_callback+0x26>
			if (!set) {
 1016b90:	b13a      	cbz	r2, 1016ba2 <gpio_nrfx_manage_callback+0x50>
Z_GENLIST_PREPEND(slist, snode)
 1016b92:	685a      	ldr	r2, [r3, #4]
	parent->next = child;
 1016b94:	600a      	str	r2, [r1, #0]
Z_GENLIST_PREPEND(slist, snode)
 1016b96:	6898      	ldr	r0, [r3, #8]
	list->head = node;
 1016b98:	6059      	str	r1, [r3, #4]
Z_GENLIST_PREPEND(slist, snode)
 1016b9a:	2800      	cmp	r0, #0
 1016b9c:	d1ea      	bne.n	1016b74 <gpio_nrfx_manage_callback+0x22>
	list->tail = node;
 1016b9e:	6099      	str	r1, [r3, #8]
}
 1016ba0:	e7e9      	b.n	1016b76 <gpio_nrfx_manage_callback+0x24>
				return -EINVAL;
 1016ba2:	f06f 0015 	mvn.w	r0, #21
	return gpio_manage_callback(&get_port_data(port)->callbacks,
 1016ba6:	e7e6      	b.n	1016b76 <gpio_nrfx_manage_callback+0x24>

01016ba8 <fire_callbacks>:
{
 1016ba8:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	struct gpio_nrfx_data *data = get_port_data(port);
 1016baa:	68c7      	ldr	r7, [r0, #12]
{
 1016bac:	460e      	mov	r6, r1
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 1016bae:	6879      	ldr	r1, [r7, #4]
{
 1016bb0:	4605      	mov	r5, r0
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 1016bb2:	b199      	cbz	r1, 1016bdc <fire_callbacks+0x34>
	return node->next;
 1016bb4:	680c      	ldr	r4, [r1, #0]
 1016bb6:	2c00      	cmp	r4, #0
 1016bb8:	bf38      	it	cc
 1016bba:	2400      	movcc	r4, #0
		if ((cb->pin_mask & pins) & data->int_en) {
 1016bbc:	688a      	ldr	r2, [r1, #8]
 1016bbe:	693b      	ldr	r3, [r7, #16]
 1016bc0:	4032      	ands	r2, r6
 1016bc2:	421a      	tst	r2, r3
 1016bc4:	d002      	beq.n	1016bcc <fire_callbacks+0x24>
			cb->handler(port, cb, cb->pin_mask & pins);
 1016bc6:	4628      	mov	r0, r5
 1016bc8:	684b      	ldr	r3, [r1, #4]
 1016bca:	4798      	blx	r3
	SYS_SLIST_FOR_EACH_CONTAINER_SAFE(list, cb, tmp, node) {
 1016bcc:	b134      	cbz	r4, 1016bdc <fire_callbacks+0x34>
 1016bce:	6823      	ldr	r3, [r4, #0]
Z_GENLIST_PEEK_NEXT_NO_CHECK(slist, snode)
 1016bd0:	4621      	mov	r1, r4
 1016bd2:	2b00      	cmp	r3, #0
 1016bd4:	bf38      	it	cc
 1016bd6:	2300      	movcc	r3, #0
 1016bd8:	461c      	mov	r4, r3
 1016bda:	e7ef      	b.n	1016bbc <fire_callbacks+0x14>
}
 1016bdc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

01016bde <gpio_nrfx_pin_disable_callback>:
	WRITE_BIT(data->int_en, pin, enable);
 1016bde:	2301      	movs	r3, #1
{
 1016be0:	b410      	push	{r4}
	struct gpio_nrfx_data *data = get_port_data(port);
 1016be2:	68c4      	ldr	r4, [r0, #12]
	WRITE_BIT(data->int_en, pin, enable);
 1016be4:	fa03 f201 	lsl.w	r2, r3, r1
 1016be8:	6923      	ldr	r3, [r4, #16]
 1016bea:	ea23 0302 	bic.w	r3, r3, r2
 1016bee:	6123      	str	r3, [r4, #16]
}
 1016bf0:	bc10      	pop	{r4}
	return gpiote_pin_int_cfg(port, pin);
 1016bf2:	f7fb bf61 	b.w	1012ab8 <gpiote_pin_int_cfg>

01016bf6 <check_level_trigger_pins>:
{
 1016bf6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t bit = 1U << pin;
 1016bf8:	2501      	movs	r5, #1
	u32_t pin = 0U;
 1016bfa:	2600      	movs	r6, #0
	struct gpio_nrfx_data *data = get_port_data(port);
 1016bfc:	68c3      	ldr	r3, [r0, #12]
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
 1016bfe:	6847      	ldr	r7, [r0, #4]
	u32_t out = data->int_en & data->pin_int_en;
 1016c00:	e9d3 1203 	ldrd	r1, r2, [r3, #12]
 1016c04:	400a      	ands	r2, r1
	out &= ~data->trig_edge & ~data->double_edge;
 1016c06:	e9d3 1006 	ldrd	r1, r0, [r3, #24]
 1016c0a:	4301      	orrs	r1, r0
 1016c0c:	ea22 0201 	bic.w	r2, r2, r1
	u32_t port_in = nrf_gpio_port_in_read(cfg->port);
 1016c10:	6879      	ldr	r1, [r7, #4]
	u32_t pin_states = ~(port_in ^ data->int_active_level);
 1016c12:	695b      	ldr	r3, [r3, #20]
    return p_reg->IN;
 1016c14:	690c      	ldr	r4, [r1, #16]
 1016c16:	405c      	eors	r4, r3
	u32_t out = pin_states & level_pins;
 1016c18:	ea22 0404 	bic.w	r4, r2, r4
	while (level_pins) {
 1016c1c:	b90a      	cbnz	r2, 1016c22 <check_level_trigger_pins+0x2c>
}
 1016c1e:	4620      	mov	r0, r4
 1016c20:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (level_pins & bit) {
 1016c22:	422a      	tst	r2, r5
 1016c24:	d009      	beq.n	1016c3a <check_level_trigger_pins+0x44>
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
 1016c26:	7a3b      	ldrb	r3, [r7, #8]
 1016c28:	f006 001f 	and.w	r0, r6, #31
			nrf_gpio_cfg_sense_set(abs_pin, NRF_GPIO_PIN_NOSENSE);
 1016c2c:	2100      	movs	r1, #0
 1016c2e:	ea40 1043 	orr.w	r0, r0, r3, lsl #5
 1016c32:	f7fb ff2b 	bl	1012a8c <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
 1016c36:	ea22 0205 	bic.w	r2, r2, r5
		++pin;
 1016c3a:	3601      	adds	r6, #1
		bit <<= 1;
 1016c3c:	006d      	lsls	r5, r5, #1
 1016c3e:	e7ed      	b.n	1016c1c <check_level_trigger_pins+0x26>

01016c40 <cfg_level_pins>:
{
 1016c40:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
	u32_t bit = 1U << pin;
 1016c42:	2601      	movs	r6, #1
	u32_t pin = 0U;
 1016c44:	2500      	movs	r5, #0
	const struct gpio_nrfx_data *data = get_port_data(port);
 1016c46:	68c4      	ldr	r4, [r0, #12]
	const struct gpio_nrfx_cfg *cfg = get_port_cfg(port);
 1016c48:	6847      	ldr	r7, [r0, #4]
	u32_t out = data->int_en & data->pin_int_en;
 1016c4a:	e9d4 3203 	ldrd	r3, r2, [r4, #12]
 1016c4e:	401a      	ands	r2, r3
	out &= ~data->trig_edge & ~data->double_edge;
 1016c50:	e9d4 3106 	ldrd	r3, r1, [r4, #24]
 1016c54:	430b      	orrs	r3, r1
 1016c56:	ea22 0203 	bic.w	r2, r2, r3
	while (level_pins) {
 1016c5a:	b902      	cbnz	r2, 1016c5e <cfg_level_pins+0x1e>
}
 1016c5c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		if (level_pins & bit) {
 1016c5e:	4216      	tst	r6, r2
 1016c60:	d00f      	beq.n	1016c82 <cfg_level_pins+0x42>
	if ((BIT(pin) & data->int_active_level) != 0U) {
 1016c62:	6961      	ldr	r1, [r4, #20]
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
 1016c64:	7a3b      	ldrb	r3, [r7, #8]
	if ((BIT(pin) & data->int_active_level) != 0U) {
 1016c66:	40e9      	lsrs	r1, r5
 1016c68:	f001 0101 	and.w	r1, r1, #1
 1016c6c:	f1c1 0103 	rsb	r1, r1, #3
			u32_t abs_pin = NRF_GPIO_PIN_MAP(cfg->port_num, pin);
 1016c70:	f005 001f 	and.w	r0, r5, #31
			nrf_gpio_cfg_sense_set(abs_pin, sense);
 1016c74:	b2c9      	uxtb	r1, r1
 1016c76:	ea40 1043 	orr.w	r0, r0, r3, lsl #5
 1016c7a:	f7fb ff07 	bl	1012a8c <nrf_gpio_cfg_sense_set>
			level_pins &= ~bit;
 1016c7e:	ea22 0206 	bic.w	r2, r2, r6
		++pin;
 1016c82:	3501      	adds	r5, #1
		bit <<= 1;
 1016c84:	0076      	lsls	r6, r6, #1
 1016c86:	e7e8      	b.n	1016c5a <cfg_level_pins+0x1a>

01016c88 <gpio_nrfx_pin_enable_callback>:
	WRITE_BIT(data->int_en, pin, enable);
 1016c88:	2301      	movs	r3, #1
{
 1016c8a:	b410      	push	{r4}
	struct gpio_nrfx_data *data = get_port_data(port);
 1016c8c:	68c4      	ldr	r4, [r0, #12]
	WRITE_BIT(data->int_en, pin, enable);
 1016c8e:	fa03 f201 	lsl.w	r2, r3, r1
 1016c92:	6923      	ldr	r3, [r4, #16]
 1016c94:	4313      	orrs	r3, r2
 1016c96:	6123      	str	r3, [r4, #16]
}
 1016c98:	bc10      	pop	{r4}
	return gpiote_pin_int_cfg(port, pin);
 1016c9a:	f7fb bf0d 	b.w	1012ab8 <gpiote_pin_int_cfg>

01016c9e <vipm_nrf_max_data_size_get>:
static inline int z_impl_ipm_max_data_size_get(struct device *ipmdev)
{
	const struct ipm_driver_api *api =
		(const struct ipm_driver_api *)ipmdev->driver_api;

	return api->max_data_size_get(ipmdev);
 1016c9e:	6883      	ldr	r3, [r0, #8]
 1016ca0:	689b      	ldr	r3, [r3, #8]
 1016ca2:	4718      	bx	r3

01016ca4 <vipm_nrf_max_id_val_get>:
}
 1016ca4:	2000      	movs	r0, #0
 1016ca6:	4770      	bx	lr

01016ca8 <vipm_nrf_0_set_enabled>:
UTIL_LISTIFY(NRFX_IPC_ID_MAX_VALUE, VIPM_DEVICE, _);
 1016ca8:	4608      	mov	r0, r1
 1016caa:	b508      	push	{r3, lr}
 1016cac:	b139      	cbz	r1, 1016cbe <vipm_nrf_0_set_enabled+0x16>
 1016cae:	2012      	movs	r0, #18
 1016cb0:	f7ee f830 	bl	1004d14 <arch_irq_enable>
 1016cb4:	2000      	movs	r0, #0
 1016cb6:	f7fc fbbf 	bl	1013438 <nrfx_ipc_receive_event_enable>
 1016cba:	2000      	movs	r0, #0
 1016cbc:	bd08      	pop	{r3, pc}
 1016cbe:	f7fc fbc3 	bl	1013448 <nrfx_ipc_receive_event_disable>
 1016cc2:	e7fa      	b.n	1016cba <vipm_nrf_0_set_enabled+0x12>

01016cc4 <uarte_nrfx_config_get>:
{
 1016cc4:	460b      	mov	r3, r1
	*cfg = get_dev_data(dev)->uart_config;
 1016cc6:	68c2      	ldr	r2, [r0, #12]
 1016cc8:	e892 0003 	ldmia.w	r2, {r0, r1}
 1016ccc:	e883 0003 	stmia.w	r3, {r0, r1}
}
 1016cd0:	2000      	movs	r0, #0
 1016cd2:	4770      	bx	lr

01016cd4 <uarte_nrfx_err_check>:
	return config->uarte_regs;
 1016cd4:	6843      	ldr	r3, [r0, #4]
 1016cd6:	681b      	ldr	r3, [r3, #0]
    uint32_t errsrc_mask = p_reg->ERRORSRC;
 1016cd8:	f8d3 0480 	ldr.w	r0, [r3, #1152]	; 0x480
    p_reg->ERRORSRC = errsrc_mask;
 1016cdc:	f8c3 0480 	str.w	r0, [r3, #1152]	; 0x480
}
 1016ce0:	4770      	bx	lr

01016ce2 <uarte_nrfx_poll_in>:
	return config->uarte_regs;
 1016ce2:	6843      	ldr	r3, [r0, #4]
	const struct uarte_nrfx_data *data = get_dev_data(dev);
 1016ce4:	68c2      	ldr	r2, [r0, #12]
	return config->uarte_regs;
 1016ce6:	681b      	ldr	r3, [r3, #0]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 1016ce8:	f8d3 0110 	ldr.w	r0, [r3, #272]	; 0x110
	if (!nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDRX)) {
 1016cec:	b138      	cbz	r0, 1016cfe <uarte_nrfx_poll_in+0x1c>
	*c = data->rx_data;
 1016cee:	7b12      	ldrb	r2, [r2, #12]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 1016cf0:	2000      	movs	r0, #0
 1016cf2:	700a      	strb	r2, [r1, #0]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1016cf4:	2201      	movs	r2, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 1016cf6:	f8c3 0110 	str.w	r0, [r3, #272]	; 0x110
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1016cfa:	601a      	str	r2, [r3, #0]
	return 0;
 1016cfc:	4770      	bx	lr
		return -1;
 1016cfe:	f04f 30ff 	mov.w	r0, #4294967295
}
 1016d02:	4770      	bx	lr

01016d04 <uarte_nrfx_poll_out>:
{
 1016d04:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
	return config->uarte_regs;
 1016d08:	6843      	ldr	r3, [r0, #4]
{
 1016d0a:	f88d 1007 	strb.w	r1, [sp, #7]
	return config->uarte_regs;
 1016d0e:	681c      	ldr	r4, [r3, #0]
	struct uarte_nrfx_data *data = get_dev_data(dev);
 1016d10:	68c6      	ldr	r6, [r0, #12]
	if (!k_is_in_isr()) {
 1016d12:	f000 fee9 	bl	1017ae8 <k_is_in_isr>
 1016d16:	b9c0      	cbnz	r0, 1016d4a <uarte_nrfx_poll_out+0x46>
		lock = &data->poll_out_lock;
 1016d18:	2564      	movs	r5, #100	; 0x64
	return __atomic_compare_exchange_n(target, &old_value, new_value,
 1016d1a:	f04f 0801 	mov.w	r8, #1
 1016d1e:	f106 0708 	add.w	r7, r6, #8
 1016d22:	e8d7 3fef 	ldaex	r3, [r7]
 1016d26:	2b00      	cmp	r3, #0
 1016d28:	d103      	bne.n	1016d32 <uarte_nrfx_poll_out+0x2e>
 1016d2a:	e8c7 8fe2 	stlex	r2, r8, [r7]
 1016d2e:	2a00      	cmp	r2, #0
 1016d30:	d1f7      	bne.n	1016d22 <uarte_nrfx_poll_out+0x1e>
		while (atomic_cas((atomic_t *) lock,
 1016d32:	d00c      	beq.n	1016d4e <uarte_nrfx_poll_out+0x4a>
	return z_impl_k_sleep(timeout);
 1016d34:	2021      	movs	r0, #33	; 0x21
 1016d36:	2100      	movs	r1, #0
 1016d38:	3d01      	subs	r5, #1
 1016d3a:	f7fd fc5f 	bl	10145fc <z_impl_k_sleep>
			if (--safety_cnt == 0) {
 1016d3e:	f015 05ff 	ands.w	r5, r5, #255	; 0xff
 1016d42:	d1ee      	bne.n	1016d22 <uarte_nrfx_poll_out+0x1e>
}
 1016d44:	b002      	add	sp, #8
 1016d46:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
		*lock = 1;
 1016d4a:	2301      	movs	r3, #1
 1016d4c:	60b3      	str	r3, [r6, #8]
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event)) = 0x0UL;
 1016d4e:	2300      	movs	r3, #0
 1016d50:	f8c4 3120 	str.w	r3, [r4, #288]	; 0x120
    p_reg->TXD.PTR    = (uint32_t)p_buffer;
 1016d54:	f10d 0307 	add.w	r3, sp, #7
 1016d58:	f8c4 3544 	str.w	r3, [r4, #1348]	; 0x544
    p_reg->TXD.MAXCNT = length;
 1016d5c:	2301      	movs	r3, #1
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1016d5e:	f44f 757a 	mov.w	r5, #1000	; 0x3e8
    p_reg->TXD.MAXCNT = length;
 1016d62:	f8c4 3548 	str.w	r3, [r4, #1352]	; 0x548
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1016d66:	60a3      	str	r3, [r4, #8]
    return (bool)*(volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)event);
 1016d68:	f8d4 3120 	ldr.w	r3, [r4, #288]	; 0x120
	NRFX_WAIT_FOR(nrf_uarte_event_check(uarte, NRF_UARTE_EVENT_ENDTX),
 1016d6c:	b923      	cbnz	r3, 1016d78 <uarte_nrfx_poll_out+0x74>
 1016d6e:	2001      	movs	r0, #1
 1016d70:	f000 f808 	bl	1016d84 <nrfx_busy_wait>
 1016d74:	3d01      	subs	r5, #1
 1016d76:	d1f7      	bne.n	1016d68 <uarte_nrfx_poll_out+0x64>
    *((volatile uint32_t *)((uint8_t *)p_reg + (uint32_t)task)) = 0x1UL;
 1016d78:	2301      	movs	r3, #1
 1016d7a:	60e3      	str	r3, [r4, #12]
	*lock = 0;
 1016d7c:	2300      	movs	r3, #0
 1016d7e:	60b3      	str	r3, [r6, #8]
 1016d80:	e7e0      	b.n	1016d44 <uarte_nrfx_poll_out+0x40>

01016d82 <nrfx_isr>:
#include <nrfx.h>
#include <kernel.h>

void nrfx_isr(void *irq_handler)
{
	((nrfx_irq_handler_t)irq_handler)();
 1016d82:	4700      	bx	r0

01016d84 <nrfx_busy_wait>:
	z_impl_k_busy_wait(usec_to_wait);
 1016d84:	f000 beb6 	b.w	1017af4 <z_impl_k_busy_wait>

01016d88 <metal_device_open>:
{
 1016d88:	b573      	push	{r0, r1, r4, r5, r6, lr}
 1016d8a:	460c      	mov	r4, r1
 1016d8c:	4615      	mov	r5, r2
	if (!bus_name || !strlen(bus_name) ||
 1016d8e:	4606      	mov	r6, r0
 1016d90:	b918      	cbnz	r0, 1016d9a <metal_device_open+0x12>
		return -EINVAL;
 1016d92:	f06f 0015 	mvn.w	r0, #21
}
 1016d96:	b002      	add	sp, #8
 1016d98:	bd70      	pop	{r4, r5, r6, pc}
	if (!bus_name || !strlen(bus_name) ||
 1016d9a:	f7ff fd5b 	bl	1016854 <strlen>
 1016d9e:	2800      	cmp	r0, #0
 1016da0:	d0f7      	beq.n	1016d92 <metal_device_open+0xa>
 1016da2:	2c00      	cmp	r4, #0
 1016da4:	d0f5      	beq.n	1016d92 <metal_device_open+0xa>
	    !dev_name || !strlen(dev_name) ||
 1016da6:	4620      	mov	r0, r4
 1016da8:	f7ff fd54 	bl	1016854 <strlen>
 1016dac:	2800      	cmp	r0, #0
 1016dae:	d0f0      	beq.n	1016d92 <metal_device_open+0xa>
 1016db0:	2d00      	cmp	r5, #0
 1016db2:	d0ee      	beq.n	1016d92 <metal_device_open+0xa>
	error = metal_bus_find(bus_name, &bus);
 1016db4:	4630      	mov	r0, r6
 1016db6:	a901      	add	r1, sp, #4
 1016db8:	f7fc fb8e 	bl	10134d8 <metal_bus_find>
	if (error)
 1016dbc:	2800      	cmp	r0, #0
 1016dbe:	d1ea      	bne.n	1016d96 <metal_device_open+0xe>
	if (!bus->ops.dev_open)
 1016dc0:	9801      	ldr	r0, [sp, #4]
 1016dc2:	6883      	ldr	r3, [r0, #8]
 1016dc4:	b11b      	cbz	r3, 1016dce <metal_device_open+0x46>
	error = (*bus->ops.dev_open)(bus, dev_name, device);
 1016dc6:	462a      	mov	r2, r5
 1016dc8:	4621      	mov	r1, r4
 1016dca:	4798      	blx	r3
	if (error)
 1016dcc:	e7e3      	b.n	1016d96 <metal_device_open+0xe>
		return -ENODEV;
 1016dce:	f06f 0012 	mvn.w	r0, #18
 1016dd2:	e7e0      	b.n	1016d96 <metal_device_open+0xe>

01016dd4 <metal_io_block_read>:
	metal_sys_io_mem_map(io);
}

int metal_io_block_read(struct metal_io_region *io, unsigned long offset,
	       void *restrict dst, int len)
{
 1016dd4:	b573      	push	{r0, r1, r4, r5, r6, lr}
	return (io->virt != METAL_BAD_VA && offset < io->size
 1016dd6:	6804      	ldr	r4, [r0, #0]
 1016dd8:	6885      	ldr	r5, [r0, #8]
		: NULL);
 1016dda:	1c66      	adds	r6, r4, #1
 1016ddc:	d00f      	beq.n	1016dfe <metal_io_block_read+0x2a>
	return (io->virt != METAL_BAD_VA && offset < io->size
 1016dde:	42a9      	cmp	r1, r5
 1016de0:	d232      	bcs.n	1016e48 <metal_io_block_read+0x74>
		: NULL);
 1016de2:	440c      	add	r4, r1
	unsigned char *dest = dst;
	int retlen;

	if (offset >= io->size)
		return -ERANGE;
	if ((offset + len) > io->size)
 1016de4:	185e      	adds	r6, r3, r1
 1016de6:	42ae      	cmp	r6, r5
		len = io->size - offset;
 1016de8:	bf88      	it	hi
 1016dea:	1a6b      	subhi	r3, r5, r1
	retlen = len;
	if (io->ops.block_read) {
 1016dec:	6a05      	ldr	r5, [r0, #32]
 1016dee:	b155      	cbz	r5, 1016e06 <metal_io_block_read+0x32>
		retlen = (*io->ops.block_read)(
 1016df0:	9300      	str	r3, [sp, #0]
 1016df2:	2305      	movs	r3, #5
 1016df4:	47a8      	blx	r5
 1016df6:	4603      	mov	r3, r0
		for (; len != 0; dest++, ptr++, len--)
			*(unsigned char *)dest =
				*(const unsigned char *)ptr;
	}
	return retlen;
}
 1016df8:	4618      	mov	r0, r3
 1016dfa:	b002      	add	sp, #8
 1016dfc:	bd70      	pop	{r4, r5, r6, pc}
	if (offset >= io->size)
 1016dfe:	42a9      	cmp	r1, r5
 1016e00:	d222      	bcs.n	1016e48 <metal_io_block_read+0x74>
 1016e02:	2400      	movs	r4, #0
 1016e04:	e7ee      	b.n	1016de4 <metal_io_block_read+0x10>
		atomic_thread_fence(memory_order_seq_cst);
 1016e06:	f3bf 8f5b 	dmb	ish
		while ( len && (
 1016e0a:	4621      	mov	r1, r4
 1016e0c:	4618      	mov	r0, r3
 1016e0e:	2800      	cmp	r0, #0
 1016e10:	d0f2      	beq.n	1016df8 <metal_io_block_read+0x24>
			((uintptr_t)dest % sizeof(int)) ||
 1016e12:	ea42 0401 	orr.w	r4, r2, r1
 1016e16:	07a4      	lsls	r4, r4, #30
 1016e18:	d10a      	bne.n	1016e30 <metal_io_block_read+0x5c>
		for (; len >= (int)sizeof(int); dest += sizeof(int),
 1016e1a:	2803      	cmp	r0, #3
 1016e1c:	dc0e      	bgt.n	1016e3c <metal_io_block_read+0x68>
 1016e1e:	3901      	subs	r1, #1
 1016e20:	4410      	add	r0, r2
		for (; len != 0; dest++, ptr++, len--)
 1016e22:	4282      	cmp	r2, r0
 1016e24:	d0e8      	beq.n	1016df8 <metal_io_block_read+0x24>
				*(const unsigned char *)ptr;
 1016e26:	f811 4f01 	ldrb.w	r4, [r1, #1]!
			*(unsigned char *)dest =
 1016e2a:	f802 4b01 	strb.w	r4, [r2], #1
		for (; len != 0; dest++, ptr++, len--)
 1016e2e:	e7f8      	b.n	1016e22 <metal_io_block_read+0x4e>
				*(const unsigned char *)ptr;
 1016e30:	f811 4b01 	ldrb.w	r4, [r1], #1
			len--;
 1016e34:	3801      	subs	r0, #1
			*(unsigned char *)dest =
 1016e36:	f802 4b01 	strb.w	r4, [r2], #1
			len--;
 1016e3a:	e7e8      	b.n	1016e0e <metal_io_block_read+0x3a>
			*(unsigned int *)dest = *(const unsigned int *)ptr;
 1016e3c:	f851 4b04 	ldr.w	r4, [r1], #4
 1016e40:	3804      	subs	r0, #4
 1016e42:	f842 4b04 	str.w	r4, [r2], #4
		for (; len >= (int)sizeof(int); dest += sizeof(int),
 1016e46:	e7e8      	b.n	1016e1a <metal_io_block_read+0x46>
		return -ERANGE;
 1016e48:	f06f 0325 	mvn.w	r3, #37	; 0x25
 1016e4c:	e7d4      	b.n	1016df8 <metal_io_block_read+0x24>

01016e4e <metal_io_block_write>:

int metal_io_block_write(struct metal_io_region *io, unsigned long offset,
	       const void *restrict src, int len)
{
 1016e4e:	b573      	push	{r0, r1, r4, r5, r6, lr}
	return (io->virt != METAL_BAD_VA && offset < io->size
 1016e50:	6804      	ldr	r4, [r0, #0]
 1016e52:	6885      	ldr	r5, [r0, #8]
		: NULL);
 1016e54:	1c66      	adds	r6, r4, #1
 1016e56:	d00e      	beq.n	1016e76 <metal_io_block_write+0x28>
	return (io->virt != METAL_BAD_VA && offset < io->size
 1016e58:	42a9      	cmp	r1, r5
 1016e5a:	d230      	bcs.n	1016ebe <metal_io_block_write+0x70>
		: NULL);
 1016e5c:	440c      	add	r4, r1
	const unsigned char *source = src;
	int retlen;

	if (offset >= io->size)
		return -ERANGE;
	if ((offset + len) > io->size)
 1016e5e:	185e      	adds	r6, r3, r1
 1016e60:	42ae      	cmp	r6, r5
		len = io->size - offset;
 1016e62:	bf88      	it	hi
 1016e64:	1a6b      	subhi	r3, r5, r1
	retlen = len;
	if (io->ops.block_write) {
 1016e66:	6a45      	ldr	r5, [r0, #36]	; 0x24
 1016e68:	b94d      	cbnz	r5, 1016e7e <metal_io_block_write+0x30>
 1016e6a:	4619      	mov	r1, r3
		retlen = (*io->ops.block_write)(
			io, offset, src, memory_order_seq_cst, len);
	} else {
		while ( len && (
 1016e6c:	b991      	cbnz	r1, 1016e94 <metal_io_block_write+0x46>
					len -= sizeof(int))
			*(unsigned int *)ptr = *(const unsigned int *)source;
		for (; len != 0; ptr++, source++, len--)
			*(unsigned char *)ptr =
				*(const unsigned char *)source;
		atomic_thread_fence(memory_order_seq_cst);
 1016e6e:	f3bf 8f5b 	dmb	ish
	retlen = len;
 1016e72:	4618      	mov	r0, r3
 1016e74:	e006      	b.n	1016e84 <metal_io_block_write+0x36>
	if (offset >= io->size)
 1016e76:	42a9      	cmp	r1, r5
 1016e78:	d221      	bcs.n	1016ebe <metal_io_block_write+0x70>
 1016e7a:	2400      	movs	r4, #0
 1016e7c:	e7ef      	b.n	1016e5e <metal_io_block_write+0x10>
		retlen = (*io->ops.block_write)(
 1016e7e:	9300      	str	r3, [sp, #0]
 1016e80:	2305      	movs	r3, #5
 1016e82:	47a8      	blx	r5
	}
	return retlen;
}
 1016e84:	b002      	add	sp, #8
 1016e86:	bd70      	pop	{r4, r5, r6, pc}
				*(const unsigned char *)source;
 1016e88:	f812 0b01 	ldrb.w	r0, [r2], #1
			len--;
 1016e8c:	3901      	subs	r1, #1
			*(unsigned char *)ptr =
 1016e8e:	f804 0b01 	strb.w	r0, [r4], #1
			len--;
 1016e92:	e7eb      	b.n	1016e6c <metal_io_block_write+0x1e>
			((uintptr_t)ptr % sizeof(int)) ||
 1016e94:	ea44 0002 	orr.w	r0, r4, r2
 1016e98:	0780      	lsls	r0, r0, #30
 1016e9a:	d1f5      	bne.n	1016e88 <metal_io_block_write+0x3a>
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
 1016e9c:	2903      	cmp	r1, #3
 1016e9e:	dc08      	bgt.n	1016eb2 <metal_io_block_write+0x64>
 1016ea0:	3a01      	subs	r2, #1
 1016ea2:	4421      	add	r1, r4
		for (; len != 0; ptr++, source++, len--)
 1016ea4:	428c      	cmp	r4, r1
 1016ea6:	d0e2      	beq.n	1016e6e <metal_io_block_write+0x20>
				*(const unsigned char *)source;
 1016ea8:	f812 0f01 	ldrb.w	r0, [r2, #1]!
			*(unsigned char *)ptr =
 1016eac:	f804 0b01 	strb.w	r0, [r4], #1
		for (; len != 0; ptr++, source++, len--)
 1016eb0:	e7f8      	b.n	1016ea4 <metal_io_block_write+0x56>
			*(unsigned int *)ptr = *(const unsigned int *)source;
 1016eb2:	f852 0b04 	ldr.w	r0, [r2], #4
 1016eb6:	3904      	subs	r1, #4
 1016eb8:	f844 0b04 	str.w	r0, [r4], #4
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
 1016ebc:	e7ee      	b.n	1016e9c <metal_io_block_write+0x4e>
		return -ERANGE;
 1016ebe:	f06f 0025 	mvn.w	r0, #37	; 0x25
 1016ec2:	e7df      	b.n	1016e84 <metal_io_block_write+0x36>

01016ec4 <metal_io_block_set>:

int metal_io_block_set(struct metal_io_region *io, unsigned long offset,
	       unsigned char value, int len)
{
 1016ec4:	b573      	push	{r0, r1, r4, r5, r6, lr}
	return (io->virt != METAL_BAD_VA && offset < io->size
 1016ec6:	6804      	ldr	r4, [r0, #0]
 1016ec8:	461d      	mov	r5, r3
		: NULL);
 1016eca:	1c66      	adds	r6, r4, #1
 1016ecc:	6883      	ldr	r3, [r0, #8]
 1016ece:	d00e      	beq.n	1016eee <metal_io_block_set+0x2a>
	return (io->virt != METAL_BAD_VA && offset < io->size
 1016ed0:	4299      	cmp	r1, r3
 1016ed2:	d22d      	bcs.n	1016f30 <metal_io_block_set+0x6c>
		: NULL);
 1016ed4:	440c      	add	r4, r1
	unsigned char *ptr = metal_io_virt(io, offset);
	int retlen = len;

	if (offset >= io->size)
		return -ERANGE;
	if ((offset + len) > io->size)
 1016ed6:	186e      	adds	r6, r5, r1
 1016ed8:	429e      	cmp	r6, r3
		len = io->size - offset;
	retlen = len;
	if (io->ops.block_set) {
 1016eda:	6a86      	ldr	r6, [r0, #40]	; 0x28
		len = io->size - offset;
 1016edc:	bf88      	it	hi
 1016ede:	1a5d      	subhi	r5, r3, r1
	if (io->ops.block_set) {
 1016ee0:	b186      	cbz	r6, 1016f04 <metal_io_block_set+0x40>
		(*io->ops.block_set)(
 1016ee2:	2305      	movs	r3, #5
 1016ee4:	9500      	str	r5, [sp, #0]
 1016ee6:	47b0      	blx	r6
		for (; len != 0; ptr++, len--)
			*(unsigned char *)ptr = (unsigned char) value;
		atomic_thread_fence(memory_order_seq_cst);
	}
	return retlen;
}
 1016ee8:	4628      	mov	r0, r5
 1016eea:	b002      	add	sp, #8
 1016eec:	bd70      	pop	{r4, r5, r6, pc}
	if (offset >= io->size)
 1016eee:	4299      	cmp	r1, r3
 1016ef0:	d21e      	bcs.n	1016f30 <metal_io_block_set+0x6c>
 1016ef2:	2400      	movs	r4, #0
 1016ef4:	e7ef      	b.n	1016ed6 <metal_io_block_set+0x12>
			*(unsigned char *)ptr = (unsigned char) value;
 1016ef6:	f804 2b01 	strb.w	r2, [r4], #1
		for (; len && ((uintptr_t)ptr % sizeof(int)); ptr++, len--)
 1016efa:	3b01      	subs	r3, #1
 1016efc:	b923      	cbnz	r3, 1016f08 <metal_io_block_set+0x44>
		atomic_thread_fence(memory_order_seq_cst);
 1016efe:	f3bf 8f5b 	dmb	ish
 1016f02:	e7f1      	b.n	1016ee8 <metal_io_block_set+0x24>
 1016f04:	462b      	mov	r3, r5
 1016f06:	e7f9      	b.n	1016efc <metal_io_block_set+0x38>
		for (; len && ((uintptr_t)ptr % sizeof(int)); ptr++, len--)
 1016f08:	07a1      	lsls	r1, r4, #30
 1016f0a:	d1f4      	bne.n	1016ef6 <metal_io_block_set+0x32>
			cint |= ((unsigned int)value << (CHAR_BIT * i));
 1016f0c:	0611      	lsls	r1, r2, #24
 1016f0e:	ea41 4102 	orr.w	r1, r1, r2, lsl #16
 1016f12:	4311      	orrs	r1, r2
 1016f14:	ea41 2102 	orr.w	r1, r1, r2, lsl #8
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
 1016f18:	2b03      	cmp	r3, #3
 1016f1a:	dc05      	bgt.n	1016f28 <metal_io_block_set+0x64>
 1016f1c:	4423      	add	r3, r4
		for (; len != 0; ptr++, len--)
 1016f1e:	429c      	cmp	r4, r3
 1016f20:	d0ed      	beq.n	1016efe <metal_io_block_set+0x3a>
			*(unsigned char *)ptr = (unsigned char) value;
 1016f22:	f804 2b01 	strb.w	r2, [r4], #1
		for (; len != 0; ptr++, len--)
 1016f26:	e7fa      	b.n	1016f1e <metal_io_block_set+0x5a>
			*(unsigned int *)ptr = cint;
 1016f28:	f844 1b04 	str.w	r1, [r4], #4
		for (; len >= (int)sizeof(int); ptr += sizeof(int),
 1016f2c:	3b04      	subs	r3, #4
 1016f2e:	e7f3      	b.n	1016f18 <metal_io_block_set+0x54>
		return -ERANGE;
 1016f30:	f06f 0525 	mvn.w	r5, #37	; 0x25
 1016f34:	e7d8      	b.n	1016ee8 <metal_io_block_set+0x24>

01016f36 <metal_generic_dev_sys_open>:

	/* Since Zephyr runs bare-metal there is no mapping that needs to be
	 * done of IO regions
	 */
	return 0;
}
 1016f36:	2000      	movs	r0, #0
 1016f38:	4770      	bx	lr

01016f3a <metal_io_phys>:
 * @return	METAL_BAD_PHYS if offset is out of range, or physical address
 *		of offset.
 */
static inline metal_phys_addr_t
metal_io_phys(struct metal_io_region *io, unsigned long offset)
{
 1016f3a:	b430      	push	{r4, r5}
	if (!io->ops.offset_to_phys) {
 1016f3c:	6b04      	ldr	r4, [r0, #48]	; 0x30
{
 1016f3e:	460b      	mov	r3, r1
	if (!io->ops.offset_to_phys) {
 1016f40:	b984      	cbnz	r4, 1016f64 <metal_io_phys+0x2a>
		unsigned long page = (io->page_shift >=
 1016f42:	68c1      	ldr	r1, [r0, #12]
				     sizeof(offset) * CHAR_BIT ?
				     0 : offset >> io->page_shift);
		return (io->physmap && offset < io->size
 1016f44:	6845      	ldr	r5, [r0, #4]
				     0 : offset >> io->page_shift);
 1016f46:	291f      	cmp	r1, #31
 1016f48:	bf98      	it	ls
 1016f4a:	fa23 f401 	lsrls.w	r4, r3, r1
			? io->physmap[page] + (offset & io->page_mask)
			: METAL_BAD_PHYS);
 1016f4e:	b165      	cbz	r5, 1016f6a <metal_io_phys+0x30>
		return (io->physmap && offset < io->size
 1016f50:	6881      	ldr	r1, [r0, #8]
 1016f52:	428b      	cmp	r3, r1
 1016f54:	d209      	bcs.n	1016f6a <metal_io_phys+0x30>
			? io->physmap[page] + (offset & io->page_mask)
 1016f56:	6900      	ldr	r0, [r0, #16]
 1016f58:	4003      	ands	r3, r0
			: METAL_BAD_PHYS);
 1016f5a:	f855 0024 	ldr.w	r0, [r5, r4, lsl #2]
 1016f5e:	4418      	add	r0, r3
	}

	return io->ops.offset_to_phys(io, offset);
}
 1016f60:	bc30      	pop	{r4, r5}
 1016f62:	4770      	bx	lr
	return io->ops.offset_to_phys(io, offset);
 1016f64:	4623      	mov	r3, r4
}
 1016f66:	bc30      	pop	{r4, r5}
	return io->ops.offset_to_phys(io, offset);
 1016f68:	4718      	bx	r3
			: METAL_BAD_PHYS);
 1016f6a:	f04f 30ff 	mov.w	r0, #4294967295
 1016f6e:	e7f7      	b.n	1016f60 <metal_io_phys+0x26>

01016f70 <virtqueue_create>:
{
 1016f70:	b570      	push	{r4, r5, r6, lr}
 1016f72:	9c06      	ldr	r4, [sp, #24]
		vq->vq_queue_index = id;
 1016f74:	8121      	strh	r1, [r4, #8]
		vq->callback = callback;
 1016f76:	9904      	ldr	r1, [sp, #16]
		vq->vq_name = name;
 1016f78:	e9c4 0200 	strd	r0, r2, [r4]
		vq->vq_nentries = ring->num_descs;
 1016f7c:	891a      	ldrh	r2, [r3, #8]
		vq->callback = callback;
 1016f7e:	60e1      	str	r1, [r4, #12]
		vq->notify = notify;
 1016f80:	9905      	ldr	r1, [sp, #20]
{
	vr->num = num;
	vr->desc = (struct vring_desc *)p;
	vr->avail = (struct vring_avail *)(p + num * sizeof(struct vring_desc));
	vr->used = (struct vring_used *)
	    (((unsigned long)&vr->avail->ring[num] + sizeof(uint16_t) +
 1016f82:	1c96      	adds	r6, r2, #2
 1016f84:	6121      	str	r1, [r4, #16]
		vq_ring_init(vq, ring->vaddr, ring->align);
 1016f86:	e9d3 1500 	ldrd	r1, r5, [r3]
	vr->avail = (struct vring_avail *)(p + num * sizeof(struct vring_desc));
 1016f8a:	eb01 1302 	add.w	r3, r1, r2, lsl #4
 1016f8e:	61e3      	str	r3, [r4, #28]
	    (((unsigned long)&vr->avail->ring[num] + sizeof(uint16_t) +
 1016f90:	eb03 0346 	add.w	r3, r3, r6, lsl #1
	      align - 1) & ~(align - 1));
 1016f94:	1c6e      	adds	r6, r5, #1
 1016f96:	4433      	add	r3, r6
 1016f98:	426d      	negs	r5, r5
 1016f9a:	402b      	ands	r3, r5
	vr->used = (struct vring_used *)
 1016f9c:	6223      	str	r3, [r4, #32]
	vr = &vq->vq_ring;

	vring_init(vr, size, ring_mem, alignment);

#ifndef VIRTIO_SLAVE_ONLY
	if (vq->vq_dev->role == VIRTIO_DEV_MASTER) {
 1016f9e:	6983      	ldr	r3, [r0, #24]
	vr->desc = (struct vring_desc *)p;
 1016fa0:	e9c4 2105 	strd	r2, r1, [r4, #20]
		vq->vq_nentries = ring->num_descs;
 1016fa4:	8162      	strh	r2, [r4, #10]
		vq->vq_free_cnt = vq->vq_nentries;
 1016fa6:	84a2      	strh	r2, [r4, #36]	; 0x24
	if (vq->vq_dev->role == VIRTIO_DEV_MASTER) {
 1016fa8:	b96b      	cbnz	r3, 1016fc6 <virtqueue_create+0x56>
		int i;

		for (i = 0; i < size - 1; i++)
 1016faa:	3a01      	subs	r2, #1
 1016fac:	4293      	cmp	r3, r2
 1016fae:	eb01 1003 	add.w	r0, r1, r3, lsl #4
 1016fb2:	db0a      	blt.n	1016fca <virtqueue_create+0x5a>
			vr->desc[i].next = i + 1;
		vr->desc[i].next = VQ_RING_DESC_CHAIN_END;
 1016fb4:	2300      	movs	r3, #0
 1016fb6:	ea22 72e2 	bic.w	r2, r2, r2, asr #31
 1016fba:	eb01 1202 	add.w	r2, r1, r2, lsl #4
 1016fbe:	7393      	strb	r3, [r2, #14]
 1016fc0:	f06f 037f 	mvn.w	r3, #127	; 0x7f
 1016fc4:	73d3      	strb	r3, [r2, #15]
}
 1016fc6:	2000      	movs	r0, #0
 1016fc8:	bd70      	pop	{r4, r5, r6, pc}
			vr->desc[i].next = i + 1;
 1016fca:	3301      	adds	r3, #1
 1016fcc:	81c3      	strh	r3, [r0, #14]
		for (i = 0; i < size - 1; i++)
 1016fce:	e7ed      	b.n	1016fac <virtqueue_create+0x3c>

01016fd0 <virtqueue_add_buffer>:
{
 1016fd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
 1016fd4:	2700      	movs	r7, #0
		head_idx = vq->vq_desc_head_idx;
 1016fd6:	f8b0 b02c 	ldrh.w	fp, [r0, #44]	; 0x2c
{
 1016fda:	4604      	mov	r4, r0
	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
 1016fdc:	465d      	mov	r5, fp
		dp->addr = virtqueue_virt_to_phys(vq, buf_list[i].buf);
 1016fde:	46ba      	mov	sl, r7
{
 1016fe0:	b085      	sub	sp, #20
	needed = readable + writable;
 1016fe2:	18d6      	adds	r6, r2, r3
{
 1016fe4:	4691      	mov	r9, r2
		dxp->cookie = cookie;
 1016fe6:	9a0e      	ldr	r2, [sp, #56]	; 0x38
 1016fe8:	eb00 03cb 	add.w	r3, r0, fp, lsl #3
 1016fec:	635a      	str	r2, [r3, #52]	; 0x34
		dxp->ndescs = needed;
 1016fee:	871e      	strh	r6, [r3, #56]	; 0x38
		if (i < needed - 1)
 1016ff0:	1e72      	subs	r2, r6, #1
		idx = vq_ring_add_buffer(vq, vq->vq_ring.desc, head_idx,
 1016ff2:	6983      	ldr	r3, [r0, #24]
	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
 1016ff4:	f101 0804 	add.w	r8, r1, #4
		if (i < needed - 1)
 1016ff8:	9201      	str	r2, [sp, #4]
	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
 1016ffa:	42be      	cmp	r6, r7
 1016ffc:	dc19      	bgt.n	1017032 <virtqueue_add_buffer+0x62>
		vq->vq_free_cnt -= needed;
 1016ffe:	8ca3      	ldrh	r3, [r4, #36]	; 0x24
	 * it usable to the host. The chain is made available now rather than
	 * deferring to virtqueue_notify() in the hopes that if the host is
	 * currently running on another CPU, we can keep it processing the new
	 * descriptor.
	 */
	avail_idx = vq->vq_ring.avail->idx & (vq->vq_nentries - 1);
 1017000:	8962      	ldrh	r2, [r4, #10]
		vq->vq_free_cnt -= needed;
 1017002:	1b9e      	subs	r6, r3, r6
	avail_idx = vq->vq_ring.avail->idx & (vq->vq_nentries - 1);
 1017004:	69e3      	ldr	r3, [r4, #28]
		vq->vq_desc_head_idx = idx;
 1017006:	85a5      	strh	r5, [r4, #44]	; 0x2c
		vq->vq_free_cnt -= needed;
 1017008:	84a6      	strh	r6, [r4, #36]	; 0x24
	avail_idx = vq->vq_ring.avail->idx & (vq->vq_nentries - 1);
 101700a:	1e51      	subs	r1, r2, #1
 101700c:	885a      	ldrh	r2, [r3, #2]
}
 101700e:	2000      	movs	r0, #0
	vq->vq_ring.avail->ring[avail_idx] = desc_idx;
 1017010:	400a      	ands	r2, r1
 1017012:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 1017016:	f8a3 b004 	strh.w	fp, [r3, #4]

	atomic_thread_fence(memory_order_seq_cst);
 101701a:	f3bf 8f5b 	dmb	ish

	vq->vq_ring.avail->idx++;
 101701e:	69e2      	ldr	r2, [r4, #28]
 1017020:	8853      	ldrh	r3, [r2, #2]
 1017022:	3301      	adds	r3, #1
 1017024:	8053      	strh	r3, [r2, #2]

	/* Keep pending count until virtqueue_notify(). */
	vq->vq_queued_cnt++;
 1017026:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 1017028:	3301      	adds	r3, #1
 101702a:	84e3      	strh	r3, [r4, #38]	; 0x26
}
 101702c:	b005      	add	sp, #20
 101702e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		dp->addr = virtqueue_virt_to_phys(vq, buf_list[i].buf);
 1017032:	6aa0      	ldr	r0, [r4, #40]	; 0x28
		dp = &desc[idx];
 1017034:	012a      	lsls	r2, r5, #4
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
 1017036:	f858 1c04 	ldr.w	r1, [r8, #-4]
 101703a:	eb03 1505 	add.w	r5, r3, r5, lsl #4
 101703e:	9302      	str	r3, [sp, #8]
 1017040:	6803      	ldr	r3, [r0, #0]
 1017042:	9203      	str	r2, [sp, #12]
 1017044:	1ac9      	subs	r1, r1, r3
 *		physical address.
 */
static inline metal_phys_addr_t
metal_io_virt_to_phys(struct metal_io_region *io, void *virt)
{
	return metal_io_phys(io, metal_io_virt_to_offset(io, virt));
 1017046:	6883      	ldr	r3, [r0, #8]
 1017048:	f108 0808 	add.w	r8, r8, #8
 101704c:	4299      	cmp	r1, r3
 101704e:	bf28      	it	cs
 1017050:	f04f 31ff 	movcs.w	r1, #4294967295
 1017054:	f7ff ff71 	bl	1016f3a <metal_io_phys>
		dp->addr = virtqueue_virt_to_phys(vq, buf_list[i].buf);
 1017058:	e9dd 3202 	ldrd	r3, r2, [sp, #8]
 101705c:	5098      	str	r0, [r3, r2]
		dp->len = buf_list[i].len;
 101705e:	f858 2c08 	ldr.w	r2, [r8, #-8]
			dp->flags |= VRING_DESC_F_NEXT;
 1017062:	f885 a00d 	strb.w	sl, [r5, #13]
		dp->len = buf_list[i].len;
 1017066:	60aa      	str	r2, [r5, #8]
		if (i < needed - 1)
 1017068:	9a01      	ldr	r2, [sp, #4]
		dp->addr = virtqueue_virt_to_phys(vq, buf_list[i].buf);
 101706a:	f8c5 a004 	str.w	sl, [r5, #4]
		if (i < needed - 1)
 101706e:	4297      	cmp	r7, r2
			dp->flags |= VRING_DESC_F_NEXT;
 1017070:	bfb6      	itet	lt
 1017072:	2201      	movlt	r2, #1
		dp->flags = 0;
 1017074:	f885 a00c 	strbge.w	sl, [r5, #12]
			dp->flags |= VRING_DESC_F_NEXT;
 1017078:	732a      	strblt	r2, [r5, #12]
		if (i >= readable)
 101707a:	45b9      	cmp	r9, r7
			dp->flags |= VRING_DESC_F_WRITE;
 101707c:	bfd8      	it	le
 101707e:	89aa      	ldrhle	r2, [r5, #12]
	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
 1017080:	f107 0701 	add.w	r7, r7, #1
			dp->flags |= VRING_DESC_F_WRITE;
 1017084:	bfdc      	itt	le
 1017086:	f042 0202 	orrle.w	r2, r2, #2
 101708a:	81aa      	strhle	r2, [r5, #12]
	for (i = 0, idx = head_idx; i < needed; i++, idx = dp->next) {
 101708c:	89ed      	ldrh	r5, [r5, #14]
 101708e:	e7b4      	b.n	1016ffa <virtqueue_add_buffer+0x2a>

01017090 <virtqueue_get_buffer>:
{
 1017090:	b5f0      	push	{r4, r5, r6, r7, lr}
	if (!vq || vq->vq_used_cons_idx == vq->vq_ring.used->idx)
 1017092:	b350      	cbz	r0, 10170ea <virtqueue_get_buffer+0x5a>
 1017094:	6a05      	ldr	r5, [r0, #32]
 1017096:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
 1017098:	886c      	ldrh	r4, [r5, #2]
 101709a:	429c      	cmp	r4, r3
 101709c:	d030      	beq.n	1017100 <virtqueue_get_buffer+0x70>
	used_idx = vq->vq_used_cons_idx++ & (vq->vq_nentries - 1);
 101709e:	1c5c      	adds	r4, r3, #1
 10170a0:	85c4      	strh	r4, [r0, #46]	; 0x2e
 10170a2:	8944      	ldrh	r4, [r0, #10]
	atomic_thread_fence(memory_order_seq_cst);
 10170a4:	f3bf 8f5b 	dmb	ish
	used_idx = vq->vq_used_cons_idx++ & (vq->vq_nentries - 1);
 10170a8:	3c01      	subs	r4, #1
 10170aa:	401c      	ands	r4, r3
	desc_idx = (uint16_t)uep->id;
 10170ac:	eb05 05c4 	add.w	r5, r5, r4, lsl #3
 10170b0:	686b      	ldr	r3, [r5, #4]
 10170b2:	b29e      	uxth	r6, r3
	if (len)
 10170b4:	b109      	cbz	r1, 10170ba <virtqueue_get_buffer+0x2a>
		*len = uep->len;
 10170b6:	68ad      	ldr	r5, [r5, #8]
 10170b8:	600d      	str	r5, [r1, #0]
	dp = &vq->vq_ring.desc[desc_idx];
 10170ba:	f8d0 c018 	ldr.w	ip, [r0, #24]
 10170be:	b29b      	uxth	r3, r3
 10170c0:	eb0c 1103 	add.w	r1, ip, r3, lsl #4
	vq->vq_free_cnt += dxp->ndescs;
 10170c4:	eb00 03c3 	add.w	r3, r0, r3, lsl #3
 10170c8:	8f1d      	ldrh	r5, [r3, #56]	; 0x38
 10170ca:	8c87      	ldrh	r7, [r0, #36]	; 0x24
 10170cc:	442f      	add	r7, r5
	dxp->ndescs--;
 10170ce:	3d01      	subs	r5, #1
	vq->vq_free_cnt += dxp->ndescs;
 10170d0:	8487      	strh	r7, [r0, #36]	; 0x24
	dxp->ndescs--;
 10170d2:	871d      	strh	r5, [r3, #56]	; 0x38
	if ((dp->flags & VRING_DESC_F_INDIRECT) == 0) {
 10170d4:	898d      	ldrh	r5, [r1, #12]
 10170d6:	076f      	lsls	r7, r5, #29
 10170d8:	d50e      	bpl.n	10170f8 <virtqueue_get_buffer+0x68>
	dp->next = vq->vq_desc_head_idx;
 10170da:	8d85      	ldrh	r5, [r0, #44]	; 0x2c
 10170dc:	81cd      	strh	r5, [r1, #14]
	vq->vq_descx[desc_idx].cookie = NULL;
 10170de:	2100      	movs	r1, #0
	vq->vq_desc_head_idx = desc_idx;
 10170e0:	8586      	strh	r6, [r0, #44]	; 0x2c
	cookie = vq->vq_descx[desc_idx].cookie;
 10170e2:	6b58      	ldr	r0, [r3, #52]	; 0x34
	vq->vq_descx[desc_idx].cookie = NULL;
 10170e4:	6359      	str	r1, [r3, #52]	; 0x34
	if (idx)
 10170e6:	b102      	cbz	r2, 10170ea <virtqueue_get_buffer+0x5a>
		*idx = used_idx;
 10170e8:	8014      	strh	r4, [r2, #0]
}
 10170ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
			dxp->ndescs--;
 10170ec:	8f1d      	ldrh	r5, [r3, #56]	; 0x38
			dp = &vq->vq_ring.desc[dp->next];
 10170ee:	89c9      	ldrh	r1, [r1, #14]
			dxp->ndescs--;
 10170f0:	3d01      	subs	r5, #1
			dp = &vq->vq_ring.desc[dp->next];
 10170f2:	eb0c 1101 	add.w	r1, ip, r1, lsl #4
			dxp->ndescs--;
 10170f6:	871d      	strh	r5, [r3, #56]	; 0x38
		while (dp->flags & VRING_DESC_F_NEXT) {
 10170f8:	898d      	ldrh	r5, [r1, #12]
 10170fa:	07ed      	lsls	r5, r5, #31
 10170fc:	d4f6      	bmi.n	10170ec <virtqueue_get_buffer+0x5c>
 10170fe:	e7ec      	b.n	10170da <virtqueue_get_buffer+0x4a>
		return NULL;
 1017100:	2000      	movs	r0, #0
 1017102:	e7f2      	b.n	10170ea <virtqueue_get_buffer+0x5a>

01017104 <virtqueue_get_available_buffer>:
{
 1017104:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
	atomic_thread_fence(memory_order_seq_cst);
 1017108:	f3bf 8f5b 	dmb	ish
{
 101710c:	4617      	mov	r7, r2
	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
 101710e:	69c2      	ldr	r2, [r0, #28]
{
 1017110:	460e      	mov	r6, r1
	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
 1017112:	8853      	ldrh	r3, [r2, #2]
 1017114:	8e01      	ldrh	r1, [r0, #48]	; 0x30
{
 1017116:	4605      	mov	r5, r0
	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
 1017118:	428b      	cmp	r3, r1
 101711a:	d046      	beq.n	10171aa <virtqueue_get_available_buffer+0xa6>
	head_idx = vq->vq_available_idx++ & (vq->vq_nentries - 1);
 101711c:	1c4b      	adds	r3, r1, #1
 101711e:	8603      	strh	r3, [r0, #48]	; 0x30
 1017120:	8943      	ldrh	r3, [r0, #10]
	buffer = virtqueue_phys_to_virt(vq, vq->vq_ring.desc[*avail_idx].addr);
 1017122:	f8d0 8028 	ldr.w	r8, [r0, #40]	; 0x28
	head_idx = vq->vq_available_idx++ & (vq->vq_nentries - 1);
 1017126:	3b01      	subs	r3, #1
	*avail_idx = vq->vq_ring.avail->ring[head_idx];
 1017128:	400b      	ands	r3, r1
 101712a:	eb02 0343 	add.w	r3, r2, r3, lsl #1
 101712e:	889a      	ldrh	r2, [r3, #4]
	buffer = virtqueue_phys_to_virt(vq, vq->vq_ring.desc[*avail_idx].addr);
 1017130:	6983      	ldr	r3, [r0, #24]
	*avail_idx = vq->vq_ring.avail->ring[head_idx];
 1017132:	b291      	uxth	r1, r2
	buffer = virtqueue_phys_to_virt(vq, vq->vq_ring.desc[*avail_idx].addr);
 1017134:	eb03 1301 	add.w	r3, r3, r1, lsl #4
	*avail_idx = vq->vq_ring.avail->ring[head_idx];
 1017138:	8032      	strh	r2, [r6, #0]
	buffer = virtqueue_phys_to_virt(vq, vq->vq_ring.desc[*avail_idx].addr);
 101713a:	f8d3 9000 	ldr.w	r9, [r3]
	if (!io->ops.phys_to_offset) {
 101713e:	f8d8 3034 	ldr.w	r3, [r8, #52]	; 0x34
 1017142:	bb5b      	cbnz	r3, 101719c <virtqueue_get_available_buffer+0x98>
			(io->page_mask == (metal_phys_addr_t)(-1) ?
 1017144:	f8d8 4010 	ldr.w	r4, [r8, #16]
			phys - io->physmap[0] :  phys & io->page_mask);
 1017148:	1c62      	adds	r2, r4, #1
 101714a:	bf09      	itett	eq
 101714c:	f8d8 3004 	ldreq.w	r3, [r8, #4]
 1017150:	ea09 0404 	andne.w	r4, r9, r4
 1017154:	681c      	ldreq	r4, [r3, #0]
 1017156:	eba9 0404 	subeq.w	r4, r9, r4
			if (metal_io_phys(io, offset) == phys)
 101715a:	4621      	mov	r1, r4
 101715c:	4640      	mov	r0, r8
 101715e:	f7ff feec 	bl	1016f3a <metal_io_phys>
 1017162:	4581      	cmp	r9, r0
 1017164:	d009      	beq.n	101717a <virtqueue_get_available_buffer+0x76>
			offset += io->page_mask + 1;
 1017166:	f8d8 3010 	ldr.w	r3, [r8, #16]
 101716a:	3301      	adds	r3, #1
 101716c:	441c      	add	r4, r3
		} while (offset < io->size);
 101716e:	f8d8 3008 	ldr.w	r3, [r8, #8]
 1017172:	429c      	cmp	r4, r3
 1017174:	d3f1      	bcc.n	101715a <virtqueue_get_available_buffer+0x56>
		return METAL_BAD_OFFSET;
 1017176:	f04f 34ff 	mov.w	r4, #4294967295
	return (io->virt != METAL_BAD_VA && offset < io->size
 101717a:	f8d8 0000 	ldr.w	r0, [r8]
		: NULL);
 101717e:	1c43      	adds	r3, r0, #1
 1017180:	d011      	beq.n	10171a6 <virtqueue_get_available_buffer+0xa2>
	return (io->virt != METAL_BAD_VA && offset < io->size
 1017182:	f8d8 3008 	ldr.w	r3, [r8, #8]
 1017186:	42a3      	cmp	r3, r4
 1017188:	d90d      	bls.n	10171a6 <virtqueue_get_available_buffer+0xa2>
		: NULL);
 101718a:	4420      	add	r0, r4
	*len = vq->vq_ring.desc[*avail_idx].len;
 101718c:	8832      	ldrh	r2, [r6, #0]
 101718e:	69ab      	ldr	r3, [r5, #24]
 1017190:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 1017194:	689b      	ldr	r3, [r3, #8]
 1017196:	603b      	str	r3, [r7, #0]
}
 1017198:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return (*io->ops.phys_to_offset)(io, phys);
 101719c:	4649      	mov	r1, r9
 101719e:	4640      	mov	r0, r8
 10171a0:	4798      	blx	r3
 10171a2:	4604      	mov	r4, r0
 10171a4:	e7e9      	b.n	101717a <virtqueue_get_available_buffer+0x76>
		: NULL);
 10171a6:	2000      	movs	r0, #0
 10171a8:	e7f0      	b.n	101718c <virtqueue_get_available_buffer+0x88>
		return NULL;
 10171aa:	2000      	movs	r0, #0
 10171ac:	e7f4      	b.n	1017198 <virtqueue_get_available_buffer+0x94>

010171ae <virtqueue_disable_cb>:
{
 10171ae:	b530      	push	{r4, r5, lr}
	if (vq->vq_dev->features & VIRTIO_RING_F_EVENT_IDX) {
 10171b0:	2500      	movs	r5, #0
 10171b2:	6802      	ldr	r2, [r0, #0]
 10171b4:	6993      	ldr	r3, [r2, #24]
 10171b6:	6912      	ldr	r2, [r2, #16]
 10171b8:	f002 5400 	and.w	r4, r2, #536870912	; 0x20000000
 10171bc:	ea54 0205 	orrs.w	r2, r4, r5
 10171c0:	d014      	beq.n	10171ec <virtqueue_disable_cb+0x3e>
		if (vq->vq_dev->role == VIRTIO_DEV_MASTER) {
 10171c2:	b94b      	cbnz	r3, 10171d8 <virtqueue_disable_cb+0x2a>
			vring_used_event(&vq->vq_ring) =
 10171c4:	69c2      	ldr	r2, [r0, #28]
 10171c6:	6941      	ldr	r1, [r0, #20]
			    vq->vq_used_cons_idx - vq->vq_nentries - 1;
 10171c8:	8dc3      	ldrh	r3, [r0, #46]	; 0x2e
 10171ca:	8940      	ldrh	r0, [r0, #10]
			vring_used_event(&vq->vq_ring) =
 10171cc:	eb02 0241 	add.w	r2, r2, r1, lsl #1
			    vq->vq_used_cons_idx - vq->vq_nentries - 1;
 10171d0:	1a1b      	subs	r3, r3, r0
			vring_avail_event(&vq->vq_ring) =
 10171d2:	3b01      	subs	r3, #1
 10171d4:	8093      	strh	r3, [r2, #4]
}
 10171d6:	bd30      	pop	{r4, r5, pc}
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE) {
 10171d8:	2b01      	cmp	r3, #1
 10171da:	d1fc      	bne.n	10171d6 <virtqueue_disable_cb+0x28>
			vring_avail_event(&vq->vq_ring) =
 10171dc:	6a02      	ldr	r2, [r0, #32]
 10171de:	6941      	ldr	r1, [r0, #20]
			    vq->vq_available_idx - vq->vq_nentries - 1;
 10171e0:	8e03      	ldrh	r3, [r0, #48]	; 0x30
 10171e2:	8940      	ldrh	r0, [r0, #10]
			vring_avail_event(&vq->vq_ring) =
 10171e4:	eb02 02c1 	add.w	r2, r2, r1, lsl #3
			    vq->vq_available_idx - vq->vq_nentries - 1;
 10171e8:	1a1b      	subs	r3, r3, r0
 10171ea:	e7f2      	b.n	10171d2 <virtqueue_disable_cb+0x24>
		if (vq->vq_dev->role == VIRTIO_DEV_MASTER)
 10171ec:	b92b      	cbnz	r3, 10171fa <virtqueue_disable_cb+0x4c>
			vq->vq_ring.avail->flags |= VRING_AVAIL_F_NO_INTERRUPT;
 10171ee:	69c2      	ldr	r2, [r0, #28]
			vq->vq_ring.used->flags |= VRING_USED_F_NO_NOTIFY;
 10171f0:	8813      	ldrh	r3, [r2, #0]
 10171f2:	f043 0301 	orr.w	r3, r3, #1
 10171f6:	8013      	strh	r3, [r2, #0]
}
 10171f8:	e7ed      	b.n	10171d6 <virtqueue_disable_cb+0x28>
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE)
 10171fa:	2b01      	cmp	r3, #1
 10171fc:	d1eb      	bne.n	10171d6 <virtqueue_disable_cb+0x28>
			vq->vq_ring.used->flags |= VRING_USED_F_NO_NOTIFY;
 10171fe:	6a02      	ldr	r2, [r0, #32]
 1017200:	e7f6      	b.n	10171f0 <virtqueue_disable_cb+0x42>

01017202 <virtqueue_kick>:
{
 1017202:	b510      	push	{r4, lr}
	atomic_thread_fence(memory_order_seq_cst);
 1017204:	f3bf 8f5b 	dmb	ish
 */
static int vq_ring_must_notify(struct virtqueue *vq)
{
	uint16_t new_idx, prev_idx, event_idx;

	if (vq->vq_dev->features & VIRTIO_RING_F_EVENT_IDX) {
 1017208:	2300      	movs	r3, #0
 101720a:	6801      	ldr	r1, [r0, #0]
{
 101720c:	4604      	mov	r4, r0
	if (vq->vq_dev->features & VIRTIO_RING_F_EVENT_IDX) {
 101720e:	6908      	ldr	r0, [r1, #16]
 1017210:	f000 5200 	and.w	r2, r0, #536870912	; 0x20000000
 1017214:	4313      	orrs	r3, r2
 1017216:	698b      	ldr	r3, [r1, #24]
 1017218:	d020      	beq.n	101725c <virtqueue_kick+0x5a>
#ifndef VIRTIO_SLAVE_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_MASTER) {
 101721a:	b9b3      	cbnz	r3, 101724a <virtqueue_kick+0x48>
			new_idx = vq->vq_ring.avail->idx;
 101721c:	69e3      	ldr	r3, [r4, #28]
			prev_idx = new_idx - vq->vq_queued_cnt;
			event_idx = vring_avail_event(&vq->vq_ring);
 101721e:	6961      	ldr	r1, [r4, #20]
			new_idx = vq->vq_ring.avail->idx;
 1017220:	885a      	ldrh	r2, [r3, #2]
			event_idx = vring_avail_event(&vq->vq_ring);
 1017222:	6a23      	ldr	r3, [r4, #32]
 1017224:	eb03 03c1 	add.w	r3, r3, r1, lsl #3
#endif /*VIRTIO_SLAVE_ONLY*/
#ifndef VIRTIO_MASTER_ONLY
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE) {
			new_idx = vq->vq_ring.used->idx;
			prev_idx = new_idx - vq->vq_queued_cnt;
			event_idx = vring_used_event(&vq->vq_ring);
 1017228:	889b      	ldrh	r3, [r3, #4]
 * event?
 */
static inline int
vring_need_event(uint16_t event_idx, uint16_t new_idx, uint16_t old)
{
	return (uint16_t)(new_idx - event_idx - 1) <
 101722a:	1ad2      	subs	r2, r2, r3
 101722c:	3a01      	subs	r2, #1
 101722e:	8ce3      	ldrh	r3, [r4, #38]	; 0x26
 1017230:	b292      	uxth	r2, r2
 1017232:	4293      	cmp	r3, r2
 1017234:	bf94      	ite	ls
 1017236:	2300      	movls	r3, #0
 1017238:	2301      	movhi	r3, #1
	if (vq_ring_must_notify(vq))
 101723a:	b11b      	cbz	r3, 1017244 <virtqueue_kick+0x42>
 * vq_ring_notify
 *
 */
static void vq_ring_notify(struct virtqueue *vq)
{
	if (vq->notify)
 101723c:	6923      	ldr	r3, [r4, #16]
 101723e:	b10b      	cbz	r3, 1017244 <virtqueue_kick+0x42>
		vq->notify(vq);
 1017240:	4620      	mov	r0, r4
 1017242:	4798      	blx	r3
	vq->vq_queued_cnt = 0;
 1017244:	2300      	movs	r3, #0
 1017246:	84e3      	strh	r3, [r4, #38]	; 0x26
}
 1017248:	bd10      	pop	{r4, pc}
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE) {
 101724a:	2b01      	cmp	r3, #1
 101724c:	d1fa      	bne.n	1017244 <virtqueue_kick+0x42>
			new_idx = vq->vq_ring.used->idx;
 101724e:	6a23      	ldr	r3, [r4, #32]
			event_idx = vring_used_event(&vq->vq_ring);
 1017250:	6961      	ldr	r1, [r4, #20]
			new_idx = vq->vq_ring.used->idx;
 1017252:	885a      	ldrh	r2, [r3, #2]
			event_idx = vring_used_event(&vq->vq_ring);
 1017254:	69e3      	ldr	r3, [r4, #28]
 1017256:	eb03 0341 	add.w	r3, r3, r1, lsl #1
 101725a:	e7e5      	b.n	1017228 <virtqueue_kick+0x26>
		if (vq->vq_dev->role == VIRTIO_DEV_MASTER)
 101725c:	b92b      	cbnz	r3, 101726a <virtqueue_kick+0x68>
			return (vq->vq_ring.used->flags &
 101725e:	6a23      	ldr	r3, [r4, #32]
			return (vq->vq_ring.avail->flags &
 1017260:	881b      	ldrh	r3, [r3, #0]
				VRING_AVAIL_F_NO_INTERRUPT) == 0;
 1017262:	43db      	mvns	r3, r3
 1017264:	f003 0301 	and.w	r3, r3, #1
 1017268:	e7e7      	b.n	101723a <virtqueue_kick+0x38>
		if (vq->vq_dev->role == VIRTIO_DEV_SLAVE)
 101726a:	2b01      	cmp	r3, #1
 101726c:	d1ea      	bne.n	1017244 <virtqueue_kick+0x42>
			return (vq->vq_ring.avail->flags &
 101726e:	69e3      	ldr	r3, [r4, #28]
 1017270:	e7f6      	b.n	1017260 <virtqueue_kick+0x5e>

01017272 <virtqueue_get_desc_size>:
	if (vq->vq_available_idx == vq->vq_ring.avail->idx) {
 1017272:	69c2      	ldr	r2, [r0, #28]
 1017274:	8e01      	ldrh	r1, [r0, #48]	; 0x30
 1017276:	8853      	ldrh	r3, [r2, #2]
 1017278:	428b      	cmp	r3, r1
 101727a:	d00a      	beq.n	1017292 <virtqueue_get_desc_size+0x20>
	head_idx = vq->vq_available_idx & (vq->vq_nentries - 1);
 101727c:	8943      	ldrh	r3, [r0, #10]
 101727e:	3b01      	subs	r3, #1
	avail_idx = vq->vq_ring.avail->ring[head_idx];
 1017280:	400b      	ands	r3, r1
 1017282:	eb02 0343 	add.w	r3, r2, r3, lsl #1
	len = vq->vq_ring.desc[avail_idx].len;
 1017286:	889a      	ldrh	r2, [r3, #4]
 1017288:	6983      	ldr	r3, [r0, #24]
 101728a:	eb03 1302 	add.w	r3, r3, r2, lsl #4
 101728e:	6898      	ldr	r0, [r3, #8]
	return len;
 1017290:	4770      	bx	lr
		return 0;
 1017292:	2000      	movs	r0, #0
}
 1017294:	4770      	bx	lr

01017296 <virtqueue_notification>:
	atomic_thread_fence(memory_order_seq_cst);
 1017296:	f3bf 8f5b 	dmb	ish
	if (vq->callback)
 101729a:	68c3      	ldr	r3, [r0, #12]
 101729c:	b103      	cbz	r3, 10172a0 <virtqueue_notification+0xa>
		vq->callback(vq);
 101729e:	4718      	bx	r3
}
 10172a0:	4770      	bx	lr

010172a2 <rpmsg_unregister_endpoint>:
{
 10172a2:	b510      	push	{r4, lr}
	if (!ept)
 10172a4:	b1d0      	cbz	r0, 10172dc <rpmsg_unregister_endpoint+0x3a>
	if (ept->addr != RPMSG_ADDR_ANY)
 10172a6:	6a43      	ldr	r3, [r0, #36]	; 0x24
 10172a8:	1c5a      	adds	r2, r3, #1
 10172aa:	d00f      	beq.n	10172cc <rpmsg_unregister_endpoint+0x2a>
	if (addr < size)
 10172ac:	2b7f      	cmp	r3, #127	; 0x7f
 10172ae:	dc0d      	bgt.n	10172cc <rpmsg_unregister_endpoint+0x2a>
		~metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
 10172b0:	2101      	movs	r1, #1
		rpmsg_release_address(rdev->bitmap, RPMSG_ADDR_BMP_SIZE,
 10172b2:	6a02      	ldr	r2, [r0, #32]
	bitmap[bit / METAL_BITS_PER_ULONG] &=
 10172b4:	095c      	lsrs	r4, r3, #5
 10172b6:	3248      	adds	r2, #72	; 0x48
		~metal_bit(bit & (METAL_BITS_PER_ULONG - 1));
 10172b8:	f003 031f 	and.w	r3, r3, #31
 10172bc:	fa01 f303 	lsl.w	r3, r1, r3
	bitmap[bit / METAL_BITS_PER_ULONG] &=
 10172c0:	f852 1024 	ldr.w	r1, [r2, r4, lsl #2]
 10172c4:	ea21 0103 	bic.w	r1, r1, r3
 10172c8:	f842 1024 	str.w	r1, [r2, r4, lsl #2]
	metal_list_del(&ept->node);
 10172cc:	f100 0334 	add.w	r3, r0, #52	; 0x34
	return list->next == list;
}

static inline void metal_list_del(struct metal_list *node)
{
	node->next->prev = node->prev;
 10172d0:	e9d0 120d 	ldrd	r1, r2, [r0, #52]	; 0x34
 10172d4:	604a      	str	r2, [r1, #4]
	node->prev->next = node->next;
 10172d6:	6011      	str	r1, [r2, #0]
	node->prev = node;
	node->next = node;
 10172d8:	e9c0 330d 	strd	r3, r3, [r0, #52]	; 0x34
}
 10172dc:	bd10      	pop	{r4, pc}

010172de <__metal_mutex_acquire>:
	return z_impl_k_sem_take(sem, timeout);
 10172de:	f04f 32ff 	mov.w	r2, #4294967295
 10172e2:	f04f 33ff 	mov.w	r3, #4294967295
 10172e6:	f7fd b9d5 	b.w	1014694 <z_impl_k_sem_take>

010172ea <rpmsg_send_ns_message>:
{
 10172ea:	b510      	push	{r4, lr}
	ns_msg.addr = ept->addr;
 10172ec:	6a43      	ldr	r3, [r0, #36]	; 0x24
{
 10172ee:	b08c      	sub	sp, #48	; 0x30
 10172f0:	4604      	mov	r4, r0
	ns_msg.flags = flags;
 10172f2:	910b      	str	r1, [sp, #44]	; 0x2c
	strncpy(ns_msg.name, ept->name, sizeof(ns_msg.name));
 10172f4:	2220      	movs	r2, #32
 10172f6:	4601      	mov	r1, r0
 10172f8:	a802      	add	r0, sp, #8
	ns_msg.addr = ept->addr;
 10172fa:	930a      	str	r3, [sp, #40]	; 0x28
	strncpy(ns_msg.name, ept->name, sizeof(ns_msg.name));
 10172fc:	f7ff fa97 	bl	101682e <strncpy>
	ret = rpmsg_send_offchannel_raw(ept, ept->addr,
 1017300:	2328      	movs	r3, #40	; 0x28
 1017302:	2201      	movs	r2, #1
 1017304:	4620      	mov	r0, r4
 1017306:	e9cd 3200 	strd	r3, r2, [sp]
 101730a:	6a61      	ldr	r1, [r4, #36]	; 0x24
 101730c:	2235      	movs	r2, #53	; 0x35
 101730e:	ab02      	add	r3, sp, #8
 1017310:	f7fc fa06 	bl	1013720 <rpmsg_send_offchannel_raw>
}
 1017314:	ea00 70e0 	and.w	r0, r0, r0, asr #31
 1017318:	b00c      	add	sp, #48	; 0x30
 101731a:	bd10      	pop	{r4, pc}

0101731c <rpmsg_get_endpoint>:
{
 101731c:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 1017320:	4680      	mov	r8, r0
 1017322:	4689      	mov	r9, r1
 1017324:	4615      	mov	r5, r2
 1017326:	461e      	mov	r6, r3
	metal_list_for_each(&rdev->endpoints, node) {
 1017328:	6807      	ldr	r7, [r0, #0]
 101732a:	45b8      	cmp	r8, r7
 101732c:	d101      	bne.n	1017332 <rpmsg_get_endpoint+0x16>
	return NULL;
 101732e:	2400      	movs	r4, #0
 1017330:	e021      	b.n	1017376 <rpmsg_get_endpoint+0x5a>
		if (addr != RPMSG_ADDR_ANY && ept->addr == addr)
 1017332:	1c69      	adds	r1, r5, #1
		ept = metal_container_of(node, struct rpmsg_endpoint, node);
 1017334:	f1a7 0434 	sub.w	r4, r7, #52	; 0x34
		if (addr != RPMSG_ADDR_ANY && ept->addr == addr)
 1017338:	6a63      	ldr	r3, [r4, #36]	; 0x24
 101733a:	d006      	beq.n	101734a <rpmsg_get_endpoint+0x2e>
 101733c:	429d      	cmp	r5, r3
		if (addr == ept->addr && dest_addr == ept->dest_addr)
 101733e:	d01a      	beq.n	1017376 <rpmsg_get_endpoint+0x5a>
		if (name)
 1017340:	f1b9 0f00 	cmp.w	r9, #0
 1017344:	d106      	bne.n	1017354 <rpmsg_get_endpoint+0x38>
	metal_list_for_each(&rdev->endpoints, node) {
 1017346:	683f      	ldr	r7, [r7, #0]
 1017348:	e7ef      	b.n	101732a <rpmsg_get_endpoint+0xe>
		if (addr == ept->addr && dest_addr == ept->dest_addr)
 101734a:	3301      	adds	r3, #1
 101734c:	d1f8      	bne.n	1017340 <rpmsg_get_endpoint+0x24>
 101734e:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1017350:	42b3      	cmp	r3, r6
 1017352:	e7f4      	b.n	101733e <rpmsg_get_endpoint+0x22>
			name_match = !strncmp(ept->name, name,
 1017354:	2220      	movs	r2, #32
 1017356:	4649      	mov	r1, r9
 1017358:	4620      	mov	r0, r4
 101735a:	f7ff fa8e 	bl	101687a <strncmp>
		if (!name || !name_match)
 101735e:	2800      	cmp	r0, #0
 1017360:	d1f1      	bne.n	1017346 <rpmsg_get_endpoint+0x2a>
		if (dest_addr != RPMSG_ADDR_ANY && ept->dest_addr == dest_addr)
 1017362:	1c72      	adds	r2, r6, #1
 1017364:	d002      	beq.n	101736c <rpmsg_get_endpoint+0x50>
 1017366:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1017368:	42b3      	cmp	r3, r6
 101736a:	d004      	beq.n	1017376 <rpmsg_get_endpoint+0x5a>
		if (addr == RPMSG_ADDR_ANY && ept->dest_addr == RPMSG_ADDR_ANY)
 101736c:	1c6b      	adds	r3, r5, #1
 101736e:	d1ea      	bne.n	1017346 <rpmsg_get_endpoint+0x2a>
 1017370:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 1017372:	3301      	adds	r3, #1
 1017374:	d1e7      	bne.n	1017346 <rpmsg_get_endpoint+0x2a>
}
 1017376:	4620      	mov	r0, r4
 1017378:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}

0101737c <rpmsg_register_endpoint>:
	new_node->prev = node->prev;
 101737c:	6842      	ldr	r2, [r0, #4]
	metal_list_add_tail(&rdev->endpoints, &ept->node);
 101737e:	f101 0334 	add.w	r3, r1, #52	; 0x34
	new_node->next = node;
 1017382:	e9c1 020d 	strd	r0, r2, [r1, #52]	; 0x34
	ept->rdev = rdev;
 1017386:	6208      	str	r0, [r1, #32]
	new_node->next->prev = new_node;
 1017388:	6043      	str	r3, [r0, #4]
	new_node->prev->next = new_node;
 101738a:	6b8a      	ldr	r2, [r1, #56]	; 0x38
 101738c:	6013      	str	r3, [r2, #0]
}
 101738e:	4770      	bx	lr

01017390 <rpmsg_destroy_ept>:
 *
 * @param ept - pointer to endpoint to destroy
 *
 */
void rpmsg_destroy_ept(struct rpmsg_endpoint *ept)
{
 1017390:	b538      	push	{r3, r4, r5, lr}
	struct rpmsg_device *rdev;

	if (!ept)
 1017392:	4604      	mov	r4, r0
 1017394:	b1b8      	cbz	r0, 10173c6 <rpmsg_destroy_ept+0x36>
		return;

	rdev = ept->rdev;
	if (ept->name[0] && rdev->support_ns && ept->addr != RPMSG_NS_EPT_ADDR)
 1017396:	7803      	ldrb	r3, [r0, #0]
	rdev = ept->rdev;
 1017398:	6a05      	ldr	r5, [r0, #32]
	if (ept->name[0] && rdev->support_ns && ept->addr != RPMSG_NS_EPT_ADDR)
 101739a:	b143      	cbz	r3, 10173ae <rpmsg_destroy_ept+0x1e>
 101739c:	f895 3078 	ldrb.w	r3, [r5, #120]	; 0x78
 10173a0:	b12b      	cbz	r3, 10173ae <rpmsg_destroy_ept+0x1e>
 10173a2:	6a43      	ldr	r3, [r0, #36]	; 0x24
 10173a4:	2b35      	cmp	r3, #53	; 0x35
 10173a6:	d002      	beq.n	10173ae <rpmsg_destroy_ept+0x1e>
		(void)rpmsg_send_ns_message(ept, RPMSG_NS_DESTROY);
 10173a8:	2101      	movs	r1, #1
 10173aa:	f7ff ff9e 	bl	10172ea <rpmsg_send_ns_message>
	metal_mutex_acquire(&rdev->lock);
 10173ae:	3558      	adds	r5, #88	; 0x58
 10173b0:	4628      	mov	r0, r5
 10173b2:	f7ff ff94 	bl	10172de <__metal_mutex_acquire>
	rpmsg_unregister_endpoint(ept);
 10173b6:	4620      	mov	r0, r4
 10173b8:	f7ff ff73 	bl	10172a2 <rpmsg_unregister_endpoint>
	z_impl_k_sem_give(sem);
 10173bc:	4628      	mov	r0, r5
	metal_mutex_release(&rdev->lock);
}
 10173be:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 10173c2:	f7fd b941 	b.w	1014648 <z_impl_k_sem_give>
 10173c6:	bd38      	pop	{r3, r4, r5, pc}

010173c8 <rpmsg_virtio_tx_callback>:
}
 10173c8:	4770      	bx	lr

010173ca <k_sem_give>:
 10173ca:	f7fd b93d 	b.w	1014648 <z_impl_k_sem_give>

010173ce <rpmsg_virtio_get_rx_buffer>:
{
 10173ce:	b430      	push	{r4, r5}
	return rvdev->vdev->role;
 10173d0:	6fc5      	ldr	r5, [r0, #124]	; 0x7c
 10173d2:	4613      	mov	r3, r2
 10173d4:	69ad      	ldr	r5, [r5, #24]
	if (role == RPMSG_MASTER) {
 10173d6:	b925      	cbnz	r5, 10173e2 <rpmsg_virtio_get_rx_buffer+0x14>
}
 10173d8:	bc30      	pop	{r4, r5}
		data = virtqueue_get_buffer(rvdev->rvq, len, idx);
 10173da:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 10173de:	f7ff be57 	b.w	1017090 <virtqueue_get_buffer>
	if (role == RPMSG_REMOTE) {
 10173e2:	2d01      	cmp	r5, #1
 10173e4:	d106      	bne.n	10173f4 <rpmsg_virtio_get_rx_buffer+0x26>
}
 10173e6:	bc30      	pop	{r4, r5}
		    virtqueue_get_available_buffer(rvdev->rvq, idx, len);
 10173e8:	460a      	mov	r2, r1
 10173ea:	f8d0 0080 	ldr.w	r0, [r0, #128]	; 0x80
 10173ee:	4619      	mov	r1, r3
 10173f0:	f7ff be88 	b.w	1017104 <virtqueue_get_available_buffer>
}
 10173f4:	2000      	movs	r0, #0
 10173f6:	bc30      	pop	{r4, r5}
 10173f8:	4770      	bx	lr

010173fa <__metal_mutex_acquire>:
	return z_impl_k_sem_take(sem, timeout);
 10173fa:	f04f 32ff 	mov.w	r2, #4294967295
 10173fe:	f04f 33ff 	mov.w	r3, #4294967295
 1017402:	f7fd b947 	b.w	1014694 <z_impl_k_sem_take>

01017406 <rpmsg_virtio_ns_callback>:
{
 1017406:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
	if (len != sizeof(*ns_msg))
 101740a:	2a28      	cmp	r2, #40	; 0x28
{
 101740c:	4680      	mov	r8, r0
 101740e:	460e      	mov	r6, r1
 1017410:	b089      	sub	sp, #36	; 0x24
	if (len != sizeof(*ns_msg))
 1017412:	d12b      	bne.n	101746c <rpmsg_virtio_ns_callback+0x66>
	struct rpmsg_device *rdev = ept->rdev;
 1017414:	6a05      	ldr	r5, [r0, #32]
	metal_io_block_read(io,
 1017416:	2320      	movs	r3, #32
	struct metal_io_region *io = rvdev->shbuf_io;
 1017418:	f8d5 0088 	ldr.w	r0, [r5, #136]	; 0x88
	metal_io_block_read(io,
 101741c:	466a      	mov	r2, sp
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
 101741e:	6801      	ldr	r1, [r0, #0]
	return (offset < io->size ? offset : METAL_BAD_OFFSET);
 1017420:	6884      	ldr	r4, [r0, #8]
	size_t offset = (uint8_t *)virt - (uint8_t *)io->virt;
 1017422:	1a71      	subs	r1, r6, r1
 1017424:	42a1      	cmp	r1, r4
 1017426:	bf28      	it	cs
 1017428:	f04f 31ff 	movcs.w	r1, #4294967295
 101742c:	f7ff fcd2 	bl	1016dd4 <metal_io_block_read>
	metal_mutex_acquire(&rdev->lock);
 1017430:	f105 0758 	add.w	r7, r5, #88	; 0x58
	dest = ns_msg->addr;
 1017434:	f8d6 9020 	ldr.w	r9, [r6, #32]
 1017438:	4638      	mov	r0, r7
 101743a:	f7ff ffde 	bl	10173fa <__metal_mutex_acquire>
	_ept = rpmsg_get_endpoint(rdev, name, RPMSG_ADDR_ANY, dest);
 101743e:	464b      	mov	r3, r9
 1017440:	f04f 32ff 	mov.w	r2, #4294967295
 1017444:	4669      	mov	r1, sp
 1017446:	4628      	mov	r0, r5
 1017448:	f7ff ff68 	bl	101731c <rpmsg_get_endpoint>
	if (ns_msg->flags & RPMSG_NS_DESTROY) {
 101744c:	6a73      	ldr	r3, [r6, #36]	; 0x24
	_ept = rpmsg_get_endpoint(rdev, name, RPMSG_ADDR_ANY, dest);
 101744e:	4604      	mov	r4, r0
	if (ns_msg->flags & RPMSG_NS_DESTROY) {
 1017450:	07db      	lsls	r3, r3, #31
 1017452:	d50f      	bpl.n	1017474 <rpmsg_virtio_ns_callback+0x6e>
		if (_ept)
 1017454:	b110      	cbz	r0, 101745c <rpmsg_virtio_ns_callback+0x56>
			_ept->dest_addr = RPMSG_ADDR_ANY;
 1017456:	f04f 33ff 	mov.w	r3, #4294967295
 101745a:	6283      	str	r3, [r0, #40]	; 0x28
 101745c:	4638      	mov	r0, r7
 101745e:	f7ff ffb4 	bl	10173ca <k_sem_give>
		if (_ept && _ept->ns_unbind_cb)
 1017462:	b11c      	cbz	r4, 101746c <rpmsg_virtio_ns_callback+0x66>
 1017464:	6b23      	ldr	r3, [r4, #48]	; 0x30
 1017466:	b10b      	cbz	r3, 101746c <rpmsg_virtio_ns_callback+0x66>
			_ept->ns_unbind_cb(ept);
 1017468:	4640      	mov	r0, r8
 101746a:	4798      	blx	r3
}
 101746c:	2000      	movs	r0, #0
 101746e:	b009      	add	sp, #36	; 0x24
 1017470:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
		if (!_ept) {
 1017474:	b950      	cbnz	r0, 101748c <rpmsg_virtio_ns_callback+0x86>
 1017476:	4638      	mov	r0, r7
 1017478:	f7ff ffa7 	bl	10173ca <k_sem_give>
			if (rdev->ns_bind_cb)
 101747c:	6f2b      	ldr	r3, [r5, #112]	; 0x70
 101747e:	2b00      	cmp	r3, #0
 1017480:	d0f4      	beq.n	101746c <rpmsg_virtio_ns_callback+0x66>
				rdev->ns_bind_cb(rdev, name, dest);
 1017482:	464a      	mov	r2, r9
 1017484:	4669      	mov	r1, sp
 1017486:	4628      	mov	r0, r5
 1017488:	4798      	blx	r3
 101748a:	e7ef      	b.n	101746c <rpmsg_virtio_ns_callback+0x66>
			_ept->dest_addr = dest;
 101748c:	f8c0 9028 	str.w	r9, [r0, #40]	; 0x28
 1017490:	4638      	mov	r0, r7
 1017492:	f7ff ff9a 	bl	10173ca <k_sem_give>
 * @see metal_mutex_try_acquire, metal_mutex_acquire
 */
static inline void metal_mutex_release(metal_mutex_t *mutex)
{
	__metal_mutex_release(mutex);
}
 1017496:	e7e9      	b.n	101746c <rpmsg_virtio_ns_callback+0x66>

01017498 <rpmsg_virtio_rx_callback>:
{
 1017498:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
	struct rpmsg_virtio_device *rvdev = vdev->priv;
 101749c:	6803      	ldr	r3, [r0, #0]
{
 101749e:	b086      	sub	sp, #24
	struct rpmsg_virtio_device *rvdev = vdev->priv;
 10174a0:	6a5e      	ldr	r6, [r3, #36]	; 0x24
	metal_mutex_acquire(&rdev->lock);
 10174a2:	f106 0758 	add.w	r7, r6, #88	; 0x58
	__metal_mutex_acquire(mutex);
 10174a6:	4638      	mov	r0, r7
 10174a8:	f7ff ffa7 	bl	10173fa <__metal_mutex_acquire>
	rp_hdr = rpmsg_virtio_get_rx_buffer(rvdev, &len, &idx);
 10174ac:	4630      	mov	r0, r6
 10174ae:	f10d 020a 	add.w	r2, sp, #10
 10174b2:	a903      	add	r1, sp, #12
 10174b4:	f7ff ff8b 	bl	10173ce <rpmsg_virtio_get_rx_buffer>
 10174b8:	4604      	mov	r4, r0
 10174ba:	4638      	mov	r0, r7
 10174bc:	f7ff ff85 	bl	10173ca <k_sem_give>
	while (rp_hdr) {
 10174c0:	b914      	cbnz	r4, 10174c8 <rpmsg_virtio_rx_callback+0x30>
}
 10174c2:	b006      	add	sp, #24
 10174c4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 10174c8:	4638      	mov	r0, r7
 10174ca:	f7ff ff96 	bl	10173fa <__metal_mutex_acquire>
			     struct rpmsg_endpoint *ept);

static inline struct rpmsg_endpoint *
rpmsg_get_ept_from_addr(struct rpmsg_device *rdev, uint32_t addr)
{
	return rpmsg_get_endpoint(rdev, NULL, addr, RPMSG_ADDR_ANY);
 10174ce:	f04f 33ff 	mov.w	r3, #4294967295
 10174d2:	2100      	movs	r1, #0
 10174d4:	4630      	mov	r0, r6
 10174d6:	6862      	ldr	r2, [r4, #4]
 10174d8:	f7ff ff20 	bl	101731c <rpmsg_get_endpoint>
 10174dc:	4605      	mov	r5, r0
 10174de:	4638      	mov	r0, r7
 10174e0:	f7ff ff73 	bl	10173ca <k_sem_give>
		if (ept) {
 10174e4:	b185      	cbz	r5, 1017508 <rpmsg_virtio_rx_callback+0x70>
			if (ept->dest_addr == RPMSG_ADDR_ANY) {
 10174e6:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 10174e8:	6823      	ldr	r3, [r4, #0]
 10174ea:	3201      	adds	r2, #1
			status = ept->cb(ept, RPMSG_LOCATE_DATA(rp_hdr),
 10174ec:	6be9      	ldr	r1, [r5, #60]	; 0x3c
				ept->dest_addr = rp_hdr->src;
 10174ee:	bf08      	it	eq
 10174f0:	62ab      	streq	r3, [r5, #40]	; 0x28
			status = ept->cb(ept, RPMSG_LOCATE_DATA(rp_hdr),
 10174f2:	89a2      	ldrh	r2, [r4, #12]
 10174f4:	9100      	str	r1, [sp, #0]
 10174f6:	4628      	mov	r0, r5
 10174f8:	f8d5 802c 	ldr.w	r8, [r5, #44]	; 0x2c
 10174fc:	f104 0110 	add.w	r1, r4, #16
 1017500:	47c0      	blx	r8
			RPMSG_ASSERT(status >= 0,
 1017502:	2800      	cmp	r0, #0
 1017504:	da00      	bge.n	1017508 <rpmsg_virtio_rx_callback+0x70>
 1017506:	e7fe      	b.n	1017506 <rpmsg_virtio_rx_callback+0x6e>
 1017508:	4638      	mov	r0, r7
 101750a:	f7ff ff76 	bl	10173fa <__metal_mutex_acquire>
 101750e:	6ff2      	ldr	r2, [r6, #124]	; 0x7c
		rpmsg_virtio_return_buffer(rvdev, rp_hdr, len, idx);
 1017510:	9b03      	ldr	r3, [sp, #12]
 1017512:	6992      	ldr	r2, [r2, #24]
	if (role == RPMSG_MASTER) {
 1017514:	b9b2      	cbnz	r2, 1017544 <rpmsg_virtio_rx_callback+0xac>
		virtqueue_add_buffer(rvdev->rvq, &vqbuf, 0, 1, buffer);
 1017516:	9400      	str	r4, [sp, #0]
		vqbuf.len = len;
 1017518:	e9cd 4304 	strd	r4, r3, [sp, #16]
		virtqueue_add_buffer(rvdev->rvq, &vqbuf, 0, 1, buffer);
 101751c:	f8d6 0080 	ldr.w	r0, [r6, #128]	; 0x80
 1017520:	2301      	movs	r3, #1
 1017522:	a904      	add	r1, sp, #16
 1017524:	f7ff fd54 	bl	1016fd0 <virtqueue_add_buffer>
		rp_hdr = rpmsg_virtio_get_rx_buffer(rvdev, &len, &idx);
 1017528:	4630      	mov	r0, r6
 101752a:	f10d 020a 	add.w	r2, sp, #10
 101752e:	a903      	add	r1, sp, #12
 1017530:	f7ff ff4d 	bl	10173ce <rpmsg_virtio_get_rx_buffer>
		if (!rp_hdr) {
 1017534:	4604      	mov	r4, r0
 1017536:	2800      	cmp	r0, #0
 1017538:	d1bf      	bne.n	10174ba <rpmsg_virtio_rx_callback+0x22>
			virtqueue_kick(rvdev->rvq);
 101753a:	f8d6 0080 	ldr.w	r0, [r6, #128]	; 0x80
 101753e:	f7ff fe60 	bl	1017202 <virtqueue_kick>
 1017542:	e7ba      	b.n	10174ba <rpmsg_virtio_rx_callback+0x22>
	if (role == RPMSG_REMOTE) {
 1017544:	2a01      	cmp	r2, #1
 1017546:	d1ef      	bne.n	1017528 <rpmsg_virtio_rx_callback+0x90>
		virtqueue_add_consumed_buffer(rvdev->rvq, idx, len);
 1017548:	461a      	mov	r2, r3
 101754a:	f8bd 100a 	ldrh.w	r1, [sp, #10]
 101754e:	f8d6 0080 	ldr.w	r0, [r6, #128]	; 0x80
 1017552:	f7fc f8c9 	bl	10136e8 <virtqueue_add_consumed_buffer>
 1017556:	e7e7      	b.n	1017528 <rpmsg_virtio_rx_callback+0x90>

01017558 <rpmsg_virtio_shm_pool_get_buffer>:
{
 1017558:	4603      	mov	r3, r0
	if (shpool->avail < size)
 101755a:	6842      	ldr	r2, [r0, #4]
{
 101755c:	b510      	push	{r4, lr}
	if (shpool->avail < size)
 101755e:	428a      	cmp	r2, r1
	buffer = (char *)shpool->base + shpool->size - shpool->avail;
 1017560:	bf29      	itett	cs
 1017562:	6880      	ldrcs	r0, [r0, #8]
		return NULL;
 1017564:	2000      	movcc	r0, #0
	buffer = (char *)shpool->base + shpool->size - shpool->avail;
 1017566:	1a84      	subcs	r4, r0, r2
 1017568:	6818      	ldrcs	r0, [r3, #0]
	shpool->avail -= size;
 101756a:	bf22      	ittt	cs
 101756c:	1a52      	subcs	r2, r2, r1
	buffer = (char *)shpool->base + shpool->size - shpool->avail;
 101756e:	1900      	addcs	r0, r0, r4
	shpool->avail -= size;
 1017570:	605a      	strcs	r2, [r3, #4]
}
 1017572:	bd10      	pop	{r4, pc}

01017574 <z_sys_power_save_idle_exit>:
	z_clock_idle_exit();
 1017574:	f7fe ba31 	b.w	10159da <z_clock_idle_exit>

01017578 <k_heap_init>:
{
 1017578:	b410      	push	{r4}
 101757a:	f100 040c 	add.w	r4, r0, #12
	list->tail = (sys_dnode_t *)list;
 101757e:	e9c0 4403 	strd	r4, r4, [r0, #12]
}
 1017582:	bc10      	pop	{r4}
	sys_heap_init(&h->heap, mem, bytes);
 1017584:	f7fd be79 	b.w	101527a <sys_heap_init>

01017588 <k_heap_alloc>:

SYS_INIT(statics_init, PRE_KERNEL_1, CONFIG_KERNEL_INIT_PRIORITY_OBJECTS);

void *k_heap_alloc(struct k_heap *h, size_t bytes, k_timeout_t timeout)
{
 1017588:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 101758c:	4604      	mov	r4, r0
 101758e:	460e      	mov	r6, r1
	s64_t now, end = z_timeout_end_calc(timeout);
 1017590:	4610      	mov	r0, r2
 1017592:	4619      	mov	r1, r3
{
 1017594:	b085      	sub	sp, #20
	s64_t now, end = z_timeout_end_calc(timeout);
 1017596:	f000 fb73 	bl	1017c80 <z_timeout_end_calc>
	void *ret = NULL;
	k_spinlock_key_t key = k_spin_lock(&h->lock);
 101759a:	f104 0a14 	add.w	sl, r4, #20
	s64_t now, end = z_timeout_end_calc(timeout);
 101759e:	4605      	mov	r5, r0
 10175a0:	460f      	mov	r7, r1
	__asm__ volatile(
 10175a2:	f04f 0220 	mov.w	r2, #32
 10175a6:	f3ef 8311 	mrs	r3, BASEPRI
 10175aa:	f382 8811 	msr	BASEPRI, r2
 10175ae:	f3bf 8f6f 	isb	sy
		now = z_tick_get();
		if ((ret != NULL) || ((end - now) <= 0)) {
			break;
		}

		(void) z_pend_curr(&h->lock, key, &h->wait_q,
 10175b2:	f104 0b0c 	add.w	fp, r4, #12
		ret = sys_heap_alloc(&h->heap, bytes);
 10175b6:	4631      	mov	r1, r6
 10175b8:	4620      	mov	r0, r4
 10175ba:	9303      	str	r3, [sp, #12]
 10175bc:	f7fd fe05 	bl	10151ca <sys_heap_alloc>
 10175c0:	9002      	str	r0, [sp, #8]
		now = z_tick_get();
 10175c2:	f7fd facb 	bl	1014b5c <z_tick_get>
		if ((ret != NULL) || ((end - now) <= 0)) {
 10175c6:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 10175ca:	b13a      	cbz	r2, 10175dc <k_heap_alloc+0x54>
	__asm__ volatile(
 10175cc:	f383 8811 	msr	BASEPRI, r3
 10175d0:	f3bf 8f6f 	isb	sy
		key = k_spin_lock(&h->lock);
	}

	k_spin_unlock(&h->lock, key);
	return ret;
}
 10175d4:	4610      	mov	r0, r2
 10175d6:	b005      	add	sp, #20
 10175d8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
		if ((ret != NULL) || ((end - now) <= 0)) {
 10175dc:	ebb5 0800 	subs.w	r8, r5, r0
 10175e0:	eb67 0901 	sbc.w	r9, r7, r1
 10175e4:	f1b8 0f01 	cmp.w	r8, #1
 10175e8:	f179 0100 	sbcs.w	r1, r9, #0
 10175ec:	dbee      	blt.n	10175cc <k_heap_alloc+0x44>
		(void) z_pend_curr(&h->lock, key, &h->wait_q,
 10175ee:	465a      	mov	r2, fp
 10175f0:	4619      	mov	r1, r3
 10175f2:	4650      	mov	r0, sl
 10175f4:	e9cd 8900 	strd	r8, r9, [sp]
 10175f8:	f7fc ff92 	bl	1014520 <z_pend_curr>
	__asm__ volatile(
 10175fc:	f04f 0220 	mov.w	r2, #32
 1017600:	f3ef 8311 	mrs	r3, BASEPRI
 1017604:	f382 8811 	msr	BASEPRI, r2
 1017608:	f3bf 8f6f 	isb	sy
 101760c:	e7d3      	b.n	10175b6 <k_heap_alloc+0x2e>

0101760e <k_heap_free>:

void k_heap_free(struct k_heap *h, void *mem)
{
 101760e:	b538      	push	{r3, r4, r5, lr}
 1017610:	4604      	mov	r4, r0
 1017612:	f04f 0320 	mov.w	r3, #32
 1017616:	f3ef 8511 	mrs	r5, BASEPRI
 101761a:	f383 8811 	msr	BASEPRI, r3
 101761e:	f3bf 8f6f 	isb	sy
	k_spinlock_key_t key = k_spin_lock(&h->lock);

	sys_heap_free(&h->heap, mem);
 1017622:	f7fd fd1f 	bl	1015064 <sys_heap_free>

	if (z_unpend_all(&h->wait_q) != 0) {
 1017626:	f104 000c 	add.w	r0, r4, #12
 101762a:	f000 fa3d 	bl	1017aa8 <z_unpend_all>
 101762e:	b130      	cbz	r0, 101763e <k_heap_free+0x30>
		z_reschedule(&h->lock, key);
 1017630:	4629      	mov	r1, r5
 1017632:	f104 0014 	add.w	r0, r4, #20
	} else {
		k_spin_unlock(&h->lock, key);
	}
}
 1017636:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		z_reschedule(&h->lock, key);
 101763a:	f000 b94a 	b.w	10178d2 <z_reschedule>
	__asm__ volatile(
 101763e:	f385 8811 	msr	BASEPRI, r5
 1017642:	f3bf 8f6f 	isb	sy
}
 1017646:	bd38      	pop	{r3, r4, r5, pc}

01017648 <k_mem_pool_alloc>:
 * backend.
 */

int k_mem_pool_alloc(struct k_mem_pool *p, struct k_mem_block *block,
		     size_t size, k_timeout_t timeout)
{
 1017648:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 101764a:	e9dd 6706 	ldrd	r6, r7, [sp, #24]
 101764e:	4614      	mov	r4, r2
	block->id.heap = p->heap;
 1017650:	6800      	ldr	r0, [r0, #0]
{
 1017652:	460d      	mov	r5, r1
	block->id.heap = p->heap;
 1017654:	6048      	str	r0, [r1, #4]
	block->data = k_heap_alloc(p->heap, size, timeout);
 1017656:	4632      	mov	r2, r6
 1017658:	463b      	mov	r3, r7
 101765a:	4621      	mov	r1, r4
 101765c:	f7ff ff94 	bl	1017588 <k_heap_alloc>
 1017660:	6028      	str	r0, [r5, #0]

	/* The legacy API returns -EAGAIN on timeout expiration, but
	 * -ENOMEM if the timeout was K_NO_WAIT. Don't ask.
	 */
	if (size != 0 && block->data == NULL) {
 1017662:	b144      	cbz	r4, 1017676 <k_mem_pool_alloc+0x2e>
 1017664:	b938      	cbnz	r0, 1017676 <k_mem_pool_alloc+0x2e>
		return K_TIMEOUT_EQ(timeout, K_NO_WAIT) ? -ENOMEM : -EAGAIN;
 1017666:	ea56 0307 	orrs.w	r3, r6, r7
 101766a:	bf0c      	ite	eq
 101766c:	f06f 000b 	mvneq.w	r0, #11
 1017670:	f06f 000a 	mvnne.w	r0, #10
	} else {
		return 0;
	}
}
 1017674:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
		return 0;
 1017676:	2000      	movs	r0, #0
 1017678:	e7fc      	b.n	1017674 <k_mem_pool_alloc+0x2c>

0101767a <k_mem_pool_free_id>:

void k_mem_pool_free_id(struct k_mem_block_id *id)
{
	k_heap_free(id->heap, id->data);
 101767a:	e9d0 1000 	ldrd	r1, r0, [r0]
 101767e:	f7ff bfc6 	b.w	101760e <k_heap_free>

01017682 <k_mem_slab_init>:
{
 1017682:	b530      	push	{r4, r5, lr}
	slab->num_used = 0U;
 1017684:	2400      	movs	r4, #0
 1017686:	6184      	str	r4, [r0, #24]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
 1017688:	ea41 0402 	orr.w	r4, r1, r2
 101768c:	f014 0403 	ands.w	r4, r4, #3
	slab->block_size = block_size;
 1017690:	e9c0 3202 	strd	r3, r2, [r0, #8]
	slab->buffer = buffer;
 1017694:	6101      	str	r1, [r0, #16]
	CHECKIF(((slab->block_size | (uintptr_t)slab->buffer) &
 1017696:	d10c      	bne.n	10176b2 <k_mem_slab_init+0x30>
	slab->free_list = NULL;
 1017698:	6144      	str	r4, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
 101769a:	42a3      	cmp	r3, r4
 101769c:	d103      	bne.n	10176a6 <k_mem_slab_init+0x24>
 101769e:	e9c0 0000 	strd	r0, r0, [r0]
}
 10176a2:	2000      	movs	r0, #0
}
 10176a4:	bd30      	pop	{r4, r5, pc}
		*(char **)p = slab->free_list;
 10176a6:	6945      	ldr	r5, [r0, #20]
	for (j = 0U; j < slab->num_blocks; j++) {
 10176a8:	3401      	adds	r4, #1
		*(char **)p = slab->free_list;
 10176aa:	600d      	str	r5, [r1, #0]
		slab->free_list = p;
 10176ac:	6141      	str	r1, [r0, #20]
		p += slab->block_size;
 10176ae:	4411      	add	r1, r2
	for (j = 0U; j < slab->num_blocks; j++) {
 10176b0:	e7f3      	b.n	101769a <k_mem_slab_init+0x18>
		return -EINVAL;
 10176b2:	f06f 0015 	mvn.w	r0, #21
	return rc;
 10176b6:	e7f5      	b.n	10176a4 <k_mem_slab_init+0x22>

010176b8 <k_mem_pool_malloc>:
{
 10176b8:	b5df      	push	{r0, r1, r2, r3, r4, r6, r7, lr}
	return __builtin_add_overflow(a, b, result);
}

static inline bool size_add_overflow(size_t a, size_t b, size_t *result)
{
	return __builtin_add_overflow(a, b, result);
 10176ba:	2408      	movs	r4, #8
 10176bc:	190a      	adds	r2, r1, r4
 10176be:	d208      	bcs.n	10176d2 <k_mem_pool_malloc+0x1a>
	if (k_mem_pool_alloc(pool, &block, size, K_NO_WAIT) != 0) {
 10176c0:	2600      	movs	r6, #0
 10176c2:	2700      	movs	r7, #0
 10176c4:	eb0d 0104 	add.w	r1, sp, r4
 10176c8:	e9cd 6700 	strd	r6, r7, [sp]
 10176cc:	f7ff ffbc 	bl	1017648 <k_mem_pool_alloc>
 10176d0:	b110      	cbz	r0, 10176d8 <k_mem_pool_malloc+0x20>
		return NULL;
 10176d2:	2000      	movs	r0, #0
}
 10176d4:	b004      	add	sp, #16
 10176d6:	bdd0      	pop	{r4, r6, r7, pc}
	(void)memcpy(block.data, &block.id, sizeof(struct k_mem_block_id));
 10176d8:	4622      	mov	r2, r4
 10176da:	9802      	ldr	r0, [sp, #8]
 10176dc:	a902      	add	r1, sp, #8
 10176de:	f7ff f8eb 	bl	10168b8 <memcpy>
	return (char *)block.data + WB_UP(sizeof(struct k_mem_block_id));
 10176e2:	9802      	ldr	r0, [sp, #8]
 10176e4:	3008      	adds	r0, #8
 10176e6:	e7f5      	b.n	10176d4 <k_mem_pool_malloc+0x1c>

010176e8 <k_free>:
	if (ptr != NULL) {
 10176e8:	b110      	cbz	r0, 10176f0 <k_free+0x8>
		k_mem_pool_free_id(ptr);
 10176ea:	3808      	subs	r0, #8
 10176ec:	f7ff bfc5 	b.w	101767a <k_mem_pool_free_id>
}
 10176f0:	4770      	bx	lr

010176f2 <queue_insert>:
{
 10176f2:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 10176f6:	4604      	mov	r4, r0
 10176f8:	460d      	mov	r5, r1
 10176fa:	4690      	mov	r8, r2
 10176fc:	4699      	mov	r9, r3
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
 10176fe:	f100 0608 	add.w	r6, r0, #8
	__asm__ volatile(
 1017702:	f04f 0320 	mov.w	r3, #32
 1017706:	f3ef 8711 	mrs	r7, BASEPRI
 101770a:	f383 8811 	msr	BASEPRI, r3
 101770e:	f3bf 8f6f 	isb	sy
	first_pending_thread = z_unpend_first_thread(&queue->wait_q);
 1017712:	4630      	mov	r0, r6
 1017714:	f000 f99b 	bl	1017a4e <z_unpend_first_thread>
	if (first_pending_thread != NULL) {
 1017718:	b158      	cbz	r0, 1017732 <queue_insert+0x40>
 101771a:	2400      	movs	r4, #0
 101771c:	f8c0 8014 	str.w	r8, [r0, #20]
 1017720:	6704      	str	r4, [r0, #112]	; 0x70
	z_ready_thread(thread);
 1017722:	f000 f91e 	bl	1017962 <z_ready_thread>
	z_reschedule(&queue->lock, key);
 1017726:	4630      	mov	r0, r6
 1017728:	4639      	mov	r1, r7
 101772a:	f000 f8d2 	bl	10178d2 <z_reschedule>
	return 0;
 101772e:	2000      	movs	r0, #0
 1017730:	e00c      	b.n	101774c <queue_insert+0x5a>
	if (alloc) {
 1017732:	f1b9 0f00 	cmp.w	r9, #0
 1017736:	d01b      	beq.n	1017770 <queue_insert+0x7e>
		anode = z_thread_malloc(sizeof(*anode));
 1017738:	2008      	movs	r0, #8
 101773a:	f7fc fc2f 	bl	1013f9c <z_thread_malloc>
		if (anode == NULL) {
 101773e:	b938      	cbnz	r0, 1017750 <queue_insert+0x5e>
	__asm__ volatile(
 1017740:	f387 8811 	msr	BASEPRI, r7
 1017744:	f3bf 8f6f 	isb	sy
			return -ENOMEM;
 1017748:	f06f 000b 	mvn.w	r0, #11
}
 101774c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	node->next_and_flags = flags;
 1017750:	2301      	movs	r3, #1
		anode->data = data;
 1017752:	f8c0 8004 	str.w	r8, [r0, #4]
 1017756:	6003      	str	r3, [r0, #0]
Z_GENLIST_INSERT(sflist, sfnode)
 1017758:	6803      	ldr	r3, [r0, #0]
 101775a:	f003 0203 	and.w	r2, r3, #3
 101775e:	b95d      	cbnz	r5, 1017778 <queue_insert+0x86>
	parent->next_and_flags = cur_flags | (unative_t)child;
 1017760:	6823      	ldr	r3, [r4, #0]
 1017762:	4313      	orrs	r3, r2
 1017764:	6003      	str	r3, [r0, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
 1017766:	6863      	ldr	r3, [r4, #4]
	list->head = node;
 1017768:	6020      	str	r0, [r4, #0]
Z_GENLIST_PREPEND(sflist, sfnode)
 101776a:	b973      	cbnz	r3, 101778a <queue_insert+0x98>
	list->tail = node;
 101776c:	6060      	str	r0, [r4, #4]
}
 101776e:	e00c      	b.n	101778a <queue_insert+0x98>
}
 1017770:	4640      	mov	r0, r8
	node->next_and_flags = flags;
 1017772:	f8c8 9000 	str.w	r9, [r8]
}
 1017776:	e7ef      	b.n	1017758 <queue_insert+0x66>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
 1017778:	682b      	ldr	r3, [r5, #0]
Z_GENLIST_INSERT(sflist, sfnode)
 101777a:	f033 0303 	bics.w	r3, r3, #3
 101777e:	d110      	bne.n	10177a2 <queue_insert+0xb0>
	parent->next_and_flags = cur_flags | (unative_t)child;
 1017780:	6002      	str	r2, [r0, #0]
Z_GENLIST_APPEND(sflist, sfnode)
 1017782:	6862      	ldr	r2, [r4, #4]
 1017784:	b93a      	cbnz	r2, 1017796 <queue_insert+0xa4>
	list->head = node;
 1017786:	e9c4 0000 	strd	r0, r0, [r4]
	z_handle_obj_poll_events(&queue->poll_events, state);
 101778a:	2104      	movs	r1, #4
 101778c:	f104 0010 	add.w	r0, r4, #16
 1017790:	f000 fbc7 	bl	1017f22 <z_handle_obj_poll_events>
 1017794:	e7c7      	b.n	1017726 <queue_insert+0x34>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
 1017796:	6813      	ldr	r3, [r2, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
 1017798:	f003 0303 	and.w	r3, r3, #3
 101779c:	4303      	orrs	r3, r0
 101779e:	6013      	str	r3, [r2, #0]
 10177a0:	e7e4      	b.n	101776c <queue_insert+0x7a>
 10177a2:	4313      	orrs	r3, r2
 10177a4:	6003      	str	r3, [r0, #0]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
 10177a6:	682b      	ldr	r3, [r5, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
 10177a8:	f003 0303 	and.w	r3, r3, #3
 10177ac:	4303      	orrs	r3, r0
 10177ae:	602b      	str	r3, [r5, #0]
}
 10177b0:	e7eb      	b.n	101778a <queue_insert+0x98>

010177b2 <z_queue_node_peek>:
{
 10177b2:	b510      	push	{r4, lr}
	if ((node != NULL) && (sys_sfnode_flags_get(node) != (u8_t)0)) {
 10177b4:	4604      	mov	r4, r0
 10177b6:	b130      	cbz	r0, 10177c6 <z_queue_node_peek+0x14>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
 10177b8:	6802      	ldr	r2, [r0, #0]
 10177ba:	0793      	lsls	r3, r2, #30
 10177bc:	d003      	beq.n	10177c6 <z_queue_node_peek+0x14>
		ret = anode->data;
 10177be:	6844      	ldr	r4, [r0, #4]
		if (needs_free) {
 10177c0:	b109      	cbz	r1, 10177c6 <z_queue_node_peek+0x14>
			k_free(anode);
 10177c2:	f7ff ff91 	bl	10176e8 <k_free>
}
 10177c6:	4620      	mov	r0, r4
 10177c8:	bd10      	pop	{r4, pc}

010177ca <z_impl_k_queue_init>:
	list->head = NULL;
 10177ca:	2300      	movs	r3, #0
	list->tail = NULL;
 10177cc:	e9c0 3300 	strd	r3, r3, [r0]
	sys_dlist_init(&w->waitq);
 10177d0:	f100 0308 	add.w	r3, r0, #8
 10177d4:	e9c0 3302 	strd	r3, r3, [r0, #8]
	sys_dlist_init(&queue->poll_events);
 10177d8:	f100 0310 	add.w	r3, r0, #16
 10177dc:	e9c0 3304 	strd	r3, r3, [r0, #16]
}
 10177e0:	4770      	bx	lr

010177e2 <k_queue_append>:
{
 10177e2:	460a      	mov	r2, r1
	(void)queue_insert(queue, sys_sflist_peek_tail(&queue->data_q),
 10177e4:	2300      	movs	r3, #0
 10177e6:	6841      	ldr	r1, [r0, #4]
 10177e8:	f7ff bf83 	b.w	10176f2 <queue_insert>

010177ec <k_queue_prepend>:
	(void)queue_insert(queue, NULL, data, false);
 10177ec:	2300      	movs	r3, #0
{
 10177ee:	460a      	mov	r2, r1
	(void)queue_insert(queue, NULL, data, false);
 10177f0:	4619      	mov	r1, r3
 10177f2:	f7ff bf7e 	b.w	10176f2 <queue_insert>

010177f6 <k_queue_append_list>:
{
 10177f6:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 10177fa:	4605      	mov	r5, r0
 10177fc:	4616      	mov	r6, r2
	CHECKIF(head == NULL || tail == NULL) {
 10177fe:	460c      	mov	r4, r1
 1017800:	b391      	cbz	r1, 1017868 <k_queue_append_list+0x72>
 1017802:	b38a      	cbz	r2, 1017868 <k_queue_append_list+0x72>
	k_spinlock_key_t key = k_spin_lock(&queue->lock);
 1017804:	f100 0708 	add.w	r7, r0, #8
	__asm__ volatile(
 1017808:	f04f 0320 	mov.w	r3, #32
 101780c:	f3ef 8811 	mrs	r8, BASEPRI
 1017810:	f383 8811 	msr	BASEPRI, r3
 1017814:	f3bf 8f6f 	isb	sy
		thread = z_unpend_first_thread(&queue->wait_q);
 1017818:	4638      	mov	r0, r7
 101781a:	f000 f918 	bl	1017a4e <z_unpend_first_thread>
 101781e:	f04f 0900 	mov.w	r9, #0
	while ((head != NULL) && (thread != NULL)) {
 1017822:	b920      	cbnz	r0, 101782e <k_queue_append_list+0x38>
Z_GENLIST_APPEND_LIST(sflist, sfnode)
 1017824:	686b      	ldr	r3, [r5, #4]
 1017826:	b9cb      	cbnz	r3, 101785c <k_queue_append_list+0x66>
	list->head = node;
 1017828:	602c      	str	r4, [r5, #0]
	list->tail = node;
 101782a:	606e      	str	r6, [r5, #4]
Z_GENLIST_APPEND_LIST(sflist, sfnode)
 101782c:	e00a      	b.n	1017844 <k_queue_append_list+0x4e>
 101782e:	6144      	str	r4, [r0, #20]
 1017830:	f8c0 9070 	str.w	r9, [r0, #112]	; 0x70
	z_ready_thread(thread);
 1017834:	f000 f895 	bl	1017962 <z_ready_thread>
		head = *(void **)head;
 1017838:	6824      	ldr	r4, [r4, #0]
		thread = z_unpend_first_thread(&queue->wait_q);
 101783a:	4638      	mov	r0, r7
 101783c:	f000 f907 	bl	1017a4e <z_unpend_first_thread>
	while ((head != NULL) && (thread != NULL)) {
 1017840:	2c00      	cmp	r4, #0
 1017842:	d1ee      	bne.n	1017822 <k_queue_append_list+0x2c>
	z_handle_obj_poll_events(&queue->poll_events, state);
 1017844:	2104      	movs	r1, #4
 1017846:	f105 0010 	add.w	r0, r5, #16
 101784a:	f000 fb6a 	bl	1017f22 <z_handle_obj_poll_events>
	z_reschedule(&queue->lock, key);
 101784e:	4638      	mov	r0, r7
 1017850:	4641      	mov	r1, r8
 1017852:	f000 f83e 	bl	10178d2 <z_reschedule>
	return 0;
 1017856:	2000      	movs	r0, #0
}
 1017858:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
 101785c:	6819      	ldr	r1, [r3, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
 101785e:	f001 0103 	and.w	r1, r1, #3
 1017862:	430c      	orrs	r4, r1
 1017864:	601c      	str	r4, [r3, #0]
}
 1017866:	e7e0      	b.n	101782a <k_queue_append_list+0x34>
		return -EINVAL;
 1017868:	f06f 0015 	mvn.w	r0, #21
 101786c:	e7f4      	b.n	1017858 <k_queue_append_list+0x62>

0101786e <z_is_t1_higher_prio_than_t2>:
	if (thread_1->base.prio < thread_2->base.prio) {
 101786e:	f990 000e 	ldrsb.w	r0, [r0, #14]
 1017872:	f991 300e 	ldrsb.w	r3, [r1, #14]
}
 1017876:	4298      	cmp	r0, r3
 1017878:	bfac      	ite	ge
 101787a:	2000      	movge	r0, #0
 101787c:	2001      	movlt	r0, #1
 101787e:	4770      	bx	lr

01017880 <z_find_first_thread_to_unpend>:
{
 1017880:	b510      	push	{r4, lr}
 1017882:	f04f 0320 	mov.w	r3, #32
 1017886:	f3ef 8411 	mrs	r4, BASEPRI
 101788a:	f383 8811 	msr	BASEPRI, r3
 101788e:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
 1017892:	f000 f85c 	bl	101794e <z_priq_dumb_best>
	__asm__ volatile(
 1017896:	f384 8811 	msr	BASEPRI, r4
 101789a:	f3bf 8f6f 	isb	sy
}
 101789e:	bd10      	pop	{r4, pc}

010178a0 <z_unpend_thread_no_timeout>:
{
 10178a0:	b538      	push	{r3, r4, r5, lr}
 10178a2:	4604      	mov	r4, r0
	__asm__ volatile(
 10178a4:	f04f 0320 	mov.w	r3, #32
 10178a8:	f3ef 8511 	mrs	r5, BASEPRI
 10178ac:	f383 8811 	msr	BASEPRI, r3
 10178b0:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
 10178b4:	4601      	mov	r1, r0
 10178b6:	6880      	ldr	r0, [r0, #8]
 10178b8:	f7fc fc10 	bl	10140dc <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
 10178bc:	7b63      	ldrb	r3, [r4, #13]
 10178be:	f023 0302 	bic.w	r3, r3, #2
 10178c2:	7363      	strb	r3, [r4, #13]
		thread->base.pended_on = NULL;
 10178c4:	2300      	movs	r3, #0
 10178c6:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
 10178c8:	f385 8811 	msr	BASEPRI, r5
 10178cc:	f3bf 8f6f 	isb	sy
}
 10178d0:	bd38      	pop	{r3, r4, r5, pc}

010178d2 <z_reschedule>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
 10178d2:	b921      	cbnz	r1, 10178de <z_reschedule+0xc>
  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 10178d4:	f3ef 8005 	mrs	r0, IPSR
 10178d8:	b908      	cbnz	r0, 10178de <z_reschedule+0xc>
 10178da:	f7ed b9cd 	b.w	1004c78 <arch_swap>
 10178de:	f381 8811 	msr	BASEPRI, r1
 10178e2:	f3bf 8f6f 	isb	sy
}
 10178e6:	4770      	bx	lr

010178e8 <z_reschedule_irqlock>:
	return arch_irq_unlocked(key) && !arch_is_in_isr();
 10178e8:	4603      	mov	r3, r0
 10178ea:	b920      	cbnz	r0, 10178f6 <z_reschedule_irqlock+0xe>
 10178ec:	f3ef 8205 	mrs	r2, IPSR
 10178f0:	b90a      	cbnz	r2, 10178f6 <z_reschedule_irqlock+0xe>
 10178f2:	f7ed b9c1 	b.w	1004c78 <arch_swap>
 10178f6:	f383 8811 	msr	BASEPRI, r3
 10178fa:	f3bf 8f6f 	isb	sy
}
 10178fe:	4770      	bx	lr

01017900 <z_reschedule_unlocked>:
	__asm__ volatile(
 1017900:	f04f 0320 	mov.w	r3, #32
 1017904:	f3ef 8011 	mrs	r0, BASEPRI
 1017908:	f383 8811 	msr	BASEPRI, r3
 101790c:	f3bf 8f6f 	isb	sy
	(void) z_reschedule_irqlock(arch_irq_lock());
 1017910:	f7ff bfea 	b.w	10178e8 <z_reschedule_irqlock>

01017914 <z_unpend_thread>:
{
 1017914:	b510      	push	{r4, lr}
 1017916:	4601      	mov	r1, r0
 1017918:	f04f 0320 	mov.w	r3, #32
 101791c:	f3ef 8411 	mrs	r4, BASEPRI
 1017920:	f383 8811 	msr	BASEPRI, r3
 1017924:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
 1017928:	6880      	ldr	r0, [r0, #8]
 101792a:	f7fc fbd7 	bl	10140dc <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
 101792e:	7b4b      	ldrb	r3, [r1, #13]
 1017930:	f023 0302 	bic.w	r3, r3, #2
 1017934:	734b      	strb	r3, [r1, #13]
		thread->base.pended_on = NULL;
 1017936:	2300      	movs	r3, #0
 1017938:	608b      	str	r3, [r1, #8]
	__asm__ volatile(
 101793a:	f384 8811 	msr	BASEPRI, r4
 101793e:	f3bf 8f6f 	isb	sy
	return z_abort_timeout(&thread->base.timeout);
 1017942:	f101 0018 	add.w	r0, r1, #24
}
 1017946:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 101794a:	f000 b953 	b.w	1017bf4 <z_abort_timeout>

0101794e <z_priq_dumb_best>:
{
 101794e:	4603      	mov	r3, r0
	return list->head == list;
 1017950:	6800      	ldr	r0, [r0, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1017952:	4283      	cmp	r3, r0
 1017954:	d003      	beq.n	101795e <z_priq_dumb_best+0x10>
	if (n != NULL) {
 1017956:	2800      	cmp	r0, #0
 1017958:	bf38      	it	cc
 101795a:	2000      	movcc	r0, #0
 101795c:	4770      	bx	lr
	struct k_thread *thread = NULL;
 101795e:	2000      	movs	r0, #0
}
 1017960:	4770      	bx	lr

01017962 <z_ready_thread>:
{
 1017962:	b510      	push	{r4, lr}
	__asm__ volatile(
 1017964:	f04f 0320 	mov.w	r3, #32
 1017968:	f3ef 8411 	mrs	r4, BASEPRI
 101796c:	f383 8811 	msr	BASEPRI, r3
 1017970:	f3bf 8f6f 	isb	sy
		ready_thread(thread);
 1017974:	f7fc fc08 	bl	1014188 <ready_thread>
	__asm__ volatile(
 1017978:	f384 8811 	msr	BASEPRI, r4
 101797c:	f3bf 8f6f 	isb	sy
}
 1017980:	bd10      	pop	{r4, pc}

01017982 <z_thread_timeout>:
{
 1017982:	b538      	push	{r3, r4, r5, lr}
	if (thread->base.pended_on != NULL) {
 1017984:	f850 3c10 	ldr.w	r3, [r0, #-16]
{
 1017988:	4604      	mov	r4, r0
	struct k_thread *thread = CONTAINER_OF(timeout,
 101798a:	f1a0 0118 	sub.w	r1, r0, #24
	if (thread->base.pended_on != NULL) {
 101798e:	b1c3      	cbz	r3, 10179c2 <z_thread_timeout+0x40>
	__asm__ volatile(
 1017990:	f04f 0320 	mov.w	r3, #32
 1017994:	f3ef 8511 	mrs	r5, BASEPRI
 1017998:	f383 8811 	msr	BASEPRI, r3
 101799c:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
 10179a0:	f850 0c10 	ldr.w	r0, [r0, #-16]
 10179a4:	f7fc fb9a 	bl	10140dc <z_priq_dumb_remove>
 10179a8:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
 10179ac:	f023 0302 	bic.w	r3, r3, #2
 10179b0:	f804 3c0b 	strb.w	r3, [r4, #-11]
		thread->base.pended_on = NULL;
 10179b4:	2300      	movs	r3, #0
 10179b6:	f844 3c10 	str.w	r3, [r4, #-16]
	__asm__ volatile(
 10179ba:	f385 8811 	msr	BASEPRI, r5
 10179be:	f3bf 8f6f 	isb	sy
	thread->base.thread_state &= ~_THREAD_SUSPENDED;
 10179c2:	f814 3c0b 	ldrb.w	r3, [r4, #-11]
	z_ready_thread(thread);
 10179c6:	4608      	mov	r0, r1
 10179c8:	f023 0314 	bic.w	r3, r3, #20
 10179cc:	f804 3c0b 	strb.w	r3, [r4, #-11]
}
 10179d0:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
	z_ready_thread(thread);
 10179d4:	f7ff bfc5 	b.w	1017962 <z_ready_thread>

010179d8 <z_remove_thread_from_ready_q>:
{
 10179d8:	b510      	push	{r4, lr}
	__asm__ volatile(
 10179da:	f04f 0320 	mov.w	r3, #32
 10179de:	f3ef 8411 	mrs	r4, BASEPRI
 10179e2:	f383 8811 	msr	BASEPRI, r3
 10179e6:	f3bf 8f6f 	isb	sy
		unready_thread(thread);
 10179ea:	f7fc fd2b 	bl	1014444 <unready_thread>
	__asm__ volatile(
 10179ee:	f384 8811 	msr	BASEPRI, r4
 10179f2:	f3bf 8f6f 	isb	sy
}
 10179f6:	bd10      	pop	{r4, pc}

010179f8 <add_to_waitq_locked>:
{
 10179f8:	b538      	push	{r3, r4, r5, lr}
 10179fa:	4604      	mov	r4, r0
 10179fc:	460d      	mov	r5, r1
	unready_thread(thread);
 10179fe:	f7fc fd21 	bl	1014444 <unready_thread>
	thread->base.thread_state |= _THREAD_PENDING;
 1017a02:	7b63      	ldrb	r3, [r4, #13]
 1017a04:	f043 0302 	orr.w	r3, r3, #2
 1017a08:	7363      	strb	r3, [r4, #13]
	if (wait_q != NULL) {
 1017a0a:	b1c5      	cbz	r5, 1017a3e <add_to_waitq_locked+0x46>
	return list->head == list;
 1017a0c:	682b      	ldr	r3, [r5, #0]
		thread->base.pended_on = wait_q;
 1017a0e:	60a5      	str	r5, [r4, #8]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1017a10:	429d      	cmp	r5, r3
 1017a12:	bf08      	it	eq
 1017a14:	2300      	moveq	r3, #0
 1017a16:	2b00      	cmp	r3, #0
 1017a18:	bf38      	it	cc
 1017a1a:	2300      	movcc	r3, #0
	SYS_DLIST_FOR_EACH_CONTAINER(pq, t, base.qnode_dlist) {
 1017a1c:	b183      	cbz	r3, 1017a40 <add_to_waitq_locked+0x48>
	if (thread_1->base.prio < thread_2->base.prio) {
 1017a1e:	f994 100e 	ldrsb.w	r1, [r4, #14]
 1017a22:	f993 200e 	ldrsb.w	r2, [r3, #14]
 1017a26:	4291      	cmp	r1, r2
 1017a28:	db04      	blt.n	1017a34 <add_to_waitq_locked+0x3c>
	return (node == list->tail) ? NULL : node->next;
 1017a2a:	686a      	ldr	r2, [r5, #4]
 1017a2c:	429a      	cmp	r2, r3
 1017a2e:	d007      	beq.n	1017a40 <add_to_waitq_locked+0x48>
 1017a30:	681b      	ldr	r3, [r3, #0]
 1017a32:	e7f3      	b.n	1017a1c <add_to_waitq_locked+0x24>
	node->prev = successor->prev;
 1017a34:	685a      	ldr	r2, [r3, #4]
	node->next = successor;
 1017a36:	e9c4 3200 	strd	r3, r2, [r4]
	successor->prev->next = node;
 1017a3a:	6014      	str	r4, [r2, #0]
	successor->prev = node;
 1017a3c:	605c      	str	r4, [r3, #4]
}
 1017a3e:	bd38      	pop	{r3, r4, r5, pc}
	node->prev = list->tail;
 1017a40:	686b      	ldr	r3, [r5, #4]
	node->next = list;
 1017a42:	6025      	str	r5, [r4, #0]
	node->prev = list->tail;
 1017a44:	6063      	str	r3, [r4, #4]
	list->tail->next = node;
 1017a46:	686b      	ldr	r3, [r5, #4]
 1017a48:	601c      	str	r4, [r3, #0]
	list->tail = node;
 1017a4a:	606c      	str	r4, [r5, #4]
 1017a4c:	e7f7      	b.n	1017a3e <add_to_waitq_locked+0x46>

01017a4e <z_unpend_first_thread>:
{
 1017a4e:	b538      	push	{r3, r4, r5, lr}
	__asm__ volatile(
 1017a50:	f04f 0320 	mov.w	r3, #32
 1017a54:	f3ef 8211 	mrs	r2, BASEPRI
 1017a58:	f383 8811 	msr	BASEPRI, r3
 1017a5c:	f3bf 8f6f 	isb	sy
		ret = _priq_wait_best(&wait_q->waitq);
 1017a60:	f7ff ff75 	bl	101794e <z_priq_dumb_best>
 1017a64:	4604      	mov	r4, r0
	__asm__ volatile(
 1017a66:	f382 8811 	msr	BASEPRI, r2
 1017a6a:	f3bf 8f6f 	isb	sy

static inline struct k_thread *z_unpend1_no_timeout(_wait_q_t *wait_q)
{
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);

	if (thread != NULL) {
 1017a6e:	b1c8      	cbz	r0, 1017aa4 <z_unpend_first_thread+0x56>
	__asm__ volatile(
 1017a70:	f04f 0320 	mov.w	r3, #32
 1017a74:	f3ef 8511 	mrs	r5, BASEPRI
 1017a78:	f383 8811 	msr	BASEPRI, r3
 1017a7c:	f3bf 8f6f 	isb	sy
		_priq_wait_remove(&pended_on(thread)->waitq, thread);
 1017a80:	4601      	mov	r1, r0
 1017a82:	6880      	ldr	r0, [r0, #8]
 1017a84:	f7fc fb2a 	bl	10140dc <z_priq_dumb_remove>
	thread->base.thread_state &= ~_THREAD_PENDING;
 1017a88:	7b63      	ldrb	r3, [r4, #13]
 1017a8a:	f023 0302 	bic.w	r3, r3, #2
 1017a8e:	7363      	strb	r3, [r4, #13]
		thread->base.pended_on = NULL;
 1017a90:	2300      	movs	r3, #0
 1017a92:	60a3      	str	r3, [r4, #8]
	__asm__ volatile(
 1017a94:	f385 8811 	msr	BASEPRI, r5
 1017a98:	f3bf 8f6f 	isb	sy
 1017a9c:	f104 0018 	add.w	r0, r4, #24
 1017aa0:	f000 f8a8 	bl	1017bf4 <z_abort_timeout>
}
 1017aa4:	4620      	mov	r0, r4
 1017aa6:	bd38      	pop	{r3, r4, r5, pc}

01017aa8 <z_unpend_all>:
{
 1017aa8:	b538      	push	{r3, r4, r5, lr}
 1017aaa:	4605      	mov	r5, r0
	int need_sched = 0;
 1017aac:	2000      	movs	r0, #0
	return list->head == list;
 1017aae:	682c      	ldr	r4, [r5, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1017ab0:	42a5      	cmp	r5, r4
 1017ab2:	d000      	beq.n	1017ab6 <z_unpend_all+0xe>
	while ((thread = z_waitq_head(wait_q)) != NULL) {
 1017ab4:	b904      	cbnz	r4, 1017ab8 <z_unpend_all+0x10>
}
 1017ab6:	bd38      	pop	{r3, r4, r5, pc}
		z_unpend_thread(thread);
 1017ab8:	4620      	mov	r0, r4
 1017aba:	f7ff ff2b 	bl	1017914 <z_unpend_thread>
		z_ready_thread(thread);
 1017abe:	4620      	mov	r0, r4
 1017ac0:	f7ff ff4f 	bl	1017962 <z_ready_thread>
		need_sched = 1;
 1017ac4:	2001      	movs	r0, #1
 1017ac6:	e7f2      	b.n	1017aae <z_unpend_all+0x6>

01017ac8 <z_impl_k_sem_init>:
	CHECKIF(limit == 0U || initial_count > limit) {
 1017ac8:	b15a      	cbz	r2, 1017ae2 <z_impl_k_sem_init+0x1a>
 1017aca:	428a      	cmp	r2, r1
 1017acc:	d309      	bcc.n	1017ae2 <z_impl_k_sem_init+0x1a>
	sys_dlist_init(&sem->poll_events);
 1017ace:	f100 0310 	add.w	r3, r0, #16
	sem->limit = limit;
 1017ad2:	e9c0 1202 	strd	r1, r2, [r0, #8]
	list->tail = (sys_dnode_t *)list;
 1017ad6:	e9c0 0000 	strd	r0, r0, [r0]
 1017ada:	e9c0 3304 	strd	r3, r3, [r0, #16]
	return 0;
 1017ade:	2000      	movs	r0, #0
 1017ae0:	4770      	bx	lr
		return -EINVAL;
 1017ae2:	f06f 0015 	mvn.w	r0, #21
}
 1017ae6:	4770      	bx	lr

01017ae8 <k_is_in_isr>:
 1017ae8:	f3ef 8005 	mrs	r0, IPSR
}
 1017aec:	3800      	subs	r0, #0
 1017aee:	bf18      	it	ne
 1017af0:	2001      	movne	r0, #1
 1017af2:	4770      	bx	lr

01017af4 <z_impl_k_busy_wait>:
	arch_busy_wait(usec_to_wait);
 1017af4:	f7ec b8e6 	b.w	1003cc4 <arch_busy_wait>

01017af8 <z_impl_k_thread_name_set>:
}
 1017af8:	f06f 0046 	mvn.w	r0, #70	; 0x46
 1017afc:	4770      	bx	lr

01017afe <k_thread_name_get>:
}
 1017afe:	2000      	movs	r0, #0
 1017b00:	4770      	bx	lr

01017b02 <k_work_submit_to_queue>:
{
 1017b02:	b500      	push	{lr}
	return __atomic_fetch_or(target, value, __ATOMIC_SEQ_CST);
 1017b04:	f101 0308 	add.w	r3, r1, #8
 1017b08:	e8d3 2fef 	ldaex	r2, [r3]
 1017b0c:	f042 0c01 	orr.w	ip, r2, #1
 1017b10:	e8c3 cfee 	stlex	lr, ip, [r3]
 1017b14:	f1be 0f00 	cmp.w	lr, #0
 1017b18:	d1f6      	bne.n	1017b08 <k_work_submit_to_queue+0x6>
	if (!atomic_test_and_set_bit(work->flags, K_WORK_STATE_PENDING)) {
 1017b1a:	07d3      	lsls	r3, r2, #31
 1017b1c:	d403      	bmi.n	1017b26 <k_work_submit_to_queue+0x24>
}
 1017b1e:	f85d eb04 	ldr.w	lr, [sp], #4
		k_queue_append(&work_q->queue, work);
 1017b22:	f7ff be5e 	b.w	10177e2 <k_queue_append>
}
 1017b26:	f85d fb04 	ldr.w	pc, [sp], #4

01017b2a <work_timeout>:
	k_work_submit_to_queue(w->work_q, &w->work);
 1017b2a:	f1a0 010c 	sub.w	r1, r0, #12
 1017b2e:	6900      	ldr	r0, [r0, #16]
 1017b30:	f7ff bfe7 	b.w	1017b02 <k_work_submit_to_queue>

01017b34 <work_cancel>:
	CHECKIF(work->work_q == NULL) {
 1017b34:	69c3      	ldr	r3, [r0, #28]
{
 1017b36:	b570      	push	{r4, r5, r6, lr}
 1017b38:	4604      	mov	r4, r0
	CHECKIF(work->work_q == NULL) {
 1017b3a:	b913      	cbnz	r3, 1017b42 <work_cancel+0xe>
		return -EALREADY;
 1017b3c:	f06f 0044 	mvn.w	r0, #68	; 0x44
}
 1017b40:	bd70      	pop	{r4, r5, r6, pc}
	return atomic_test_bit(work->flags, K_WORK_STATE_PENDING);
 1017b42:	f100 0508 	add.w	r5, r0, #8
	return __atomic_load_n(target, __ATOMIC_SEQ_CST);
 1017b46:	e8d5 3faf 	lda	r3, [r5]
	if (k_work_pending(&work->work)) {
 1017b4a:	07db      	lsls	r3, r3, #31
 1017b4c:	d52f      	bpl.n	1017bae <work_cancel+0x7a>
 * @return true if node was removed
 */
static inline bool sys_sflist_find_and_remove(sys_sflist_t *list,
					      sys_sfnode_t *node);

Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
 1017b4e:	2100      	movs	r1, #0
		if (!k_queue_remove(&work->work_q->queue, &work->work)) {
 1017b50:	69c2      	ldr	r2, [r0, #28]
 1017b52:	6813      	ldr	r3, [r2, #0]
 1017b54:	b913      	cbnz	r3, 1017b5c <work_cancel+0x28>
			return -EINVAL;
 1017b56:	f06f 0015 	mvn.w	r0, #21
 1017b5a:	e7f1      	b.n	1017b40 <work_cancel+0xc>
 1017b5c:	429c      	cmp	r4, r3
 1017b5e:	d121      	bne.n	1017ba4 <work_cancel+0x70>
Z_GENLIST_REMOVE(sflist, sfnode)
 1017b60:	6823      	ldr	r3, [r4, #0]
 1017b62:	6856      	ldr	r6, [r2, #4]
 1017b64:	f023 0003 	bic.w	r0, r3, #3
 1017b68:	b991      	cbnz	r1, 1017b90 <work_cancel+0x5c>
 1017b6a:	42b4      	cmp	r4, r6
	list->head = node;
 1017b6c:	6010      	str	r0, [r2, #0]
Z_GENLIST_REMOVE(sflist, sfnode)
 1017b6e:	d100      	bne.n	1017b72 <work_cancel+0x3e>
	list->tail = node;
 1017b70:	6050      	str	r0, [r2, #4]
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
 1017b72:	6823      	ldr	r3, [r4, #0]
	parent->next_and_flags = cur_flags | (unative_t)child;
 1017b74:	f003 0303 	and.w	r3, r3, #3
 1017b78:	6023      	str	r3, [r4, #0]
	work->work_q = NULL;
 1017b7a:	2000      	movs	r0, #0
 1017b7c:	61e0      	str	r0, [r4, #28]
	return __atomic_fetch_and(target, value, __ATOMIC_SEQ_CST);
 1017b7e:	e8d5 3fef 	ldaex	r3, [r5]
 1017b82:	f023 0301 	bic.w	r3, r3, #1
 1017b86:	e8c5 3fe2 	stlex	r2, r3, [r5]
 1017b8a:	2a00      	cmp	r2, #0
 1017b8c:	d0d8      	beq.n	1017b40 <work_cancel+0xc>
 1017b8e:	e7f6      	b.n	1017b7e <work_cancel+0x4a>
	return node->next_and_flags & SYS_SFLIST_FLAGS_MASK;
 1017b90:	680b      	ldr	r3, [r1, #0]
Z_GENLIST_REMOVE(sflist, sfnode)
 1017b92:	42b4      	cmp	r4, r6
	parent->next_and_flags = cur_flags | (unative_t)child;
 1017b94:	f003 0303 	and.w	r3, r3, #3
 1017b98:	ea43 0300 	orr.w	r3, r3, r0
 1017b9c:	600b      	str	r3, [r1, #0]
	list->tail = node;
 1017b9e:	bf08      	it	eq
 1017ba0:	6051      	streq	r1, [r2, #4]
}
 1017ba2:	e7e6      	b.n	1017b72 <work_cancel+0x3e>
	return (sys_sfnode_t *)(node->next_and_flags & ~SYS_SFLIST_FLAGS_MASK);
 1017ba4:	6818      	ldr	r0, [r3, #0]
 1017ba6:	4619      	mov	r1, r3
Z_GENLIST_FIND_AND_REMOVE(sflist, sfnode)
 1017ba8:	f020 0303 	bic.w	r3, r0, #3
 1017bac:	e7d2      	b.n	1017b54 <work_cancel+0x20>
		int err = z_abort_timeout(&work->timeout);
 1017bae:	300c      	adds	r0, #12
 1017bb0:	f000 f820 	bl	1017bf4 <z_abort_timeout>
		if (err) {
 1017bb4:	2800      	cmp	r0, #0
 1017bb6:	d0e0      	beq.n	1017b7a <work_cancel+0x46>
 1017bb8:	e7c0      	b.n	1017b3c <work_cancel+0x8>

01017bba <k_delayed_work_init>:
	*work = (struct k_work)Z_WORK_INITIALIZER(handler);
 1017bba:	2300      	movs	r3, #0
 1017bbc:	e9c0 3100 	strd	r3, r1, [r0]
	node->next = NULL;
 1017bc0:	e9c0 3302 	strd	r3, r3, [r0, #8]
	node->prev = NULL;
 1017bc4:	6103      	str	r3, [r0, #16]
	work->work_q = NULL;
 1017bc6:	61c3      	str	r3, [r0, #28]
}
 1017bc8:	4770      	bx	lr

01017bca <k_delayed_work_cancel>:

int k_delayed_work_cancel(struct k_delayed_work *work)
{
	if (!work->work_q) {
 1017bca:	69c3      	ldr	r3, [r0, #28]
{
 1017bcc:	b510      	push	{r4, lr}
	if (!work->work_q) {
 1017bce:	b173      	cbz	r3, 1017bee <k_delayed_work_cancel+0x24>
	__asm__ volatile(
 1017bd0:	f04f 0320 	mov.w	r3, #32
 1017bd4:	f3ef 8411 	mrs	r4, BASEPRI
 1017bd8:	f383 8811 	msr	BASEPRI, r3
 1017bdc:	f3bf 8f6f 	isb	sy
		return -EINVAL;
	}

	k_spinlock_key_t key = k_spin_lock(&lock);
	int ret = work_cancel(work);
 1017be0:	f7ff ffa8 	bl	1017b34 <work_cancel>
	__asm__ volatile(
 1017be4:	f384 8811 	msr	BASEPRI, r4
 1017be8:	f3bf 8f6f 	isb	sy

	k_spin_unlock(&lock, key);
	return ret;
}
 1017bec:	bd10      	pop	{r4, pc}
		return -EINVAL;
 1017bee:	f06f 0015 	mvn.w	r0, #21
 1017bf2:	e7fb      	b.n	1017bec <k_delayed_work_cancel+0x22>

01017bf4 <z_abort_timeout>:
{
 1017bf4:	b510      	push	{r4, lr}
	__asm__ volatile(
 1017bf6:	f04f 0220 	mov.w	r2, #32
 1017bfa:	f3ef 8411 	mrs	r4, BASEPRI
 1017bfe:	f382 8811 	msr	BASEPRI, r2
 1017c02:	f3bf 8f6f 	isb	sy
		if (sys_dnode_is_linked(&to->node)) {
 1017c06:	6803      	ldr	r3, [r0, #0]
 1017c08:	b13b      	cbz	r3, 1017c1a <z_abort_timeout+0x26>
			remove_timeout(to);
 1017c0a:	f7fc fea9 	bl	1014960 <remove_timeout>
			ret = 0;
 1017c0e:	2000      	movs	r0, #0
	__asm__ volatile(
 1017c10:	f384 8811 	msr	BASEPRI, r4
 1017c14:	f3bf 8f6f 	isb	sy
}
 1017c18:	bd10      	pop	{r4, pc}
	int ret = -EINVAL;
 1017c1a:	f06f 0015 	mvn.w	r0, #21
 1017c1e:	e7f7      	b.n	1017c10 <z_abort_timeout+0x1c>

01017c20 <z_get_next_timeout_expiry>:
{
 1017c20:	b510      	push	{r4, lr}
	__asm__ volatile(
 1017c22:	f04f 0320 	mov.w	r3, #32
 1017c26:	f3ef 8411 	mrs	r4, BASEPRI
 1017c2a:	f383 8811 	msr	BASEPRI, r3
 1017c2e:	f3bf 8f6f 	isb	sy
		ret = next_timeout();
 1017c32:	f7fc fea9 	bl	1014988 <next_timeout>
	__asm__ volatile(
 1017c36:	f384 8811 	msr	BASEPRI, r4
 1017c3a:	f3bf 8f6f 	isb	sy
}
 1017c3e:	bd10      	pop	{r4, pc}

01017c40 <z_set_timeout_expiry>:
{
 1017c40:	b570      	push	{r4, r5, r6, lr}
 1017c42:	4604      	mov	r4, r0
 1017c44:	460d      	mov	r5, r1
	__asm__ volatile(
 1017c46:	f04f 0320 	mov.w	r3, #32
 1017c4a:	f3ef 8611 	mrs	r6, BASEPRI
 1017c4e:	f383 8811 	msr	BASEPRI, r3
 1017c52:	f3bf 8f6f 	isb	sy
		int next = next_timeout();
 1017c56:	f7fc fe97 	bl	1014988 <next_timeout>
		if (!imminent && (sooner || IS_ENABLED(CONFIG_SMP))) {
 1017c5a:	2801      	cmp	r0, #1
 1017c5c:	dd05      	ble.n	1017c6a <z_set_timeout_expiry+0x2a>
 1017c5e:	42a0      	cmp	r0, r4
 1017c60:	dd03      	ble.n	1017c6a <z_set_timeout_expiry+0x2a>
			z_clock_set_timeout(ticks, idle);
 1017c62:	4629      	mov	r1, r5
 1017c64:	4620      	mov	r0, r4
 1017c66:	f7ec fe99 	bl	100499c <z_clock_set_timeout>
	__asm__ volatile(
 1017c6a:	f386 8811 	msr	BASEPRI, r6
 1017c6e:	f3bf 8f6f 	isb	sy
}
 1017c72:	bd70      	pop	{r4, r5, r6, pc}

01017c74 <z_tick_get_32>:

u32_t z_tick_get_32(void)
{
 1017c74:	b508      	push	{r3, lr}
#ifdef CONFIG_TICKLESS_KERNEL
	return (u32_t)z_tick_get();
 1017c76:	f7fc ff71 	bl	1014b5c <z_tick_get>
#else
	return (u32_t)curr_tick;
#endif
}
 1017c7a:	bd08      	pop	{r3, pc}

01017c7c <z_impl_k_uptime_ticks>:

s64_t z_impl_k_uptime_ticks(void)
{
	return z_tick_get();
 1017c7c:	f7fc bf6e 	b.w	1014b5c <z_tick_get>

01017c80 <z_timeout_end_calc>:
 * timeout object.  When used correctly, this should be called once,
 * synchronously with the user passing a new timeout value.  It should
 * not be used iteratively to adjust a timeout.
 */
u64_t z_timeout_end_calc(k_timeout_t timeout)
{
 1017c80:	b538      	push	{r3, r4, r5, lr}
	k_ticks_t dt;

	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 1017c82:	1c4b      	adds	r3, r1, #1
 1017c84:	bf08      	it	eq
 1017c86:	f1b0 3fff 	cmpeq.w	r0, #4294967295
{
 1017c8a:	4604      	mov	r4, r0
 1017c8c:	460d      	mov	r5, r1
	if (K_TIMEOUT_EQ(timeout, K_FOREVER)) {
 1017c8e:	d013      	beq.n	1017cb8 <z_timeout_end_calc+0x38>
		return UINT64_MAX;
	} else if (K_TIMEOUT_EQ(timeout, K_NO_WAIT)) {
 1017c90:	ea54 0105 	orrs.w	r1, r4, r5
 1017c94:	d103      	bne.n	1017c9e <z_timeout_end_calc+0x1e>
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
		return Z_TICK_ABS(dt);
	}
#endif
	return z_tick_get() + MAX(1, dt);
}
 1017c96:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
		return z_tick_get();
 1017c9a:	f7fc bf5f 	b.w	1014b5c <z_tick_get>
	if (IS_ENABLED(CONFIG_TIMEOUT_64BIT) && Z_TICK_ABS(dt) >= 0) {
 1017c9e:	f06f 0101 	mvn.w	r1, #1
 1017ca2:	1a0a      	subs	r2, r1, r0
 1017ca4:	f04f 31ff 	mov.w	r1, #4294967295
 1017ca8:	eb61 0305 	sbc.w	r3, r1, r5
 1017cac:	2a00      	cmp	r2, #0
 1017cae:	f173 0100 	sbcs.w	r1, r3, #0
 1017cb2:	db02      	blt.n	1017cba <z_timeout_end_calc+0x3a>
		return Z_TICK_ABS(dt);
 1017cb4:	4610      	mov	r0, r2
 1017cb6:	4619      	mov	r1, r3
}
 1017cb8:	bd38      	pop	{r3, r4, r5, pc}
	return z_tick_get() + MAX(1, dt);
 1017cba:	f7fc ff4f 	bl	1014b5c <z_tick_get>
 1017cbe:	2c01      	cmp	r4, #1
 1017cc0:	f175 0300 	sbcs.w	r3, r5, #0
 1017cc4:	bfbc      	itt	lt
 1017cc6:	2401      	movlt	r4, #1
 1017cc8:	2500      	movlt	r5, #0
 1017cca:	1820      	adds	r0, r4, r0
 1017ccc:	eb45 0101 	adc.w	r1, r5, r1
 1017cd0:	e7f2      	b.n	1017cb8 <z_timeout_end_calc+0x38>

01017cd2 <k_timer_init>:
	timer->status = 0U;
 1017cd2:	2300      	movs	r3, #0
	timer->stop_fn = stop_fn;
 1017cd4:	e9c0 1206 	strd	r1, r2, [r0, #24]
 1017cd8:	f100 0210 	add.w	r2, r0, #16
	list->tail = (sys_dnode_t *)list;
 1017cdc:	e9c0 2204 	strd	r2, r2, [r0, #16]
	node->prev = NULL;
 1017ce0:	e9c0 3300 	strd	r3, r3, [r0]
	timer->status = 0U;
 1017ce4:	6283      	str	r3, [r0, #40]	; 0x28
	timer->user_data = NULL;
 1017ce6:	62c3      	str	r3, [r0, #44]	; 0x2c
}
 1017ce8:	4770      	bx	lr

01017cea <z_impl_k_timer_stop>:
}
#include <syscalls/k_timer_start_mrsh.c>
#endif

void z_impl_k_timer_stop(struct k_timer *timer)
{
 1017cea:	b510      	push	{r4, lr}
 1017cec:	4604      	mov	r4, r0
	int inactive = z_abort_timeout(&timer->timeout) != 0;
 1017cee:	f7ff ff81 	bl	1017bf4 <z_abort_timeout>

	if (inactive) {
 1017cf2:	b9d8      	cbnz	r0, 1017d2c <z_impl_k_timer_stop+0x42>
		return;
	}

	if (timer->stop_fn != NULL) {
 1017cf4:	69e3      	ldr	r3, [r4, #28]
 1017cf6:	b10b      	cbz	r3, 1017cfc <z_impl_k_timer_stop+0x12>
		timer->stop_fn(timer);
 1017cf8:	4620      	mov	r0, r4
 1017cfa:	4798      	blx	r3
	struct k_thread *thread = z_find_first_thread_to_unpend(wait_q, NULL);
 1017cfc:	f104 0010 	add.w	r0, r4, #16
 1017d00:	2100      	movs	r1, #0
 1017d02:	f7ff fdbd 	bl	1017880 <z_find_first_thread_to_unpend>
	if (thread != NULL) {
 1017d06:	4604      	mov	r4, r0
 1017d08:	b180      	cbz	r0, 1017d2c <z_impl_k_timer_stop+0x42>
		z_unpend_thread_no_timeout(thread);
 1017d0a:	f7ff fdc9 	bl	10178a0 <z_unpend_thread_no_timeout>
	}

	struct k_thread *pending_thread = z_unpend1_no_timeout(&timer->wait_q);

	if (pending_thread != NULL) {
		z_ready_thread(pending_thread);
 1017d0e:	4620      	mov	r0, r4
 1017d10:	f7ff fe27 	bl	1017962 <z_ready_thread>
	__asm__ volatile(
 1017d14:	f04f 0320 	mov.w	r3, #32
 1017d18:	f3ef 8011 	mrs	r0, BASEPRI
 1017d1c:	f383 8811 	msr	BASEPRI, r3
 1017d20:	f3bf 8f6f 	isb	sy
		z_reschedule_unlocked();
	}
}
 1017d24:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
	(void) z_reschedule_irqlock(arch_irq_lock());
 1017d28:	f7ff bdde 	b.w	10178e8 <z_reschedule_irqlock>
 1017d2c:	bd10      	pop	{r4, pc}

01017d2e <clear_event_registrations>:
	while (num_events--) {
 1017d2e:	2314      	movs	r3, #20
{
 1017d30:	b530      	push	{r4, r5, lr}
	event->poller = NULL;
 1017d32:	2400      	movs	r4, #0
 1017d34:	fb03 0101 	mla	r1, r3, r1, r0
	while (num_events--) {
 1017d38:	4281      	cmp	r1, r0
 1017d3a:	d100      	bne.n	1017d3e <clear_event_registrations+0x10>
}
 1017d3c:	bd30      	pop	{r4, r5, pc}
	switch (event->type) {
 1017d3e:	f811 3c07 	ldrb.w	r3, [r1, #-7]
	event->poller = NULL;
 1017d42:	f841 4c0c 	str.w	r4, [r1, #-12]
	switch (event->type) {
 1017d46:	f003 030f 	and.w	r3, r3, #15
 1017d4a:	2b02      	cmp	r3, #2
 1017d4c:	d80a      	bhi.n	1017d64 <clear_event_registrations+0x36>
 1017d4e:	b15b      	cbz	r3, 1017d68 <clear_event_registrations+0x3a>
	if (remove && sys_dnode_is_linked(&event->_node)) {
 1017d50:	f851 3c14 	ldr.w	r3, [r1, #-20]
 1017d54:	b143      	cbz	r3, 1017d68 <clear_event_registrations+0x3a>
	node->prev->next = node->next;
 1017d56:	f851 5c10 	ldr.w	r5, [r1, #-16]
 1017d5a:	602b      	str	r3, [r5, #0]
	node->next->prev = node->prev;
 1017d5c:	605d      	str	r5, [r3, #4]
	node->prev = NULL;
 1017d5e:	e941 4405 	strd	r4, r4, [r1, #-20]
}
 1017d62:	e001      	b.n	1017d68 <clear_event_registrations+0x3a>
	switch (event->type) {
 1017d64:	2b04      	cmp	r3, #4
 1017d66:	d0f3      	beq.n	1017d50 <clear_event_registrations+0x22>
	__asm__ volatile(
 1017d68:	f382 8811 	msr	BASEPRI, r2
 1017d6c:	f3bf 8f6f 	isb	sy
	__asm__ volatile(
 1017d70:	f04f 0320 	mov.w	r3, #32
 1017d74:	f3ef 8211 	mrs	r2, BASEPRI
 1017d78:	f383 8811 	msr	BASEPRI, r3
 1017d7c:	f3bf 8f6f 	isb	sy
 1017d80:	3914      	subs	r1, #20
 1017d82:	e7d9      	b.n	1017d38 <clear_event_registrations+0xa>

01017d84 <signal_poll_event>:
{
 1017d84:	b570      	push	{r4, r5, r6, lr}
	struct _poller *poller = event->poller;
 1017d86:	6884      	ldr	r4, [r0, #8]
{
 1017d88:	4605      	mov	r5, r0
 1017d8a:	460e      	mov	r6, r1
	if (poller) {
 1017d8c:	b19c      	cbz	r4, 1017db6 <signal_poll_event+0x32>
		if (poller->cb != NULL) {
 1017d8e:	68a3      	ldr	r3, [r4, #8]
 1017d90:	b95b      	cbnz	r3, 1017daa <signal_poll_event+0x26>
	int retcode = 0;
 1017d92:	4618      	mov	r0, r3
		poller->is_polling = false;
 1017d94:	7023      	strb	r3, [r4, #0]
	event->poller = NULL;
 1017d96:	2300      	movs	r3, #0
 1017d98:	60ab      	str	r3, [r5, #8]
	event->state |= state;
 1017d9a:	68eb      	ldr	r3, [r5, #12]
 1017d9c:	f3c3 3104 	ubfx	r1, r3, #12, #5
 1017da0:	430e      	orrs	r6, r1
 1017da2:	f366 3310 	bfi	r3, r6, #12, #5
 1017da6:	60eb      	str	r3, [r5, #12]
	return retcode;
 1017da8:	e004      	b.n	1017db4 <signal_poll_event+0x30>
			retcode = poller->cb(event, state);
 1017daa:	4798      	blx	r3
		poller->is_polling = false;
 1017dac:	2300      	movs	r3, #0
		if (retcode < 0) {
 1017dae:	2800      	cmp	r0, #0
		poller->is_polling = false;
 1017db0:	7023      	strb	r3, [r4, #0]
		if (retcode < 0) {
 1017db2:	daf0      	bge.n	1017d96 <signal_poll_event+0x12>
}
 1017db4:	bd70      	pop	{r4, r5, r6, pc}
	int retcode = 0;
 1017db6:	4620      	mov	r0, r4
 1017db8:	e7ed      	b.n	1017d96 <signal_poll_event+0x12>

01017dba <k_poll_poller_cb>:
{
 1017dba:	b538      	push	{r3, r4, r5, lr}
	struct k_thread *thread = event->poller->thread;
 1017dbc:	6883      	ldr	r3, [r0, #8]
{
 1017dbe:	460d      	mov	r5, r1
	struct k_thread *thread = event->poller->thread;
 1017dc0:	685c      	ldr	r4, [r3, #4]
	if (!z_is_thread_pending(thread)) {
 1017dc2:	7b63      	ldrb	r3, [r4, #13]
 1017dc4:	079a      	lsls	r2, r3, #30
 1017dc6:	d50e      	bpl.n	1017de6 <k_poll_poller_cb+0x2c>
	if (z_is_thread_timeout_expired(thread)) {
 1017dc8:	6a23      	ldr	r3, [r4, #32]
 1017dca:	3302      	adds	r3, #2
 1017dcc:	d014      	beq.n	1017df8 <k_poll_poller_cb+0x3e>
	z_unpend_thread(thread);
 1017dce:	4620      	mov	r0, r4
 1017dd0:	f7ff fda0 	bl	1017914 <z_unpend_thread>
	arch_thread_return_value_set(thread,
 1017dd4:	2d08      	cmp	r5, #8
 1017dd6:	bf0c      	ite	eq
 1017dd8:	f06f 0303 	mvneq.w	r3, #3
 1017ddc:	2300      	movne	r3, #0
 1017dde:	6723      	str	r3, [r4, #112]	; 0x70
	return !((z_is_thread_prevented_from_running(thread)) != 0 ||
 1017de0:	7b63      	ldrb	r3, [r4, #13]
 1017de2:	06db      	lsls	r3, r3, #27
 1017de4:	d001      	beq.n	1017dea <k_poll_poller_cb+0x30>
		return 0;
 1017de6:	2000      	movs	r0, #0
}
 1017de8:	bd38      	pop	{r3, r4, r5, pc}
	if (!z_is_thread_ready(thread)) {
 1017dea:	69a5      	ldr	r5, [r4, #24]
 1017dec:	2d00      	cmp	r5, #0
 1017dee:	d1fa      	bne.n	1017de6 <k_poll_poller_cb+0x2c>
	z_ready_thread(thread);
 1017df0:	4620      	mov	r0, r4
 1017df2:	f7ff fdb6 	bl	1017962 <z_ready_thread>
	return 0;
 1017df6:	e7f6      	b.n	1017de6 <k_poll_poller_cb+0x2c>
		return -EAGAIN;
 1017df8:	f06f 000a 	mvn.w	r0, #10
 1017dfc:	e7f4      	b.n	1017de8 <k_poll_poller_cb+0x2e>

01017dfe <add_event>:
{
 1017dfe:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1017e00:	4617      	mov	r7, r2
	return sys_dlist_is_empty(list) ? NULL : list->tail;
 1017e02:	e9d0 2300 	ldrd	r2, r3, [r0]
 1017e06:	4290      	cmp	r0, r2
 1017e08:	4604      	mov	r4, r0
 1017e0a:	460d      	mov	r5, r1
 1017e0c:	d106      	bne.n	1017e1c <add_event+0x1e>
	node->prev = list->tail;
 1017e0e:	6863      	ldr	r3, [r4, #4]
	node->next = list;
 1017e10:	602c      	str	r4, [r5, #0]
	node->prev = list->tail;
 1017e12:	606b      	str	r3, [r5, #4]
	list->tail->next = node;
 1017e14:	6863      	ldr	r3, [r4, #4]
 1017e16:	601d      	str	r5, [r3, #0]
	list->tail = node;
 1017e18:	6065      	str	r5, [r4, #4]
}
 1017e1a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	if ((pending == NULL) ||
 1017e1c:	2b00      	cmp	r3, #0
 1017e1e:	d0f6      	beq.n	1017e0e <add_event+0x10>
		z_is_t1_higher_prio_than_t2(pending->poller->thread,
 1017e20:	689b      	ldr	r3, [r3, #8]
 1017e22:	6879      	ldr	r1, [r7, #4]
 1017e24:	6858      	ldr	r0, [r3, #4]
 1017e26:	f7ff fd22 	bl	101786e <z_is_t1_higher_prio_than_t2>
	if ((pending == NULL) ||
 1017e2a:	2800      	cmp	r0, #0
 1017e2c:	d1ef      	bne.n	1017e0e <add_event+0x10>
	return list->head == list;
 1017e2e:	6826      	ldr	r6, [r4, #0]
	return sys_dlist_is_empty(list) ? NULL : list->head;
 1017e30:	42b4      	cmp	r4, r6
 1017e32:	d0ec      	beq.n	1017e0e <add_event+0x10>
 1017e34:	2e00      	cmp	r6, #0
 1017e36:	bf38      	it	cc
 1017e38:	2600      	movcc	r6, #0
	SYS_DLIST_FOR_EACH_CONTAINER(events, pending, _node) {
 1017e3a:	2e00      	cmp	r6, #0
 1017e3c:	d0e7      	beq.n	1017e0e <add_event+0x10>
		if (z_is_t1_higher_prio_than_t2(poller->thread,
 1017e3e:	68b3      	ldr	r3, [r6, #8]
 1017e40:	6878      	ldr	r0, [r7, #4]
 1017e42:	6859      	ldr	r1, [r3, #4]
 1017e44:	f7ff fd13 	bl	101786e <z_is_t1_higher_prio_than_t2>
 1017e48:	b128      	cbz	r0, 1017e56 <add_event+0x58>
	node->prev = successor->prev;
 1017e4a:	6873      	ldr	r3, [r6, #4]
	node->next = successor;
 1017e4c:	e9c5 6300 	strd	r6, r3, [r5]
	successor->prev->next = node;
 1017e50:	601d      	str	r5, [r3, #0]
	successor->prev = node;
 1017e52:	6075      	str	r5, [r6, #4]
			return;
 1017e54:	e7e1      	b.n	1017e1a <add_event+0x1c>
	return (node == list->tail) ? NULL : node->next;
 1017e56:	6863      	ldr	r3, [r4, #4]
 1017e58:	42b3      	cmp	r3, r6
 1017e5a:	d0d8      	beq.n	1017e0e <add_event+0x10>
 1017e5c:	6836      	ldr	r6, [r6, #0]
 1017e5e:	e7ec      	b.n	1017e3a <add_event+0x3c>

01017e60 <register_events>:
{
 1017e60:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
	for (int ii = 0; ii < num_events; ii++) {
 1017e64:	f04f 0a00 	mov.w	sl, #0
{
 1017e68:	460e      	mov	r6, r1
 1017e6a:	4614      	mov	r4, r2
 1017e6c:	461f      	mov	r7, r3
 1017e6e:	4683      	mov	fp, r0
	int events_registered = 0;
 1017e70:	4655      	mov	r5, sl
	event->poller = NULL;
 1017e72:	46d0      	mov	r8, sl
	for (int ii = 0; ii < num_events; ii++) {
 1017e74:	45b2      	cmp	sl, r6
 1017e76:	db02      	blt.n	1017e7e <register_events+0x1e>
}
 1017e78:	4628      	mov	r0, r5
 1017e7a:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 1017e7e:	f04f 0320 	mov.w	r3, #32
 1017e82:	f3ef 8911 	mrs	r9, BASEPRI
 1017e86:	f383 8811 	msr	BASEPRI, r3
 1017e8a:	f3bf 8f6f 	isb	sy
	switch (event->type) {
 1017e8e:	f89b 200d 	ldrb.w	r2, [fp, #13]
 1017e92:	f002 020f 	and.w	r2, r2, #15
 1017e96:	2a02      	cmp	r2, #2
 1017e98:	d006      	beq.n	1017ea8 <register_events+0x48>
 1017e9a:	2a04      	cmp	r2, #4
 1017e9c:	d008      	beq.n	1017eb0 <register_events+0x50>
 1017e9e:	2a01      	cmp	r2, #1
 1017ea0:	d120      	bne.n	1017ee4 <register_events+0x84>
		if (event->signal->signaled != 0U) {
 1017ea2:	f8db 3010 	ldr.w	r3, [fp, #16]
 1017ea6:	e001      	b.n	1017eac <register_events+0x4c>
		if (k_sem_count_get(event->sem) > 0) {
 1017ea8:	f8db 3010 	ldr.w	r3, [fp, #16]
		if (event->signal->signaled != 0U) {
 1017eac:	689b      	ldr	r3, [r3, #8]
 1017eae:	e002      	b.n	1017eb6 <register_events+0x56>
		if (!k_queue_is_empty(event->queue)) {
 1017eb0:	f8db 3010 	ldr.w	r3, [fp, #16]
 1017eb4:	681b      	ldr	r3, [r3, #0]
		if (event->signal->signaled != 0U) {
 1017eb6:	b1ab      	cbz	r3, 1017ee4 <register_events+0x84>
	event->state |= state;
 1017eb8:	f8db 300c 	ldr.w	r3, [fp, #12]
	event->poller = NULL;
 1017ebc:	f8cb 8008 	str.w	r8, [fp, #8]
	event->state |= state;
 1017ec0:	f3c3 3104 	ubfx	r1, r3, #12, #5
 1017ec4:	430a      	orrs	r2, r1
 1017ec6:	f362 3310 	bfi	r3, r2, #12, #5
 1017eca:	f8cb 300c 	str.w	r3, [fp, #12]
			poller->is_polling = false;
 1017ece:	f884 8000 	strb.w	r8, [r4]
	__asm__ volatile(
 1017ed2:	f389 8811 	msr	BASEPRI, r9
 1017ed6:	f3bf 8f6f 	isb	sy
	for (int ii = 0; ii < num_events; ii++) {
 1017eda:	f10a 0a01 	add.w	sl, sl, #1
 1017ede:	f10b 0b14 	add.w	fp, fp, #20
 1017ee2:	e7c7      	b.n	1017e74 <register_events+0x14>
		} else if (!just_check && poller->is_polling) {
 1017ee4:	2f00      	cmp	r7, #0
 1017ee6:	d1f4      	bne.n	1017ed2 <register_events+0x72>
 1017ee8:	7823      	ldrb	r3, [r4, #0]
 1017eea:	2b00      	cmp	r3, #0
 1017eec:	d0f1      	beq.n	1017ed2 <register_events+0x72>
	switch (event->type) {
 1017eee:	f89b 300d 	ldrb.w	r3, [fp, #13]
 1017ef2:	f003 030f 	and.w	r3, r3, #15
 1017ef6:	2b02      	cmp	r3, #2
 1017ef8:	d008      	beq.n	1017f0c <register_events+0xac>
 1017efa:	2b04      	cmp	r3, #4
 1017efc:	d006      	beq.n	1017f0c <register_events+0xac>
 1017efe:	2b01      	cmp	r3, #1
 1017f00:	d10b      	bne.n	1017f1a <register_events+0xba>
		add_event(&event->signal->poll_events, event, poller);
 1017f02:	4622      	mov	r2, r4
 1017f04:	4659      	mov	r1, fp
 1017f06:	f8db 0010 	ldr.w	r0, [fp, #16]
 1017f0a:	e004      	b.n	1017f16 <register_events+0xb6>
		add_event(&event->queue->poll_events, event, poller);
 1017f0c:	4622      	mov	r2, r4
 1017f0e:	4659      	mov	r1, fp
 1017f10:	f8db 0010 	ldr.w	r0, [fp, #16]
 1017f14:	3010      	adds	r0, #16
		add_event(&event->signal->poll_events, event, poller);
 1017f16:	f7ff ff72 	bl	1017dfe <add_event>
	event->poller = poller;
 1017f1a:	f8cb 4008 	str.w	r4, [fp, #8]
				events_registered += 1;
 1017f1e:	3501      	adds	r5, #1
 1017f20:	e7d7      	b.n	1017ed2 <register_events+0x72>

01017f22 <z_handle_obj_poll_events>:
{
 1017f22:	4603      	mov	r3, r0
	return list->head == list;
 1017f24:	6800      	ldr	r0, [r0, #0]
	if (!sys_dlist_is_empty(list)) {
 1017f26:	4283      	cmp	r3, r0
 1017f28:	d008      	beq.n	1017f3c <z_handle_obj_poll_events+0x1a>
	node->prev->next = node->next;
 1017f2a:	e9d0 3200 	ldrd	r3, r2, [r0]
 1017f2e:	6013      	str	r3, [r2, #0]
	node->next->prev = node->prev;
 1017f30:	605a      	str	r2, [r3, #4]
	node->next = NULL;
 1017f32:	2300      	movs	r3, #0
	node->prev = NULL;
 1017f34:	e9c0 3300 	strd	r3, r3, [r0]
		(void) signal_poll_event(poll_event, state);
 1017f38:	f7ff bf24 	b.w	1017d84 <signal_poll_event>
}
 1017f3c:	4770      	bx	lr

01017f3e <_OffsetAbsSyms>:
#include "offsets_aarch64.c"
#else
#include "offsets_aarch32.c"
#endif

GEN_ABS_SYM_END
 1017f3e:	4770      	bx	lr
